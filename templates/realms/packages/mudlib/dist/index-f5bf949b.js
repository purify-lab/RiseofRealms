var KN = Object.defineProperty;
var XN = (ne, oe, ae) => oe in ne ? KN(ne, oe, { enumerable: !0, configurable: !0, writable: !0, value: ae }) : ne[oe] = ae;
var Na = (ne, oe, ae) => (XN(ne, typeof oe != "symbol" ? oe + "" : oe, ae), ae);
function createClientComponents({ components: ne }) {
  return {
    ...ne
    // add your client components or overrides here
  };
}
function createSystemCalls({
  tables: ne,
  worldContract: oe,
  waitForTransaction: ae,
  tokenAContract: fe,
  tokenBContract: ye,
  tokenCContract: ve
}) {
  return {
    spawnPlayer: async () => {
      const Ot = await oe.write.spawnPlayer([]);
      await ae(Ot);
    },
    marchArmy: async (Ot, Qe, at, wt, bt, At) => {
      const Ft = await oe.write.march([Ot, Qe, at, wt, bt, At]);
      await ae(Ft);
    },
    attack: async (Ot) => {
      const Qe = await oe.write.attack([Ot]);
      await ae(Qe);
    },
    garrison: async (Ot, Qe, at, wt, bt) => {
      const At = await oe.write.garrison([Ot, Qe, at, wt, bt]);
      await ae(At);
    },
    buyInfantry: async (Ot) => {
      console.log("worldContract", oe);
      const Qe = await oe.write.buyInfantry([Ot]);
      await ae(Qe);
    },
    buyCavalryA: async (Ot) => {
      const Qe = await oe.write.buyCavalryA([Ot]);
      await ae(Qe);
    },
    buyCavalryB: async (Ot) => {
      const Qe = await oe.write.buyCavalryB([Ot]);
      await ae(Qe);
    },
    buyCavalryC: async (Ot) => {
      const Qe = await oe.write.buyCavalryC([Ot]);
      await ae(Qe);
    },
    spawnCapital: async (Ot) => {
      const Qe = await oe.write.spawnCapital([Ot], {
        value: 5e14
        //ethers.utils.parseEther("0.5"),
      });
      await ae(Qe);
    },
    stakeTokenB: async (Ot) => {
      const Qe = await oe.write.stakeTokenB([Ot]);
      await ae(Qe);
    },
    stakeTokenC: async (Ot) => {
      const Qe = await oe.write.stakeTokenC([Ot]);
      await ae(Qe);
    },
    unStakeTokenB: async (Ot, Qe) => {
      const at = await oe.write.unStakeTokenB([Ot, Qe]);
      await ae(at);
    },
    unStakeTokenC: async (Ot, Qe) => {
      const at = await oe.write.unStakeTokenC([Ot, Qe]);
      await ae(at);
    },
    farming: async (Ot) => {
      const Qe = await oe.write.farming([Ot]);
      await ae(Qe);
    },
    setMerkleRoot: async (Ot) => {
      const Qe = await oe.write.setMerkleRoot([Ot]);
      await ae(Qe);
    },
    claim: async (Ot, Qe) => {
      const at = await oe.write.claim([Ot, Qe]);
      await ae(at);
    },
    swapA2B: async (Ot) => {
      const Qe = await oe.write.swapA2B([Ot]);
      await ae(Qe);
    },
    swapA2C: async (Ot) => {
      const Qe = await oe.write.swapA2C([Ot]);
      await ae(Qe);
    },
    withdrawToken: async (Ot, Qe) => {
      const at = await oe.write.withdrawToken([Ot, Qe]);
      await ae(at);
    },
    transactionTokenA: async (Ot, Qe) => {
      const at = await fe.write.transfer([Ot, Qe]);
      await ae(at);
    },
    transactionTokenB: async (Ot, Qe) => {
      const at = await ye.write.transfer([Ot, Qe]);
      await ae(at);
    },
    transactionTokenC: async (Ot, Qe) => {
      const at = await ve.write.transfer([Ot, Qe]);
      await ae(at);
    },
    approveTokenA: async (Ot, Qe, at) => {
      const wt = await fe.write.approve([Ot, Qe, at]);
      await ae(wt);
    }
  };
}
const version$5 = "1.0.0";
let BaseError$2 = class GE extends Error {
  constructor(oe, ae = {}) {
    var _e;
    const fe = ae.cause instanceof GE ? ae.cause.details : (_e = ae.cause) != null && _e.message ? ae.cause.message : ae.details, ye = ae.cause instanceof GE && ae.cause.docsPath || ae.docsPath, ve = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [`Docs: https://abitype.dev${ye}`] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: abitype@${version$5}`
    ].join(`
`);
    super(ve), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
};
function execTyped(ne, oe) {
  const ae = ne.exec(oe);
  return ae == null ? void 0 : ae.groups;
}
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex$1 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, isTupleRegex = /^\(.+?\).*?$/, tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(ne) {
  let oe = ne.type;
  if (tupleRegex.test(ne.type) && "components" in ne) {
    oe = "(";
    const ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      const ve = ne.components[ye];
      oe += formatAbiParameter(ve), ye < ae - 1 && (oe += ", ");
    }
    const fe = execTyped(tupleRegex, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, formatAbiParameter({
      ...ne,
      type: oe
    });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
function formatAbiParameters(ne) {
  let oe = "";
  const ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    const ye = ne[fe];
    oe += formatAbiParameter(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
function formatAbiItem$1(ne) {
  return ne.type === "function" ? `function ${ne.name}(${formatAbiParameters(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${formatAbiParameters(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "constructor" ? `constructor(${formatAbiParameters(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(ne) {
  return errorSignatureRegex.test(ne);
}
function execErrorSignature(ne) {
  return execTyped(errorSignatureRegex, ne);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(ne) {
  return eventSignatureRegex.test(ne);
}
function execEventSignature(ne) {
  return execTyped(eventSignatureRegex, ne);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(ne) {
  return functionSignatureRegex.test(ne);
}
function execFunctionSignature(ne) {
  return execTyped(functionSignatureRegex, ne);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(ne) {
  return structSignatureRegex.test(ne);
}
function execStructSignature(ne) {
  return execTyped(structSignatureRegex, ne);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(ne) {
  return constructorSignatureRegex.test(ne);
}
function execConstructorSignature(ne) {
  return execTyped(constructorSignatureRegex, ne);
}
const fallbackSignatureRegex = /^fallback\(\)$/;
function isFallbackSignature(ne) {
  return fallbackSignatureRegex.test(ne);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(ne) {
  return receiveSignatureRegex.test(ne);
}
const modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]), eventModifiers = /* @__PURE__ */ new Set(["indexed"]), functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class UnknownTypeError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${oe}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [`Type "${oe}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidAbiParametersError extends BaseError$2 {
  constructor({ params: oe }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(oe, null, 2)})`,
      docsPath: "/api/human#parseabiparameters-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiParametersError"
    });
  }
}
class InvalidParameterError extends BaseError$2 {
  constructor({ param: oe }) {
    super("Invalid ABI parameter.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError$2 {
  constructor({ param: oe, name: ae }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `"${ae}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError$2 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError$2 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${fe}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError$2 {
  constructor({ abiParameter: oe }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(oe, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError$2 {
  constructor({ signature: oe, type: ae }) {
    super(`Invalid ${ae} signature.`, {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError$2 {
  constructor({ signature: oe }) {
    super("Unknown signature.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError$2 {
  constructor({ signature: oe }) {
    super("Invalid struct signature.", {
      details: oe,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${oe}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError$2 {
  constructor({ current: oe, depth: ae }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${oe.trim()}" has too many ${ae > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${ae}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(ne, oe) {
  return oe ? `${oe}:${ne}` : ne;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function parseSignature(ne, oe = {}) {
  if (isFunctionSignature(ne)) {
    const ae = execFunctionSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "function" });
    const fe = splitParameters(ae.parameters), ye = [], ve = fe.length;
    for (let xe = 0; xe < ve; xe++)
      ye.push(parseAbiParameter(fe[xe], {
        modifiers: functionModifiers,
        structs: oe,
        type: "function"
      }));
    const _e = [];
    if (ae.returns) {
      const xe = splitParameters(ae.returns), Oe = xe.length;
      for (let $e = 0; $e < Oe; $e++)
        _e.push(parseAbiParameter(xe[$e], {
          modifiers: functionModifiers,
          structs: oe,
          type: "function"
        }));
    }
    return {
      name: ae.name,
      type: "function",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye,
      outputs: _e
    };
  }
  if (isEventSignature(ne)) {
    const ae = execEventSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "event" });
    const fe = splitParameters(ae.parameters), ye = [], ve = fe.length;
    for (let _e = 0; _e < ve; _e++)
      ye.push(parseAbiParameter(fe[_e], {
        modifiers: eventModifiers,
        structs: oe,
        type: "event"
      }));
    return { name: ae.name, type: "event", inputs: ye };
  }
  if (isErrorSignature(ne)) {
    const ae = execErrorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "error" });
    const fe = splitParameters(ae.parameters), ye = [], ve = fe.length;
    for (let _e = 0; _e < ve; _e++)
      ye.push(parseAbiParameter(fe[_e], { structs: oe, type: "error" }));
    return { name: ae.name, type: "error", inputs: ye };
  }
  if (isConstructorSignature(ne)) {
    const ae = execConstructorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "constructor" });
    const fe = splitParameters(ae.parameters), ye = [], ve = fe.length;
    for (let _e = 0; _e < ve; _e++)
      ye.push(parseAbiParameter(fe[_e], { structs: oe, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye
    };
  }
  if (isFallbackSignature(ne))
    return { type: "fallback" };
  if (isReceiveSignature(ne))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: ne });
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(ne, oe) {
  var Re, je;
  const ae = getParameterCacheKey(ne, oe == null ? void 0 : oe.type);
  if (parameterCache.has(ae))
    return parameterCache.get(ae);
  const fe = isTupleRegex.test(ne), ye = execTyped(fe ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, ne);
  if (!ye)
    throw new InvalidParameterError({ param: ne });
  if (ye.name && isSolidityKeyword(ye.name))
    throw new SolidityProtectedKeywordError({ param: ne, name: ye.name });
  const ve = ye.name ? { name: ye.name } : {}, _e = ye.modifier === "indexed" ? { indexed: !0 } : {}, xe = (oe == null ? void 0 : oe.structs) ?? {};
  let Oe, $e = {};
  if (fe) {
    Oe = "tuple";
    const Be = splitParameters(ye.type), ze = [], He = Be.length;
    for (let qe = 0; qe < He; qe++)
      ze.push(parseAbiParameter(Be[qe], { structs: xe }));
    $e = { components: ze };
  } else if (ye.type in xe)
    Oe = "tuple", $e = { components: xe[ye.type] };
  else if (dynamicIntegerRegex.test(ye.type))
    Oe = `${ye.type}256`;
  else if (Oe = ye.type, (oe == null ? void 0 : oe.type) !== "struct" && !isSolidityType(Oe))
    throw new UnknownSolidityTypeError({ type: Oe });
  if (ye.modifier) {
    if (!((je = (Re = oe == null ? void 0 : oe.modifiers) == null ? void 0 : Re.has) != null && je.call(Re, ye.modifier)))
      throw new InvalidModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
    if (functionModifiers.has(ye.modifier) && !isValidDataLocation(Oe, !!ye.array))
      throw new InvalidFunctionModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
  }
  const Me = {
    type: `${Oe}${ye.array ?? ""}`,
    ...ve,
    ..._e,
    ...$e
  };
  return parameterCache.set(ae, Me), Me;
}
function splitParameters(ne, oe = [], ae = "", fe = 0) {
  const ye = ne.trim().length;
  for (let ve = 0; ve < ye; ve++) {
    const _e = ne[ve], xe = ne.slice(ve + 1);
    switch (_e) {
      case ",":
        return fe === 0 ? splitParameters(xe, [...oe, ae.trim()]) : splitParameters(xe, oe, `${ae}${_e}`, fe);
      case "(":
        return splitParameters(xe, oe, `${ae}${_e}`, fe + 1);
      case ")":
        return splitParameters(xe, oe, `${ae}${_e}`, fe - 1);
      default:
        return splitParameters(xe, oe, `${ae}${_e}`, fe);
    }
  }
  if (ae === "")
    return oe;
  if (fe !== 0)
    throw new InvalidParenthesisError({ current: ae, depth: fe });
  return oe.push(ae.trim()), oe;
}
function isSolidityType(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || bytesRegex$1.test(ne) || integerRegex$1.test(ne);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || ne === "tuple" || bytesRegex$1.test(ne) || integerRegex$1.test(ne) || protectedKeywordsRegex.test(ne);
}
function isValidDataLocation(ne, oe) {
  return oe || ne === "bytes" || ne === "string" || ne === "tuple";
}
function parseStructs(ne) {
  const oe = {}, ae = ne.length;
  for (let _e = 0; _e < ae; _e++) {
    const xe = ne[_e];
    if (!isStructSignature(xe))
      continue;
    const Oe = execStructSignature(xe);
    if (!Oe)
      throw new InvalidSignatureError({ signature: xe, type: "struct" });
    const $e = Oe.properties.split(";"), Me = [], Re = $e.length;
    for (let je = 0; je < Re; je++) {
      const ze = $e[je].trim();
      if (!ze)
        continue;
      const He = parseAbiParameter(ze, {
        type: "struct"
      });
      Me.push(He);
    }
    if (!Me.length)
      throw new InvalidStructSignatureError({ signature: xe });
    oe[Oe.name] = Me;
  }
  const fe = {}, ye = Object.entries(oe), ve = ye.length;
  for (let _e = 0; _e < ve; _e++) {
    const [xe, Oe] = ye[_e];
    fe[xe] = resolveStructs(Oe, oe);
  }
  return fe;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(ne, oe, ae = /* @__PURE__ */ new Set()) {
  const fe = [], ye = ne.length;
  for (let ve = 0; ve < ye; ve++) {
    const _e = ne[ve];
    if (isTupleRegex.test(_e.type))
      fe.push(_e);
    else {
      const Oe = execTyped(typeWithoutTupleRegex, _e.type);
      if (!(Oe != null && Oe.type))
        throw new InvalidAbiTypeParameterError({ abiParameter: _e });
      const { array: $e, type: Me } = Oe;
      if (Me in oe) {
        if (ae.has(Me))
          throw new CircularReferenceError({ type: Me });
        fe.push({
          ..._e,
          type: `tuple${$e ?? ""}`,
          components: resolveStructs(oe[Me] ?? [], oe, /* @__PURE__ */ new Set([...ae, Me]))
        });
      } else if (isSolidityType(Me))
        fe.push(_e);
      else
        throw new UnknownTypeError({ type: Me });
    }
  }
  return fe;
}
function parseAbi(ne) {
  const oe = parseStructs(ne), ae = [], fe = ne.length;
  for (let ye = 0; ye < fe; ye++) {
    const ve = ne[ye];
    isStructSignature(ve) || ae.push(parseSignature(ve, oe));
  }
  return ae;
}
function parseAbiParameters(ne) {
  const oe = [];
  if (typeof ne == "string") {
    const ae = splitParameters(ne), fe = ae.length;
    for (let ye = 0; ye < fe; ye++)
      oe.push(parseAbiParameter(ae[ye], { modifiers }));
  } else {
    const ae = parseStructs(ne), fe = ne.length;
    for (let ye = 0; ye < fe; ye++) {
      const ve = ne[ye];
      if (isStructSignature(ve))
        continue;
      const _e = splitParameters(ve), xe = _e.length;
      for (let Oe = 0; Oe < xe; Oe++)
        oe.push(parseAbiParameter(_e[Oe], { modifiers, structs: ae }));
    }
  }
  if (oe.length === 0)
    throw new InvalidAbiParametersError({ params: ne });
  return oe;
}
function getAction(ne, oe, ae) {
  return (fe) => {
    var ye, ve;
    return ((ye = ne[oe.name]) == null ? void 0 : ye.call(ne, fe)) ?? ((ve = ne[ae]) == null ? void 0 : ve.call(ne, fe)) ?? oe(ne, fe);
  };
}
function formatAbiItem(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new InvalidDefinitionTypeError(ne.type);
  return `${ne.name}(${formatAbiParams(ne.inputs, { includeName: oe })})`;
}
function formatAbiParams(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => formatAbiParam(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function formatAbiParam(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${formatAbiParams(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
function isHex$1(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
function size$2(ne) {
  return isHex$1(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
const version$4 = "2.9.20", getContractAddress = (ne) => ne, getUrl$1 = (ne) => ne, getVersion$1 = () => `viem@${version$4}`;
let BaseError$1 = class YE extends Error {
  constructor(oe, ae = {}) {
    var ve;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion$1()
    });
    const fe = ae.cause instanceof YE ? ae.cause.details : (ve = ae.cause) != null && ve.message ? ae.cause.message : ae.details, ye = ae.cause instanceof YE && ae.cause.docsPath || ae.docsPath;
    this.message = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [
        `Docs: https://viem.sh${ye}${ae.docsSlug ? `#${ae.docsSlug}` : ""}`
      ] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
  walk(oe) {
    return walk$1(this, oe);
  }
};
function walk$1(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? walk$1(ne.cause, oe) : oe ? null : ne;
}
class AbiConstructorNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$1 {
  constructor({ data: oe, params: ae, size: fe }) {
    super([`Data size of ${fe} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(ae, { includeName: !0 })})`,
        `Data:   ${oe} (${fe} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe, this.params = ae, this.size = fe;
  }
}
class AbiDecodingZeroDataError extends BaseError$1 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: oe, givenLength: ae, type: fe }) {
    super([
      `ABI encoding array length mismatch for type ${fe}.`,
      `Expected length: ${oe}`,
      `Given length: ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: oe, value: ae }) {
    super(`Size of bytes "${ae}" (bytes${size$2(ae)}) does not match expected size (bytes${oe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: oe, givenLength: ae }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${oe}`,
      `Given length (values): ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded error signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = oe;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded event signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Event ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Function ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Function "${oe}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$1 {
  constructor(oe, ae) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${oe.type}\` in \`${formatAbiItem(oe.abiItem)}\`, and`,
        `\`${ae.type}\` in \`${formatAbiItem(ae.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: oe, givenSize: ae }) {
    super(`Expected bytes${oe}, got bytes${ae}.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$1 {
  constructor({ abiItem: oe, data: ae, params: fe, size: ye }) {
    super([
      `Data size of ${ye} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(fe, { includeName: !0 })})`,
        `Data:   ${ae} (${ye} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe, this.data = ae, this.params = fe, this.size = ye;
  }
}
class DecodeLogTopicsMismatch extends BaseError$1 {
  constructor({ abiItem: oe, param: ae }) {
    super([
      `Expected a topic for indexed event parameter${ae.name ? ` "${ae.name}"` : ""} on event "${formatAbiItem(oe, { includeName: !0 })}".`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogTopicsMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError$1 {
  constructor(oe) {
    super([`Value "${oe}" is not a valid array.`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$1 {
  constructor(oe) {
    super([
      `"${oe}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidDefinitionTypeError"
    });
  }
}
class UnsupportedPackedAbiType extends BaseError$1 {
  constructor(oe) {
    super(`Type "${oe}" is not supported for packed encoding.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedPackedAbiType"
    });
  }
}
class FilterTypeNotSupportedError extends BaseError$1 {
  constructor(oe) {
    super(`Filter type "${oe}" is not supported.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FilterTypeNotSupportedError"
    });
  }
}
class SliceOffsetOutOfBoundsError extends BaseError$1 {
  constructor({ offset: oe, position: ae, size: fe }) {
    super(`Slice ${ae === "start" ? "starting" : "ending"} at offset "${oe}" is out-of-bounds (size: ${fe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
let SizeExceedsPaddingSizeError$1 = class extends BaseError$1 {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} size (${oe}) exceeds padding size (${ae}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
};
class InvalidBytesLengthError extends BaseError$1 {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} is expected to be ${ae} ${fe} long, but is ${oe} ${fe} long.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesLengthError"
    });
  }
}
function pad$1(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? padHex$1(ne, { dir: oe, size: ae }) : padBytes$1(ne, { dir: oe, size: ae });
}
function padHex$1(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  const fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new SizeExceedsPaddingSizeError$1({
      size: Math.ceil(fe.length / 2),
      targetSize: ae,
      type: "hex"
    });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function padBytes$1(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new SizeExceedsPaddingSizeError$1({
      size: ne.length,
      targetSize: ae,
      type: "bytes"
    });
  const fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    const ve = oe === "right";
    fe[ve ? ye : ae - ye - 1] = ne[ve ? ye : ne.length - ye - 1];
  }
  return fe;
}
class IntegerOutOfRangeError extends BaseError$1 {
  constructor({ max: oe, min: ae, signed: fe, size: ye, value: ve }) {
    super(`Number "${ve}" is not in safe ${ye ? `${ye * 8}-bit ${fe ? "signed" : "unsigned"} ` : ""}integer range ${oe ? `(${ae} to ${oe})` : `(above ${ae})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    });
  }
}
class InvalidBytesBooleanError extends BaseError$1 {
  constructor(oe) {
    super(`Bytes value "${oe}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError$1 {
  constructor(oe) {
    super(`Hex value "${oe}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidHexBooleanError"
    });
  }
}
let SizeOverflowError$1 = class extends BaseError$1 {
  constructor({ givenSize: oe, maxSize: ae }) {
    super(`Size cannot exceed ${ae} bytes. Given size: ${oe} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
};
function trim(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
function assertSize$1(ne, { size: oe }) {
  if (size$2(ne) > oe)
    throw new SizeOverflowError$1({
      givenSize: size$2(ne),
      maxSize: oe
    });
}
function hexToBigInt(ne, oe = {}) {
  const { signed: ae } = oe;
  oe.size && assertSize$1(ne, { size: oe.size });
  const fe = BigInt(ne);
  if (!ae)
    return fe;
  const ye = (ne.length - 2) / 2, ve = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= ve ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function hexToBool(ne, oe = {}) {
  let ae = ne;
  if (oe.size && (assertSize$1(ae, { size: oe.size }), ae = trim(ae)), trim(ae) === "0x00")
    return !1;
  if (trim(ae) === "0x01")
    return !0;
  throw new InvalidHexBooleanError(ae);
}
function hexToNumber$1(ne, oe = {}) {
  return Number(hexToBigInt(ne, oe));
}
function hexToString(ne, oe = {}) {
  let ae = hexToBytes$1(ne);
  return oe.size && (assertSize$1(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function toHex$1(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToHex(ne, oe) : typeof ne == "string" ? stringToHex$1(ne, oe) : typeof ne == "boolean" ? boolToHex(ne, oe) : bytesToHex$2(ne, oe);
}
function boolToHex(ne, oe = {}) {
  const ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { size: oe.size })) : ae;
}
function bytesToHex$2(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += hexes$2[ne[ye]];
  const fe = `0x${ae}`;
  return typeof oe.size == "number" ? (assertSize$1(fe, { size: oe.size }), pad$1(fe, { dir: "right", size: oe.size })) : fe;
}
function numberToHex(ne, oe = {}) {
  const { signed: ae, size: fe } = oe, ye = BigInt(ne);
  let ve;
  fe ? ae ? ve = (1n << BigInt(fe) * 8n - 1n) - 1n : ve = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (ve = BigInt(Number.MAX_SAFE_INTEGER));
  const _e = typeof ve == "bigint" && ae ? -ve - 1n : 0;
  if (ve && ye > ve || ye < _e) {
    const Oe = typeof ne == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: ve ? `${ve}${Oe}` : void 0,
      min: `${_e}${Oe}`,
      signed: ae,
      size: fe,
      value: `${ne}${Oe}`
    });
  }
  const xe = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? pad$1(xe, { size: fe }) : xe;
}
const encoder$2 = /* @__PURE__ */ new TextEncoder();
function stringToHex$1(ne, oe = {}) {
  const ae = encoder$2.encode(ne);
  return bytesToHex$2(ae, oe);
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$1(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToBytes(ne, oe) : typeof ne == "boolean" ? boolToBytes(ne, oe) : isHex$1(ne) ? hexToBytes$1(ne, oe) : stringToBytes(ne, oe);
}
function boolToBytes(ne, oe = {}) {
  const ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { size: oe.size })) : ae;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(ne) {
  if (ne >= charCodeMap.zero && ne <= charCodeMap.nine)
    return ne - charCodeMap.zero;
  if (ne >= charCodeMap.A && ne <= charCodeMap.F)
    return ne - (charCodeMap.A - 10);
  if (ne >= charCodeMap.a && ne <= charCodeMap.f)
    return ne - (charCodeMap.a - 10);
}
function hexToBytes$1(ne, oe = {}) {
  let ae = ne;
  oe.size && (assertSize$1(ae, { size: oe.size }), ae = pad$1(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  const ye = fe.length / 2, ve = new Uint8Array(ye);
  for (let _e = 0, xe = 0; _e < ye; _e++) {
    const Oe = charCodeToBase16(fe.charCodeAt(xe++)), $e = charCodeToBase16(fe.charCodeAt(xe++));
    if (Oe === void 0 || $e === void 0)
      throw new BaseError$1(`Invalid byte sequence ("${fe[xe - 2]}${fe[xe - 1]}" in "${fe}").`);
    ve[_e] = Oe * 16 + $e;
  }
  return ve;
}
function numberToBytes(ne, oe) {
  const ae = numberToHex(ne, oe);
  return hexToBytes$1(ae);
}
function stringToBytes(ne, oe = {}) {
  const ae = encoder$1.encode(ne);
  return typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { dir: "right", size: oe.size })) : ae;
}
function number(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function bytes(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function hash$1(ne) {
  if (typeof ne != "function" || typeof ne.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(ne.outputLen), number(ne.blockLen);
}
function exists(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(ne, oe) {
  bytes(ne);
  const ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(ne, oe = !1) {
  return oe ? { h: Number(ne & U32_MASK64), l: Number(ne >> _32n & U32_MASK64) } : { h: Number(ne >> _32n & U32_MASK64) | 0, l: Number(ne & U32_MASK64) | 0 };
}
function split(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    const { h: ve, l: _e } = fromBig(ne[ye], oe);
    [ae[ye], fe[ye]] = [ve, _e];
  }
  return [ae, fe];
}
const rotlSH = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, rotlSL = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, rotlBH = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, rotlBL = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae, crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (ne) => ne instanceof Uint8Array, u32 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), createView = (ne) => new DataView(ne.buffer, ne.byteOffset, ne.byteLength), rotr = (ne, oe) => ne << 32 - oe | ne >>> oe, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function toBytes(ne) {
  if (typeof ne == "string" && (ne = utf8ToBytes$1(ne)), !u8a$1(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function concatBytes$2(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a$1(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(ne) {
  const oe = (fe) => ne().update(toBytes(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function randomBytes(ne = 32) {
  if (crypto && typeof crypto.getRandomValues == "function")
    return crypto.getRandomValues(new Uint8Array(ne));
  throw new Error("crypto.getRandomValues must be defined");
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$4 = /* @__PURE__ */ BigInt(0), _1n$5 = /* @__PURE__ */ BigInt(1), _2n$3 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let ne = 0, oe = _1n$5, ae = 1, fe = 0; ne < 24; ne++) {
  [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], SHA3_PI.push(2 * (5 * fe + ae)), SHA3_ROTL.push((ne + 1) * (ne + 2) / 2 % 64);
  let ye = _0n$4;
  for (let ve = 0; ve < 7; ve++)
    oe = (oe << _1n$5 ^ (oe >> _7n) * _0x71n) % _256n, oe & _2n$3 && (ye ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(ve)) - _1n$5);
  _SHA3_IOTA.push(ye);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, !0), rotlH = (ne, oe, ae) => ae > 32 ? rotlBH(ne, oe, ae) : rotlSH(ne, oe, ae), rotlL = (ne, oe, ae) => ae > 32 ? rotlBL(ne, oe, ae) : rotlSL(ne, oe, ae);
function keccakP(ne, oe = 24) {
  const ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let _e = 0; _e < 10; _e++)
      ae[_e] = ne[_e] ^ ne[_e + 10] ^ ne[_e + 20] ^ ne[_e + 30] ^ ne[_e + 40];
    for (let _e = 0; _e < 10; _e += 2) {
      const xe = (_e + 8) % 10, Oe = (_e + 2) % 10, $e = ae[Oe], Me = ae[Oe + 1], Re = rotlH($e, Me, 1) ^ ae[xe], je = rotlL($e, Me, 1) ^ ae[xe + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[_e + Be] ^= Re, ne[_e + Be + 1] ^= je;
    }
    let ye = ne[2], ve = ne[3];
    for (let _e = 0; _e < 24; _e++) {
      const xe = SHA3_ROTL[_e], Oe = rotlH(ye, ve, xe), $e = rotlL(ye, ve, xe), Me = SHA3_PI[_e];
      ye = ne[Me], ve = ne[Me + 1], ne[Me] = Oe, ne[Me + 1] = $e;
    }
    for (let _e = 0; _e < 50; _e += 10) {
      for (let xe = 0; xe < 10; xe++)
        ae[xe] = ne[_e + xe];
      for (let xe = 0; xe < 10; xe++)
        ne[_e + xe] ^= ~ae[(xe + 2) % 10] & ae[(xe + 4) % 10];
    }
    ne[0] ^= SHA3_IOTA_H[fe], ne[1] ^= SHA3_IOTA_L[fe];
  }
  ae.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(oe, ae, fe, ye = !1, ve = 24) {
    if (super(), this.blockLen = oe, this.suffix = ae, this.outputLen = fe, this.enableXOF = ye, this.rounds = ve, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number(fe), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(oe) {
    exists(this);
    const { blockLen: ae, state: fe } = this;
    oe = toBytes(oe);
    const ye = oe.length;
    for (let ve = 0; ve < ye; ) {
      const _e = Math.min(ae - this.pos, ye - ve);
      for (let xe = 0; xe < _e; xe++)
        fe[this.pos++] ^= oe[ve++];
      this.pos === ae && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: oe, suffix: ae, pos: fe, blockLen: ye } = this;
    oe[fe] ^= ae, ae & 128 && fe === ye - 1 && this.keccak(), oe[ye - 1] ^= 128, this.keccak();
  }
  writeInto(oe) {
    exists(this, !1), bytes(oe), this.finish();
    const ae = this.state, { blockLen: fe } = this;
    for (let ye = 0, ve = oe.length; ye < ve; ) {
      this.posOut >= fe && this.keccak();
      const _e = Math.min(fe - this.posOut, ve - ye);
      oe.set(ae.subarray(this.posOut, this.posOut + _e), ye), this.posOut += _e, ye += _e;
    }
    return oe;
  }
  xofInto(oe) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(oe);
  }
  xof(oe) {
    return number(oe), this.xofInto(new Uint8Array(oe));
  }
  digestInto(oe) {
    if (output(oe, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(oe), this.destroy(), oe;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(oe) {
    const { blockLen: ae, suffix: fe, outputLen: ye, rounds: ve, enableXOF: _e } = this;
    return oe || (oe = new Keccak(ae, fe, ye, _e, ve)), oe.state32.set(this.state32), oe.pos = this.pos, oe.posOut = this.posOut, oe.finished = this.finished, oe.rounds = ve, oe.suffix = fe, oe.outputLen = ye, oe.enableXOF = _e, oe.destroyed = this.destroyed, oe;
  }
}
const gen = (ne, oe, ae) => wrapConstructor(() => new Keccak(oe, ne, ae)), keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256(ne, oe) {
  const ae = oe || "hex", fe = keccak_256(isHex$1(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex$1(fe);
}
const hash = (ne) => keccak256(toBytes$1(ne));
function hashSignature(ne) {
  return hash(ne);
}
function normalizeSignature(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", ve = !1;
  for (let _e = 0; _e < ne.length; _e++) {
    const xe = ne[_e];
    if (["(", ")", ","].includes(xe) && (oe = !0), xe === "(" && fe++, xe === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (xe === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += xe, xe === ")") {
          ve = !0;
          break;
        }
        continue;
      }
      if (xe === " ") {
        ne[_e - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += xe, ae += xe;
    }
  }
  if (!ve)
    throw new BaseError$1("Unable to normalize signature.");
  return ye;
}
const toSignature = (ne) => {
  const oe = (() => typeof ne == "string" ? ne : formatAbiItem$1(ne))();
  return normalizeSignature(oe);
};
function toSignatureHash(ne) {
  return hashSignature(toSignature(ne));
}
const toEventSelector = toSignatureHash;
class InvalidAddressError extends BaseError$1 {
  constructor({ address: oe }) {
    super(`Address "${oe}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(oe) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = oe;
  }
  set(oe, ae) {
    return super.set(oe, ae), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
}
function checksumAddress(ne, oe) {
  const ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = keccak256(stringToBytes(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let ve = 0; ve < 40; ve += 2)
    fe[ve >> 1] >> 4 >= 8 && ye[ve] && (ye[ve] = ye[ve].toUpperCase()), (fe[ve >> 1] & 15) >= 8 && ye[ve + 1] && (ye[ve + 1] = ye[ve + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
function getAddress(ne, oe) {
  if (!isAddress(ne, { strict: !1 }))
    throw new InvalidAddressError({ address: ne });
  return checksumAddress(ne, oe);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/, isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(ne, oe) {
  const { strict: ae = !0 } = oe ?? {};
  if (isAddressCache.has(ne))
    return isAddressCache.get(ne);
  const fe = (() => addressRegex.test(ne) ? ne.toLowerCase() === ne ? !0 : ae ? checksumAddress(ne) === ne : !0 : !1)();
  return isAddressCache.set(ne, fe), fe;
}
function concat$1(ne) {
  return typeof ne[0] == "string" ? concatHex$1(ne) : concatBytes$1(ne);
}
function concatBytes$1(ne) {
  let oe = 0;
  for (const ye of ne)
    oe += ye.length;
  const ae = new Uint8Array(oe);
  let fe = 0;
  for (const ye of ne)
    ae.set(ye, fe), fe += ye.length;
  return ae;
}
function concatHex$1(ne) {
  return `0x${ne.reduce((oe, ae) => oe + ae.replace("0x", ""), "")}`;
}
function slice(ne, oe, ae, { strict: fe } = {}) {
  return isHex$1(ne, { strict: !1 }) ? sliceHex(ne, oe, ae, {
    strict: fe
  }) : sliceBytes(ne, oe, ae, {
    strict: fe
  });
}
function assertStartOffset(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > size$2(ne) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: oe,
      position: "start",
      size: size$2(ne)
    });
}
function assertEndOffset(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && size$2(ne) !== ae - oe)
    throw new SliceOffsetOutOfBoundsError({
      offset: ae,
      position: "end",
      size: size$2(ne)
    });
}
function sliceBytes(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = ne.slice(oe, ae);
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function sliceHex(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function encodeAbiParameters(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = prepareParams({
    params: ne,
    values: oe
  }), fe = encodeParams(ae);
  return fe.length === 0 ? "0x" : fe;
}
function prepareParams({ params: ne, values: oe }) {
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++)
    ae.push(prepareParam({ param: ne[fe], value: oe[fe] }));
  return ae;
}
function prepareParam({ param: ne, value: oe }) {
  const ae = getArrayComponents(ne.type);
  if (ae) {
    const [fe, ye] = ae;
    return encodeArray(oe, { length: fe, param: { ...ne, type: ye } });
  }
  if (ne.type === "tuple")
    return encodeTuple(oe, {
      param: ne
    });
  if (ne.type === "address")
    return encodeAddress(oe);
  if (ne.type === "bool")
    return encodeBool(oe);
  if (ne.type.startsWith("uint") || ne.type.startsWith("int")) {
    const fe = ne.type.startsWith("int");
    return encodeNumber(oe, { signed: fe });
  }
  if (ne.type.startsWith("bytes"))
    return encodeBytes(oe, { param: ne });
  if (ne.type === "string")
    return encodeString(oe);
  throw new InvalidAbiEncodingTypeError(ne.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(ne) {
  let oe = 0;
  for (let ve = 0; ve < ne.length; ve++) {
    const { dynamic: _e, encoded: xe } = ne[ve];
    _e ? oe += 32 : oe += size$2(xe);
  }
  const ae = [], fe = [];
  let ye = 0;
  for (let ve = 0; ve < ne.length; ve++) {
    const { dynamic: _e, encoded: xe } = ne[ve];
    _e ? (ae.push(numberToHex(oe + ye, { size: 32 })), fe.push(xe), ye += size$2(xe)) : ae.push(xe);
  }
  return concat$1([...ae, ...fe]);
}
function encodeAddress(ne) {
  if (!isAddress(ne))
    throw new InvalidAddressError({ address: ne });
  return { dynamic: !1, encoded: padHex$1(ne.toLowerCase()) };
}
function encodeArray(ne, { length: oe, param: ae }) {
  const fe = oe === null;
  if (!Array.isArray(ne))
    throw new InvalidArrayError(ne);
  if (!fe && ne.length !== oe)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: oe,
      givenLength: ne.length,
      type: `${ae.type}[${oe}]`
    });
  let ye = !1;
  const ve = [];
  for (let _e = 0; _e < ne.length; _e++) {
    const xe = prepareParam({ param: ae, value: ne[_e] });
    xe.dynamic && (ye = !0), ve.push(xe);
  }
  if (fe || ye) {
    const _e = encodeParams(ve);
    if (fe) {
      const xe = numberToHex(ve.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: ve.length > 0 ? concat$1([xe, _e]) : xe
      };
    }
    if (ye)
      return { dynamic: !0, encoded: _e };
  }
  return {
    dynamic: !1,
    encoded: concat$1(ve.map(({ encoded: _e }) => _e))
  };
}
function encodeBytes(ne, { param: oe }) {
  const [, ae] = oe.type.split("bytes"), fe = size$2(ne);
  if (!ae) {
    let ye = ne;
    return fe % 32 !== 0 && (ye = padHex$1(ye, {
      dir: "right",
      size: Math.ceil((ne.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: concat$1([padHex$1(numberToHex(fe, { size: 32 })), ye])
    };
  }
  if (fe !== parseInt(ae))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(ae),
      value: ne
    });
  return { dynamic: !1, encoded: padHex$1(ne, { dir: "right" }) };
}
function encodeBool(ne) {
  if (typeof ne != "boolean")
    throw new BaseError$1(`Invalid boolean value: "${ne}" (type: ${typeof ne}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: padHex$1(boolToHex(ne)) };
}
function encodeNumber(ne, { signed: oe }) {
  return {
    dynamic: !1,
    encoded: numberToHex(ne, {
      size: 32,
      signed: oe
    })
  };
}
function encodeString(ne) {
  const oe = stringToHex$1(ne), ae = Math.ceil(size$2(oe) / 32), fe = [];
  for (let ye = 0; ye < ae; ye++)
    fe.push(padHex$1(slice(oe, ye * 32, (ye + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: concat$1([
      padHex$1(numberToHex(size$2(oe), { size: 32 })),
      ...fe
    ])
  };
}
function encodeTuple(ne, { param: oe }) {
  let ae = !1;
  const fe = [];
  for (let ye = 0; ye < oe.components.length; ye++) {
    const ve = oe.components[ye], _e = Array.isArray(ne) ? ye : ve.name, xe = prepareParam({
      param: ve,
      value: ne[_e]
    });
    fe.push(xe), xe.dynamic && (ae = !0);
  }
  return {
    dynamic: ae,
    encoded: ae ? encodeParams(fe) : concat$1(fe.map(({ encoded: ye }) => ye))
  };
}
function getArrayComponents(ne) {
  const oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? (
    // Return `null` if the array is dynamic.
    [oe[2] ? Number(oe[2]) : null, oe[1]]
  ) : void 0;
}
const toFunctionSelector = (ne) => slice(toSignatureHash(ne), 0, 4);
function getAbiItem(ne) {
  const { abi: oe, args: ae = [], name: fe } = ne, ye = isHex$1(fe, { strict: !1 }), ve = oe.filter((xe) => ye ? xe.type === "function" ? toFunctionSelector(xe) === fe : xe.type === "event" ? toEventSelector(xe) === fe : !1 : "name" in xe && xe.name === fe);
  if (ve.length === 0)
    return;
  if (ve.length === 1)
    return ve[0];
  let _e;
  for (const xe of ve) {
    if (!("inputs" in xe))
      continue;
    if (!ae || ae.length === 0) {
      if (!xe.inputs || xe.inputs.length === 0)
        return xe;
      continue;
    }
    if (!xe.inputs || xe.inputs.length === 0 || xe.inputs.length !== ae.length)
      continue;
    if (ae.every(($e, Me) => {
      const Re = "inputs" in xe && xe.inputs[Me];
      return Re ? isArgOfType($e, Re) : !1;
    })) {
      if (_e && "inputs" in _e && _e.inputs) {
        const $e = getAmbiguousTypes(xe.inputs, _e.inputs, ae);
        if ($e)
          throw new AbiItemAmbiguityError({
            abiItem: xe,
            type: $e[0]
          }, {
            abiItem: _e,
            type: $e[1]
          });
      }
      _e = xe;
    }
  }
  return _e || ve[0];
}
function isArgOfType(ne, oe) {
  const ae = typeof ne, fe = oe.type;
  switch (fe) {
    case "address":
      return isAddress(ne, { strict: !1 });
    case "bool":
      return ae === "boolean";
    case "function":
      return ae === "string";
    case "string":
      return ae === "string";
    default:
      return fe === "tuple" && "components" in oe ? Object.values(oe.components).every((ye, ve) => isArgOfType(Object.values(ne)[ve], ye)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(fe) ? ae === "number" || ae === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(fe) ? ae === "string" || ne instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(fe) ? Array.isArray(ne) && ne.every((ye) => isArgOfType(ye, {
        ...oe,
        // Pop off `[]` or `[M]` from end of type
        type: fe.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function getAmbiguousTypes(ne, oe, ae) {
  for (const fe in ne) {
    const ye = ne[fe], ve = oe[fe];
    if (ye.type === "tuple" && ve.type === "tuple" && "components" in ye && "components" in ve)
      return getAmbiguousTypes(ye.components, ve.components, ae[fe]);
    const _e = [ye.type, ve.type];
    if ((() => _e.includes("address") && _e.includes("bytes20") ? !0 : _e.includes("address") && _e.includes("string") ? isAddress(ae[fe], { strict: !1 }) : _e.includes("address") && _e.includes("bytes") ? isAddress(ae[fe], { strict: !1 }) : !1)())
      return _e;
  }
}
const docsPath$4 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(ne) {
  var Oe;
  const { abi: oe, eventName: ae, args: fe } = ne;
  let ye = oe[0];
  if (ae) {
    const $e = getAbiItem({ abi: oe, name: ae });
    if (!$e)
      throw new AbiEventNotFoundError(ae, { docsPath: docsPath$4 });
    ye = $e;
  }
  if (ye.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$4 });
  const ve = formatAbiItem(ye), _e = toEventSelector(ve);
  let xe = [];
  if (fe && "inputs" in ye) {
    const $e = (Oe = ye.inputs) == null ? void 0 : Oe.filter((Re) => "indexed" in Re && Re.indexed), Me = Array.isArray(fe) ? fe : Object.values(fe).length > 0 ? ($e == null ? void 0 : $e.map((Re) => fe[Re.name])) ?? [] : [];
    Me.length > 0 && (xe = ($e == null ? void 0 : $e.map((Re, je) => Array.isArray(Me[je]) ? Me[je].map((Be, ze) => encodeArg({ param: Re, value: Me[je][ze] })) : Me[je] ? encodeArg({ param: Re, value: Me[je] }) : null)) ?? []);
  }
  return [_e, ...xe];
}
function encodeArg({ param: ne, value: oe }) {
  if (ne.type === "string" || ne.type === "bytes")
    return keccak256(toBytes$1(oe));
  if (ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(ne.type);
  return encodeAbiParameters([ne], [oe]);
}
function createFilterRequestScope(ne, { method: oe }) {
  var fe, ye;
  const ae = {};
  return ne.transport.type === "fallback" && ((ye = (fe = ne.transport).onResponse) == null || ye.call(fe, ({ method: ve, response: _e, status: xe, transport: Oe }) => {
    xe === "success" && oe === ve && (ae[_e] = Oe.request);
  })), (ve) => ae[ve] || ne.request;
}
async function createContractEventFilter(ne, oe) {
  const { address: ae, abi: fe, args: ye, eventName: ve, fromBlock: _e, strict: xe, toBlock: Oe } = oe, $e = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  }), Me = ve ? encodeEventTopics({
    abi: fe,
    args: ye,
    eventName: ve
  }) : void 0, Re = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: ae,
        fromBlock: typeof _e == "bigint" ? numberToHex(_e) : _e,
        toBlock: typeof Oe == "bigint" ? numberToHex(Oe) : Oe,
        topics: Me
      }
    ]
  });
  return {
    abi: fe,
    args: ye,
    eventName: ve,
    id: Re,
    request: $e(Re),
    strict: !!xe,
    type: "event"
  };
}
function parseAccount(ne) {
  return typeof ne == "string" ? { address: ne, type: "json-rpc" } : ne;
}
const docsPath$3 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(ne) {
  const { abi: oe, args: ae, functionName: fe } = ne;
  let ye = oe[0];
  if (fe) {
    const ve = getAbiItem({
      abi: oe,
      args: ae,
      name: fe
    });
    if (!ve)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$3 });
    ye = ve;
  }
  if (ye.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  return {
    abi: [ye],
    functionName: toFunctionSelector(formatAbiItem(ye))
  };
}
function encodeFunctionData(ne) {
  const { args: oe } = ne, { abi: ae, functionName: fe } = (() => {
    var xe;
    return ne.abi.length === 1 && ((xe = ne.functionName) != null && xe.startsWith("0x")) ? ne : prepareEncodeFunctionData(ne);
  })(), ye = ae[0], ve = fe, _e = "inputs" in ye && ye.inputs ? encodeAbiParameters(ye.inputs, oe ?? []) : void 0;
  return concatHex$1([ve, _e ?? "0x"]);
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class NegativeOffsetError extends BaseError$1 {
  constructor({ offset: oe }) {
    super(`Offset \`${oe}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$1 {
  constructor({ length: oe, position: ae }) {
    super(`Position \`${ae}\` is out of bounds (\`0 < position < ${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError$1 {
  constructor({ count: oe, limit: ae }) {
    super(`Recursive read limit of \`${ae}\` exceeded (recursive read count: \`${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: 1 / 0,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: ne
      });
  },
  decrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  },
  getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  },
  incrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  },
  inspectByte(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectBytes(ne, oe) {
    const ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  },
  inspectUint8(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectUint16(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  },
  inspectUint24(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  },
  inspectUint32(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  },
  pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  },
  pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  },
  pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  },
  pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectByte();
    return this.position++, ne;
  },
  readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    const ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint8();
    return this.position += 1, ne;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint16();
    return this.position += 2, ne;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint24();
    return this.position += 3, ne;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint32();
    return this.position += 4, ne;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(ne) {
    const oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  },
  _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    const ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  }
};
function createCursor(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  const ae = Object.create(staticCursor);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
function bytesToBigInt(ne, oe = {}) {
  typeof oe.size < "u" && assertSize$1(ne, { size: oe.size });
  const ae = bytesToHex$2(ne, oe);
  return hexToBigInt(ae, oe);
}
function bytesToBool(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (assertSize$1(ae, { size: oe.size }), ae = trim(ae)), ae.length > 1 || ae[0] > 1)
    throw new InvalidBytesBooleanError(ae);
  return !!ae[0];
}
function bytesToNumber(ne, oe = {}) {
  typeof oe.size < "u" && assertSize$1(ne, { size: oe.size });
  const ae = bytesToHex$2(ne, oe);
  return hexToNumber$1(ae, oe);
}
function bytesToString(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (assertSize$1(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
function decodeAbiParameters(ne, oe) {
  const ae = typeof oe == "string" ? hexToBytes$1(oe) : oe, fe = createCursor(ae);
  if (size$2(ae) === 0 && ne.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$2(oe) && size$2(oe) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof oe == "string" ? oe : bytesToHex$2(oe),
      params: ne,
      size: size$2(oe)
    });
  let ye = 0;
  const ve = [];
  for (let _e = 0; _e < ne.length; ++_e) {
    const xe = ne[_e];
    fe.setPosition(ye);
    const [Oe, $e] = decodeParameter(fe, xe, {
      staticPosition: 0
    });
    ye += $e, ve.push(Oe);
  }
  return ve;
}
function decodeParameter(ne, oe, { staticPosition: ae }) {
  const fe = getArrayComponents(oe.type);
  if (fe) {
    const [ye, ve] = fe;
    return decodeArray(ne, { ...oe, type: ve }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return decodeTuple(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return decodeAddress(ne);
  if (oe.type === "bool")
    return decodeBool(ne);
  if (oe.type.startsWith("bytes"))
    return decodeBytes(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return decodeNumber(ne, oe);
  if (oe.type === "string")
    return decodeString(ne, { staticPosition: ae });
  throw new InvalidAbiDecodingTypeError(oe.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32, sizeOfOffset = 32;
function decodeAddress(ne) {
  const oe = ne.readBytes(32);
  return [checksumAddress(bytesToHex$2(sliceBytes(oe, -20))), 32];
}
function decodeArray(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = fe + _e, Oe = xe + sizeOfLength;
    ne.setPosition(xe);
    const $e = bytesToNumber(ne.readBytes(sizeOfLength)), Me = hasDynamicChild(oe);
    let Re = 0;
    const je = [];
    for (let Be = 0; Be < $e; ++Be) {
      ne.setPosition(Oe + (Me ? Be * 32 : Re));
      const [ze, He] = decodeParameter(ne, oe, {
        staticPosition: Oe
      });
      Re += He, je.push(ze);
    }
    return ne.setPosition(fe + 32), [je, 32];
  }
  if (hasDynamicChild(oe)) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = fe + _e, Oe = [];
    for (let $e = 0; $e < ae; ++$e) {
      ne.setPosition(xe + $e * 32);
      const [Me] = decodeParameter(ne, oe, {
        staticPosition: xe
      });
      Oe.push(Me);
    }
    return ne.setPosition(fe + 32), [Oe, 32];
  }
  let ye = 0;
  const ve = [];
  for (let _e = 0; _e < ae; ++_e) {
    const [xe, Oe] = decodeParameter(ne, oe, {
      staticPosition: fe + ye
    });
    ye += Oe, ve.push(xe);
  }
  return [ve, ye];
}
function decodeBool(ne) {
  return [bytesToBool(ne.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(ne, oe, { staticPosition: ae }) {
  const [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    const _e = bytesToNumber(ne.readBytes(32));
    ne.setPosition(ae + _e);
    const xe = bytesToNumber(ne.readBytes(32));
    if (xe === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    const Oe = ne.readBytes(xe);
    return ne.setPosition(ae + 32), [bytesToHex$2(Oe), 32];
  }
  return [bytesToHex$2(ne.readBytes(parseInt(ye), 32)), 32];
}
function decodeNumber(ne, oe) {
  const ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [
    fe > 48 ? bytesToBigInt(ye, { signed: ae }) : bytesToNumber(ye, { signed: ae }),
    32
  ];
}
function decodeTuple(ne, oe, { staticPosition: ae }) {
  const fe = oe.components.length === 0 || oe.components.some(({ name: _e }) => !_e), ye = fe ? [] : {};
  let ve = 0;
  if (hasDynamicChild(oe)) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = ae + _e;
    for (let Oe = 0; Oe < oe.components.length; ++Oe) {
      const $e = oe.components[Oe];
      ne.setPosition(xe + ve);
      const [Me, Re] = decodeParameter(ne, $e, {
        staticPosition: xe
      });
      ve += Re, ye[fe ? Oe : $e == null ? void 0 : $e.name] = Me;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let _e = 0; _e < oe.components.length; ++_e) {
    const xe = oe.components[_e], [Oe, $e] = decodeParameter(ne, xe, {
      staticPosition: ae
    });
    ye[fe ? _e : xe == null ? void 0 : xe.name] = Oe, ve += $e;
  }
  return [ye, ve];
}
function decodeString(ne, { staticPosition: oe }) {
  const ae = bytesToNumber(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  const ye = bytesToNumber(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  const ve = ne.readBytes(ye, 32), _e = bytesToString(trim(ve));
  return ne.setPosition(oe + 32), [_e, 32];
}
function hasDynamicChild(ne) {
  var fe;
  const { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(hasDynamicChild);
  const ae = getArrayComponents(ne.type);
  return !!(ae && hasDynamicChild({ ...ne, type: ae[1] }));
}
function decodeErrorResult(ne) {
  const { abi: oe, data: ae } = ne, fe = slice(ae, 0, 4);
  if (fe === "0x")
    throw new AbiDecodingZeroDataError();
  const ve = [...oe || [], solidityError, solidityPanic].find((_e) => _e.type === "error" && fe === toFunctionSelector(formatAbiItem(_e)));
  if (!ve)
    throw new AbiErrorSignatureNotFoundError(fe, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: ve,
    args: "inputs" in ve && ve.inputs && ve.inputs.length > 0 ? decodeAbiParameters(ve.inputs, slice(ae, 4)) : void 0,
    errorName: ve.name
  };
}
const stringify = (ne, oe, ae) => JSON.stringify(ne, (fe, ye) => {
  const ve = typeof ye == "bigint" ? ye.toString() : ye;
  return typeof oe == "function" ? oe(fe, ve) : ve;
}, ae);
function formatAbiItemWithArgs({ abiItem: ne, args: oe, includeFunctionName: ae = !0, includeName: fe = !1 }) {
  if ("name" in ne && "inputs" in ne && ne.inputs)
    return `${ae ? ne.name : ""}(${ne.inputs.map((ye, ve) => `${fe && ye.name ? `${ye.name}: ` : ""}${typeof oe[ve] == "object" ? stringify(oe[ve]) : oe[ve]}`).join(", ")})`;
}
const etherUnits = {
  gwei: 9,
  wei: 18
}, gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits$1(ne, oe) {
  let ae = ne.toString();
  const fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, ve] = [
    ae.slice(0, ae.length - oe),
    ae.slice(ae.length - oe)
  ];
  return ve = ve.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${ve ? `.${ve}` : ""}`;
}
function formatEther(ne, oe = "wei") {
  return formatUnits$1(ne, etherUnits[oe]);
}
function formatGwei(ne, oe = "wei") {
  return formatUnits$1(ne, gweiUnits[oe]);
}
class AccountStateConflictError extends BaseError$1 {
  constructor({ address: oe }) {
    super(`State for account "${oe}" is set multiple times.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$1 {
  constructor() {
    super("state and stateDiff are set on the same account."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(ne) {
  return ne.reduce((oe, { slot: ae, value: fe }) => `${oe}        ${ae}: ${fe}
`, "");
}
function prettyStateOverride(ne) {
  return ne.reduce((oe, { address: ae, ...fe }) => {
    let ye = `${oe}    ${ae}:
`;
    return fe.nonce && (ye += `      nonce: ${fe.nonce}
`), fe.balance && (ye += `      balance: ${fe.balance}
`), fe.code && (ye += `      code: ${fe.code}
`), fe.state && (ye += `      state:
`, ye += prettyStateMapping(fe.state)), fe.stateDiff && (ye += `      stateDiff:
`, ye += prettyStateMapping(fe.stateDiff)), ye;
  }, `  State Override:
`).slice(0, -1);
}
function prettyPrint(ne) {
  const oe = Object.entries(ne).map(([fe, ye]) => ye === void 0 || ye === !1 ? null : [fe, ye]).filter(Boolean), ae = oe.reduce((fe, [ye]) => Math.max(fe, ye.length), 0);
  return oe.map(([fe, ye]) => `  ${`${fe}:`.padEnd(ae + 1)}  ${ye}`).join(`
`);
}
class FeeConflictError extends BaseError$1 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeConflictError"
    });
  }
}
class InvalidLegacyVError extends BaseError$1 {
  constructor({ v: oe }) {
    super(`Invalid \`v\` value "${oe}". Expected 27 or 28.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidLegacyVError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError$1 {
  constructor({ transaction: oe }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(oe),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class InvalidStorageKeySizeError extends BaseError$1 {
  constructor({ storageKey: oe }) {
    super(`Size for storage key "${oe}" is invalid. Expected 32 bytes. Got ${Math.floor((oe.length - 2) / 2)} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStorageKeySizeError"
    });
  }
}
class TransactionExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ve, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Me, to: Re, value: je }) {
    var ze;
    const Be = prettyPrint({
      chain: ye && `${ye == null ? void 0 : ye.name} (id: ${ye == null ? void 0 : ye.id})`,
      from: ae == null ? void 0 : ae.address,
      to: Re,
      value: typeof je < "u" && `${formatEther(je)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: ve,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Me
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Request Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionExecutionError"
    }), this.cause = oe;
  }
}
class TransactionNotFoundError extends BaseError$1 {
  constructor({ blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: ve }) {
    let _e = "Transaction";
    fe && ve !== void 0 && (_e = `Transaction at block time "${fe}" at index "${ve}"`), oe && ve !== void 0 && (_e = `Transaction at block hash "${oe}" at index "${ve}"`), ae && ve !== void 0 && (_e = `Transaction at block number "${ae}" at index "${ve}"`), ye && (_e = `Transaction with hash "${ye}"`), super(`${_e} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$1 {
  constructor({ hash: oe }) {
    super(`Transaction receipt with hash "${oe}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$1 {
  constructor({ hash: oe }) {
    super(`Timed out while waiting for transaction with hash "${oe}" to be confirmed.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
class CallExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ve, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Me, to: Re, value: je, stateOverride: Be }) {
    var qe;
    const ze = ae ? parseAccount(ae) : void 0;
    let He = prettyPrint({
      from: ze == null ? void 0 : ze.address,
      to: Re,
      value: typeof je < "u" && `${formatEther(je)} ${((qe = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : qe.symbol) || "ETH"}`,
      data: ve,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Me
    });
    Be && (He += `
${prettyStateOverride(Be)}`), super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Raw Call Arguments:",
        He
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CallExecutionError"
    }), this.cause = oe;
  }
}
class ContractFunctionExecutionError extends BaseError$1 {
  constructor(oe, { abi: ae, args: fe, contractAddress: ye, docsPath: ve, functionName: _e, sender: xe }) {
    const Oe = getAbiItem({ abi: ae, args: fe, name: _e }), $e = Oe ? formatAbiItemWithArgs({
      abiItem: Oe,
      args: fe,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, Me = Oe ? formatAbiItem(Oe, { includeName: !0 }) : void 0, Re = prettyPrint({
      address: ye && getContractAddress(ye),
      function: Me,
      args: $e && $e !== "()" && `${[...Array((_e == null ? void 0 : _e.length) ?? 0).keys()].map(() => " ").join("")}${$e}`,
      sender: xe
    });
    super(oe.shortMessage || `An unknown error occurred while executing the contract function "${_e}".`, {
      cause: oe,
      docsPath: ve,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Contract Call:",
        Re
      ].filter(Boolean)
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionExecutionError"
    }), this.abi = ae, this.args = fe, this.cause = oe, this.contractAddress = ye, this.functionName = _e, this.sender = xe;
  }
}
class ContractFunctionRevertedError extends BaseError$1 {
  constructor({ abi: oe, data: ae, functionName: fe, message: ye }) {
    let ve, _e, xe, Oe;
    if (ae && ae !== "0x")
      try {
        _e = decodeErrorResult({ abi: oe, data: ae });
        const { abiItem: Me, errorName: Re, args: je } = _e;
        if (Re === "Error")
          Oe = je[0];
        else if (Re === "Panic") {
          const [Be] = je;
          Oe = panicReasons[Be];
        } else {
          const Be = Me ? formatAbiItem(Me, { includeName: !0 }) : void 0, ze = Me && je ? formatAbiItemWithArgs({
            abiItem: Me,
            args: je,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          xe = [
            Be ? `Error: ${Be}` : "",
            ze && ze !== "()" ? `       ${[...Array((Re == null ? void 0 : Re.length) ?? 0).keys()].map(() => " ").join("")}${ze}` : ""
          ];
        }
      } catch (Me) {
        ve = Me;
      }
    else
      ye && (Oe = ye);
    let $e;
    ve instanceof AbiErrorSignatureNotFoundError && ($e = ve.signature, xe = [
      `Unable to decode signature "${$e}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${$e}.`
    ]), super(Oe && Oe !== "execution reverted" || $e ? [
      `The contract function "${fe}" reverted with the following ${$e ? "signature" : "reason"}:`,
      Oe || $e
    ].join(`
`) : `The contract function "${fe}" reverted.`, {
      cause: ve,
      metaMessages: xe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = _e, this.reason = Oe, this.signature = $e;
  }
}
class ContractFunctionZeroDataError extends BaseError$1 {
  constructor({ functionName: oe }) {
    super(`The contract function "${oe}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${oe}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class RawContractError extends BaseError$1 {
  constructor({ data: oe, message: ae }) {
    super(ae || ""), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RawContractError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe;
  }
}
class HttpRequestError extends BaseError$1 {
  constructor({ body: oe, details: ae, headers: fe, status: ye, url: ve }) {
    super("HTTP request failed.", {
      details: ae,
      metaMessages: [
        ye && `Status: ${ye}`,
        `URL: ${getUrl$1(ve)}`,
        oe && `Request body: ${stringify(oe)}`
      ].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = oe, this.headers = fe, this.status = ye, this.url = ve;
  }
}
class WebSocketRequestError extends BaseError$1 {
  constructor({ body: oe, details: ae, url: fe }) {
    super("WebSocket request failed.", {
      details: ae,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WebSocketRequestError"
    });
  }
}
class RpcRequestError extends BaseError$1 {
  constructor({ body: oe, error: ae, url: fe }) {
    super("RPC Request failed.", {
      cause: ae,
      details: ae.message,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = ae.code;
  }
}
let TimeoutError$1 = class extends BaseError$1 {
  constructor({ body: oe, url: ae }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl$1(ae)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TimeoutError"
    });
  }
};
const unknownErrorCode = -1;
class RpcError extends BaseError$1 {
  constructor(oe, { code: ae, docsPath: fe, metaMessages: ye, shortMessage: ve }) {
    super(ve, {
      cause: oe,
      docsPath: fe,
      metaMessages: ye || (oe == null ? void 0 : oe.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = oe.name, this.code = oe instanceof RpcRequestError ? oe.code : ae ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(oe, ae) {
    super(oe, ae), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = ae.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    });
  }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(ne, { abi: oe, address: ae, args: fe, docsPath: ye, functionName: ve, sender: _e }) {
  const { code: xe, data: Oe, message: $e, shortMessage: Me } = ne instanceof RawContractError ? ne : ne instanceof BaseError$1 ? ne.walk((je) => "data" in je) || ne.walk() : {}, Re = (() => ne instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({ functionName: ve }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(xe) && (Oe || $e || Me) ? new ContractFunctionRevertedError({
    abi: oe,
    data: typeof Oe == "object" ? Oe.data : Oe,
    functionName: ve,
    message: Me ?? $e
  }) : ne)();
  return new ContractFunctionExecutionError(Re, {
    abi: oe,
    args: fe,
    contractAddress: ae,
    docsPath: ye,
    functionName: ve,
    sender: _e
  });
}
class EstimateGasExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ve, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Me, to: Re, value: je }) {
    var ze;
    const Be = prettyPrint({
      from: ae == null ? void 0 : ae.address,
      to: Re,
      value: typeof je < "u" && `${formatEther(je)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: ve,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Me
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EstimateGasExecutionError"
    }), this.cause = oe;
  }
}
class ExecutionRevertedError extends BaseError$1 {
  constructor({ cause: oe, message: ae } = {}) {
    var ye;
    const fe = (ye = ae == null ? void 0 : ae.replace("execution reverted: ", "")) == null ? void 0 : ye.replace("execution reverted", "");
    super(`Execution reverted ${fe ? `with reason: ${fe}` : "for an unknown reason"}.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$1 {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$1 {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is higher than the next one expected.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super([
      `Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}exceeds the maximum allowed nonce.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$1 {
  constructor({ cause: oe } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: oe,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError$1 {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$1 {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction is too low.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$1 {
  constructor({ cause: oe }) {
    super("The transaction type is not supported for this chain.", {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$1 {
  constructor({ cause: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${fe ? ` = ${formatGwei(fe)} gwei` : ""}).`
    ].join(`
`), {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$1 {
  constructor({ cause: oe }) {
    super(`An error occurred while executing: ${oe == null ? void 0 : oe.shortMessage}`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownNodeError"
    });
  }
}
function getNodeError(ne, oe) {
  const ae = (ne.details || "").toLowerCase(), fe = ne instanceof BaseError$1 ? ne.walk((ye) => ye.code === ExecutionRevertedError.code) : ne;
  return fe instanceof BaseError$1 ? new ExecutionRevertedError({
    cause: ne,
    message: fe.details
  }) : ExecutionRevertedError.nodeMessage.test(ae) ? new ExecutionRevertedError({
    cause: ne,
    message: ne.details
  }) : FeeCapTooHighError.nodeMessage.test(ae) ? new FeeCapTooHighError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : FeeCapTooLowError.nodeMessage.test(ae) ? new FeeCapTooLowError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : NonceTooHighError.nodeMessage.test(ae) ? new NonceTooHighError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceTooLowError.nodeMessage.test(ae) ? new NonceTooLowError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceMaxValueError.nodeMessage.test(ae) ? new NonceMaxValueError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : InsufficientFundsError.nodeMessage.test(ae) ? new InsufficientFundsError({ cause: ne }) : IntrinsicGasTooHighError.nodeMessage.test(ae) ? new IntrinsicGasTooHighError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : IntrinsicGasTooLowError.nodeMessage.test(ae) ? new IntrinsicGasTooLowError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : TransactionTypeNotSupportedError.nodeMessage.test(ae) ? new TransactionTypeNotSupportedError({ cause: ne }) : TipAboveFeeCapError.nodeMessage.test(ae) ? new TipAboveFeeCapError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas,
    maxPriorityFeePerGas: oe == null ? void 0 : oe.maxPriorityFeePerGas
  }) : new UnknownNodeError({
    cause: ne
  });
}
function getEstimateGasError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new EstimateGasExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
function extract(ne, { format: oe }) {
  if (!oe)
    return {};
  const ae = {};
  function fe(ve) {
    const _e = Object.keys(ve);
    for (const xe of _e)
      xe in ne && (ae[xe] = ne[xe]), ve[xe] && typeof ve[xe] == "object" && !Array.isArray(ve[xe]) && fe(ve[xe]);
  }
  const ye = oe(ne || {});
  return fe(ye), ae;
}
function defineFormatter(ne, oe) {
  return ({ exclude: ae, format: fe }) => ({
    exclude: ae,
    format: (ye) => {
      const ve = oe(ye);
      if (ae)
        for (const _e of ae)
          delete ve[_e];
      return {
        ...ve,
        ...fe(ye)
      };
    },
    type: ne
  });
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3"
};
function formatTransactionRequest(ne) {
  const oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => bytesToHex$2(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = numberToHex(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = numberToHex(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = numberToHex(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = numberToHex(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = numberToHex(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = numberToHex(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = rpcTransactionType[ne.type]), typeof ne.value < "u" && (oe.value = numberToHex(ne.value)), oe;
}
function assertRequest(ne) {
  const { account: oe, gasPrice: ae, maxFeePerGas: fe, maxPriorityFeePerGas: ye, to: ve } = ne, _e = oe ? parseAccount(oe) : void 0;
  if (_e && !isAddress(_e.address))
    throw new InvalidAddressError({ address: _e.address });
  if (ve && !isAddress(ve))
    throw new InvalidAddressError({ address: ve });
  if (typeof ae < "u" && (typeof fe < "u" || typeof ye < "u"))
    throw new FeeConflictError();
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ye && fe && ye > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ye });
}
class BaseFeeScalarError extends BaseError$1 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$1 {
  constructor() {
    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$1 {
  constructor({ maxPriorityFeePerGas: oe }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(oe)} gwei).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class BlockNotFoundError extends BaseError$1 {
  constructor({ blockHash: oe, blockNumber: ae }) {
    let fe = "Block";
    oe && (fe = `Block at hash "${oe}"`), ae && (fe = `Block at number "${ae}"`), super(`${fe} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlockNotFoundError"
    });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(ne) {
  const oe = {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    chainId: ne.chainId ? hexToNumber$1(ne.chainId) : void 0,
    gas: ne.gas ? BigInt(ne.gas) : void 0,
    gasPrice: ne.gasPrice ? BigInt(ne.gasPrice) : void 0,
    maxFeePerBlobGas: ne.maxFeePerBlobGas ? BigInt(ne.maxFeePerBlobGas) : void 0,
    maxFeePerGas: ne.maxFeePerGas ? BigInt(ne.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: ne.maxPriorityFeePerGas ? BigInt(ne.maxPriorityFeePerGas) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    type: ne.type ? transactionType[ne.type] : void 0,
    typeHex: ne.type ? ne.type : void 0,
    value: ne.value ? BigInt(ne.value) : void 0,
    v: ne.v ? BigInt(ne.v) : void 0
  };
  return oe.yParity = (() => {
    if (ne.yParity)
      return Number(ne.yParity);
    if (typeof oe.v == "bigint") {
      if (oe.v === 0n || oe.v === 27n)
        return 0;
      if (oe.v === 1n || oe.v === 28n)
        return 1;
      if (oe.v >= 35n)
        return oe.v % 2n === 0n ? 1 : 0;
    }
  })(), oe.type === "legacy" && (delete oe.accessList, delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas, delete oe.yParity), oe.type === "eip2930" && (delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas), oe.type === "eip1559" && delete oe.maxFeePerBlobGas, oe;
}
const defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatBlock(ne) {
  var ae;
  const oe = (ae = ne.transactions) == null ? void 0 : ae.map((fe) => typeof fe == "string" ? fe : formatTransaction(fe));
  return {
    ...ne,
    baseFeePerGas: ne.baseFeePerGas ? BigInt(ne.baseFeePerGas) : null,
    blobGasUsed: ne.blobGasUsed ? BigInt(ne.blobGasUsed) : void 0,
    difficulty: ne.difficulty ? BigInt(ne.difficulty) : void 0,
    excessBlobGas: ne.excessBlobGas ? BigInt(ne.excessBlobGas) : void 0,
    gasLimit: ne.gasLimit ? BigInt(ne.gasLimit) : void 0,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : void 0,
    hash: ne.hash ? ne.hash : null,
    logsBloom: ne.logsBloom ? ne.logsBloom : null,
    nonce: ne.nonce ? ne.nonce : null,
    number: ne.number ? BigInt(ne.number) : null,
    size: ne.size ? BigInt(ne.size) : void 0,
    timestamp: ne.timestamp ? BigInt(ne.timestamp) : void 0,
    transactions: oe,
    totalDifficulty: ne.totalDifficulty ? BigInt(ne.totalDifficulty) : null
  };
}
const defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);
async function getBlock(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, includeTransactions: ye } = {}) {
  var Me, Re, je;
  const ve = fe ?? "latest", _e = ye ?? !1, xe = ae !== void 0 ? numberToHex(ae) : void 0;
  let Oe = null;
  if (oe ? Oe = await ne.request({
    method: "eth_getBlockByHash",
    params: [oe, _e]
  }) : Oe = await ne.request({
    method: "eth_getBlockByNumber",
    params: [xe || ve, _e]
  }), !Oe)
    throw new BlockNotFoundError({ blockHash: oe, blockNumber: ae });
  return (((je = (Re = (Me = ne.chain) == null ? void 0 : Me.formatters) == null ? void 0 : Re.block) == null ? void 0 : je.format) || formatBlock)(Oe);
}
async function getGasPrice(ne) {
  const oe = await ne.request({
    method: "eth_gasPrice"
  });
  return BigInt(oe);
}
async function estimateMaxPriorityFeePerGas(ne, oe) {
  return internal_estimateMaxPriorityFeePerGas(ne, oe);
}
async function internal_estimateMaxPriorityFeePerGas(ne, oe) {
  var ve, _e, xe;
  const { block: ae, chain: fe = ne.chain, request: ye } = oe || {};
  if (typeof ((ve = fe == null ? void 0 : fe.fees) == null ? void 0 : ve.defaultPriorityFee) == "function") {
    const Oe = ae || await getAction(ne, getBlock, "getBlock")({});
    return fe.fees.defaultPriorityFee({
      block: Oe,
      client: ne,
      request: ye
    });
  }
  if (typeof ((_e = fe == null ? void 0 : fe.fees) == null ? void 0 : _e.defaultPriorityFee) < "u")
    return (xe = fe == null ? void 0 : fe.fees) == null ? void 0 : xe.defaultPriorityFee;
  try {
    const Oe = await ne.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(Oe);
  } catch {
    const [Oe, $e] = await Promise.all([
      ae ? Promise.resolve(ae) : getAction(ne, getBlock, "getBlock")({}),
      getAction(ne, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof Oe.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const Me = $e - Oe.baseFeePerGas;
    return Me < 0n ? 0n : Me;
  }
}
async function estimateFeesPerGas(ne, oe) {
  return internal_estimateFeesPerGas(ne, oe);
}
async function internal_estimateFeesPerGas(ne, oe) {
  var je, Be;
  const { block: ae, chain: fe = ne.chain, request: ye, type: ve = "eip1559" } = oe || {}, _e = await (async () => {
    var ze, He;
    return typeof ((ze = fe == null ? void 0 : fe.fees) == null ? void 0 : ze.baseFeeMultiplier) == "function" ? fe.fees.baseFeeMultiplier({
      block: ae,
      client: ne,
      request: ye
    }) : ((He = fe == null ? void 0 : fe.fees) == null ? void 0 : He.baseFeeMultiplier) ?? 1.2;
  })();
  if (_e < 1)
    throw new BaseFeeScalarError();
  const Oe = 10 ** (((je = _e.toString().split(".")[1]) == null ? void 0 : je.length) ?? 0), $e = (ze) => ze * BigInt(Math.ceil(_e * Oe)) / BigInt(Oe), Me = ae || await getAction(ne, getBlock, "getBlock")({});
  if (typeof ((Be = fe == null ? void 0 : fe.fees) == null ? void 0 : Be.estimateFeesPerGas) == "function") {
    const ze = await fe.fees.estimateFeesPerGas({
      block: ae,
      client: ne,
      multiply: $e,
      request: ye,
      type: ve
    });
    if (ze !== null)
      return ze;
  }
  if (ve === "eip1559") {
    if (typeof Me.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const ze = typeof (ye == null ? void 0 : ye.maxPriorityFeePerGas) == "bigint" ? ye.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(ne, {
      block: Me,
      chain: fe,
      request: ye
    }), He = $e(Me.baseFeePerGas);
    return {
      maxFeePerGas: (ye == null ? void 0 : ye.maxFeePerGas) ?? He + ze,
      maxPriorityFeePerGas: ze
    };
  }
  return {
    gasPrice: (ye == null ? void 0 : ye.gasPrice) ?? $e(await getAction(ne, getGasPrice, "getGasPrice")({}))
  };
}
async function getTransactionCount(ne, { address: oe, blockTag: ae = "latest", blockNumber: fe }) {
  const ye = await ne.request({
    method: "eth_getTransactionCount",
    params: [oe, fe ? numberToHex(fe) : ae]
  });
  return hexToNumber$1(ye);
}
class AccountNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join(`
`), {
      docsPath: oe,
      docsSlug: "account"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountNotFoundError"
    });
  }
}
function blobsToCommitments(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((ve) => hexToBytes$1(ve)) : ne.blobs, ye = [];
  for (const ve of fe)
    ye.push(Uint8Array.from(oe.blobToKzgCommitment(ve)));
  return ae === "bytes" ? ye : ye.map((ve) => bytesToHex$2(ve));
}
function blobsToProofs(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((_e) => hexToBytes$1(_e)) : ne.blobs, ye = typeof ne.commitments[0] == "string" ? ne.commitments.map((_e) => hexToBytes$1(_e)) : ne.commitments, ve = [];
  for (let _e = 0; _e < fe.length; _e++) {
    const xe = fe[_e], Oe = ye[_e];
    ve.push(Uint8Array.from(oe.computeBlobKzgProof(xe, Oe)));
  }
  return ae === "bytes" ? ve : ve.map((_e) => bytesToHex$2(_e));
}
function setBigUint64(ne, oe, ae, fe) {
  if (typeof ne.setBigUint64 == "function")
    return ne.setBigUint64(oe, ae, fe);
  const ye = BigInt(32), ve = BigInt(4294967295), _e = Number(ae >> ye & ve), xe = Number(ae & ve), Oe = fe ? 4 : 0, $e = fe ? 0 : 4;
  ne.setUint32(oe + Oe, _e, fe), ne.setUint32(oe + $e, xe, fe);
}
class SHA2 extends Hash {
  constructor(oe, ae, fe, ye) {
    super(), this.blockLen = oe, this.outputLen = ae, this.padOffset = fe, this.isLE = ye, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(oe), this.view = createView(this.buffer);
  }
  update(oe) {
    exists(this);
    const { view: ae, buffer: fe, blockLen: ye } = this;
    oe = toBytes(oe);
    const ve = oe.length;
    for (let _e = 0; _e < ve; ) {
      const xe = Math.min(ye - this.pos, ve - _e);
      if (xe === ye) {
        const Oe = createView(oe);
        for (; ye <= ve - _e; _e += ye)
          this.process(Oe, _e);
        continue;
      }
      fe.set(oe.subarray(_e, _e + xe), this.pos), this.pos += xe, _e += xe, this.pos === ye && (this.process(ae, 0), this.pos = 0);
    }
    return this.length += oe.length, this.roundClean(), this;
  }
  digestInto(oe) {
    exists(this), output(oe, this), this.finished = !0;
    const { buffer: ae, view: fe, blockLen: ye, isLE: ve } = this;
    let { pos: _e } = this;
    ae[_e++] = 128, this.buffer.subarray(_e).fill(0), this.padOffset > ye - _e && (this.process(fe, 0), _e = 0);
    for (let Re = _e; Re < ye; Re++)
      ae[Re] = 0;
    setBigUint64(fe, ye - 8, BigInt(this.length * 8), ve), this.process(fe, 0);
    const xe = createView(oe), Oe = this.outputLen;
    if (Oe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const $e = Oe / 4, Me = this.get();
    if ($e > Me.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Re = 0; Re < $e; Re++)
      xe.setUint32(4 * Re, Me[Re], ve);
  }
  digest() {
    const { buffer: oe, outputLen: ae } = this;
    this.digestInto(oe);
    const fe = oe.slice(0, ae);
    return this.destroy(), fe;
  }
  _cloneInto(oe) {
    oe || (oe = new this.constructor()), oe.set(...this.get());
    const { blockLen: ae, buffer: fe, length: ye, finished: ve, destroyed: _e, pos: xe } = this;
    return oe.length = ye, oe.pos = xe, oe.finished = ve, oe.destroyed = _e, ye % ae && oe.buffer.set(fe), oe;
  }
}
const Chi = (ne, oe, ae) => ne & oe ^ ~ne & ae, Maj = (ne, oe, ae) => ne & oe ^ ne & ae ^ oe & ae, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: oe, B: ae, C: fe, D: ye, E: ve, F: _e, G: xe, H: Oe } = this;
    return [oe, ae, fe, ye, ve, _e, xe, Oe];
  }
  // prettier-ignore
  set(oe, ae, fe, ye, ve, _e, xe, Oe) {
    this.A = oe | 0, this.B = ae | 0, this.C = fe | 0, this.D = ye | 0, this.E = ve | 0, this.F = _e | 0, this.G = xe | 0, this.H = Oe | 0;
  }
  process(oe, ae) {
    for (let Re = 0; Re < 16; Re++, ae += 4)
      SHA256_W[Re] = oe.getUint32(ae, !1);
    for (let Re = 16; Re < 64; Re++) {
      const je = SHA256_W[Re - 15], Be = SHA256_W[Re - 2], ze = rotr(je, 7) ^ rotr(je, 18) ^ je >>> 3, He = rotr(Be, 17) ^ rotr(Be, 19) ^ Be >>> 10;
      SHA256_W[Re] = He + SHA256_W[Re - 7] + ze + SHA256_W[Re - 16] | 0;
    }
    let { A: fe, B: ye, C: ve, D: _e, E: xe, F: Oe, G: $e, H: Me } = this;
    for (let Re = 0; Re < 64; Re++) {
      const je = rotr(xe, 6) ^ rotr(xe, 11) ^ rotr(xe, 25), Be = Me + je + Chi(xe, Oe, $e) + SHA256_K[Re] + SHA256_W[Re] | 0, He = (rotr(fe, 2) ^ rotr(fe, 13) ^ rotr(fe, 22)) + Maj(fe, ye, ve) | 0;
      Me = $e, $e = Oe, Oe = xe, xe = _e + Be | 0, _e = ve, ve = ye, ye = fe, fe = Be + He | 0;
    }
    fe = fe + this.A | 0, ye = ye + this.B | 0, ve = ve + this.C | 0, _e = _e + this.D | 0, xe = xe + this.E | 0, Oe = Oe + this.F | 0, $e = $e + this.G | 0, Me = Me + this.H | 0, this.set(fe, ye, ve, _e, xe, Oe, $e, Me);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
function sha256(ne, oe) {
  const ae = oe || "hex", fe = sha256$1(isHex$1(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex$1(fe);
}
function commitmentToVersionedHash(ne) {
  const { commitment: oe, version: ae = 1 } = ne, fe = ne.to ?? (typeof oe == "string" ? "hex" : "bytes"), ye = sha256(oe, "bytes");
  return ye.set([ae], 0), fe === "bytes" ? ye : bytesToHex$2(ye);
}
function commitmentsToVersionedHashes(ne) {
  const { commitments: oe, version: ae } = ne, fe = ne.to ?? (typeof oe[0] == "string" ? "hex" : "bytes"), ye = [];
  for (const ve of oe)
    ye.push(commitmentToVersionedHash({
      commitment: ve,
      to: fe,
      version: ae
    }));
  return ye;
}
const blobsPerTransaction = 6, bytesPerFieldElement = 32, fieldElementsPerBlob = 4096, bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob, maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction, versionedHashVersionKzg = 1;
class BlobSizeTooLargeError extends BaseError$1 {
  constructor({ maxSize: oe, size: ae }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${oe} bytes`, `Given: ${ae} bytes`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$1 {
  constructor() {
    super("Blob data must not be empty."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EmptyBlobError"
    });
  }
}
class InvalidVersionedHashSizeError extends BaseError$1 {
  constructor({ hash: oe, size: ae }) {
    super(`Versioned hash "${oe}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${ae}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashSizeError"
    });
  }
}
class InvalidVersionedHashVersionError extends BaseError$1 {
  constructor({ hash: oe, version: ae }) {
    super(`Versioned hash "${oe}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${ae}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashVersionError"
    });
  }
}
function toBlobs(ne) {
  const oe = ne.to ?? (typeof ne.data == "string" ? "hex" : "bytes"), ae = typeof ne.data == "string" ? hexToBytes$1(ne.data) : ne.data, fe = size$2(ae);
  if (!fe)
    throw new EmptyBlobError();
  if (fe > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: fe
    });
  const ye = [];
  let ve = !0, _e = 0;
  for (; ve; ) {
    const xe = createCursor(new Uint8Array(bytesPerBlob));
    let Oe = 0;
    for (; Oe < fieldElementsPerBlob; ) {
      const $e = ae.slice(_e, _e + (bytesPerFieldElement - 1));
      if (xe.pushByte(0), xe.pushBytes($e), $e.length < 31) {
        xe.pushByte(128), ve = !1;
        break;
      }
      Oe++, _e += 31;
    }
    ye.push(xe);
  }
  return oe === "bytes" ? ye.map((xe) => xe.bytes) : ye.map((xe) => bytesToHex$2(xe.bytes));
}
function toBlobSidecars(ne) {
  const { data: oe, kzg: ae, to: fe } = ne, ye = ne.blobs ?? toBlobs({ data: oe, to: fe }), ve = ne.commitments ?? blobsToCommitments({ blobs: ye, kzg: ae, to: fe }), _e = ne.proofs ?? blobsToProofs({ blobs: ye, commitments: ve, kzg: ae, to: fe }), xe = [];
  for (let Oe = 0; Oe < ye.length; Oe++)
    xe.push({
      blob: ye[Oe],
      commitment: ve[Oe],
      proof: _e[Oe]
    });
  return xe;
}
function getTransactionType(ne) {
  if (ne.type)
    return ne.type;
  if (typeof ne.blobs < "u" || typeof ne.blobVersionedHashes < "u" || typeof ne.maxFeePerBlobGas < "u" || typeof ne.sidecars < "u")
    return "eip4844";
  if (typeof ne.maxFeePerGas < "u" || typeof ne.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof ne.gasPrice < "u")
    return typeof ne.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: ne });
}
async function getChainId(ne) {
  const oe = await ne.request({
    method: "eth_chainId"
  });
  return hexToNumber$1(oe);
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(ne, oe) {
  const { account: ae = ne.account, blobs: fe, chain: ye, chainId: ve, gas: _e, kzg: xe, nonce: Oe, parameters: $e = defaultParameters, type: Me } = oe, Re = ae ? parseAccount(ae) : void 0, je = { ...oe, ...Re ? { from: Re == null ? void 0 : Re.address } : {} };
  let Be;
  async function ze() {
    return Be || (Be = await getAction(ne, getBlock, "getBlock")({ blockTag: "latest" }), Be);
  }
  if (($e.includes("blobVersionedHashes") || $e.includes("sidecars")) && fe && xe) {
    const He = blobsToCommitments({ blobs: fe, kzg: xe });
    if ($e.includes("blobVersionedHashes")) {
      const qe = commitmentsToVersionedHashes({
        commitments: He,
        to: "hex"
      });
      je.blobVersionedHashes = qe;
    }
    if ($e.includes("sidecars")) {
      const qe = blobsToProofs({ blobs: fe, commitments: He, kzg: xe }), Ye = toBlobSidecars({
        blobs: fe,
        commitments: He,
        proofs: qe,
        to: "hex"
      });
      je.sidecars = Ye;
    }
  }
  if ($e.includes("chainId") && (ye ? je.chainId = ye.id : typeof ve < "u" ? je.chainId = ve : je.chainId = await getAction(ne, getChainId, "getChainId")({})), $e.includes("nonce") && typeof Oe > "u" && Re && (je.nonce = await getAction(ne, getTransactionCount, "getTransactionCount")({
    address: Re.address,
    blockTag: "pending"
  })), ($e.includes("fees") || $e.includes("type")) && typeof Me > "u")
    try {
      je.type = getTransactionType(je);
    } catch {
      const He = await ze();
      je.type = typeof (He == null ? void 0 : He.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if ($e.includes("fees"))
    if (je.type === "eip1559" || je.type === "eip4844") {
      if (typeof je.maxFeePerGas > "u" || typeof je.maxPriorityFeePerGas > "u") {
        const He = await ze(), { maxFeePerGas: qe, maxPriorityFeePerGas: Ye } = await internal_estimateFeesPerGas(ne, {
          block: He,
          chain: ye,
          request: je
        });
        if (typeof oe.maxPriorityFeePerGas > "u" && oe.maxFeePerGas && oe.maxFeePerGas < Ye)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas: Ye
          });
        je.maxPriorityFeePerGas = Ye, je.maxFeePerGas = qe;
      }
    } else {
      if (typeof oe.maxFeePerGas < "u" || typeof oe.maxPriorityFeePerGas < "u")
        throw new Eip1559FeesNotSupportedError();
      const He = await ze(), { gasPrice: qe } = await internal_estimateFeesPerGas(ne, {
        block: He,
        chain: ye,
        request: je,
        type: "legacy"
      });
      je.gasPrice = qe;
    }
  return $e.includes("gas") && typeof _e > "u" && (je.gas = await getAction(ne, estimateGas, "estimateGas")({
    ...je,
    account: Re ? { address: Re.address, type: "json-rpc" } : void 0
  })), assertRequest(je), delete je.parameters, je;
}
async function estimateGas(ne, oe) {
  var ye, ve, _e;
  const ae = oe.account ?? ne.account, fe = ae ? parseAccount(ae) : void 0;
  try {
    const { accessList: xe, blobs: Oe, blobVersionedHashes: $e, blockNumber: Me, blockTag: Re, data: je, gas: Be, gasPrice: ze, maxFeePerBlobGas: He, maxFeePerGas: qe, maxPriorityFeePerGas: Ye, nonce: pt, to: dt, value: yt, ...Ct } = await prepareTransactionRequest(ne, {
      ...oe,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (fe == null ? void 0 : fe.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), Vt = (Me ? numberToHex(Me) : void 0) || Re;
    assertRequest(oe);
    const Ut = (_e = (ve = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : ve.transactionRequest) == null ? void 0 : _e.format, tr = (Ut || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(Ct, { format: Ut }),
      from: fe == null ? void 0 : fe.address,
      accessList: xe,
      blobs: Oe,
      blobVersionedHashes: $e,
      data: je,
      gas: Be,
      gasPrice: ze,
      maxFeePerBlobGas: He,
      maxFeePerGas: qe,
      maxPriorityFeePerGas: Ye,
      nonce: pt,
      to: dt,
      value: yt
    }), er = await ne.request({
      method: "eth_estimateGas",
      params: Vt ? [tr, Vt] : [tr]
    });
    return BigInt(er);
  } catch (xe) {
    throw getEstimateGasError(xe, {
      ...oe,
      account: fe,
      chain: ne.chain
    });
  }
}
async function estimateContractGas(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: ve, ..._e } = oe, xe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: ve
  });
  try {
    return await getAction(ne, estimateGas, "estimateGas")({
      data: xe,
      to: fe,
      ..._e
    });
  } catch (Oe) {
    const $e = _e.account ? parseAccount(_e.account) : void 0;
    throw getContractError(Oe, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: ve,
      sender: $e == null ? void 0 : $e.address
    });
  }
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog(ne) {
  const { abi: oe, data: ae, strict: fe, topics: ye } = ne, ve = fe ?? !0, [_e, ...xe] = ye;
  if (!_e)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath$2 });
  const Oe = oe.find((He) => He.type === "event" && _e === toEventSelector(formatAbiItem(He)));
  if (!(Oe && "name" in Oe) || Oe.type !== "event")
    throw new AbiEventSignatureNotFoundError(_e, { docsPath: docsPath$2 });
  const { name: $e, inputs: Me } = Oe, Re = Me == null ? void 0 : Me.some((He) => !("name" in He && He.name));
  let je = Re ? [] : {};
  const Be = Me.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    const qe = Be[He], Ye = xe[He];
    if (!Ye)
      throw new DecodeLogTopicsMismatch({
        abiItem: Oe,
        param: qe
      });
    je[Re ? He : qe.name || He] = decodeTopic({ param: qe, value: Ye });
  }
  const ze = Me.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        const He = decodeAbiParameters(ze, ae);
        if (He)
          if (Re)
            je = [...je, ...He];
          else
            for (let qe = 0; qe < ze.length; qe++)
              je[ze[qe].name] = He[qe];
      } catch (He) {
        if (ve)
          throw He instanceof AbiDecodingDataSizeTooSmallError || He instanceof PositionOutOfBoundsError ? new DecodeLogDataMismatch({
            abiItem: Oe,
            data: ae,
            params: ze,
            size: size$2(ae)
          }) : He;
      }
    else if (ve)
      throw new DecodeLogDataMismatch({
        abiItem: Oe,
        data: "0x",
        params: ze,
        size: 0
      });
  }
  return {
    eventName: $e,
    args: Object.values(je).length > 0 ? je : void 0
  };
}
function decodeTopic({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (decodeAbiParameters([ne], oe) || [])[0];
}
function parseEventLogs({ abi: ne, eventName: oe, logs: ae, strict: fe = !0 }) {
  return ae.map((ye) => {
    var ve;
    try {
      const _e = decodeEventLog({
        ...ye,
        abi: ne,
        strict: fe
      });
      return oe && !oe.includes(_e.eventName) ? null : { ..._e, ...ye };
    } catch (_e) {
      let xe, Oe;
      if (_e instanceof AbiEventSignatureNotFoundError)
        return null;
      if (_e instanceof DecodeLogDataMismatch || _e instanceof DecodeLogTopicsMismatch) {
        if (fe)
          return null;
        xe = _e.abiItem.name, Oe = (ve = _e.abiItem.inputs) == null ? void 0 : ve.some(($e) => !("name" in $e && $e.name));
      }
      return { ...ye, args: Oe ? [] : {}, eventName: xe };
    }
  }).filter(Boolean);
}
function formatLog(ne, { args: oe, eventName: ae } = {}) {
  return {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    logIndex: ne.logIndex ? Number(ne.logIndex) : null,
    transactionHash: ne.transactionHash ? ne.transactionHash : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    ...ae ? { args: oe, eventName: ae } : {}
  };
}
async function getLogs(ne, { address: oe, blockHash: ae, fromBlock: fe, toBlock: ye, event: ve, events: _e, args: xe, strict: Oe } = {}) {
  const $e = Oe ?? !1, Me = _e ?? (ve ? [ve] : void 0);
  let Re = [];
  Me && (Re = [
    Me.flatMap((ze) => encodeEventTopics({
      abi: [ze],
      eventName: ze.name,
      args: xe
    }))
  ], ve && (Re = Re[0]));
  let je;
  ae ? je = await ne.request({
    method: "eth_getLogs",
    params: [{ address: oe, topics: Re, blockHash: ae }]
  }) : je = await ne.request({
    method: "eth_getLogs",
    params: [
      {
        address: oe,
        topics: Re,
        fromBlock: typeof fe == "bigint" ? numberToHex(fe) : fe,
        toBlock: typeof ye == "bigint" ? numberToHex(ye) : ye
      }
    ]
  });
  const Be = je.map((ze) => formatLog(ze));
  return Me ? parseEventLogs({
    abi: Me,
    logs: Be,
    strict: $e
  }) : Be;
}
async function getContractEvents(ne, oe) {
  const { abi: ae, address: fe, args: ye, blockHash: ve, eventName: _e, fromBlock: xe, toBlock: Oe, strict: $e } = oe, Me = _e ? getAbiItem({ abi: ae, name: _e }) : void 0, Re = Me ? void 0 : ae.filter((je) => je.type === "event");
  return getAction(ne, getLogs, "getLogs")({
    address: fe,
    args: ye,
    blockHash: ve,
    event: Me,
    events: Re,
    fromBlock: xe,
    toBlock: Oe,
    strict: $e
  });
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(ne) {
  const { abi: oe, args: ae, functionName: fe, data: ye } = ne;
  let ve = oe[0];
  if (fe) {
    const xe = getAbiItem({ abi: oe, args: ae, name: fe });
    if (!xe)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$1 });
    ve = xe;
  }
  if (ve.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!ve.outputs)
    throw new AbiFunctionOutputsNotFoundError(ve.name, { docsPath: docsPath$1 });
  const _e = decodeAbiParameters(ve.outputs, ye);
  if (_e && _e.length > 1)
    return _e;
  if (_e && _e.length === 1)
    return _e[0];
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
], aggregate3Signature = "0x82ad56cb";
class ChainDoesNotSupportContract extends BaseError$1 {
  constructor({ blockNumber: oe, chain: ae, contract: fe }) {
    super(`Chain "${ae.name}" does not support contract "${fe.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...oe && fe.blockCreated && fe.blockCreated > oe ? [
          `- The contract "${fe.name}" was not deployed until block ${fe.blockCreated} (current block ${oe}).`
        ] : [
          `- The chain does not have the contract "${fe.name}" configured.`
        ]
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$1 {
  constructor({ chain: oe, currentChainId: ae }) {
    super(`The current chain of the wallet (id: ${ae}) does not match the target chain for the transaction (id: ${oe.id}  ${oe.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${ae}`,
        `Expected Chain ID: ${oe.id}  ${oe.name}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError$1 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ClientChainNotConfiguredError"
    });
  }
}
class InvalidChainIdError extends BaseError$1 {
  constructor({ chainId: oe }) {
    super(typeof oe == "number" ? `Chain ID "${oe}" is invalid.` : "Chain ID is invalid."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidChainIdError"
    });
  }
}
function getChainContractAddress({ blockNumber: ne, chain: oe, contract: ae }) {
  var ye;
  const fe = (ye = oe == null ? void 0 : oe.contracts) == null ? void 0 : ye[ae];
  if (!fe)
    throw new ChainDoesNotSupportContract({
      chain: oe,
      contract: { name: ae }
    });
  if (ne && fe.blockCreated && fe.blockCreated > ne)
    throw new ChainDoesNotSupportContract({
      blockNumber: ne,
      chain: oe,
      contract: {
        name: ae,
        blockCreated: fe.blockCreated
      }
    });
  return fe.address;
}
function getCallError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new CallExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: ne, id: oe, shouldSplitBatch: ae, wait: fe = 0, sort: ye }) {
  const ve = async () => {
    const Me = Oe();
    _e();
    const Re = Me.map(({ args: je }) => je);
    Re.length !== 0 && ne(Re).then((je) => {
      var Be;
      ye && Array.isArray(je) && je.sort(ye);
      for (let ze = 0; ze < Me.length; ze++) {
        const { pendingPromise: He } = Me[ze];
        (Be = He.resolve) == null || Be.call(He, [je[ze], je]);
      }
    }).catch((je) => {
      var Be;
      for (let ze = 0; ze < Me.length; ze++) {
        const { pendingPromise: He } = Me[ze];
        (Be = He.reject) == null || Be.call(He, je);
      }
    });
  }, _e = () => schedulerCache.delete(oe), xe = () => Oe().map(({ args: Me }) => Me), Oe = () => schedulerCache.get(oe) || [], $e = (Me) => schedulerCache.set(oe, [...Oe(), Me]);
  return {
    flush: _e,
    async schedule(Me) {
      const Re = {}, je = new Promise((He, qe) => {
        Re.resolve = He, Re.reject = qe;
      });
      return (ae == null ? void 0 : ae([...xe(), Me])) && ve(), Oe().length > 0 ? ($e({ args: Me, pendingPromise: Re }), je) : ($e({ args: Me, pendingPromise: Re }), setTimeout(ve, fe), je);
    }
  };
}
async function call(ne, oe) {
  var yt, Ct, It, Vt;
  const { account: ae = ne.account, batch: fe = !!((yt = ne.batch) != null && yt.multicall), blockNumber: ye, blockTag: ve = "latest", accessList: _e, blobs: xe, data: Oe, gas: $e, gasPrice: Me, maxFeePerBlobGas: Re, maxFeePerGas: je, maxPriorityFeePerGas: Be, nonce: ze, to: He, value: qe, stateOverride: Ye, ...pt } = oe, dt = ae ? parseAccount(ae) : void 0;
  try {
    assertRequest(oe);
    const Zt = (ye ? numberToHex(ye) : void 0) || ve, tr = parseStateOverride(Ye), er = (Vt = (It = (Ct = ne.chain) == null ? void 0 : Ct.formatters) == null ? void 0 : It.transactionRequest) == null ? void 0 : Vt.format, Ot = (er || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(pt, { format: er }),
      from: dt == null ? void 0 : dt.address,
      accessList: _e,
      blobs: xe,
      data: Oe,
      gas: $e,
      gasPrice: Me,
      maxFeePerBlobGas: Re,
      maxFeePerGas: je,
      maxPriorityFeePerGas: Be,
      nonce: ze,
      to: He,
      value: qe
    });
    if (fe && shouldPerformMulticall({ request: Ot }) && !tr)
      try {
        return await scheduleMulticall(ne, {
          ...Ot,
          blockNumber: ye,
          blockTag: ve
        });
      } catch (at) {
        if (!(at instanceof ClientChainNotConfiguredError) && !(at instanceof ChainDoesNotSupportContract))
          throw at;
      }
    const Qe = await ne.request({
      method: "eth_call",
      params: tr ? [
        Ot,
        Zt,
        tr
      ] : [Ot, Zt]
    });
    return Qe === "0x" ? { data: void 0 } : { data: Qe };
  } catch (Ut) {
    const Zt = getRevertErrorData(Ut), { offchainLookup: tr, offchainLookupSignature: er } = await import("./ccip-485022ea.js");
    if (ne.ccipRead !== !1 && (Zt == null ? void 0 : Zt.slice(0, 10)) === er && He)
      return { data: await tr(ne, { data: Zt, to: He }) };
    throw getCallError(Ut, {
      ...oe,
      account: dt,
      chain: ne.chain
    });
  }
}
function shouldPerformMulticall({ request: ne }) {
  const { data: oe, to: ae, ...fe } = ne;
  return !(!oe || oe.startsWith(aggregate3Signature) || !ae || Object.values(fe).filter((ye) => typeof ye < "u").length > 0);
}
async function scheduleMulticall(ne, oe) {
  var He;
  const { batchSize: ae = 1024, wait: fe = 0 } = typeof ((He = ne.batch) == null ? void 0 : He.multicall) == "object" ? ne.batch.multicall : {}, { blockNumber: ye, blockTag: ve = "latest", data: _e, multicallAddress: xe, to: Oe } = oe;
  let $e = xe;
  if (!$e) {
    if (!ne.chain)
      throw new ClientChainNotConfiguredError();
    $e = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Re = (ye ? numberToHex(ye) : void 0) || ve, { schedule: je } = createBatchScheduler({
    id: `${ne.uid}.${Re}`,
    wait: fe,
    shouldSplitBatch(qe) {
      return qe.reduce((pt, { data: dt }) => pt + (dt.length - 2), 0) > ae * 2;
    },
    fn: async (qe) => {
      const Ye = qe.map((yt) => ({
        allowFailure: !0,
        callData: yt.data,
        target: yt.to
      })), pt = encodeFunctionData({
        abi: multicall3Abi,
        args: [Ye],
        functionName: "aggregate3"
      }), dt = await ne.request({
        method: "eth_call",
        params: [
          {
            data: pt,
            to: $e
          },
          Re
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [Ye],
        functionName: "aggregate3",
        data: dt || "0x"
      });
    }
  }), [{ returnData: Be, success: ze }] = await je({ data: _e, to: Oe });
  if (!ze)
    throw new RawContractError({ data: Be });
  return Be === "0x" ? { data: void 0 } : { data: Be };
}
function getRevertErrorData(ne) {
  var ae;
  if (!(ne instanceof BaseError$1))
    return;
  const oe = ne.walk();
  return typeof (oe == null ? void 0 : oe.data) == "object" ? (ae = oe.data) == null ? void 0 : ae.data : oe.data;
}
function parseStateMapping(ne) {
  if (!(!ne || ne.length === 0))
    return ne.reduce((oe, { slot: ae, value: fe }) => {
      if (ae.length !== 66)
        throw new InvalidBytesLengthError({
          size: ae.length,
          targetSize: 66,
          type: "hex"
        });
      if (fe.length !== 66)
        throw new InvalidBytesLengthError({
          size: fe.length,
          targetSize: 66,
          type: "hex"
        });
      return oe[ae] = fe, oe;
    }, {});
}
function parseAccountStateOverride(ne) {
  const { balance: oe, nonce: ae, state: fe, stateDiff: ye, code: ve } = ne, _e = {};
  if (ve !== void 0 && (_e.code = ve), oe !== void 0 && (_e.balance = numberToHex(oe)), ae !== void 0 && (_e.nonce = numberToHex(ae)), fe !== void 0 && (_e.state = parseStateMapping(fe)), ye !== void 0) {
    if (_e.state)
      throw new StateAssignmentConflictError();
    _e.stateDiff = parseStateMapping(ye);
  }
  return _e;
}
function parseStateOverride(ne) {
  if (!ne)
    return;
  const oe = {};
  for (const { address: ae, ...fe } of ne) {
    if (!isAddress(ae, { strict: !1 }))
      throw new InvalidAddressError({ address: ae });
    if (oe[ae])
      throw new AccountStateConflictError({ address: ae });
    oe[ae] = parseAccountStateOverride(fe);
  }
  return oe;
}
async function readContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: ve, ..._e } = oe, xe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: ve
  });
  try {
    const { data: Oe } = await getAction(ne, call, "call")({
      ..._e,
      data: xe,
      to: fe
    });
    return decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: ve,
      data: Oe || "0x"
    });
  } catch (Oe) {
    throw getContractError(Oe, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/readContract",
      functionName: ve
    });
  }
}
async function simulateContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: ve, functionName: _e, ...xe } = oe, Oe = xe.account ? parseAccount(xe.account) : ne.account, $e = encodeFunctionData({ abi: ae, args: ye, functionName: _e });
  try {
    const { data: Me } = await getAction(ne, call, "call")({
      batch: !1,
      data: `${$e}${ve ? ve.replace("0x", "") : ""}`,
      to: fe,
      ...xe,
      account: Oe
    }), Re = decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: _e,
      data: Me || "0x"
    }), je = ae.filter((Be) => "name" in Be && Be.name === oe.functionName);
    return {
      result: Re,
      request: {
        abi: je,
        address: fe,
        args: ye,
        dataSuffix: ve,
        functionName: _e,
        ...xe,
        account: Oe
      }
    };
  } catch (Me) {
    throw getContractError(Me, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/simulateContract",
      functionName: _e,
      sender: Oe == null ? void 0 : Oe.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map(), cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(ne, oe, ae) {
  const fe = ++callbackCount, ye = () => listenersCache.get(ne) || [], ve = () => {
    const Me = ye();
    listenersCache.set(ne, Me.filter((Re) => Re.id !== fe));
  }, _e = () => {
    const Me = cleanupCache.get(ne);
    ye().length === 1 && Me && Me(), ve();
  }, xe = ye();
  if (listenersCache.set(ne, [
    ...xe,
    { id: fe, fns: oe }
  ]), xe && xe.length > 0)
    return _e;
  const Oe = {};
  for (const Me in oe)
    Oe[Me] = (...Re) => {
      var Be, ze;
      const je = ye();
      if (je.length !== 0)
        for (const He of je)
          (ze = (Be = He.fns)[Me]) == null || ze.call(Be, ...Re);
    };
  const $e = ae(Oe);
  return typeof $e == "function" && cleanupCache.set(ne, $e), _e;
}
async function wait(ne) {
  return new Promise((oe) => setTimeout(oe, ne));
}
function poll(ne, { emitOnBegin: oe, initialWaitTime: ae, interval: fe }) {
  let ye = !0;
  const ve = () => ye = !1;
  return (async () => {
    let xe;
    oe && (xe = await ne({ unpoll: ve }));
    const Oe = await (ae == null ? void 0 : ae(xe)) ?? fe;
    await wait(Oe);
    const $e = async () => {
      ye && (await ne({ unpoll: ve }), await wait(fe), $e());
    };
    $e();
  })(), ve;
}
const promiseCache = /* @__PURE__ */ new Map(), responseCache = /* @__PURE__ */ new Map();
function getCache(ne) {
  const oe = (ye, ve) => ({
    clear: () => ve.delete(ye),
    get: () => ve.get(ye),
    set: (_e) => ve.set(ye, _e)
  }), ae = oe(ne, promiseCache), fe = oe(ne, responseCache);
  return {
    clear: () => {
      ae.clear(), fe.clear();
    },
    promise: ae,
    response: fe
  };
}
async function withCache(ne, { cacheKey: oe, cacheTime: ae = 1 / 0 }) {
  const fe = getCache(oe), ye = fe.response.get();
  if (ye && ae > 0 && (/* @__PURE__ */ new Date()).getTime() - ye.created.getTime() < ae)
    return ye.data;
  let ve = fe.promise.get();
  ve || (ve = ne(), fe.promise.set(ve));
  try {
    const _e = await ve;
    return fe.response.set({ created: /* @__PURE__ */ new Date(), data: _e }), _e;
  } finally {
    fe.promise.clear();
  }
}
const cacheKey = (ne) => `blockNumber.${ne}`;
async function getBlockNumber(ne, { cacheTime: oe = ne.cacheTime } = {}) {
  const ae = await withCache(() => ne.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(ne.uid), cacheTime: oe });
  return BigInt(ae);
}
async function getFilterChanges(ne, { filter: oe }) {
  const ae = "strict" in oe && oe.strict, fe = await oe.request({
    method: "eth_getFilterChanges",
    params: [oe.id]
  });
  if (typeof fe[0] == "string")
    return fe;
  const ye = fe.map((ve) => formatLog(ve));
  return !("abi" in oe) || !oe.abi ? ye : parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  });
}
async function uninstallFilter(ne, { filter: oe }) {
  return oe.request({
    method: "eth_uninstallFilter",
    params: [oe.id]
  });
}
function watchContractEvent(ne, oe) {
  const { abi: ae, address: fe, args: ye, batch: ve = !0, eventName: _e, fromBlock: xe, onError: Oe, onLogs: $e, poll: Me, pollingInterval: Re = ne.pollingInterval, strict: je } = oe;
  return (typeof Me < "u" ? Me : ne.transport.type !== "webSocket" || typeof xe == "number") ? (() => {
    const qe = je ?? !1, Ye = stringify([
      "watchContractEvent",
      fe,
      ye,
      ve,
      ne.uid,
      _e,
      Re,
      qe,
      xe
    ]);
    return observe(Ye, { onLogs: $e, onError: Oe }, (pt) => {
      let dt;
      xe !== void 0 && (dt = xe - 1n);
      let yt, Ct = !1;
      const It = poll(async () => {
        var Vt;
        if (!Ct) {
          try {
            yt = await getAction(ne, createContractEventFilter, "createContractEventFilter")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: _e,
              strict: qe,
              fromBlock: xe
            });
          } catch {
          }
          Ct = !0;
          return;
        }
        try {
          let Ut;
          if (yt)
            Ut = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: yt });
          else {
            const Zt = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            dt && dt !== Zt ? Ut = await getAction(ne, getContractEvents, "getContractEvents")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: _e,
              fromBlock: dt + 1n,
              toBlock: Zt,
              strict: qe
            }) : Ut = [], dt = Zt;
          }
          if (Ut.length === 0)
            return;
          if (ve)
            pt.onLogs(Ut);
          else
            for (const Zt of Ut)
              pt.onLogs([Zt]);
        } catch (Ut) {
          yt && Ut instanceof InvalidInputRpcError && (Ct = !1), (Vt = pt.onError) == null || Vt.call(pt, Ut);
        }
      }, {
        emitOnBegin: !0,
        interval: Re
      });
      return async () => {
        yt && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: yt }), It();
      };
    });
  })() : (() => {
    const qe = je ?? !1, Ye = stringify([
      "watchContractEvent",
      fe,
      ye,
      ve,
      ne.uid,
      _e,
      Re,
      qe
    ]);
    let pt = !0, dt = () => pt = !1;
    return observe(Ye, { onLogs: $e, onError: Oe }, (yt) => ((async () => {
      try {
        const Ct = _e ? encodeEventTopics({
          abi: ae,
          eventName: _e,
          args: ye
        }) : [], { unsubscribe: It } = await ne.transport.subscribe({
          params: ["logs", { address: fe, topics: Ct }],
          onData(Vt) {
            var Zt;
            if (!pt)
              return;
            const Ut = Vt.result;
            try {
              const { eventName: tr, args: er } = decodeEventLog({
                abi: ae,
                data: Ut.data,
                topics: Ut.topics,
                strict: je
              }), hr = formatLog(Ut, {
                args: er,
                eventName: tr
              });
              yt.onLogs([hr]);
            } catch (tr) {
              let er, hr;
              if (tr instanceof DecodeLogDataMismatch || tr instanceof DecodeLogTopicsMismatch) {
                if (je)
                  return;
                er = tr.abiItem.name, hr = (Zt = tr.abiItem.inputs) == null ? void 0 : Zt.some((Qe) => !("name" in Qe && Qe.name));
              }
              const Ot = formatLog(Ut, {
                args: hr ? [] : {},
                eventName: er
              });
              yt.onLogs([Ot]);
            }
          },
          onError(Vt) {
            var Ut;
            (Ut = yt.onError) == null || Ut.call(yt, Vt);
          }
        });
        dt = It, pt || dt();
      } catch (Ct) {
        Oe == null || Oe(Ct);
      }
    })(), () => dt()));
  })();
}
function assertCurrentChain({ chain: ne, currentChainId: oe }) {
  if (!ne)
    throw new ChainNotFoundError();
  if (oe !== ne.id)
    throw new ChainMismatchError({ chain: ne, currentChainId: oe });
}
function getTransactionError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new TransactionExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
async function sendRawTransaction(ne, { serializedTransaction: oe }) {
  return ne.request({
    method: "eth_sendRawTransaction",
    params: [oe]
  }, { retryCount: 0 });
}
async function sendTransaction(ne, oe) {
  var Ye, pt, dt, yt;
  const { account: ae = ne.account, chain: fe = ne.chain, accessList: ye, blobs: ve, data: _e, gas: xe, gasPrice: Oe, maxFeePerBlobGas: $e, maxFeePerGas: Me, maxPriorityFeePerGas: Re, nonce: je, to: Be, value: ze, ...He } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const qe = parseAccount(ae);
  try {
    assertRequest(oe);
    let Ct;
    if (fe !== null && (Ct = await getAction(ne, getChainId, "getChainId")({}), assertCurrentChain({
      currentChainId: Ct,
      chain: fe
    })), qe.type === "local") {
      const Zt = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({
        account: qe,
        accessList: ye,
        blobs: ve,
        chain: fe,
        chainId: Ct,
        data: _e,
        gas: xe,
        gasPrice: Oe,
        maxFeePerBlobGas: $e,
        maxFeePerGas: Me,
        maxPriorityFeePerGas: Re,
        nonce: je,
        parameters: [...defaultParameters, "sidecars"],
        to: Be,
        value: ze,
        ...He
      }), tr = (Ye = fe == null ? void 0 : fe.serializers) == null ? void 0 : Ye.transaction, er = await qe.signTransaction(Zt, {
        serializer: tr
      });
      return await getAction(ne, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction: er
      });
    }
    const It = (yt = (dt = (pt = ne.chain) == null ? void 0 : pt.formatters) == null ? void 0 : dt.transactionRequest) == null ? void 0 : yt.format, Ut = (It || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(He, { format: It }),
      accessList: ye,
      blobs: ve,
      data: _e,
      from: qe.address,
      gas: xe,
      gasPrice: Oe,
      maxFeePerBlobGas: $e,
      maxFeePerGas: Me,
      maxPriorityFeePerGas: Re,
      nonce: je,
      to: Be,
      value: ze
    });
    return await ne.request({
      method: "eth_sendTransaction",
      params: [Ut]
    }, { retryCount: 0 });
  } catch (Ct) {
    throw getTransactionError(Ct, {
      ...oe,
      account: qe,
      chain: oe.chain || void 0
    });
  }
}
async function writeContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: ve, functionName: _e, ...xe } = oe, Oe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: _e
  });
  return getAction(ne, sendTransaction, "sendTransaction")({
    data: `${Oe}${ve ? ve.replace("0x", "") : ""}`,
    to: fe,
    ...xe
  });
}
function getContract({ abi: ne, address: oe, client: ae }) {
  const fe = ae, [ye, ve] = (() => fe ? "public" in fe && "wallet" in fe ? [fe.public, fe.wallet] : "public" in fe ? [fe.public, void 0] : "wallet" in fe ? [void 0, fe.wallet] : [fe, fe] : [void 0, void 0])(), _e = ye != null, xe = ve != null, Oe = {};
  let $e = !1, Me = !1, Re = !1;
  for (const je of ne)
    if (je.type === "function" ? je.stateMutability === "view" || je.stateMutability === "pure" ? $e = !0 : Me = !0 : je.type === "event" && (Re = !0), $e && Me && Re)
      break;
  return _e && ($e && (Oe.read = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye, readContract, "readContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), Me && (Oe.simulate = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye, simulateContract, "simulateContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), Re && (Oe.createEventFilter = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((pt) => pt.type === "event" && pt.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, createContractEventFilter, "createContractEventFilter")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }), Oe.getEvents = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((pt) => pt.type === "event" && pt.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, getContractEvents, "getContractEvents")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }), Oe.watchEvent = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((pt) => pt.type === "event" && pt.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, watchContractEvent, "watchContractEvent")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }))), xe && Me && (Oe.write = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ve, writeContract, "writeContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), (_e || xe) && Me && (Oe.estimateGas = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye ?? ve, estimateContractGas, "estimateContractGas")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe,
          account: qe.account ?? ve.account
        });
      };
    }
  })), Oe.address = oe, Oe.abi = ne, Oe;
}
function getFunctionParameters(ne) {
  const oe = ne.length && Array.isArray(ne[0]), ae = oe ? ne[0] : [], fe = (oe ? ne[1] : ne[0]) ?? {};
  return { args: ae, options: fe };
}
function getEventParameters(ne, oe) {
  let ae = !1;
  Array.isArray(ne[0]) ? ae = !0 : ne.length === 1 ? ae = oe.inputs.some((ve) => ve.indexed) : ne.length === 2 && (ae = !0);
  const fe = ae ? ne[0] : void 0, ye = (ae ? ne[1] : ne[0]) ?? {};
  return { args: fe, options: ye };
}
async function addChain(ne, { chain: oe }) {
  const { id: ae, name: fe, nativeCurrency: ye, rpcUrls: ve, blockExplorers: _e } = oe;
  await ne.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(ae),
        chainName: fe,
        nativeCurrency: ye,
        rpcUrls: ve.default.http,
        blockExplorerUrls: _e ? Object.values(_e).map(({ url: xe }) => xe) : void 0
      }
    ]
  }, { retryCount: 0 });
}
function publicKeyToAddress(ne) {
  const oe = keccak256(`0x${ne.substring(4)}`).substring(26);
  return checksumAddress(`0x${oe}`);
}
const size$1 = 256;
let index = size$1, buffer;
function uid(ne = 11) {
  if (!buffer || index + ne > size$1 * 2) {
    buffer = "", index = 0;
    for (let oe = 0; oe < size$1; oe++)
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer.substring(index, index++ + ne);
}
function createClient$1(ne) {
  const { batch: oe, cacheTime: ae = ne.pollingInterval ?? 4e3, ccipRead: fe, key: ye = "base", name: ve = "Base Client", pollingInterval: _e = 4e3, type: xe = "base" } = ne, Oe = ne.chain, $e = ne.account ? parseAccount(ne.account) : void 0, { config: Me, request: Re, value: je } = ne.transport({
    chain: Oe,
    pollingInterval: _e
  }), Be = { ...Me, ...je }, ze = {
    account: $e,
    batch: oe,
    cacheTime: ae,
    ccipRead: fe,
    chain: Oe,
    key: ye,
    name: ve,
    pollingInterval: _e,
    request: Re,
    transport: Be,
    type: xe,
    uid: uid()
  };
  function He(qe) {
    return (Ye) => {
      const pt = Ye(qe);
      for (const yt in ze)
        delete pt[yt];
      const dt = { ...qe, ...pt };
      return Object.assign(dt, { extend: He(dt) });
    };
  }
  return Object.assign(ze, { extend: He(ze) });
}
function withRetry(ne, { delay: oe = 100, retryCount: ae = 2, shouldRetry: fe = () => !0 } = {}) {
  return new Promise((ye, ve) => {
    const _e = async ({ count: xe = 0 } = {}) => {
      const Oe = async ({ error: $e }) => {
        const Me = typeof oe == "function" ? oe({ count: xe, error: $e }) : oe;
        Me && await wait(Me), _e({ count: xe + 1 });
      };
      try {
        const $e = await ne();
        ye($e);
      } catch ($e) {
        if (xe < ae && await fe({ count: xe, error: $e }))
          return Oe({ error: $e });
        ve($e);
      }
    };
    _e();
  });
}
function buildRequest(ne, oe = {}) {
  return async (ae, fe = {}) => {
    const { retryDelay: ye = 150, retryCount: ve = 3 } = {
      ...oe,
      ...fe
    };
    return withRetry(async () => {
      try {
        return await ne(ae);
      } catch (_e) {
        const xe = _e;
        switch (xe.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(xe);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(xe);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(xe);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(xe);
          case InternalRpcError.code:
            throw new InternalRpcError(xe);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(xe);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(xe);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(xe);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(xe);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(xe);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(xe);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(xe);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(xe);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(xe);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(xe);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(xe);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(xe);
          case SwitchChainError.code:
            throw new SwitchChainError(xe);
          case 5e3:
            throw new UserRejectedRequestError(xe);
          default:
            throw _e instanceof BaseError$1 ? _e : new UnknownRpcError(xe);
        }
      }
    }, {
      delay: ({ count: _e, error: xe }) => {
        var Oe;
        if (xe && xe instanceof HttpRequestError) {
          const $e = (Oe = xe == null ? void 0 : xe.headers) == null ? void 0 : Oe.get("Retry-After");
          if ($e != null && $e.match(/\d/))
            return parseInt($e) * 1e3;
        }
        return ~~(1 << _e) * ye;
      },
      retryCount: ve,
      shouldRetry: ({ error: _e }) => shouldRetry(_e)
    });
  };
}
function shouldRetry(ne) {
  return "code" in ne && typeof ne.code == "number" ? ne.code === -1 || ne.code === LimitExceededRpcError.code || ne.code === InternalRpcError.code : ne instanceof HttpRequestError && ne.status ? ne.status === 403 || ne.status === 408 || ne.status === 413 || ne.status === 429 || ne.status === 500 || ne.status === 502 || ne.status === 503 || ne.status === 504 : !0;
}
function createTransport({ key: ne, name: oe, request: ae, retryCount: fe = 3, retryDelay: ye = 150, timeout: ve, type: _e }, xe) {
  return {
    config: { key: ne, name: oe, request: ae, retryCount: fe, retryDelay: ye, timeout: ve, type: _e },
    request: buildRequest(ae, { retryCount: fe, retryDelay: ye }),
    value: xe
  };
}
function fallback(ne, oe = {}) {
  const { key: ae = "fallback", name: fe = "Fallback", rank: ye = !1, retryCount: ve, retryDelay: _e } = oe;
  return ({ chain: xe, pollingInterval: Oe = 4e3, timeout: $e, ...Me }) => {
    let Re = ne, je = () => {
    };
    const Be = createTransport({
      key: ae,
      name: fe,
      async request({ method: ze, params: He }) {
        const qe = async (Ye = 0) => {
          const pt = Re[Ye]({
            ...Me,
            chain: xe,
            retryCount: 0,
            timeout: $e
          });
          try {
            const dt = await pt.request({
              method: ze,
              params: He
            });
            return je({
              method: ze,
              params: He,
              response: dt,
              transport: pt,
              status: "success"
            }), dt;
          } catch (dt) {
            if (je({
              error: dt,
              method: ze,
              params: He,
              transport: pt,
              status: "error"
            }), shouldThrow(dt) || Ye === Re.length - 1)
              throw dt;
            return qe(Ye + 1);
          }
        };
        return qe();
      },
      retryCount: ve,
      retryDelay: _e,
      type: "fallback"
    }, {
      onResponse: (ze) => je = ze,
      transports: Re.map((ze) => ze({ chain: xe, retryCount: 0 }))
    });
    if (ye) {
      const ze = typeof ye == "object" ? ye : {};
      rankTransports({
        chain: xe,
        interval: ze.interval ?? Oe,
        onTransports: (He) => Re = He,
        sampleCount: ze.sampleCount,
        timeout: ze.timeout,
        transports: Re,
        weights: ze.weights
      });
    }
    return Be;
  };
}
function shouldThrow(ne) {
  return "code" in ne && typeof ne.code == "number" && (ne.code === TransactionRejectedRpcError.code || ne.code === UserRejectedRequestError.code || ne.code === 5e3);
}
function rankTransports({ chain: ne, interval: oe = 4e3, onTransports: ae, sampleCount: fe = 10, timeout: ye = 1e3, transports: ve, weights: _e = {} }) {
  const { stability: xe = 0.7, latency: Oe = 0.3 } = _e, $e = [], Me = async () => {
    const Re = await Promise.all(ve.map(async (ze) => {
      const He = ze({ chain: ne, retryCount: 0, timeout: ye }), qe = Date.now();
      let Ye, pt;
      try {
        await He.request({ method: "net_listening" }), pt = 1;
      } catch {
        pt = 0;
      } finally {
        Ye = Date.now();
      }
      return { latency: Ye - qe, success: pt };
    }));
    $e.push(Re), $e.length > fe && $e.shift();
    const je = Math.max(...$e.map((ze) => Math.max(...ze.map(({ latency: He }) => He)))), Be = ve.map((ze, He) => {
      const qe = $e.map((Ct) => Ct[He].latency), pt = 1 - qe.reduce((Ct, It) => Ct + It, 0) / qe.length / je, dt = $e.map((Ct) => Ct[He].success), yt = dt.reduce((Ct, It) => Ct + It, 0) / dt.length;
      return yt === 0 ? [0, He] : [
        Oe * pt + xe * yt,
        He
      ];
    }).sort((ze, He) => He[0] - ze[0]);
    ae(Be.map(([, ze]) => ve[ze])), await wait(oe), Me();
  };
  Me();
}
class UrlRequiredError extends BaseError$1 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function withTimeout(ne, { errorInstance: oe = new Error("timed out"), timeout: ae, signal: fe }) {
  return new Promise((ye, ve) => {
    (async () => {
      let _e;
      try {
        const xe = new AbortController();
        ae > 0 && (_e = setTimeout(() => {
          fe ? xe.abort() : ve(oe);
        }, ae)), ye(await ne({ signal: (xe == null ? void 0 : xe.signal) || null }));
      } catch (xe) {
        xe.name === "AbortError" && ve(oe), ve(xe);
      } finally {
        clearTimeout(_e);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(ne, oe = {}) {
  return {
    async request(ae) {
      var Re;
      const { body: fe, fetchOptions: ye = {}, onRequest: ve = oe.onRequest, onResponse: _e = oe.onResponse, timeout: xe = oe.timeout ?? 1e4 } = ae, { headers: Oe, method: $e, signal: Me } = { ...oe.fetchOptions, ...ye };
      try {
        const je = await withTimeout(async ({ signal: ze }) => {
          const He = {
            ...ye,
            body: Array.isArray(fe) ? stringify(fe.map((pt) => ({
              jsonrpc: "2.0",
              id: pt.id ?? idCache.take(),
              ...pt
            }))) : stringify({
              jsonrpc: "2.0",
              id: fe.id ?? idCache.take(),
              ...fe
            }),
            headers: {
              ...Oe,
              "Content-Type": "application/json"
            },
            method: $e || "POST",
            signal: Me || (xe > 0 ? ze : null)
          }, qe = new Request(ne, He);
          return ve && await ve(qe), await fetch(ne, He);
        }, {
          errorInstance: new TimeoutError$1({ body: fe, url: ne }),
          timeout: xe,
          signal: !0
        });
        _e && await _e(je);
        let Be;
        if ((Re = je.headers.get("Content-Type")) != null && Re.startsWith("application/json") ? Be = await je.json() : Be = await je.text(), !je.ok)
          throw new HttpRequestError({
            body: fe,
            details: stringify(Be.error) || je.statusText,
            headers: je.headers,
            status: je.status,
            url: ne
          });
        return Be;
      } catch (je) {
        throw je instanceof HttpRequestError || je instanceof TimeoutError$1 ? je : new HttpRequestError({
          body: fe,
          details: je.message,
          url: ne
        });
      }
    }
  };
}
function http(ne, oe = {}) {
  const { batch: ae, fetchOptions: fe, key: ye = "http", name: ve = "HTTP JSON-RPC", onFetchRequest: _e, onFetchResponse: xe, retryDelay: Oe } = oe;
  return ({ chain: $e, retryCount: Me, timeout: Re }) => {
    const { batchSize: je = 1e3, wait: Be = 0 } = typeof ae == "object" ? ae : {}, ze = oe.retryCount ?? Me, He = Re ?? oe.timeout ?? 1e4, qe = ne || ($e == null ? void 0 : $e.rpcUrls.default.http[0]);
    if (!qe)
      throw new UrlRequiredError();
    const Ye = getHttpRpcClient(qe, {
      fetchOptions: fe,
      onRequest: _e,
      onResponse: xe,
      timeout: He
    });
    return createTransport({
      key: ye,
      name: ve,
      async request({ method: pt, params: dt }) {
        const yt = { method: pt, params: dt }, { schedule: Ct } = createBatchScheduler({
          id: `${ne}`,
          wait: Be,
          shouldSplitBatch(Zt) {
            return Zt.length > je;
          },
          fn: (Zt) => Ye.request({
            body: Zt
          }),
          sort: (Zt, tr) => Zt.id - tr.id
        }), It = async (Zt) => ae ? Ct(Zt) : [
          await Ye.request({
            body: Zt
          })
        ], [{ error: Vt, result: Ut }] = await It(yt);
        if (Vt)
          throw new RpcRequestError({
            body: yt,
            error: Vt,
            url: qe
          });
        return Ut;
      },
      retryCount: ze,
      retryDelay: Oe,
      timeout: He,
      type: "http"
    }, {
      fetchOptions: fe,
      url: qe
    });
  };
}
function isNullUniversalResolverError(ne, oe) {
  var fe, ye, ve, _e, xe, Oe;
  if (!(ne instanceof BaseError$1))
    return !1;
  const ae = ne.walk(($e) => $e instanceof ContractFunctionRevertedError);
  return ae instanceof ContractFunctionRevertedError ? !!(((fe = ae.data) == null ? void 0 : fe.errorName) === "ResolverNotFound" || ((ye = ae.data) == null ? void 0 : ye.errorName) === "ResolverWildcardNotSupported" || ((ve = ae.data) == null ? void 0 : ve.errorName) === "ResolverNotContract" || ((_e = ae.data) == null ? void 0 : _e.errorName) === "ResolverError" || ((xe = ae.data) == null ? void 0 : xe.errorName) === "HttpError" || (Oe = ae.reason) != null && Oe.includes("Wildcard on non-extended resolvers is not supported") || oe === "reverse" && ae.reason === panicReasons[50]) : !1;
}
function encodedLabelToLabelhash(ne) {
  if (ne.length !== 66 || ne.indexOf("[") !== 0 || ne.indexOf("]") !== 65)
    return null;
  const oe = `0x${ne.slice(1, 65)}`;
  return isHex$1(oe) ? oe : null;
}
function namehash(ne) {
  let oe = new Uint8Array(32).fill(0);
  if (!ne)
    return bytesToHex$2(oe);
  const ae = ne.split(".");
  for (let fe = ae.length - 1; fe >= 0; fe -= 1) {
    const ye = encodedLabelToLabelhash(ae[fe]), ve = ye ? toBytes$1(ye) : keccak256(stringToBytes(ae[fe]), "bytes");
    oe = keccak256(concat$1([oe, ve]), "bytes");
  }
  return bytesToHex$2(oe);
}
function encodeLabelhash(ne) {
  return `[${ne.slice(2)}]`;
}
function labelhash(ne) {
  const oe = new Uint8Array(32).fill(0);
  return ne ? encodedLabelToLabelhash(ne) || keccak256(stringToBytes(ne)) : bytesToHex$2(oe);
}
function packetToBytes(ne) {
  const oe = ne.replace(/^\.|\.$/gm, "");
  if (oe.length === 0)
    return new Uint8Array(1);
  const ae = new Uint8Array(stringToBytes(oe).byteLength + 2);
  let fe = 0;
  const ye = oe.split(".");
  for (let ve = 0; ve < ye.length; ve++) {
    let _e = stringToBytes(ye[ve]);
    _e.byteLength > 255 && (_e = stringToBytes(encodeLabelhash(labelhash(ye[ve])))), ae[fe] = _e.length, ae.set(_e, fe + 1), fe += _e.length + 1;
  }
  return ae.byteLength !== fe + 1 ? ae.slice(0, fe + 1) : ae;
}
async function getEnsAddress(ne, { blockNumber: oe, blockTag: ae, coinType: fe, name: ye, gatewayUrls: ve, strict: _e, universalResolverAddress: xe }) {
  let Oe = xe;
  if (!Oe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Oe = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const $e = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...fe != null ? { args: [namehash(ye), BigInt(fe)] } : { args: [namehash(ye)] }
    }), Me = {
      address: Oe,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex$1(packetToBytes(ye)), $e],
      blockNumber: oe,
      blockTag: ae
    }, Re = getAction(ne, readContract, "readContract"), je = ve ? await Re({
      ...Me,
      args: [...Me.args, ve]
    }) : await Re(Me);
    if (je[0] === "0x")
      return null;
    const Be = decodeFunctionResult({
      abi: addressResolverAbi,
      args: fe != null ? [namehash(ye), BigInt(fe)] : void 0,
      functionName: "addr",
      data: je[0]
    });
    return Be === "0x" || trim(Be) === "0x00" ? null : Be;
  } catch ($e) {
    if (_e)
      throw $e;
    if (isNullUniversalResolverError($e, "resolve"))
      return null;
    throw $e;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$1 {
  constructor({ data: oe }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(oe)}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$1 {
  constructor({ reason: oe }) {
    super(`ENS NFT avatar URI is invalid. ${oe}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$1 {
  constructor({ uri: oe }) {
    super(`Unable to resolve ENS avatar URI "${oe}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$1 {
  constructor({ namespace: oe }) {
    super(`ENS NFT avatar namespace "${oe}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, base64Regex$1 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(ne) {
  try {
    const oe = await fetch(ne, { method: "HEAD" });
    if (oe.status === 200) {
      const ae = oe.headers.get("content-type");
      return ae == null ? void 0 : ae.startsWith("image/");
    }
    return !1;
  } catch (oe) {
    return typeof oe == "object" && typeof oe.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((ae) => {
      const fe = new Image();
      fe.onload = () => {
        ae(!0);
      }, fe.onerror = () => {
        ae(!1);
      }, fe.src = ne;
    });
  }
}
function getGateway(ne, oe) {
  return ne ? ne.endsWith("/") ? ne.slice(0, -1) : ne : oe;
}
function resolveAvatarUri({ uri: ne, gatewayUrls: oe }) {
  const ae = base64Regex$1.test(ne);
  if (ae)
    return { uri: ne, isOnChain: !0, isEncoded: ae };
  const fe = getGateway(oe == null ? void 0 : oe.ipfs, "https://ipfs.io"), ye = getGateway(oe == null ? void 0 : oe.arweave, "https://arweave.net"), ve = ne.match(networkRegex), { protocol: _e, subpath: xe, target: Oe, subtarget: $e = "" } = (ve == null ? void 0 : ve.groups) || {}, Me = _e === "ipns:/" || xe === "ipns/", Re = _e === "ipfs:/" || xe === "ipfs/" || ipfsHashRegex.test(ne);
  if (ne.startsWith("http") && !Me && !Re) {
    let Be = ne;
    return oe != null && oe.arweave && (Be = ne.replace(/https:\/\/arweave.net/g, oe == null ? void 0 : oe.arweave)), { uri: Be, isOnChain: !1, isEncoded: !1 };
  }
  if ((Me || Re) && Oe)
    return {
      uri: `${fe}/${Me ? "ipns" : "ipfs"}/${Oe}${$e}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (_e === "ar:/" && Oe)
    return {
      uri: `${ye}/${Oe}${$e || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let je = ne.replace(dataURIRegex, "");
  if (je.startsWith("<svg") && (je = `data:image/svg+xml;base64,${btoa(je)}`), je.startsWith("data:") || je.startsWith("{"))
    return {
      uri: je,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new EnsAvatarUriResolutionError({ uri: ne });
}
function getJsonImage(ne) {
  if (typeof ne != "object" || !("image" in ne) && !("image_url" in ne) && !("image_data" in ne))
    throw new EnsAvatarInvalidMetadataError({ data: ne });
  return ne.image || ne.image_url || ne.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls: ne, uri: oe }) {
  try {
    const ae = await fetch(oe).then((ye) => ye.json());
    return await parseAvatarUri({
      gatewayUrls: ne,
      uri: getJsonImage(ae)
    });
  } catch {
    throw new EnsAvatarUriResolutionError({ uri: oe });
  }
}
async function parseAvatarUri({ gatewayUrls: ne, uri: oe }) {
  const { uri: ae, isOnChain: fe } = resolveAvatarUri({ uri: oe, gatewayUrls: ne });
  if (fe || await isImageUri(ae))
    return ae;
  throw new EnsAvatarUriResolutionError({ uri: oe });
}
function parseNftUri(ne) {
  let oe = ne;
  oe.startsWith("did:nft:") && (oe = oe.replace("did:nft:", "").replace(/_/g, "/"));
  const [ae, fe, ye] = oe.split("/"), [ve, _e] = ae.split(":"), [xe, Oe] = fe.split(":");
  if (!ve || ve.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!_e)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!Oe)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!ye)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!xe)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(_e),
    namespace: xe.toLowerCase(),
    contractAddress: Oe,
    tokenID: ye
  };
}
async function getNftTokenUri(ne, { nft: oe }) {
  if (oe.namespace === "erc721")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(oe.tokenID)]
    });
  if (oe.namespace === "erc1155")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(oe.tokenID)]
    });
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: oe.namespace });
}
async function parseAvatarRecord(ne, { gatewayUrls: oe, record: ae }) {
  return /eip155:/i.test(ae) ? parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) : parseAvatarUri({ uri: ae, gatewayUrls: oe });
}
async function parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) {
  const fe = parseNftUri(ae), ye = await getNftTokenUri(ne, { nft: fe }), { uri: ve, isOnChain: _e, isEncoded: xe } = resolveAvatarUri({ uri: ye, gatewayUrls: oe });
  if (_e && (ve.includes("data:application/json;base64,") || ve.startsWith("{"))) {
    const $e = xe ? (
      // if it is encoded, decode it
      atob(ve.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      ve
    ), Me = JSON.parse($e);
    return parseAvatarUri({ uri: getJsonImage(Me), gatewayUrls: oe });
  }
  let Oe = fe.tokenID;
  return fe.namespace === "erc1155" && (Oe = Oe.replace("0x", "").padStart(64, "0")), getMetadataAvatarUri({
    gatewayUrls: oe,
    uri: ve.replace(/(?:0x)?{id}/, Oe)
  });
}
async function getEnsText(ne, { blockNumber: oe, blockTag: ae, name: fe, key: ye, gatewayUrls: ve, strict: _e, universalResolverAddress: xe }) {
  let Oe = xe;
  if (!Oe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Oe = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const $e = {
      address: Oe,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex$1(packetToBytes(fe)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(fe), ye]
        })
      ],
      blockNumber: oe,
      blockTag: ae
    }, Me = getAction(ne, readContract, "readContract"), Re = ve ? await Me({
      ...$e,
      args: [...$e.args, ve]
    }) : await Me($e);
    if (Re[0] === "0x")
      return null;
    const je = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: Re[0]
    });
    return je === "" ? null : je;
  } catch ($e) {
    if (_e)
      throw $e;
    if (isNullUniversalResolverError($e, "resolve"))
      return null;
    throw $e;
  }
}
async function getEnsAvatar(ne, { blockNumber: oe, blockTag: ae, assetGatewayUrls: fe, name: ye, gatewayUrls: ve, strict: _e, universalResolverAddress: xe }) {
  const Oe = await getAction(ne, getEnsText, "getEnsText")({
    blockNumber: oe,
    blockTag: ae,
    key: "avatar",
    name: ye,
    universalResolverAddress: xe,
    gatewayUrls: ve,
    strict: _e
  });
  if (!Oe)
    return null;
  try {
    return await parseAvatarRecord(ne, {
      record: Oe,
      gatewayUrls: fe
    });
  } catch {
    return null;
  }
}
async function getEnsName(ne, { address: oe, blockNumber: ae, blockTag: fe, gatewayUrls: ye, strict: ve, universalResolverAddress: _e }) {
  let xe = _e;
  if (!xe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    xe = getChainContractAddress({
      blockNumber: ae,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const Oe = `${oe.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const $e = {
      address: xe,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex$1(packetToBytes(Oe))],
      blockNumber: ae,
      blockTag: fe
    }, Me = getAction(ne, readContract, "readContract"), [Re, je] = ye ? await Me({
      ...$e,
      args: [...$e.args, ye]
    }) : await Me($e);
    return oe.toLowerCase() !== je.toLowerCase() ? null : Re;
  } catch ($e) {
    if (ve)
      throw $e;
    if (isNullUniversalResolverError($e, "reverse"))
      return null;
    throw $e;
  }
}
async function getEnsResolver(ne, { blockNumber: oe, blockTag: ae, name: fe, universalResolverAddress: ye }) {
  let ve = ye;
  if (!ve) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    ve = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [_e] = await getAction(ne, readContract, "readContract")({
    address: ve,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex$1(packetToBytes(fe))],
    blockNumber: oe,
    blockTag: ae
  });
  return _e;
}
async function createBlockFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newBlockFilter"
  }), ae = await ne.request({
    method: "eth_newBlockFilter"
  });
  return { id: ae, request: oe(ae), type: "block" };
}
async function createEventFilter(ne, { address: oe, args: ae, event: fe, events: ye, fromBlock: ve, strict: _e, toBlock: xe } = {}) {
  const Oe = ye ?? (fe ? [fe] : void 0), $e = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  });
  let Me = [];
  Oe && (Me = [
    Oe.flatMap((je) => encodeEventTopics({
      abi: [je],
      eventName: je.name,
      args: ae
    }))
  ], fe && (Me = Me[0]));
  const Re = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: oe,
        fromBlock: typeof ve == "bigint" ? numberToHex(ve) : ve,
        toBlock: typeof xe == "bigint" ? numberToHex(xe) : xe,
        ...Me.length ? { topics: Me } : {}
      }
    ]
  });
  return {
    abi: Oe,
    args: ae,
    eventName: fe ? fe.name : void 0,
    fromBlock: ve,
    id: Re,
    request: $e(Re),
    strict: !!_e,
    toBlock: xe,
    type: "event"
  };
}
async function createPendingTransactionFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newPendingTransactionFilter"
  }), ae = await ne.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: ae, request: oe(ae), type: "transaction" };
}
async function getBalance(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae ? numberToHex(ae) : void 0, ve = await ne.request({
    method: "eth_getBalance",
    params: [oe, ye || fe]
  });
  return BigInt(ve);
}
async function getBlobBaseFee(ne) {
  const oe = await ne.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(oe);
}
async function getBlockTransactionCount(ne, { blockHash: oe, blockNumber: ae, blockTag: fe = "latest" } = {}) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0;
  let ve;
  return oe ? ve = await ne.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [oe]
  }) : ve = await ne.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [ye || fe]
  }), hexToNumber$1(ve);
}
async function getBytecode(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0, ve = await ne.request({
    method: "eth_getCode",
    params: [oe, ye || fe]
  });
  if (ve !== "0x")
    return ve;
}
function formatFeeHistory(ne) {
  var oe;
  return {
    baseFeePerGas: ne.baseFeePerGas.map((ae) => BigInt(ae)),
    gasUsedRatio: ne.gasUsedRatio,
    oldestBlock: BigInt(ne.oldestBlock),
    reward: (oe = ne.reward) == null ? void 0 : oe.map((ae) => ae.map((fe) => BigInt(fe)))
  };
}
async function getFeeHistory(ne, { blockCount: oe, blockNumber: ae, blockTag: fe = "latest", rewardPercentiles: ye }) {
  const ve = ae ? numberToHex(ae) : void 0, _e = await ne.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(oe),
      ve || fe,
      ye
    ]
  });
  return formatFeeHistory(_e);
}
async function getFilterLogs(ne, { filter: oe }) {
  const ae = oe.strict ?? !1, ye = (await oe.request({
    method: "eth_getFilterLogs",
    params: [oe.id]
  })).map((ve) => formatLog(ve));
  return oe.abi ? parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  }) : ye;
}
function defineChain(ne) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...ne
  };
}
const arrayRegex = /^(.*)\[([0-9]*)\]$/, bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, socketClientCache = /* @__PURE__ */ new Map();
async function getSocketRpcClient(ne) {
  const { getSocket: oe, reconnect: ae = !0, url: fe } = ne, { attempts: ye = 5, delay: ve = 2e3 } = typeof ae == "object" ? ae : {};
  let _e = socketClientCache.get(fe);
  if (_e)
    return _e;
  let xe = 0;
  const { schedule: Oe } = createBatchScheduler({
    id: fe,
    fn: async () => {
      const Re = /* @__PURE__ */ new Map(), je = /* @__PURE__ */ new Map();
      let Be, ze;
      async function He() {
        return oe({
          onError(qe) {
            var Ye, pt;
            Be = qe;
            for (const dt of Re.values())
              (Ye = dt.onError) == null || Ye.call(dt, Be);
            for (const dt of je.values())
              (pt = dt.onError) == null || pt.call(dt, Be);
            Re.clear(), je.clear(), ae && xe < ye && setTimeout(async () => {
              xe++, ze = await He().catch(console.error);
            }, ve);
          },
          onOpen() {
            Be = void 0, xe = 0;
          },
          onResponse(qe) {
            const Ye = qe.method === "eth_subscription", pt = Ye ? qe.params.subscription : qe.id, dt = Ye ? je : Re, yt = dt.get(pt);
            yt && yt.onResponse(qe), Ye || dt.delete(pt);
          }
        });
      }
      return ze = await He(), Be = void 0, _e = {
        close() {
          ze.close(), socketClientCache.delete(fe);
        },
        socket: ze,
        request({ body: qe, onError: Ye, onResponse: pt }) {
          Be && Ye && Ye(Be);
          const dt = qe.id ?? idCache.take(), yt = (Ct) => {
            var It;
            typeof Ct.id == "number" && dt !== Ct.id || (qe.method === "eth_subscribe" && typeof Ct.result == "string" && je.set(Ct.result, {
              onResponse: yt,
              onError: Ye
            }), qe.method === "eth_unsubscribe" && je.delete((It = qe.params) == null ? void 0 : It[0]), pt(Ct));
          };
          Re.set(dt, { onResponse: yt, onError: Ye });
          try {
            ze.request({
              body: {
                jsonrpc: "2.0",
                id: dt,
                ...qe
              }
            });
          } catch (Ct) {
            Ye == null || Ye(Ct);
          }
        },
        requestAsync({ body: qe, timeout: Ye = 1e4 }) {
          return withTimeout(() => new Promise((pt, dt) => this.request({
            body: qe,
            onError: dt,
            onResponse: pt
          })), {
            errorInstance: new TimeoutError$1({ body: qe, url: fe }),
            timeout: Ye
          });
        },
        requests: Re,
        subscriptions: je,
        url: fe
      }, socketClientCache.set(fe, _e), [_e];
    }
  }), [$e, [Me]] = await Oe();
  return Me;
}
async function getWebSocketRpcClient(ne, oe = {}) {
  const { reconnect: ae } = oe;
  return getSocketRpcClient({
    async getSocket({ onError: fe, onOpen: ye, onResponse: ve }) {
      const _e = await import("./native-15074a2a.js").then((Re) => Re.WebSocket), xe = new _e(ne);
      function Oe() {
        xe.removeEventListener("close", Oe), xe.removeEventListener("message", $e), xe.removeEventListener("error", fe), xe.removeEventListener("open", ye);
      }
      function $e({ data: Re }) {
        ve(JSON.parse(Re));
      }
      xe.addEventListener("close", Oe), xe.addEventListener("message", $e), xe.addEventListener("error", fe), xe.addEventListener("open", ye), xe.readyState === _e.CONNECTING && await new Promise((Re, je) => {
        xe && (xe.onopen = Re, xe.onerror = je);
      });
      const { close: Me } = xe;
      return Object.assign(xe, {
        close() {
          Me.bind(xe)(), Oe();
        },
        request({ body: Re }) {
          if (xe.readyState === xe.CLOSED || xe.readyState === xe.CLOSING)
            throw new WebSocketRequestError({
              body: Re,
              url: xe.url,
              details: "Socket is closed."
            });
          return xe.send(JSON.stringify(Re));
        }
      });
    },
    reconnect: ae,
    url: ne
  });
}
async function getSocket(ne) {
  const oe = await getWebSocketRpcClient(ne);
  return Object.assign(oe.socket, {
    requests: oe.requests,
    subscriptions: oe.subscriptions
  });
}
function hashTypedData(ne) {
  const { domain: oe = {}, message: ae, primaryType: fe } = ne, ye = {
    EIP712Domain: getTypesForEIP712Domain({ domain: oe }),
    ...ne.types
  };
  validateTypedData({
    domain: oe,
    message: ae,
    primaryType: fe,
    types: ye
  });
  const ve = ["0x1901"];
  return oe && ve.push(hashDomain({
    domain: oe,
    types: ye
  })), fe !== "EIP712Domain" && ve.push(hashStruct({
    data: ae,
    primaryType: fe,
    types: ye
  })), keccak256(concat$1(ve));
}
function hashDomain({ domain: ne, types: oe }) {
  return hashStruct({
    data: ne,
    primaryType: "EIP712Domain",
    types: oe
  });
}
function hashStruct({ data: ne, primaryType: oe, types: ae }) {
  const fe = encodeData({
    data: ne,
    primaryType: oe,
    types: ae
  });
  return keccak256(fe);
}
function encodeData({ data: ne, primaryType: oe, types: ae }) {
  const fe = [{ type: "bytes32" }], ye = [hashType({ primaryType: oe, types: ae })];
  for (const ve of ae[oe]) {
    const [_e, xe] = encodeField({
      types: ae,
      name: ve.name,
      type: ve.type,
      value: ne[ve.name]
    });
    fe.push(_e), ye.push(xe);
  }
  return encodeAbiParameters(fe, ye);
}
function hashType({ primaryType: ne, types: oe }) {
  const ae = toHex$1(encodeType({ primaryType: ne, types: oe }));
  return keccak256(ae);
}
function encodeType({ primaryType: ne, types: oe }) {
  let ae = "";
  const fe = findTypeDependencies({ primaryType: ne, types: oe });
  fe.delete(ne);
  const ye = [ne, ...Array.from(fe).sort()];
  for (const ve of ye)
    ae += `${ve}(${oe[ve].map(({ name: _e, type: xe }) => `${xe} ${_e}`).join(",")})`;
  return ae;
}
function findTypeDependencies({ primaryType: ne, types: oe }, ae = /* @__PURE__ */ new Set()) {
  const fe = ne.match(/^\w*/u), ye = fe == null ? void 0 : fe[0];
  if (ae.has(ye) || oe[ye] === void 0)
    return ae;
  ae.add(ye);
  for (const ve of oe[ye])
    findTypeDependencies({ primaryType: ve.type, types: oe }, ae);
  return ae;
}
function encodeField({ types: ne, name: oe, type: ae, value: fe }) {
  if (ne[ae] !== void 0)
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: fe, primaryType: ae, types: ne }))
    ];
  if (ae === "bytes")
    return fe = `0x${(fe.length % 2 ? "0" : "") + fe.slice(2)}`, [{ type: "bytes32" }, keccak256(fe)];
  if (ae === "string")
    return [{ type: "bytes32" }, keccak256(toHex$1(fe))];
  if (ae.lastIndexOf("]") === ae.length - 1) {
    const ye = ae.slice(0, ae.lastIndexOf("[")), ve = fe.map((_e) => encodeField({
      name: oe,
      type: ye,
      types: ne,
      value: _e
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(ve.map(([_e]) => _e), ve.map(([, _e]) => _e)))
    ];
  }
  return [{ type: ae }, fe];
}
function validateTypedData(ne) {
  const { domain: oe, message: ae, primaryType: fe, types: ye } = ne, ve = (_e, xe) => {
    for (const Oe of _e) {
      const { name: $e, type: Me } = Oe, Re = xe[$e], je = Me.match(integerRegex);
      if (je && (typeof Re == "number" || typeof Re == "bigint")) {
        const [He, qe, Ye] = je;
        numberToHex(Re, {
          signed: qe === "int",
          size: parseInt(Ye) / 8
        });
      }
      if (Me === "address" && typeof Re == "string" && !isAddress(Re))
        throw new InvalidAddressError({ address: Re });
      const Be = Me.match(bytesRegex);
      if (Be) {
        const [He, qe] = Be;
        if (qe && size$2(Re) !== parseInt(qe))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(qe),
            givenSize: size$2(Re)
          });
      }
      const ze = ye[Me];
      ze && ve(ze, Re);
    }
  };
  if (ye.EIP712Domain && oe && ve(ye.EIP712Domain, oe), fe !== "EIP712Domain") {
    const _e = ye[fe];
    ve(_e, ae);
  }
}
function getTypesForEIP712Domain({ domain: ne }) {
  return [
    typeof (ne == null ? void 0 : ne.name) == "string" && { name: "name", type: "string" },
    (ne == null ? void 0 : ne.version) && { name: "version", type: "string" },
    typeof (ne == null ? void 0 : ne.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (ne == null ? void 0 : ne.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (ne == null ? void 0 : ne.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData(ne) {
  const { abi: oe, args: ae, bytecode: fe } = ne;
  if (!ae || ae.length === 0)
    return fe;
  const ye = oe.find((_e) => "type" in _e && _e.type === "constructor");
  if (!ye)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in ye))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!ye.inputs || ye.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const ve = encodeAbiParameters(ye.inputs, ae);
  return concatHex$1([fe, ve]);
}
function encodePacked(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++) {
    const ye = ne[fe], ve = oe[fe];
    ae.push(encode(ye, ve));
  }
  return concatHex$1(ae);
}
function encode(ne, oe, ae = !1) {
  if (ne === "address") {
    const _e = oe;
    if (!isAddress(_e))
      throw new InvalidAddressError({ address: _e });
    return pad$1(_e.toLowerCase(), {
      size: ae ? 32 : null
    });
  }
  if (ne === "string")
    return stringToHex$1(oe);
  if (ne === "bytes")
    return oe;
  if (ne === "bool")
    return pad$1(boolToHex(oe), { size: ae ? 32 : 1 });
  const fe = ne.match(integerRegex);
  if (fe) {
    const [_e, xe, Oe = "256"] = fe, $e = parseInt(Oe) / 8;
    return numberToHex(oe, {
      size: ae ? 32 : $e,
      signed: xe === "int"
    });
  }
  const ye = ne.match(bytesRegex);
  if (ye) {
    const [_e, xe] = ye;
    if (parseInt(xe) !== (oe.length - 2) / 2)
      throw new BytesSizeMismatchError({
        expectedSize: parseInt(xe),
        givenSize: (oe.length - 2) / 2
      });
    return pad$1(oe, { dir: "right", size: ae ? 32 : null });
  }
  const ve = ne.match(arrayRegex);
  if (ve && Array.isArray(oe)) {
    const [_e, xe] = ve, Oe = [];
    for (let $e = 0; $e < oe.length; $e++)
      Oe.push(encode(xe, oe[$e], !0));
    return Oe.length === 0 ? "0x" : concatHex$1(Oe);
  }
  throw new UnsupportedPackedAbiType(ne);
}
function toRlp(ne, oe = "hex") {
  const ae = getEncodable(ne), fe = createCursor(new Uint8Array(ae.length));
  return ae.encode(fe), oe === "hex" ? bytesToHex$2(fe.bytes) : fe.bytes;
}
function getEncodable(ne) {
  return Array.isArray(ne) ? getEncodableList(ne.map((oe) => getEncodable(oe))) : getEncodableBytes(ne);
}
function getEncodableList(ne) {
  const oe = ne.reduce((ye, ve) => ye + ve.length, 0), ae = getSizeOfLength(oe);
  return {
    length: (() => oe <= 55 ? 1 + oe : 1 + ae + oe)(),
    encode(ye) {
      oe <= 55 ? ye.pushByte(192 + oe) : (ye.pushByte(192 + 55 + ae), ae === 1 ? ye.pushUint8(oe) : ae === 2 ? ye.pushUint16(oe) : ae === 3 ? ye.pushUint24(oe) : ye.pushUint32(oe));
      for (const { encode: ve } of ne)
        ve(ye);
    }
  };
}
function getEncodableBytes(ne) {
  const oe = typeof ne == "string" ? hexToBytes$1(ne) : ne, ae = getSizeOfLength(oe.length);
  return {
    length: (() => oe.length === 1 && oe[0] < 128 ? 1 : oe.length <= 55 ? 1 + oe.length : 1 + ae + oe.length)(),
    encode(ye) {
      oe.length === 1 && oe[0] < 128 ? ye.pushBytes(oe) : oe.length <= 55 ? (ye.pushByte(128 + oe.length), ye.pushBytes(oe)) : (ye.pushByte(128 + 55 + ae), ae === 1 ? ye.pushUint8(oe.length) : ae === 2 ? ye.pushUint16(oe.length) : ae === 3 ? ye.pushUint24(oe.length) : ye.pushUint32(oe.length), ye.pushBytes(oe));
    }
  };
}
function getSizeOfLength(ne) {
  if (ne < 2 ** 8)
    return 1;
  if (ne < 2 ** 16)
    return 2;
  if (ne < 2 ** 24)
    return 3;
  if (ne < 2 ** 32)
    return 4;
  throw new BaseError$1("Length is too large.");
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(ne) {
  const oe = {
    ...ne,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    contractAddress: ne.contractAddress ? ne.contractAddress : null,
    cumulativeGasUsed: ne.cumulativeGasUsed ? BigInt(ne.cumulativeGasUsed) : null,
    effectiveGasPrice: ne.effectiveGasPrice ? BigInt(ne.effectiveGasPrice) : null,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : null,
    logs: ne.logs ? ne.logs.map((ae) => formatLog(ae)) : null,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? hexToNumber$1(ne.transactionIndex) : null,
    status: ne.status ? receiptStatuses[ne.status] : null,
    type: ne.type ? transactionType[ne.type] || ne.type : null
  };
  return ne.blobGasPrice && (oe.blobGasPrice = BigInt(ne.blobGasPrice)), ne.blobGasUsed && (oe.blobGasUsed = BigInt(ne.blobGasUsed)), oe;
}
const defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt), presignMessagePrefix = `Ethereum Signed Message:
`;
function hashMessage(ne, oe) {
  const ae = (() => typeof ne == "string" ? stringToBytes(ne) : ne.raw instanceof Uint8Array ? ne.raw : toBytes$1(ne.raw))(), fe = stringToBytes(`${presignMessagePrefix}${ae.length}`);
  return keccak256(concat$1([fe, ae]), oe);
}
function assertTransactionEIP4844(ne) {
  const { blobVersionedHashes: oe } = ne;
  if (oe) {
    if (oe.length === 0)
      throw new EmptyBlobError();
    for (const ae of oe) {
      const fe = size$2(ae), ye = hexToNumber$1(slice(ae, 0, 1));
      if (fe !== 32)
        throw new InvalidVersionedHashSizeError({ hash: ae, size: fe });
      if (ye !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash: ae,
          version: ye
        });
    }
  }
  assertTransactionEIP1559(ne);
}
function assertTransactionEIP1559(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe, to: ye } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ye && !isAddress(ye))
    throw new InvalidAddressError({ address: ye });
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ae && fe && ae > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ae });
}
function assertTransactionEIP2930(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: ve } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ve && !isAddress(ve))
    throw new InvalidAddressError({ address: ve });
  if (ae || ye)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
}
function assertTransactionLegacy(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: ve, accessList: _e } = ne;
  if (ve && !isAddress(ve))
    throw new InvalidAddressError({ address: ve });
  if (typeof oe < "u" && oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ae || ye)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (_e)
    throw new BaseError$1("`accessList` is not a valid Legacy Transaction attribute.");
}
function serializeAccessList(ne) {
  if (!ne || ne.length === 0)
    return [];
  const oe = [];
  for (let ae = 0; ae < ne.length; ae++) {
    const { address: fe, storageKeys: ye } = ne[ae];
    for (let ve = 0; ve < ye.length; ve++)
      if (ye[ve].length - 2 !== 64)
        throw new InvalidStorageKeySizeError({ storageKey: ye[ve] });
    if (!isAddress(fe, { strict: !1 }))
      throw new InvalidAddressError({ address: fe });
    oe.push([fe, ye]);
  }
  return oe;
}
function serializeTransaction$1(ne, oe) {
  const ae = getTransactionType(ne);
  return ae === "eip1559" ? serializeTransactionEIP1559(ne, oe) : ae === "eip2930" ? serializeTransactionEIP2930(ne, oe) : ae === "eip4844" ? serializeTransactionEIP4844(ne, oe) : serializeTransactionLegacy(ne, oe);
}
function serializeTransactionEIP4844(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: ve, value: _e, maxFeePerBlobGas: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, accessList: Me, data: Re } = ne;
  assertTransactionEIP4844(ne);
  let je = ne.blobVersionedHashes, Be = ne.sidecars;
  if (ne.blobs && (typeof je > "u" || typeof Be > "u")) {
    const dt = typeof ne.blobs[0] == "string" ? ne.blobs : ne.blobs.map((It) => bytesToHex$2(It)), yt = ne.kzg, Ct = blobsToCommitments({
      blobs: dt,
      kzg: yt
    });
    if (typeof je > "u" && (je = commitmentsToVersionedHashes({
      commitments: Ct
    })), typeof Be > "u") {
      const It = blobsToProofs({ blobs: dt, commitments: Ct, kzg: yt });
      Be = toBlobSidecars({ blobs: dt, commitments: Ct, proofs: It });
    }
  }
  const ze = serializeAccessList(Me), He = [
    toHex$1(ae),
    ye ? toHex$1(ye) : "0x",
    $e ? toHex$1($e) : "0x",
    Oe ? toHex$1(Oe) : "0x",
    fe ? toHex$1(fe) : "0x",
    ve ?? "0x",
    _e ? toHex$1(_e) : "0x",
    Re ?? "0x",
    ze,
    xe ? toHex$1(xe) : "0x",
    je ?? [],
    ...toYParitySignatureArray(ne, oe)
  ], qe = [], Ye = [], pt = [];
  if (Be)
    for (let dt = 0; dt < Be.length; dt++) {
      const { blob: yt, commitment: Ct, proof: It } = Be[dt];
      qe.push(yt), Ye.push(Ct), pt.push(It);
    }
  return concatHex$1([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    toRlp(Be ? [He, qe, Ye, pt] : He)
  ]);
}
function serializeTransactionEIP1559(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: ve, value: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, accessList: $e, data: Me } = ne;
  assertTransactionEIP1559(ne);
  const Re = serializeAccessList($e), je = [
    toHex$1(ae),
    ye ? toHex$1(ye) : "0x",
    Oe ? toHex$1(Oe) : "0x",
    xe ? toHex$1(xe) : "0x",
    fe ? toHex$1(fe) : "0x",
    ve ?? "0x",
    _e ? toHex$1(_e) : "0x",
    Me ?? "0x",
    Re,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex$1([
    "0x02",
    toRlp(je)
  ]);
}
function serializeTransactionEIP2930(ne, oe) {
  const { chainId: ae, gas: fe, data: ye, nonce: ve, to: _e, value: xe, accessList: Oe, gasPrice: $e } = ne;
  assertTransactionEIP2930(ne);
  const Me = serializeAccessList(Oe), Re = [
    toHex$1(ae),
    ve ? toHex$1(ve) : "0x",
    $e ? toHex$1($e) : "0x",
    fe ? toHex$1(fe) : "0x",
    _e ?? "0x",
    xe ? toHex$1(xe) : "0x",
    ye ?? "0x",
    Me,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex$1([
    "0x01",
    toRlp(Re)
  ]);
}
function serializeTransactionLegacy(ne, oe) {
  const { chainId: ae = 0, gas: fe, data: ye, nonce: ve, to: _e, value: xe, gasPrice: Oe } = ne;
  assertTransactionLegacy(ne);
  let $e = [
    ve ? toHex$1(ve) : "0x",
    Oe ? toHex$1(Oe) : "0x",
    fe ? toHex$1(fe) : "0x",
    _e ?? "0x",
    xe ? toHex$1(xe) : "0x",
    ye ?? "0x"
  ];
  if (oe) {
    const Me = (() => {
      if (oe.v >= 35n)
        return (oe.v - 35n) / 2n > 0 ? oe.v : 27n + (oe.v === 35n ? 0n : 1n);
      if (ae > 0)
        return BigInt(ae * 2) + BigInt(35n + oe.v - 27n);
      const Re = 27n + (oe.v === 27n ? 0n : 1n);
      if (oe.v !== Re)
        throw new InvalidLegacyVError({ v: oe.v });
      return Re;
    })();
    $e = [
      ...$e,
      toHex$1(Me),
      oe.r,
      oe.s
    ];
  } else
    ae > 0 && ($e = [
      ...$e,
      toHex$1(ae),
      "0x",
      "0x"
    ]);
  return toRlp($e);
}
function toYParitySignatureArray(ne, oe) {
  const { r: ae, s: fe, v: ye, yParity: ve } = oe ?? ne;
  return typeof ae > "u" ? [] : typeof fe > "u" ? [] : typeof ye > "u" && typeof ve > "u" ? [] : [(() => typeof ve == "number" ? ve ? toHex$1(1) : "0x" : ye === 0n ? "0x" : ye === 1n ? toHex$1(1) : ye === 27n ? "0x" : toHex$1(1))(), trim(ae), trim(fe)];
}
function parseUnits(ne, oe) {
  let [ae, fe = "0"] = ne.split(".");
  const ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    const [ve, _e, xe] = [
      fe.slice(0, oe - 1),
      fe.slice(oe - 1, oe),
      fe.slice(oe)
    ], Oe = Math.round(+`${_e}.${xe}`);
    Oe > 9 ? fe = `${BigInt(ve) + BigInt(1)}0`.padStart(ve.length + 1, "0") : fe = `${ve}${Oe}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
function parseEther(ne, oe = "wei") {
  return parseUnits(ne, etherUnits[oe]);
}
function formatStorageProof(ne) {
  return ne.map((oe) => ({
    ...oe,
    value: BigInt(oe.value)
  }));
}
function formatProof(ne) {
  return {
    ...ne,
    balance: ne.balance ? BigInt(ne.balance) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    storageProof: ne.storageProof ? formatStorageProof(ne.storageProof) : void 0
  };
}
async function getProof(ne, { address: oe, blockNumber: ae, blockTag: fe, storageKeys: ye }) {
  const ve = fe ?? "latest", _e = ae !== void 0 ? numberToHex(ae) : void 0, xe = await ne.request({
    method: "eth_getProof",
    params: [oe, ye, _e || ve]
  });
  return formatProof(xe);
}
async function getStorageAt(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest", slot: ye }) {
  const ve = ae !== void 0 ? numberToHex(ae) : void 0;
  return await ne.request({
    method: "eth_getStorageAt",
    params: [oe, ye, ve || fe]
  });
}
async function getTransaction(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: ve }) {
  var Me, Re, je;
  const _e = fe || "latest", xe = ae !== void 0 ? numberToHex(ae) : void 0;
  let Oe = null;
  if (ye ? Oe = await ne.request({
    method: "eth_getTransactionByHash",
    params: [ye]
  }) : oe ? Oe = await ne.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [oe, numberToHex(ve)]
  }) : (xe || _e) && (Oe = await ne.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [xe || _e, numberToHex(ve)]
  })), !Oe)
    throw new TransactionNotFoundError({
      blockHash: oe,
      blockNumber: ae,
      blockTag: _e,
      hash: ye,
      index: ve
    });
  return (((je = (Re = (Me = ne.chain) == null ? void 0 : Me.formatters) == null ? void 0 : Re.transaction) == null ? void 0 : je.format) || formatTransaction)(Oe);
}
async function getTransactionConfirmations(ne, { hash: oe, transactionReceipt: ae }) {
  const [fe, ye] = await Promise.all([
    getAction(ne, getBlockNumber, "getBlockNumber")({}),
    oe ? getAction(ne, getTransaction, "getBlockNumber")({ hash: oe }) : void 0
  ]), ve = (ae == null ? void 0 : ae.blockNumber) || (ye == null ? void 0 : ye.blockNumber);
  return ve ? fe - ve + 1n : 0n;
}
async function getTransactionReceipt(ne, { hash: oe }) {
  var ye, ve, _e;
  const ae = await ne.request({
    method: "eth_getTransactionReceipt",
    params: [oe]
  });
  if (!ae)
    throw new TransactionReceiptNotFoundError({ hash: oe });
  return (((_e = (ve = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : ve.transactionReceipt) == null ? void 0 : _e.format) || formatTransactionReceipt)(ae);
}
async function multicall(ne, oe) {
  var qe;
  const { allowFailure: ae = !0, batchSize: fe, blockNumber: ye, blockTag: ve, multicallAddress: _e, stateOverride: xe } = oe, Oe = oe.contracts, $e = fe ?? (typeof ((qe = ne.batch) == null ? void 0 : qe.multicall) == "object" && ne.batch.multicall.batchSize || 1024);
  let Me = _e;
  if (!Me) {
    if (!ne.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    Me = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Re = [[]];
  let je = 0, Be = 0;
  for (let Ye = 0; Ye < Oe.length; Ye++) {
    const { abi: pt, address: dt, args: yt, functionName: Ct } = Oe[Ye];
    try {
      const It = encodeFunctionData({ abi: pt, args: yt, functionName: Ct });
      Be += (It.length - 2) / 2, // Check if batching is enabled.
      $e > 0 && // Check if the current size of the batch exceeds the size limit.
      Be > $e && // Check if the current chunk is not already empty.
      Re[je].length > 0 && (je++, Be = (It.length - 2) / 2, Re[je] = []), Re[je] = [
        ...Re[je],
        {
          allowFailure: !0,
          callData: It,
          target: dt
        }
      ];
    } catch (It) {
      const Vt = getContractError(It, {
        abi: pt,
        address: dt,
        args: yt,
        docsPath: "/docs/contract/multicall",
        functionName: Ct
      });
      if (!ae)
        throw Vt;
      Re[je] = [
        ...Re[je],
        {
          allowFailure: !0,
          callData: "0x",
          target: dt
        }
      ];
    }
  }
  const ze = await Promise.allSettled(Re.map((Ye) => getAction(ne, readContract, "readContract")({
    abi: multicall3Abi,
    address: Me,
    args: [Ye],
    blockNumber: ye,
    blockTag: ve,
    functionName: "aggregate3",
    stateOverride: xe
  }))), He = [];
  for (let Ye = 0; Ye < ze.length; Ye++) {
    const pt = ze[Ye];
    if (pt.status === "rejected") {
      if (!ae)
        throw pt.reason;
      for (let yt = 0; yt < Re[Ye].length; yt++)
        He.push({
          status: "failure",
          error: pt.reason,
          result: void 0
        });
      continue;
    }
    const dt = pt.value;
    for (let yt = 0; yt < dt.length; yt++) {
      const { returnData: Ct, success: It } = dt[yt], { callData: Vt } = Re[Ye][yt], { abi: Ut, address: Zt, functionName: tr, args: er } = Oe[He.length];
      try {
        if (Vt === "0x")
          throw new AbiDecodingZeroDataError();
        if (!It)
          throw new RawContractError({ data: Ct });
        const hr = decodeFunctionResult({
          abi: Ut,
          args: er,
          data: Ct,
          functionName: tr
        });
        He.push(ae ? { result: hr, status: "success" } : hr);
      } catch (hr) {
        const Ot = getContractError(hr, {
          abi: Ut,
          address: Zt,
          args: er,
          docsPath: "/docs/contract/multicall",
          functionName: tr
        });
        if (!ae)
          throw Ot;
        He.push({ error: Ot, result: void 0, status: "failure" });
      }
    }
  }
  if (He.length !== Oe.length)
    throw new BaseError$1("multicall results mismatch");
  return He;
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a = (ne) => ne instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function bytesToHex$1(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  let oe = "";
  for (let ae = 0; ae < ne.length; ae++)
    oe += hexes$1[ne[ae]];
  return oe;
}
function numberToHexUnpadded(ne) {
  const oe = ne.toString(16);
  return oe.length & 1 ? `0${oe}` : oe;
}
function hexToNumber(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  return BigInt(ne === "" ? "0" : `0x${ne}`);
}
function hexToBytes(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  const oe = ne.length;
  if (oe % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + oe);
  const ae = new Uint8Array(oe / 2);
  for (let fe = 0; fe < ae.length; fe++) {
    const ye = fe * 2, ve = ne.slice(ye, ye + 2), _e = Number.parseInt(ve, 16);
    if (Number.isNaN(_e) || _e < 0)
      throw new Error("Invalid byte sequence");
    ae[fe] = _e;
  }
  return ae;
}
function bytesToNumberBE(ne) {
  return hexToNumber(bytesToHex$1(ne));
}
function bytesToNumberLE(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(ne).reverse()));
}
function numberToBytesBE(ne, oe) {
  return hexToBytes(ne.toString(16).padStart(oe * 2, "0"));
}
function numberToBytesLE(ne, oe) {
  return numberToBytesBE(ne, oe).reverse();
}
function numberToVarBytesBE(ne) {
  return hexToBytes(numberToHexUnpadded(ne));
}
function ensureBytes(ne, oe, ae) {
  let fe;
  if (typeof oe == "string")
    try {
      fe = hexToBytes(oe);
    } catch (ve) {
      throw new Error(`${ne} must be valid hex string, got "${oe}". Cause: ${ve}`);
    }
  else if (u8a(oe))
    fe = Uint8Array.from(oe);
  else
    throw new Error(`${ne} must be hex string or Uint8Array`);
  const ye = fe.length;
  if (typeof ae == "number" && ye !== ae)
    throw new Error(`${ne} expected ${ae} bytes, got ${ye}`);
  return fe;
}
function concatBytes(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
function equalBytes(ne, oe) {
  if (ne.length !== oe.length)
    return !1;
  for (let ae = 0; ae < ne.length; ae++)
    if (ne[ae] !== oe[ae])
      return !1;
  return !0;
}
function utf8ToBytes(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function bitLen(ne) {
  let oe;
  for (oe = 0; ne > _0n$3; ne >>= _1n$4, oe += 1)
    ;
  return oe;
}
function bitGet(ne, oe) {
  return ne >> BigInt(oe) & _1n$4;
}
const bitSet = (ne, oe, ae) => ne | (ae ? _1n$4 : _0n$3) << BigInt(oe), bitMask = (ne) => (_2n$2 << BigInt(ne - 1)) - _1n$4, u8n = (ne) => new Uint8Array(ne), u8fr = (ne) => Uint8Array.from(ne);
function createHmacDrbg(ne, oe, ae) {
  if (typeof ne != "number" || ne < 2)
    throw new Error("hashLen must be a number");
  if (typeof oe != "number" || oe < 2)
    throw new Error("qByteLen must be a number");
  if (typeof ae != "function")
    throw new Error("hmacFn must be a function");
  let fe = u8n(ne), ye = u8n(ne), ve = 0;
  const _e = () => {
    fe.fill(1), ye.fill(0), ve = 0;
  }, xe = (...Re) => ae(ye, fe, ...Re), Oe = (Re = u8n()) => {
    ye = xe(u8fr([0]), Re), fe = xe(), Re.length !== 0 && (ye = xe(u8fr([1]), Re), fe = xe());
  }, $e = () => {
    if (ve++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let Re = 0;
    const je = [];
    for (; Re < oe; ) {
      fe = xe();
      const Be = fe.slice();
      je.push(Be), Re += fe.length;
    }
    return concatBytes(...je);
  };
  return (Re, je) => {
    _e(), Oe(Re);
    let Be;
    for (; !(Be = je($e())); )
      Oe();
    return _e(), Be;
  };
}
const validatorFns = {
  bigint: (ne) => typeof ne == "bigint",
  function: (ne) => typeof ne == "function",
  boolean: (ne) => typeof ne == "boolean",
  string: (ne) => typeof ne == "string",
  stringOrUint8Array: (ne) => typeof ne == "string" || ne instanceof Uint8Array,
  isSafeInteger: (ne) => Number.isSafeInteger(ne),
  array: (ne) => Array.isArray(ne),
  field: (ne, oe) => oe.Fp.isValid(ne),
  hash: (ne) => typeof ne == "function" && Number.isSafeInteger(ne.outputLen)
};
function validateObject(ne, oe, ae = {}) {
  const fe = (ye, ve, _e) => {
    const xe = validatorFns[ve];
    if (typeof xe != "function")
      throw new Error(`Invalid validator "${ve}", expected function`);
    const Oe = ne[ye];
    if (!(_e && Oe === void 0) && !xe(Oe, ne))
      throw new Error(`Invalid param ${String(ye)}=${Oe} (${typeof Oe}), expected ${ve}`);
  };
  for (const [ye, ve] of Object.entries(oe))
    fe(ye, ve, !1);
  for (const [ye, ve] of Object.entries(ae))
    fe(ye, ve, !0);
  return ne;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual(ne, oe) {
  const ae = isHex$1(ne) ? toBytes$1(ne) : ne, fe = isHex$1(oe) ? toBytes$1(oe) : oe;
  return equalBytes(ae, fe);
}
async function verifyHash(ne, { address: oe, hash: ae, signature: fe, ...ye }) {
  const ve = isHex$1(fe) ? fe : toHex$1(fe);
  try {
    const { data: _e } = await getAction(ne, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [oe, ae, ve],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...ye
    });
    return isBytesEqual(_e ?? "0x0", "0x1");
  } catch (_e) {
    if (_e instanceof CallExecutionError)
      return !1;
    throw _e;
  }
}
async function verifyMessage(ne, { address: oe, message: ae, signature: fe, ...ye }) {
  const ve = hashMessage(ae);
  return verifyHash(ne, {
    address: oe,
    hash: ve,
    signature: fe,
    ...ye
  });
}
async function verifyTypedData(ne, oe) {
  const { address: ae, signature: fe, message: ye, primaryType: ve, types: _e, domain: xe, ...Oe } = oe, $e = hashTypedData({ message: ye, primaryType: ve, types: _e, domain: xe });
  return verifyHash(ne, {
    address: ae,
    hash: $e,
    signature: fe,
    ...Oe
  });
}
function watchBlockNumber(ne, { emitOnBegin: oe = !1, emitMissed: ae = !1, onBlockNumber: fe, onError: ye, poll: ve, pollingInterval: _e = ne.pollingInterval }) {
  const xe = typeof ve < "u" ? ve : ne.transport.type !== "webSocket";
  let Oe;
  return xe ? (() => {
    const Re = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae,
      _e
    ]);
    return observe(Re, { onBlockNumber: fe, onError: ye }, (je) => poll(async () => {
      var Be;
      try {
        const ze = await getAction(ne, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (Oe) {
          if (ze === Oe)
            return;
          if (ze - Oe > 1 && ae)
            for (let He = Oe + 1n; He < ze; He++)
              je.onBlockNumber(He, Oe), Oe = He;
        }
        (!Oe || ze > Oe) && (je.onBlockNumber(ze, Oe), Oe = ze);
      } catch (ze) {
        (Be = je.onError) == null || Be.call(je, ze);
      }
    }, {
      emitOnBegin: oe,
      interval: _e
    }));
  })() : (() => {
    const Re = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae
    ]);
    return observe(Re, { onBlockNumber: fe, onError: ye }, (je) => {
      let Be = !0, ze = () => Be = !1;
      return (async () => {
        try {
          const { unsubscribe: He } = await ne.transport.subscribe({
            params: ["newHeads"],
            onData(qe) {
              var pt;
              if (!Be)
                return;
              const Ye = hexToBigInt((pt = qe.result) == null ? void 0 : pt.number);
              je.onBlockNumber(Ye, Oe), Oe = Ye;
            },
            onError(qe) {
              var Ye;
              (Ye = je.onError) == null || Ye.call(je, qe);
            }
          });
          ze = He, Be || ze();
        } catch (He) {
          ye == null || ye(He);
        }
      })(), () => ze();
    });
  })();
}
async function waitForTransactionReceipt(ne, {
  confirmations: oe = 1,
  hash: ae,
  onReplaced: fe,
  pollingInterval: ye = ne.pollingInterval,
  retryCount: ve = 6,
  retryDelay: _e = ({ count: Oe }) => ~~(1 << Oe) * 200,
  // exponential backoff
  timeout: xe
}) {
  const Oe = stringify(["waitForTransactionReceipt", ne.uid, ae]);
  let $e, Me, Re, je = !1;
  return new Promise((Be, ze) => {
    xe && setTimeout(() => ze(new WaitForTransactionReceiptTimeoutError({ hash: ae })), xe);
    const He = observe(Oe, { onReplaced: fe, resolve: Be, reject: ze }, (qe) => {
      const Ye = getAction(ne, watchBlockNumber, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: ye,
        async onBlockNumber(pt) {
          if (je)
            return;
          let dt = pt;
          const yt = (Ct) => {
            Ye(), Ct(), He();
          };
          try {
            if (Re) {
              if (oe > 1 && (!Re.blockNumber || dt - Re.blockNumber + 1n < oe))
                return;
              yt(() => qe.resolve(Re));
              return;
            }
            if ($e || (je = !0, await withRetry(async () => {
              $e = await getAction(ne, getTransaction, "getTransaction")({ hash: ae }), $e.blockNumber && (dt = $e.blockNumber);
            }, {
              delay: _e,
              retryCount: ve
            }), je = !1), Re = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({ hash: ae }), oe > 1 && (!Re.blockNumber || dt - Re.blockNumber + 1n < oe))
              return;
            yt(() => qe.resolve(Re));
          } catch (Ct) {
            if (Ct instanceof TransactionNotFoundError || Ct instanceof TransactionReceiptNotFoundError) {
              if (!$e) {
                je = !1;
                return;
              }
              try {
                Me = $e, je = !0;
                const It = await withRetry(() => getAction(ne, getBlock, "getBlock")({
                  blockNumber: dt,
                  includeTransactions: !0
                }), {
                  delay: _e,
                  retryCount: ve,
                  shouldRetry: ({ error: Zt }) => Zt instanceof BlockNotFoundError
                });
                je = !1;
                const Vt = It.transactions.find(({ from: Zt, nonce: tr }) => Zt === Me.from && tr === Me.nonce);
                if (!Vt || (Re = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({
                  hash: Vt.hash
                }), oe > 1 && (!Re.blockNumber || dt - Re.blockNumber + 1n < oe)))
                  return;
                let Ut = "replaced";
                Vt.to === Me.to && Vt.value === Me.value ? Ut = "repriced" : Vt.from === Vt.to && Vt.value === 0n && (Ut = "cancelled"), yt(() => {
                  var Zt;
                  (Zt = qe.onReplaced) == null || Zt.call(qe, {
                    reason: Ut,
                    replacedTransaction: Me,
                    transaction: Vt,
                    transactionReceipt: Re
                  }), qe.resolve(Re);
                });
              } catch (It) {
                yt(() => qe.reject(It));
              }
            } else
              yt(() => qe.reject(Ct));
          }
        }
      });
    });
  });
}
function watchBlocks(ne, { blockTag: oe = "latest", emitMissed: ae = !1, emitOnBegin: fe = !1, onBlock: ye, onError: ve, includeTransactions: _e, poll: xe, pollingInterval: Oe = ne.pollingInterval }) {
  const $e = typeof xe < "u" ? xe : ne.transport.type !== "webSocket", Me = _e ?? !1;
  let Re;
  return $e ? (() => {
    const ze = stringify([
      "watchBlocks",
      ne.uid,
      oe,
      ae,
      fe,
      Me,
      Oe
    ]);
    return observe(ze, { onBlock: ye, onError: ve }, (He) => poll(async () => {
      var qe;
      try {
        const Ye = await getAction(ne, getBlock, "getBlock")({
          blockTag: oe,
          includeTransactions: Me
        });
        if (Ye.number && (Re != null && Re.number)) {
          if (Ye.number === Re.number)
            return;
          if (Ye.number - Re.number > 1 && ae)
            for (let pt = (Re == null ? void 0 : Re.number) + 1n; pt < Ye.number; pt++) {
              const dt = await getAction(ne, getBlock, "getBlock")({
                blockNumber: pt,
                includeTransactions: Me
              });
              He.onBlock(dt, Re), Re = dt;
            }
        }
        // If no previous block exists, emit.
        (!(Re != null && Re.number) || // If the block tag is "pending" with no block number, emit.
        oe === "pending" && !(Ye != null && Ye.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        Ye.number && Ye.number > Re.number) && (He.onBlock(Ye, Re), Re = Ye);
      } catch (Ye) {
        (qe = He.onError) == null || qe.call(He, Ye);
      }
    }, {
      emitOnBegin: fe,
      interval: Oe
    }));
  })() : (() => {
    let ze = !0, He = () => ze = !1;
    return (async () => {
      try {
        const { unsubscribe: qe } = await ne.transport.subscribe({
          params: ["newHeads"],
          onData(Ye) {
            var yt, Ct, It;
            if (!ze)
              return;
            const dt = (((It = (Ct = (yt = ne.chain) == null ? void 0 : yt.formatters) == null ? void 0 : Ct.block) == null ? void 0 : It.format) || formatBlock)(Ye.result);
            ye(dt, Re), Re = dt;
          },
          onError(Ye) {
            ve == null || ve(Ye);
          }
        });
        He = qe, ze || He();
      } catch (qe) {
        ve == null || ve(qe);
      }
    })(), () => He();
  })();
}
function watchEvent(ne, { address: oe, args: ae, batch: fe = !0, event: ye, events: ve, fromBlock: _e, onError: xe, onLogs: Oe, poll: $e, pollingInterval: Me = ne.pollingInterval, strict: Re }) {
  const je = typeof $e < "u" ? $e : ne.transport.type !== "webSocket" || typeof _e == "bigint", Be = Re ?? !1;
  return je ? (() => {
    const qe = stringify([
      "watchEvent",
      oe,
      ae,
      fe,
      ne.uid,
      ye,
      Me,
      _e
    ]);
    return observe(qe, { onLogs: Oe, onError: xe }, (Ye) => {
      let pt;
      _e !== void 0 && (pt = _e - 1n);
      let dt, yt = !1;
      const Ct = poll(async () => {
        var It;
        if (!yt) {
          try {
            dt = await getAction(ne, createEventFilter, "createEventFilter")({
              address: oe,
              args: ae,
              event: ye,
              events: ve,
              strict: Be,
              fromBlock: _e
            });
          } catch {
          }
          yt = !0;
          return;
        }
        try {
          let Vt;
          if (dt)
            Vt = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: dt });
          else {
            const Ut = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            pt && pt !== Ut ? Vt = await getAction(ne, getLogs, "getLogs")({
              address: oe,
              args: ae,
              event: ye,
              events: ve,
              fromBlock: pt + 1n,
              toBlock: Ut
            }) : Vt = [], pt = Ut;
          }
          if (Vt.length === 0)
            return;
          if (fe)
            Ye.onLogs(Vt);
          else
            for (const Ut of Vt)
              Ye.onLogs([Ut]);
        } catch (Vt) {
          dt && Vt instanceof InvalidInputRpcError && (yt = !1), (It = Ye.onError) == null || It.call(Ye, Vt);
        }
      }, {
        emitOnBegin: !0,
        interval: Me
      });
      return async () => {
        dt && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: dt }), Ct();
      };
    });
  })() : (() => {
    let qe = !0, Ye = () => qe = !1;
    return (async () => {
      try {
        const pt = ve ?? (ye ? [ye] : void 0);
        let dt = [];
        pt && (dt = [
          pt.flatMap((Ct) => encodeEventTopics({
            abi: [Ct],
            eventName: Ct.name,
            args: ae
          }))
        ], ye && (dt = dt[0]));
        const { unsubscribe: yt } = await ne.transport.subscribe({
          params: ["logs", { address: oe, topics: dt }],
          onData(Ct) {
            var Vt;
            if (!qe)
              return;
            const It = Ct.result;
            try {
              const { eventName: Ut, args: Zt } = decodeEventLog({
                abi: pt ?? [],
                data: It.data,
                topics: It.topics,
                strict: Be
              }), tr = formatLog(It, { args: Zt, eventName: Ut });
              Oe([tr]);
            } catch (Ut) {
              let Zt, tr;
              if (Ut instanceof DecodeLogDataMismatch || Ut instanceof DecodeLogTopicsMismatch) {
                if (Re)
                  return;
                Zt = Ut.abiItem.name, tr = (Vt = Ut.abiItem.inputs) == null ? void 0 : Vt.some((hr) => !("name" in hr && hr.name));
              }
              const er = formatLog(It, {
                args: tr ? [] : {},
                eventName: Zt
              });
              Oe([er]);
            }
          },
          onError(Ct) {
            xe == null || xe(Ct);
          }
        });
        Ye = yt, qe || Ye();
      } catch (pt) {
        xe == null || xe(pt);
      }
    })(), () => Ye();
  })();
}
function watchPendingTransactions(ne, { batch: oe = !0, onError: ae, onTransactions: fe, poll: ye, pollingInterval: ve = ne.pollingInterval }) {
  return (typeof ye < "u" ? ye : ne.transport.type !== "webSocket") ? (() => {
    const $e = stringify([
      "watchPendingTransactions",
      ne.uid,
      oe,
      ve
    ]);
    return observe($e, { onTransactions: fe, onError: ae }, (Me) => {
      let Re;
      const je = poll(async () => {
        var Be;
        try {
          if (!Re)
            try {
              Re = await getAction(ne, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (He) {
              throw je(), He;
            }
          const ze = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: Re });
          if (ze.length === 0)
            return;
          if (oe)
            Me.onTransactions(ze);
          else
            for (const He of ze)
              Me.onTransactions([He]);
        } catch (ze) {
          (Be = Me.onError) == null || Be.call(Me, ze);
        }
      }, {
        emitOnBegin: !0,
        interval: ve
      });
      return async () => {
        Re && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: Re }), je();
      };
    });
  })() : (() => {
    let $e = !0, Me = () => $e = !1;
    return (async () => {
      try {
        const { unsubscribe: Re } = await ne.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(je) {
            if (!$e)
              return;
            const Be = je.result;
            fe([Be]);
          },
          onError(je) {
            ae == null || ae(je);
          }
        });
        Me = Re, $e || Me();
      } catch (Re) {
        ae == null || ae(Re);
      }
    })(), () => Me();
  })();
}
function publicActions(ne) {
  return {
    call: (oe) => call(ne, oe),
    createBlockFilter: () => createBlockFilter(ne),
    createContractEventFilter: (oe) => createContractEventFilter(ne, oe),
    createEventFilter: (oe) => createEventFilter(ne, oe),
    createPendingTransactionFilter: () => createPendingTransactionFilter(ne),
    estimateContractGas: (oe) => estimateContractGas(ne, oe),
    estimateGas: (oe) => estimateGas(ne, oe),
    getBalance: (oe) => getBalance(ne, oe),
    getBlobBaseFee: () => getBlobBaseFee(ne),
    getBlock: (oe) => getBlock(ne, oe),
    getBlockNumber: (oe) => getBlockNumber(ne, oe),
    getBlockTransactionCount: (oe) => getBlockTransactionCount(ne, oe),
    getBytecode: (oe) => getBytecode(ne, oe),
    getChainId: () => getChainId(ne),
    getContractEvents: (oe) => getContractEvents(ne, oe),
    getEnsAddress: (oe) => getEnsAddress(ne, oe),
    getEnsAvatar: (oe) => getEnsAvatar(ne, oe),
    getEnsName: (oe) => getEnsName(ne, oe),
    getEnsResolver: (oe) => getEnsResolver(ne, oe),
    getEnsText: (oe) => getEnsText(ne, oe),
    getFeeHistory: (oe) => getFeeHistory(ne, oe),
    estimateFeesPerGas: (oe) => estimateFeesPerGas(ne, oe),
    getFilterChanges: (oe) => getFilterChanges(ne, oe),
    getFilterLogs: (oe) => getFilterLogs(ne, oe),
    getGasPrice: () => getGasPrice(ne),
    getLogs: (oe) => getLogs(ne, oe),
    getProof: (oe) => getProof(ne, oe),
    estimateMaxPriorityFeePerGas: (oe) => estimateMaxPriorityFeePerGas(ne, oe),
    getStorageAt: (oe) => getStorageAt(ne, oe),
    getTransaction: (oe) => getTransaction(ne, oe),
    getTransactionConfirmations: (oe) => getTransactionConfirmations(ne, oe),
    getTransactionCount: (oe) => getTransactionCount(ne, oe),
    getTransactionReceipt: (oe) => getTransactionReceipt(ne, oe),
    multicall: (oe) => multicall(ne, oe),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    readContract: (oe) => readContract(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    simulateContract: (oe) => simulateContract(ne, oe),
    verifyMessage: (oe) => verifyMessage(ne, oe),
    verifyTypedData: (oe) => verifyTypedData(ne, oe),
    uninstallFilter: (oe) => uninstallFilter(ne, oe),
    waitForTransactionReceipt: (oe) => waitForTransactionReceipt(ne, oe),
    watchBlocks: (oe) => watchBlocks(ne, oe),
    watchBlockNumber: (oe) => watchBlockNumber(ne, oe),
    watchContractEvent: (oe) => watchContractEvent(ne, oe),
    watchEvent: (oe) => watchEvent(ne, oe),
    watchPendingTransactions: (oe) => watchPendingTransactions(ne, oe)
  };
}
function createPublicClient(ne) {
  const { key: oe = "public", name: ae = "Public Client" } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    type: "publicClient"
  }).extend(publicActions);
}
function deployContract(ne, oe) {
  const { abi: ae, args: fe, bytecode: ye, ...ve } = oe, _e = encodeDeployData({ abi: ae, args: fe, bytecode: ye });
  return sendTransaction(ne, {
    ...ve,
    data: _e
  });
}
async function getAddresses(ne) {
  var ae;
  return ((ae = ne.account) == null ? void 0 : ae.type) === "local" ? [ne.account.address] : (await ne.request({ method: "eth_accounts" })).map((fe) => checksumAddress(fe));
}
async function getPermissions(ne) {
  return await ne.request({ method: "wallet_getPermissions" });
}
async function requestAddresses(ne) {
  return (await ne.request({ method: "eth_requestAccounts" }, { retryCount: 0 })).map((ae) => getAddress(ae));
}
async function requestPermissions(ne, oe) {
  return ne.request({
    method: "wallet_requestPermissions",
    params: [oe]
  }, { retryCount: 0 });
}
async function signMessage$1(ne, { account: oe = ne.account, message: ae }) {
  if (!oe)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const fe = parseAccount(oe);
  if (fe.type === "local")
    return fe.signMessage({ message: ae });
  const ye = (() => typeof ae == "string" ? stringToHex$1(ae) : ae.raw instanceof Uint8Array ? toHex$1(ae.raw) : ae.raw)();
  return ne.request({
    method: "personal_sign",
    params: [ye, fe.address]
  }, { retryCount: 0 });
}
async function signTransaction$1(ne, oe) {
  var $e, Me, Re, je;
  const { account: ae = ne.account, chain: fe = ne.chain, ...ye } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const ve = parseAccount(ae);
  assertRequest({
    account: ve,
    ...oe
  });
  const _e = await getAction(ne, getChainId, "getChainId")({});
  fe !== null && assertCurrentChain({
    currentChainId: _e,
    chain: fe
  });
  const xe = (fe == null ? void 0 : fe.formatters) || (($e = ne.chain) == null ? void 0 : $e.formatters), Oe = ((Me = xe == null ? void 0 : xe.transactionRequest) == null ? void 0 : Me.format) || formatTransactionRequest;
  return ve.type === "local" ? ve.signTransaction({
    ...ye,
    chainId: _e
  }, { serializer: (je = (Re = ne.chain) == null ? void 0 : Re.serializers) == null ? void 0 : je.transaction }) : await ne.request({
    method: "eth_signTransaction",
    params: [
      {
        ...Oe(ye),
        chainId: numberToHex(_e),
        from: ve.address
      }
    ]
  }, { retryCount: 0 });
}
async function signTypedData$1(ne, oe) {
  const { account: ae = ne.account, domain: fe, message: ye, primaryType: ve } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const _e = parseAccount(ae), xe = {
    EIP712Domain: getTypesForEIP712Domain({ domain: fe }),
    ...oe.types
  };
  if (validateTypedData({ domain: fe, message: ye, primaryType: ve, types: xe }), _e.type === "local")
    return _e.signTypedData({ domain: fe, message: ye, primaryType: ve, types: xe });
  const Oe = stringify({ domain: fe ?? {}, message: ye, primaryType: ve, types: xe }, ($e, Me) => isHex$1(Me) ? Me.toLowerCase() : Me);
  return ne.request({
    method: "eth_signTypedData_v4",
    params: [_e.address, Oe]
  }, { retryCount: 0 });
}
async function switchChain(ne, { id: oe }) {
  await ne.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(oe)
      }
    ]
  }, { retryCount: 0 });
}
async function watchAsset(ne, oe) {
  return await ne.request({
    method: "wallet_watchAsset",
    params: oe
  }, { retryCount: 0 });
}
function walletActions(ne) {
  return {
    addChain: (oe) => addChain(ne, oe),
    deployContract: (oe) => deployContract(ne, oe),
    getAddresses: () => getAddresses(ne),
    getChainId: () => getChainId(ne),
    getPermissions: () => getPermissions(ne),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    requestAddresses: () => requestAddresses(ne),
    requestPermissions: (oe) => requestPermissions(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    sendTransaction: (oe) => sendTransaction(ne, oe),
    signMessage: (oe) => signMessage$1(ne, oe),
    signTransaction: (oe) => signTransaction$1(ne, oe),
    signTypedData: (oe) => signTypedData$1(ne, oe),
    switchChain: (oe) => switchChain(ne, oe),
    watchAsset: (oe) => watchAsset(ne, oe),
    writeContract: (oe) => writeContract(ne, oe)
  };
}
function createWalletClient(ne) {
  const { key: oe = "wallet", name: ae = "Wallet Client", transport: fe } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    transport: fe,
    type: "walletClient"
  }).extend(walletActions);
}
function webSocket(ne, oe = {}) {
  const { key: ae = "webSocket", name: fe = "WebSocket JSON-RPC", reconnect: ye, retryDelay: ve } = oe;
  return ({ chain: _e, retryCount: xe, timeout: Oe }) => {
    var je;
    const $e = oe.retryCount ?? xe, Me = Oe ?? oe.timeout ?? 1e4, Re = ne || ((je = _e == null ? void 0 : _e.rpcUrls.default.webSocket) == null ? void 0 : je[0]);
    if (!Re)
      throw new UrlRequiredError();
    return createTransport({
      key: ae,
      name: fe,
      async request({ method: Be, params: ze }) {
        const He = { method: Be, params: ze }, qe = await getWebSocketRpcClient(Re, { reconnect: ye }), { error: Ye, result: pt } = await qe.requestAsync({
          body: He,
          timeout: Me
        });
        if (Ye)
          throw new RpcRequestError({
            body: He,
            error: Ye,
            url: Re
          });
        return pt;
      },
      retryCount: $e,
      retryDelay: ve,
      timeout: Me,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(Re);
      },
      getRpcClient() {
        return getWebSocketRpcClient(Re);
      },
      async subscribe({ params: Be, onData: ze, onError: He }) {
        const qe = await getWebSocketRpcClient(Re), { result: Ye } = await new Promise((pt, dt) => qe.request({
          body: {
            method: "eth_subscribe",
            params: Be
          },
          onResponse(yt) {
            if (yt.error) {
              dt(yt.error), He == null || He(yt.error);
              return;
            }
            if (typeof yt.id == "number") {
              pt(yt);
              return;
            }
            yt.method === "eth_subscription" && ze(yt.params);
          }
        }));
        return {
          subscriptionId: Ye,
          async unsubscribe() {
            return new Promise((pt) => qe.request({
              body: {
                method: "eth_unsubscribe",
                params: [Ye]
              },
              onResponse: pt
            }));
          }
        };
      }
    });
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(ne, oe) {
  const ae = ne % oe;
  return ae >= _0n$2 ? ae : oe + ae;
}
function pow(ne, oe, ae) {
  if (ae <= _0n$2 || oe < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (ae === _1n$3)
    return _0n$2;
  let fe = _1n$3;
  for (; oe > _0n$2; )
    oe & _1n$3 && (fe = fe * ne % ae), ne = ne * ne % ae, oe >>= _1n$3;
  return fe;
}
function pow2(ne, oe, ae) {
  let fe = ne;
  for (; oe-- > _0n$2; )
    fe *= fe, fe %= ae;
  return fe;
}
function invert$1(ne, oe) {
  if (ne === _0n$2 || oe <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${ne} mod=${oe}`);
  let ae = mod(ne, oe), fe = oe, ye = _0n$2, ve = _1n$3;
  for (; ae !== _0n$2; ) {
    const xe = fe / ae, Oe = fe % ae, $e = ye - ve * xe;
    fe = ae, ae = Oe, ye = ve, ve = $e;
  }
  if (fe !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(ye, oe);
}
function tonelliShanks(ne) {
  const oe = (ne - _1n$3) / _2n$1;
  let ae, fe, ye;
  for (ae = ne - _1n$3, fe = 0; ae % _2n$1 === _0n$2; ae /= _2n$1, fe++)
    ;
  for (ye = _2n$1; ye < ne && pow(ye, oe, ne) !== ne - _1n$3; ye++)
    ;
  if (fe === 1) {
    const _e = (ne + _1n$3) / _4n;
    return function(Oe, $e) {
      const Me = Oe.pow($e, _e);
      if (!Oe.eql(Oe.sqr(Me), $e))
        throw new Error("Cannot find square root");
      return Me;
    };
  }
  const ve = (ae + _1n$3) / _2n$1;
  return function(xe, Oe) {
    if (xe.pow(Oe, oe) === xe.neg(xe.ONE))
      throw new Error("Cannot find square root");
    let $e = fe, Me = xe.pow(xe.mul(xe.ONE, ye), ae), Re = xe.pow(Oe, ve), je = xe.pow(Oe, ae);
    for (; !xe.eql(je, xe.ONE); ) {
      if (xe.eql(je, xe.ZERO))
        return xe.ZERO;
      let Be = 1;
      for (let He = xe.sqr(je); Be < $e && !xe.eql(He, xe.ONE); Be++)
        He = xe.sqr(He);
      const ze = xe.pow(Me, _1n$3 << BigInt($e - Be - 1));
      Me = xe.sqr(ze), Re = xe.mul(Re, ze), je = xe.mul(je, Me), $e = Be;
    }
    return Re;
  };
}
function FpSqrt(ne) {
  if (ne % _4n === _3n$1) {
    const oe = (ne + _1n$3) / _4n;
    return function(fe, ye) {
      const ve = fe.pow(ye, oe);
      if (!fe.eql(fe.sqr(ve), ye))
        throw new Error("Cannot find square root");
      return ve;
    };
  }
  if (ne % _8n === _5n) {
    const oe = (ne - _5n) / _8n;
    return function(fe, ye) {
      const ve = fe.mul(ye, _2n$1), _e = fe.pow(ve, oe), xe = fe.mul(ye, _e), Oe = fe.mul(fe.mul(xe, _2n$1), _e), $e = fe.mul(xe, fe.sub(Oe, fe.ONE));
      if (!fe.eql(fe.sqr($e), ye))
        throw new Error("Cannot find square root");
      return $e;
    };
  }
  return tonelliShanks(ne);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(ne) {
  const oe = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, ae = FIELD_FIELDS.reduce((fe, ye) => (fe[ye] = "function", fe), oe);
  return validateObject(ne, ae);
}
function FpPow(ne, oe, ae) {
  if (ae < _0n$2)
    throw new Error("Expected power > 0");
  if (ae === _0n$2)
    return ne.ONE;
  if (ae === _1n$3)
    return oe;
  let fe = ne.ONE, ye = oe;
  for (; ae > _0n$2; )
    ae & _1n$3 && (fe = ne.mul(fe, ye)), ye = ne.sqr(ye), ae >>= _1n$3;
  return fe;
}
function FpInvertBatch(ne, oe) {
  const ae = new Array(oe.length), fe = oe.reduce((ve, _e, xe) => ne.is0(_e) ? ve : (ae[xe] = ve, ne.mul(ve, _e)), ne.ONE), ye = ne.inv(fe);
  return oe.reduceRight((ve, _e, xe) => ne.is0(_e) ? ve : (ae[xe] = ne.mul(ve, ae[xe]), ne.mul(ve, _e)), ye), ae;
}
function nLength(ne, oe) {
  const ae = oe !== void 0 ? oe : ne.toString(2).length, fe = Math.ceil(ae / 8);
  return { nBitLength: ae, nByteLength: fe };
}
function Field(ne, oe, ae = !1, fe = {}) {
  if (ne <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ne}`);
  const { nBitLength: ye, nByteLength: ve } = nLength(ne, oe);
  if (ve > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const _e = FpSqrt(ne), xe = Object.freeze({
    ORDER: ne,
    BITS: ye,
    BYTES: ve,
    MASK: bitMask(ye),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (Oe) => mod(Oe, ne),
    isValid: (Oe) => {
      if (typeof Oe != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof Oe}`);
      return _0n$2 <= Oe && Oe < ne;
    },
    is0: (Oe) => Oe === _0n$2,
    isOdd: (Oe) => (Oe & _1n$3) === _1n$3,
    neg: (Oe) => mod(-Oe, ne),
    eql: (Oe, $e) => Oe === $e,
    sqr: (Oe) => mod(Oe * Oe, ne),
    add: (Oe, $e) => mod(Oe + $e, ne),
    sub: (Oe, $e) => mod(Oe - $e, ne),
    mul: (Oe, $e) => mod(Oe * $e, ne),
    pow: (Oe, $e) => FpPow(xe, Oe, $e),
    div: (Oe, $e) => mod(Oe * invert$1($e, ne), ne),
    // Same as above, but doesn't normalize
    sqrN: (Oe) => Oe * Oe,
    addN: (Oe, $e) => Oe + $e,
    subN: (Oe, $e) => Oe - $e,
    mulN: (Oe, $e) => Oe * $e,
    inv: (Oe) => invert$1(Oe, ne),
    sqrt: fe.sqrt || ((Oe) => _e(xe, Oe)),
    invertBatch: (Oe) => FpInvertBatch(xe, Oe),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (Oe, $e, Me) => Me ? $e : Oe,
    toBytes: (Oe) => ae ? numberToBytesLE(Oe, ve) : numberToBytesBE(Oe, ve),
    fromBytes: (Oe) => {
      if (Oe.length !== ve)
        throw new Error(`Fp.fromBytes: expected ${ve}, got ${Oe.length}`);
      return ae ? bytesToNumberLE(Oe) : bytesToNumberBE(Oe);
    }
  });
  return Object.freeze(xe);
}
function getFieldBytesLength(ne) {
  if (typeof ne != "bigint")
    throw new Error("field order must be bigint");
  const oe = ne.toString(2).length;
  return Math.ceil(oe / 8);
}
function getMinHashLength(ne) {
  const oe = getFieldBytesLength(ne);
  return oe + Math.ceil(oe / 2);
}
function mapHashToField(ne, oe, ae = !1) {
  const fe = ne.length, ye = getFieldBytesLength(oe), ve = getMinHashLength(oe);
  if (fe < 16 || fe < ve || fe > 1024)
    throw new Error(`expected ${ve}-1024 bytes of input, got ${fe}`);
  const _e = ae ? bytesToNumberBE(ne) : bytesToNumberLE(ne), xe = mod(_e, oe - _1n$3) + _1n$3;
  return ae ? numberToBytesLE(xe, ye) : numberToBytesBE(xe, ye);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(ne, oe) {
  const ae = (ye, ve) => {
    const _e = ve.negate();
    return ye ? _e : ve;
  }, fe = (ye) => {
    const ve = Math.ceil(oe / ye) + 1, _e = 2 ** (ye - 1);
    return { windows: ve, windowSize: _e };
  };
  return {
    constTimeNegate: ae,
    // non-const time multiplication ladder
    unsafeLadder(ye, ve) {
      let _e = ne.ZERO, xe = ye;
      for (; ve > _0n$1; )
        ve & _1n$2 && (_e = _e.add(xe)), xe = xe.double(), ve >>= _1n$2;
      return _e;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ye, ve) {
      const { windows: _e, windowSize: xe } = fe(ve), Oe = [];
      let $e = ye, Me = $e;
      for (let Re = 0; Re < _e; Re++) {
        Me = $e, Oe.push(Me);
        for (let je = 1; je < xe; je++)
          Me = Me.add($e), Oe.push(Me);
        $e = Me.double();
      }
      return Oe;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ye, ve, _e) {
      const { windows: xe, windowSize: Oe } = fe(ye);
      let $e = ne.ZERO, Me = ne.BASE;
      const Re = BigInt(2 ** ye - 1), je = 2 ** ye, Be = BigInt(ye);
      for (let ze = 0; ze < xe; ze++) {
        const He = ze * Oe;
        let qe = Number(_e & Re);
        _e >>= Be, qe > Oe && (qe -= je, _e += _1n$2);
        const Ye = He, pt = He + Math.abs(qe) - 1, dt = ze % 2 !== 0, yt = qe < 0;
        qe === 0 ? Me = Me.add(ae(dt, ve[Ye])) : $e = $e.add(ae(yt, ve[pt]));
      }
      return { p: $e, f: Me };
    },
    wNAFCached(ye, ve, _e, xe) {
      const Oe = ye._WINDOW_SIZE || 1;
      let $e = ve.get(ye);
      return $e || ($e = this.precomputeWindow(ye, Oe), Oe !== 1 && ve.set(ye, xe($e))), this.wNAF(Oe, $e, _e);
    }
  };
}
function validateBasic(ne) {
  return validateField(ne.Fp), validateObject(ne, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(ne.n, ne.nBitLength),
    ...ne,
    p: ne.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(ne) {
  const oe = validateBasic(ne);
  validateObject(oe, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: ae, Fp: fe, a: ye } = oe;
  if (ae) {
    if (!fe.eql(ye, fe.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof ae != "object" || typeof ae.beta != "bigint" || typeof ae.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...oe });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(oe = "") {
      super(oe);
    }
  },
  _parseInt(ne) {
    const { Err: oe } = DER;
    if (ne.length < 2 || ne[0] !== 2)
      throw new oe("Invalid signature integer tag");
    const ae = ne[1], fe = ne.subarray(2, ae + 2);
    if (!ae || fe.length !== ae)
      throw new oe("Invalid signature integer: wrong length");
    if (fe[0] & 128)
      throw new oe("Invalid signature integer: negative");
    if (fe[0] === 0 && !(fe[1] & 128))
      throw new oe("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(fe), l: ne.subarray(ae + 2) };
  },
  toSig(ne) {
    const { Err: oe } = DER, ae = typeof ne == "string" ? h2b(ne) : ne;
    if (!(ae instanceof Uint8Array))
      throw new Error("ui8a expected");
    let fe = ae.length;
    if (fe < 2 || ae[0] != 48)
      throw new oe("Invalid signature tag");
    if (ae[1] !== fe - 2)
      throw new oe("Invalid signature: incorrect length");
    const { d: ye, l: ve } = DER._parseInt(ae.subarray(2)), { d: _e, l: xe } = DER._parseInt(ve);
    if (xe.length)
      throw new oe("Invalid signature: left bytes after parsing");
    return { r: ye, s: _e };
  },
  hexFromSig(ne) {
    const oe = ($e) => Number.parseInt($e[0], 16) & 8 ? "00" + $e : $e, ae = ($e) => {
      const Me = $e.toString(16);
      return Me.length & 1 ? `0${Me}` : Me;
    }, fe = oe(ae(ne.s)), ye = oe(ae(ne.r)), ve = fe.length / 2, _e = ye.length / 2, xe = ae(ve), Oe = ae(_e);
    return `30${ae(_e + ve + 4)}02${Oe}${ye}02${xe}${fe}`;
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(ne) {
  const oe = validatePointOpts(ne), { Fp: ae } = oe, fe = oe.toBytes || ((ze, He, qe) => {
    const Ye = He.toAffine();
    return concatBytes(Uint8Array.from([4]), ae.toBytes(Ye.x), ae.toBytes(Ye.y));
  }), ye = oe.fromBytes || ((ze) => {
    const He = ze.subarray(1), qe = ae.fromBytes(He.subarray(0, ae.BYTES)), Ye = ae.fromBytes(He.subarray(ae.BYTES, 2 * ae.BYTES));
    return { x: qe, y: Ye };
  });
  function ve(ze) {
    const { a: He, b: qe } = oe, Ye = ae.sqr(ze), pt = ae.mul(Ye, ze);
    return ae.add(ae.add(pt, ae.mul(ze, He)), qe);
  }
  if (!ae.eql(ae.sqr(oe.Gy), ve(oe.Gx)))
    throw new Error("bad generator point: equation left != right");
  function _e(ze) {
    return typeof ze == "bigint" && _0n < ze && ze < oe.n;
  }
  function xe(ze) {
    if (!_e(ze))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function Oe(ze) {
    const { allowedPrivateKeyLengths: He, nByteLength: qe, wrapPrivateKey: Ye, n: pt } = oe;
    if (He && typeof ze != "bigint") {
      if (ze instanceof Uint8Array && (ze = bytesToHex$1(ze)), typeof ze != "string" || !He.includes(ze.length))
        throw new Error("Invalid key");
      ze = ze.padStart(qe * 2, "0");
    }
    let dt;
    try {
      dt = typeof ze == "bigint" ? ze : bytesToNumberBE(ensureBytes("private key", ze, qe));
    } catch {
      throw new Error(`private key must be ${qe} bytes, hex or bigint, not ${typeof ze}`);
    }
    return Ye && (dt = mod(dt, pt)), xe(dt), dt;
  }
  const $e = /* @__PURE__ */ new Map();
  function Me(ze) {
    if (!(ze instanceof Re))
      throw new Error("ProjectivePoint expected");
  }
  class Re {
    constructor(He, qe, Ye) {
      if (this.px = He, this.py = qe, this.pz = Ye, He == null || !ae.isValid(He))
        throw new Error("x required");
      if (qe == null || !ae.isValid(qe))
        throw new Error("y required");
      if (Ye == null || !ae.isValid(Ye))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(He) {
      const { x: qe, y: Ye } = He || {};
      if (!He || !ae.isValid(qe) || !ae.isValid(Ye))
        throw new Error("invalid affine point");
      if (He instanceof Re)
        throw new Error("projective point not allowed");
      const pt = (dt) => ae.eql(dt, ae.ZERO);
      return pt(qe) && pt(Ye) ? Re.ZERO : new Re(qe, Ye, ae.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(He) {
      const qe = ae.invertBatch(He.map((Ye) => Ye.pz));
      return He.map((Ye, pt) => Ye.toAffine(qe[pt])).map(Re.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(He) {
      const qe = Re.fromAffine(ye(ensureBytes("pointHex", He)));
      return qe.assertValidity(), qe;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(He) {
      return Re.BASE.multiply(Oe(He));
    }
    // "Private method", don't use it directly
    _setWindowSize(He) {
      this._WINDOW_SIZE = He, $e.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (oe.allowInfinityPoint && !ae.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: He, y: qe } = this.toAffine();
      if (!ae.isValid(He) || !ae.isValid(qe))
        throw new Error("bad point: x or y not FE");
      const Ye = ae.sqr(qe), pt = ve(He);
      if (!ae.eql(Ye, pt))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: He } = this.toAffine();
      if (ae.isOdd)
        return !ae.isOdd(He);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(He) {
      Me(He);
      const { px: qe, py: Ye, pz: pt } = this, { px: dt, py: yt, pz: Ct } = He, It = ae.eql(ae.mul(qe, Ct), ae.mul(dt, pt)), Vt = ae.eql(ae.mul(Ye, Ct), ae.mul(yt, pt));
      return It && Vt;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Re(this.px, ae.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: He, b: qe } = oe, Ye = ae.mul(qe, _3n), { px: pt, py: dt, pz: yt } = this;
      let Ct = ae.ZERO, It = ae.ZERO, Vt = ae.ZERO, Ut = ae.mul(pt, pt), Zt = ae.mul(dt, dt), tr = ae.mul(yt, yt), er = ae.mul(pt, dt);
      return er = ae.add(er, er), Vt = ae.mul(pt, yt), Vt = ae.add(Vt, Vt), Ct = ae.mul(He, Vt), It = ae.mul(Ye, tr), It = ae.add(Ct, It), Ct = ae.sub(Zt, It), It = ae.add(Zt, It), It = ae.mul(Ct, It), Ct = ae.mul(er, Ct), Vt = ae.mul(Ye, Vt), tr = ae.mul(He, tr), er = ae.sub(Ut, tr), er = ae.mul(He, er), er = ae.add(er, Vt), Vt = ae.add(Ut, Ut), Ut = ae.add(Vt, Ut), Ut = ae.add(Ut, tr), Ut = ae.mul(Ut, er), It = ae.add(It, Ut), tr = ae.mul(dt, yt), tr = ae.add(tr, tr), Ut = ae.mul(tr, er), Ct = ae.sub(Ct, Ut), Vt = ae.mul(tr, Zt), Vt = ae.add(Vt, Vt), Vt = ae.add(Vt, Vt), new Re(Ct, It, Vt);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(He) {
      Me(He);
      const { px: qe, py: Ye, pz: pt } = this, { px: dt, py: yt, pz: Ct } = He;
      let It = ae.ZERO, Vt = ae.ZERO, Ut = ae.ZERO;
      const Zt = oe.a, tr = ae.mul(oe.b, _3n);
      let er = ae.mul(qe, dt), hr = ae.mul(Ye, yt), Ot = ae.mul(pt, Ct), Qe = ae.add(qe, Ye), at = ae.add(dt, yt);
      Qe = ae.mul(Qe, at), at = ae.add(er, hr), Qe = ae.sub(Qe, at), at = ae.add(qe, pt);
      let wt = ae.add(dt, Ct);
      return at = ae.mul(at, wt), wt = ae.add(er, Ot), at = ae.sub(at, wt), wt = ae.add(Ye, pt), It = ae.add(yt, Ct), wt = ae.mul(wt, It), It = ae.add(hr, Ot), wt = ae.sub(wt, It), Ut = ae.mul(Zt, at), It = ae.mul(tr, Ot), Ut = ae.add(It, Ut), It = ae.sub(hr, Ut), Ut = ae.add(hr, Ut), Vt = ae.mul(It, Ut), hr = ae.add(er, er), hr = ae.add(hr, er), Ot = ae.mul(Zt, Ot), at = ae.mul(tr, at), hr = ae.add(hr, Ot), Ot = ae.sub(er, Ot), Ot = ae.mul(Zt, Ot), at = ae.add(at, Ot), er = ae.mul(hr, at), Vt = ae.add(Vt, er), er = ae.mul(wt, at), It = ae.mul(Qe, It), It = ae.sub(It, er), er = ae.mul(Qe, hr), Ut = ae.mul(wt, Ut), Ut = ae.add(Ut, er), new Re(It, Vt, Ut);
    }
    subtract(He) {
      return this.add(He.negate());
    }
    is0() {
      return this.equals(Re.ZERO);
    }
    wNAF(He) {
      return Be.wNAFCached(this, $e, He, (qe) => {
        const Ye = ae.invertBatch(qe.map((pt) => pt.pz));
        return qe.map((pt, dt) => pt.toAffine(Ye[dt])).map(Re.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(He) {
      const qe = Re.ZERO;
      if (He === _0n)
        return qe;
      if (xe(He), He === _1n$1)
        return this;
      const { endo: Ye } = oe;
      if (!Ye)
        return Be.unsafeLadder(this, He);
      let { k1neg: pt, k1: dt, k2neg: yt, k2: Ct } = Ye.splitScalar(He), It = qe, Vt = qe, Ut = this;
      for (; dt > _0n || Ct > _0n; )
        dt & _1n$1 && (It = It.add(Ut)), Ct & _1n$1 && (Vt = Vt.add(Ut)), Ut = Ut.double(), dt >>= _1n$1, Ct >>= _1n$1;
      return pt && (It = It.negate()), yt && (Vt = Vt.negate()), Vt = new Re(ae.mul(Vt.px, Ye.beta), Vt.py, Vt.pz), It.add(Vt);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(He) {
      xe(He);
      let qe = He, Ye, pt;
      const { endo: dt } = oe;
      if (dt) {
        const { k1neg: yt, k1: Ct, k2neg: It, k2: Vt } = dt.splitScalar(qe);
        let { p: Ut, f: Zt } = this.wNAF(Ct), { p: tr, f: er } = this.wNAF(Vt);
        Ut = Be.constTimeNegate(yt, Ut), tr = Be.constTimeNegate(It, tr), tr = new Re(ae.mul(tr.px, dt.beta), tr.py, tr.pz), Ye = Ut.add(tr), pt = Zt.add(er);
      } else {
        const { p: yt, f: Ct } = this.wNAF(qe);
        Ye = yt, pt = Ct;
      }
      return Re.normalizeZ([Ye, pt])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(He, qe, Ye) {
      const pt = Re.BASE, dt = (Ct, It) => It === _0n || It === _1n$1 || !Ct.equals(pt) ? Ct.multiplyUnsafe(It) : Ct.multiply(It), yt = dt(this, qe).add(dt(He, Ye));
      return yt.is0() ? void 0 : yt;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(He) {
      const { px: qe, py: Ye, pz: pt } = this, dt = this.is0();
      He == null && (He = dt ? ae.ONE : ae.inv(pt));
      const yt = ae.mul(qe, He), Ct = ae.mul(Ye, He), It = ae.mul(pt, He);
      if (dt)
        return { x: ae.ZERO, y: ae.ZERO };
      if (!ae.eql(It, ae.ONE))
        throw new Error("invZ was invalid");
      return { x: yt, y: Ct };
    }
    isTorsionFree() {
      const { h: He, isTorsionFree: qe } = oe;
      if (He === _1n$1)
        return !0;
      if (qe)
        return qe(Re, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: He, clearCofactor: qe } = oe;
      return He === _1n$1 ? this : qe ? qe(Re, this) : this.multiplyUnsafe(oe.h);
    }
    toRawBytes(He = !0) {
      return this.assertValidity(), fe(Re, this, He);
    }
    toHex(He = !0) {
      return bytesToHex$1(this.toRawBytes(He));
    }
  }
  Re.BASE = new Re(oe.Gx, oe.Gy, ae.ONE), Re.ZERO = new Re(ae.ZERO, ae.ONE, ae.ZERO);
  const je = oe.nBitLength, Be = wNAF(Re, oe.endo ? Math.ceil(je / 2) : je);
  return {
    CURVE: oe,
    ProjectivePoint: Re,
    normPrivateKeyToScalar: Oe,
    weierstrassEquation: ve,
    isWithinCurveOrder: _e
  };
}
function validateOpts(ne) {
  const oe = validateBasic(ne);
  return validateObject(oe, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...oe });
}
function weierstrass(ne) {
  const oe = validateOpts(ne), { Fp: ae, n: fe } = oe, ye = ae.BYTES + 1, ve = 2 * ae.BYTES + 1;
  function _e(at) {
    return _0n < at && at < ae.ORDER;
  }
  function xe(at) {
    return mod(at, fe);
  }
  function Oe(at) {
    return invert$1(at, fe);
  }
  const { ProjectivePoint: $e, normPrivateKeyToScalar: Me, weierstrassEquation: Re, isWithinCurveOrder: je } = weierstrassPoints({
    ...oe,
    toBytes(at, wt, bt) {
      const At = wt.toAffine(), Ft = ae.toBytes(At.x), Gt = concatBytes;
      return bt ? Gt(Uint8Array.from([wt.hasEvenY() ? 2 : 3]), Ft) : Gt(Uint8Array.from([4]), Ft, ae.toBytes(At.y));
    },
    fromBytes(at) {
      const wt = at.length, bt = at[0], At = at.subarray(1);
      if (wt === ye && (bt === 2 || bt === 3)) {
        const Ft = bytesToNumberBE(At);
        if (!_e(Ft))
          throw new Error("Point is not on curve");
        const Gt = Re(Ft);
        let ot = ae.sqrt(Gt);
        const et = (ot & _1n$1) === _1n$1;
        return (bt & 1) === 1 !== et && (ot = ae.neg(ot)), { x: Ft, y: ot };
      } else if (wt === ve && bt === 4) {
        const Ft = ae.fromBytes(At.subarray(0, ae.BYTES)), Gt = ae.fromBytes(At.subarray(ae.BYTES, 2 * ae.BYTES));
        return { x: Ft, y: Gt };
      } else
        throw new Error(`Point of length ${wt} was invalid. Expected ${ye} compressed bytes or ${ve} uncompressed bytes`);
    }
  }), Be = (at) => bytesToHex$1(numberToBytesBE(at, oe.nByteLength));
  function ze(at) {
    const wt = fe >> _1n$1;
    return at > wt;
  }
  function He(at) {
    return ze(at) ? xe(-at) : at;
  }
  const qe = (at, wt, bt) => bytesToNumberBE(at.slice(wt, bt));
  class Ye {
    constructor(wt, bt, At) {
      this.r = wt, this.s = bt, this.recovery = At, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(wt) {
      const bt = oe.nByteLength;
      return wt = ensureBytes("compactSignature", wt, bt * 2), new Ye(qe(wt, 0, bt), qe(wt, bt, 2 * bt));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(wt) {
      const { r: bt, s: At } = DER.toSig(ensureBytes("DER", wt));
      return new Ye(bt, At);
    }
    assertValidity() {
      if (!je(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!je(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(wt) {
      return new Ye(this.r, this.s, wt);
    }
    recoverPublicKey(wt) {
      const { r: bt, s: At, recovery: Ft } = this, Gt = Vt(ensureBytes("msgHash", wt));
      if (Ft == null || ![0, 1, 2, 3].includes(Ft))
        throw new Error("recovery id invalid");
      const ot = Ft === 2 || Ft === 3 ? bt + oe.n : bt;
      if (ot >= ae.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const et = Ft & 1 ? "03" : "02", Rt = $e.fromHex(et + Be(ot)), xr = Oe(ot), Xt = xe(-Gt * xr), dr = xe(At * xr), Nr = $e.BASE.multiplyAndAddUnsafe(Rt, Xt, dr);
      if (!Nr)
        throw new Error("point at infinify");
      return Nr.assertValidity(), Nr;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return ze(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ye(this.r, xe(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return Be(this.r) + Be(this.s);
    }
  }
  const pt = {
    isValidPrivateKey(at) {
      try {
        return Me(at), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: Me,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const at = getMinHashLength(oe.n);
      return mapHashToField(oe.randomBytes(at), oe.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(at = 8, wt = $e.BASE) {
      return wt._setWindowSize(at), wt.multiply(BigInt(3)), wt;
    }
  };
  function dt(at, wt = !0) {
    return $e.fromPrivateKey(at).toRawBytes(wt);
  }
  function yt(at) {
    const wt = at instanceof Uint8Array, bt = typeof at == "string", At = (wt || bt) && at.length;
    return wt ? At === ye || At === ve : bt ? At === 2 * ye || At === 2 * ve : at instanceof $e;
  }
  function Ct(at, wt, bt = !0) {
    if (yt(at))
      throw new Error("first arg must be private key");
    if (!yt(wt))
      throw new Error("second arg must be public key");
    return $e.fromHex(wt).multiply(Me(at)).toRawBytes(bt);
  }
  const It = oe.bits2int || function(at) {
    const wt = bytesToNumberBE(at), bt = at.length * 8 - oe.nBitLength;
    return bt > 0 ? wt >> BigInt(bt) : wt;
  }, Vt = oe.bits2int_modN || function(at) {
    return xe(It(at));
  }, Ut = bitMask(oe.nBitLength);
  function Zt(at) {
    if (typeof at != "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= at && at < Ut))
      throw new Error(`bigint expected < 2^${oe.nBitLength}`);
    return numberToBytesBE(at, oe.nByteLength);
  }
  function tr(at, wt, bt = er) {
    if (["recovered", "canonical"].some((jr) => jr in bt))
      throw new Error("sign() legacy options not supported");
    const { hash: At, randomBytes: Ft } = oe;
    let { lowS: Gt, prehash: ot, extraEntropy: et } = bt;
    Gt == null && (Gt = !0), at = ensureBytes("msgHash", at), ot && (at = ensureBytes("prehashed msgHash", At(at)));
    const Rt = Vt(at), xr = Me(wt), Xt = [Zt(xr), Zt(Rt)];
    if (et != null) {
      const jr = et === !0 ? Ft(ae.BYTES) : et;
      Xt.push(ensureBytes("extraEntropy", jr));
    }
    const dr = concatBytes(...Xt), Nr = Rt;
    function Dr(jr) {
      const un = It(jr);
      if (!je(un))
        return;
      const so = Oe(un), Pn = $e.BASE.multiply(un).toAffine(), co = xe(Pn.x);
      if (co === _0n)
        return;
      const kn = xe(so * xe(Nr + co * xr));
      if (kn === _0n)
        return;
      let Yn = (Pn.x === co ? 0 : 2) | Number(Pn.y & _1n$1), Ho = kn;
      return Gt && ze(kn) && (Ho = He(kn), Yn ^= 1), new Ye(co, Ho, Yn);
    }
    return { seed: dr, k2sig: Dr };
  }
  const er = { lowS: oe.lowS, prehash: !1 }, hr = { lowS: oe.lowS, prehash: !1 };
  function Ot(at, wt, bt = er) {
    const { seed: At, k2sig: Ft } = tr(at, wt, bt), Gt = oe;
    return createHmacDrbg(Gt.hash.outputLen, Gt.nByteLength, Gt.hmac)(At, Ft);
  }
  $e.BASE._setWindowSize(8);
  function Qe(at, wt, bt, At = hr) {
    var Pn;
    const Ft = at;
    if (wt = ensureBytes("msgHash", wt), bt = ensureBytes("publicKey", bt), "strict" in At)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Gt, prehash: ot } = At;
    let et, Rt;
    try {
      if (typeof Ft == "string" || Ft instanceof Uint8Array)
        try {
          et = Ye.fromDER(Ft);
        } catch (co) {
          if (!(co instanceof DER.Err))
            throw co;
          et = Ye.fromCompact(Ft);
        }
      else if (typeof Ft == "object" && typeof Ft.r == "bigint" && typeof Ft.s == "bigint") {
        const { r: co, s: kn } = Ft;
        et = new Ye(co, kn);
      } else
        throw new Error("PARSE");
      Rt = $e.fromHex(bt);
    } catch (co) {
      if (co.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Gt && et.hasHighS())
      return !1;
    ot && (wt = oe.hash(wt));
    const { r: xr, s: Xt } = et, dr = Vt(wt), Nr = Oe(Xt), Dr = xe(dr * Nr), jr = xe(xr * Nr), un = (Pn = $e.BASE.multiplyAndAddUnsafe(Rt, Dr, jr)) == null ? void 0 : Pn.toAffine();
    return un ? xe(un.x) === xr : !1;
  }
  return {
    CURVE: oe,
    getPublicKey: dt,
    getSharedSecret: Ct,
    sign: Ot,
    verify: Qe,
    ProjectivePoint: $e,
    Signature: Ye,
    utils: pt
  };
}
class HMAC extends Hash {
  constructor(oe, ae) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(oe);
    const fe = toBytes(ae);
    if (this.iHash = oe.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const ye = this.blockLen, ve = new Uint8Array(ye);
    ve.set(fe.length > ye ? oe.create().update(fe).digest() : fe);
    for (let _e = 0; _e < ve.length; _e++)
      ve[_e] ^= 54;
    this.iHash.update(ve), this.oHash = oe.create();
    for (let _e = 0; _e < ve.length; _e++)
      ve[_e] ^= 106;
    this.oHash.update(ve), ve.fill(0);
  }
  update(oe) {
    return exists(this), this.iHash.update(oe), this;
  }
  digestInto(oe) {
    exists(this), bytes(oe, this.outputLen), this.finished = !0, this.iHash.digestInto(oe), this.oHash.update(oe), this.oHash.digestInto(oe), this.destroy();
  }
  digest() {
    const oe = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(oe), oe;
  }
  _cloneInto(oe) {
    oe || (oe = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: ae, iHash: fe, finished: ye, destroyed: ve, blockLen: _e, outputLen: xe } = this;
    return oe = oe, oe.finished = ye, oe.destroyed = ve, oe.blockLen = _e, oe.outputLen = xe, oe.oHash = ae._cloneInto(oe.oHash), oe.iHash = fe._cloneInto(oe.iHash), oe;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (ne, oe, ae) => new HMAC(ne, oe).update(ae).digest();
hmac.create = (ne, oe) => new HMAC(ne, oe);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(ne) {
  return {
    hash: ne,
    hmac: (oe, ...ae) => hmac(ne, oe, concatBytes$2(...ae)),
    randomBytes
  };
}
function createCurve(ne, oe) {
  const ae = (fe) => weierstrass({ ...ne, ...getHash(fe) });
  return Object.freeze({ ...ae(oe), create: ae });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (ne, oe) => (ne + oe / _2n) / oe;
function sqrtMod(ne) {
  const oe = secp256k1P, ae = BigInt(3), fe = BigInt(6), ye = BigInt(11), ve = BigInt(22), _e = BigInt(23), xe = BigInt(44), Oe = BigInt(88), $e = ne * ne * ne % oe, Me = $e * $e * ne % oe, Re = pow2(Me, ae, oe) * Me % oe, je = pow2(Re, ae, oe) * Me % oe, Be = pow2(je, _2n, oe) * $e % oe, ze = pow2(Be, ye, oe) * Be % oe, He = pow2(ze, ve, oe) * ze % oe, qe = pow2(He, xe, oe) * He % oe, Ye = pow2(qe, Oe, oe) * qe % oe, pt = pow2(Ye, xe, oe) * He % oe, dt = pow2(pt, ae, oe) * Me % oe, yt = pow2(dt, _e, oe) * ze % oe, Ct = pow2(yt, fe, oe) * $e % oe, It = pow2(Ct, _2n, oe);
  if (!Fp.eql(Fp.sqr(It), ne))
    throw new Error("Cannot find square root");
  return It;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (ne) => {
      const oe = secp256k1N, ae = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), fe = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ye = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ve = ae, _e = BigInt("0x100000000000000000000000000000000"), xe = divNearest(ve * ne, oe), Oe = divNearest(-fe * ne, oe);
      let $e = mod(ne - xe * ae - Oe * ye, oe), Me = mod(-xe * fe - Oe * ve, oe);
      const Re = $e > _e, je = Me > _e;
      if (Re && ($e = oe - $e), je && (Me = oe - Me), $e > _e || Me > _e)
        throw new Error("splitScalar: Endomorphism failed, k=" + ne);
      return { k1neg: Re, k1: $e, k2neg: je, k2: Me };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
function signatureToHex({ r: ne, s: oe, v: ae, yParity: fe }) {
  const ye = (() => {
    if (ae === 27n || fe === 0)
      return "1b";
    if (ae === 28n || fe === 1)
      return "1c";
    throw new Error("Invalid v value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(ne), hexToBigInt(oe)).toCompactHex()}${ye}`;
}
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Long(ne, oe, ae) {
  this.low = ne | 0, this.high = oe | 0, this.unsigned = !!ae;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: !0 });
function isLong(ne) {
  return (ne && ne.__isLong__) === !0;
}
function ctz32(ne) {
  var oe = Math.clz32(ne & -ne);
  return ne ? 31 - oe : oe;
}
Long.isLong = isLong;
var INT_CACHE = {}, UINT_CACHE = {};
function fromInt(ne, oe) {
  var ae, fe, ye;
  return oe ? (ne >>>= 0, (ye = 0 <= ne && ne < 256) && (fe = UINT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, 0, !0), ye && (UINT_CACHE[ne] = ae), ae)) : (ne |= 0, (ye = -128 <= ne && ne < 128) && (fe = INT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, ne < 0 ? -1 : 0, !1), ye && (INT_CACHE[ne] = ae), ae));
}
Long.fromInt = fromInt;
function fromNumber(ne, oe) {
  if (isNaN(ne))
    return oe ? UZERO : ZERO;
  if (oe) {
    if (ne < 0)
      return UZERO;
    if (ne >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (ne <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (ne + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  return ne < 0 ? fromNumber(-ne, oe).neg() : fromBits(ne % TWO_PWR_32_DBL | 0, ne / TWO_PWR_32_DBL | 0, oe);
}
Long.fromNumber = fromNumber;
function fromBits(ne, oe, ae) {
  return new Long(ne, oe, ae);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(ne, oe, ae) {
  if (ne.length === 0)
    throw Error("empty string");
  if (typeof oe == "number" ? (ae = oe, oe = !1) : oe = !!oe, ne === "NaN" || ne === "Infinity" || ne === "+Infinity" || ne === "-Infinity")
    return oe ? UZERO : ZERO;
  if (ae = ae || 10, ae < 2 || 36 < ae)
    throw RangeError("radix");
  var fe;
  if ((fe = ne.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (fe === 0)
    return fromString(ne.substring(1), oe, ae).neg();
  for (var ye = fromNumber(pow_dbl(ae, 8)), ve = ZERO, _e = 0; _e < ne.length; _e += 8) {
    var xe = Math.min(8, ne.length - _e), Oe = parseInt(ne.substring(_e, _e + xe), ae);
    if (xe < 8) {
      var $e = fromNumber(pow_dbl(ae, xe));
      ve = ve.mul($e).add(fromNumber(Oe));
    } else
      ve = ve.mul(ye), ve = ve.add(fromNumber(Oe));
  }
  return ve.unsigned = oe, ve;
}
Long.fromString = fromString;
function fromValue(ne, oe) {
  return typeof ne == "number" ? fromNumber(ne, oe) : typeof ne == "string" ? fromString(ne, oe) : fromBits(ne.low, ne.high, typeof oe == "boolean" ? oe : ne.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536, TWO_PWR_24_DBL = 1 << 24, TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = fromInt(TWO_PWR_24_DBL), ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE$1 = fromInt(1);
Long.ONE = ONE$1;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function(oe) {
  if (oe = oe || 10, oe < 2 || 36 < oe)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(MIN_VALUE)) {
      var ae = fromNumber(oe), fe = this.div(ae), ye = fe.mul(ae).sub(this);
      return fe.toString(oe) + ye.toInt().toString(oe);
    } else
      return "-" + this.neg().toString(oe);
  for (var ve = fromNumber(pow_dbl(oe, 6), this.unsigned), _e = this, xe = ""; ; ) {
    var Oe = _e.div(ve), $e = _e.sub(Oe.mul(ve)).toInt() >>> 0, Me = $e.toString(oe);
    if (_e = Oe, _e.isZero())
      return Me + xe;
    for (; Me.length < 6; )
      Me = "0" + Me;
    xe = "" + Me + xe;
  }
};
LongPrototype.getHighBits = function() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (var oe = this.high != 0 ? this.high : this.low, ae = 31; ae > 0 && !(oe & 1 << ae); ae--)
    ;
  return this.high != 0 ? ae + 33 : ae + 1;
};
LongPrototype.isZero = function() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.unsigned !== oe.unsigned && this.high >>> 31 === 1 && oe.high >>> 31 === 1 ? !1 : this.high === oe.high && this.low === oe.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function(oe) {
  return !this.eq(
    /* validates */
    oe
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), this.eq(oe))
    return 0;
  var ae = this.isNegative(), fe = oe.isNegative();
  return ae && !fe ? -1 : !ae && fe ? 1 : this.unsigned ? oe.high >>> 0 > this.high >>> 0 || oe.high === this.high && oe.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(oe).isNegative() ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function() {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE$1);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function(oe) {
  isLong(oe) || (oe = fromValue(oe));
  var ae = this.high >>> 16, fe = this.high & 65535, ye = this.low >>> 16, ve = this.low & 65535, _e = oe.high >>> 16, xe = oe.high & 65535, Oe = oe.low >>> 16, $e = oe.low & 65535, Me = 0, Re = 0, je = 0, Be = 0;
  return Be += ve + $e, je += Be >>> 16, Be &= 65535, je += ye + Oe, Re += je >>> 16, je &= 65535, Re += fe + xe, Me += Re >>> 16, Re &= 65535, Me += ae + _e, Me &= 65535, fromBits(je << 16 | Be, Me << 16 | Re, this.unsigned);
};
LongPrototype.subtract = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.add(oe.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function(oe) {
  if (this.isZero())
    return this;
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = wasm.mul(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (oe.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return oe.isOdd() ? MIN_VALUE : ZERO;
  if (oe.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return oe.isNegative() ? this.neg().mul(oe.neg()) : this.neg().mul(oe).neg();
  if (oe.isNegative())
    return this.mul(oe.neg()).neg();
  if (this.lt(TWO_PWR_24) && oe.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * oe.toNumber(), this.unsigned);
  var fe = this.high >>> 16, ye = this.high & 65535, ve = this.low >>> 16, _e = this.low & 65535, xe = oe.high >>> 16, Oe = oe.high & 65535, $e = oe.low >>> 16, Me = oe.low & 65535, Re = 0, je = 0, Be = 0, ze = 0;
  return ze += _e * Me, Be += ze >>> 16, ze &= 65535, Be += ve * Me, je += Be >>> 16, Be &= 65535, Be += _e * $e, je += Be >>> 16, Be &= 65535, je += ye * Me, Re += je >>> 16, je &= 65535, je += ve * $e, Re += je >>> 16, je &= 65535, je += _e * Oe, Re += je >>> 16, je &= 65535, Re += fe * Me + ye * $e + ve * Oe + _e * xe, Re &= 65535, fromBits(Be << 16 | ze, Re << 16 | je, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), oe.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && oe.low === -1 && oe.high === -1)
      return this;
    var ae = (this.unsigned ? wasm.div_u : wasm.div_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var fe, ye, ve;
  if (this.unsigned) {
    if (oe.unsigned || (oe = oe.toUnsigned()), oe.gt(this))
      return UZERO;
    if (oe.gt(this.shru(1)))
      return UONE;
    ve = UZERO;
  } else {
    if (this.eq(MIN_VALUE)) {
      if (oe.eq(ONE$1) || oe.eq(NEG_ONE))
        return MIN_VALUE;
      if (oe.eq(MIN_VALUE))
        return ONE$1;
      var _e = this.shr(1);
      return fe = _e.div(oe).shl(1), fe.eq(ZERO) ? oe.isNegative() ? ONE$1 : NEG_ONE : (ye = this.sub(oe.mul(fe)), ve = fe.add(ye.div(oe)), ve);
    } else if (oe.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return oe.isNegative() ? this.neg().div(oe.neg()) : this.neg().div(oe).neg();
    if (oe.isNegative())
      return this.div(oe.neg()).neg();
    ve = ZERO;
  }
  for (ye = this; ye.gte(oe); ) {
    fe = Math.max(1, Math.floor(ye.toNumber() / oe.toNumber()));
    for (var xe = Math.ceil(Math.log(fe) / Math.LN2), Oe = xe <= 48 ? 1 : pow_dbl(2, xe - 48), $e = fromNumber(fe), Me = $e.mul(oe); Me.isNegative() || Me.gt(ye); )
      fe -= Oe, $e = fromNumber(fe, this.unsigned), Me = $e.mul(oe);
    $e.isZero() && ($e = ONE$1), ve = ve.add($e), ye = ye.sub(Me);
  }
  return ve;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(oe).mul(oe));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low & oe.low, this.high & oe.high, this.unsigned);
};
LongPrototype.or = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low | oe.low, this.high | oe.high, this.unsigned);
};
LongPrototype.xor = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low ^ oe.low, this.high ^ oe.high, this.unsigned);
};
LongPrototype.shiftLeft = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low << oe, this.high << oe | this.low >>> 32 - oe, this.unsigned) : fromBits(0, this.low << oe - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >> oe, this.unsigned) : fromBits(this.high >> oe - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >>> oe, this.unsigned) : oe === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> oe - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.low << oe | this.high >>> ae, this.high << oe | this.low >>> ae, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.high << oe | this.low >>> ae, this.low << oe | this.high >>> ae, this.unsigned));
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.high << ae | this.low >>> oe, this.low << ae | this.high >>> oe, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.low << ae | this.high >>> oe, this.high << ae | this.low >>> oe, this.unsigned));
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function() {
  return this.unsigned ? fromBits(this.low, this.high, !1) : this;
};
LongPrototype.toUnsigned = function() {
  return this.unsigned ? this : fromBits(this.low, this.high, !0);
};
LongPrototype.toBytes = function(oe) {
  return oe ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function() {
  var oe = this.high, ae = this.low;
  return [
    ae & 255,
    ae >>> 8 & 255,
    ae >>> 16 & 255,
    ae >>> 24,
    oe & 255,
    oe >>> 8 & 255,
    oe >>> 16 & 255,
    oe >>> 24
  ];
};
LongPrototype.toBytesBE = function() {
  var oe = this.high, ae = this.low;
  return [
    oe >>> 24,
    oe >>> 16 & 255,
    oe >>> 8 & 255,
    oe & 255,
    ae >>> 24,
    ae >>> 16 & 255,
    ae >>> 8 & 255,
    ae & 255
  ];
};
Long.fromBytes = function(oe, ae, fe) {
  return fe ? Long.fromBytesLE(oe, ae) : Long.fromBytesBE(oe, ae);
};
Long.fromBytesLE = function(oe, ae) {
  return new Long(
    oe[0] | oe[1] << 8 | oe[2] << 16 | oe[3] << 24,
    oe[4] | oe[5] << 8 | oe[6] << 16 | oe[7] << 24,
    ae
  );
};
Long.fromBytesBE = function(oe, ae) {
  return new Long(
    oe[4] << 24 | oe[5] << 16 | oe[6] << 8 | oe[7],
    oe[0] << 24 | oe[1] << 16 | oe[2] << 8 | oe[3],
    ae
  );
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(ne) {
  return ne && ne.__esModule && Object.prototype.hasOwnProperty.call(ne, "default") ? ne.default : ne;
}
function getAugmentedNamespace(ne) {
  if (ne.__esModule)
    return ne;
  var oe = ne.default;
  if (typeof oe == "function") {
    var ae = function fe() {
      return this instanceof fe ? Reflect.construct(oe, arguments, this.constructor) : oe.apply(this, arguments);
    };
    ae.prototype = oe.prototype;
  } else
    ae = {};
  return Object.defineProperty(ae, "__esModule", { value: !0 }), Object.keys(ne).forEach(function(fe) {
    var ye = Object.getOwnPropertyDescriptor(ne, fe);
    Object.defineProperty(ae, fe, ye.get ? ye : {
      enumerable: !0,
      get: function() {
        return ne[fe];
      }
    });
  }), ae;
}
var indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(ne, oe) {
  for (var ae = new Array(arguments.length - 1), fe = 0, ye = 2, ve = !0; ye < arguments.length; )
    ae[fe++] = arguments[ye++];
  return new Promise(function(xe, Oe) {
    ae[fe] = function(Me) {
      if (ve)
        if (ve = !1, Me)
          Oe(Me);
        else {
          for (var Re = new Array(arguments.length - 1), je = 0; je < Re.length; )
            Re[je++] = arguments[je];
          xe.apply(null, Re);
        }
    };
    try {
      ne.apply(oe || null, ae);
    } catch ($e) {
      ve && (ve = !1, Oe($e));
    }
  });
}
var base64$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(xe) {
    var Oe = xe.length;
    if (!Oe)
      return 0;
    for (var $e = 0; --Oe % 4 > 1 && xe.charAt(Oe) === "="; )
      ++$e;
    return Math.ceil(xe.length * 3) / 4 - $e;
  };
  for (var ae = new Array(64), fe = new Array(123), ye = 0; ye < 64; )
    fe[ae[ye] = ye < 26 ? ye + 65 : ye < 52 ? ye + 71 : ye < 62 ? ye - 4 : ye - 59 | 43] = ye++;
  oe.encode = function(xe, Oe, $e) {
    for (var Me = null, Re = [], je = 0, Be = 0, ze; Oe < $e; ) {
      var He = xe[Oe++];
      switch (Be) {
        case 0:
          Re[je++] = ae[He >> 2], ze = (He & 3) << 4, Be = 1;
          break;
        case 1:
          Re[je++] = ae[ze | He >> 4], ze = (He & 15) << 2, Be = 2;
          break;
        case 2:
          Re[je++] = ae[ze | He >> 6], Re[je++] = ae[He & 63], Be = 0;
          break;
      }
      je > 8191 && ((Me || (Me = [])).push(String.fromCharCode.apply(String, Re)), je = 0);
    }
    return Be && (Re[je++] = ae[ze], Re[je++] = 61, Be === 1 && (Re[je++] = 61)), Me ? (je && Me.push(String.fromCharCode.apply(String, Re.slice(0, je))), Me.join("")) : String.fromCharCode.apply(String, Re.slice(0, je));
  };
  var ve = "invalid encoding";
  oe.decode = function(xe, Oe, $e) {
    for (var Me = $e, Re = 0, je, Be = 0; Be < xe.length; ) {
      var ze = xe.charCodeAt(Be++);
      if (ze === 61 && Re > 1)
        break;
      if ((ze = fe[ze]) === void 0)
        throw Error(ve);
      switch (Re) {
        case 0:
          je = ze, Re = 1;
          break;
        case 1:
          Oe[$e++] = je << 2 | (ze & 48) >> 4, je = ze, Re = 2;
          break;
        case 2:
          Oe[$e++] = (je & 15) << 4 | (ze & 60) >> 2, je = ze, Re = 3;
          break;
        case 3:
          Oe[$e++] = (je & 3) << 6 | ze, Re = 0;
          break;
      }
    }
    if (Re === 1)
      throw Error(ve);
    return $e - Me;
  }, oe.test = function(xe) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(xe);
  };
})(base64$2);
var eventemitter = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function(oe, ae, fe) {
  return (this._listeners[oe] || (this._listeners[oe] = [])).push({
    fn: ae,
    ctx: fe || this
  }), this;
};
EventEmitter$1.prototype.off = function(oe, ae) {
  if (oe === void 0)
    this._listeners = {};
  else if (ae === void 0)
    this._listeners[oe] = [];
  else
    for (var fe = this._listeners[oe], ye = 0; ye < fe.length; )
      fe[ye].fn === ae ? fe.splice(ye, 1) : ++ye;
  return this;
};
EventEmitter$1.prototype.emit = function(oe) {
  var ae = this._listeners[oe];
  if (ae) {
    for (var fe = [], ye = 1; ye < arguments.length; )
      fe.push(arguments[ye++]);
    for (ye = 0; ye < ae.length; )
      ae[ye].fn.apply(ae[ye++].ctx, fe);
  }
  return this;
};
var float = factory(factory);
function factory(ne) {
  return typeof Float32Array < "u" ? function() {
    var oe = new Float32Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[3] === 128;
    function ye(Oe, $e, Me) {
      oe[0] = Oe, $e[Me] = ae[0], $e[Me + 1] = ae[1], $e[Me + 2] = ae[2], $e[Me + 3] = ae[3];
    }
    function ve(Oe, $e, Me) {
      oe[0] = Oe, $e[Me] = ae[3], $e[Me + 1] = ae[2], $e[Me + 2] = ae[1], $e[Me + 3] = ae[0];
    }
    ne.writeFloatLE = fe ? ye : ve, ne.writeFloatBE = fe ? ve : ye;
    function _e(Oe, $e) {
      return ae[0] = Oe[$e], ae[1] = Oe[$e + 1], ae[2] = Oe[$e + 2], ae[3] = Oe[$e + 3], oe[0];
    }
    function xe(Oe, $e) {
      return ae[3] = Oe[$e], ae[2] = Oe[$e + 1], ae[1] = Oe[$e + 2], ae[0] = Oe[$e + 3], oe[0];
    }
    ne.readFloatLE = fe ? _e : xe, ne.readFloatBE = fe ? xe : _e;
  }() : function() {
    function oe(fe, ye, ve, _e) {
      var xe = ye < 0 ? 1 : 0;
      if (xe && (ye = -ye), ye === 0)
        fe(1 / ye > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), ve, _e);
      else if (isNaN(ye))
        fe(2143289344, ve, _e);
      else if (ye > 34028234663852886e22)
        fe((xe << 31 | 2139095040) >>> 0, ve, _e);
      else if (ye < 11754943508222875e-54)
        fe((xe << 31 | Math.round(ye / 1401298464324817e-60)) >>> 0, ve, _e);
      else {
        var Oe = Math.floor(Math.log(ye) / Math.LN2), $e = Math.round(ye * Math.pow(2, -Oe) * 8388608) & 8388607;
        fe((xe << 31 | Oe + 127 << 23 | $e) >>> 0, ve, _e);
      }
    }
    ne.writeFloatLE = oe.bind(null, writeUintLE), ne.writeFloatBE = oe.bind(null, writeUintBE);
    function ae(fe, ye, ve) {
      var _e = fe(ye, ve), xe = (_e >> 31) * 2 + 1, Oe = _e >>> 23 & 255, $e = _e & 8388607;
      return Oe === 255 ? $e ? NaN : xe * (1 / 0) : Oe === 0 ? xe * 1401298464324817e-60 * $e : xe * Math.pow(2, Oe - 150) * ($e + 8388608);
    }
    ne.readFloatLE = ae.bind(null, readUintLE), ne.readFloatBE = ae.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var oe = new Float64Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[7] === 128;
    function ye(Oe, $e, Me) {
      oe[0] = Oe, $e[Me] = ae[0], $e[Me + 1] = ae[1], $e[Me + 2] = ae[2], $e[Me + 3] = ae[3], $e[Me + 4] = ae[4], $e[Me + 5] = ae[5], $e[Me + 6] = ae[6], $e[Me + 7] = ae[7];
    }
    function ve(Oe, $e, Me) {
      oe[0] = Oe, $e[Me] = ae[7], $e[Me + 1] = ae[6], $e[Me + 2] = ae[5], $e[Me + 3] = ae[4], $e[Me + 4] = ae[3], $e[Me + 5] = ae[2], $e[Me + 6] = ae[1], $e[Me + 7] = ae[0];
    }
    ne.writeDoubleLE = fe ? ye : ve, ne.writeDoubleBE = fe ? ve : ye;
    function _e(Oe, $e) {
      return ae[0] = Oe[$e], ae[1] = Oe[$e + 1], ae[2] = Oe[$e + 2], ae[3] = Oe[$e + 3], ae[4] = Oe[$e + 4], ae[5] = Oe[$e + 5], ae[6] = Oe[$e + 6], ae[7] = Oe[$e + 7], oe[0];
    }
    function xe(Oe, $e) {
      return ae[7] = Oe[$e], ae[6] = Oe[$e + 1], ae[5] = Oe[$e + 2], ae[4] = Oe[$e + 3], ae[3] = Oe[$e + 4], ae[2] = Oe[$e + 5], ae[1] = Oe[$e + 6], ae[0] = Oe[$e + 7], oe[0];
    }
    ne.readDoubleLE = fe ? _e : xe, ne.readDoubleBE = fe ? xe : _e;
  }() : function() {
    function oe(fe, ye, ve, _e, xe, Oe) {
      var $e = _e < 0 ? 1 : 0;
      if ($e && (_e = -_e), _e === 0)
        fe(0, xe, Oe + ye), fe(1 / _e > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), xe, Oe + ve);
      else if (isNaN(_e))
        fe(0, xe, Oe + ye), fe(2146959360, xe, Oe + ve);
      else if (_e > 17976931348623157e292)
        fe(0, xe, Oe + ye), fe(($e << 31 | 2146435072) >>> 0, xe, Oe + ve);
      else {
        var Me;
        if (_e < 22250738585072014e-324)
          Me = _e / 5e-324, fe(Me >>> 0, xe, Oe + ye), fe(($e << 31 | Me / 4294967296) >>> 0, xe, Oe + ve);
        else {
          var Re = Math.floor(Math.log(_e) / Math.LN2);
          Re === 1024 && (Re = 1023), Me = _e * Math.pow(2, -Re), fe(Me * 4503599627370496 >>> 0, xe, Oe + ye), fe(($e << 31 | Re + 1023 << 20 | Me * 1048576 & 1048575) >>> 0, xe, Oe + ve);
        }
      }
    }
    ne.writeDoubleLE = oe.bind(null, writeUintLE, 0, 4), ne.writeDoubleBE = oe.bind(null, writeUintBE, 4, 0);
    function ae(fe, ye, ve, _e, xe) {
      var Oe = fe(_e, xe + ye), $e = fe(_e, xe + ve), Me = ($e >> 31) * 2 + 1, Re = $e >>> 20 & 2047, je = 4294967296 * ($e & 1048575) + Oe;
      return Re === 2047 ? je ? NaN : Me * (1 / 0) : Re === 0 ? Me * 5e-324 * je : Me * Math.pow(2, Re - 1075) * (je + 4503599627370496);
    }
    ne.readDoubleLE = ae.bind(null, readUintLE, 0, 4), ne.readDoubleBE = ae.bind(null, readUintBE, 4, 0);
  }(), ne;
}
function writeUintLE(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
function writeUintBE(ne, oe, ae) {
  oe[ae] = ne >>> 24, oe[ae + 1] = ne >>> 16 & 255, oe[ae + 2] = ne >>> 8 & 255, oe[ae + 3] = ne & 255;
}
function readUintLE(ne, oe) {
  return (ne[oe] | ne[oe + 1] << 8 | ne[oe + 2] << 16 | ne[oe + 3] << 24) >>> 0;
}
function readUintBE(ne, oe) {
  return (ne[oe] << 24 | ne[oe + 1] << 16 | ne[oe + 2] << 8 | ne[oe + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (ne) {
  }
  return null;
}
var utf8$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(fe) {
    for (var ye = 0, ve = 0, _e = 0; _e < fe.length; ++_e)
      ve = fe.charCodeAt(_e), ve < 128 ? ye += 1 : ve < 2048 ? ye += 2 : (ve & 64512) === 55296 && (fe.charCodeAt(_e + 1) & 64512) === 56320 ? (++_e, ye += 4) : ye += 3;
    return ye;
  }, oe.read = function(fe, ye, ve) {
    var _e = ve - ye;
    if (_e < 1)
      return "";
    for (var xe = null, Oe = [], $e = 0, Me; ye < ve; )
      Me = fe[ye++], Me < 128 ? Oe[$e++] = Me : Me > 191 && Me < 224 ? Oe[$e++] = (Me & 31) << 6 | fe[ye++] & 63 : Me > 239 && Me < 365 ? (Me = ((Me & 7) << 18 | (fe[ye++] & 63) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63) - 65536, Oe[$e++] = 55296 + (Me >> 10), Oe[$e++] = 56320 + (Me & 1023)) : Oe[$e++] = (Me & 15) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63, $e > 8191 && ((xe || (xe = [])).push(String.fromCharCode.apply(String, Oe)), $e = 0);
    return xe ? ($e && xe.push(String.fromCharCode.apply(String, Oe.slice(0, $e))), xe.join("")) : String.fromCharCode.apply(String, Oe.slice(0, $e));
  }, oe.write = function(fe, ye, ve) {
    for (var _e = ve, xe, Oe, $e = 0; $e < fe.length; ++$e)
      xe = fe.charCodeAt($e), xe < 128 ? ye[ve++] = xe : xe < 2048 ? (ye[ve++] = xe >> 6 | 192, ye[ve++] = xe & 63 | 128) : (xe & 64512) === 55296 && ((Oe = fe.charCodeAt($e + 1)) & 64512) === 56320 ? (xe = 65536 + ((xe & 1023) << 10) + (Oe & 1023), ++$e, ye[ve++] = xe >> 18 | 240, ye[ve++] = xe >> 12 & 63 | 128, ye[ve++] = xe >> 6 & 63 | 128, ye[ve++] = xe & 63 | 128) : (ye[ve++] = xe >> 12 | 224, ye[ve++] = xe >> 6 & 63 | 128, ye[ve++] = xe & 63 | 128);
    return ve - _e;
  };
})(utf8$2);
var pool_1 = pool;
function pool(ne, oe, ae) {
  var fe = ae || 8192, ye = fe >>> 1, ve = null, _e = fe;
  return function(Oe) {
    if (Oe < 1 || Oe > ye)
      return ne(Oe);
    _e + Oe > fe && (ve = ne(fe), _e = 0);
    var $e = oe.call(ve, _e, _e += Oe);
    return _e & 7 && (_e = (_e | 7) + 1), $e;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = oe;
  var ne = requireMinimal();
  function oe(ve, _e) {
    this.lo = ve >>> 0, this.hi = _e >>> 0;
  }
  var ae = oe.zero = new oe(0, 0);
  ae.toNumber = function() {
    return 0;
  }, ae.zzEncode = ae.zzDecode = function() {
    return this;
  }, ae.length = function() {
    return 1;
  };
  var fe = oe.zeroHash = "\0\0\0\0\0\0\0\0";
  oe.fromNumber = function(_e) {
    if (_e === 0)
      return ae;
    var xe = _e < 0;
    xe && (_e = -_e);
    var Oe = _e >>> 0, $e = (_e - Oe) / 4294967296 >>> 0;
    return xe && ($e = ~$e >>> 0, Oe = ~Oe >>> 0, ++Oe > 4294967295 && (Oe = 0, ++$e > 4294967295 && ($e = 0))), new oe(Oe, $e);
  }, oe.from = function(_e) {
    if (typeof _e == "number")
      return oe.fromNumber(_e);
    if (ne.isString(_e))
      if (ne.Long)
        _e = ne.Long.fromString(_e);
      else
        return oe.fromNumber(parseInt(_e, 10));
    return _e.low || _e.high ? new oe(_e.low >>> 0, _e.high >>> 0) : ae;
  }, oe.prototype.toNumber = function(_e) {
    if (!_e && this.hi >>> 31) {
      var xe = ~this.lo + 1 >>> 0, Oe = ~this.hi >>> 0;
      return xe || (Oe = Oe + 1 >>> 0), -(xe + Oe * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, oe.prototype.toLong = function(_e) {
    return ne.Long ? new ne.Long(this.lo | 0, this.hi | 0, !!_e) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_e };
  };
  var ye = String.prototype.charCodeAt;
  return oe.fromHash = function(_e) {
    return _e === fe ? ae : new oe(
      (ye.call(_e, 0) | ye.call(_e, 1) << 8 | ye.call(_e, 2) << 16 | ye.call(_e, 3) << 24) >>> 0,
      (ye.call(_e, 4) | ye.call(_e, 5) << 8 | ye.call(_e, 6) << 16 | ye.call(_e, 7) << 24) >>> 0
    );
  }, oe.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, oe.prototype.zzEncode = function() {
    var _e = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _e) >>> 0, this.lo = (this.lo << 1 ^ _e) >>> 0, this;
  }, oe.prototype.zzDecode = function() {
    var _e = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _e) >>> 0, this.hi = (this.hi >>> 1 ^ _e) >>> 0, this;
  }, oe.prototype.length = function() {
    var _e = this.lo, xe = (this.lo >>> 28 | this.hi << 4) >>> 0, Oe = this.hi >>> 24;
    return Oe === 0 ? xe === 0 ? _e < 16384 ? _e < 128 ? 1 : 2 : _e < 2097152 ? 3 : 4 : xe < 16384 ? xe < 128 ? 5 : 6 : xe < 2097152 ? 7 : 8 : Oe < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(ne) {
    var oe = ne;
    oe.asPromise = aspromise, oe.base64 = base64$2, oe.EventEmitter = eventemitter, oe.float = float, oe.inquire = inquire_1, oe.utf8 = utf8$2, oe.pool = pool_1, oe.LongBits = requireLongbits(), oe.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), oe.global = oe.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, oe.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), oe.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), oe.isInteger = Number.isInteger || /* istanbul ignore next */
    function(ve) {
      return typeof ve == "number" && isFinite(ve) && Math.floor(ve) === ve;
    }, oe.isString = function(ve) {
      return typeof ve == "string" || ve instanceof String;
    }, oe.isObject = function(ve) {
      return ve && typeof ve == "object";
    }, oe.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    oe.isSet = function(ve, _e) {
      var xe = ve[_e];
      return xe != null && ve.hasOwnProperty(_e) ? typeof xe != "object" || (Array.isArray(xe) ? xe.length : Object.keys(xe).length) > 0 : !1;
    }, oe.Buffer = function() {
      try {
        var ye = oe.inquire("buffer").Buffer;
        return ye.prototype.utf8Write ? ye : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), oe._Buffer_from = null, oe._Buffer_allocUnsafe = null, oe.newBuffer = function(ve) {
      return typeof ve == "number" ? oe.Buffer ? oe._Buffer_allocUnsafe(ve) : new oe.Array(ve) : oe.Buffer ? oe._Buffer_from(ve) : typeof Uint8Array > "u" ? ve : new Uint8Array(ve);
    }, oe.Array = typeof Uint8Array < "u" ? Uint8Array : Array, oe.Long = /* istanbul ignore next */
    oe.global.dcodeIO && /* istanbul ignore next */
    oe.global.dcodeIO.Long || /* istanbul ignore next */
    oe.global.Long || oe.inquire("long"), oe.key2Re = /^true|false|0|1$/, oe.key32Re = /^-?(?:0|[1-9][0-9]*)$/, oe.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, oe.longToHash = function(ve) {
      return ve ? oe.LongBits.from(ve).toHash() : oe.LongBits.zeroHash;
    }, oe.longFromHash = function(ve, _e) {
      var xe = oe.LongBits.fromHash(ve);
      return oe.Long ? oe.Long.fromBits(xe.lo, xe.hi, _e) : xe.toNumber(!!_e);
    };
    function ae(ye, ve, _e) {
      for (var xe = Object.keys(ve), Oe = 0; Oe < xe.length; ++Oe)
        (ye[xe[Oe]] === void 0 || !_e) && (ye[xe[Oe]] = ve[xe[Oe]]);
      return ye;
    }
    oe.merge = ae, oe.lcFirst = function(ve) {
      return ve.charAt(0).toLowerCase() + ve.substring(1);
    };
    function fe(ye) {
      function ve(_e, xe) {
        if (!(this instanceof ve))
          return new ve(_e, xe);
        Object.defineProperty(this, "message", { get: function() {
          return _e;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, ve) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), xe && ae(this, xe);
      }
      return ve.prototype = Object.create(Error.prototype, {
        constructor: {
          value: ve,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return ye;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), ve;
    }
    oe.newError = fe, oe.ProtocolError = fe("ProtocolError"), oe.oneOfGetter = function(ve) {
      for (var _e = {}, xe = 0; xe < ve.length; ++xe)
        _e[ve[xe]] = 1;
      return function() {
        for (var Oe = Object.keys(this), $e = Oe.length - 1; $e > -1; --$e)
          if (_e[Oe[$e]] === 1 && this[Oe[$e]] !== void 0 && this[Oe[$e]] !== null)
            return Oe[$e];
      };
    }, oe.oneOfSetter = function(ve) {
      return function(_e) {
        for (var xe = 0; xe < ve.length; ++xe)
          ve[xe] !== _e && delete this[ve[xe]];
      };
    }, oe.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, oe._configure = function() {
      var ye = oe.Buffer;
      if (!ye) {
        oe._Buffer_from = oe._Buffer_allocUnsafe = null;
        return;
      }
      oe._Buffer_from = ye.from !== Uint8Array.from && ye.from || /* istanbul ignore next */
      function(_e, xe) {
        return new ye(_e, xe);
      }, oe._Buffer_allocUnsafe = ye.allocUnsafe || /* istanbul ignore next */
      function(_e) {
        return new ye(_e);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1, util$5 = requireMinimal(), BufferWriter$1, LongBits$1 = util$5.LongBits, base64$1 = util$5.base64, utf8$1 = util$5.utf8;
function Op(ne, oe, ae) {
  this.fn = ne, this.len = oe, this.next = void 0, this.val = ae;
}
function noop$3() {
}
function State(ne) {
  this.head = ne.head, this.tail = ne.tail, this.len = ne.len, this.next = ne.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$3, 0, 0), this.tail = this.head, this.states = null;
}
var create$2 = function ne() {
  return util$5.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$2();
Writer$1.alloc = function ne(oe) {
  return new util$5.Array(oe);
};
util$5.Array !== Array && (Writer$1.alloc = util$5.pool(Writer$1.alloc, util$5.Array.prototype.subarray));
Writer$1.prototype._push = function ne(oe, ae, fe) {
  return this.tail = this.tail.next = new Op(oe, ae, fe), this.len += ae, this;
};
function writeByte(ne, oe, ae) {
  oe[ae] = ne & 255;
}
function writeVarint32(ne, oe, ae) {
  for (; ne > 127; )
    oe[ae++] = ne & 127 | 128, ne >>>= 7;
  oe[ae] = ne;
}
function VarintOp(ne, oe) {
  this.len = ne, this.next = void 0, this.val = oe;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function ne(oe) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (oe = oe >>> 0) < 128 ? 1 : oe < 16384 ? 2 : oe < 2097152 ? 3 : oe < 268435456 ? 4 : 5,
    oe
  )).len, this;
};
Writer$1.prototype.int32 = function ne(oe) {
  return oe < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(oe)) : this.uint32(oe);
};
Writer$1.prototype.sint32 = function ne(oe) {
  return this.uint32((oe << 1 ^ oe >> 31) >>> 0);
};
function writeVarint64(ne, oe, ae) {
  for (; ne.hi; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = (ne.lo >>> 7 | ne.hi << 25) >>> 0, ne.hi >>>= 7;
  for (; ne.lo > 127; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = ne.lo >>> 7;
  oe[ae++] = ne.lo;
}
Writer$1.prototype.uint64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function ne(oe) {
  var ae = LongBits$1.from(oe).zzEncode();
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.bool = function ne(oe) {
  return this._push(writeByte, 1, oe ? 1 : 0);
};
function writeFixed32(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
Writer$1.prototype.fixed32 = function ne(oe) {
  return this._push(writeFixed32, 4, oe >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeFixed32, 4, ae.lo)._push(writeFixed32, 4, ae.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function ne(oe) {
  return this._push(util$5.float.writeFloatLE, 4, oe);
};
Writer$1.prototype.double = function ne(oe) {
  return this._push(util$5.float.writeDoubleLE, 8, oe);
};
var writeBytes = util$5.Array.prototype.set ? function ne(oe, ae, fe) {
  ae.set(oe, fe);
} : function ne(oe, ae, fe) {
  for (var ye = 0; ye < oe.length; ++ye)
    ae[fe + ye] = oe[ye];
};
Writer$1.prototype.bytes = function ne(oe) {
  var ae = oe.length >>> 0;
  if (!ae)
    return this._push(writeByte, 1, 0);
  if (util$5.isString(oe)) {
    var fe = Writer$1.alloc(ae = base64$1.length(oe));
    base64$1.decode(oe, fe, 0), oe = fe;
  }
  return this.uint32(ae)._push(writeBytes, ae, oe);
};
Writer$1.prototype.string = function ne(oe) {
  var ae = utf8$1.length(oe);
  return ae ? this.uint32(ae)._push(utf8$1.write, ae, oe) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function ne() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function ne() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function ne() {
  var oe = this.head, ae = this.tail, fe = this.len;
  return this.reset().uint32(fe), fe && (this.tail.next = oe.next, this.tail = ae, this.len += fe), this;
};
Writer$1.prototype.finish = function ne() {
  for (var oe = this.head.next, ae = this.constructor.alloc(this.len), fe = 0; oe; )
    oe.fn(oe.val, ae, fe), fe += oe.len, oe = oe.next;
  return ae;
};
Writer$1._configure = function(ne) {
  BufferWriter$1 = ne, Writer$1.create = create$2(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$4 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$4._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$4.Buffer && util$4.Buffer.prototype instanceof Uint8Array && util$4.Buffer.prototype.set.name === "set" ? function(oe, ae, fe) {
    ae.set(oe, fe);
  } : function(oe, ae, fe) {
    if (oe.copy)
      oe.copy(ae, fe, 0, oe.length);
    else
      for (var ye = 0; ye < oe.length; )
        ae[fe++] = oe[ye++];
  };
};
BufferWriter.prototype.bytes = function ne(oe) {
  util$4.isString(oe) && (oe = util$4._Buffer_from(oe, "base64"));
  var ae = oe.length >>> 0;
  return this.uint32(ae), ae && this._push(BufferWriter.writeBytesBuffer, ae, oe), this;
};
function writeStringBuffer(ne, oe, ae) {
  ne.length < 40 ? util$4.utf8.write(ne, oe, ae) : oe.utf8Write ? oe.utf8Write(ne, ae) : oe.write(ne, ae);
}
BufferWriter.prototype.string = function ne(oe) {
  var ae = util$4.Buffer.byteLength(oe);
  return this.uint32(ae), ae && this._push(writeStringBuffer, ae, oe), this;
};
BufferWriter._configure();
var reader = Reader$1, util$3 = requireMinimal(), BufferReader$1, LongBits = util$3.LongBits, utf8 = util$3.utf8;
function indexOutOfRange(ne, oe) {
  return RangeError("index out of range: " + ne.pos + " + " + (oe || 1) + " > " + ne.len);
}
function Reader$1(ne) {
  this.buf = ne, this.pos = 0, this.len = ne.length;
}
var create_array = typeof Uint8Array < "u" ? function ne(oe) {
  if (oe instanceof Uint8Array || Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
} : function ne(oe) {
  if (Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
}, create$1 = function ne() {
  return util$3.Buffer ? function(ae) {
    return (Reader$1.create = function(ye) {
      return util$3.Buffer.isBuffer(ye) ? new BufferReader$1(ye) : create_array(ye);
    })(ae);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$3.Array.prototype.subarray || /* istanbul ignore next */
util$3.Array.prototype.slice;
Reader$1.prototype.uint32 = function ne() {
  var oe = 4294967295;
  return function() {
    if (oe = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (oe = (oe | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return oe;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return oe;
  };
}();
Reader$1.prototype.int32 = function ne() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function ne() {
  var oe = this.uint32();
  return oe >>> 1 ^ -(oe & 1) | 0;
};
function readLongVarint() {
  var ne = new LongBits(0, 0), oe = 0;
  if (this.len - this.pos > 4) {
    for (; oe < 4; ++oe)
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << 28) >>> 0, ne.hi = (ne.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return ne;
    oe = 0;
  } else {
    for (; oe < 3; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
    return ne.lo = (ne.lo | (this.buf[this.pos++] & 127) << oe * 7) >>> 0, ne;
  }
  if (this.len - this.pos > 4) {
    for (; oe < 5; ++oe)
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
  } else
    for (; oe < 5; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function ne() {
  return this.uint32() !== 0;
};
function readFixed32_end(ne, oe) {
  return (ne[oe - 4] | ne[oe - 3] << 8 | ne[oe - 2] << 16 | ne[oe - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, oe;
};
Reader$1.prototype.double = function ne() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, oe;
};
Reader$1.prototype.bytes = function ne() {
  var oe = this.uint32(), ae = this.pos, fe = this.pos + oe;
  if (fe > this.len)
    throw indexOutOfRange(this, oe);
  if (this.pos += oe, Array.isArray(this.buf))
    return this.buf.slice(ae, fe);
  if (ae === fe) {
    var ye = util$3.Buffer;
    return ye ? ye.alloc(0) : new this.buf.constructor(0);
  }
  return this._slice.call(this.buf, ae, fe);
};
Reader$1.prototype.string = function ne() {
  var oe = this.bytes();
  return utf8.read(oe, 0, oe.length);
};
Reader$1.prototype.skip = function ne(oe) {
  if (typeof oe == "number") {
    if (this.pos + oe > this.len)
      throw indexOutOfRange(this, oe);
    this.pos += oe;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(ne) {
  switch (ne) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (ne = this.uint32() & 7) !== 4; )
        this.skipType(ne);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + ne + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(ne) {
  BufferReader$1 = ne, Reader$1.create = create$1(), BufferReader$1._configure();
  var oe = util$3.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$3.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[oe](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[oe](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[oe](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[oe](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[oe](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$2 = requireMinimal();
function BufferReader(ne) {
  Reader.call(this, ne);
}
BufferReader._configure = function() {
  util$2.Buffer && (BufferReader.prototype._slice = util$2.Buffer.prototype.slice);
};
BufferReader.prototype.string = function ne() {
  var oe = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + oe, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + oe, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$1 = requireMinimal();
(Service.prototype = Object.create(util$1.EventEmitter.prototype)).constructor = Service;
function Service(ne, oe, ae) {
  if (typeof ne != "function")
    throw TypeError("rpcImpl must be a function");
  util$1.EventEmitter.call(this), this.rpcImpl = ne, this.requestDelimited = !!oe, this.responseDelimited = !!ae;
}
Service.prototype.rpcCall = function ne(oe, ae, fe, ye, ve) {
  if (!ye)
    throw TypeError("request must be specified");
  var _e = this;
  if (!ve)
    return util$1.asPromise(ne, _e, oe, ae, fe, ye);
  if (!_e.rpcImpl) {
    setTimeout(function() {
      ve(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _e.rpcImpl(
      oe,
      ae[_e.requestDelimited ? "encodeDelimited" : "encode"](ye).finish(),
      function(Oe, $e) {
        if (Oe)
          return _e.emit("error", Oe, oe), ve(Oe);
        if ($e === null) {
          _e.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!($e instanceof fe))
          try {
            $e = fe[_e.responseDelimited ? "decodeDelimited" : "decode"]($e);
          } catch (Me) {
            return _e.emit("error", Me, oe), ve(Me);
          }
        return _e.emit("data", $e, oe), ve(null, $e);
      }
    );
  } catch (xe) {
    _e.emit("error", xe, oe), setTimeout(function() {
      ve(xe);
    }, 0);
    return;
  }
};
Service.prototype.end = function ne(oe) {
  return this.rpcImpl && (oe || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(ne) {
  var oe = ne;
  oe.Service = service;
})(rpc);
var roots = {};
(function(ne) {
  var oe = ne;
  oe.build = "minimal", oe.Writer = writer, oe.BufferWriter = writer_buffer, oe.Reader = reader, oe.BufferReader = reader_buffer, oe.util = requireMinimal(), oe.rpc = rpc, oe.roots = roots, oe.configure = ae;
  function ae() {
    oe.util._configure(), oe.Writer._configure(oe.BufferWriter), oe.Reader._configure(oe.BufferReader);
  }
  ae();
})(indexMinimal);
var minimal = indexMinimal;
const _m0 = /* @__PURE__ */ getDefaultExportFromCjs(minimal);
var lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function ne(oe) {
  const ae = /* @__PURE__ */ new Map(), fe = {
    set(ye, ve) {
      if (ye = normalizeKey(ye), Array.isArray(ve))
        if (ve.length === 0)
          ae.delete(ye);
        else {
          for (const _e of ve)
            validate(ye, _e);
          ae.set(ye, ye.endsWith("-bin") ? ve : [ve.join(", ")]);
        }
      else
        validate(ye, ve), ae.set(ye, [ve]);
      return fe;
    },
    append(ye, ve) {
      ye = normalizeKey(ye), validate(ye, ve);
      let _e = ae.get(ye);
      return _e == null && (_e = [], ae.set(ye, _e)), _e.push(ve), ye.endsWith("-bin") || ae.set(ye, [_e.join(", ")]), fe;
    },
    delete(ye) {
      ye = normalizeKey(ye), ae.delete(ye);
    },
    get(ye) {
      var ve;
      return ye = normalizeKey(ye), (ve = ae.get(ye)) === null || ve === void 0 ? void 0 : ve[0];
    },
    getAll(ye) {
      var ve;
      return ye = normalizeKey(ye), (ve = ae.get(ye)) !== null && ve !== void 0 ? ve : [];
    },
    has(ye) {
      return ye = normalizeKey(ye), ae.has(ye);
    },
    [Symbol.iterator]() {
      return ae[Symbol.iterator]();
    }
  };
  if (oe != null) {
    const ye = isIterable$1(oe) ? oe : Object.entries(oe);
    for (const [ve, _e] of ye)
      fe.set(ve, _e);
  }
  return fe;
};
function normalizeKey(ne) {
  return ne.toLowerCase();
}
function validate(ne, oe) {
  if (!/^[0-9a-z_.-]+$/.test(ne))
    throw new Error(`Metadata key '${ne}' contains illegal characters`);
  if (ne.endsWith("-bin")) {
    if (!(oe instanceof Uint8Array))
      throw new Error(`Metadata key '${ne}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof oe != "string")
      throw new Error(`Metadata key '${ne}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(oe))
      throw new Error(`Metadata value '${oe}' of key '${ne}' contains illegal characters`);
  }
}
function isIterable$1(ne) {
  return Symbol.iterator in ne;
}
var Status = {};
(function(ne) {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = void 0, function(oe) {
    oe[oe.OK = 0] = "OK", oe[oe.CANCELLED = 1] = "CANCELLED", oe[oe.UNKNOWN = 2] = "UNKNOWN", oe[oe.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", oe[oe.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", oe[oe.NOT_FOUND = 5] = "NOT_FOUND", oe[oe.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", oe[oe.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", oe[oe.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", oe[oe.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", oe[oe.ABORTED = 10] = "ABORTED", oe[oe.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", oe[oe.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", oe[oe.INTERNAL = 13] = "INTERNAL", oe[oe.UNAVAILABLE = 14] = "UNAVAILABLE", oe[oe.DATA_LOSS = 15] = "DATA_LOSS", oe[oe.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(ne.Status || (ne.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(ne, oe) {
  return (ae, fe) => oe(Object.assign(Object.assign({}, ae), { next: (ye, ve) => ne(Object.assign(Object.assign({}, ae), { request: ye }), ve) }), fe);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function ne(oe, ae) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(oe, ae) : oe.__proto__ = ae;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function ne(oe) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(oe) : oe.__proto__ || oe.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function ne(oe, ae, fe) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(oe, ae, fe);
    } catch {
      ie8ObjectDefinePropertyBug = !0, ne(oe, ae, fe);
    }
  else
    oe[ae] = fe.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty = function ne(oe, ae) {
  return objectHasOwnPropertyIsDefined ? oe.hasOwnProperty(oe, ae) : oe[ae] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty;
var objectCreate = function ne(oe, ae) {
  if (objectCreateIsDefined)
    return Object.create(oe, ae);
  var fe = function() {
  };
  fe.prototype = oe;
  var ye = new fe();
  if (typeof ae > "u")
    return ye;
  if (typeof ae == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof ae == "object")
    for (var ve in ae)
      hasOwnProperty(ae, ve) && (ye[ve] = ae[ve].value);
  return ye;
};
helpers.objectCreate = objectCreate;
(function(ne) {
  ne.__esModule = void 0, ne.__esModule = !0;
  var oe = helpers, ae = oe.setPrototypeOf, fe = oe.getPrototypeOf, ye = oe.defineProperty, ve = oe.objectCreate, _e = new Error().toString() === "[object Error]", xe = "";
  function Oe($e) {
    var Me = this.constructor, Re = Me.name || function() {
      var qe = Me.toString().match(/^function\s*([^\s(]+)/);
      return qe === null ? xe || "Error" : qe[1];
    }(), je = Re === "Error", Be = je ? xe : Re, ze = Error.apply(this, arguments);
    if (ae(ze, fe(this)), !(ze instanceof Me) || !(ze instanceof Oe)) {
      var ze = this;
      Error.apply(this, arguments), ye(ze, "message", {
        configurable: !0,
        enumerable: !1,
        value: $e,
        writable: !0
      });
    }
    if (ye(ze, "name", {
      configurable: !0,
      enumerable: !1,
      value: Be,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      ze,
      je ? Oe : Me
    ), ze.stack === void 0) {
      var He = new Error($e);
      He.name = ze.name, ze.stack = He.stack;
    }
    return _e && ye(ze, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), ze;
  }
  xe = Oe.name || "ExtendableError", Oe.prototype = ve(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), ne.ExtendableError = Oe, ne.default = ne.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(oe, ae, fe) {
    super(`${oe} ${Status_1$1.Status[ae]}: ${fe}`), this.path = oe, this.code = ae, this.details = fe, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ClientError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ClientError || oe["@@nice-grpc:ClientError"] === !0 || oe.name === "ClientError" && oe["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(ne, oe) {
  return (ae, fe) => ne(Object.assign(Object.assign({}, ae), { next: (ye, ve) => oe(Object.assign(Object.assign({}, ae), { request: ye }), ve) }), fe);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(oe, ae) {
    super(`${Status_1.Status[oe]}: ${ae}`), this.code = oe, this.details = ae, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ServerError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ServerError || oe["@@nice-grpc:ServerError"] === !0 || oe.name === "ServerError" && oe["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ye, ve, _e) {
    _e === void 0 && (_e = ve);
    var xe = Object.getOwnPropertyDescriptor(ye, ve);
    (!xe || ("get" in xe ? !ye.__esModule : xe.writable || xe.configurable)) && (xe = { enumerable: !0, get: function() {
      return ye[ve];
    } }), Object.defineProperty(fe, _e, xe);
  } : function(fe, ye, ve, _e) {
    _e === void 0 && (_e = ve), fe[_e] = ye[ve];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ye) {
    for (var ve in fe)
      ve !== "default" && !Object.prototype.hasOwnProperty.call(ye, ve) && oe(ye, fe, ve);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ae(Metadata, ne), ae(Status, ne), ae(MethodDescriptor, ne), ae(CallOptions, ne), ae(ClientMiddleware, ne), ae(composeClientMiddleware$1, ne), ae(ClientError$1, ne), ae(CallContext, ne), ae(ServerMiddleware, ne), ae(composeServerMiddleware$1, ne), ae(ServerError$1, ne);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne)) {
    if (ae === "serviceName")
      continue;
    const ye = fe;
    oe[uncapitalize(ae)] = {
      path: `/${ne.serviceName}/${ae}`,
      requestStream: ye.requestStream,
      responseStream: ye.responseStream,
      requestDeserialize: ye.requestType.deserializeBinary,
      requestSerialize: (ve) => ve.serializeBinary(),
      responseDeserialize: ye.responseType.deserializeBinary,
      responseSerialize: (ve) => ve.serializeBinary(),
      options: {}
    };
  }
  return oe;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(ne) {
  return "prototype" in ne;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(ne) {
  return ne.length === 0 ? ne : ne[0].toLowerCase() + ne.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne.methods)) {
    const ye = fe.requestType.encode, ve = fe.requestType.fromPartial, _e = fe.responseType.encode, xe = fe.responseType.fromPartial;
    oe[ae] = {
      path: `/${ne.fullName}/${fe.name}`,
      requestStream: fe.requestStream,
      responseStream: fe.responseStream,
      requestDeserialize: fe.requestType.decode,
      requestSerialize: ve != null ? (Oe) => ye(ve(Oe)).finish() : (Oe) => ye(Oe).finish(),
      responseDeserialize: fe.responseType.decode,
      responseSerialize: xe != null ? (Oe) => _e(xe(Oe)).finish() : (Oe) => _e(Oe).finish(),
      options: fe.options
    };
  }
  return oe;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(ne) {
  return "name" in ne && "fullName" in ne && "methods" in ne;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(ne) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(ne) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(ne) : (0, ts_proto_1.isTsProtoServiceDefinition)(ne) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(ne) : ne;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(ne) {
  const [, oe, ae] = ne.path.split("/");
  return {
    service: {
      serviceName: oe
    },
    methodName: ae,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.requestDeserialize(fe);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.responseDeserialize(fe);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(ne, oe) {
  return { address: ne, transport: oe };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(commonjsGlobal, function() {
    return ae = { 418: function(ye, ve) {
      (function(_e, xe) {
        for (var Oe in xe)
          _e[Oe] = xe[Oe];
      })(ve, function(_e) {
        var xe = {};
        function Oe($e) {
          if (xe[$e])
            return xe[$e].exports;
          var Me = xe[$e] = { i: $e, l: !1, exports: {} };
          return _e[$e].call(Me.exports, Me, Me.exports, Oe), Me.l = !0, Me.exports;
        }
        return Oe.m = _e, Oe.c = xe, Oe.i = function($e) {
          return $e;
        }, Oe.d = function($e, Me, Re) {
          Oe.o($e, Me) || Object.defineProperty($e, Me, { configurable: !1, enumerable: !0, get: Re });
        }, Oe.n = function($e) {
          var Me = $e && $e.__esModule ? function() {
            return $e.default;
          } : function() {
            return $e;
          };
          return Oe.d(Me, "a", Me), Me;
        }, Oe.o = function($e, Me) {
          return Object.prototype.hasOwnProperty.call($e, Me);
        }, Oe.p = "", Oe(Oe.s = 1);
      }([function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(3), Me = function() {
          function Re(je, Be) {
            je === void 0 && (je = {}), Be === void 0 && (Be = { splitValues: !1 });
            var ze, He = this;
            this.headersMap = {}, je && (typeof Headers < "u" && je instanceof Headers ? $e.getHeaderKeys(je).forEach(function(qe) {
              $e.getHeaderValues(je, qe).forEach(function(Ye) {
                Be.splitValues ? He.append(qe, $e.splitHeaderValue(Ye)) : He.append(qe, Ye);
              });
            }) : typeof (ze = je) == "object" && typeof ze.headersMap == "object" && typeof ze.forEach == "function" ? je.forEach(function(qe, Ye) {
              He.append(qe, Ye);
            }) : typeof Map < "u" && je instanceof Map ? je.forEach(function(qe, Ye) {
              He.append(Ye, qe);
            }) : typeof je == "string" ? this.appendFromString(je) : typeof je == "object" && Object.getOwnPropertyNames(je).forEach(function(qe) {
              var Ye = je[qe];
              Array.isArray(Ye) ? Ye.forEach(function(pt) {
                He.append(qe, pt);
              }) : He.append(qe, Ye);
            }));
          }
          return Re.prototype.appendFromString = function(je) {
            for (var Be = je.split(`\r
`), ze = 0; ze < Be.length; ze++) {
              var He = Be[ze], qe = He.indexOf(":");
              if (qe > 0) {
                var Ye = He.substring(0, qe).trim(), pt = He.substring(qe + 1).trim();
                this.append(Ye, pt);
              }
            }
          }, Re.prototype.delete = function(je, Be) {
            var ze = $e.normalizeName(je);
            if (Be === void 0)
              delete this.headersMap[ze];
            else {
              var He = this.headersMap[ze];
              if (He) {
                var qe = He.indexOf(Be);
                qe >= 0 && He.splice(qe, 1), He.length === 0 && delete this.headersMap[ze];
              }
            }
          }, Re.prototype.append = function(je, Be) {
            var ze = this, He = $e.normalizeName(je);
            Array.isArray(this.headersMap[He]) || (this.headersMap[He] = []), Array.isArray(Be) ? Be.forEach(function(qe) {
              ze.headersMap[He].push($e.normalizeValue(qe));
            }) : this.headersMap[He].push($e.normalizeValue(Be));
          }, Re.prototype.set = function(je, Be) {
            var ze = $e.normalizeName(je);
            if (Array.isArray(Be)) {
              var He = [];
              Be.forEach(function(qe) {
                He.push($e.normalizeValue(qe));
              }), this.headersMap[ze] = He;
            } else
              this.headersMap[ze] = [$e.normalizeValue(Be)];
          }, Re.prototype.has = function(je, Be) {
            var ze = this.headersMap[$e.normalizeName(je)];
            if (!Array.isArray(ze))
              return !1;
            if (Be !== void 0) {
              var He = $e.normalizeValue(Be);
              return ze.indexOf(He) >= 0;
            }
            return !0;
          }, Re.prototype.get = function(je) {
            var Be = this.headersMap[$e.normalizeName(je)];
            return Be !== void 0 ? Be.concat() : [];
          }, Re.prototype.forEach = function(je) {
            var Be = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(ze) {
              je(ze, Be.headersMap[ze]);
            }, this);
          }, Re.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var je = new Headers();
              return this.forEach(function(Be, ze) {
                ze.forEach(function(He) {
                  je.append(Be, He);
                });
              }), je;
            }
            throw new Error("Headers class is not defined");
          }, Re;
        }();
        xe.BrowserHeaders = Me;
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(0);
        xe.BrowserHeaders = $e.BrowserHeaders;
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 }), xe.iterateHeaders = function($e, Me) {
          for (var Re = $e[Symbol.iterator](), je = Re.next(); !je.done; )
            Me(je.value[0]), je = Re.next();
        }, xe.iterateHeadersKeys = function($e, Me) {
          for (var Re = $e.keys(), je = Re.next(); !je.done; )
            Me(je.value), je = Re.next();
        };
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(2);
        xe.normalizeName = function(Me) {
          if (typeof Me != "string" && (Me = String(Me)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(Me))
            throw new TypeError("Invalid character in header field name");
          return Me.toLowerCase();
        }, xe.normalizeValue = function(Me) {
          return typeof Me != "string" && (Me = String(Me)), Me;
        }, xe.getHeaderValues = function(Me, Re) {
          var je = Me;
          if (je instanceof Headers && je.getAll)
            return je.getAll(Re);
          var Be = je.get(Re);
          return Be && typeof Be == "string" ? [Be] : Be;
        }, xe.getHeaderKeys = function(Me) {
          var Re = Me, je = {}, Be = [];
          return Re.keys ? $e.iterateHeadersKeys(Re, function(ze) {
            je[ze] || (je[ze] = !0, Be.push(ze));
          }) : Re.forEach ? Re.forEach(function(ze, He) {
            je[He] || (je[He] = !0, Be.push(He));
          }) : $e.iterateHeaders(Re, function(ze) {
            var He = ze[0];
            je[He] || (je[He] = !0, Be.push(He));
          }), Be;
        }, xe.splitHeaderValue = function(Me) {
          var Re = [];
          return Me.split(", ").forEach(function(je) {
            je.split(",").forEach(function(Be) {
              Re.push(Be);
            });
          }), Re;
        };
      }]));
    }, 617: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.ChunkParser = ve.ChunkType = ve.encodeASCII = ve.decodeASCII = void 0;
      var xe, Oe = _e(65);
      function $e(qe) {
        return (Ye = qe) === 9 || Ye === 10 || Ye === 13 || qe >= 32 && qe <= 126;
        var Ye;
      }
      function Me(qe) {
        for (var Ye = 0; Ye !== qe.length; ++Ye)
          if (!$e(qe[Ye]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(qe));
      }
      function Re(qe) {
        return (128 & qe.getUint8(0)) == 128;
      }
      function je(qe) {
        return qe.getUint32(1, !1);
      }
      function Be(qe, Ye, pt) {
        return qe.byteLength - Ye >= pt;
      }
      function ze(qe, Ye, pt) {
        if (qe.slice)
          return qe.slice(Ye, pt);
        var dt = qe.length;
        pt !== void 0 && (dt = pt);
        for (var yt = new Uint8Array(dt - Ye), Ct = 0, It = Ye; It < dt; It++)
          yt[Ct++] = qe[It];
        return yt;
      }
      ve.decodeASCII = Me, ve.encodeASCII = function(qe) {
        for (var Ye = new Uint8Array(qe.length), pt = 0; pt !== qe.length; ++pt) {
          var dt = qe.charCodeAt(pt);
          if (!$e(dt))
            throw new Error("Metadata contains invalid ASCII");
          Ye[pt] = dt;
        }
        return Ye;
      }, function(qe) {
        qe[qe.MESSAGE = 1] = "MESSAGE", qe[qe.TRAILERS = 2] = "TRAILERS";
      }(xe = ve.ChunkType || (ve.ChunkType = {}));
      var He = function() {
        function qe() {
          this.buffer = null, this.position = 0;
        }
        return qe.prototype.parse = function(Ye, pt) {
          if (Ye.length === 0 && pt)
            return [];
          var dt, yt = [];
          if (this.buffer == null)
            this.buffer = Ye, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = Ye, this.position = 0;
          else {
            var Ct = this.buffer.byteLength - this.position, It = new Uint8Array(Ct + Ye.byteLength), Vt = ze(this.buffer, this.position);
            It.set(Vt, 0);
            var Ut = new Uint8Array(Ye);
            It.set(Ut, Ct), this.buffer = It, this.position = 0;
          }
          for (; ; ) {
            if (!Be(this.buffer, this.position, 5))
              return yt;
            var Zt = ze(this.buffer, this.position, this.position + 5), tr = new DataView(Zt.buffer, Zt.byteOffset, Zt.byteLength), er = je(tr);
            if (!Be(this.buffer, this.position, 5 + er))
              return yt;
            var hr = ze(this.buffer, this.position + 5, this.position + 5 + er);
            if (this.position += 5 + er, Re(tr))
              return yt.push({ chunkType: xe.TRAILERS, trailers: (dt = hr, new Oe.Metadata(Me(dt))) }), yt;
            yt.push({ chunkType: xe.MESSAGE, data: hr });
          }
        }, qe;
      }();
      ve.ChunkParser = He;
    }, 8: function(ye, ve) {
      var _e;
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.httpStatusToCode = ve.Code = void 0, function(xe) {
        xe[xe.OK = 0] = "OK", xe[xe.Canceled = 1] = "Canceled", xe[xe.Unknown = 2] = "Unknown", xe[xe.InvalidArgument = 3] = "InvalidArgument", xe[xe.DeadlineExceeded = 4] = "DeadlineExceeded", xe[xe.NotFound = 5] = "NotFound", xe[xe.AlreadyExists = 6] = "AlreadyExists", xe[xe.PermissionDenied = 7] = "PermissionDenied", xe[xe.ResourceExhausted = 8] = "ResourceExhausted", xe[xe.FailedPrecondition = 9] = "FailedPrecondition", xe[xe.Aborted = 10] = "Aborted", xe[xe.OutOfRange = 11] = "OutOfRange", xe[xe.Unimplemented = 12] = "Unimplemented", xe[xe.Internal = 13] = "Internal", xe[xe.Unavailable = 14] = "Unavailable", xe[xe.DataLoss = 15] = "DataLoss", xe[xe.Unauthenticated = 16] = "Unauthenticated";
      }(_e = ve.Code || (ve.Code = {})), ve.httpStatusToCode = function(xe) {
        switch (xe) {
          case 0:
            return _e.Internal;
          case 200:
            return _e.OK;
          case 400:
            return _e.InvalidArgument;
          case 401:
            return _e.Unauthenticated;
          case 403:
            return _e.PermissionDenied;
          case 404:
            return _e.NotFound;
          case 409:
            return _e.Aborted;
          case 412:
            return _e.FailedPrecondition;
          case 429:
            return _e.ResourceExhausted;
          case 499:
            return _e.Canceled;
          case 500:
            return _e.Unknown;
          case 501:
            return _e.Unimplemented;
          case 503:
            return _e.Unavailable;
          case 504:
            return _e.DeadlineExceeded;
          default:
            return _e.Unknown;
        }
      };
    }, 934: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.client = void 0;
      var xe = _e(65), Oe = _e(617), $e = _e(8), Me = _e(346), Re = _e(57), je = _e(882);
      ve.client = function(He, qe) {
        return new Be(He, qe);
      };
      var Be = function() {
        function He(qe, Ye) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new Oe.ChunkParser(), this.methodDefinition = qe, this.props = Ye, this.createTransport();
        }
        return He.prototype.createTransport = function() {
          var qe = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, Ye = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: qe, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(Ye) : this.transport = Re.makeDefaultTransport(Ye);
        }, He.prototype.onTransportHeaders = function(qe, Ye) {
          if (this.props.debug && Me.debug("onHeaders", qe, Ye), this.closed)
            this.props.debug && Me.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (Ye !== 0) {
            this.responseHeaders = qe, this.props.debug && Me.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var pt = ze(qe);
            this.props.debug && Me.debug("onHeaders.gRPCStatus", pt);
            var dt = pt && pt >= 0 ? pt : $e.httpStatusToCode(Ye);
            this.props.debug && Me.debug("onHeaders.code", dt);
            var yt = qe.get("grpc-message") || [];
            if (this.props.debug && Me.debug("onHeaders.gRPCMessage", yt), this.rawOnHeaders(qe), dt !== $e.Code.OK) {
              var Ct = this.decodeGRPCStatus(yt[0]);
              this.rawOnError(dt, Ct, qe);
            }
          }
        }, He.prototype.onTransportChunk = function(qe) {
          var Ye = this;
          if (this.closed)
            this.props.debug && Me.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var pt = [];
            try {
              pt = this.parser.parse(qe);
            } catch (dt) {
              return this.props.debug && Me.debug("onChunk.parsing error", dt, dt.message), void this.rawOnError($e.Code.Internal, "parsing error: " + dt.message);
            }
            pt.forEach(function(dt) {
              if (dt.chunkType === Oe.ChunkType.MESSAGE) {
                var yt = Ye.methodDefinition.responseType.deserializeBinary(dt.data);
                Ye.rawOnMessage(yt);
              } else
                dt.chunkType === Oe.ChunkType.TRAILERS && (Ye.responseHeaders ? (Ye.responseTrailers = new xe.Metadata(dt.trailers), Ye.props.debug && Me.debug("onChunk.trailers", Ye.responseTrailers)) : (Ye.responseHeaders = new xe.Metadata(dt.trailers), Ye.rawOnHeaders(Ye.responseHeaders)));
            });
          }
        }, He.prototype.onTransportEnd = function() {
          if (this.props.debug && Me.debug("grpc.onEnd"), this.closed)
            this.props.debug && Me.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var qe = ze(this.responseTrailers);
            if (qe !== null) {
              var Ye = this.responseTrailers.get("grpc-message"), pt = this.decodeGRPCStatus(Ye[0]);
              this.rawOnEnd(qe, pt, this.responseTrailers);
            } else
              this.rawOnError($e.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError($e.Code.Unknown, "Response closed without headers");
            var dt = ze(this.responseHeaders), yt = this.responseHeaders.get("grpc-message");
            if (this.props.debug && Me.debug("grpc.headers only response ", dt, yt), dt === null)
              return void this.rawOnEnd($e.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var Ct = this.decodeGRPCStatus(yt[0]);
            this.rawOnEnd(dt, Ct, this.responseHeaders);
          }
        }, He.prototype.decodeGRPCStatus = function(qe) {
          if (!qe)
            return "";
          try {
            return decodeURIComponent(qe);
          } catch {
            return qe;
          }
        }, He.prototype.rawOnEnd = function(qe, Ye, pt) {
          var dt = this;
          this.props.debug && Me.debug("rawOnEnd", qe, Ye, pt), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(yt) {
            if (!dt.closed)
              try {
                yt(qe, Ye, pt);
              } catch (Ct) {
                setTimeout(function() {
                  throw Ct;
                }, 0);
              }
          }));
        }, He.prototype.rawOnHeaders = function(qe) {
          this.props.debug && Me.debug("rawOnHeaders", qe), this.completed || this.onHeadersCallbacks.forEach(function(Ye) {
            try {
              Ye(qe);
            } catch (pt) {
              setTimeout(function() {
                throw pt;
              }, 0);
            }
          });
        }, He.prototype.rawOnError = function(qe, Ye, pt) {
          var dt = this;
          pt === void 0 && (pt = new xe.Metadata()), this.props.debug && Me.debug("rawOnError", qe, Ye), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(yt) {
            if (!dt.closed)
              try {
                yt(qe, Ye, pt);
              } catch (Ct) {
                setTimeout(function() {
                  throw Ct;
                }, 0);
              }
          }));
        }, He.prototype.rawOnMessage = function(qe) {
          var Ye = this;
          this.props.debug && Me.debug("rawOnMessage", qe.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(pt) {
            if (!Ye.closed)
              try {
                pt(qe);
              } catch (dt) {
                setTimeout(function() {
                  throw dt;
                }, 0);
              }
          });
        }, He.prototype.onHeaders = function(qe) {
          this.onHeadersCallbacks.push(qe);
        }, He.prototype.onMessage = function(qe) {
          this.onMessageCallbacks.push(qe);
        }, He.prototype.onEnd = function(qe) {
          this.onEndCallbacks.push(qe);
        }, He.prototype.start = function(qe) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var Ye = new xe.Metadata(qe || {});
          Ye.set("content-type", "application/grpc-web+proto"), Ye.set("x-grpc-web", "1"), this.transport.start(Ye);
        }, He.prototype.send = function(qe) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var Ye = je.frameRequest(qe);
          this.transport.sendMessage(Ye);
        }, He.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, He.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && Me.debug("request.abort aborting request"), this.transport.cancel();
        }, He;
      }();
      function ze(He) {
        var qe = He.get("grpc-status") || [];
        if (qe.length > 0)
          try {
            var Ye = qe[0];
            return parseInt(Ye, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(ye, ve) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.debug = void 0, ve.debug = function() {
        for (var _e = [], xe = 0; xe < arguments.length; xe++)
          _e[xe] = arguments[xe];
        console.debug ? console.debug.apply(null, _e) : console.log.apply(null, _e);
      };
    }, 607: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.grpc = void 0;
      var xe, Oe = _e(418), $e = _e(57), Me = _e(229), Re = _e(540), je = _e(210), Be = _e(859), ze = _e(8), He = _e(938), qe = _e(35), Ye = _e(934);
      (xe = ve.grpc || (ve.grpc = {})).setDefaultTransport = $e.setDefaultTransportFactory, xe.CrossBrowserHttpTransport = Be.CrossBrowserHttpTransport, xe.FetchReadableStreamTransport = Me.FetchReadableStreamTransport, xe.XhrTransport = je.XhrTransport, xe.WebsocketTransport = Re.WebsocketTransport, xe.Code = ze.Code, xe.Metadata = Oe.BrowserHeaders, xe.client = function(pt, dt) {
        return Ye.client(pt, dt);
      }, xe.invoke = He.invoke, xe.unary = qe.unary;
    }, 938: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.invoke = void 0;
      var xe = _e(934);
      ve.invoke = function(Oe, $e) {
        if (Oe.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var Me = xe.client(Oe, { host: $e.host, transport: $e.transport, debug: $e.debug });
        return $e.onHeaders && Me.onHeaders($e.onHeaders), $e.onMessage && Me.onMessage($e.onMessage), $e.onEnd && Me.onEnd($e.onEnd), Me.start($e.metadata), Me.send($e.request), Me.finishSend(), { close: function() {
          Me.close();
        } };
      };
    }, 65: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.Metadata = void 0;
      var xe = _e(418);
      Object.defineProperty(ve, "Metadata", { enumerable: !0, get: function() {
        return xe.BrowserHeaders;
      } });
    }, 57: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.makeDefaultTransport = ve.setDefaultTransportFactory = void 0;
      var xe = _e(859), Oe = function($e) {
        return xe.CrossBrowserHttpTransport({ withCredentials: !1 })($e);
      };
      ve.setDefaultTransportFactory = function($e) {
        Oe = $e;
      }, ve.makeDefaultTransport = function($e) {
        return Oe($e);
      };
    }, 229: function(ye, ve, _e) {
      var xe = this && this.__assign || function() {
        return (xe = Object.assign || function(Re) {
          for (var je, Be = 1, ze = arguments.length; Be < ze; Be++)
            for (var He in je = arguments[Be])
              Object.prototype.hasOwnProperty.call(je, He) && (Re[He] = je[He]);
          return Re;
        }).apply(this, arguments);
      };
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.detectFetchSupport = ve.FetchReadableStreamTransport = void 0;
      var Oe = _e(65), $e = _e(346);
      ve.FetchReadableStreamTransport = function(Re) {
        return function(je) {
          return function(Be, ze) {
            return Be.debug && $e.debug("fetchRequest", Be), new Me(Be, ze);
          }(je, Re);
        };
      };
      var Me = function() {
        function Re(je, Be) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = je, this.init = Be;
        }
        return Re.prototype.pump = function(je, Be) {
          var ze = this;
          if (this.reader = je, this.cancelled)
            return this.options.debug && $e.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(He) {
              ze.options.debug && $e.debug("Fetch.pump.reader.cancel exception", He);
            });
          this.reader.read().then(function(He) {
            if (He.done)
              return ze.options.onEnd(), Be;
            ze.options.onChunk(He.value), ze.pump(ze.reader, Be);
          }).catch(function(He) {
            ze.cancelled ? ze.options.debug && $e.debug("Fetch.catch - request cancelled") : (ze.cancelled = !0, ze.options.debug && $e.debug("Fetch.catch", He.message), ze.options.onEnd(He));
          });
        }, Re.prototype.send = function(je) {
          var Be = this;
          fetch(this.options.url, xe(xe({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: je, signal: this.controller && this.controller.signal })).then(function(ze) {
            if (Be.options.debug && $e.debug("Fetch.response", ze), Be.options.onHeaders(new Oe.Metadata(ze.headers), ze.status), !ze.body)
              return ze;
            Be.pump(ze.body.getReader(), ze);
          }).catch(function(ze) {
            Be.cancelled ? Be.options.debug && $e.debug("Fetch.catch - request cancelled") : (Be.cancelled = !0, Be.options.debug && $e.debug("Fetch.catch", ze.message), Be.options.onEnd(ze));
          });
        }, Re.prototype.sendMessage = function(je) {
          this.send(je);
        }, Re.prototype.finishSend = function() {
        }, Re.prototype.start = function(je) {
          this.metadata = je;
        }, Re.prototype.cancel = function() {
          var je = this;
          this.cancelled ? this.options.debug && $e.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && $e.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && $e.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && $e.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(Be) {
            je.options.debug && $e.debug("Fetch.cancel.reader.cancel exception", Be);
          })) : this.options.debug && $e.debug("Fetch.cancel before reader"));
        }, Re;
      }();
      ve.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.CrossBrowserHttpTransport = void 0;
      var xe = _e(229), Oe = _e(210);
      ve.CrossBrowserHttpTransport = function($e) {
        if (xe.detectFetchSupport()) {
          var Me = { credentials: $e.withCredentials ? "include" : "same-origin" };
          return xe.FetchReadableStreamTransport(Me);
        }
        return Oe.XhrTransport({ withCredentials: $e.withCredentials });
      };
    }, 210: function(ye, ve, _e) {
      var xe, Oe = this && this.__extends || (xe = function(qe, Ye) {
        return (xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(pt, dt) {
          pt.__proto__ = dt;
        } || function(pt, dt) {
          for (var yt in dt)
            Object.prototype.hasOwnProperty.call(dt, yt) && (pt[yt] = dt[yt]);
        })(qe, Ye);
      }, function(qe, Ye) {
        function pt() {
          this.constructor = qe;
        }
        xe(qe, Ye), qe.prototype = Ye === null ? Object.create(Ye) : (pt.prototype = Ye.prototype, new pt());
      });
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.stringToArrayBuffer = ve.MozChunkedArrayBufferXHR = ve.XHR = ve.XhrTransport = void 0;
      var $e = _e(65), Me = _e(346), Re = _e(849);
      ve.XhrTransport = function(qe) {
        return function(Ye) {
          if (Re.detectMozXHRSupport())
            return new Be(Ye, qe);
          if (Re.detectXHROverrideMimeTypeSupport())
            return new je(Ye, qe);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var je = function() {
        function qe(Ye, pt) {
          this.options = Ye, this.init = pt;
        }
        return qe.prototype.onProgressEvent = function() {
          this.options.debug && Me.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var Ye = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var pt = He(Ye);
          this.options.onChunk(pt);
        }, qe.prototype.onLoadEvent = function() {
          this.options.debug && Me.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, qe.prototype.onStateChange = function() {
          this.options.debug && Me.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new $e.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, qe.prototype.sendMessage = function(Ye) {
          this.xhr.send(Ye);
        }, qe.prototype.finishSend = function() {
        }, qe.prototype.start = function(Ye) {
          var pt = this;
          this.metadata = Ye;
          var dt = new XMLHttpRequest();
          this.xhr = dt, dt.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(yt, Ct) {
            dt.setRequestHeader(yt, Ct.join(", "));
          }), dt.withCredentials = !!this.init.withCredentials, dt.addEventListener("readystatechange", this.onStateChange.bind(this)), dt.addEventListener("progress", this.onProgressEvent.bind(this)), dt.addEventListener("loadend", this.onLoadEvent.bind(this)), dt.addEventListener("error", function(yt) {
            pt.options.debug && Me.debug("XHR.error", yt), pt.options.onEnd(yt.error);
          });
        }, qe.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, qe.prototype.cancel = function() {
          this.options.debug && Me.debug("XHR.abort"), this.xhr.abort();
        }, qe;
      }();
      ve.XHR = je;
      var Be = function(qe) {
        function Ye() {
          return qe !== null && qe.apply(this, arguments) || this;
        }
        return Oe(Ye, qe), Ye.prototype.configureXhr = function() {
          this.options.debug && Me.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, Ye.prototype.onProgressEvent = function() {
          var pt = this.xhr.response;
          this.options.debug && Me.debug("MozXHR.onProgressEvent: ", new Uint8Array(pt)), this.options.onChunk(new Uint8Array(pt));
        }, Ye;
      }(je);
      function ze(qe, Ye) {
        var pt = qe.charCodeAt(Ye);
        if (pt >= 55296 && pt <= 56319) {
          var dt = qe.charCodeAt(Ye + 1);
          dt >= 56320 && dt <= 57343 && (pt = 65536 + (pt - 55296 << 10) + (dt - 56320));
        }
        return pt;
      }
      function He(qe) {
        for (var Ye = new Uint8Array(qe.length), pt = 0, dt = 0; dt < qe.length; dt++) {
          var yt = String.prototype.codePointAt ? qe.codePointAt(dt) : ze(qe, dt);
          Ye[pt++] = 255 & yt;
        }
        return Ye;
      }
      ve.MozChunkedArrayBufferXHR = Be, ve.stringToArrayBuffer = He;
    }, 849: function(ye, ve) {
      var _e;
      function xe() {
        if (_e !== void 0)
          return _e;
        if (XMLHttpRequest) {
          _e = new XMLHttpRequest();
          try {
            _e.open("GET", "https://localhost");
          } catch {
          }
        }
        return _e;
      }
      function Oe($e) {
        var Me = xe();
        if (!Me)
          return !1;
        try {
          return Me.responseType = $e, Me.responseType === $e;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.detectXHROverrideMimeTypeSupport = ve.detectMozXHRSupport = ve.xhrSupportsResponseType = void 0, ve.xhrSupportsResponseType = Oe, ve.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && Oe("moz-chunked-arraybuffer");
      }, ve.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.WebsocketTransport = void 0;
      var xe, Oe = _e(346), $e = _e(617);
      (function(Re) {
        Re[Re.FINISH_SEND = 1] = "FINISH_SEND";
      })(xe || (xe = {}));
      var Me = new Uint8Array([1]);
      ve.WebsocketTransport = function() {
        return function(Re) {
          return function(je) {
            je.debug && Oe.debug("websocketRequest", je);
            var Be, ze = function(Ye) {
              if (Ye.substr(0, 8) === "https://")
                return "wss://" + Ye.substr(8);
              if (Ye.substr(0, 7) === "http://")
                return "ws://" + Ye.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(je.url), He = [];
            function qe(Ye) {
              if (Ye === xe.FINISH_SEND)
                Be.send(Me);
              else {
                var pt = Ye, dt = new Int8Array(pt.byteLength + 1);
                dt.set(new Uint8Array([0])), dt.set(pt, 1), Be.send(dt);
              }
            }
            return { sendMessage: function(Ye) {
              Be && Be.readyState !== Be.CONNECTING ? qe(Ye) : He.push(Ye);
            }, finishSend: function() {
              Be && Be.readyState !== Be.CONNECTING ? qe(xe.FINISH_SEND) : He.push(xe.FINISH_SEND);
            }, start: function(Ye) {
              (Be = new WebSocket(ze, ["grpc-websockets"])).binaryType = "arraybuffer", Be.onopen = function() {
                var pt;
                je.debug && Oe.debug("websocketRequest.onopen"), Be.send((pt = "", Ye.forEach(function(dt, yt) {
                  pt += dt + ": " + yt.join(", ") + `\r
`;
                }), $e.encodeASCII(pt))), He.forEach(function(dt) {
                  qe(dt);
                });
              }, Be.onclose = function(pt) {
                je.debug && Oe.debug("websocketRequest.onclose", pt), je.onEnd();
              }, Be.onerror = function(pt) {
                je.debug && Oe.debug("websocketRequest.onerror", pt);
              }, Be.onmessage = function(pt) {
                je.onChunk(new Uint8Array(pt.data));
              };
            }, cancel: function() {
              je.debug && Oe.debug("websocket.abort"), Be.close();
            } };
          }(Re);
        };
      };
    }, 35: function(ye, ve, _e) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.unary = void 0;
      var xe = _e(65), Oe = _e(934);
      ve.unary = function($e, Me) {
        if ($e.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if ($e.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var Re = null, je = null, Be = Oe.client($e, { host: Me.host, transport: Me.transport, debug: Me.debug });
        return Be.onHeaders(function(ze) {
          Re = ze;
        }), Be.onMessage(function(ze) {
          je = ze;
        }), Be.onEnd(function(ze, He, qe) {
          Me.onEnd({ status: ze, statusMessage: He, headers: Re || new xe.Metadata(), message: je, trailers: qe });
        }), Be.start(Me.metadata), Be.send(Me.request), Be.finishSend(), { close: function() {
          Be.close();
        } };
      };
    }, 882: function(ye, ve) {
      Object.defineProperty(ve, "__esModule", { value: !0 }), ve.frameRequest = void 0, ve.frameRequest = function(_e) {
        var xe = _e.serializeBinary(), Oe = new ArrayBuffer(xe.byteLength + 5);
        return new DataView(Oe, 1, 4).setUint32(0, xe.length, !1), new Uint8Array(Oe, 5).set(xe), new Uint8Array(Oe);
      };
    } }, fe = {}, function ye(ve) {
      if (fe[ve])
        return fe[ve].exports;
      var _e = fe[ve] = { exports: {} };
      return ae[ve].call(_e.exports, _e, _e.exports, ye), _e.exports;
    }(607);
    var ae, fe;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
let AbortError$3 = class extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
};
function isAbortError(ne) {
  return typeof ne == "object" && ne !== null && ne.name === "AbortError";
}
function throwIfAborted(ne) {
  if (ne.aborted)
    throw new AbortError$3();
}
function rethrowAbortError(ne) {
  if (isAbortError(ne))
    throw ne;
}
function catchAbortError(ne) {
  if (!isAbortError(ne))
    throw ne;
}
function execute(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    let ye, ve = !1;
    function _e() {
      ve || (ve = !0, ye != null && ye());
    }
    const xe = oe((Oe) => {
      ae(Oe), _e();
    }, (Oe) => {
      fe(Oe), _e();
    });
    if (!ve) {
      const Oe = () => {
        const $e = xe();
        $e == null ? fe(new AbortError$3()) : $e.then(() => {
          fe(new AbortError$3());
        }, (Me) => {
          fe(Me);
        }), _e();
      };
      ne.addEventListener("abort", Oe), ye = () => {
        ne.removeEventListener("abort", Oe);
      };
    }
  });
}
function abortable(ne, oe) {
  if (ne.aborted) {
    const ae = () => {
    };
    oe.then(ae, ae);
  }
  return execute(ne, (ae, fe) => (oe.then(ae, fe), () => {
  }));
}
function delay(ne, oe) {
  return execute(ne, (ae) => {
    const fe = typeof oe == "number" ? oe : oe.getTime() - Date.now(), ye = setTimeout(ae, fe);
    return () => {
      clearTimeout(ye);
    };
  });
}
function forever(ne) {
  return execute(ne, () => () => {
  });
}
function waitForEvent(ne, oe, ae, fe) {
  return execute(ne, (ye) => {
    let ve, _e = !1;
    return ve = listen(oe, ae, (...Oe) => {
      ye(Oe.length > 1 ? Oe : Oe[0]), _e = !0, ve != null && ve();
    }, fe), _e && ve(), () => {
      _e = !0, ve != null && ve();
    };
  });
}
function listen(ne, oe, ae, fe) {
  if (isEventTarget(ne))
    return ne.addEventListener(oe, ae, fe), () => ne.removeEventListener(oe, ae, fe);
  if (isJQueryStyleEventEmitter(ne))
    return ne.on(oe, ae), () => ne.off(oe, ae);
  if (isNodeStyleEventEmitter(ne))
    return ne.addListener(oe, ae), () => ne.removeListener(oe, ae);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(ne) {
  return isFunction$3(ne.addListener) && isFunction$3(ne.removeListener);
}
function isJQueryStyleEventEmitter(ne) {
  return isFunction$3(ne.on) && isFunction$3(ne.off);
}
function isEventTarget(ne) {
  return isFunction$3(ne.addEventListener) && isFunction$3(ne.removeEventListener);
}
const isFunction$3 = (ne) => typeof ne == "function";
function all(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), ve = oe(ye.signal);
    if (ve.length === 0) {
      ae([]);
      return;
    }
    const _e = () => {
      ye.abort();
    };
    ne.addEventListener("abort", _e);
    let xe;
    const Oe = new Array(ve.length);
    let $e = 0;
    function Me() {
      $e += 1, $e === ve.length && (ne.removeEventListener("abort", _e), xe != null ? fe(xe.reason) : ae(Oe));
    }
    for (const [Re, je] of ve.entries())
      je.then((Be) => {
        Oe[Re] = Be, Me();
      }, (Be) => {
        ye.abort(), (xe == null || !isAbortError(Be) && isAbortError(xe.reason)) && (xe = { reason: Be }), Me();
      });
  });
}
function race(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), ve = oe(ye.signal), _e = () => {
      ye.abort();
    };
    ne.addEventListener("abort", _e);
    let xe = 0;
    function Oe(Me) {
      ye.abort(), xe += 1, xe === ve.length && (ne.removeEventListener("abort", _e), Me.status === "fulfilled" ? ae(Me.value) : fe(Me.reason));
    }
    let $e;
    for (const Me of ve)
      Me.then((Re) => {
        $e == null && ($e = { status: "fulfilled", value: Re }), Oe($e);
      }, (Re) => {
        ($e == null || !isAbortError(Re) && ($e.status === "fulfilled" || isAbortError($e.reason))) && ($e = { status: "rejected", reason: Re }), Oe($e);
      });
  });
}
async function retry$4(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, maxDelayMs: ye = 3e4, onError: ve, maxAttempts: _e = 1 / 0 } = ae;
  let xe = 0;
  const Oe = () => {
    xe = -1;
  };
  for (; ; )
    try {
      return await oe(ne, xe, Oe);
    } catch ($e) {
      if (rethrowAbortError($e), xe >= _e)
        throw $e;
      let Me;
      if (xe === -1)
        Me = 0;
      else {
        const Re = Math.min(ye, Math.pow(2, xe) * fe);
        Me = Math.round(Re * (1 + Math.random()) / 2);
      }
      ve && ve($e, xe, Me), Me !== 0 && await delay(ne, Me), xe += 1;
    }
}
function spawn(ne, oe) {
  if (ne.aborted)
    return Promise.reject(new AbortError$3());
  const ae = [], fe = new AbortController(), ye = fe.signal, ve = () => {
    fe.abort();
  };
  ne.addEventListener("abort", ve);
  const _e = () => {
    ne.removeEventListener("abort", ve);
  }, xe = /* @__PURE__ */ new Set(), Oe = () => {
    for (const Re of xe)
      Re.abort();
  };
  ye.addEventListener("abort", Oe);
  const $e = () => {
    ye.removeEventListener("abort", Oe);
  };
  let Me = new Promise((Re, je) => {
    let Be, ze;
    He((qe) => oe(qe, {
      defer(Ye) {
        ae.push(Ye);
      },
      fork: He
    })).join().then((qe) => {
      fe.abort(), Be = { value: qe };
    }, (qe) => {
      fe.abort(), (!isAbortError(qe) || ze == null) && (ze = { error: qe });
    });
    function He(qe) {
      if (ye.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError$3();
          }
        };
      const Ye = new AbortController(), pt = Ye.signal, dt = qe(pt), yt = {
        abort() {
          Ye.abort();
        },
        join: () => dt
      };
      return xe.add(yt), dt.catch(catchAbortError).catch((Ct) => {
        ze = { error: Ct }, fe.abort();
      }).finally(() => {
        xe.delete(yt), xe.size === 0 && (ze != null ? je(ze.error) : Re(Be.value));
      }), yt;
    }
  });
  return Me = Me.finally(() => {
    _e(), $e();
    let Re = Promise.resolve();
    for (let je = ae.length - 1; je >= 0; je--)
      Re = Re.finally(ae[je]);
    return Re;
  }), Me;
}
function run$1(ne) {
  const oe = new AbortController(), ae = ne(oe.signal).catch(catchAbortError);
  return () => (oe.abort(), ae);
}
function proactiveRetry(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, onError: ye, maxAttempts: ve = 1 / 0 } = ae;
  return execute(ne, (_e, xe) => {
    const Oe = new AbortController();
    let $e = !1;
    const Me = /* @__PURE__ */ new Map();
    function Re(ze) {
      Oe.abort(), Me.clear(), _e(ze);
    }
    function je(ze, He) {
      if (Me.delete(He), $e && Me.size === 0) {
        xe(ze);
        return;
      }
      if (!isAbortError(ze) && ye)
        try {
          ye(ze, He);
        } catch (qe) {
          Oe.abort(), Me.clear(), xe(qe);
        }
    }
    async function Be(ze) {
      for (let He = 0; ; He++) {
        const qe = oe(ze, He);
        if (Me.set(He, qe), qe.then(Re, (dt) => je(dt, He)), He + 1 >= ve)
          break;
        const Ye = Math.pow(2, He) * fe, pt = Math.round(Ye * (1 + Math.random()) / 2);
        await delay(ze, pt);
      }
      $e = !0;
    }
    return Be(Oe.signal).catch(catchAbortError), () => {
      Oe.abort();
    };
  });
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError: AbortError$3,
  abortable,
  all,
  catchAbortError,
  delay,
  execute,
  forever,
  isAbortError,
  proactiveRetry,
  race,
  rethrowAbortError,
  retry: retry$4,
  run: run$1,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(oe) {
    this._push({ type: ARRAY_VALUE, value: oe });
  }
  error(oe) {
    this._push({ type: ARRAY_ERROR, error: oe });
  }
  _push(oe) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: ae, reject: fe } = this._resolvers.shift();
      oe.type === ARRAY_ERROR ? fe(oe.error) : ae({ done: !1, value: oe.value });
    } else
      this._values.push(oe);
  }
  next() {
    if (this._values.length > 0) {
      const { type: oe, value: ae, error: fe } = this._values.shift();
      return oe === ARRAY_ERROR ? Promise.reject(fe) : Promise.resolve({ done: !1, value: ae });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((oe, ae) => {
      this._resolvers.push({ resolve: oe, reject: ae });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$2 = {};
Object.defineProperty(isAsyncIterable$2, "__esModule", { value: !0 });
isAsyncIterable$2.isAsyncIterable = void 0;
function isAsyncIterable$1(ne) {
  return ne != null && Symbol.asyncIterator in ne;
}
isAsyncIterable$2.isAsyncIterable = isAsyncIterable$1;
var convertMetadata = {}, base64 = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal, function() {
    var ae = "3.7.7", fe = ae, ye = typeof Buffer == "function", ve = typeof TextDecoder == "function" ? new TextDecoder() : void 0, _e = typeof TextEncoder == "function" ? new TextEncoder() : void 0, xe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Oe = Array.prototype.slice.call(xe), $e = function(Xt) {
      var dr = {};
      return Xt.forEach(function(Nr, Dr) {
        return dr[Nr] = Dr;
      }), dr;
    }(Oe), Me = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, Re = String.fromCharCode.bind(String), je = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(Xt) {
      return new Uint8Array(Array.prototype.slice.call(Xt, 0));
    }, Be = function(Xt) {
      return Xt.replace(/=/g, "").replace(/[+\/]/g, function(dr) {
        return dr == "+" ? "-" : "_";
      });
    }, ze = function(Xt) {
      return Xt.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, He = function(Xt) {
      for (var dr, Nr, Dr, jr, un = "", so = Xt.length % 3, Pn = 0; Pn < Xt.length; ) {
        if ((Nr = Xt.charCodeAt(Pn++)) > 255 || (Dr = Xt.charCodeAt(Pn++)) > 255 || (jr = Xt.charCodeAt(Pn++)) > 255)
          throw new TypeError("invalid character found");
        dr = Nr << 16 | Dr << 8 | jr, un += Oe[dr >> 18 & 63] + Oe[dr >> 12 & 63] + Oe[dr >> 6 & 63] + Oe[dr & 63];
      }
      return so ? un.slice(0, so - 3) + "===".substring(so) : un;
    }, qe = typeof btoa == "function" ? function(Xt) {
      return btoa(Xt);
    } : ye ? function(Xt) {
      return Buffer.from(Xt, "binary").toString("base64");
    } : He, Ye = ye ? function(Xt) {
      return Buffer.from(Xt).toString("base64");
    } : function(Xt) {
      for (var dr = 4096, Nr = [], Dr = 0, jr = Xt.length; Dr < jr; Dr += dr)
        Nr.push(Re.apply(null, Xt.subarray(Dr, Dr + dr)));
      return qe(Nr.join(""));
    }, pt = function(Xt, dr) {
      return dr === void 0 && (dr = !1), dr ? Be(Ye(Xt)) : Ye(Xt);
    }, dt = function(Xt) {
      if (Xt.length < 2) {
        var dr = Xt.charCodeAt(0);
        return dr < 128 ? Xt : dr < 2048 ? Re(192 | dr >>> 6) + Re(128 | dr & 63) : Re(224 | dr >>> 12 & 15) + Re(128 | dr >>> 6 & 63) + Re(128 | dr & 63);
      } else {
        var dr = 65536 + (Xt.charCodeAt(0) - 55296) * 1024 + (Xt.charCodeAt(1) - 56320);
        return Re(240 | dr >>> 18 & 7) + Re(128 | dr >>> 12 & 63) + Re(128 | dr >>> 6 & 63) + Re(128 | dr & 63);
      }
    }, yt = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, Ct = function(Xt) {
      return Xt.replace(yt, dt);
    }, It = ye ? function(Xt) {
      return Buffer.from(Xt, "utf8").toString("base64");
    } : _e ? function(Xt) {
      return Ye(_e.encode(Xt));
    } : function(Xt) {
      return qe(Ct(Xt));
    }, Vt = function(Xt, dr) {
      return dr === void 0 && (dr = !1), dr ? Be(It(Xt)) : It(Xt);
    }, Ut = function(Xt) {
      return Vt(Xt, !0);
    }, Zt = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, tr = function(Xt) {
      switch (Xt.length) {
        case 4:
          var dr = (7 & Xt.charCodeAt(0)) << 18 | (63 & Xt.charCodeAt(1)) << 12 | (63 & Xt.charCodeAt(2)) << 6 | 63 & Xt.charCodeAt(3), Nr = dr - 65536;
          return Re((Nr >>> 10) + 55296) + Re((Nr & 1023) + 56320);
        case 3:
          return Re((15 & Xt.charCodeAt(0)) << 12 | (63 & Xt.charCodeAt(1)) << 6 | 63 & Xt.charCodeAt(2));
        default:
          return Re((31 & Xt.charCodeAt(0)) << 6 | 63 & Xt.charCodeAt(1));
      }
    }, er = function(Xt) {
      return Xt.replace(Zt, tr);
    }, hr = function(Xt) {
      if (Xt = Xt.replace(/\s+/g, ""), !Me.test(Xt))
        throw new TypeError("malformed base64.");
      Xt += "==".slice(2 - (Xt.length & 3));
      for (var dr, Nr = "", Dr, jr, un = 0; un < Xt.length; )
        dr = $e[Xt.charAt(un++)] << 18 | $e[Xt.charAt(un++)] << 12 | (Dr = $e[Xt.charAt(un++)]) << 6 | (jr = $e[Xt.charAt(un++)]), Nr += Dr === 64 ? Re(dr >> 16 & 255) : jr === 64 ? Re(dr >> 16 & 255, dr >> 8 & 255) : Re(dr >> 16 & 255, dr >> 8 & 255, dr & 255);
      return Nr;
    }, Ot = typeof atob == "function" ? function(Xt) {
      return atob(ze(Xt));
    } : ye ? function(Xt) {
      return Buffer.from(Xt, "base64").toString("binary");
    } : hr, Qe = ye ? function(Xt) {
      return je(Buffer.from(Xt, "base64"));
    } : function(Xt) {
      return je(Ot(Xt).split("").map(function(dr) {
        return dr.charCodeAt(0);
      }));
    }, at = function(Xt) {
      return Qe(bt(Xt));
    }, wt = ye ? function(Xt) {
      return Buffer.from(Xt, "base64").toString("utf8");
    } : ve ? function(Xt) {
      return ve.decode(Qe(Xt));
    } : function(Xt) {
      return er(Ot(Xt));
    }, bt = function(Xt) {
      return ze(Xt.replace(/[-_]/g, function(dr) {
        return dr == "-" ? "+" : "/";
      }));
    }, At = function(Xt) {
      return wt(bt(Xt));
    }, Ft = function(Xt) {
      if (typeof Xt != "string")
        return !1;
      var dr = Xt.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(dr) || !/[^\s0-9a-zA-Z\-_]/.test(dr);
    }, Gt = function(Xt) {
      return {
        value: Xt,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, ot = function() {
      var Xt = function(dr, Nr) {
        return Object.defineProperty(String.prototype, dr, Gt(Nr));
      };
      Xt("fromBase64", function() {
        return At(this);
      }), Xt("toBase64", function(dr) {
        return Vt(this, dr);
      }), Xt("toBase64URI", function() {
        return Vt(this, !0);
      }), Xt("toBase64URL", function() {
        return Vt(this, !0);
      }), Xt("toUint8Array", function() {
        return at(this);
      });
    }, et = function() {
      var Xt = function(dr, Nr) {
        return Object.defineProperty(Uint8Array.prototype, dr, Gt(Nr));
      };
      Xt("toBase64", function(dr) {
        return pt(this, dr);
      }), Xt("toBase64URI", function() {
        return pt(this, !0);
      }), Xt("toBase64URL", function() {
        return pt(this, !0);
      });
    }, Rt = function() {
      ot(), et();
    }, xr = {
      version: ae,
      VERSION: fe,
      atob: Ot,
      atobPolyfill: hr,
      btoa: qe,
      btoaPolyfill: He,
      fromBase64: At,
      toBase64: Vt,
      encode: Vt,
      encodeURI: Ut,
      encodeURL: Ut,
      utob: Ct,
      btou: er,
      decode: At,
      isValid: Ft,
      fromUint8Array: pt,
      toUint8Array: at,
      extendString: ot,
      extendUint8Array: et,
      extendBuiltins: Rt
    };
    return xr.Base64 = {}, Object.keys(xr).forEach(function(Xt) {
      return xr.Base64[Xt] = xr[Xt];
    }), xr;
  });
})(base64);
var base64Exports = base64.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(ne) {
  const oe = new grpc_web_1$4.grpc.Metadata();
  for (const [ae, fe] of ne)
    for (const ye of fe)
      oe.append(ae, typeof ye == "string" ? ye : js_base64_1.Base64.fromUint8Array(ye));
  return oe;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(ne) {
  const oe = (0, nice_grpc_common_1$5.Metadata)();
  for (const [ae, fe] of Object.entries(ne.headersMap))
    if (ae.endsWith("-bin"))
      for (const ye of fe)
        for (const ve of ye.split(/,\s?/))
          oe.append(ae, js_base64_1.Base64.toUint8Array(ve));
    else
      oe.set(ae, fe);
  return oe;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$2, AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$2, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(ne), ve = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: Me = (0, nice_grpc_common_1$4.Metadata)(), signal: Re = new AbortController().signal, onHeader: je, onTrailer: Be } = $e, ze = new AbortController(), He = new AsyncSink_1$1.AsyncSink(), qe = grpc_web_1$3.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    qe.onHeaders((dt) => {
      je == null || je((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(dt));
    }), qe.onMessage((dt) => {
      He.write(dt);
    }), qe.onEnd((dt, yt, Ct) => {
      Be == null || Be((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Ct)), dt === grpc_web_1$3.grpc.Code.OK ? He.end() : He.error(new nice_grpc_common_1$4.ClientError(ne.path, +dt, yt));
    }), qe.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(Me));
    let Ye;
    pipeRequest$1(ze.signal, Oe, qe, ne).then(() => {
      qe.finishSend();
    }, (dt) => {
      (0, abort_controller_x_1$3.isAbortError)(dt) || (Ye = dt, qe.close(), He.end());
    });
    const pt = () => {
      He.error(new abort_controller_x_1$3.AbortError()), ze.abort(), qe.close();
    };
    Re.addEventListener("abort", pt);
    try {
      yield* He;
    } finally {
      if (ze.abort(), Re.removeEventListener("abort", pt), (0, abort_controller_x_1$3.throwIfAborted)(Re), Ye)
        throw Ye;
    }
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: ve,
    requestStream: !0,
    request: Oe,
    responseStream: !0,
    next: _e
  }, $e);
  return (Oe, $e) => {
    const Re = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const je = await Re.next();
            return je.done && je.value != null ? await Re.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : je;
          },
          return() {
            return Re.return();
          },
          throw(je) {
            return Re.throw(je);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$3.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createClientStreamingMethod$1 = {};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$2, service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$2, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(ne), ve = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: Me = (0, nice_grpc_common_1$3.Metadata)(), signal: Re = new AbortController().signal, onHeader: je, onTrailer: Be } = $e;
    return await (0, abort_controller_x_1$2.execute)(Re, (ze, He) => {
      const qe = new AbortController();
      let Ye;
      const pt = grpc_web_1$2.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return pt.onHeaders((dt) => {
        je == null || je((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(dt));
      }), pt.onMessage((dt) => {
        Ye = dt;
      }), pt.onEnd((dt, yt, Ct) => {
        Be == null || Be((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Ct)), qe.abort(), dt === grpc_web_1$2.grpc.Code.OK ? ze(Ye) : He(new nice_grpc_common_1$3.ClientError(ne.path, +dt, yt));
      }), pt.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(Me)), pipeRequest(qe.signal, Oe, pt, ne).then(() => {
        pt.finishSend();
      }, (dt) => {
        (0, abort_controller_x_1$2.isAbortError)(dt) || (He(dt), pt.close());
      }), () => {
        qe.abort(), pt.close();
      };
    });
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: ve,
    requestStream: !0,
    request: Oe,
    responseStream: !1,
    next: _e
  }, $e);
  return async (Oe, $e) => {
    const Re = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    let je = await Re.next();
    for (; ; ) {
      if (!je.done) {
        je = await Re.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (je.value == null) {
        je = await Re.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return je.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$2.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createServerStreamingMethod$1 = {};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$2, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$2;
function createServerStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(ne), ve = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: Me = (0, nice_grpc_common_1$2.Metadata)(), signal: Re = new AbortController().signal, onHeader: je, onTrailer: Be } = $e, ze = new AsyncSink_1.AsyncSink(), He = grpc_web_1$1.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    He.onHeaders((Ye) => {
      je == null || je((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(Ye));
    }), He.onMessage((Ye) => {
      ze.write(Ye);
    }), He.onEnd((Ye, pt, dt) => {
      Be == null || Be((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(dt)), Ye === grpc_web_1$1.grpc.Code.OK ? ze.end() : ze.error(new nice_grpc_common_1$2.ClientError(ne.path, +Ye, pt));
    }), He.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(Me)), He.send({
      serializeBinary: () => ne.requestSerialize(Oe)
    }), He.finishSend();
    const qe = () => {
      ze.error(new abort_controller_x_1$1.AbortError()), He.close();
    };
    Re.addEventListener("abort", qe);
    try {
      yield* ze;
    } finally {
      Re.removeEventListener("abort", qe), (0, abort_controller_x_1$1.throwIfAborted)(Re);
    }
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: ve,
    requestStream: !1,
    request: Oe,
    responseStream: !0,
    next: _e
  }, $e);
  return (Oe, $e) => {
    const Re = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const je = await Re.next();
            return je.done && je.value != null ? await Re.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : je;
          },
          return() {
            return Re.return();
          },
          throw(je) {
            return Re.throw(je);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1 = require$$2, service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$2, convertMetadata_1 = convertMetadata;
function createUnaryMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(ne), ve = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: Me = (0, nice_grpc_common_1$1.Metadata)(), signal: Re = new AbortController().signal, onHeader: je, onTrailer: Be } = $e;
    return await (0, abort_controller_x_1.execute)(Re, (ze, He) => {
      let qe;
      const Ye = grpc_web_1.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return Ye.onHeaders((pt) => {
        je == null || je((0, convertMetadata_1.convertMetadataFromGrpcWeb)(pt));
      }), Ye.onMessage((pt) => {
        qe = pt;
      }), Ye.onEnd((pt, dt, yt) => {
        Be == null || Be((0, convertMetadata_1.convertMetadataFromGrpcWeb)(yt)), pt === grpc_web_1.grpc.Code.OK ? ze(qe) : He(new nice_grpc_common_1$1.ClientError(ne.path, +pt, dt));
      }), Ye.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(Me)), Ye.send({
        serializeBinary: () => ne.requestSerialize(Oe)
      }), Ye.finishSend(), () => {
        Ye.close();
      };
    });
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: ve,
    requestStream: !1,
    request: Oe,
    responseStream: !1,
    next: _e
  }, $e);
  return async (Oe, $e) => {
    const Re = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    let je = await Re.next();
    for (; ; ) {
      if (!je.done) {
        je = await Re.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (je.value == null) {
        je = await Re.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return je.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(ne, oe, ae) {
  return createClientFactory().create(ne, oe, ae);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(ne) {
  return {
    use(oe) {
      return createClientFactoryWithMiddleware(ne == null ? oe : (0, nice_grpc_common_1.composeClientMiddleware)(ne, oe));
    },
    create(oe, ae, fe = {}) {
      const ye = {}, ve = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(oe));
      for (const [_e, xe] of ve) {
        const Oe = {
          ...fe["*"],
          ...fe[_e]
        };
        xe.requestStream ? xe.responseStream ? ye[_e] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(xe, ae, ne, Oe) : ye[_e] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(xe, ae, ne, Oe) : xe.responseStream ? ye[_e] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(xe, ae, ne, Oe) : ye[_e] = (0, createUnaryMethod_1.createUnaryMethod)(xe, ae, ne, Oe);
      }
      return ye;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ye, ve, _e, xe) {
    xe === void 0 && (xe = _e);
    var Oe = Object.getOwnPropertyDescriptor(ve, _e);
    (!Oe || ("get" in Oe ? !ve.__esModule : Oe.writable || Oe.configurable)) && (Oe = { enumerable: !0, get: function() {
      return ve[_e];
    } }), Object.defineProperty(ye, xe, Oe);
  } : function(ye, ve, _e, xe) {
    xe === void 0 && (xe = _e), ye[xe] = ve[_e];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(ye, ve) {
    for (var _e in ye)
      _e !== "default" && !Object.prototype.hasOwnProperty.call(ve, _e) && oe(ve, ye, _e);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = ne.Metadata = ne.composeClientMiddleware = ne.ClientError = void 0;
  var fe = lib;
  Object.defineProperty(ne, "ClientError", { enumerable: !0, get: function() {
    return fe.ClientError;
  } }), Object.defineProperty(ne, "composeClientMiddleware", { enumerable: !0, get: function() {
    return fe.composeClientMiddleware;
  } }), Object.defineProperty(ne, "Metadata", { enumerable: !0, get: function() {
    return fe.Metadata;
  } }), Object.defineProperty(ne, "Status", { enumerable: !0, get: function() {
    return fe.Status;
  } }), ae(serviceDefinitions, ne), ae(channel, ne), ae(ClientFactory, ne), ae(Client, ne);
})(lib$1);
function createBaseLinkedTwitterPair() {
  return { username: "", address: "" };
}
var LinkedTwitterPair = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterPair();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (ve != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterPair.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterPair();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripRequest() {
  return { username: "", address: "" };
}
var DripRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (ve != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return DripRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripRequest();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripDevRequest() {
  return { address: "" };
}
var DripDevRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripDevRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return DripDevRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripDevRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripResponse() {
  return { dripTxHash: "", ecsTxHash: "" };
}
var DripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.dripTxHash !== "" && oe.uint32(10).string(ne.dripTxHash), ne.ecsTxHash !== "" && oe.uint32(18).string(ne.ecsTxHash), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.dripTxHash = ae.string();
          continue;
        case 2:
          if (ve != 18)
            break;
          ye.ecsTxHash = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return DripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripResponse();
    return oe.dripTxHash = ne.dripTxHash ?? "", oe.ecsTxHash = ne.ecsTxHash ?? "", oe;
  }
};
function createBaseTimeUntilDripResponse() {
  return { timeUntilDripMinutes: 0, timeUntilDripSeconds: 0 };
}
var TimeUntilDripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.timeUntilDripMinutes !== 0 && oe.uint32(9).double(ne.timeUntilDripMinutes), ne.timeUntilDripSeconds !== 0 && oe.uint32(17).double(ne.timeUntilDripSeconds), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseTimeUntilDripResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 9)
            break;
          ye.timeUntilDripMinutes = ae.double();
          continue;
        case 2:
          if (ve != 17)
            break;
          ye.timeUntilDripSeconds = ae.double();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return TimeUntilDripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseTimeUntilDripResponse();
    return oe.timeUntilDripMinutes = ne.timeUntilDripMinutes ?? 0, oe.timeUntilDripSeconds = ne.timeUntilDripSeconds ?? 0, oe;
  }
};
function createBaseGetLinkedTwittersRequest() {
  return {};
}
var GetLinkedTwittersRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseGetLinkedTwittersRequest();
  }
};
function createBaseGetLinkedTwittersResponse() {
  return { linkedTwitters: [] };
}
var GetLinkedTwittersResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    for (const ae of ne.linkedTwitters)
      LinkedTwitterPair.encode(ae, oe.uint32(10).fork()).ldelim();
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.linkedTwitters.push(LinkedTwitterPair.decode(ae, ae.uint32()));
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    var ae;
    const oe = createBaseGetLinkedTwittersResponse();
    return oe.linkedTwitters = ((ae = ne.linkedTwitters) == null ? void 0 : ae.map((fe) => LinkedTwitterPair.fromPartial(fe))) || [], oe;
  }
};
function createBaseLinkedTwitterForAddressRequest() {
  return { address: "" };
}
var LinkedTwitterForAddressRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseLinkedTwitterForAddressResponse() {
  return { username: "" };
}
var LinkedTwitterForAddressResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressResponse();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterRequest() {
  return { username: "" };
}
var LinkedAddressForTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterRequest();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterResponse() {
  return { address: "" };
}
var LinkedAddressForTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterResponse();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseSetLinkedTwitterRequest() {
  return { address: "", username: "", signature: "" };
}
var SetLinkedTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), ne.username !== "" && oe.uint32(18).string(ne.username), ne.signature !== "" && oe.uint32(26).string(ne.signature), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterRequest();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      switch (ve >>> 3) {
        case 1:
          if (ve != 10)
            break;
          ye.address = ae.string();
          continue;
        case 2:
          if (ve != 18)
            break;
          ye.username = ae.string();
          continue;
        case 3:
          if (ve != 26)
            break;
          ye.signature = ae.string();
          continue;
      }
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseSetLinkedTwitterRequest();
    return oe.address = ne.address ?? "", oe.username = ne.username ?? "", oe.signature = ne.signature ?? "", oe;
  }
};
function createBaseSetLinkedTwitterResponse() {
  return {};
}
var SetLinkedTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterResponse();
    for (; ae.pos < fe; ) {
      const ve = ae.uint32();
      if ((ve & 7) == 4 || ve == 0)
        break;
      ae.skipType(ve & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseSetLinkedTwitterResponse();
  }
}, FaucetServiceDefinition = {
  name: "FaucetService",
  fullName: "faucet.FaucetService",
  methods: {
    drip: {
      name: "Drip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripDev: {
      name: "DripDev",
      requestType: DripDevRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripVerifyTweet: {
      name: "DripVerifyTweet",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    timeUntilDrip: {
      name: "TimeUntilDrip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: TimeUntilDripResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitters: {
      name: "GetLinkedTwitters",
      requestType: GetLinkedTwittersRequest,
      requestStream: !1,
      responseType: GetLinkedTwittersResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitterForAddress: {
      name: "GetLinkedTwitterForAddress",
      requestType: LinkedTwitterForAddressRequest,
      requestStream: !1,
      responseType: LinkedTwitterForAddressResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedAddressForTwitter: {
      name: "GetLinkedAddressForTwitter",
      requestType: LinkedAddressForTwitterRequest,
      requestStream: !1,
      responseType: LinkedAddressForTwitterResponse,
      responseStream: !1,
      options: {}
    },
    /** Admin utility endpoints for modifying state. Requires a signature with faucet private key. */
    setLinkedTwitter: {
      name: "SetLinkedTwitter",
      requestType: SetLinkedTwitterRequest,
      requestStream: !1,
      responseType: SetLinkedTwitterResponse,
      responseStream: !1,
      options: {}
    }
  }
};
(() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && (_m0.util.Long = Long, _m0.configure());
function createFaucetService(ne) {
  return lib$1.createClient(FaucetServiceDefinition, lib$1.createChannel(ne));
}
var util;
(function(ne) {
  ne.assertEqual = (ye) => ye;
  function oe(ye) {
  }
  ne.assertIs = oe;
  function ae(ye) {
    throw new Error();
  }
  ne.assertNever = ae, ne.arrayToEnum = (ye) => {
    const ve = {};
    for (const _e of ye)
      ve[_e] = _e;
    return ve;
  }, ne.getValidEnumValues = (ye) => {
    const ve = ne.objectKeys(ye).filter((xe) => typeof ye[ye[xe]] != "number"), _e = {};
    for (const xe of ve)
      _e[xe] = ye[xe];
    return ne.objectValues(_e);
  }, ne.objectValues = (ye) => ne.objectKeys(ye).map(function(ve) {
    return ye[ve];
  }), ne.objectKeys = typeof Object.keys == "function" ? (ye) => Object.keys(ye) : (ye) => {
    const ve = [];
    for (const _e in ye)
      Object.prototype.hasOwnProperty.call(ye, _e) && ve.push(_e);
    return ve;
  }, ne.find = (ye, ve) => {
    for (const _e of ye)
      if (ve(_e))
        return _e;
  }, ne.isInteger = typeof Number.isInteger == "function" ? (ye) => Number.isInteger(ye) : (ye) => typeof ye == "number" && isFinite(ye) && Math.floor(ye) === ye;
  function fe(ye, ve = " | ") {
    return ye.map((_e) => typeof _e == "string" ? `'${_e}'` : _e).join(ve);
  }
  ne.joinValues = fe, ne.jsonStringifyReplacer = (ye, ve) => typeof ve == "bigint" ? ve.toString() : ve;
})(util || (util = {}));
var objectUtil;
(function(ne) {
  ne.mergeShapes = (oe, ae) => ({
    ...oe,
    ...ae
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (ne) => {
  switch (typeof ne) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(ne) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(ne) ? ZodParsedType.array : ne === null ? ZodParsedType.null : ne.then && typeof ne.then == "function" && ne.catch && typeof ne.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && ne instanceof Map ? ZodParsedType.map : typeof Set < "u" && ne instanceof Set ? ZodParsedType.set : typeof Date < "u" && ne instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson = (ne) => JSON.stringify(ne, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
  constructor(oe) {
    super(), this.issues = [], this.addIssue = (fe) => {
      this.issues = [...this.issues, fe];
    }, this.addIssues = (fe = []) => {
      this.issues = [...this.issues, ...fe];
    };
    const ae = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, ae) : this.__proto__ = ae, this.name = "ZodError", this.issues = oe;
  }
  get errors() {
    return this.issues;
  }
  format(oe) {
    const ae = oe || function(ve) {
      return ve.message;
    }, fe = { _errors: [] }, ye = (ve) => {
      for (const _e of ve.issues)
        if (_e.code === "invalid_union")
          _e.unionErrors.map(ye);
        else if (_e.code === "invalid_return_type")
          ye(_e.returnTypeError);
        else if (_e.code === "invalid_arguments")
          ye(_e.argumentsError);
        else if (_e.path.length === 0)
          fe._errors.push(ae(_e));
        else {
          let xe = fe, Oe = 0;
          for (; Oe < _e.path.length; ) {
            const $e = _e.path[Oe];
            Oe === _e.path.length - 1 ? (xe[$e] = xe[$e] || { _errors: [] }, xe[$e]._errors.push(ae(_e))) : xe[$e] = xe[$e] || { _errors: [] }, xe = xe[$e], Oe++;
          }
        }
    };
    return ye(this), fe;
  }
  static assert(oe) {
    if (!(oe instanceof ZodError))
      throw new Error(`Not a ZodError: ${oe}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(oe = (ae) => ae.message) {
    const ae = {}, fe = [];
    for (const ye of this.issues)
      ye.path.length > 0 ? (ae[ye.path[0]] = ae[ye.path[0]] || [], ae[ye.path[0]].push(oe(ye))) : fe.push(oe(ye));
    return { formErrors: fe, fieldErrors: ae };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (ne) => new ZodError(ne);
const errorMap = (ne, oe) => {
  let ae;
  switch (ne.code) {
    case ZodIssueCode.invalid_type:
      ne.received === ZodParsedType.undefined ? ae = "Required" : ae = `Expected ${ne.expected}, received ${ne.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      ae = `Invalid literal value, expected ${JSON.stringify(ne.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      ae = `Unrecognized key(s) in object: ${util.joinValues(ne.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      ae = `Invalid discriminator value. Expected ${util.joinValues(ne.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      ae = `Invalid enum value. Expected ${util.joinValues(ne.options)}, received '${ne.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      ae = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      ae = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      ae = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof ne.validation == "object" ? "includes" in ne.validation ? (ae = `Invalid input: must include "${ne.validation.includes}"`, typeof ne.validation.position == "number" && (ae = `${ae} at one or more positions greater than or equal to ${ne.validation.position}`)) : "startsWith" in ne.validation ? ae = `Invalid input: must start with "${ne.validation.startsWith}"` : "endsWith" in ne.validation ? ae = `Invalid input: must end with "${ne.validation.endsWith}"` : util.assertNever(ne.validation) : ne.validation !== "regex" ? ae = `Invalid ${ne.validation}` : ae = "Invalid";
      break;
    case ZodIssueCode.too_small:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "more than"} ${ne.minimum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "over"} ${ne.minimum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${ne.minimum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(ne.minimum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "less than"} ${ne.maximum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "under"} ${ne.maximum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "bigint" ? ae = `BigInt must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly" : ne.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(ne.maximum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.custom:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      ae = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      ae = `Number must be a multiple of ${ne.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      ae = "Number must be finite";
      break;
    default:
      ae = oe.defaultError, util.assertNever(ne);
  }
  return { message: ae };
};
let overrideErrorMap = errorMap;
function setErrorMap(ne) {
  overrideErrorMap = ne;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (ne) => {
  const { data: oe, path: ae, errorMaps: fe, issueData: ye } = ne, ve = [...ae, ...ye.path || []], _e = {
    ...ye,
    path: ve
  };
  if (ye.message !== void 0)
    return {
      ...ye,
      path: ve,
      message: ye.message
    };
  let xe = "";
  const Oe = fe.filter(($e) => !!$e).slice().reverse();
  for (const $e of Oe)
    xe = $e(_e, { data: oe, defaultError: xe }).message;
  return {
    ...ye,
    path: ve,
    message: xe
  };
}, EMPTY_PATH = [];
function addIssueToContext(ne, oe) {
  const ae = getErrorMap(), fe = makeIssue({
    issueData: oe,
    data: ne.data,
    path: ne.path,
    errorMaps: [
      ne.common.contextualErrorMap,
      ne.schemaErrorMap,
      ae,
      ae === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((ye) => !!ye)
  });
  ne.common.issues.push(fe);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      if (ye.status === "aborted")
        return INVALID;
      ye.status === "dirty" && oe.dirty(), fe.push(ye.value);
    }
    return { status: oe.value, value: fe };
  }
  static async mergeObjectAsync(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      const ve = await ye.key, _e = await ye.value;
      fe.push({
        key: ve,
        value: _e
      });
    }
    return ParseStatus.mergeObjectSync(oe, fe);
  }
  static mergeObjectSync(oe, ae) {
    const fe = {};
    for (const ye of ae) {
      const { key: ve, value: _e } = ye;
      if (ve.status === "aborted" || _e.status === "aborted")
        return INVALID;
      ve.status === "dirty" && oe.dirty(), _e.status === "dirty" && oe.dirty(), ve.value !== "__proto__" && (typeof _e.value < "u" || ye.alwaysSet) && (fe[ve.value] = _e.value);
    }
    return { status: oe.value, value: fe };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (ne) => ({ status: "dirty", value: ne }), OK = (ne) => ({ status: "valid", value: ne }), isAborted = (ne) => ne.status === "aborted", isDirty = (ne) => ne.status === "dirty", isValid = (ne) => ne.status === "valid", isAsync = (ne) => typeof Promise < "u" && ne instanceof Promise;
function __classPrivateFieldGet$2(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}
function __classPrivateFieldSet$1(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}
typeof SuppressedError == "function" && SuppressedError;
var errorUtil;
(function(ne) {
  ne.errToObj = (oe) => typeof oe == "string" ? { message: oe } : oe || {}, ne.toString = (oe) => typeof oe == "string" ? oe : oe == null ? void 0 : oe.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(oe, ae, fe, ye) {
    this._cachedPath = [], this.parent = oe, this.data = ae, this._path = fe, this._key = ye;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const handleResult = (ne, oe) => {
  if (isValid(oe))
    return { success: !0, data: oe.value };
  if (!ne.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const ae = new ZodError(ne.common.issues);
      return this._error = ae, this._error;
    }
  };
};
function processCreateParams(ne) {
  if (!ne)
    return {};
  const { errorMap: oe, invalid_type_error: ae, required_error: fe, description: ye } = ne;
  if (oe && (ae || fe))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return oe ? { errorMap: oe, description: ye } : { errorMap: (_e, xe) => {
    var Oe, $e;
    const { message: Me } = ne;
    return _e.code === "invalid_enum_value" ? { message: Me ?? xe.defaultError } : typeof xe.data > "u" ? { message: (Oe = Me ?? fe) !== null && Oe !== void 0 ? Oe : xe.defaultError } : _e.code !== "invalid_type" ? { message: xe.defaultError } : { message: ($e = Me ?? ae) !== null && $e !== void 0 ? $e : xe.defaultError };
  }, description: ye };
}
class ZodType {
  constructor(oe) {
    this.spa = this.safeParseAsync, this._def = oe, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(oe) {
    return getParsedType(oe.data);
  }
  _getOrReturnCtx(oe, ae) {
    return ae || {
      common: oe.parent.common,
      data: oe.data,
      parsedType: getParsedType(oe.data),
      schemaErrorMap: this._def.errorMap,
      path: oe.path,
      parent: oe.parent
    };
  }
  _processInputParams(oe) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: oe.parent.common,
        data: oe.data,
        parsedType: getParsedType(oe.data),
        schemaErrorMap: this._def.errorMap,
        path: oe.path,
        parent: oe.parent
      }
    };
  }
  _parseSync(oe) {
    const ae = this._parse(oe);
    if (isAsync(ae))
      throw new Error("Synchronous parse encountered promise.");
    return ae;
  }
  _parseAsync(oe) {
    const ae = this._parse(oe);
    return Promise.resolve(ae);
  }
  parse(oe, ae) {
    const fe = this.safeParse(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  safeParse(oe, ae) {
    var fe;
    const ye = {
      common: {
        issues: [],
        async: (fe = ae == null ? void 0 : ae.async) !== null && fe !== void 0 ? fe : !1,
        contextualErrorMap: ae == null ? void 0 : ae.errorMap
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, ve = this._parseSync({ data: oe, path: ye.path, parent: ye });
    return handleResult(ye, ve);
  }
  async parseAsync(oe, ae) {
    const fe = await this.safeParseAsync(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  async safeParseAsync(oe, ae) {
    const fe = {
      common: {
        issues: [],
        contextualErrorMap: ae == null ? void 0 : ae.errorMap,
        async: !0
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, ye = this._parse({ data: oe, path: fe.path, parent: fe }), ve = await (isAsync(ye) ? ye : Promise.resolve(ye));
    return handleResult(fe, ve);
  }
  refine(oe, ae) {
    const fe = (ye) => typeof ae == "string" || typeof ae > "u" ? { message: ae } : typeof ae == "function" ? ae(ye) : ae;
    return this._refinement((ye, ve) => {
      const _e = oe(ye), xe = () => ve.addIssue({
        code: ZodIssueCode.custom,
        ...fe(ye)
      });
      return typeof Promise < "u" && _e instanceof Promise ? _e.then((Oe) => Oe ? !0 : (xe(), !1)) : _e ? !0 : (xe(), !1);
    });
  }
  refinement(oe, ae) {
    return this._refinement((fe, ye) => oe(fe) ? !0 : (ye.addIssue(typeof ae == "function" ? ae(fe, ye) : ae), !1));
  }
  _refinement(oe) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement: oe }
    });
  }
  superRefine(oe) {
    return this._refinement(oe);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(oe) {
    return ZodUnion.create([this, oe], this._def);
  }
  and(oe) {
    return ZodIntersection.create(this, oe, this._def);
  }
  transform(oe) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: oe }
    });
  }
  default(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(oe) {
    const ae = this.constructor;
    return new ae({
      ...this._def,
      description: oe
    });
  }
  pipe(oe) {
    return ZodPipeline.create(this, oe);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(ne) {
  let oe = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return ne.precision ? oe = `${oe}\\.\\d{${ne.precision}}` : ne.precision == null && (oe = `${oe}(\\.\\d+)?`), oe;
}
function timeRegex(ne) {
  return new RegExp(`^${timeRegexSource(ne)}$`);
}
function datetimeRegex(ne) {
  let oe = `${dateRegexSource}T${timeRegexSource(ne)}`;
  const ae = [];
  return ae.push(ne.local ? "Z?" : "Z"), ne.offset && ae.push("([+-]\\d{2}:?\\d{2})"), oe = `${oe}(${ae.join("|")})`, new RegExp(`^${oe}$`);
}
function isValidIP(ne, oe) {
  return !!((oe === "v4" || !oe) && ipv4Regex.test(ne) || (oe === "v6" || !oe) && ipv6Regex.test(ne));
}
class ZodString extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = String(oe.data)), this._getType(oe) !== ZodParsedType.string) {
      const ve = this._getOrReturnCtx(oe);
      return addIssueToContext(ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ve.parsedType
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const ve of this._def.checks)
      if (ve.kind === "min")
        oe.data.length < ve.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: ve.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "max")
        oe.data.length > ve.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: ve.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "length") {
        const _e = oe.data.length > ve.value, xe = oe.data.length < ve.value;
        (_e || xe) && (ye = this._getOrReturnCtx(oe, ye), _e ? addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: ve.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: ve.message
        }) : xe && addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: ve.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: ve.message
        }), fe.dirty());
      } else if (ve.kind === "email")
        emailRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "uuid")
        uuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "nanoid")
        nanoidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "cuid")
        cuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "cuid2")
        cuid2Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "ulid")
        ulidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty());
      else if (ve.kind === "url")
        try {
          new URL(oe.data);
        } catch {
          ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: ve.message
          }), fe.dirty();
        }
      else
        ve.kind === "regex" ? (ve.regex.lastIndex = 0, ve.regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "regex",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty())) : ve.kind === "trim" ? oe.data = oe.data.trim() : ve.kind === "includes" ? oe.data.includes(ve.value, ve.position) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { includes: ve.value, position: ve.position },
          message: ve.message
        }), fe.dirty()) : ve.kind === "toLowerCase" ? oe.data = oe.data.toLowerCase() : ve.kind === "toUpperCase" ? oe.data = oe.data.toUpperCase() : ve.kind === "startsWith" ? oe.data.startsWith(ve.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { startsWith: ve.value },
          message: ve.message
        }), fe.dirty()) : ve.kind === "endsWith" ? oe.data.endsWith(ve.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { endsWith: ve.value },
          message: ve.message
        }), fe.dirty()) : ve.kind === "datetime" ? datetimeRegex(ve).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "datetime",
          message: ve.message
        }), fe.dirty()) : ve.kind === "date" ? dateRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "date",
          message: ve.message
        }), fe.dirty()) : ve.kind === "time" ? timeRegex(ve).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "time",
          message: ve.message
        }), fe.dirty()) : ve.kind === "duration" ? durationRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "duration",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty()) : ve.kind === "ip" ? isValidIP(oe.data, ve.version) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ip",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty()) : ve.kind === "base64" ? base64Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "base64",
          code: ZodIssueCode.invalid_string,
          message: ve.message
        }), fe.dirty()) : util.assertNever(ve);
    return { status: fe.value, value: oe.data };
  }
  _regex(oe, ae, fe) {
    return this.refinement((ye) => oe.test(ye), {
      validation: ae,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(fe)
    });
  }
  _addCheck(oe) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  email(oe) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(oe) });
  }
  url(oe) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(oe) });
  }
  emoji(oe) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(oe) });
  }
  uuid(oe) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(oe) });
  }
  nanoid(oe) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(oe) });
  }
  cuid(oe) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(oe) });
  }
  cuid2(oe) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(oe) });
  }
  ulid(oe) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(oe) });
  }
  base64(oe) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(oe) });
  }
  ip(oe) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(oe) });
  }
  datetime(oe) {
    var ae, fe;
    return typeof oe == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: oe
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      offset: (ae = oe == null ? void 0 : oe.offset) !== null && ae !== void 0 ? ae : !1,
      local: (fe = oe == null ? void 0 : oe.local) !== null && fe !== void 0 ? fe : !1,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  date(oe) {
    return this._addCheck({ kind: "date", message: oe });
  }
  time(oe) {
    return typeof oe == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: oe
    }) : this._addCheck({
      kind: "time",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  duration(oe) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(oe) });
  }
  regex(oe, ae) {
    return this._addCheck({
      kind: "regex",
      regex: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  includes(oe, ae) {
    return this._addCheck({
      kind: "includes",
      value: oe,
      position: ae == null ? void 0 : ae.position,
      ...errorUtil.errToObj(ae == null ? void 0 : ae.message)
    });
  }
  startsWith(oe, ae) {
    return this._addCheck({
      kind: "startsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  endsWith(oe, ae) {
    return this._addCheck({
      kind: "endsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  length(oe, ae) {
    return this._addCheck({
      kind: "length",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(oe) {
    return this.min(1, errorUtil.errToObj(oe));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((oe) => oe.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((oe) => oe.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((oe) => oe.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((oe) => oe.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((oe) => oe.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((oe) => oe.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((oe) => oe.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((oe) => oe.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((oe) => oe.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((oe) => oe.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((oe) => oe.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((oe) => oe.kind === "base64");
  }
  get minLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodString.create = (ne) => {
  var oe;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
function floatSafeRemainder(ne, oe) {
  const ae = (ne.toString().split(".")[1] || "").length, fe = (oe.toString().split(".")[1] || "").length, ye = ae > fe ? ae : fe, ve = parseInt(ne.toFixed(ye).replace(".", "")), _e = parseInt(oe.toFixed(ye).replace(".", ""));
  return ve % _e / Math.pow(10, ye);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = Number(oe.data)), this._getType(oe) !== ZodParsedType.number) {
      const ve = this._getOrReturnCtx(oe);
      return addIssueToContext(ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ve.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const ve of this._def.checks)
      ve.kind === "int" ? util.isInteger(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: ve.message
      }), ye.dirty()) : ve.kind === "min" ? (ve.inclusive ? oe.data < ve.value : oe.data <= ve.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: ve.value,
        type: "number",
        inclusive: ve.inclusive,
        exact: !1,
        message: ve.message
      }), ye.dirty()) : ve.kind === "max" ? (ve.inclusive ? oe.data > ve.value : oe.data >= ve.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        maximum: ve.value,
        type: "number",
        inclusive: ve.inclusive,
        exact: !1,
        message: ve.message
      }), ye.dirty()) : ve.kind === "multipleOf" ? floatSafeRemainder(oe.data, ve.value) !== 0 && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: ve.value,
        message: ve.message
      }), ye.dirty()) : ve.kind === "finite" ? Number.isFinite(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_finite,
        message: ve.message
      }), ye.dirty()) : util.assertNever(ve);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  int(oe) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(oe)
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  finite(oe) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(oe)
    });
  }
  safe(oe) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
  get isInt() {
    return !!this._def.checks.find((oe) => oe.kind === "int" || oe.kind === "multipleOf" && util.isInteger(oe.value));
  }
  get isFinite() {
    let oe = null, ae = null;
    for (const fe of this._def.checks) {
      if (fe.kind === "finite" || fe.kind === "int" || fe.kind === "multipleOf")
        return !0;
      fe.kind === "min" ? (ae === null || fe.value > ae) && (ae = fe.value) : fe.kind === "max" && (oe === null || fe.value < oe) && (oe = fe.value);
    }
    return Number.isFinite(ae) && Number.isFinite(oe);
  }
}
ZodNumber.create = (ne) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = BigInt(oe.data)), this._getType(oe) !== ZodParsedType.bigint) {
      const ve = this._getOrReturnCtx(oe);
      return addIssueToContext(ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ve.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const ve of this._def.checks)
      ve.kind === "min" ? (ve.inclusive ? oe.data < ve.value : oe.data <= ve.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: ve.value,
        inclusive: ve.inclusive,
        message: ve.message
      }), ye.dirty()) : ve.kind === "max" ? (ve.inclusive ? oe.data > ve.value : oe.data >= ve.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: ve.value,
        inclusive: ve.inclusive,
        message: ve.message
      }), ye.dirty()) : ve.kind === "multipleOf" ? oe.data % ve.value !== BigInt(0) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: ve.value,
        message: ve.message
      }), ye.dirty()) : util.assertNever(ve);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodBigInt.create = (ne) => {
  var oe;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
class ZodBoolean extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = !!oe.data), this._getType(oe) !== ZodParsedType.boolean) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodBoolean.create = (ne) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodDate extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = new Date(oe.data)), this._getType(oe) !== ZodParsedType.date) {
      const ve = this._getOrReturnCtx(oe);
      return addIssueToContext(ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ve.parsedType
      }), INVALID;
    }
    if (isNaN(oe.data.getTime())) {
      const ve = this._getOrReturnCtx(oe);
      return addIssueToContext(ve, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const ve of this._def.checks)
      ve.kind === "min" ? oe.data.getTime() < ve.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_small,
        message: ve.message,
        inclusive: !0,
        exact: !1,
        minimum: ve.value,
        type: "date"
      }), fe.dirty()) : ve.kind === "max" ? oe.data.getTime() > ve.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_big,
        message: ve.message,
        inclusive: !0,
        exact: !1,
        maximum: ve.value,
        type: "date"
      }), fe.dirty()) : util.assertNever(ve);
    return {
      status: fe.value,
      value: new Date(oe.data.getTime())
    };
  }
  _addCheck(oe) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  get minDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
  get maxDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
}
ZodDate.create = (ne) => new ZodDate({
  checks: [],
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(ne)
});
class ZodSymbol extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.symbol) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodSymbol.create = (ne) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(ne)
});
class ZodUndefined extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodUndefined.create = (ne) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(ne)
});
class ZodNull extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.null) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodNull.create = (ne) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(ne)
});
class ZodAny extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodAny.create = (ne) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(ne)
});
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodUnknown.create = (ne) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(ne)
});
class ZodNever extends ZodType {
  _parse(oe) {
    const ae = this._getOrReturnCtx(oe);
    return addIssueToContext(ae, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ae.parsedType
    }), INVALID;
  }
}
ZodNever.create = (ne) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(ne)
});
class ZodVoid extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodVoid.create = (ne) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(ne)
});
class ZodArray extends ZodType {
  _parse(oe) {
    const { ctx: ae, status: fe } = this._processInputParams(oe), ye = this._def;
    if (ae.parsedType !== ZodParsedType.array)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ae.parsedType
      }), INVALID;
    if (ye.exactLength !== null) {
      const _e = ae.data.length > ye.exactLength.value, xe = ae.data.length < ye.exactLength.value;
      (_e || xe) && (addIssueToContext(ae, {
        code: _e ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: xe ? ye.exactLength.value : void 0,
        maximum: _e ? ye.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: ye.exactLength.message
      }), fe.dirty());
    }
    if (ye.minLength !== null && ae.data.length < ye.minLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_small,
      minimum: ye.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.minLength.message
    }), fe.dirty()), ye.maxLength !== null && ae.data.length > ye.maxLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.maxLength.message
    }), fe.dirty()), ae.common.async)
      return Promise.all([...ae.data].map((_e, xe) => ye.type._parseAsync(new ParseInputLazyPath(ae, _e, ae.path, xe)))).then((_e) => ParseStatus.mergeArray(fe, _e));
    const ve = [...ae.data].map((_e, xe) => ye.type._parseSync(new ParseInputLazyPath(ae, _e, ae.path, xe)));
    return ParseStatus.mergeArray(fe, ve);
  }
  get element() {
    return this._def.type;
  }
  min(oe, ae) {
    return new ZodArray({
      ...this._def,
      minLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  length(oe, ae) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodArray.create = (ne, oe) => new ZodArray({
  type: ne,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(oe)
});
function deepPartialify(ne) {
  if (ne instanceof ZodObject) {
    const oe = {};
    for (const ae in ne.shape) {
      const fe = ne.shape[ae];
      oe[ae] = ZodOptional.create(deepPartialify(fe));
    }
    return new ZodObject({
      ...ne._def,
      shape: () => oe
    });
  } else
    return ne instanceof ZodArray ? new ZodArray({
      ...ne._def,
      type: deepPartialify(ne.element)
    }) : ne instanceof ZodOptional ? ZodOptional.create(deepPartialify(ne.unwrap())) : ne instanceof ZodNullable ? ZodNullable.create(deepPartialify(ne.unwrap())) : ne instanceof ZodTuple ? ZodTuple.create(ne.items.map((oe) => deepPartialify(oe))) : ne;
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const oe = this._def.shape(), ae = util.objectKeys(oe);
    return this._cached = { shape: oe, keys: ae };
  }
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.object) {
      const $e = this._getOrReturnCtx(oe);
      return addIssueToContext($e, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: $e.parsedType
      }), INVALID;
    }
    const { status: fe, ctx: ye } = this._processInputParams(oe), { shape: ve, keys: _e } = this._getCached(), xe = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (const $e in ye.data)
        _e.includes($e) || xe.push($e);
    const Oe = [];
    for (const $e of _e) {
      const Me = ve[$e], Re = ye.data[$e];
      Oe.push({
        key: { status: "valid", value: $e },
        value: Me._parse(new ParseInputLazyPath(ye, Re, ye.path, $e)),
        alwaysSet: $e in ye.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const $e = this._def.unknownKeys;
      if ($e === "passthrough")
        for (const Me of xe)
          Oe.push({
            key: { status: "valid", value: Me },
            value: { status: "valid", value: ye.data[Me] }
          });
      else if ($e === "strict")
        xe.length > 0 && (addIssueToContext(ye, {
          code: ZodIssueCode.unrecognized_keys,
          keys: xe
        }), fe.dirty());
      else if ($e !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const $e = this._def.catchall;
      for (const Me of xe) {
        const Re = ye.data[Me];
        Oe.push({
          key: { status: "valid", value: Me },
          value: $e._parse(
            new ParseInputLazyPath(ye, Re, ye.path, Me)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: Me in ye.data
        });
      }
    }
    return ye.common.async ? Promise.resolve().then(async () => {
      const $e = [];
      for (const Me of Oe) {
        const Re = await Me.key, je = await Me.value;
        $e.push({
          key: Re,
          value: je,
          alwaysSet: Me.alwaysSet
        });
      }
      return $e;
    }).then(($e) => ParseStatus.mergeObjectSync(fe, $e)) : ParseStatus.mergeObjectSync(fe, Oe);
  }
  get shape() {
    return this._def.shape();
  }
  strict(oe) {
    return errorUtil.errToObj, new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...oe !== void 0 ? {
        errorMap: (ae, fe) => {
          var ye, ve, _e, xe;
          const Oe = (_e = (ve = (ye = this._def).errorMap) === null || ve === void 0 ? void 0 : ve.call(ye, ae, fe).message) !== null && _e !== void 0 ? _e : fe.defaultError;
          return ae.code === "unrecognized_keys" ? {
            message: (xe = errorUtil.errToObj(oe).message) !== null && xe !== void 0 ? xe : Oe
          } : {
            message: Oe
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(oe) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...oe
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(oe) {
    return new ZodObject({
      unknownKeys: oe._def.unknownKeys,
      catchall: oe._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...oe._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(oe, ae) {
    return this.augment({ [oe]: ae });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(oe) {
    return new ZodObject({
      ...this._def,
      catchall: oe
    });
  }
  pick(oe) {
    const ae = {};
    return util.objectKeys(oe).forEach((fe) => {
      oe[fe] && this.shape[fe] && (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  omit(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      oe[fe] || (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      const ye = this.shape[fe];
      oe && !oe[fe] ? ae[fe] = ye : ae[fe] = ye.optional();
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  required(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      if (oe && !oe[fe])
        ae[fe] = this.shape[fe];
      else {
        let ve = this.shape[fe];
        for (; ve instanceof ZodOptional; )
          ve = ve._def.innerType;
        ae[fe] = ve;
      }
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.strictCreate = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.lazycreate = (ne, oe) => new ZodObject({
  shape: ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
class ZodUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = this._def.options;
    function ye(ve) {
      for (const xe of ve)
        if (xe.result.status === "valid")
          return xe.result;
      for (const xe of ve)
        if (xe.result.status === "dirty")
          return ae.common.issues.push(...xe.ctx.common.issues), xe.result;
      const _e = ve.map((xe) => new ZodError(xe.ctx.common.issues));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: _e
      }), INVALID;
    }
    if (ae.common.async)
      return Promise.all(fe.map(async (ve) => {
        const _e = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await ve._parseAsync({
            data: ae.data,
            path: ae.path,
            parent: _e
          }),
          ctx: _e
        };
      })).then(ye);
    {
      let ve;
      const _e = [];
      for (const Oe of fe) {
        const $e = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        }, Me = Oe._parseSync({
          data: ae.data,
          path: ae.path,
          parent: $e
        });
        if (Me.status === "valid")
          return Me;
        Me.status === "dirty" && !ve && (ve = { result: Me, ctx: $e }), $e.common.issues.length && _e.push($e.common.issues);
      }
      if (ve)
        return ae.common.issues.push(...ve.ctx.common.issues), ve.result;
      const xe = _e.map((Oe) => new ZodError(Oe));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: xe
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (ne, oe) => new ZodUnion({
  options: ne,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(oe)
});
const getDiscriminator = (ne) => ne instanceof ZodLazy ? getDiscriminator(ne.schema) : ne instanceof ZodEffects ? getDiscriminator(ne.innerType()) : ne instanceof ZodLiteral ? [ne.value] : ne instanceof ZodEnum ? ne.options : ne instanceof ZodNativeEnum ? util.objectValues(ne.enum) : ne instanceof ZodDefault ? getDiscriminator(ne._def.innerType) : ne instanceof ZodUndefined ? [void 0] : ne instanceof ZodNull ? [null] : ne instanceof ZodOptional ? [void 0, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodNullable ? [null, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodBranded || ne instanceof ZodReadonly ? getDiscriminator(ne.unwrap()) : ne instanceof ZodCatch ? getDiscriminator(ne._def.innerType) : [];
class ZodDiscriminatedUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.object)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ae.parsedType
      }), INVALID;
    const fe = this.discriminator, ye = ae.data[fe], ve = this.optionsMap.get(ye);
    return ve ? ae.common.async ? ve._parseAsync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : ve._parseSync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : (addIssueToContext(ae, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [fe]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(oe, ae, fe) {
    const ye = /* @__PURE__ */ new Map();
    for (const ve of ae) {
      const _e = getDiscriminator(ve.shape[oe]);
      if (!_e.length)
        throw new Error(`A discriminator value for key \`${oe}\` could not be extracted from all schema options`);
      for (const xe of _e) {
        if (ye.has(xe))
          throw new Error(`Discriminator property ${String(oe)} has duplicate value ${String(xe)}`);
        ye.set(xe, ve);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: oe,
      options: ae,
      optionsMap: ye,
      ...processCreateParams(fe)
    });
  }
}
function mergeValues(ne, oe) {
  const ae = getParsedType(ne), fe = getParsedType(oe);
  if (ne === oe)
    return { valid: !0, data: ne };
  if (ae === ZodParsedType.object && fe === ZodParsedType.object) {
    const ye = util.objectKeys(oe), ve = util.objectKeys(ne).filter((xe) => ye.indexOf(xe) !== -1), _e = { ...ne, ...oe };
    for (const xe of ve) {
      const Oe = mergeValues(ne[xe], oe[xe]);
      if (!Oe.valid)
        return { valid: !1 };
      _e[xe] = Oe.data;
    }
    return { valid: !0, data: _e };
  } else if (ae === ZodParsedType.array && fe === ZodParsedType.array) {
    if (ne.length !== oe.length)
      return { valid: !1 };
    const ye = [];
    for (let ve = 0; ve < ne.length; ve++) {
      const _e = ne[ve], xe = oe[ve], Oe = mergeValues(_e, xe);
      if (!Oe.valid)
        return { valid: !1 };
      ye.push(Oe.data);
    }
    return { valid: !0, data: ye };
  } else
    return ae === ZodParsedType.date && fe === ZodParsedType.date && +ne == +oe ? { valid: !0, data: ne } : { valid: !1 };
}
class ZodIntersection extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = (ve, _e) => {
      if (isAborted(ve) || isAborted(_e))
        return INVALID;
      const xe = mergeValues(ve.value, _e.value);
      return xe.valid ? ((isDirty(ve) || isDirty(_e)) && ae.dirty(), { status: ae.value, value: xe.data }) : (addIssueToContext(fe, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return fe.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      }),
      this._def.right._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      })
    ]).then(([ve, _e]) => ye(ve, _e)) : ye(this._def.left._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }), this._def.right._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }));
  }
}
ZodIntersection.create = (ne, oe, ae) => new ZodIntersection({
  left: ne,
  right: oe,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(ae)
});
class ZodTuple extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.array)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: fe.parsedType
      }), INVALID;
    if (fe.data.length < this._def.items.length)
      return addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && fe.data.length > this._def.items.length && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), ae.dirty());
    const ve = [...fe.data].map((_e, xe) => {
      const Oe = this._def.items[xe] || this._def.rest;
      return Oe ? Oe._parse(new ParseInputLazyPath(fe, _e, fe.path, xe)) : null;
    }).filter((_e) => !!_e);
    return fe.common.async ? Promise.all(ve).then((_e) => ParseStatus.mergeArray(ae, _e)) : ParseStatus.mergeArray(ae, ve);
  }
  get items() {
    return this._def.items;
  }
  rest(oe) {
    return new ZodTuple({
      ...this._def,
      rest: oe
    });
  }
}
ZodTuple.create = (ne, oe) => {
  if (!Array.isArray(ne))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: ne,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(oe)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.object)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: fe.parsedType
      }), INVALID;
    const ye = [], ve = this._def.keyType, _e = this._def.valueType;
    for (const xe in fe.data)
      ye.push({
        key: ve._parse(new ParseInputLazyPath(fe, xe, fe.path, xe)),
        value: _e._parse(new ParseInputLazyPath(fe, fe.data[xe], fe.path, xe)),
        alwaysSet: xe in fe.data
      });
    return fe.common.async ? ParseStatus.mergeObjectAsync(ae, ye) : ParseStatus.mergeObjectSync(ae, ye);
  }
  get element() {
    return this._def.valueType;
  }
  static create(oe, ae, fe) {
    return ae instanceof ZodType ? new ZodRecord({
      keyType: oe,
      valueType: ae,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(fe)
    }) : new ZodRecord({
      keyType: ZodString.create(),
      valueType: oe,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(ae)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.map)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def.keyType, ve = this._def.valueType, _e = [...fe.data.entries()].map(([xe, Oe], $e) => ({
      key: ye._parse(new ParseInputLazyPath(fe, xe, fe.path, [$e, "key"])),
      value: ve._parse(new ParseInputLazyPath(fe, Oe, fe.path, [$e, "value"]))
    }));
    if (fe.common.async) {
      const xe = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const Oe of _e) {
          const $e = await Oe.key, Me = await Oe.value;
          if ($e.status === "aborted" || Me.status === "aborted")
            return INVALID;
          ($e.status === "dirty" || Me.status === "dirty") && ae.dirty(), xe.set($e.value, Me.value);
        }
        return { status: ae.value, value: xe };
      });
    } else {
      const xe = /* @__PURE__ */ new Map();
      for (const Oe of _e) {
        const $e = Oe.key, Me = Oe.value;
        if ($e.status === "aborted" || Me.status === "aborted")
          return INVALID;
        ($e.status === "dirty" || Me.status === "dirty") && ae.dirty(), xe.set($e.value, Me.value);
      }
      return { status: ae.value, value: xe };
    }
  }
}
ZodMap.create = (ne, oe, ae) => new ZodMap({
  valueType: oe,
  keyType: ne,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(ae)
});
class ZodSet extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.set)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def;
    ye.minSize !== null && fe.data.size < ye.minSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_small,
      minimum: ye.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.minSize.message
    }), ae.dirty()), ye.maxSize !== null && fe.data.size > ye.maxSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.maxSize.message
    }), ae.dirty());
    const ve = this._def.valueType;
    function _e(Oe) {
      const $e = /* @__PURE__ */ new Set();
      for (const Me of Oe) {
        if (Me.status === "aborted")
          return INVALID;
        Me.status === "dirty" && ae.dirty(), $e.add(Me.value);
      }
      return { status: ae.value, value: $e };
    }
    const xe = [...fe.data.values()].map((Oe, $e) => ve._parse(new ParseInputLazyPath(fe, Oe, fe.path, $e)));
    return fe.common.async ? Promise.all(xe).then((Oe) => _e(Oe)) : _e(xe);
  }
  min(oe, ae) {
    return new ZodSet({
      ...this._def,
      minSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  size(oe, ae) {
    return this.min(oe, ae).max(oe, ae);
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodSet.create = (ne, oe) => new ZodSet({
  valueType: ne,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(oe)
});
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.function)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ae.parsedType
      }), INVALID;
    function fe(xe, Oe) {
      return makeIssue({
        data: xe,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter(($e) => !!$e),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: Oe
        }
      });
    }
    function ye(xe, Oe) {
      return makeIssue({
        data: xe,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter(($e) => !!$e),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: Oe
        }
      });
    }
    const ve = { errorMap: ae.common.contextualErrorMap }, _e = ae.data;
    if (this._def.returns instanceof ZodPromise) {
      const xe = this;
      return OK(async function(...Oe) {
        const $e = new ZodError([]), Me = await xe._def.args.parseAsync(Oe, ve).catch((Be) => {
          throw $e.addIssue(fe(Oe, Be)), $e;
        }), Re = await Reflect.apply(_e, this, Me);
        return await xe._def.returns._def.type.parseAsync(Re, ve).catch((Be) => {
          throw $e.addIssue(ye(Re, Be)), $e;
        });
      });
    } else {
      const xe = this;
      return OK(function(...Oe) {
        const $e = xe._def.args.safeParse(Oe, ve);
        if (!$e.success)
          throw new ZodError([fe(Oe, $e.error)]);
        const Me = Reflect.apply(_e, this, $e.data), Re = xe._def.returns.safeParse(Me, ve);
        if (!Re.success)
          throw new ZodError([ye(Me, Re.error)]);
        return Re.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...oe) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(oe).rest(ZodUnknown.create())
    });
  }
  returns(oe) {
    return new ZodFunction({
      ...this._def,
      returns: oe
    });
  }
  implement(oe) {
    return this.parse(oe);
  }
  strictImplement(oe) {
    return this.parse(oe);
  }
  static create(oe, ae, fe) {
    return new ZodFunction({
      args: oe || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: ae || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(fe)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    return this._def.getter()._parse({ data: ae.data, path: ae.path, parent: ae });
  }
}
ZodLazy.create = (ne, oe) => new ZodLazy({
  getter: ne,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(oe)
});
class ZodLiteral extends ZodType {
  _parse(oe) {
    if (oe.data !== this._def.value) {
      const ae = this._getOrReturnCtx(oe);
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (ne, oe) => new ZodLiteral({
  value: ne,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(oe)
});
function createZodEnum(ne, oe) {
  return new ZodEnum({
    values: ne,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(oe)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    if (typeof oe.data != "string") {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        expected: util.joinValues(fe),
        received: ae.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodEnum_cache, new Set(this._def.values), "f"), !__classPrivateFieldGet$2(this, _ZodEnum_cache, "f").has(oe.data)) {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_enum_value,
        options: fe
      }), INVALID;
    }
    return OK(oe.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Values() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  extract(oe, ae = this._def) {
    return ZodEnum.create(oe, {
      ...this._def,
      ...ae
    });
  }
  exclude(oe, ae = this._def) {
    return ZodEnum.create(this.options.filter((fe) => !oe.includes(fe)), {
      ...this._def,
      ...ae
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    const ae = util.getValidEnumValues(this._def.values), fe = this._getOrReturnCtx(oe);
    if (fe.parsedType !== ZodParsedType.string && fe.parsedType !== ZodParsedType.number) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        expected: util.joinValues(ye),
        received: fe.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f"), !__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f").has(oe.data)) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        received: fe.data,
        code: ZodIssueCode.invalid_enum_value,
        options: ye
      }), INVALID;
    }
    return OK(oe.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (ne, oe) => new ZodNativeEnum({
  values: ne,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(oe)
});
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.promise && ae.common.async === !1)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ae.parsedType
      }), INVALID;
    const fe = ae.parsedType === ZodParsedType.promise ? ae.data : Promise.resolve(ae.data);
    return OK(fe.then((ye) => this._def.type.parseAsync(ye, {
      path: ae.path,
      errorMap: ae.common.contextualErrorMap
    })));
  }
}
ZodPromise.create = (ne, oe) => new ZodPromise({
  type: ne,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(oe)
});
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = this._def.effect || null, ve = {
      addIssue: (_e) => {
        addIssueToContext(fe, _e), _e.fatal ? ae.abort() : ae.dirty();
      },
      get path() {
        return fe.path;
      }
    };
    if (ve.addIssue = ve.addIssue.bind(ve), ye.type === "preprocess") {
      const _e = ye.transform(fe.data, ve);
      if (fe.common.async)
        return Promise.resolve(_e).then(async (xe) => {
          if (ae.value === "aborted")
            return INVALID;
          const Oe = await this._def.schema._parseAsync({
            data: xe,
            path: fe.path,
            parent: fe
          });
          return Oe.status === "aborted" ? INVALID : Oe.status === "dirty" || ae.value === "dirty" ? DIRTY(Oe.value) : Oe;
        });
      {
        if (ae.value === "aborted")
          return INVALID;
        const xe = this._def.schema._parseSync({
          data: _e,
          path: fe.path,
          parent: fe
        });
        return xe.status === "aborted" ? INVALID : xe.status === "dirty" || ae.value === "dirty" ? DIRTY(xe.value) : xe;
      }
    }
    if (ye.type === "refinement") {
      const _e = (xe) => {
        const Oe = ye.refinement(xe, ve);
        if (fe.common.async)
          return Promise.resolve(Oe);
        if (Oe instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return xe;
      };
      if (fe.common.async === !1) {
        const xe = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return xe.status === "aborted" ? INVALID : (xe.status === "dirty" && ae.dirty(), _e(xe.value), { status: ae.value, value: xe.value });
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((xe) => xe.status === "aborted" ? INVALID : (xe.status === "dirty" && ae.dirty(), _e(xe.value).then(() => ({ status: ae.value, value: xe.value }))));
    }
    if (ye.type === "transform")
      if (fe.common.async === !1) {
        const _e = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        if (!isValid(_e))
          return _e;
        const xe = ye.transform(_e.value, ve);
        if (xe instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: ae.value, value: xe };
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((_e) => isValid(_e) ? Promise.resolve(ye.transform(_e.value, ve)).then((xe) => ({ status: ae.value, value: xe })) : _e);
    util.assertNever(ye);
  }
}
ZodEffects.create = (ne, oe, ae) => new ZodEffects({
  schema: ne,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect: oe,
  ...processCreateParams(ae)
});
ZodEffects.createWithPreprocess = (ne, oe, ae) => new ZodEffects({
  schema: oe,
  effect: { type: "preprocess", transform: ne },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(ae)
});
class ZodOptional extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (ne, oe) => new ZodOptional({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(oe)
});
class ZodNullable extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (ne, oe) => new ZodNullable({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(oe)
});
class ZodDefault extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    let fe = ae.data;
    return ae.parsedType === ZodParsedType.undefined && (fe = this._def.defaultValue()), this._def.innerType._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (ne, oe) => new ZodDefault({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof oe.default == "function" ? oe.default : () => oe.default,
  ...processCreateParams(oe)
});
class ZodCatch extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = {
      ...ae,
      common: {
        ...ae.common,
        issues: []
      }
    }, ye = this._def.innerType._parse({
      data: fe.data,
      path: fe.path,
      parent: {
        ...fe
      }
    });
    return isAsync(ye) ? ye.then((ve) => ({
      status: "valid",
      value: ve.status === "valid" ? ve.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    })) : {
      status: "valid",
      value: ye.status === "valid" ? ye.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (ne, oe) => new ZodCatch({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof oe.catch == "function" ? oe.catch : () => oe.catch,
  ...processCreateParams(oe)
});
class ZodNaN extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.nan) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: fe.parsedType
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
}
ZodNaN.create = (ne) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(ne)
});
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = ae.data;
    return this._def.type._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.common.async)
      return (async () => {
        const ve = await this._def.in._parseAsync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return ve.status === "aborted" ? INVALID : ve.status === "dirty" ? (ae.dirty(), DIRTY(ve.value)) : this._def.out._parseAsync({
          data: ve.value,
          path: fe.path,
          parent: fe
        });
      })();
    {
      const ye = this._def.in._parseSync({
        data: fe.data,
        path: fe.path,
        parent: fe
      });
      return ye.status === "aborted" ? INVALID : ye.status === "dirty" ? (ae.dirty(), {
        status: "dirty",
        value: ye.value
      }) : this._def.out._parseSync({
        data: ye.value,
        path: fe.path,
        parent: fe
      });
    }
  }
  static create(oe, ae) {
    return new ZodPipeline({
      in: oe,
      out: ae,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(oe) {
    const ae = this._def.innerType._parse(oe), fe = (ye) => (isValid(ye) && (ye.value = Object.freeze(ye.value)), ye);
    return isAsync(ae) ? ae.then((ye) => fe(ye)) : fe(ae);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (ne, oe) => new ZodReadonly({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(oe)
});
function custom(ne, oe = {}, ae) {
  return ne ? ZodAny.create().superRefine((fe, ye) => {
    var ve, _e;
    if (!ne(fe)) {
      const xe = typeof oe == "function" ? oe(fe) : typeof oe == "string" ? { message: oe } : oe, Oe = (_e = (ve = xe.fatal) !== null && ve !== void 0 ? ve : ae) !== null && _e !== void 0 ? _e : !0, $e = typeof xe == "string" ? { message: xe } : xe;
      ye.addIssue({ code: "custom", ...$e, fatal: Oe });
    }
  }) : ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ne) {
  ne.ZodString = "ZodString", ne.ZodNumber = "ZodNumber", ne.ZodNaN = "ZodNaN", ne.ZodBigInt = "ZodBigInt", ne.ZodBoolean = "ZodBoolean", ne.ZodDate = "ZodDate", ne.ZodSymbol = "ZodSymbol", ne.ZodUndefined = "ZodUndefined", ne.ZodNull = "ZodNull", ne.ZodAny = "ZodAny", ne.ZodUnknown = "ZodUnknown", ne.ZodNever = "ZodNever", ne.ZodVoid = "ZodVoid", ne.ZodArray = "ZodArray", ne.ZodObject = "ZodObject", ne.ZodUnion = "ZodUnion", ne.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ne.ZodIntersection = "ZodIntersection", ne.ZodTuple = "ZodTuple", ne.ZodRecord = "ZodRecord", ne.ZodMap = "ZodMap", ne.ZodSet = "ZodSet", ne.ZodFunction = "ZodFunction", ne.ZodLazy = "ZodLazy", ne.ZodLiteral = "ZodLiteral", ne.ZodEnum = "ZodEnum", ne.ZodEffects = "ZodEffects", ne.ZodNativeEnum = "ZodNativeEnum", ne.ZodOptional = "ZodOptional", ne.ZodNullable = "ZodNullable", ne.ZodDefault = "ZodDefault", ne.ZodCatch = "ZodCatch", ne.ZodPromise = "ZodPromise", ne.ZodBranded = "ZodBranded", ne.ZodPipeline = "ZodPipeline", ne.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (ne, oe = {
  message: `Input not instance of ${ne.name}`
}) => custom((ae) => ae instanceof ne, oe), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = {
  string: (ne) => ZodString.create({ ...ne, coerce: !0 }),
  number: (ne) => ZodNumber.create({ ...ne, coerce: !0 }),
  boolean: (ne) => ZodBoolean.create({
    ...ne,
    coerce: !0
  }),
  bigint: (ne) => ZodBigInt.create({ ...ne, coerce: !0 }),
  date: (ne) => ZodDate.create({ ...ne, coerce: !0 })
}, NEVER = INVALID;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
z$2.object({ chainId: z$2.number(), address: z$2.string().refine(isHex$1).optional(), filters: z$2.array(z$2.object({ tableId: z$2.string().refine(isHex$1), key0: z$2.string().refine(isHex$1).optional(), key1: z$2.string().refine(isHex$1).optional() })).default([]) });
function invert(ne) {
  const oe = /* @__PURE__ */ Object.create(null);
  for (const ae in ne) {
    const fe = ne[ae];
    oe[fe] = ae;
  }
  return oe;
}
const TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);
invert(TRPC_ERROR_CODES_BY_KEY);
const noop$2 = () => {
};
function createInnerProxy(ne, oe) {
  return new Proxy(noop$2, {
    get(fe, ye) {
      if (!(typeof ye != "string" || ye === "then"))
        return createInnerProxy(ne, [
          ...oe,
          ye
        ]);
    },
    apply(fe, ye, ve) {
      const _e = oe[oe.length - 1] === "apply";
      return ne({
        args: _e ? ve.length >= 2 ? ve[1] : [] : ve,
        path: _e ? oe.slice(0, -1) : oe
      });
    }
  });
}
const createRecursiveProxy = (ne) => createInnerProxy(ne, []), createFlatProxy = (ne) => new Proxy(noop$2, {
  get(oe, ae) {
    if (!(typeof ae != "string" || ae === "then"))
      return ne(ae);
  }
});
var oO, aO, iO, sO, uO, lO;
typeof window > "u" || "Deno" in window || ((aO = (oO = globalThis.process) == null ? void 0 : oO.env) == null ? void 0 : aO.NODE_ENV) === "test" || (sO = (iO = globalThis.process) == null ? void 0 : iO.env) != null && sO.JEST_WORKER_ID || (lO = (uO = globalThis.process) == null ? void 0 : uO.env) != null && lO.VITEST_WORKER_ID;
var DoubleIndexedKV = (
  /** @class */
  function() {
    function ne() {
      this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
    }
    return ne.prototype.set = function(oe, ae) {
      this.keyToValue.set(oe, ae), this.valueToKey.set(ae, oe);
    }, ne.prototype.getByKey = function(oe) {
      return this.keyToValue.get(oe);
    }, ne.prototype.getByValue = function(oe) {
      return this.valueToKey.get(oe);
    }, ne.prototype.clear = function() {
      this.keyToValue.clear(), this.valueToKey.clear();
    }, ne;
  }()
), Registry = (
  /** @class */
  function() {
    function ne(oe) {
      this.generateIdentifier = oe, this.kv = new DoubleIndexedKV();
    }
    return ne.prototype.register = function(oe, ae) {
      this.kv.getByValue(oe) || (ae || (ae = this.generateIdentifier(oe)), this.kv.set(ae, oe));
    }, ne.prototype.clear = function() {
      this.kv.clear();
    }, ne.prototype.getIdentifier = function(oe) {
      return this.kv.getByValue(oe);
    }, ne.prototype.getValue = function(oe) {
      return this.kv.getByKey(oe);
    }, ne;
  }()
), __extends$1 = globalThis && globalThis.__extends || function() {
  var ne = function(oe, ae) {
    return ne = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ye) {
      fe.__proto__ = ye;
    } || function(fe, ye) {
      for (var ve in ye)
        Object.prototype.hasOwnProperty.call(ye, ve) && (fe[ve] = ye[ve]);
    }, ne(oe, ae);
  };
  return function(oe, ae) {
    if (typeof ae != "function" && ae !== null)
      throw new TypeError("Class extends value " + String(ae) + " is not a constructor or null");
    ne(oe, ae);
    function fe() {
      this.constructor = oe;
    }
    oe.prototype = ae === null ? Object.create(ae) : (fe.prototype = ae.prototype, new fe());
  };
}(), ClassRegistry = (
  /** @class */
  function(ne) {
    __extends$1(oe, ne);
    function oe() {
      var ae = ne.call(this, function(fe) {
        return fe.name;
      }) || this;
      return ae.classToAllowedProps = /* @__PURE__ */ new Map(), ae;
    }
    return oe.prototype.register = function(ae, fe) {
      typeof fe == "object" ? (fe.allowProps && this.classToAllowedProps.set(ae, fe.allowProps), ne.prototype.register.call(this, ae, fe.identifier)) : ne.prototype.register.call(this, ae, fe);
    }, oe.prototype.getAllowedProps = function(ae) {
      return this.classToAllowedProps.get(ae);
    }, oe;
  }(Registry)
), __read$4 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ve = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ve.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return ve;
};
function valuesOfObj(ne) {
  if ("values" in Object)
    return Object.values(ne);
  var oe = [];
  for (var ae in ne)
    ne.hasOwnProperty(ae) && oe.push(ne[ae]);
  return oe;
}
function find(ne, oe) {
  var ae = valuesOfObj(ne);
  if ("find" in ae)
    return ae.find(oe);
  for (var fe = ae, ye = 0; ye < fe.length; ye++) {
    var ve = fe[ye];
    if (oe(ve))
      return ve;
  }
}
function forEach(ne, oe) {
  Object.entries(ne).forEach(function(ae) {
    var fe = __read$4(ae, 2), ye = fe[0], ve = fe[1];
    return oe(ve, ye);
  });
}
function includes(ne, oe) {
  return ne.indexOf(oe) !== -1;
}
function findArr(ne, oe) {
  for (var ae = 0; ae < ne.length; ae++) {
    var fe = ne[ae];
    if (oe(fe))
      return fe;
  }
}
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function ne() {
      this.transfomers = {};
    }
    return ne.prototype.register = function(oe) {
      this.transfomers[oe.name] = oe;
    }, ne.prototype.findApplicable = function(oe) {
      return find(this.transfomers, function(ae) {
        return ae.isApplicable(oe);
      });
    }, ne.prototype.findByName = function(oe) {
      return this.transfomers[oe];
    }, ne;
  }()
), getType$1 = function(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}, isUndefined = function(ne) {
  return typeof ne > "u";
}, isNull = function(ne) {
  return ne === null;
}, isPlainObject$2 = function(ne) {
  return typeof ne != "object" || ne === null || ne === Object.prototype ? !1 : Object.getPrototypeOf(ne) === null ? !0 : Object.getPrototypeOf(ne) === Object.prototype;
}, isEmptyObject = function(ne) {
  return isPlainObject$2(ne) && Object.keys(ne).length === 0;
}, isArray$3 = function(ne) {
  return Array.isArray(ne);
}, isString = function(ne) {
  return typeof ne == "string";
}, isNumber = function(ne) {
  return typeof ne == "number" && !isNaN(ne);
}, isBoolean = function(ne) {
  return typeof ne == "boolean";
}, isRegExp = function(ne) {
  return ne instanceof RegExp;
}, isMap = function(ne) {
  return ne instanceof Map;
}, isSet = function(ne) {
  return ne instanceof Set;
}, isSymbol = function(ne) {
  return getType$1(ne) === "Symbol";
}, isDate = function(ne) {
  return ne instanceof Date && !isNaN(ne.valueOf());
}, isError = function(ne) {
  return ne instanceof Error;
}, isNaNValue = function(ne) {
  return typeof ne == "number" && isNaN(ne);
}, isPrimitive = function(ne) {
  return isBoolean(ne) || isNull(ne) || isUndefined(ne) || isNumber(ne) || isString(ne) || isSymbol(ne);
}, isBigint = function(ne) {
  return typeof ne == "bigint";
}, isInfinite = function(ne) {
  return ne === 1 / 0 || ne === -1 / 0;
}, isTypedArray = function(ne) {
  return ArrayBuffer.isView(ne) && !(ne instanceof DataView);
}, isURL = function(ne) {
  return ne instanceof URL;
}, escapeKey = function(ne) {
  return ne.replace(/\./g, "\\.");
}, stringifyPath = function(ne) {
  return ne.map(String).map(escapeKey).join(".");
}, parsePath = function(ne) {
  for (var oe = [], ae = "", fe = 0; fe < ne.length; fe++) {
    var ye = ne.charAt(fe), ve = ye === "\\" && ne.charAt(fe + 1) === ".";
    if (ve) {
      ae += ".", fe++;
      continue;
    }
    var _e = ye === ".";
    if (_e) {
      oe.push(ae), ae = "";
      continue;
    }
    ae += ye;
  }
  var xe = ae;
  return oe.push(xe), oe;
}, __assign$1 = globalThis && globalThis.__assign || function() {
  return __assign$1 = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign$1.apply(this, arguments);
}, __read$3 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ve = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ve.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return ve;
}, __spreadArray$3 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function simpleTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
  }),
  simpleTransformation(isBigint, "bigint", function(ne) {
    return ne.toString();
  }, function(ne) {
    return typeof BigInt < "u" ? BigInt(ne) : (console.error("Please add a BigInt polyfill."), ne);
  }),
  simpleTransformation(isDate, "Date", function(ne) {
    return ne.toISOString();
  }, function(ne) {
    return new Date(ne);
  }),
  simpleTransformation(isError, "Error", function(ne, oe) {
    var ae = {
      name: ne.name,
      message: ne.message
    };
    return oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }, function(ne, oe) {
    var ae = new Error(ne.message);
    return ae.name = ne.name, ae.stack = ne.stack, oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }),
  simpleTransformation(isRegExp, "regexp", function(ne) {
    return "" + ne;
  }, function(ne) {
    var oe = ne.slice(1, ne.lastIndexOf("/")), ae = ne.slice(ne.lastIndexOf("/") + 1);
    return new RegExp(oe, ae);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(ne) {
      return __spreadArray$3([], __read$3(ne.values()));
    },
    function(ne) {
      return new Set(ne);
    }
  ),
  simpleTransformation(isMap, "map", function(ne) {
    return __spreadArray$3([], __read$3(ne.entries()));
  }, function(ne) {
    return new Map(ne);
  }),
  simpleTransformation(function(ne) {
    return isNaNValue(ne) || isInfinite(ne);
  }, "number", function(ne) {
    return isNaNValue(ne) ? "NaN" : ne > 0 ? "Infinity" : "-Infinity";
  }, Number),
  simpleTransformation(function(ne) {
    return ne === 0 && 1 / ne === -1 / 0;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(ne) {
    return ne.toString();
  }, function(ne) {
    return new URL(ne);
  })
];
function compositeTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var symbolRule = compositeTransformation(function(ne, oe) {
  if (isSymbol(ne)) {
    var ae = !!oe.symbolRegistry.getIdentifier(ne);
    return ae;
  }
  return !1;
}, function(ne, oe) {
  var ae = oe.symbolRegistry.getIdentifier(ne);
  return ["symbol", ae];
}, function(ne) {
  return ne.description;
}, function(ne, oe, ae) {
  var fe = ae.symbolRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown symbol");
  return fe;
}), constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(ne, oe) {
  return ne[oe.name] = oe, ne;
}, {}), typedArrayRule = compositeTransformation(isTypedArray, function(ne) {
  return ["typed-array", ne.constructor.name];
}, function(ne) {
  return __spreadArray$3([], __read$3(ne));
}, function(ne, oe) {
  var ae = constructorToName[oe[1]];
  if (!ae)
    throw new Error("Trying to deserialize unknown typed array");
  return new ae(ne);
});
function isInstanceOfRegisteredClass(ne, oe) {
  if (ne != null && ne.constructor) {
    var ae = !!oe.classRegistry.getIdentifier(ne.constructor);
    return ae;
  }
  return !1;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(ne, oe) {
  var ae = oe.classRegistry.getIdentifier(ne.constructor);
  return ["class", ae];
}, function(ne, oe) {
  var ae = oe.classRegistry.getAllowedProps(ne.constructor);
  if (!ae)
    return __assign$1({}, ne);
  var fe = {};
  return ae.forEach(function(ye) {
    fe[ye] = ne[ye];
  }), fe;
}, function(ne, oe, ae) {
  var fe = ae.classRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  return Object.assign(Object.create(fe.prototype), ne);
}), customRule = compositeTransformation(function(ne, oe) {
  return !!oe.customTransformerRegistry.findApplicable(ne);
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ["custom", ae.name];
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ae.serialize(ne);
}, function(ne, oe, ae) {
  var fe = ae.customTransformerRegistry.findByName(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown custom value");
  return fe.deserialize(ne);
}), compositeRules = [classRule, symbolRule, customRule, typedArrayRule], transformValue = function(ne, oe) {
  var ae = findArr(compositeRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (ae)
    return {
      value: ae.transform(ne, oe),
      type: ae.annotation(ne, oe)
    };
  var fe = findArr(simpleRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (fe)
    return {
      value: fe.transform(ne, oe),
      type: fe.annotation
    };
}, simpleRulesByAnnotation = {};
simpleRules.forEach(function(ne) {
  simpleRulesByAnnotation[ne.annotation] = ne;
});
var untransformValue = function(ne, oe, ae) {
  if (isArray$3(oe))
    switch (oe[0]) {
      case "symbol":
        return symbolRule.untransform(ne, oe, ae);
      case "class":
        return classRule.untransform(ne, oe, ae);
      case "custom":
        return customRule.untransform(ne, oe, ae);
      case "typed-array":
        return typedArrayRule.untransform(ne, oe, ae);
      default:
        throw new Error("Unknown transformation: " + oe);
    }
  else {
    var fe = simpleRulesByAnnotation[oe];
    if (!fe)
      throw new Error("Unknown transformation: " + oe);
    return fe.untransform(ne, ae);
  }
}, getNthKey = function(ne, oe) {
  for (var ae = ne.keys(); oe > 0; )
    ae.next(), oe--;
  return ae.next().value;
};
function validatePath(ne) {
  if (includes(ne, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (includes(ne, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (includes(ne, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var getDeep = function(ne, oe) {
  validatePath(oe);
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    if (isSet(ne))
      ne = getNthKey(ne, +fe);
    else if (isMap(ne)) {
      var ye = +fe, ve = +oe[++ae] == 0 ? "key" : "value", _e = getNthKey(ne, ye);
      switch (ve) {
        case "key":
          ne = _e;
          break;
        case "value":
          ne = ne.get(_e);
          break;
      }
    } else
      ne = ne[fe];
  }
  return ne;
}, setDeep = function(ne, oe, ae) {
  if (validatePath(oe), oe.length === 0)
    return ae(ne);
  for (var fe = ne, ye = 0; ye < oe.length - 1; ye++) {
    var ve = oe[ye];
    if (isArray$3(fe)) {
      var _e = +ve;
      fe = fe[_e];
    } else if (isPlainObject$2(fe))
      fe = fe[ve];
    else if (isSet(fe)) {
      var xe = +ve;
      fe = getNthKey(fe, xe);
    } else if (isMap(fe)) {
      var Oe = ye === oe.length - 2;
      if (Oe)
        break;
      var xe = +ve, $e = +oe[++ye] == 0 ? "key" : "value", Me = getNthKey(fe, xe);
      switch ($e) {
        case "key":
          fe = Me;
          break;
        case "value":
          fe = fe.get(Me);
          break;
      }
    }
  }
  var Re = oe[oe.length - 1];
  if (isArray$3(fe) ? fe[+Re] = ae(fe[+Re]) : isPlainObject$2(fe) && (fe[Re] = ae(fe[Re])), isSet(fe)) {
    var je = getNthKey(fe, +Re), Be = ae(je);
    je !== Be && (fe.delete(je), fe.add(Be));
  }
  if (isMap(fe)) {
    var xe = +oe[oe.length - 2], ze = getNthKey(fe, xe), $e = +Re == 0 ? "key" : "value";
    switch ($e) {
      case "key": {
        var He = ae(ze);
        fe.set(He, fe.get(ze)), He !== ze && fe.delete(ze);
        break;
      }
      case "value": {
        fe.set(ze, ae(fe.get(ze)));
        break;
      }
    }
  }
  return ne;
}, __read$2 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ve = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ve.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return ve;
}, __spreadArray$2 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function traverse(ne, oe, ae) {
  if (ae === void 0 && (ae = []), !!ne) {
    if (!isArray$3(ne)) {
      forEach(ne, function(_e, xe) {
        return traverse(_e, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(xe))));
      });
      return;
    }
    var fe = __read$2(ne, 2), ye = fe[0], ve = fe[1];
    ve && forEach(ve, function(_e, xe) {
      traverse(_e, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(xe))));
    }), oe(ye, ae);
  }
}
function applyValueAnnotations(ne, oe, ae) {
  return traverse(oe, function(fe, ye) {
    ne = setDeep(ne, ye, function(ve) {
      return untransformValue(ve, fe, ae);
    });
  }), ne;
}
function applyReferentialEqualityAnnotations(ne, oe) {
  function ae(_e, xe) {
    var Oe = getDeep(ne, parsePath(xe));
    _e.map(parsePath).forEach(function($e) {
      ne = setDeep(ne, $e, function() {
        return Oe;
      });
    });
  }
  if (isArray$3(oe)) {
    var fe = __read$2(oe, 2), ye = fe[0], ve = fe[1];
    ye.forEach(function(_e) {
      ne = setDeep(ne, parsePath(_e), function() {
        return ne;
      });
    }), ve && forEach(ve, ae);
  } else
    forEach(oe, ae);
  return ne;
}
var isDeep = function(ne, oe) {
  return isPlainObject$2(ne) || isArray$3(ne) || isMap(ne) || isSet(ne) || isInstanceOfRegisteredClass(ne, oe);
};
function addIdentity(ne, oe, ae) {
  var fe = ae.get(ne);
  fe ? fe.push(oe) : ae.set(ne, [oe]);
}
function generateReferentialEqualityAnnotations(ne, oe) {
  var ae = {}, fe = void 0;
  return ne.forEach(function(ye) {
    if (!(ye.length <= 1)) {
      oe || (ye = ye.map(function(Oe) {
        return Oe.map(String);
      }).sort(function(Oe, $e) {
        return Oe.length - $e.length;
      }));
      var ve = __read$2(ye), _e = ve[0], xe = ve.slice(1);
      _e.length === 0 ? fe = xe.map(stringifyPath) : ae[stringifyPath(_e)] = xe.map(stringifyPath);
    }
  }), fe ? isEmptyObject(ae) ? [fe] : [fe, ae] : isEmptyObject(ae) ? void 0 : ae;
}
var walker = function(ne, oe, ae, fe, ye, ve, _e) {
  var xe;
  ye === void 0 && (ye = []), ve === void 0 && (ve = []), _e === void 0 && (_e = /* @__PURE__ */ new Map());
  var Oe = isPrimitive(ne);
  if (!Oe) {
    addIdentity(ne, ye, oe);
    var $e = _e.get(ne);
    if ($e)
      return fe ? {
        transformedValue: null
      } : $e;
  }
  if (!isDeep(ne, ae)) {
    var Me = transformValue(ne, ae), Re = Me ? {
      transformedValue: Me.value,
      annotations: [Me.type]
    } : {
      transformedValue: ne
    };
    return Oe || _e.set(ne, Re), Re;
  }
  if (includes(ve, ne))
    return {
      transformedValue: null
    };
  var je = transformValue(ne, ae), Be = (xe = je == null ? void 0 : je.value) !== null && xe !== void 0 ? xe : ne, ze = isArray$3(Be) ? [] : {}, He = {};
  forEach(Be, function(Ye, pt) {
    var dt = walker(Ye, oe, ae, fe, __spreadArray$2(__spreadArray$2([], __read$2(ye)), [pt]), __spreadArray$2(__spreadArray$2([], __read$2(ve)), [ne]), _e);
    ze[pt] = dt.transformedValue, isArray$3(dt.annotations) ? He[pt] = dt.annotations : isPlainObject$2(dt.annotations) && forEach(dt.annotations, function(yt, Ct) {
      He[escapeKey(pt) + "." + Ct] = yt;
    });
  });
  var qe = isEmptyObject(He) ? {
    transformedValue: ze,
    annotations: je ? [je.type] : void 0
  } : {
    transformedValue: ze,
    annotations: je ? [je.type, He] : He
  };
  return Oe || _e.set(ne, qe), qe;
};
function getType(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}
function isArray$2(ne) {
  return getType(ne) === "Array";
}
function isPlainObject$1(ne) {
  if (getType(ne) !== "Object")
    return !1;
  const oe = Object.getPrototypeOf(ne);
  return !!oe && oe.constructor === Object && oe === Object.prototype;
}
function assignProp(ne, oe, ae, fe, ye) {
  const ve = {}.propertyIsEnumerable.call(fe, oe) ? "enumerable" : "nonenumerable";
  ve === "enumerable" && (ne[oe] = ae), ye && ve === "nonenumerable" && Object.defineProperty(ne, oe, {
    value: ae,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function copy(ne, oe = {}) {
  if (isArray$2(ne))
    return ne.map((ye) => copy(ye, oe));
  if (!isPlainObject$1(ne))
    return ne;
  const ae = Object.getOwnPropertyNames(ne), fe = Object.getOwnPropertySymbols(ne);
  return [...ae, ...fe].reduce((ye, ve) => {
    if (isArray$2(oe.props) && !oe.props.includes(ve))
      return ye;
    const _e = ne[ve], xe = copy(_e, oe);
    return assignProp(ye, ve, xe, ne, oe.nonenumerable), ye;
  }, {});
}
var __assign = globalThis && globalThis.__assign || function() {
  return __assign = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign.apply(this, arguments);
}, __read$1 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ve = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ve.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return ve;
}, __spreadArray$1 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
}, SuperJSON = (
  /** @class */
  function() {
    function ne(oe) {
      var ae = oe === void 0 ? {} : oe, fe = ae.dedupe, ye = fe === void 0 ? !1 : fe;
      this.classRegistry = new ClassRegistry(), this.symbolRegistry = new Registry(function(ve) {
        var _e;
        return (_e = ve.description) !== null && _e !== void 0 ? _e : "";
      }), this.customTransformerRegistry = new CustomTransformerRegistry(), this.allowedErrorProps = [], this.dedupe = ye;
    }
    return ne.prototype.serialize = function(oe) {
      var ae = /* @__PURE__ */ new Map(), fe = walker(oe, ae, this, this.dedupe), ye = {
        json: fe.transformedValue
      };
      fe.annotations && (ye.meta = __assign(__assign({}, ye.meta), { values: fe.annotations }));
      var ve = generateReferentialEqualityAnnotations(ae, this.dedupe);
      return ve && (ye.meta = __assign(__assign({}, ye.meta), { referentialEqualities: ve })), ye;
    }, ne.prototype.deserialize = function(oe) {
      var ae = oe.json, fe = oe.meta, ye = copy(ae);
      return fe != null && fe.values && (ye = applyValueAnnotations(ye, fe.values, this)), fe != null && fe.referentialEqualities && (ye = applyReferentialEqualityAnnotations(ye, fe.referentialEqualities)), ye;
    }, ne.prototype.stringify = function(oe) {
      return JSON.stringify(this.serialize(oe));
    }, ne.prototype.parse = function(oe) {
      return this.deserialize(JSON.parse(oe));
    }, ne.prototype.registerClass = function(oe, ae) {
      this.classRegistry.register(oe, ae);
    }, ne.prototype.registerSymbol = function(oe, ae) {
      this.symbolRegistry.register(oe, ae);
    }, ne.prototype.registerCustom = function(oe, ae) {
      this.customTransformerRegistry.register(__assign({ name: ae }, oe));
    }, ne.prototype.allowErrorProps = function() {
      for (var oe, ae = [], fe = 0; fe < arguments.length; fe++)
        ae[fe] = arguments[fe];
      (oe = this.allowedErrorProps).push.apply(oe, __spreadArray$1([], __read$1(ae)));
    }, ne.defaultInstance = new ne(), ne.serialize = ne.defaultInstance.serialize.bind(ne.defaultInstance), ne.deserialize = ne.defaultInstance.deserialize.bind(ne.defaultInstance), ne.stringify = ne.defaultInstance.stringify.bind(ne.defaultInstance), ne.parse = ne.defaultInstance.parse.bind(ne.defaultInstance), ne.registerClass = ne.defaultInstance.registerClass.bind(ne.defaultInstance), ne.registerSymbol = ne.defaultInstance.registerSymbol.bind(ne.defaultInstance), ne.registerCustom = ne.defaultInstance.registerCustom.bind(ne.defaultInstance), ne.allowErrorProps = ne.defaultInstance.allowErrorProps.bind(ne.defaultInstance), ne;
  }()
);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
function identity$2(ne) {
  return ne;
}
function pipeFromArray$1(ne) {
  return ne.length === 0 ? identity$2 : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce((fe, ye) => ye(fe), ae);
  };
}
function observable$2(ne) {
  const oe = {
    subscribe(ae) {
      let fe = null, ye = !1, ve = !1, _e = !1;
      function xe() {
        if (fe === null) {
          _e = !0;
          return;
        }
        ve || (ve = !0, typeof fe == "function" ? fe() : fe && fe.unsubscribe());
      }
      return fe = ne({
        next(Oe) {
          var $e;
          ye || ($e = ae.next) == null || $e.call(ae, Oe);
        },
        error(Oe) {
          var $e;
          ye || (ye = !0, ($e = ae.error) == null || $e.call(ae, Oe), xe());
        },
        complete() {
          var Oe;
          ye || (ye = !0, (Oe = ae.complete) == null || Oe.call(ae), xe());
        }
      }), _e && xe(), {
        unsubscribe: xe
      };
    },
    pipe(...ae) {
      return pipeFromArray$1(ae)(oe);
    }
  };
  return oe;
}
function share$1(ne) {
  return (oe) => {
    let ae = 0, fe = null;
    const ye = [];
    function ve() {
      fe || (fe = oe.subscribe({
        next(xe) {
          var Oe;
          for (const $e of ye)
            (Oe = $e.next) == null || Oe.call($e, xe);
        },
        error(xe) {
          var Oe;
          for (const $e of ye)
            (Oe = $e.error) == null || Oe.call($e, xe);
        },
        complete() {
          var xe;
          for (const Oe of ye)
            (xe = Oe.complete) == null || xe.call(Oe);
        }
      }));
    }
    function _e() {
      if (ae === 0 && fe) {
        const xe = fe;
        fe = null, xe.unsubscribe();
      }
    }
    return {
      subscribe(xe) {
        return ae++, ye.push(xe), ve(), {
          unsubscribe() {
            ae--, _e();
            const Oe = ye.findIndex(($e) => $e === xe);
            Oe > -1 && ye.splice(Oe, 1);
          }
        };
      }
    };
  };
}
class ObservableAbortError extends Error {
  constructor(oe) {
    super(oe), this.name = "ObservableAbortError", Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
}
function observableToPromise(ne) {
  let oe;
  return {
    promise: new Promise((fe, ye) => {
      let ve = !1;
      function _e() {
        ve || (ve = !0, ye(new ObservableAbortError("This operation was aborted.")), xe.unsubscribe());
      }
      const xe = ne.subscribe({
        next(Oe) {
          ve = !0, fe(Oe), _e();
        },
        error(Oe) {
          ve = !0, ye(Oe), _e();
        },
        complete() {
          ve = !0, _e();
        }
      });
      oe = _e;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: oe
  };
}
function createChain(ne) {
  return observable$2((oe) => {
    function ae(ye = 0, ve = ne.op) {
      const _e = ne.links[ye];
      if (!_e)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return _e({
        op: ve,
        next(Oe) {
          return ae(ye + 1, Oe);
        }
      });
    }
    return ae().subscribe(oe);
  });
}
function isTRPCClientError(ne) {
  return ne instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  ne.name === "TRPCClientError";
}
class TRPCClientError extends Error {
  static from(oe, ae = {}) {
    return oe instanceof Error ? isTRPCClientError(oe) ? (ae.meta && (oe.meta = {
      ...oe.meta,
      ...ae.meta
    }), oe) : new TRPCClientError(oe.message, {
      ...ae,
      cause: oe,
      result: null
    }) : new TRPCClientError(oe.error.message ?? "", {
      ...ae,
      cause: void 0,
      result: oe
    });
  }
  constructor(oe, ae) {
    var ye, ve;
    const fe = ae == null ? void 0 : ae.cause;
    super(oe, {
      cause: fe
    }), this.meta = ae == null ? void 0 : ae.meta, this.cause = fe, this.shape = (ye = ae == null ? void 0 : ae.result) == null ? void 0 : ye.error, this.data = (ve = ae == null ? void 0 : ae.result) == null ? void 0 : ve.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
}
const isFunction$2 = (ne) => typeof ne == "function";
function getFetch(ne) {
  if (ne)
    return ne;
  if (typeof window < "u" && isFunction$2(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && isFunction$2(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function getAbortController(ne) {
  return ne || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function resolveHTTPLinkOptions(ne) {
  return {
    url: ne.url,
    fetch: ne.fetch,
    AbortController: getAbortController(ne.AbortController)
  };
}
function arrayToDict(ne) {
  const oe = {};
  for (let ae = 0; ae < ne.length; ae++) {
    const fe = ne[ae];
    oe[ae] = fe;
  }
  return oe;
}
const METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(ne) {
  return "input" in ne ? ne.runtime.transformer.serialize(ne.input) : arrayToDict(ne.inputs.map((oe) => ne.runtime.transformer.serialize(oe)));
}
const getUrl = (ne) => {
  let oe = ne.url + "/" + ne.path;
  const ae = [];
  if ("inputs" in ne && ae.push("batch=1"), ne.type === "query") {
    const fe = getInput(ne);
    fe !== void 0 && ae.push(`input=${encodeURIComponent(JSON.stringify(fe))}`);
  }
  return ae.length && (oe += "?" + ae.join("&")), oe;
}, getBody = (ne) => {
  if (ne.type === "query")
    return;
  const oe = getInput(ne);
  return oe !== void 0 ? JSON.stringify(oe) : void 0;
}, jsonHttpRequester = (ne) => httpRequest({
  ...ne,
  contentTypeHeader: "application/json",
  getUrl,
  getBody
});
async function fetchHTTPResponse(ne, oe) {
  const ae = ne.getUrl(ne), fe = ne.getBody(ne), { type: ye } = ne, ve = await ne.headers();
  /* istanbul ignore if -- @preserve */
  if (ye === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const _e = {
    ...ne.contentTypeHeader ? {
      "content-type": ne.contentTypeHeader
    } : {},
    ...ne.batchModeHeader ? {
      "trpc-batch-mode": ne.batchModeHeader
    } : {},
    ...ve
  };
  return getFetch(ne.fetch)(ae, {
    method: METHOD[ye],
    signal: oe == null ? void 0 : oe.signal,
    body: fe,
    headers: _e
  });
}
function httpRequest(ne) {
  const oe = ne.AbortController ? new ne.AbortController() : null, ae = {};
  return {
    promise: new Promise((ve, _e) => {
      fetchHTTPResponse(ne, oe).then((xe) => (ae.response = xe, xe.json())).then((xe) => {
        ae.responseJSON = xe, ve({
          json: xe,
          meta: ae
        });
      }).catch((xe) => {
        _e(TRPCClientError.from(xe, {
          meta: ae
        }));
      });
    }),
    cancel: () => {
      oe == null || oe.abort();
    }
  };
}
function isObject$1(ne) {
  return !!ne && !Array.isArray(ne) && typeof ne == "object";
}
function transformResultInner(ne, oe) {
  if ("error" in ne) {
    const fe = oe.transformer.deserialize(ne.error);
    return {
      ok: !1,
      error: {
        ...ne,
        error: fe
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...ne.result,
      ...(!ne.result.type || ne.result.type === "data") && {
        type: "data",
        data: oe.transformer.deserialize(ne.result.data)
      }
    }
  };
}
class TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function transformResult(ne, oe) {
  let ae;
  try {
    ae = transformResultInner(ne, oe);
  } catch {
    throw new TransformResultError();
  }
  if (!ae.ok && (!isObject$1(ae.error.error) || typeof ae.error.error.code != "number"))
    throw new TransformResultError();
  if (ae.ok && !isObject$1(ae.result))
    throw new TransformResultError();
  return ae;
}
const throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(ne) {
  let oe = null, ae = null;
  const fe = () => {
    clearTimeout(ae), ae = null, oe = null;
  };
  function ye(xe) {
    var Me, Re;
    const Oe = [
      []
    ];
    let $e = 0;
    for (; ; ) {
      const je = xe[$e];
      if (!je)
        break;
      const Be = Oe[Oe.length - 1];
      if (je.aborted) {
        (Me = je.reject) == null || Me.call(je, new Error("Aborted")), $e++;
        continue;
      }
      if (ne.validate(Be.concat(je).map((He) => He.key))) {
        Be.push(je), $e++;
        continue;
      }
      if (Be.length === 0) {
        (Re = je.reject) == null || Re.call(je, new Error("Input is too big for a single dispatch")), $e++;
        continue;
      }
      Oe.push([]);
    }
    return Oe;
  }
  function ve() {
    const xe = ye(oe);
    fe();
    for (const Oe of xe) {
      if (!Oe.length)
        continue;
      const $e = {
        items: Oe,
        cancel: throwFatalError
      };
      for (const Be of Oe)
        Be.batch = $e;
      const Me = (Be, ze) => {
        var qe;
        const He = $e.items[Be];
        (qe = He.resolve) == null || qe.call(He, ze), He.batch = null, He.reject = null, He.resolve = null;
      }, { promise: Re, cancel: je } = ne.fetch($e.items.map((Be) => Be.key), Me);
      $e.cancel = je, Re.then((Be) => {
        var ze;
        for (let He = 0; He < Be.length; He++) {
          const qe = Be[He];
          Me(He, qe);
        }
        for (const He of $e.items)
          (ze = He.reject) == null || ze.call(He, new Error("Missing result")), He.batch = null;
      }).catch((Be) => {
        var ze;
        for (const He of $e.items)
          (ze = He.reject) == null || ze.call(He, Be), He.batch = null;
      });
    }
  }
  function _e(xe) {
    const Oe = {
      aborted: !1,
      key: xe,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    }, $e = new Promise((Re, je) => {
      Oe.reject = je, Oe.resolve = Re, oe || (oe = []), oe.push(Oe);
    });
    return ae || (ae = setTimeout(ve)), {
      promise: $e,
      cancel: () => {
        var Re;
        Oe.aborted = !0, (Re = Oe.batch) != null && Re.items.every((je) => je.aborted) && (Oe.batch.cancel(), Oe.batch = null);
      }
    };
  }
  return {
    load: _e
  };
}
function createHTTPBatchLink(ne) {
  return function(ae) {
    const fe = resolveHTTPLinkOptions(ae), ye = ae.maxURLLength ?? 1 / 0;
    return (ve) => {
      const _e = (Re) => {
        const je = (ze) => {
          if (ye === 1 / 0)
            return !0;
          const He = ze.map((pt) => pt.path).join(","), qe = ze.map((pt) => pt.input);
          return getUrl({
            ...fe,
            runtime: ve,
            type: Re,
            path: He,
            inputs: qe
          }).length <= ye;
        }, Be = ne({
          ...fe,
          runtime: ve,
          type: Re,
          opts: ae
        });
        return {
          validate: je,
          fetch: Be
        };
      }, xe = dataLoader(_e("query")), Oe = dataLoader(_e("mutation")), $e = dataLoader(_e("subscription")), Me = {
        query: xe,
        subscription: $e,
        mutation: Oe
      };
      return ({ op: Re }) => observable$2((je) => {
        const Be = Me[Re.type], { promise: ze, cancel: He } = Be.load(Re);
        let qe;
        return ze.then((Ye) => {
          qe = Ye;
          const pt = transformResult(Ye.json, ve);
          if (!pt.ok) {
            je.error(TRPCClientError.from(pt.error, {
              meta: Ye.meta
            }));
            return;
          }
          je.next({
            context: Ye.meta,
            result: pt.result
          }), je.complete();
        }).catch((Ye) => {
          je.error(TRPCClientError.from(Ye, {
            meta: qe == null ? void 0 : qe.meta
          }));
        }), () => {
          He();
        };
      });
    };
  };
}
const batchRequester = (ne) => (oe) => {
  const ae = oe.map((_e) => _e.path).join(","), fe = oe.map((_e) => _e.input), { promise: ye, cancel: ve } = jsonHttpRequester({
    ...ne,
    path: ae,
    inputs: fe,
    headers() {
      return ne.opts.headers ? typeof ne.opts.headers == "function" ? ne.opts.headers({
        opList: oe
      }) : ne.opts.headers : {};
    }
  });
  return {
    promise: ye.then((_e) => (Array.isArray(_e.json) ? _e.json : oe.map(() => _e.json)).map(($e) => ({
      meta: _e.meta,
      json: $e
    }))),
    cancel: ve
  };
}, httpBatchLink = createHTTPBatchLink(batchRequester);
class TRPCUntypedClient {
  $request({ type: oe, input: ae, path: fe, context: ye = {} }) {
    return createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: oe,
        path: fe,
        input: ae,
        context: ye
      }
    }).pipe(share$1());
  }
  requestAsPromise(oe) {
    const ae = this.$request(oe), { promise: fe, abort: ye } = observableToPromise(ae);
    return new Promise((_e, xe) => {
      var Oe;
      (Oe = oe.signal) == null || Oe.addEventListener("abort", ye), fe.then(($e) => {
        _e($e.result.data);
      }).catch(($e) => {
        xe(TRPCClientError.from($e));
      });
    });
  }
  query(oe, ae, fe) {
    return this.requestAsPromise({
      type: "query",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  mutation(oe, ae, fe) {
    return this.requestAsPromise({
      type: "mutation",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  subscription(oe, ae, fe) {
    return this.$request({
      type: "subscription",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context
    }).subscribe({
      next(ve) {
        var _e, xe, Oe;
        ve.result.type === "started" ? (_e = fe.onStarted) == null || _e.call(fe) : ve.result.type === "stopped" ? (xe = fe.onStopped) == null || xe.call(fe) : (Oe = fe.onData) == null || Oe.call(fe, ve.result.data);
      },
      error(ve) {
        var _e;
        (_e = fe.onError) == null || _e.call(fe, ve);
      },
      complete() {
        var ve;
        (ve = fe.onComplete) == null || ve.call(fe);
      }
    });
  }
  constructor(oe) {
    this.requestId = 0;
    const ae = (() => {
      const fe = oe.transformer;
      return fe ? "input" in fe ? oe.transformer : {
        input: fe,
        output: fe
      } : {
        input: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        },
        output: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (fe) => ae.input.serialize(fe),
        deserialize: (fe) => ae.output.deserialize(fe)
      },
      combinedTransformer: ae
    }, this.links = oe.links.map((fe) => fe(this.runtime));
  }
}
const clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, clientCallTypeToProcedureType = (ne) => clientCallTypeMap[ne];
function createTRPCClientProxy(ne) {
  return createFlatProxy((oe) => ne.hasOwnProperty(oe) ? ne[oe] : oe === "__untypedClient" ? ne : createRecursiveProxy(({ path: ae, args: fe }) => {
    const ye = [
      oe,
      ...ae
    ], ve = clientCallTypeToProcedureType(ye.pop()), _e = ye.join(".");
    return ne[ve](_e, ...fe);
  }));
}
function createTRPCProxyClient(ne) {
  const oe = new TRPCUntypedClient(ne);
  return createTRPCClientProxy(oe);
}
function g$8({ url: ne }) {
  return createTRPCProxyClient({ transformer: SuperJSON, links: [httpBatchLink({ url: ne })] });
}
function s$3({ url: ne }) {
  return { getLogs: async (oe) => {
    try {
      let ae = encodeURIComponent(JSON.stringify(oe)), fe = new URL(ne).origin, ye = await (await fetch(`${fe}/api/logs?input=${ae}`, { method: "GET" })).json();
      return i$8(ye) ? { ok: { ...ye, blockNumber: BigInt(ye.blockNumber) } } : { error: ye };
    } catch (ae) {
      return { error: ae };
    }
  } };
}
function i$8(ne) {
  return ne && typeof ne.blockNumber == "string" && Array.isArray(ne.logs);
}
var n$2 = ["uint8", "uint16", "uint24", "uint32", "uint40", "uint48", "uint56", "uint64", "uint72", "uint80", "uint88", "uint96", "uint104", "uint112", "uint120", "uint128", "uint136", "uint144", "uint152", "uint160", "uint168", "uint176", "uint184", "uint192", "uint200", "uint208", "uint216", "uint224", "uint232", "uint240", "uint248", "uint256", "int8", "int16", "int24", "int32", "int40", "int48", "int56", "int64", "int72", "int80", "int88", "int96", "int104", "int112", "int120", "int128", "int136", "int144", "int152", "int160", "int168", "int176", "int184", "int192", "int200", "int208", "int216", "int224", "int232", "int240", "int248", "int256", "bytes1", "bytes2", "bytes3", "bytes4", "bytes5", "bytes6", "bytes7", "bytes8", "bytes9", "bytes10", "bytes11", "bytes12", "bytes13", "bytes14", "bytes15", "bytes16", "bytes17", "bytes18", "bytes19", "bytes20", "bytes21", "bytes22", "bytes23", "bytes24", "bytes25", "bytes26", "bytes27", "bytes28", "bytes29", "bytes30", "bytes31", "bytes32", "bool", "address", "uint8[]", "uint16[]", "uint24[]", "uint32[]", "uint40[]", "uint48[]", "uint56[]", "uint64[]", "uint72[]", "uint80[]", "uint88[]", "uint96[]", "uint104[]", "uint112[]", "uint120[]", "uint128[]", "uint136[]", "uint144[]", "uint152[]", "uint160[]", "uint168[]", "uint176[]", "uint184[]", "uint192[]", "uint200[]", "uint208[]", "uint216[]", "uint224[]", "uint232[]", "uint240[]", "uint248[]", "uint256[]", "int8[]", "int16[]", "int24[]", "int32[]", "int40[]", "int48[]", "int56[]", "int64[]", "int72[]", "int80[]", "int88[]", "int96[]", "int104[]", "int112[]", "int120[]", "int128[]", "int136[]", "int144[]", "int152[]", "int160[]", "int168[]", "int176[]", "int184[]", "int192[]", "int200[]", "int208[]", "int216[]", "int224[]", "int232[]", "int240[]", "int248[]", "int256[]", "bytes1[]", "bytes2[]", "bytes3[]", "bytes4[]", "bytes5[]", "bytes6[]", "bytes7[]", "bytes8[]", "bytes9[]", "bytes10[]", "bytes11[]", "bytes12[]", "bytes13[]", "bytes14[]", "bytes15[]", "bytes16[]", "bytes17[]", "bytes18[]", "bytes19[]", "bytes20[]", "bytes21[]", "bytes22[]", "bytes23[]", "bytes24[]", "bytes25[]", "bytes26[]", "bytes27[]", "bytes28[]", "bytes29[]", "bytes30[]", "bytes31[]", "bytes32[]", "bool[]", "address[]", "bytes", "string"], a$6 = n$2.slice(0, 98), s$2 = n$2.slice(98);
function o$8(ne) {
  return n$2.includes(ne);
}
var b$8 = { uint8: 0, uint16: 0, uint24: 0, uint32: 0, uint40: 0, uint48: 0, uint56: 0n, uint64: 0n, uint72: 0n, uint80: 0n, uint88: 0n, uint96: 0n, uint104: 0n, uint112: 0n, uint120: 0n, uint128: 0n, uint136: 0n, uint144: 0n, uint152: 0n, uint160: 0n, uint168: 0n, uint176: 0n, uint184: 0n, uint192: 0n, uint200: 0n, uint208: 0n, uint216: 0n, uint224: 0n, uint232: 0n, uint240: 0n, uint248: 0n, uint256: 0n, int8: 0, int16: 0, int24: 0, int32: 0, int40: 0, int48: 0, int56: 0n, int64: 0n, int72: 0n, int80: 0n, int88: 0n, int96: 0n, int104: 0n, int112: 0n, int120: 0n, int128: 0n, int136: 0n, int144: 0n, int152: 0n, int160: 0n, int168: 0n, int176: 0n, int184: 0n, int192: 0n, int200: 0n, int208: 0n, int216: 0n, int224: 0n, int232: 0n, int240: 0n, int248: 0n, int256: 0n, bytes1: "0x00", bytes2: "0x0000", bytes3: "0x000000", bytes4: "0x00000000", bytes5: "0x0000000000", bytes6: "0x000000000000", bytes7: "0x00000000000000", bytes8: "0x0000000000000000", bytes9: "0x000000000000000000", bytes10: "0x00000000000000000000", bytes11: "0x0000000000000000000000", bytes12: "0x000000000000000000000000", bytes13: "0x00000000000000000000000000", bytes14: "0x0000000000000000000000000000", bytes15: "0x000000000000000000000000000000", bytes16: "0x00000000000000000000000000000000", bytes17: "0x0000000000000000000000000000000000", bytes18: "0x000000000000000000000000000000000000", bytes19: "0x00000000000000000000000000000000000000", bytes20: "0x0000000000000000000000000000000000000000", bytes21: "0x000000000000000000000000000000000000000000", bytes22: "0x00000000000000000000000000000000000000000000", bytes23: "0x0000000000000000000000000000000000000000000000", bytes24: "0x000000000000000000000000000000000000000000000000", bytes25: "0x00000000000000000000000000000000000000000000000000", bytes26: "0x0000000000000000000000000000000000000000000000000000", bytes27: "0x000000000000000000000000000000000000000000000000000000", bytes28: "0x00000000000000000000000000000000000000000000000000000000", bytes29: "0x0000000000000000000000000000000000000000000000000000000000", bytes30: "0x000000000000000000000000000000000000000000000000000000000000", bytes31: "0x00000000000000000000000000000000000000000000000000000000000000", bytes32: "0x0000000000000000000000000000000000000000000000000000000000000000", bool: !1, address: "0x0000000000000000000000000000000000000000" }, T$9 = { uint8: 1, uint16: 2, uint24: 3, uint32: 4, uint40: 5, uint48: 6, uint56: 7, uint64: 8, uint72: 9, uint80: 10, uint88: 11, uint96: 12, uint104: 13, uint112: 14, uint120: 15, uint128: 16, uint136: 17, uint144: 18, uint152: 19, uint160: 20, uint168: 21, uint176: 22, uint184: 23, uint192: 24, uint200: 25, uint208: 26, uint216: 27, uint224: 28, uint232: 29, uint240: 30, uint248: 31, uint256: 32, int8: 1, int16: 2, int24: 3, int32: 4, int40: 5, int48: 6, int56: 7, int64: 8, int72: 9, int80: 10, int88: 11, int96: 12, int104: 13, int112: 14, int120: 15, int128: 16, int136: 17, int144: 18, int152: 19, int160: 20, int168: 21, int176: 22, int184: 23, int192: 24, int200: 25, int208: 26, int216: 27, int224: 28, int232: 29, int240: 30, int248: 31, int256: 32, bytes1: 1, bytes2: 2, bytes3: 3, bytes4: 4, bytes5: 5, bytes6: 6, bytes7: 7, bytes8: 8, bytes9: 9, bytes10: 10, bytes11: 11, bytes12: 12, bytes13: 13, bytes14: 14, bytes15: 15, bytes16: 16, bytes17: 17, bytes18: 18, bytes19: 19, bytes20: 20, bytes21: 21, bytes22: 22, bytes23: 23, bytes24: 24, bytes25: 25, bytes26: 26, bytes27: 27, bytes28: 28, bytes29: 29, bytes30: 30, bytes31: 31, bytes32: 32, bool: 1, address: 20 };
function e$5(ne) {
  return a$6.includes(ne);
}
var y$8 = /\[\]$/, i$7 = /\[\d+\]$/;
function c$6(ne) {
  return typeof ne == "string" && y$8.test(ne) && e$5(ne.replace(y$8, ""));
}
function A$6(ne) {
  return typeof ne == "string" && i$7.test(ne) && e$5(ne.replace(i$7, ""));
}
function m$7(ne) {
  return ne.replace(y$8, "");
}
function f$6(ne) {
  return ne.replace(i$7, "[]");
}
var r$8 = { "uint8[]": [], "uint16[]": [], "uint24[]": [], "uint32[]": [], "uint40[]": [], "uint48[]": [], "uint56[]": [], "uint64[]": [], "uint72[]": [], "uint80[]": [], "uint88[]": [], "uint96[]": [], "uint104[]": [], "uint112[]": [], "uint120[]": [], "uint128[]": [], "uint136[]": [], "uint144[]": [], "uint152[]": [], "uint160[]": [], "uint168[]": [], "uint176[]": [], "uint184[]": [], "uint192[]": [], "uint200[]": [], "uint208[]": [], "uint216[]": [], "uint224[]": [], "uint232[]": [], "uint240[]": [], "uint248[]": [], "uint256[]": [], "int8[]": [], "int16[]": [], "int24[]": [], "int32[]": [], "int40[]": [], "int48[]": [], "int56[]": [], "int64[]": [], "int72[]": [], "int80[]": [], "int88[]": [], "int96[]": [], "int104[]": [], "int112[]": [], "int120[]": [], "int128[]": [], "int136[]": [], "int144[]": [], "int152[]": [], "int160[]": [], "int168[]": [], "int176[]": [], "int184[]": [], "int192[]": [], "int200[]": [], "int208[]": [], "int216[]": [], "int224[]": [], "int232[]": [], "int240[]": [], "int248[]": [], "int256[]": [], "bytes1[]": [], "bytes2[]": [], "bytes3[]": [], "bytes4[]": [], "bytes5[]": [], "bytes6[]": [], "bytes7[]": [], "bytes8[]": [], "bytes9[]": [], "bytes10[]": [], "bytes11[]": [], "bytes12[]": [], "bytes13[]": [], "bytes14[]": [], "bytes15[]": [], "bytes16[]": [], "bytes17[]": [], "bytes18[]": [], "bytes19[]": [], "bytes20[]": [], "bytes21[]": [], "bytes22[]": [], "bytes23[]": [], "bytes24[]": [], "bytes25[]": [], "bytes26[]": [], "bytes27[]": [], "bytes28[]": [], "bytes29[]": [], "bytes30[]": [], "bytes31[]": [], "bytes32[]": [], "bool[]": [], "address[]": [], bytes: "0x", string: "" };
function v$5(ne) {
  return s$2.includes(ne);
}
function u$4(ne, oe) {
  throw new Error(oe ?? `Unexpected value: ${ne}`);
}
function a$5(...ne) {
  return ne.reduce((oe, ae) => ae > oe ? ae : oe);
}
function l$6(...ne) {
  return ne.reduce((oe, ae) => ae < oe ? ae : oe);
}
function s$1(ne, oe) {
  return ne < oe ? -1 : ne > oe ? 1 : 0;
}
function* m$6(ne, oe) {
  for (let ae = 0; ae < ne.length; ae += oe)
    yield ne.slice(ae, ae + oe);
}
function y$7(ne, oe) {
  let ae = /* @__PURE__ */ new Map();
  for (let fe of ne) {
    let ye = oe(fe);
    ae.has(ye) || ae.set(ye, []), ae.get(ye).push(fe);
  }
  return ae;
}
function b$7(ne) {
  return ne !== void 0;
}
function P$8(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, oe(fe, ae)]));
}
function B$3(ne) {
  return new Promise((oe) => setTimeout(() => oe(), ne));
}
function N$7() {
  return new Promise((ne) => {
    typeof requestIdleCallback < "u" ? requestIdleCallback(() => ne()) : setTimeout(() => ne(), 1);
  });
}
var r$7 = class extends Error {
  constructor() {
    super(...arguments);
    Na(this, "name", "MUDError");
  }
}, browser$1 = { exports: {} }, ms$1, hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var ne = 1e3, oe = ne * 60, ae = oe * 60, fe = ae * 24, ye = fe * 7, ve = fe * 365.25;
  ms$1 = function(Me, Re) {
    Re = Re || {};
    var je = typeof Me;
    if (je === "string" && Me.length > 0)
      return _e(Me);
    if (je === "number" && isFinite(Me))
      return Re.long ? Oe(Me) : xe(Me);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(Me)
    );
  };
  function _e(Me) {
    if (Me = String(Me), !(Me.length > 100)) {
      var Re = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        Me
      );
      if (Re) {
        var je = parseFloat(Re[1]), Be = (Re[2] || "ms").toLowerCase();
        switch (Be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return je * ve;
          case "weeks":
          case "week":
          case "w":
            return je * ye;
          case "days":
          case "day":
          case "d":
            return je * fe;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return je * ae;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return je * oe;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return je * ne;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return je;
          default:
            return;
        }
      }
    }
  }
  function xe(Me) {
    var Re = Math.abs(Me);
    return Re >= fe ? Math.round(Me / fe) + "d" : Re >= ae ? Math.round(Me / ae) + "h" : Re >= oe ? Math.round(Me / oe) + "m" : Re >= ne ? Math.round(Me / ne) + "s" : Me + "ms";
  }
  function Oe(Me) {
    var Re = Math.abs(Me);
    return Re >= fe ? $e(Me, Re, fe, "day") : Re >= ae ? $e(Me, Re, ae, "hour") : Re >= oe ? $e(Me, Re, oe, "minute") : Re >= ne ? $e(Me, Re, ne, "second") : Me + " ms";
  }
  function $e(Me, Re, je, Be) {
    var ze = Re >= je * 1.5;
    return Math.round(Me / je) + " " + Be + (ze ? "s" : "");
  }
  return ms$1;
}
function setup$2(ne) {
  ae.debug = ae, ae.default = ae, ae.coerce = Oe, ae.disable = ve, ae.enable = ye, ae.enabled = _e, ae.humanize = requireMs$1(), ae.destroy = $e, Object.keys(ne).forEach((Me) => {
    ae[Me] = ne[Me];
  }), ae.names = [], ae.skips = [], ae.formatters = {};
  function oe(Me) {
    let Re = 0;
    for (let je = 0; je < Me.length; je++)
      Re = (Re << 5) - Re + Me.charCodeAt(je), Re |= 0;
    return ae.colors[Math.abs(Re) % ae.colors.length];
  }
  ae.selectColor = oe;
  function ae(Me) {
    let Re, je = null, Be, ze;
    function He(...qe) {
      if (!He.enabled)
        return;
      const Ye = He, pt = Number(/* @__PURE__ */ new Date()), dt = pt - (Re || pt);
      Ye.diff = dt, Ye.prev = Re, Ye.curr = pt, Re = pt, qe[0] = ae.coerce(qe[0]), typeof qe[0] != "string" && qe.unshift("%O");
      let yt = 0;
      qe[0] = qe[0].replace(/%([a-zA-Z%])/g, (It, Vt) => {
        if (It === "%%")
          return "%";
        yt++;
        const Ut = ae.formatters[Vt];
        if (typeof Ut == "function") {
          const Zt = qe[yt];
          It = Ut.call(Ye, Zt), qe.splice(yt, 1), yt--;
        }
        return It;
      }), ae.formatArgs.call(Ye, qe), (Ye.log || ae.log).apply(Ye, qe);
    }
    return He.namespace = Me, He.useColors = ae.useColors(), He.color = ae.selectColor(Me), He.extend = fe, He.destroy = ae.destroy, Object.defineProperty(He, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => je !== null ? je : (Be !== ae.namespaces && (Be = ae.namespaces, ze = ae.enabled(Me)), ze),
      set: (qe) => {
        je = qe;
      }
    }), typeof ae.init == "function" && ae.init(He), He;
  }
  function fe(Me, Re) {
    const je = ae(this.namespace + (typeof Re > "u" ? ":" : Re) + Me);
    return je.log = this.log, je;
  }
  function ye(Me) {
    ae.save(Me), ae.namespaces = Me, ae.names = [], ae.skips = [];
    let Re;
    const je = (typeof Me == "string" ? Me : "").split(/[\s,]+/), Be = je.length;
    for (Re = 0; Re < Be; Re++)
      je[Re] && (Me = je[Re].replace(/\*/g, ".*?"), Me[0] === "-" ? ae.skips.push(new RegExp("^" + Me.slice(1) + "$")) : ae.names.push(new RegExp("^" + Me + "$")));
  }
  function ve() {
    const Me = [
      ...ae.names.map(xe),
      ...ae.skips.map(xe).map((Re) => "-" + Re)
    ].join(",");
    return ae.enable(""), Me;
  }
  function _e(Me) {
    if (Me[Me.length - 1] === "*")
      return !0;
    let Re, je;
    for (Re = 0, je = ae.skips.length; Re < je; Re++)
      if (ae.skips[Re].test(Me))
        return !1;
    for (Re = 0, je = ae.names.length; Re < je; Re++)
      if (ae.names[Re].test(Me))
        return !0;
    return !1;
  }
  function xe(Me) {
    return Me.toString().substring(2, Me.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function Oe(Me) {
    return Me instanceof Error ? Me.stack || Me.message : Me;
  }
  function $e() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ae.enable(ae.load()), ae;
}
var common$1 = setup$2;
(function(ne, oe) {
  oe.formatArgs = fe, oe.save = ye, oe.load = ve, oe.useColors = ae, oe.storage = _e(), oe.destroy = (() => {
    let Oe = !1;
    return () => {
      Oe || (Oe = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), oe.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ae() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let Oe;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (Oe = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Oe[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fe(Oe) {
    if (Oe[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Oe[0] + (this.useColors ? "%c " : " ") + "+" + ne.exports.humanize(this.diff), !this.useColors)
      return;
    const $e = "color: " + this.color;
    Oe.splice(1, 0, $e, "color: inherit");
    let Me = 0, Re = 0;
    Oe[0].replace(/%[a-zA-Z%]/g, (je) => {
      je !== "%%" && (Me++, je === "%c" && (Re = Me));
    }), Oe.splice(Re, 0, $e);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ye(Oe) {
    try {
      Oe ? oe.storage.setItem("debug", Oe) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function ve() {
    let Oe;
    try {
      Oe = oe.storage.getItem("debug");
    } catch {
    }
    return !Oe && typeof process < "u" && "env" in process && (Oe = process.env.DEBUG), Oe;
  }
  function _e() {
    try {
      return localStorage;
    } catch {
    }
  }
  ne.exports = common$1(oe);
  const { formatters: xe } = ne.exports;
  xe.j = function(Oe) {
    try {
      return JSON.stringify(Oe);
    } catch ($e) {
      return "[UnexpectedJSONParseError]: " + $e.message;
    }
  };
})(browser$1, browser$1.exports);
var browserExports$1 = browser$1.exports;
const z$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var e$4 = z$1("mud:common"), r$6 = z$1("mud:common");
e$4.log = console.debug.bind(console);
r$6.log = console.error.bind(console);
var eventemitter3$1 = { exports: {} };
(function(ne) {
  var oe = Object.prototype.hasOwnProperty, ae = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (ae = !1));
  function ye(Oe, $e, Me) {
    this.fn = Oe, this.context = $e, this.once = Me || !1;
  }
  function ve(Oe, $e, Me, Re, je) {
    if (typeof Me != "function")
      throw new TypeError("The listener must be a function");
    var Be = new ye(Me, Re || Oe, je), ze = ae ? ae + $e : $e;
    return Oe._events[ze] ? Oe._events[ze].fn ? Oe._events[ze] = [Oe._events[ze], Be] : Oe._events[ze].push(Be) : (Oe._events[ze] = Be, Oe._eventsCount++), Oe;
  }
  function _e(Oe, $e) {
    --Oe._eventsCount === 0 ? Oe._events = new fe() : delete Oe._events[$e];
  }
  function xe() {
    this._events = new fe(), this._eventsCount = 0;
  }
  xe.prototype.eventNames = function() {
    var $e = [], Me, Re;
    if (this._eventsCount === 0)
      return $e;
    for (Re in Me = this._events)
      oe.call(Me, Re) && $e.push(ae ? Re.slice(1) : Re);
    return Object.getOwnPropertySymbols ? $e.concat(Object.getOwnPropertySymbols(Me)) : $e;
  }, xe.prototype.listeners = function($e) {
    var Me = ae ? ae + $e : $e, Re = this._events[Me];
    if (!Re)
      return [];
    if (Re.fn)
      return [Re.fn];
    for (var je = 0, Be = Re.length, ze = new Array(Be); je < Be; je++)
      ze[je] = Re[je].fn;
    return ze;
  }, xe.prototype.listenerCount = function($e) {
    var Me = ae ? ae + $e : $e, Re = this._events[Me];
    return Re ? Re.fn ? 1 : Re.length : 0;
  }, xe.prototype.emit = function($e, Me, Re, je, Be, ze) {
    var He = ae ? ae + $e : $e;
    if (!this._events[He])
      return !1;
    var qe = this._events[He], Ye = arguments.length, pt, dt;
    if (qe.fn) {
      switch (qe.once && this.removeListener($e, qe.fn, void 0, !0), Ye) {
        case 1:
          return qe.fn.call(qe.context), !0;
        case 2:
          return qe.fn.call(qe.context, Me), !0;
        case 3:
          return qe.fn.call(qe.context, Me, Re), !0;
        case 4:
          return qe.fn.call(qe.context, Me, Re, je), !0;
        case 5:
          return qe.fn.call(qe.context, Me, Re, je, Be), !0;
        case 6:
          return qe.fn.call(qe.context, Me, Re, je, Be, ze), !0;
      }
      for (dt = 1, pt = new Array(Ye - 1); dt < Ye; dt++)
        pt[dt - 1] = arguments[dt];
      qe.fn.apply(qe.context, pt);
    } else {
      var yt = qe.length, Ct;
      for (dt = 0; dt < yt; dt++)
        switch (qe[dt].once && this.removeListener($e, qe[dt].fn, void 0, !0), Ye) {
          case 1:
            qe[dt].fn.call(qe[dt].context);
            break;
          case 2:
            qe[dt].fn.call(qe[dt].context, Me);
            break;
          case 3:
            qe[dt].fn.call(qe[dt].context, Me, Re);
            break;
          case 4:
            qe[dt].fn.call(qe[dt].context, Me, Re, je);
            break;
          default:
            if (!pt)
              for (Ct = 1, pt = new Array(Ye - 1); Ct < Ye; Ct++)
                pt[Ct - 1] = arguments[Ct];
            qe[dt].fn.apply(qe[dt].context, pt);
        }
    }
    return !0;
  }, xe.prototype.on = function($e, Me, Re) {
    return ve(this, $e, Me, Re, !1);
  }, xe.prototype.once = function($e, Me, Re) {
    return ve(this, $e, Me, Re, !0);
  }, xe.prototype.removeListener = function($e, Me, Re, je) {
    var Be = ae ? ae + $e : $e;
    if (!this._events[Be])
      return this;
    if (!Me)
      return _e(this, Be), this;
    var ze = this._events[Be];
    if (ze.fn)
      ze.fn === Me && (!je || ze.once) && (!Re || ze.context === Re) && _e(this, Be);
    else {
      for (var He = 0, qe = [], Ye = ze.length; He < Ye; He++)
        (ze[He].fn !== Me || je && !ze[He].once || Re && ze[He].context !== Re) && qe.push(ze[He]);
      qe.length ? this._events[Be] = qe.length === 1 ? qe[0] : qe : _e(this, Be);
    }
    return this;
  }, xe.prototype.removeAllListeners = function($e) {
    var Me;
    return $e ? (Me = ae ? ae + $e : $e, this._events[Me] && _e(this, Me)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, xe.prototype.off = xe.prototype.removeListener, xe.prototype.addListener = xe.prototype.on, xe.prefixed = ae, xe.EventEmitter = xe, ne.exports = xe;
})(eventemitter3$1);
var eventemitter3Exports = eventemitter3$1.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError extends Error {
  constructor(oe) {
    super(oe), this.name = "TimeoutError";
  }
}
let AbortError$2 = class extends Error {
  constructor(oe) {
    super(), this.name = "AbortError", this.message = oe;
  }
};
const getDOMException$1 = (ne) => globalThis.DOMException === void 0 ? new AbortError$2(ne) : new DOMException(ne), getAbortedReason = (ne) => {
  const oe = ne.reason === void 0 ? getDOMException$1("This operation was aborted.") : ne.reason;
  return oe instanceof Error ? oe : getDOMException$1(oe);
};
function pTimeout(ne, oe, ae, fe) {
  let ye;
  const ve = new Promise((_e, xe) => {
    if (typeof oe != "number" || Math.sign(oe) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${oe}\``);
    if (oe === Number.POSITIVE_INFINITY) {
      _e(ne);
      return;
    }
    if (fe = {
      customTimers: { setTimeout, clearTimeout },
      ...fe
    }, fe.signal) {
      const { signal: Oe } = fe;
      Oe.aborted && xe(getAbortedReason(Oe)), Oe.addEventListener("abort", () => {
        xe(getAbortedReason(Oe));
      });
    }
    ye = fe.customTimers.setTimeout.call(void 0, () => {
      if (typeof ae == "function") {
        try {
          _e(ae());
        } catch (Me) {
          xe(Me);
        }
        return;
      }
      const Oe = typeof ae == "string" ? ae : `Promise timed out after ${oe} milliseconds`, $e = ae instanceof Error ? ae : new TimeoutError(Oe);
      typeof ne.cancel == "function" && ne.cancel(), xe($e);
    }, oe), (async () => {
      try {
        _e(await ne);
      } catch (Oe) {
        xe(Oe);
      } finally {
        fe.customTimers.clearTimeout.call(void 0, ye);
      }
    })();
  });
  return ve.clear = () => {
    clearTimeout(ye), ye = void 0;
  }, ve;
}
function lowerBound(ne, oe, ae) {
  let fe = 0, ye = ne.length;
  for (; ye > 0; ) {
    const ve = Math.trunc(ye / 2);
    let _e = fe + ve;
    ae(ne[_e], oe) <= 0 ? (fe = ++_e, ye -= ve + 1) : ye = ve;
  }
  return fe;
}
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(oe, ae) {
    ae = {
      priority: 0,
      ...ae
    };
    const fe = {
      priority: ae.priority,
      run: oe
    };
    if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= ae.priority) {
      __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(fe);
      return;
    }
    const ye = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), fe, (ve, _e) => _e.priority - ve.priority);
    __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(ye, 0, fe);
  }
  dequeue() {
    const oe = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
    return oe == null ? void 0 : oe.run;
  }
  filter(oe) {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((ae) => ae.priority === oe.priority).map((ae) => ae.run);
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}, __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;
let AbortError$1 = class extends Error {
};
class PQueue extends EventEmitter {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(oe) {
    var ae, fe, ye, ve;
    if (super(), _PQueue_instances.add(this), _PQueue_carryoverConcurrencyCount.set(this, void 0), _PQueue_isIntervalIgnored.set(this, void 0), _PQueue_intervalCount.set(this, 0), _PQueue_intervalCap.set(this, void 0), _PQueue_interval.set(this, void 0), _PQueue_intervalEnd.set(this, 0), _PQueue_intervalId.set(this, void 0), _PQueue_timeoutId.set(this, void 0), _PQueue_queue.set(this, void 0), _PQueue_queueClass.set(this, void 0), _PQueue_pending.set(this, 0), _PQueue_concurrency.set(this, void 0), _PQueue_isPaused.set(this, void 0), _PQueue_throwOnTimeout.set(this, void 0), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), oe = {
      carryoverConcurrencyCount: !1,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: !0,
      queueClass: PriorityQueue,
      ...oe
    }, !(typeof oe.intervalCap == "number" && oe.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(fe = (ae = oe.intervalCap) === null || ae === void 0 ? void 0 : ae.toString()) !== null && fe !== void 0 ? fe : ""}\` (${typeof oe.intervalCap})`);
    if (oe.interval === void 0 || !(Number.isFinite(oe.interval) && oe.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(ve = (ye = oe.interval) === null || ye === void 0 ? void 0 : ye.toString()) !== null && ve !== void 0 ? ve : ""}\` (${typeof oe.interval})`);
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, oe.carryoverConcurrencyCount, "f"), __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, oe.intervalCap === Number.POSITIVE_INFINITY || oe.interval === 0, "f"), __classPrivateFieldSet(this, _PQueue_intervalCap, oe.intervalCap, "f"), __classPrivateFieldSet(this, _PQueue_interval, oe.interval, "f"), __classPrivateFieldSet(this, _PQueue_queue, new oe.queueClass(), "f"), __classPrivateFieldSet(this, _PQueue_queueClass, oe.queueClass, "f"), this.concurrency = oe.concurrency, this.timeout = oe.timeout, __classPrivateFieldSet(this, _PQueue_throwOnTimeout, oe.throwOnTimeout === !0, "f"), __classPrivateFieldSet(this, _PQueue_isPaused, oe.autoStart === !1, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet(this, _PQueue_concurrency, "f");
  }
  set concurrency(oe) {
    if (!(typeof oe == "number" && oe >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${oe}\` (${typeof oe})`);
    __classPrivateFieldSet(this, _PQueue_concurrency, oe, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(oe, ae = {}) {
    return ae = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f"),
      ...ae
    }, new Promise((fe, ye) => {
      __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(async () => {
        var ve, _e, xe;
        __classPrivateFieldSet(this, _PQueue_pending, (_e = __classPrivateFieldGet(this, _PQueue_pending, "f"), _e++, _e), "f"), __classPrivateFieldSet(this, _PQueue_intervalCount, (xe = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"), xe++, xe), "f");
        try {
          if (!((ve = ae.signal) === null || ve === void 0) && ve.aborted)
            throw new AbortError$1("The task was aborted.");
          let Oe = oe({ signal: ae.signal });
          ae.timeout && (Oe = pTimeout(Promise.resolve(Oe), ae.timeout)), ae.signal && (Oe = Promise.race([Oe, __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, ae.signal)]));
          const $e = await Oe;
          fe($e), this.emit("completed", $e);
        } catch (Oe) {
          if (Oe instanceof TimeoutError && !ae.throwOnTimeout) {
            fe();
            return;
          }
          ye(Oe), this.emit("error", Oe);
        } finally {
          __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, ae), this.emit("add"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(oe, ae) {
    return Promise.all(oe.map(async (fe) => this.add(fe, ae)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet(this, _PQueue_isPaused, !1, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, !0, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(oe) {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(oe) {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(oe).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_pending, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f");
}, _PQueue_next = function ne() {
  var oe;
  __classPrivateFieldSet(this, _PQueue_pending, (oe = __classPrivateFieldGet(this, _PQueue_pending, "f"), oe--, oe), "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("next");
}, _PQueue_onResumeInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function ne() {
  const oe = Date.now();
  if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
    const ae = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - oe;
    if (ae < 0)
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f");
    else
      return __classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
      }, ae), "f"), !0;
  }
  return !1;
}, _PQueue_tryToStartAnother = function ne() {
  if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0)
    return __classPrivateFieldGet(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f"), this.emit("empty"), __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && this.emit("idle"), !1;
  if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
    const oe = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const ae = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
      return ae ? (this.emit("active"), ae(), oe && __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), !0) : !1;
    }
  }
  return !1;
}, _PQueue_initializeIntervalIfNeeded = function ne() {
  __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet(this, _PQueue_interval, "f")), "f"), __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f"));
}, _PQueue_onInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f")), __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function ne() {
  for (; __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
    ;
}, _PQueue_throwOnAbort = async function ne(oe) {
  return new Promise((ae, fe) => {
    oe.addEventListener("abort", () => {
      fe(new AbortError$1("The task was aborted."));
    }, { once: !0 });
  });
}, _PQueue_onEvent = async function ne(oe, ae) {
  return new Promise((fe) => {
    const ye = () => {
      ae && !ae() || (this.off(oe, ye), fe());
    };
    this.on(oe, ye);
  });
};
var retry$3 = {};
function RetryOperation$1(ne, oe) {
  typeof oe == "boolean" && (oe = { forever: oe }), this._originalTimeouts = JSON.parse(JSON.stringify(ne)), this._timeouts = ne, this._options = oe || {}, this._maxRetryTime = oe && oe.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation$1 = RetryOperation$1;
RetryOperation$1.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation$1.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation$1.prototype.retry = function(ne) {
  if (this._timeout && clearTimeout(this._timeout), !ne)
    return !1;
  var oe = (/* @__PURE__ */ new Date()).getTime();
  if (ne && oe - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ne), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ne);
  var ae = this._timeouts.shift();
  if (ae === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), ae = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, ae), this._options.unref && this._timer.unref(), !0;
};
RetryOperation$1.prototype.attempt = function(ne, oe) {
  this._fn = ne, oe && (oe.timeout && (this._operationTimeout = oe.timeout), oe.cb && (this._operationTimeoutCb = oe.cb));
  var ae = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    ae._operationTimeoutCb();
  }, ae._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation$1.prototype.try = function(ne) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ne);
};
RetryOperation$1.prototype.start = function(ne) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ne);
};
RetryOperation$1.prototype.start = RetryOperation$1.prototype.try;
RetryOperation$1.prototype.errors = function() {
  return this._errors;
};
RetryOperation$1.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation$1.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ne = {}, oe = null, ae = 0, fe = 0; fe < this._errors.length; fe++) {
    var ye = this._errors[fe], ve = ye.message, _e = (ne[ve] || 0) + 1;
    ne[ve] = _e, _e >= ae && (oe = ye, ae = _e);
  }
  return oe;
};
(function(ne) {
  var oe = retry_operation$1;
  ne.operation = function(ae) {
    var fe = ne.timeouts(ae);
    return new oe(fe, {
      forever: ae && (ae.forever || ae.retries === 1 / 0),
      unref: ae && ae.unref,
      maxRetryTime: ae && ae.maxRetryTime
    });
  }, ne.timeouts = function(ae) {
    if (ae instanceof Array)
      return [].concat(ae);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ye in ae)
      fe[ye] = ae[ye];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var ve = [], _e = 0; _e < fe.retries; _e++)
      ve.push(this.createTimeout(_e, fe));
    return ae && ae.forever && !ve.length && ve.push(this.createTimeout(_e, fe)), ve.sort(function(xe, Oe) {
      return xe - Oe;
    }), ve;
  }, ne.createTimeout = function(ae, fe) {
    var ye = fe.randomize ? Math.random() + 1 : 1, ve = Math.round(ye * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, ae));
    return ve = Math.min(ve, fe.maxTimeout), ve;
  }, ne.wrap = function(ae, fe, ye) {
    if (fe instanceof Array && (ye = fe, fe = null), !ye) {
      ye = [];
      for (var ve in ae)
        typeof ae[ve] == "function" && ye.push(ve);
    }
    for (var _e = 0; _e < ye.length; _e++) {
      var xe = ye[_e], Oe = ae[xe];
      ae[xe] = (function(Me) {
        var Re = ne.operation(fe), je = Array.prototype.slice.call(arguments, 1), Be = je.pop();
        je.push(function(ze) {
          Re.retry(ze) || (ze && (arguments[0] = Re.mainError()), Be.apply(this, arguments));
        }), Re.attempt(function() {
          Me.apply(ae, je);
        });
      }).bind(ae, Oe), ae[xe].options = fe;
    }
  };
})(retry$3);
var retry$1 = retry$3;
const retry$2 = /* @__PURE__ */ getDefaultExportFromCjs(retry$1), networkErrorMsgs = /* @__PURE__ */ new Set([
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed",
  // `cross-fetch`
  "fetch failed"
  // Undici (Node.js)
]);
class AbortError extends Error {
  constructor(oe) {
    super(), oe instanceof Error ? (this.originalError = oe, { message: oe } = oe) : (this.originalError = new Error(oe), this.originalError.stack = this.stack), this.name = "AbortError", this.message = oe;
  }
}
const decorateErrorWithCounts = (ne, oe, ae) => {
  const fe = ae.retries - (oe - 1);
  return ne.attemptNumber = oe, ne.retriesLeft = fe, ne;
}, isNetworkError = (ne) => networkErrorMsgs.has(ne), getDOMException = (ne) => globalThis.DOMException === void 0 ? new Error(ne) : new DOMException(ne);
async function pRetry(ne, oe) {
  return new Promise((ae, fe) => {
    oe = {
      onFailedAttempt() {
      },
      retries: 10,
      ...oe
    };
    const ye = retry$2.operation(oe);
    ye.attempt(async (ve) => {
      try {
        ae(await ne(ve));
      } catch (_e) {
        if (!(_e instanceof Error)) {
          fe(new TypeError(`Non-error was thrown: "${_e}". You should only throw errors.`));
          return;
        }
        if (_e instanceof AbortError)
          ye.stop(), fe(_e.originalError);
        else if (_e instanceof TypeError && !isNetworkError(_e.message))
          ye.stop(), fe(_e);
        else {
          decorateErrorWithCounts(_e, ve, oe);
          try {
            await oe.onFailedAttempt(_e);
          } catch (xe) {
            fe(xe);
            return;
          }
          ye.retry(_e) || fe(ye.mainError());
        }
      }
    }), oe.signal && !oe.signal.aborted && oe.signal.addEventListener("abort", () => {
      ye.stop();
      const ve = oe.signal.reason === void 0 ? getDOMException("The operation was aborted.") : oe.signal.reason;
      fe(ve instanceof Error ? ve : getDOMException(ve));
    }, {
      once: !0
    });
  });
}
function toAccount(ne) {
  if (typeof ne == "string") {
    if (!isAddress(ne, { strict: !1 }))
      throw new InvalidAddressError({ address: ne });
    return {
      address: ne,
      type: "json-rpc"
    };
  }
  if (!isAddress(ne.address, { strict: !1 }))
    throw new InvalidAddressError({ address: ne.address });
  return {
    address: ne.address,
    signMessage: ne.signMessage,
    signTransaction: ne.signTransaction,
    signTypedData: ne.signTypedData,
    source: "custom",
    type: "local"
  };
}
async function sign({ hash: ne, privateKey: oe }) {
  const { r: ae, s: fe, recovery: ye } = secp256k1.sign(ne.slice(2), oe.slice(2));
  return {
    r: toHex$1(ae),
    s: toHex$1(fe),
    v: ye ? 28n : 27n,
    yParity: ye
  };
}
async function signMessage({ message: ne, privateKey: oe }) {
  const ae = await sign({ hash: hashMessage(ne), privateKey: oe });
  return signatureToHex(ae);
}
async function signTransaction(ne) {
  const { privateKey: oe, transaction: ae, serializer: fe = serializeTransaction$1 } = ne, ye = (() => ae.type === "eip4844" ? {
    ...ae,
    sidecars: !1
  } : ae)(), ve = await sign({
    hash: keccak256(fe(ye)),
    privateKey: oe
  });
  return fe(ae, ve);
}
async function signTypedData(ne) {
  const { privateKey: oe, ...ae } = ne, fe = await sign({
    hash: hashTypedData(ae),
    privateKey: oe
  });
  return signatureToHex(fe);
}
function privateKeyToAccount(ne) {
  const oe = toHex$1(secp256k1.getPublicKey(ne.slice(2), !1)), ae = publicKeyToAddress(oe);
  return {
    ...toAccount({
      address: ae,
      async signMessage({ message: ye }) {
        return signMessage({ message: ye, privateKey: ne });
      },
      async signTransaction(ye, { serializer: ve } = {}) {
        return signTransaction({ privateKey: ne, transaction: ye, serializer: ve });
      },
      async signTypedData(ye) {
        return signTypedData({ ...ye, privateKey: ne });
      }
    }),
    publicKey: oe,
    source: "privateKey"
  };
}
async function h$3({ client: ne, address: oe, blockTag: ae }) {
  var fe;
  return `mud:createNonceManager:${((fe = ne.chain) == null ? void 0 : fe.id) ?? await getChainId(ne)}:${getAddress(oe)}:${ae}`;
}
var R = e$4.extend("createNonceManager");
function P$7({ client: ne, address: oe, blockTag: ae = "pending", broadcastChannelName: fe, queueConcurrency: ye = 1 }) {
  let ve = { current: -1 }, _e = null;
  typeof BroadcastChannel < "u" && (fe ? Promise.resolve(fe) : h$3({ client: ne, address: oe, blockTag: ae })).then((Be) => {
    _e = new BroadcastChannel(Be), _e.addEventListener("message", (ze) => {
      let He = JSON.parse(ze.data);
      R("got nonce from broadcast channel", He), ve.current = He;
    });
  });
  function xe() {
    return ve.current >= 0;
  }
  function Oe() {
    if (!xe())
      throw new Error("call resetNonce before using getNonce");
    return ve.current;
  }
  function $e() {
    if (!xe())
      throw new Error("call resetNonce before using nextNonce");
    let Be = ve.current++;
    return _e == null || _e.postMessage(JSON.stringify(ve.current)), Be;
  }
  async function Me() {
    let Be = await getTransactionCount(ne, { address: oe, blockTag: ae });
    ve.current = Be, _e == null || _e.postMessage(JSON.stringify(ve.current)), R("reset nonce to", ve.current);
  }
  function Re(Be) {
    return Be instanceof BaseError$1 && Be.walk((ze) => ze instanceof NonceTooLowError || ze instanceof NonceTooHighError) != null;
  }
  let je = new PQueue({ concurrency: ye });
  return { hasNonce: xe, getNonce: Oe, nextNonce: $e, resetNonce: Me, shouldResetNonce: Re, mempoolQueue: je };
}
var T$8 = /* @__PURE__ */ new Map();
async function C$5({ client: ne, address: oe, blockTag: ae = "pending", ...fe }) {
  let ye = await h$3({ client: ne, address: oe, blockTag: ae }), ve = T$8.get(ye);
  if (ve)
    return ve;
  let _e = P$7({ client: ne, address: oe, blockTag: ae, ...fe });
  return T$8.set(ye, _e), _e;
}
async function F$2({ client: ne, args: oe, refreshInterval: ae }) {
  let fe = { fees: {}, lastUpdatedTimestamp: 0 };
  async function ye() {
    let ve = await estimateFeesPerGas(ne, oe);
    fe.fees = ve, fe.lastUpdatedTimestamp = Date.now();
  }
  return setInterval(ye, ae), await ye(), fe;
}
var M$4 = /* @__PURE__ */ new Map();
async function N$6(ne) {
  var ye, ve, _e;
  let oe = ((ve = (ye = ne.args) == null ? void 0 : ye.chain) == null ? void 0 : ve.id) ?? ((_e = ne.client.chain) == null ? void 0 : _e.id) ?? await getChainId(ne.client), ae = M$4.get(oe);
  if (ae)
    return ae;
  let fe = await F$2(ne);
  return M$4.set(oe, fe), fe;
}
var y$6 = e$4.extend("writeContract");
async function Je(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), ve = ne.chain, _e = { chain: ve, ...ve != null && ve.fees ? { type: "eip1559" } : {} }, xe = await C$5({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), Oe = await N$6({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: ve } });
  async function $e() {
    if (oe.gas)
      return y$6("gas provided, skipping preparation", oe.functionName, oe.address), oe;
    let { abi: Me, address: Re, args: je, dataSuffix: Be, functionName: ze } = oe, He = encodeFunctionData({ abi: Me, args: je, functionName: ze }), { nonce: qe, maxFeePerGas: Ye, maxPriorityFeePerGas: pt, ...dt } = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({ maxFeePerGas: 0n, maxPriorityFeePerGas: 0n, nonce: xe.getNonce(), ..._e, ...oe, blockTag: "pending", account: ye, data: `${He}${Be ? Be.replace("0x", "") : ""}`, to: Re });
    return dt;
  }
  return xe.mempoolQueue.add(() => pRetry(async () => {
    xe.hasNonce() || await xe.resetNonce();
    let Me = await $e(), Re = xe.nextNonce(), je = { ...Me, nonce: Re, ...Oe.fees };
    return y$6("calling", je.functionName, "with nonce", Re, "at", je.address), await writeContract(ne, je);
  }, { retries: 3, onFailedAttempt: async (Me) => {
    if (xe.shouldResetNonce(Me)) {
      y$6("got nonce error, retrying", Me.message), await xe.resetNonce();
      return;
    }
    throw Me;
  } }), { throwOnTimeout: !0 });
}
var b$6 = e$4.extend("sendTransaction");
async function Ve(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), ve = ne.chain, _e = await C$5({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), xe = await N$6({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: ve } });
  async function Oe() {
    return oe.gas ? (b$6("gas provided, skipping simulate", oe.to), oe) : (b$6("simulating tx to", oe.to), await call(ae.publicClient ?? ne, { ...oe, blockTag: "pending", account: ye }), oe);
  }
  return await _e.mempoolQueue.add(() => pRetry(async () => {
    let $e = await Oe();
    _e.hasNonce() || await _e.resetNonce();
    let Me = _e.nextNonce();
    b$6("sending tx with nonce", Me, "to", $e.to);
    let Re = { ...$e, nonce: Me, ...xe.fees };
    return await sendTransaction(ne, Re);
  }, { retries: 3, onFailedAttempt: async ($e) => {
    if (_e.shouldResetNonce($e)) {
      b$6("got nonce error, retrying", $e.message), await _e.resetNonce();
      return;
    }
    throw $e;
  } }), { throwOnTimeout: !0 });
}
var m$5 = ["table", "offchainTable", "namespace", "system"], o$7 = { table: "tb", offchainTable: "ot", namespace: "ns", system: "sy" };
function x$3(ne) {
  let oe = o$7[ne.type];
  if (ne.namespace.length > 14)
    throw new Error(`Namespaces must fit into \`bytes14\`, but "${ne.namespace}" is too long.`);
  return concatHex$1([stringToHex$1(oe, { size: 2 }), stringToHex$1(ne.namespace, { size: 14 }), stringToHex$1(ne.name.slice(0, 16), { size: 16 })]);
}
var y$5 = "";
function i$6({ namespace: ne, name: oe }) {
  return ne === y$5 ? oe : `${ne}__${oe}`;
}
var f$5 = Object.fromEntries(Object.entries(o$7).map(([ne, oe]) => [oe, ne]));
function T$7(ne) {
  let oe = f$5[ne];
  if (m$5.includes(oe))
    return oe;
}
function _$4(ne) {
  let oe = hexToString(sliceHex(ne, 0, 2)).replace(/\0+$/, ""), ae = T$7(oe), fe = hexToString(sliceHex(ne, 2, 16)).replace(/\0+$/, ""), ye = hexToString(sliceHex(ne, 16, 32)).replace(/\0+$/, "");
  if (!ae)
    throw new Error(`Unknown type (${oe}) for resource (${i$6({ namespace: fe, name: ye })})`);
  return { resourceId: ne, type: ae, namespace: fe, name: ye };
}
var T$6 = z$1("mud:benchmark");
T$6.log = console.info.bind(console);
function Q$4(ne) {
  return { ...privateKeyToAccount(ne) };
}
var C$4 = class extends Map {
  constructor(ae) {
    super();
    Na(this, "maxSize");
    this.maxSize = ae;
  }
  set(ae, fe) {
    return super.set(ae, fe), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
};
function a$4(ne, oe, ae) {
  return `0x${ne.replace(/^0x/, "").slice(oe * 2, ae != null ? ae * 2 : void 0).padEnd(((ae ?? oe) - oe) * 2, "0")}`;
}
function be(ne) {
  return "ok" in ne;
}
function Pe(ne, oe, ae = 0, fe = "0x") {
  return concatHex$1([a$4(ne, 0, oe), fe, a$4(ne, oe + ae)]);
}
var G$3 = e$4.extend("transportObserver");
function Ee(ne) {
  return (oe) => {
    let ae = ne(oe);
    return { ...ae, request: async (fe) => {
      if (fe.method === "eth_sendRawTransaction" && fe.params instanceof Array) {
        let ye = fe.params.map((ve) => keccak256(ve));
        G$3("saw txs", ye);
      }
      return ae.request(fe);
    } };
  };
}
var u$3 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" is an odd length (${ae.length - 2}). It must be an even length.`);
    Na(this, "name", "InvalidHexValueError");
  }
}, S$1 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for a schema.`);
    Na(this, "name", "InvalidHexLengthForSchemaError");
  }
}, g$7 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for encoded lengths.`);
    Na(this, "name", "InvalidHexLengthForEncodedLengthsError");
  }
}, A$5 = class extends r$7 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected length of ${T$9[ae] * 2} for ${ae} type.`);
    Na(this, "name", "InvalidHexLengthForStaticFieldError");
  }
}, v$4 = class extends r$7 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected a multiple of ${T$9[ae] * 2} for ${ae}[] type.`);
    Na(this, "name", "InvalidHexLengthForArrayFieldError");
  }
}, H$3 = class extends r$7 {
  constructor(ae, fe, ye) {
    super(`Schema "${ae}" static data length (${fe}) did not match the summed length of all static fields (${ye}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`);
    Na(this, "name", "SchemaStaticLengthMismatchError");
  }
}, F$1 = class extends r$7 {
  constructor(ae, fe, ye) {
    super(`EncodedLengths "${ae}" total bytes length (${fe}) did not match the summed length of all field byte lengths (${ye}).`);
    Na(this, "name", "EncodedLengthsLengthMismatchError");
  }
};
function y$4(ne, oe) {
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$3(oe);
  if ((oe.length - 2) / 2 !== T$9[ne])
    throw new A$5(ne, oe);
  switch (ne) {
    case "uint8":
    case "uint16":
    case "uint24":
    case "uint32":
    case "uint40":
    case "uint48":
    case "uint56":
    case "uint64":
    case "uint72":
    case "uint80":
    case "uint88":
    case "uint96":
    case "uint104":
    case "uint112":
    case "uint120":
    case "uint128":
    case "uint136":
    case "uint144":
    case "uint152":
    case "uint160":
    case "uint168":
    case "uint176":
    case "uint184":
    case "uint192":
    case "uint200":
    case "uint208":
    case "uint216":
    case "uint224":
    case "uint232":
    case "uint240":
    case "uint248":
    case "uint256":
    case "int8":
    case "int16":
    case "int24":
    case "int32":
    case "int40":
    case "int48":
    case "int56":
    case "int64":
    case "int72":
    case "int80":
    case "int88":
    case "int96":
    case "int104":
    case "int112":
    case "int120":
    case "int128":
    case "int136":
    case "int144":
    case "int152":
    case "int160":
    case "int168":
    case "int176":
    case "int184":
    case "int192":
    case "int200":
    case "int208":
    case "int216":
    case "int224":
    case "int232":
    case "int240":
    case "int248":
    case "int256": {
      let ae = hexToBigInt(oe, { signed: ne.startsWith("int") }), fe = typeof b$8[ne];
      if (fe === "number")
        return Number(ae);
      if (fe === "bigint")
        return ae;
      throw new Error(`Unexpected default value type (${fe}) for ABI type (${ne})`);
    }
    case "bytes1":
    case "bytes2":
    case "bytes3":
    case "bytes4":
    case "bytes5":
    case "bytes6":
    case "bytes7":
    case "bytes8":
    case "bytes9":
    case "bytes10":
    case "bytes11":
    case "bytes12":
    case "bytes13":
    case "bytes14":
    case "bytes15":
    case "bytes16":
    case "bytes17":
    case "bytes18":
    case "bytes19":
    case "bytes20":
    case "bytes21":
    case "bytes22":
    case "bytes23":
    case "bytes24":
    case "bytes25":
    case "bytes26":
    case "bytes27":
    case "bytes28":
    case "bytes29":
    case "bytes30":
    case "bytes31":
    case "bytes32":
      return oe;
    case "bool":
      return hexToBool(oe);
    case "address":
      return getAddress(oe);
  }
  return u$4(ne, `Unsupported static ABI type: ${ne}`);
}
function f$4(ne, oe) {
  if (ne === "bytes")
    return oe;
  if (ne === "string")
    return hexToString(oe);
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$3(oe);
  let ae = (oe.length - 2) / 2;
  switch (ne) {
    case "uint8[]":
    case "uint16[]":
    case "uint24[]":
    case "uint32[]":
    case "uint40[]":
    case "uint48[]":
    case "uint56[]":
    case "uint64[]":
    case "uint72[]":
    case "uint80[]":
    case "uint88[]":
    case "uint96[]":
    case "uint104[]":
    case "uint112[]":
    case "uint120[]":
    case "uint128[]":
    case "uint136[]":
    case "uint144[]":
    case "uint152[]":
    case "uint160[]":
    case "uint168[]":
    case "uint176[]":
    case "uint184[]":
    case "uint192[]":
    case "uint200[]":
    case "uint208[]":
    case "uint216[]":
    case "uint224[]":
    case "uint232[]":
    case "uint240[]":
    case "uint248[]":
    case "uint256[]":
    case "int8[]":
    case "int16[]":
    case "int24[]":
    case "int32[]":
    case "int40[]":
    case "int48[]":
    case "int56[]":
    case "int64[]":
    case "int72[]":
    case "int80[]":
    case "int88[]":
    case "int96[]":
    case "int104[]":
    case "int112[]":
    case "int120[]":
    case "int128[]":
    case "int136[]":
    case "int144[]":
    case "int152[]":
    case "int160[]":
    case "int168[]":
    case "int176[]":
    case "int184[]":
    case "int192[]":
    case "int200[]":
    case "int208[]":
    case "int216[]":
    case "int224[]":
    case "int232[]":
    case "int240[]":
    case "int248[]":
    case "int256[]":
    case "bytes1[]":
    case "bytes2[]":
    case "bytes3[]":
    case "bytes4[]":
    case "bytes5[]":
    case "bytes6[]":
    case "bytes7[]":
    case "bytes8[]":
    case "bytes9[]":
    case "bytes10[]":
    case "bytes11[]":
    case "bytes12[]":
    case "bytes13[]":
    case "bytes14[]":
    case "bytes15[]":
    case "bytes16[]":
    case "bytes17[]":
    case "bytes18[]":
    case "bytes19[]":
    case "bytes20[]":
    case "bytes21[]":
    case "bytes22[]":
    case "bytes23[]":
    case "bytes24[]":
    case "bytes25[]":
    case "bytes26[]":
    case "bytes27[]":
    case "bytes28[]":
    case "bytes29[]":
    case "bytes30[]":
    case "bytes31[]":
    case "bytes32[]":
    case "bool[]":
    case "address[]": {
      let fe = m$7(ne), ye = T$9[fe];
      if (ae % ye !== 0)
        throw new v$4(fe, oe);
      return new Array(ae / ye).fill(void 0).map((ve, _e) => {
        let xe = sliceHex(oe, _e * ye, (_e + 1) * ye);
        return y$4(fe, xe);
      });
    }
  }
  return u$4(ne, `Unsupported dynamic ABI type: ${ne}`);
}
function V$3(ne, oe) {
  if (ne.staticFields.length !== oe.length)
    throw new Error(`key tuple length ${oe.length} does not match key schema length ${ne.staticFields.length}`);
  return oe.map((ae, fe) => decodeAbiParameters([{ type: ne.staticFields[fe] }], ae)[0]);
}
function lt$1(ne, oe) {
  let ae = V$3({ staticFields: Object.values(ne), dynamicFields: [] }, oe);
  return Object.fromEntries(Object.keys(ne).map((fe, ye) => [fe, ae[ye]]));
}
function E$4(ne) {
  if (ne.length !== 66)
    throw new g$7(ne);
  let oe = y$4("uint56", a$4(ne, 32 - 7, 32)), ae = f$4("uint40[]", a$4(ne, 0, 32 - 7)), fe = Object.freeze([...ae].reverse()), ye = BigInt(fe.reduce((ve, _e) => ve + _e, 0));
  if (ye !== oe)
    throw new F$1(ne, oe, ye);
  return { totalByteLength: oe, fieldByteLengths: fe };
}
function T$5(ne) {
  return ne.reduce((oe, ae) => oe + T$9[ae], 0);
}
function w$3(ne, oe) {
  let ae = [], fe = 0;
  ne.staticFields.forEach((_e) => {
    let xe = T$9[_e], Oe = y$4(_e, a$4(oe, fe, fe + xe));
    fe += xe, ae.push(Oe);
  });
  let ye = T$5(ne.staticFields), ve = fe;
  if (ve !== ye && console.warn("Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?", { expectedLength: ye, actualLength: ve, bytesOffset: fe }), ne.dynamicFields.length > 0) {
    let _e = E$4(a$4(oe, fe, fe + 32));
    fe += 32, ne.dynamicFields.forEach((Oe, $e) => {
      let Me = _e.fieldByteLengths[$e];
      if (Me > 0) {
        let Re = f$4(Oe, a$4(oe, fe, fe + Me));
        fe += Me, ae.push(Re);
      } else
        ae.push(r$8[Oe]);
    });
    let xe = fe - 32 - ve;
    BigInt(xe) !== _e.totalByteLength && console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?", { expectedLength: _e.totalByteLength, actualLength: xe, bytesOffset: fe });
  }
  return ae;
}
function j$4(ne, oe) {
  let ae = Object.values(ne).filter(e$5), fe = Object.values(ne).filter(v$5), ye = w$3({ staticFields: ae, dynamicFields: fe }, oe);
  return Object.fromEntries(Object.keys(ne).map((ve, _e) => [ve, ye[_e]]));
}
function zt$1(ne, { staticData: oe, encodedLengths: ae, dynamicData: fe }) {
  return j$4(ne, concatHex$1([a$4(oe, 0, T$5(Object.values(ne).filter(e$5))), ae, fe]));
}
function p$4(ne, oe) {
  if (c$6(ne) && Array.isArray(oe)) {
    let ae = m$7(ne);
    return oe.length === 0 ? "0x" : encodePacked(oe.map(() => ae), oe);
  }
  return encodePacked([ne], [oe]);
}
function I$9(ne, oe) {
  return oe.map((ae, fe) => encodeAbiParameters([{ type: ne.staticFields[fe] }], [ae]));
}
function Yt(ne, oe) {
  let ae = Object.values(ne).filter(e$5);
  return I$9({ staticFields: ae, dynamicFields: [] }, Object.values(oe));
}
function K$6(ne) {
  let oe = ne.map(size$2).reverse(), ae = oe.reduce((fe, ye) => fe + BigInt(ye), 0n);
  return padHex$1(concatHex$1([...oe.map((fe) => p$4("uint40", fe)), p$4("uint56", ae)]), { size: 32, dir: "left" });
}
function N$5(ne, oe) {
  let ae = Object.entries(ne), fe = ae.filter(([, Oe]) => e$5(Oe)), ye = ae.filter(([, Oe]) => v$5(Oe)), ve = fe.map(([Oe, $e]) => p$4($e, oe[Oe])), _e = ye.map(([Oe, $e]) => p$4($e, oe[Oe])), xe = K$6(_e);
  return { staticData: concatHex$1(ve), encodedLengths: xe, dynamicData: concatHex$1(_e) };
}
function D$3(ne) {
  if (ne.length !== 66)
    throw new S$1(ne);
  let oe = hexToNumber$1(sliceHex(ne, 0, 2)), ae = hexToNumber$1(sliceHex(ne, 2, 3)), fe = hexToNumber$1(sliceHex(ne, 3, 4)), ye = [], ve = [];
  for (let xe = 4; xe < 4 + ae; xe++) {
    let Oe = hexToNumber$1(sliceHex(ne, xe, xe + 1));
    ye.push(n$2[Oe]);
  }
  for (let xe = 4 + ae; xe < 4 + ae + fe; xe++) {
    let Oe = hexToNumber$1(sliceHex(ne, xe, xe + 1));
    ve.push(n$2[Oe]);
  }
  let _e = ye.reduce((xe, Oe) => xe + T$9[Oe], 0);
  if (_e !== oe)
    throw console.warn(`Schema "${ne}" static data length (${oe}) did not match the summed length of all static fields (${_e}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`), new H$3(ne, oe, _e);
  return { staticFields: ye, dynamicFields: ve };
}
function P$6(ne) {
  let oe = ne.staticFields.map((fe) => n$2.indexOf(fe)), ae = ne.dynamicFields.map((fe) => n$2.indexOf(fe));
  return `0x${[T$5(ne.staticFields).toString(16).padStart(4, "0"), ne.staticFields.length.toString(16).padStart(2, "0"), ne.dynamicFields.length.toString(16).padStart(2, "0"), ...oe.map((fe) => fe.toString(16).padStart(2, "0")), ...ae.map((fe) => fe.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function zi(ne) {
  return P$6({ staticFields: Object.values(ne).filter(e$5), dynamicFields: [] });
}
function _i(ne) {
  let oe = Object.values(ne).filter(e$5), ae = Object.values(ne).filter(v$5), fe = oe.map((ye) => T$9[ye]);
  return `0x${[fe.reduce((ye, ve) => ye + ve, 0).toString(16).padStart(4, "0"), oe.length.toString(16).padStart(2, "0"), ae.length.toString(16).padStart(2, "0"), ...fe.map((ye) => ye.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function Ji(ne) {
  return P$6({ staticFields: Object.values(ne).filter(e$5), dynamicFields: Object.values(ne).filter(v$5) });
}
function Xi$1(ne) {
  return Object.fromEntries(ne.key.map((oe) => [oe, ne.schema[oe]]));
}
function Zi(ne) {
  return Object.fromEntries(Object.entries(ne.schema).filter(([oe]) => !ne.key.includes(oe)));
}
function ia(ne) {
  return P$8(ne, (oe) => oe.type);
}
function flatMorph$1(ne, oe) {
  var ve;
  const ae = Array.isArray(ne), fe = Object.entries(ne).flatMap((_e, xe) => {
    const Oe = ae ? oe(xe, _e[1]) : oe(..._e, xe);
    return Array.isArray(Oe[0]) || Oe.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      Oe
    ) : [Oe];
  }), ye = Object.fromEntries(fe);
  return typeof ((ve = fe[0]) == null ? void 0 : ve[0]) == "number" ? Object.values(ye) : ye;
}
var Hkt$1;
(function(ne) {
  class oe {
  }
  ne.Kind = oe;
  class ae {
  }
  ne.Instantiable = ae, ne.reify = (ye) => ye.hkt;
  class fe {
  }
  ne.UnaryKind = fe, ne.pipe = (...ye) => (ve) => ye.reduce((_e, xe) => xe.hkt(_e), ve);
})(Hkt$1 || (Hkt$1 = {}));
const wellFormedNumberMatcher$1 = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
wellFormedNumberMatcher$1.test.bind(wellFormedNumberMatcher$1);
const wellFormedIntegerMatcher$1 = /^(?:0|(?:-?[1-9]\d*))$/;
wellFormedIntegerMatcher$1.test.bind(wellFormedIntegerMatcher$1);
const integerLikeMatcher$1 = /^-?\d+$/;
integerLikeMatcher$1.test.bind(integerLikeMatcher$1);
const prototypeKeysOf$1 = (ne) => {
  const oe = [];
  let ae = ne;
  for (; ae !== Object.prototype && ae !== null && ae !== void 0; ) {
    for (const fe of Object.getOwnPropertyNames(ae))
      fe !== "constructor" && !oe.includes(fe) && oe.push(fe);
    for (const fe of Object.getOwnPropertySymbols(ae))
      oe.includes(fe) || oe.push(fe);
    ae = Object.getPrototypeOf(ae);
  }
  return oe;
};
prototypeKeysOf$1(0n), prototypeKeysOf$1(!1), prototypeKeysOf$1(0), prototypeKeysOf$1(""), prototypeKeysOf$1(Symbol());
function c$5(ne, oe) {
  return typeof ne == "object" && ne != null && o$6(ne, oe) ? ne[oe] : void 0;
}
function o$6(ne, oe) {
  return typeof ne == "object" && ne !== null && ne.hasOwnProperty(oe);
}
function r$5(ne) {
  return ne != null && typeof ne == "object";
}
function i$5(ne, oe) {
  let ae = [.../* @__PURE__ */ new Set([...Object.keys(ne), ...Object.keys(oe)])];
  return Object.fromEntries(ae.map((fe) => [fe, typeof ne[fe] > "u" ? oe[fe] : ne[fe]]));
}
var b$5 = { storeImportPath: "@latticexyz/store/src", userTypesFilename: "common.sol", outputDirectory: "codegen", indexFilename: "index.sol" }, m$4 = { outputDirectory: "tables", tableIdArgument: !1, storeArgument: !1 }, N$4 = { disabled: !1 }, x$2 = { namespace: "", type: "table" }, T$4 = { sourceDirectory: "src", namespace: "" }, a$3 = { types: Object.fromEntries(n$2.map((ne) => [ne, ne])) };
function u$2(ne, oe) {
  return { types: { ...ne.types, ...oe } };
}
function h$2(ne, oe = a$3) {
  if (!r$5(ne))
    throw new Error(`Expected schema, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    if (!A$6(ae) && !o$6(oe.types, ae))
      throw new Error(`"${String(ae)}" is not a valid type in this scope.`);
}
function k$5(ne, oe = a$3) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, { type: A$6(fe) ? f$6(fe) : oe.types[fe], internalType: fe }]));
}
function v$3(ne, oe = a$3) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((ae) => A$6(ae) || o$6(oe.types, ae));
}
function Y$3(ne, oe = a$3) {
  return Object.entries(ne).filter(([, ae]) => o$6(oe.types, ae) && e$5(oe.types[ae])).map(([ae]) => ae);
}
function q$3(ne, oe, ae = a$3) {
  return Array.isArray(ne) && ne.every((fe) => o$6(oe, fe) && o$6(ae.types, oe[fe]) && e$5(ae.types[oe[fe]]));
}
function g$6(ne, oe = a$3, ae = { inStoreContext: !1 }) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full table config, got \`${JSON.stringify(ne)}\``);
  if (!o$6(ne, "schema"))
    throw new Error("Missing schema input");
  if (h$2(ne.schema, oe), !o$6(ne, "key") || !q$3(ne.key, ne.schema, oe))
    throw new Error(`Invalid key. Expected \`(${Y$3(ne.schema, oe).map((fe) => `"${String(fe)}"`).join(" | ")})[]\`, received \`${o$6(ne, "key") && Array.isArray(ne.key) ? `[${ne.key.map((fe) => `"${fe}"`).join(", ")}]` : String(c$5(ne, "key"))}\``);
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`Table \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$6(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`Table \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
  if (ae.inStoreContext && (o$6(ne, "label") || o$6(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for tables in this context.");
}
function H$2(ne) {
  let oe = ne.codegen;
  return { outputDirectory: c$5(oe, "outputDirectory") ?? m$4.outputDirectory, tableIdArgument: c$5(oe, "tableIdArgument") ?? m$4.tableIdArgument, storeArgument: c$5(oe, "storeArgument") ?? m$4.storeArgument, dataStruct: c$5(oe, "dataStruct") ?? Object.keys(ne.schema).length - ne.key.length > 1 };
}
function E$3(ne, oe = a$3) {
  let ae = ne.label, fe = ne.type ?? x$2.type, ye = ne.namespace ?? x$2.namespace, ve = ne.name ?? ae.slice(0, 16), _e = x$3({ type: fe, namespace: ye, name: ve });
  return { label: ae, type: fe, namespace: ye, name: ve, tableId: _e, schema: k$5(ne.schema, oe), key: ne.key, codegen: H$2(ne), deploy: i$5(ne.deploy ?? {}, N$4) };
}
function D$2(ne) {
  return typeof ne == "string" || r$5(ne) && Object.values(ne).every((oe) => typeof oe == "string");
}
function A$4(ne, oe = a$3) {
  if (typeof ne == "string") {
    if (A$6(ne) || o$6(oe.types, ne))
      return;
    throw new Error(`Invalid ABI type. \`${ne}\` not found in scope.`);
  }
  if (typeof ne == "object" && ne !== null) {
    if (v$3(ne, oe)) {
      if (o$6(ne, "id") && e$5(oe.types[ne.id]))
        return;
      throw new Error("Invalid schema. Expected an `id` field with a static ABI type or an explicit `key` option.");
    }
    throw new Error("Invalid schema. Are you using invalid types or missing types in your scope?");
  }
  throw new Error("Invalid table shorthand.");
}
function l$5(ne, oe) {
  return typeof ne == "string" ? { schema: { id: "bytes32", value: ne }, key: ["id"] } : v$3(ne, oe) ? { schema: ne, key: ["id"] } : ne;
}
function d$2(ne, oe) {
  if (r$5(ne)) {
    for (let ae of Object.values(ne))
      D$2(ae) ? A$4(ae, oe) : g$6(ae, oe, { inStoreContext: !0 });
    return;
  }
  throw new Error(`Expected tables config, received ${JSON.stringify(ne)}`);
}
function I$8(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, E$3(i$5(l$5(fe, oe), { label: ae }), oe)]));
}
function Z$1(ne) {
  return P$8(ne, (oe) => oe.type);
}
function ee$1(ne) {
  return r$5(ne) && Object.values(ne).every((oe) => o$8(oe.type));
}
function U$4(ne, oe = a$3) {
  return ee$1(ne) ? u$2(oe, Z$1(ne)) : oe;
}
function L$3(ne) {
  if (!r$5(ne))
    throw new Error(`Expected userTypes, received ${JSON.stringify(ne)}`);
  for (let { type: oe } of Object.values(ne))
    if (!o$6(a$3.types, oe))
      throw new Error(`"${String(oe)}" is not a valid ABI type.`);
}
function te$3(ne) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((oe) => Array.isArray(oe) && oe.every((ae) => typeof ae == "string"));
}
function _$3(ne, oe = a$3) {
  if (te$3(ne)) {
    let ae = Object.fromEntries(Object.keys(ne).map((fe) => [fe, "uint8"]));
    return u$2(oe, ae);
  }
  return oe;
}
function j$3(ne) {
  return flatMorph$1(ne, (oe, ae) => [oe, flatMorph$1(ae, (fe, ye) => [ye, fe])]);
}
function C$3(ne) {
  return r$5(ne) ? i$5(ne, b$5) : b$5;
}
function K$5(ne, oe) {
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$6(ne, "tables") && d$2(ne.tables, oe);
}
function $$1(ne, oe = a$3) {
  let ae = ne.label, fe = ne.namespace ?? ae.slice(0, 14);
  return { label: ae, namespace: fe, tables: I$8(flatMorph$1(ne.tables ?? {}, (ye, ve) => [ye, i$5(l$5(ve, oe), { namespace: fe })]), oe) };
}
function w$2(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    K$5(ae, oe);
}
function f$3(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph$1(ne, (ye, ve) => [ye, $$1(i$5(ve, { label: ye }), oe)]), fe = Array.from(y$7(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function B$2(ne) {
  return Object.fromEntries(Object.entries(ne.namespaces).flatMap(([oe, ae]) => Object.entries(ae.tables).map(([fe, ye]) => [oe === "" ? fe : `${oe}__${fe}`, ye])));
}
function G$2(ne) {
  return _$3(c$5(ne, "enums"), U$4(c$5(ne, "userTypes")));
}
function pe$1(ne) {
  let oe = G$2(ne);
  if (o$6(ne, "namespaces")) {
    if (o$6(ne, "namespace") || o$6(ne, "tables"))
      throw new Error("Cannot use `namespaces` with `namespace` or `tables` keys.");
    w$2(ne.namespaces, oe);
  }
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$6(ne, "tables") && d$2(ne.tables, oe), o$6(ne, "userTypes") && L$3(ne.userTypes);
}
function re$1(ne) {
  let oe = G$2(ne), ae = ne.namespace ?? T$4.namespace, fe = ne.namespaces ? { multipleNamespaces: !0, namespace: null, namespaces: f$3(ne.namespaces, oe) } : { multipleNamespaces: !1, namespace: ae, namespaces: f$3({ [ae]: ne }, oe) }, ye = B$2(fe);
  return { ...fe, tables: ye, sourceDirectory: ne.sourceDirectory ?? T$4.sourceDirectory, userTypes: ne.userTypes ?? {}, enums: ne.enums ?? {}, enumValues: j$3(ne.enums ?? {}), codegen: C$3(ne.codegen) };
}
function Lt(ne) {
  return pe$1(ne), re$1(ne);
}
var o$5 = Lt({ namespace: "store", codegen: { storeImportPath: "./src" }, userTypes: { ResourceId: { filePath: "./src/ResourceId.sol", type: "bytes32" }, FieldLayout: { filePath: "./src/FieldLayout.sol", type: "bytes32" }, Schema: { filePath: "./src/Schema.sol", type: "bytes32" } }, tables: { StoreHooks: { schema: { tableId: "ResourceId", hooks: "bytes21[]" }, key: ["tableId"] }, Tables: { schema: { tableId: "ResourceId", fieldLayout: "FieldLayout", keySchema: "Schema", valueSchema: "Schema", abiEncodedKeyNames: "bytes", abiEncodedFieldNames: "bytes" }, key: ["tableId"] }, ResourceIds: { schema: { resourceId: "ResourceId", exists: "bool" }, key: ["resourceId"] }, Hooks: { schema: { resourceId: "ResourceId", hooks: "bytes21[]" }, key: ["resourceId"], codegen: { tableIdArgument: !0 }, deploy: { disabled: !0 } } } }), m$3 = { namespace: "", openAccess: !0, accessList: [] }, C$2 = { root: !1, args: [], artifactPath: void 0 }, I$7 = { worldInterfaceName: "IWorld", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src" }, b$4 = { customWorldContract: void 0, postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", upgradeableWorldImplementation: !1 }, P$5 = { systems: {}, tables: {}, excludeSystems: [], modules: [], codegen: I$7, deploy: b$4 };
function i$4(ne, oe = {}) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full system config, got \`${JSON.stringify(ne)}\``);
  if (oe.inNamespace && (o$6(ne, "label") || o$6(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for systems in this context.");
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`System \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$6(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`System \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
}
function c$4(ne) {
  let oe = ne.label, ae = ne.namespace ?? m$3.namespace, fe = ne.name ?? oe.slice(0, 16), ye = x$3({ type: "system", namespace: ae, name: fe });
  return i$5({ ...ne, label: oe, namespace: ae, name: fe, systemId: ye }, m$3);
}
function y$3(ne) {
  if (r$5(ne)) {
    for (let oe of Object.values(ne))
      i$4(oe, { inNamespace: !0 });
    return;
  }
  throw new Error(`Expected system config, received ${JSON.stringify(ne)}`);
}
function l$4(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, c$4({ ...fe, label: ae, namespace: oe })]));
}
function Q$3(ne, oe) {
  o$6(ne, "systems") && y$3(ne.systems), K$5(ne, oe);
}
function X$1(ne, oe = a$3) {
  let ae = $$1(ne, oe), fe = l$4(ne.systems ?? {}, ae.namespace);
  return { ...ae, systems: fe };
}
function l$3(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    Q$3(ae, oe);
}
function r$4(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph$1(ne, (ye, ve) => [ye, X$1(i$5(ve, { label: ye }), oe)]), fe = Array.from(y$7(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function N$3(ne) {
  return r$5(ne) ? i$5(ne, I$7) : I$7;
}
function g$5(ne) {
  return r$5(ne) ? i$5(ne, b$4) : b$4;
}
function W$1(ne) {
  let oe = G$2(ne);
  if (o$6(ne, "namespaces")) {
    if (o$6(ne, "namespace") || o$6(ne, "tables") || o$6(ne, "systems"))
      throw new Error("Cannot use `namespaces` with `namespace`, `tables`, or `systems` keys.");
    l$3(ne.namespaces, oe);
  }
  o$6(ne, "systems") && y$3(ne.systems), pe$1(ne);
}
function _$2(ne) {
  let oe = G$2(ne), ae = re$1(ne), fe = ne.namespaces ? r$4(ne.namespaces, oe) : r$4({ [ae.namespace]: ne }, oe), ye = B$2({ namespaces: fe }), ve = (ne.modules ?? P$5.modules).map((_e) => i$5(_e, C$2));
  return i$5({ ...ae, namespaces: fe, tables: ye, systems: !ae.multipleNamespaces && ne.systems ? l$4(ne.systems, ae.namespace) : P$5.systems, excludeSystems: c$5(ne, "excludeSystems"), codegen: i$5(ae.codegen, N$3(ne.codegen)), deploy: g$5(ne.deploy), modules: ve }, P$5);
}
function te$2(ne) {
  return W$1(ne), _$2(ne);
}
var s = { namespace: "world", codegen: { worldImportPath: "./src", worldgenDirectory: "interfaces", worldInterfaceName: "IBaseWorld" }, userTypes: { ResourceId: { filePath: "@latticexyz/store/src/ResourceId.sol", type: "bytes32" } }, tables: { NamespaceOwner: { schema: { namespaceId: "ResourceId", owner: "address" }, key: ["namespaceId"] }, ResourceAccess: { schema: { resourceId: "ResourceId", caller: "address", access: "bool" }, key: ["resourceId", "caller"] }, InstalledModules: { schema: { moduleAddress: "address", argumentsHash: "bytes32", isInstalled: "bool" }, key: ["moduleAddress", "argumentsHash"] }, UserDelegationControl: { schema: { delegator: "address", delegatee: "address", delegationControlId: "ResourceId" }, key: ["delegator", "delegatee"] }, NamespaceDelegationControl: { schema: { namespaceId: "ResourceId", delegationControlId: "ResourceId" }, key: ["namespaceId"] }, Balances: { schema: { namespaceId: "ResourceId", balance: "uint256" }, key: ["namespaceId"] }, Systems: { schema: { systemId: "ResourceId", system: "address", publicAccess: "bool" }, key: ["systemId"], codegen: { dataStruct: !1 } }, SystemRegistry: { schema: { system: "address", systemId: "ResourceId" }, key: ["system"] }, SystemHooks: { schema: { systemId: "ResourceId", value: "bytes21[]" }, key: ["systemId"] }, FunctionSelectors: { schema: { worldFunctionSelector: "bytes4", systemId: "ResourceId", systemFunctionSelector: "bytes4" }, key: ["worldFunctionSelector"], codegen: { dataStruct: !1 } }, FunctionSignatures: { type: "offchainTable", schema: { functionSelector: "bytes4", functionSignature: "string" }, key: ["functionSelector"] }, InitModuleAddress: { schema: { value: "address" }, key: [] } }, excludeSystems: ["StoreRegistrationSystem"] }, a$2 = te$2(s), t$1 = "event Store_SetRecord(bytes32 indexed tableId, bytes32[] keyTuple, bytes staticData, bytes32 encodedLengths, bytes dynamicData)", o$4 = "event Store_SpliceStaticData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, bytes data)", r$3 = "event Store_SpliceDynamicData(bytes32 indexed tableId, bytes32[] keyTuple, uint8 dynamicFieldIndex, uint48 start, uint40 deleteCount, bytes32 encodedLengths, bytes data)", n$1 = "event Store_DeleteRecord(bytes32 indexed tableId, bytes32[] keyTuple)", e$3 = [t$1, o$4, r$3, n$1], p$3 = parseAbi(e$3), extendStatics = function(ne, oe) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ae, fe) {
    ae.__proto__ = fe;
  } || function(ae, fe) {
    for (var ye in fe)
      Object.prototype.hasOwnProperty.call(fe, ye) && (ae[ye] = fe[ye]);
  }, extendStatics(ne, oe);
};
function __extends(ne, oe) {
  if (typeof oe != "function" && oe !== null)
    throw new TypeError("Class extends value " + String(oe) + " is not a constructor or null");
  extendStatics(ne, oe);
  function ae() {
    this.constructor = ne;
  }
  ne.prototype = oe === null ? Object.create(oe) : (ae.prototype = oe.prototype, new ae());
}
function __awaiter(ne, oe, ae, fe) {
  function ye(ve) {
    return ve instanceof ae ? ve : new ae(function(_e) {
      _e(ve);
    });
  }
  return new (ae || (ae = Promise))(function(ve, _e) {
    function xe(Me) {
      try {
        $e(fe.next(Me));
      } catch (Re) {
        _e(Re);
      }
    }
    function Oe(Me) {
      try {
        $e(fe.throw(Me));
      } catch (Re) {
        _e(Re);
      }
    }
    function $e(Me) {
      Me.done ? ve(Me.value) : ye(Me.value).then(xe, Oe);
    }
    $e((fe = fe.apply(ne, oe || [])).next());
  });
}
function __generator(ne, oe) {
  var ae = { label: 0, sent: function() {
    if (ve[0] & 1)
      throw ve[1];
    return ve[1];
  }, trys: [], ops: [] }, fe, ye, ve, _e = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return _e.next = xe(0), _e.throw = xe(1), _e.return = xe(2), typeof Symbol == "function" && (_e[Symbol.iterator] = function() {
    return this;
  }), _e;
  function xe($e) {
    return function(Me) {
      return Oe([$e, Me]);
    };
  }
  function Oe($e) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; _e && (_e = 0, $e[0] && (ae = 0)), ae; )
      try {
        if (fe = 1, ye && (ve = $e[0] & 2 ? ye.return : $e[0] ? ye.throw || ((ve = ye.return) && ve.call(ye), 0) : ye.next) && !(ve = ve.call(ye, $e[1])).done)
          return ve;
        switch (ye = 0, ve && ($e = [$e[0] & 2, ve.value]), $e[0]) {
          case 0:
          case 1:
            ve = $e;
            break;
          case 4:
            return ae.label++, { value: $e[1], done: !1 };
          case 5:
            ae.label++, ye = $e[1], $e = [0];
            continue;
          case 7:
            $e = ae.ops.pop(), ae.trys.pop();
            continue;
          default:
            if (ve = ae.trys, !(ve = ve.length > 0 && ve[ve.length - 1]) && ($e[0] === 6 || $e[0] === 2)) {
              ae = 0;
              continue;
            }
            if ($e[0] === 3 && (!ve || $e[1] > ve[0] && $e[1] < ve[3])) {
              ae.label = $e[1];
              break;
            }
            if ($e[0] === 6 && ae.label < ve[1]) {
              ae.label = ve[1], ve = $e;
              break;
            }
            if (ve && ae.label < ve[2]) {
              ae.label = ve[2], ae.ops.push($e);
              break;
            }
            ve[2] && ae.ops.pop(), ae.trys.pop();
            continue;
        }
        $e = oe.call(ne, ae);
      } catch (Me) {
        $e = [6, Me], ye = 0;
      } finally {
        fe = ve = 0;
      }
    if ($e[0] & 5)
      throw $e[1];
    return { value: $e[0] ? $e[1] : void 0, done: !0 };
  }
}
function __values(ne) {
  var oe = typeof Symbol == "function" && Symbol.iterator, ae = oe && ne[oe], fe = 0;
  if (ae)
    return ae.call(ne);
  if (ne && typeof ne.length == "number")
    return {
      next: function() {
        return ne && fe >= ne.length && (ne = void 0), { value: ne && ne[fe++], done: !ne };
      }
    };
  throw new TypeError(oe ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ve = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ve.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return ve;
}
function __spreadArray(ne, oe, ae) {
  if (ae || arguments.length === 2)
    for (var fe = 0, ye = oe.length, ve; fe < ye; fe++)
      (ve || !(fe in oe)) && (ve || (ve = Array.prototype.slice.call(oe, 0, fe)), ve[fe] = oe[fe]);
  return ne.concat(ve || Array.prototype.slice.call(oe));
}
function __await(ne) {
  return this instanceof __await ? (this.v = ne, this) : new __await(ne);
}
function __asyncGenerator(ne, oe, ae) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var fe = ae.apply(ne, oe || []), ye, ve = [];
  return ye = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), xe("next"), xe("throw"), xe("return", _e), ye[Symbol.asyncIterator] = function() {
    return this;
  }, ye;
  function _e(Be) {
    return function(ze) {
      return Promise.resolve(ze).then(Be, Re);
    };
  }
  function xe(Be, ze) {
    fe[Be] && (ye[Be] = function(He) {
      return new Promise(function(qe, Ye) {
        ve.push([Be, He, qe, Ye]) > 1 || Oe(Be, He);
      });
    }, ze && (ye[Be] = ze(ye[Be])));
  }
  function Oe(Be, ze) {
    try {
      $e(fe[Be](ze));
    } catch (He) {
      je(ve[0][3], He);
    }
  }
  function $e(Be) {
    Be.value instanceof __await ? Promise.resolve(Be.value.v).then(Me, Re) : je(ve[0][2], Be);
  }
  function Me(Be) {
    Oe("next", Be);
  }
  function Re(Be) {
    Oe("throw", Be);
  }
  function je(Be, ze) {
    Be(ze), ve.shift(), ve.length && Oe(ve[0][0], ve[0][1]);
  }
}
function __asyncValues(ne) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var oe = ne[Symbol.asyncIterator], ae;
  return oe ? oe.call(ne) : (ne = typeof __values == "function" ? __values(ne) : ne[Symbol.iterator](), ae = {}, fe("next"), fe("throw"), fe("return"), ae[Symbol.asyncIterator] = function() {
    return this;
  }, ae);
  function fe(ve) {
    ae[ve] = ne[ve] && function(_e) {
      return new Promise(function(xe, Oe) {
        _e = ne[ve](_e), ye(xe, Oe, _e.done, _e.value);
      });
    };
  }
  function ye(ve, _e, xe, Oe) {
    Promise.resolve(Oe).then(function($e) {
      ve({ value: $e, done: xe });
    }, _e);
  }
}
typeof SuppressedError == "function" && SuppressedError;
function isFunction$1(ne) {
  return typeof ne == "function";
}
function createErrorClass(ne) {
  var oe = function(fe) {
    Error.call(fe), fe.stack = new Error().stack;
  }, ae = ne(oe);
  return ae.prototype = Object.create(Error.prototype), ae.prototype.constructor = ae, ae;
}
var UnsubscriptionError = createErrorClass(function(ne) {
  return function(ae) {
    ne(this), this.message = ae ? ae.length + ` errors occurred during unsubscription:
` + ae.map(function(fe, ye) {
      return ye + 1 + ") " + fe.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = ae;
  };
});
function arrRemove(ne, oe) {
  if (ne) {
    var ae = ne.indexOf(oe);
    0 <= ae && ne.splice(ae, 1);
  }
}
var Subscription = function() {
  function ne(oe) {
    this.initialTeardown = oe, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return ne.prototype.unsubscribe = function() {
    var oe, ae, fe, ye, ve;
    if (!this.closed) {
      this.closed = !0;
      var _e = this._parentage;
      if (_e)
        if (this._parentage = null, Array.isArray(_e))
          try {
            for (var xe = __values(_e), Oe = xe.next(); !Oe.done; Oe = xe.next()) {
              var $e = Oe.value;
              $e.remove(this);
            }
          } catch (He) {
            oe = { error: He };
          } finally {
            try {
              Oe && !Oe.done && (ae = xe.return) && ae.call(xe);
            } finally {
              if (oe)
                throw oe.error;
            }
          }
        else
          _e.remove(this);
      var Me = this.initialTeardown;
      if (isFunction$1(Me))
        try {
          Me();
        } catch (He) {
          ve = He instanceof UnsubscriptionError ? He.errors : [He];
        }
      var Re = this._finalizers;
      if (Re) {
        this._finalizers = null;
        try {
          for (var je = __values(Re), Be = je.next(); !Be.done; Be = je.next()) {
            var ze = Be.value;
            try {
              execFinalizer(ze);
            } catch (He) {
              ve = ve ?? [], He instanceof UnsubscriptionError ? ve = __spreadArray(__spreadArray([], __read(ve)), __read(He.errors)) : ve.push(He);
            }
          }
        } catch (He) {
          fe = { error: He };
        } finally {
          try {
            Be && !Be.done && (ye = je.return) && ye.call(je);
          } finally {
            if (fe)
              throw fe.error;
          }
        }
      }
      if (ve)
        throw new UnsubscriptionError(ve);
    }
  }, ne.prototype.add = function(oe) {
    var ae;
    if (oe && oe !== this)
      if (this.closed)
        execFinalizer(oe);
      else {
        if (oe instanceof ne) {
          if (oe.closed || oe._hasParent(this))
            return;
          oe._addParent(this);
        }
        (this._finalizers = (ae = this._finalizers) !== null && ae !== void 0 ? ae : []).push(oe);
      }
  }, ne.prototype._hasParent = function(oe) {
    var ae = this._parentage;
    return ae === oe || Array.isArray(ae) && ae.includes(oe);
  }, ne.prototype._addParent = function(oe) {
    var ae = this._parentage;
    this._parentage = Array.isArray(ae) ? (ae.push(oe), ae) : ae ? [ae, oe] : oe;
  }, ne.prototype._removeParent = function(oe) {
    var ae = this._parentage;
    ae === oe ? this._parentage = null : Array.isArray(ae) && arrRemove(ae, oe);
  }, ne.prototype.remove = function(oe) {
    var ae = this._finalizers;
    ae && arrRemove(ae, oe), oe instanceof ne && oe._removeParent(this);
  }, ne.EMPTY = function() {
    var oe = new ne();
    return oe.closed = !0, oe;
  }(), ne;
}(), EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(ne) {
  return ne instanceof Subscription || ne && "closed" in ne && isFunction$1(ne.remove) && isFunction$1(ne.add) && isFunction$1(ne.unsubscribe);
}
function execFinalizer(ne) {
  isFunction$1(ne) ? ne() : ne.unsubscribe();
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, timeoutProvider = {
  setTimeout: function(ne, oe) {
    for (var ae = [], fe = 2; fe < arguments.length; fe++)
      ae[fe - 2] = arguments[fe];
    var ye = timeoutProvider.delegate;
    return ye != null && ye.setTimeout ? ye.setTimeout.apply(ye, __spreadArray([ne, oe], __read(ae))) : setTimeout.apply(void 0, __spreadArray([ne, oe], __read(ae)));
  },
  clearTimeout: function(ne) {
    var oe = timeoutProvider.delegate;
    return ((oe == null ? void 0 : oe.clearTimeout) || clearTimeout)(ne);
  },
  delegate: void 0
};
function reportUnhandledError(ne) {
  timeoutProvider.setTimeout(function() {
    throw ne;
  });
}
function noop$1() {
}
function errorContext(ne) {
  ne();
}
var Subscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae) {
    var fe = ne.call(this) || this;
    return fe.isStopped = !1, ae ? (fe.destination = ae, isSubscription(ae) && ae.add(fe)) : fe.destination = EMPTY_OBSERVER, fe;
  }
  return oe.create = function(ae, fe, ye) {
    return new SafeSubscriber(ae, fe, ye);
  }, oe.prototype.next = function(ae) {
    this.isStopped || this._next(ae);
  }, oe.prototype.error = function(ae) {
    this.isStopped || (this.isStopped = !0, this._error(ae));
  }, oe.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, oe.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, ne.prototype.unsubscribe.call(this), this.destination = null);
  }, oe.prototype._next = function(ae) {
    this.destination.next(ae);
  }, oe.prototype._error = function(ae) {
    try {
      this.destination.error(ae);
    } finally {
      this.unsubscribe();
    }
  }, oe.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, oe;
}(Subscription), _bind = Function.prototype.bind;
function bind(ne, oe) {
  return _bind.call(ne, oe);
}
var ConsumerObserver = function() {
  function ne(oe) {
    this.partialObserver = oe;
  }
  return ne.prototype.next = function(oe) {
    var ae = this.partialObserver;
    if (ae.next)
      try {
        ae.next(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
  }, ne.prototype.error = function(oe) {
    var ae = this.partialObserver;
    if (ae.error)
      try {
        ae.error(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
    else
      handleUnhandledError(oe);
  }, ne.prototype.complete = function() {
    var oe = this.partialObserver;
    if (oe.complete)
      try {
        oe.complete();
      } catch (ae) {
        handleUnhandledError(ae);
      }
  }, ne;
}(), SafeSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    var ve = ne.call(this) || this, _e;
    if (isFunction$1(ae) || !ae)
      _e = {
        next: ae ?? void 0,
        error: fe ?? void 0,
        complete: ye ?? void 0
      };
    else {
      var xe;
      ve && config.useDeprecatedNextContext ? (xe = Object.create(ae), xe.unsubscribe = function() {
        return ve.unsubscribe();
      }, _e = {
        next: ae.next && bind(ae.next, xe),
        error: ae.error && bind(ae.error, xe),
        complete: ae.complete && bind(ae.complete, xe)
      }) : _e = ae;
    }
    return ve.destination = new ConsumerObserver(_e), ve;
  }
  return oe;
}(Subscriber);
function handleUnhandledError(ne) {
  reportUnhandledError(ne);
}
function defaultErrorHandler(ne) {
  throw ne;
}
var EMPTY_OBSERVER = {
  closed: !0,
  next: noop$1,
  error: defaultErrorHandler,
  complete: noop$1
}, observable$1 = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(ne) {
  return ne;
}
function pipe() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return pipeFromArray(ne);
}
function pipeFromArray(ne) {
  return ne.length === 0 ? identity$1 : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce(function(fe, ye) {
      return ye(fe);
    }, ae);
  };
}
var Observable = function() {
  function ne(oe) {
    oe && (this._subscribe = oe);
  }
  return ne.prototype.lift = function(oe) {
    var ae = new ne();
    return ae.source = this, ae.operator = oe, ae;
  }, ne.prototype.subscribe = function(oe, ae, fe) {
    var ye = this, ve = isSubscriber(oe) ? oe : new SafeSubscriber(oe, ae, fe);
    return errorContext(function() {
      var _e = ye, xe = _e.operator, Oe = _e.source;
      ve.add(xe ? xe.call(ve, Oe) : Oe ? ye._subscribe(ve) : ye._trySubscribe(ve));
    }), ve;
  }, ne.prototype._trySubscribe = function(oe) {
    try {
      return this._subscribe(oe);
    } catch (ae) {
      oe.error(ae);
    }
  }, ne.prototype.forEach = function(oe, ae) {
    var fe = this;
    return ae = getPromiseCtor(ae), new ae(function(ye, ve) {
      var _e = new SafeSubscriber({
        next: function(xe) {
          try {
            oe(xe);
          } catch (Oe) {
            ve(Oe), _e.unsubscribe();
          }
        },
        error: ve,
        complete: ye
      });
      fe.subscribe(_e);
    });
  }, ne.prototype._subscribe = function(oe) {
    var ae;
    return (ae = this.source) === null || ae === void 0 ? void 0 : ae.subscribe(oe);
  }, ne.prototype[observable$1] = function() {
    return this;
  }, ne.prototype.pipe = function() {
    for (var oe = [], ae = 0; ae < arguments.length; ae++)
      oe[ae] = arguments[ae];
    return pipeFromArray(oe)(this);
  }, ne.prototype.toPromise = function(oe) {
    var ae = this;
    return oe = getPromiseCtor(oe), new oe(function(fe, ye) {
      var ve;
      ae.subscribe(function(_e) {
        return ve = _e;
      }, function(_e) {
        return ye(_e);
      }, function() {
        return fe(ve);
      });
    });
  }, ne.create = function(oe) {
    return new ne(oe);
  }, ne;
}();
function getPromiseCtor(ne) {
  var oe;
  return (oe = ne ?? config.Promise) !== null && oe !== void 0 ? oe : Promise;
}
function isObserver(ne) {
  return ne && isFunction$1(ne.next) && isFunction$1(ne.error) && isFunction$1(ne.complete);
}
function isSubscriber(ne) {
  return ne && ne instanceof Subscriber || isObserver(ne) && isSubscription(ne);
}
function hasLift(ne) {
  return isFunction$1(ne == null ? void 0 : ne.lift);
}
function operate(ne) {
  return function(oe) {
    if (hasLift(oe))
      return oe.lift(function(ae) {
        try {
          return ne(ae, this);
        } catch (fe) {
          this.error(fe);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(ne, oe, ae, fe, ye) {
  return new OperatorSubscriber(ne, oe, ae, fe, ye);
}
var OperatorSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye, ve, _e, xe) {
    var Oe = ne.call(this, ae) || this;
    return Oe.onFinalize = _e, Oe.shouldUnsubscribe = xe, Oe._next = fe ? function($e) {
      try {
        fe($e);
      } catch (Me) {
        ae.error(Me);
      }
    } : ne.prototype._next, Oe._error = ve ? function($e) {
      try {
        ve($e);
      } catch (Me) {
        ae.error(Me);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._error, Oe._complete = ye ? function() {
      try {
        ye();
      } catch ($e) {
        ae.error($e);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._complete, Oe;
  }
  return oe.prototype.unsubscribe = function() {
    var ae;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var fe = this.closed;
      ne.prototype.unsubscribe.call(this), !fe && ((ae = this.onFinalize) === null || ae === void 0 || ae.call(this));
    }
  }, oe;
}(Subscriber), ObjectUnsubscribedError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Subject = function(ne) {
  __extends(oe, ne);
  function oe() {
    var ae = ne.call(this) || this;
    return ae.closed = !1, ae.currentObservers = null, ae.observers = [], ae.isStopped = !1, ae.hasError = !1, ae.thrownError = null, ae;
  }
  return oe.prototype.lift = function(ae) {
    var fe = new AnonymousSubject(this, this);
    return fe.operator = ae, fe;
  }, oe.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
  }, oe.prototype.next = function(ae) {
    var fe = this;
    errorContext(function() {
      var ye, ve;
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.currentObservers || (fe.currentObservers = Array.from(fe.observers));
        try {
          for (var _e = __values(fe.currentObservers), xe = _e.next(); !xe.done; xe = _e.next()) {
            var Oe = xe.value;
            Oe.next(ae);
          }
        } catch ($e) {
          ye = { error: $e };
        } finally {
          try {
            xe && !xe.done && (ve = _e.return) && ve.call(_e);
          } finally {
            if (ye)
              throw ye.error;
          }
        }
      }
    });
  }, oe.prototype.error = function(ae) {
    var fe = this;
    errorContext(function() {
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.hasError = fe.isStopped = !0, fe.thrownError = ae;
        for (var ye = fe.observers; ye.length; )
          ye.shift().error(ae);
      }
    });
  }, oe.prototype.complete = function() {
    var ae = this;
    errorContext(function() {
      if (ae._throwIfClosed(), !ae.isStopped) {
        ae.isStopped = !0;
        for (var fe = ae.observers; fe.length; )
          fe.shift().complete();
      }
    });
  }, oe.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(oe.prototype, "observed", {
    get: function() {
      var ae;
      return ((ae = this.observers) === null || ae === void 0 ? void 0 : ae.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), oe.prototype._trySubscribe = function(ae) {
    return this._throwIfClosed(), ne.prototype._trySubscribe.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(ae), this._innerSubscribe(ae);
  }, oe.prototype._innerSubscribe = function(ae) {
    var fe = this, ye = this, ve = ye.hasError, _e = ye.isStopped, xe = ye.observers;
    return ve || _e ? EMPTY_SUBSCRIPTION : (this.currentObservers = null, xe.push(ae), new Subscription(function() {
      fe.currentObservers = null, arrRemove(xe, ae);
    }));
  }, oe.prototype._checkFinalizedStatuses = function(ae) {
    var fe = this, ye = fe.hasError, ve = fe.thrownError, _e = fe.isStopped;
    ye ? ae.error(ve) : _e && ae.complete();
  }, oe.prototype.asObservable = function() {
    var ae = new Observable();
    return ae.source = this, ae;
  }, oe.create = function(ae, fe) {
    return new AnonymousSubject(ae, fe);
  }, oe;
}(Observable), AnonymousSubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe) {
    var ye = ne.call(this) || this;
    return ye.destination = ae, ye.source = fe, ye;
  }
  return oe.prototype.next = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.next) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.error = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.error) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.complete = function() {
    var ae, fe;
    (fe = (ae = this.destination) === null || ae === void 0 ? void 0 : ae.complete) === null || fe === void 0 || fe.call(ae);
  }, oe.prototype._subscribe = function(ae) {
    var fe, ye;
    return (ye = (fe = this.source) === null || fe === void 0 ? void 0 : fe.subscribe(ae)) !== null && ye !== void 0 ? ye : EMPTY_SUBSCRIPTION;
  }, oe;
}(Subject), dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
}, ReplaySubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    ae === void 0 && (ae = 1 / 0), fe === void 0 && (fe = 1 / 0), ye === void 0 && (ye = dateTimestampProvider);
    var ve = ne.call(this) || this;
    return ve._bufferSize = ae, ve._windowTime = fe, ve._timestampProvider = ye, ve._buffer = [], ve._infiniteTimeWindow = !0, ve._infiniteTimeWindow = fe === 1 / 0, ve._bufferSize = Math.max(1, ae), ve._windowTime = Math.max(1, fe), ve;
  }
  return oe.prototype.next = function(ae) {
    var fe = this, ye = fe.isStopped, ve = fe._buffer, _e = fe._infiniteTimeWindow, xe = fe._timestampProvider, Oe = fe._windowTime;
    ye || (ve.push(ae), !_e && ve.push(xe.now() + Oe)), this._trimBuffer(), ne.prototype.next.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    this._throwIfClosed(), this._trimBuffer();
    for (var fe = this._innerSubscribe(ae), ye = this, ve = ye._infiniteTimeWindow, _e = ye._buffer, xe = _e.slice(), Oe = 0; Oe < xe.length && !ae.closed; Oe += ve ? 1 : 2)
      ae.next(xe[Oe]);
    return this._checkFinalizedStatuses(ae), fe;
  }, oe.prototype._trimBuffer = function() {
    var ae = this, fe = ae._bufferSize, ye = ae._timestampProvider, ve = ae._buffer, _e = ae._infiniteTimeWindow, xe = (_e ? 1 : 2) * fe;
    if (fe < 1 / 0 && xe < ve.length && ve.splice(0, ve.length - xe), !_e) {
      for (var Oe = ye.now(), $e = 0, Me = 1; Me < ve.length && ve[Me] <= Oe; Me += 2)
        $e = Me;
      $e && ve.splice(0, $e + 1);
    }
  }, oe;
}(Subject), EMPTY = new Observable(function(ne) {
  return ne.complete();
});
function isScheduler(ne) {
  return ne && isFunction$1(ne.schedule);
}
function last(ne) {
  return ne[ne.length - 1];
}
function popResultSelector(ne) {
  return isFunction$1(last(ne)) ? ne.pop() : void 0;
}
function popScheduler(ne) {
  return isScheduler(last(ne)) ? ne.pop() : void 0;
}
function popNumber(ne, oe) {
  return typeof last(ne) == "number" ? ne.pop() : oe;
}
var isArrayLike = function(ne) {
  return ne && typeof ne.length == "number" && typeof ne != "function";
};
function isPromise(ne) {
  return isFunction$1(ne == null ? void 0 : ne.then);
}
function isInteropObservable(ne) {
  return isFunction$1(ne[observable$1]);
}
function isAsyncIterable(ne) {
  return Symbol.asyncIterator && isFunction$1(ne == null ? void 0 : ne[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(ne) {
  return new TypeError("You provided " + (ne !== null && typeof ne == "object" ? "an invalid object" : "'" + ne + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(ne) {
  return isFunction$1(ne == null ? void 0 : ne[iterator]);
}
function readableStreamLikeToAsyncGenerator(ne) {
  return __asyncGenerator(this, arguments, function() {
    var ae, fe, ye, ve;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          ae = ne.getReader(), _e.label = 1;
        case 1:
          _e.trys.push([1, , 9, 10]), _e.label = 2;
        case 2:
          return [4, __await(ae.read())];
        case 3:
          return fe = _e.sent(), ye = fe.value, ve = fe.done, ve ? [4, __await(void 0)] : [3, 5];
        case 4:
          return [2, _e.sent()];
        case 5:
          return [4, __await(ye)];
        case 6:
          return [4, _e.sent()];
        case 7:
          return _e.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return ae.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(ne) {
  return isFunction$1(ne == null ? void 0 : ne.getReader);
}
function innerFrom(ne) {
  if (ne instanceof Observable)
    return ne;
  if (ne != null) {
    if (isInteropObservable(ne))
      return fromInteropObservable(ne);
    if (isArrayLike(ne))
      return fromArrayLike(ne);
    if (isPromise(ne))
      return fromPromise(ne);
    if (isAsyncIterable(ne))
      return fromAsyncIterable(ne);
    if (isIterable(ne))
      return fromIterable(ne);
    if (isReadableStreamLike(ne))
      return fromReadableStreamLike(ne);
  }
  throw createInvalidObservableTypeError(ne);
}
function fromInteropObservable(ne) {
  return new Observable(function(oe) {
    var ae = ne[observable$1]();
    if (isFunction$1(ae.subscribe))
      return ae.subscribe(oe);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(ne) {
  return new Observable(function(oe) {
    for (var ae = 0; ae < ne.length && !oe.closed; ae++)
      oe.next(ne[ae]);
    oe.complete();
  });
}
function fromPromise(ne) {
  return new Observable(function(oe) {
    ne.then(function(ae) {
      oe.closed || (oe.next(ae), oe.complete());
    }, function(ae) {
      return oe.error(ae);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(ne) {
  return new Observable(function(oe) {
    var ae, fe;
    try {
      for (var ye = __values(ne), ve = ye.next(); !ve.done; ve = ye.next()) {
        var _e = ve.value;
        if (oe.next(_e), oe.closed)
          return;
      }
    } catch (xe) {
      ae = { error: xe };
    } finally {
      try {
        ve && !ve.done && (fe = ye.return) && fe.call(ye);
      } finally {
        if (ae)
          throw ae.error;
      }
    }
    oe.complete();
  });
}
function fromAsyncIterable(ne) {
  return new Observable(function(oe) {
    process$1(ne, oe).catch(function(ae) {
      return oe.error(ae);
    });
  });
}
function fromReadableStreamLike(ne) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(ne));
}
function process$1(ne, oe) {
  var ae, fe, ye, ve;
  return __awaiter(this, void 0, void 0, function() {
    var _e, xe;
    return __generator(this, function(Oe) {
      switch (Oe.label) {
        case 0:
          Oe.trys.push([0, 5, 6, 11]), ae = __asyncValues(ne), Oe.label = 1;
        case 1:
          return [4, ae.next()];
        case 2:
          if (fe = Oe.sent(), !!fe.done)
            return [3, 4];
          if (_e = fe.value, oe.next(_e), oe.closed)
            return [2];
          Oe.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return xe = Oe.sent(), ye = { error: xe }, [3, 11];
        case 6:
          return Oe.trys.push([6, , 9, 10]), fe && !fe.done && (ve = ae.return) ? [4, ve.call(ae)] : [3, 8];
        case 7:
          Oe.sent(), Oe.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (ye)
            throw ye.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return oe.complete(), [2];
      }
    });
  });
}
function executeSchedule(ne, oe, ae, fe, ye) {
  fe === void 0 && (fe = 0), ye === void 0 && (ye = !1);
  var ve = oe.schedule(function() {
    ae(), ye ? ne.add(this.schedule(null, fe)) : this.unsubscribe();
  }, fe);
  if (ne.add(ve), !ye)
    return ve;
}
function observeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    ae.subscribe(createOperatorSubscriber(fe, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.next(ye);
      }, oe);
    }, function() {
      return executeSchedule(fe, ne, function() {
        return fe.complete();
      }, oe);
    }, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.error(ye);
      }, oe);
    }));
  });
}
function subscribeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    fe.add(ne.schedule(function() {
      return ae.subscribe(fe);
    }, oe));
  });
}
function scheduleObservable(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function schedulePromise(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function scheduleArray(ne, oe) {
  return new Observable(function(ae) {
    var fe = 0;
    return oe.schedule(function() {
      fe === ne.length ? ae.complete() : (ae.next(ne[fe++]), ae.closed || this.schedule());
    });
  });
}
function scheduleIterable(ne, oe) {
  return new Observable(function(ae) {
    var fe;
    return executeSchedule(ae, oe, function() {
      fe = ne[iterator](), executeSchedule(ae, oe, function() {
        var ye, ve, _e;
        try {
          ye = fe.next(), ve = ye.value, _e = ye.done;
        } catch (xe) {
          ae.error(xe);
          return;
        }
        _e ? ae.complete() : ae.next(ve);
      }, 0, !0);
    }), function() {
      return isFunction$1(fe == null ? void 0 : fe.return) && fe.return();
    };
  });
}
function scheduleAsyncIterable(ne, oe) {
  if (!ne)
    throw new Error("Iterable cannot be null");
  return new Observable(function(ae) {
    executeSchedule(ae, oe, function() {
      var fe = ne[Symbol.asyncIterator]();
      executeSchedule(ae, oe, function() {
        fe.next().then(function(ye) {
          ye.done ? ae.complete() : ae.next(ye.value);
        });
      }, 0, !0);
    });
  });
}
function scheduleReadableStreamLike(ne, oe) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(ne), oe);
}
function scheduled(ne, oe) {
  if (ne != null) {
    if (isInteropObservable(ne))
      return scheduleObservable(ne, oe);
    if (isArrayLike(ne))
      return scheduleArray(ne, oe);
    if (isPromise(ne))
      return schedulePromise(ne, oe);
    if (isAsyncIterable(ne))
      return scheduleAsyncIterable(ne, oe);
    if (isIterable(ne))
      return scheduleIterable(ne, oe);
    if (isReadableStreamLike(ne))
      return scheduleReadableStreamLike(ne, oe);
  }
  throw createInvalidObservableTypeError(ne);
}
function from(ne, oe) {
  return oe ? scheduled(ne, oe) : innerFrom(ne);
}
function of() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne);
  return from(ne, ae);
}
var EmptyError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function firstValueFrom(ne, oe) {
  var ae = typeof oe == "object";
  return new Promise(function(fe, ye) {
    var ve = new SafeSubscriber({
      next: function(_e) {
        fe(_e), ve.unsubscribe();
      },
      error: ye,
      complete: function() {
        ae ? fe(oe.defaultValue) : ye(new EmptyError());
      }
    });
    ne.subscribe(ve);
  });
}
function map(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(ve) {
      fe.next(ne.call(oe, ve, ye++));
    }));
  });
}
var isArray$1 = Array.isArray;
function callOrApply(ne, oe) {
  return isArray$1(oe) ? ne.apply(void 0, __spreadArray([], __read(oe))) : ne(oe);
}
function mapOneOrManyArgs(ne) {
  return map(function(oe) {
    return callOrApply(ne, oe);
  });
}
var isArray = Array.isArray, getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(ne) {
  if (ne.length === 1) {
    var oe = ne[0];
    if (isArray(oe))
      return { args: oe, keys: null };
    if (isPOJO(oe)) {
      var ae = getKeys(oe);
      return {
        args: ae.map(function(fe) {
          return oe[fe];
        }),
        keys: ae
      };
    }
  }
  return { args: ne, keys: null };
}
function isPOJO(ne) {
  return ne && typeof ne == "object" && getPrototypeOf(ne) === objectProto;
}
function createObject(ne, oe) {
  return ne.reduce(function(ae, fe, ye) {
    return ae[fe] = oe[ye], ae;
  }, {});
}
function combineLatest() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popResultSelector(ne), ye = argsArgArrayOrObject(ne), ve = ye.args, _e = ye.keys;
  if (ve.length === 0)
    return from([], ae);
  var xe = new Observable(combineLatestInit(ve, ae, _e ? function(Oe) {
    return createObject(_e, Oe);
  } : identity$1));
  return fe ? xe.pipe(mapOneOrManyArgs(fe)) : xe;
}
function combineLatestInit(ne, oe, ae) {
  return ae === void 0 && (ae = identity$1), function(fe) {
    maybeSchedule(oe, function() {
      for (var ye = ne.length, ve = new Array(ye), _e = ye, xe = ye, Oe = function(Me) {
        maybeSchedule(oe, function() {
          var Re = from(ne[Me], oe), je = !1;
          Re.subscribe(createOperatorSubscriber(fe, function(Be) {
            ve[Me] = Be, je || (je = !0, xe--), xe || fe.next(ae(ve.slice()));
          }, function() {
            --_e || fe.complete();
          }));
        }, fe);
      }, $e = 0; $e < ye; $e++)
        Oe($e);
    }, fe);
  };
}
function maybeSchedule(ne, oe, ae) {
  ne ? executeSchedule(ae, ne, oe) : oe();
}
function mergeInternals(ne, oe, ae, fe, ye, ve, _e, xe) {
  var Oe = [], $e = 0, Me = 0, Re = !1, je = function() {
    Re && !Oe.length && !$e && oe.complete();
  }, Be = function(He) {
    return $e < fe ? ze(He) : Oe.push(He);
  }, ze = function(He) {
    ve && oe.next(He), $e++;
    var qe = !1;
    innerFrom(ae(He, Me++)).subscribe(createOperatorSubscriber(oe, function(Ye) {
      ye == null || ye(Ye), ve ? Be(Ye) : oe.next(Ye);
    }, function() {
      qe = !0;
    }, void 0, function() {
      if (qe)
        try {
          $e--;
          for (var Ye = function() {
            var pt = Oe.shift();
            _e ? executeSchedule(oe, _e, function() {
              return ze(pt);
            }) : ze(pt);
          }; Oe.length && $e < fe; )
            Ye();
          je();
        } catch (pt) {
          oe.error(pt);
        }
    }));
  };
  return ne.subscribe(createOperatorSubscriber(oe, Be, function() {
    Re = !0, je();
  })), function() {
    xe == null || xe();
  };
}
function mergeMap(ne, oe, ae) {
  return ae === void 0 && (ae = 1 / 0), isFunction$1(oe) ? mergeMap(function(fe, ye) {
    return map(function(ve, _e) {
      return oe(fe, ve, ye, _e);
    })(innerFrom(ne(fe, ye)));
  }, ae) : (typeof oe == "number" && (ae = oe), operate(function(fe, ye) {
    return mergeInternals(fe, ye, ne, ae);
  }));
}
function mergeAll(ne) {
  return ne === void 0 && (ne = 1 / 0), mergeMap(identity$1, ne);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return concatAll()(from(ne, popScheduler(ne)));
}
function defer(ne) {
  return new Observable(function(oe) {
    innerFrom(ne()).subscribe(oe);
  });
}
function merge() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popNumber(ne, 1 / 0), ye = ne;
  return ye.length ? ye.length === 1 ? innerFrom(ye[0]) : mergeAll(fe)(from(ye, ae)) : EMPTY;
}
function filter(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(ve) {
      return ne.call(oe, ve, ye++) && fe.next(ve);
    }));
  });
}
function catchError(ne) {
  return operate(function(oe, ae) {
    var fe = null, ye = !1, ve;
    fe = oe.subscribe(createOperatorSubscriber(ae, void 0, void 0, function(_e) {
      ve = innerFrom(ne(_e, catchError(ne)(oe))), fe ? (fe.unsubscribe(), fe = null, ve.subscribe(ae)) : ye = !0;
    })), ye && (fe.unsubscribe(), fe = null, ve.subscribe(ae));
  });
}
function scanInternals(ne, oe, ae, fe, ye) {
  return function(ve, _e) {
    var xe = ae, Oe = oe, $e = 0;
    ve.subscribe(createOperatorSubscriber(_e, function(Me) {
      var Re = $e++;
      Oe = xe ? ne(Oe, Me, Re) : (xe = !0, Me), fe && _e.next(Oe);
    }, ye && function() {
      xe && _e.next(Oe), _e.complete();
    }));
  };
}
function concatMap(ne, oe) {
  return isFunction$1(oe) ? mergeMap(ne, oe, 1) : mergeMap(ne, 1);
}
function take(ne) {
  return ne <= 0 ? function() {
    return EMPTY;
  } : operate(function(oe, ae) {
    var fe = 0;
    oe.subscribe(createOperatorSubscriber(ae, function(ye) {
      ++fe <= ne && (ae.next(ye), ne <= fe && ae.complete());
    }));
  });
}
function scan(ne, oe) {
  return operate(scanInternals(ne, oe, arguments.length >= 2, !0));
}
function share(ne) {
  ne === void 0 && (ne = {});
  var oe = ne.connector, ae = oe === void 0 ? function() {
    return new Subject();
  } : oe, fe = ne.resetOnError, ye = fe === void 0 ? !0 : fe, ve = ne.resetOnComplete, _e = ve === void 0 ? !0 : ve, xe = ne.resetOnRefCountZero, Oe = xe === void 0 ? !0 : xe;
  return function($e) {
    var Me = null, Re = null, je = null, Be = 0, ze = !1, He = !1, qe = function() {
      Re == null || Re.unsubscribe(), Re = null;
    }, Ye = function() {
      qe(), Me = je = null, ze = He = !1;
    }, pt = function() {
      var dt = Me;
      Ye(), dt == null || dt.unsubscribe();
    };
    return operate(function(dt, yt) {
      Be++, !He && !ze && qe();
      var Ct = je = je ?? ae();
      yt.add(function() {
        Be--, Be === 0 && !He && !ze && (Re = handleReset(pt, Oe));
      }), Ct.subscribe(yt), Me || (Me = new SafeSubscriber({
        next: function(It) {
          return Ct.next(It);
        },
        error: function(It) {
          He = !0, qe(), Re = handleReset(Ye, ye, It), Ct.error(It);
        },
        complete: function() {
          ze = !0, qe(), Re = handleReset(Ye, _e), Ct.complete();
        }
      }), from(dt).subscribe(Me));
    })($e);
  };
}
function handleReset(ne, oe) {
  for (var ae = [], fe = 2; fe < arguments.length; fe++)
    ae[fe - 2] = arguments[fe];
  return oe === !0 ? (ne(), null) : oe === !1 ? null : oe.apply(void 0, __spreadArray([], __read(ae))).pipe(take(1)).subscribe(function() {
    return ne();
  });
}
function shareReplay(ne, oe, ae) {
  var fe, ye, ve, _e, xe = !1;
  return ne && typeof ne == "object" ? (fe = ne.bufferSize, _e = fe === void 0 ? 1 / 0 : fe, ye = ne.windowTime, oe = ye === void 0 ? 1 / 0 : ye, ve = ne.refCount, xe = ve === void 0 ? !1 : ve, ae = ne.scheduler) : _e = ne ?? 1 / 0, share({
    connector: function() {
      return new ReplaySubject(_e, oe, ae);
    },
    resetOnError: !0,
    resetOnComplete: !1,
    resetOnRefCountZero: xe
  });
}
function tap(ne, oe, ae) {
  var fe = isFunction$1(ne) || oe || ae ? { next: ne, error: oe, complete: ae } : ne;
  return fe ? operate(function(ye, ve) {
    var _e;
    (_e = fe.subscribe) === null || _e === void 0 || _e.call(fe);
    var xe = !0;
    ye.subscribe(createOperatorSubscriber(ve, function(Oe) {
      var $e;
      ($e = fe.next) === null || $e === void 0 || $e.call(fe, Oe), ve.next(Oe);
    }, function() {
      var Oe;
      xe = !1, (Oe = fe.complete) === null || Oe === void 0 || Oe.call(fe), ve.complete();
    }, function(Oe) {
      var $e;
      xe = !1, ($e = fe.error) === null || $e === void 0 || $e.call(fe, Oe), ve.error(Oe);
    }, function() {
      var Oe, $e;
      xe && ((Oe = fe.unsubscribe) === null || Oe === void 0 || Oe.call(fe)), ($e = fe.finalize) === null || $e === void 0 || $e.call(fe);
    }));
  }) : identity$1;
}
var g$4 = z$1("mud:block-events-stream"), k$4 = z$1("mud:block-events-stream");
g$4.log = console.debug.bind(console);
k$4.log = console.error.bind(console);
var p$2 = ["rate limit exceeded", "over rate limit", "sender is over rate limit"], B$1 = ["block range exceeded", "backend response too large", "block range is too large", "block is out of range"];
async function* u$1({ maxBlockRange: ne = 1000n, maxRetryCount: oe = 3, publicClient: ae, ...fe }) {
  let ye = fe.fromBlock, ve = l$6(ne, fe.toBlock - ye), _e = 0;
  for (; ye <= fe.toBlock; )
    try {
      let xe = ye + ve;
      g$4("getting logs", { fromBlock: ye, toBlock: xe });
      let Oe = await ae.getLogs({ ...fe, fromBlock: ye, toBlock: xe, strict: !0 });
      yield { fromBlock: ye, toBlock: xe, logs: Oe }, ye = xe + 1n, ve = l$6(ne, fe.toBlock - ye);
    } catch (xe) {
      if (g$4("error getting logs:", String(xe)), !(xe instanceof Error))
        throw xe;
      if (_e < oe && p$2.some((Oe) => xe.message.includes(Oe))) {
        let Oe = 2 * _e;
        g$4(`too many requests, retrying in ${Oe}s`, xe), await B$3(1e3 * Oe), _e += 1;
        continue;
      }
      if (B$1.some((Oe) => xe.message.includes(Oe))) {
        if (ve /= 2n, ve <= 0n)
          throw new Error("can't reduce block range any further");
        g$4("block range exceeded or too many logs in range, trying a smaller block range", xe);
        continue;
      }
      throw xe;
    }
}
function M$3({ publicClient: ne, blockTag: oe }) {
  return new Observable(function(ae) {
    return ne.watchBlocks({ blockTag: oe, emitOnBegin: !0, onBlock: (fe) => ae.next(fe), onError: (fe) => ae.error(fe) });
  });
}
function K$4(ne, oe) {
  let ae = Array.from(new Set(ne.map((ve) => ve.blockNumber)));
  ae.sort(s$1);
  let fe = ae.map((ve) => {
    let _e = ne.filter((xe) => xe.blockNumber === ve);
    if (_e.length && (_e.sort((xe, Oe) => xe.logIndex < Oe.logIndex ? -1 : xe.logIndex > Oe.logIndex ? 1 : 0), !!_e.length))
      return { blockNumber: ve, logs: _e };
  }).filter(b$7), ye = ae.length > 0 ? ae[ae.length - 1] : null;
  return oe != null && (ye == null || oe > ye) && fe.push({ blockNumber: oe, logs: [] }), fe;
}
function O(ne) {
  let oe = Object.values(ne.namespaces).flatMap((ae) => Object.values(ae.tables));
  return Object.fromEntries(oe.map((ae) => [ae.label, ae]));
}
var A$3 = { ...O(o$5), ...O(a$2) }, K$3 = Object.values(A$3).map((ne) => ne.tableId), L$2 = { ...A$3.Tables, keySchema: ia(Xi$1(A$3.Tables)), valueSchema: ia(Zi(A$3.Tables)) }, V$2 = ((ne) => (ne.INITIALIZE = "initialize", ne.SNAPSHOT = "snapshot", ne.RPC = "rpc", ne.LIVE = "live", ne))(V$2 || {});
function j$2(ne) {
  return { eventName: "Store_SetRecord", address: ne.address, args: { tableId: L$2.tableId, keyTuple: Yt(L$2.keySchema, { tableId: ne.tableId }), ...N$5(L$2.valueSchema, { fieldLayout: _i(ne.valueSchema), keySchema: zi(ne.keySchema), valueSchema: Ji(ne.valueSchema), abiEncodedKeyNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.keySchema)]), abiEncodedFieldNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.valueSchema)]) }) } };
}
function P$4(ne) {
  return [...ne.map(j$2), ...ne.flatMap((oe) => oe.records.map((ae) => ({ eventName: "Store_SetRecord", address: oe.address, args: { tableId: oe.tableId, keyTuple: Yt(ia(Xi$1(oe)), ae.key), ...N$5(ia(Zi(oe)), ae.value) } })))];
}
var S = z$1("mud:store-sync"), he$1 = z$1("mud:store-sync");
S.log = console.debug.bind(console);
he$1.log = console.error.bind(console);
var I$6 = S.extend("getSnapshot");
async function U$3({ chainId: ne, address: oe, filters: ae, initialState: fe, initialBlockLogs: ye, indexerUrl: ve }) {
  if (ye && fe)
    throw new Error("Only one of initialBlockLogs or initialState should be provided.");
  if (ye)
    return ye;
  if (fe)
    return { blockNumber: fe.blockNumber, logs: P$4(fe.tables) };
  if (!ve)
    return;
  let _e = new URL(ve).origin, xe = s$3({ url: _e }), Oe = g$8({ url: `${_e}/trpc` });
  I$6("fetching logs from indexer via get", ve);
  let $e = await xe.getLogs({ chainId: ne, address: oe, filters: ae });
  if (be($e))
    return $e.ok;
  console.warn($e.error);
  try {
    return I$6("fetching logs from indexer via trpc", ve), await Oe.getLogs.query({ chainId: ne, address: oe, filters: ae });
  } catch (Me) {
    if (Me instanceof TRPCClientError) {
      I$6("failed to fetch logs, fetching table records instead", ve);
      let Re = await Oe.findAll.query({ chainId: ne, address: oe, filters: ae });
      return console.warn(`The indexer at ${ve} appears to be outdated. Consider upgrading to a recent version for better performance.`), Re.blockNumber == null ? void 0 : { blockNumber: Re.blockNumber, logs: P$4(Re.tables) };
    }
    throw Me;
  }
}
async function* q$2({ storageAdapter: ne, logFilter: oe, ...ae }) {
  for await (let { logs: fe, toBlock: ye } of u$1(ae)) {
    let ve = K$4(oe ? fe.filter(oe) : fe, ye);
    for (let _e of ve)
      await ne(_e), yield _e;
  }
}
var m$2 = S.extend("createStoreSync"), We = K$3.map((ne) => ({ tableId: ne }));
async function Et({ storageAdapter: ne, onProgress: oe, publicClient: ae, address: fe, filters: ye = [], tableIds: ve = [], followBlockTag: _e = "latest", startBlock: xe = 0n, maxBlockRange: Oe, initialState: $e, initialBlockLogs: Me, indexerUrl: Re }) {
  let je = ye.length || ve.length ? [...ye, ...ve.map((er) => ({ tableId: er })), ...We] : [], Be = je.length ? (er) => je.some((hr) => hr.tableId === er.args.tableId && (hr.key0 == null || hr.key0 === er.args.keyTuple[0]) && (hr.key1 == null || hr.key1 === er.args.keyTuple[1])) : void 0, ze = defer(async () => {
    var Ot;
    let er = ((Ot = ae.chain) == null ? void 0 : Ot.id) ?? await ae.getChainId();
    oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Getting snapshot" });
    let hr = await U$3({ chainId: er, address: fe, filters: je, initialState: $e, initialBlockLogs: Me, indexerUrl: Re !== !1 ? Re ?? (ae.chain && "indexerUrl" in ae.chain && typeof ae.chain.indexerUrl == "string" ? ae.chain.indexerUrl : void 0) : void 0 });
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Got snapshot" }), hr;
  }).pipe(catchError((er) => (m$2("error getting snapshot", er), oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: xe, message: "Failed to get snapshot" }), of(void 0))), shareReplay(1)), He = ze.pipe(filter(b$7), concatMap(async ({ blockNumber: er, logs: hr }) => {
    m$2("hydrating", hr.length, "logs to block", er), oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: er, message: "Hydrating from snapshot" });
    let Ot = Math.max(100, Math.floor(hr.length / 50)), Qe = Array.from(m$6(hr, Ot));
    for (let [at, wt] of Qe.entries())
      await ne({ blockNumber: er, logs: wt }), oe == null || oe({ step: "snapshot", percentage: (at + 1) / Qe.length * 100, latestBlockNumber: 0n, lastBlockNumberProcessed: er, message: "Hydrating from snapshot" }), await N$7();
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: er, message: "Hydrated from snapshot" }), { blockNumber: er, logs: hr };
  }), shareReplay(1)), qe = ze.pipe(map((er) => a$5((er == null ? void 0 : er.blockNumber) ?? 0n, xe)), tap((er) => m$2("starting sync from block", er))), Ye = M$3({ publicClient: ae, blockTag: _e }).pipe(shareReplay(1)), pt = Ye.pipe(map((er) => er.number), tap((er) => {
    m$2("on block number", er, "for", _e, "block tag");
  }), shareReplay(1)), dt = null, yt = null, Ct = null, It = combineLatest([qe, pt]).pipe(map(([er, hr]) => ({ startBlock: er, endBlock: hr })), tap((er) => {
    dt = er.startBlock, yt = er.endBlock;
  }), concatMap((er) => {
    let hr = q$2({ publicClient: ae, address: fe, events: p$3, maxBlockRange: Oe, fromBlock: Ct ? a$5(er.startBlock, Ct + 1n) : er.startBlock, toBlock: er.endBlock, storageAdapter: ne, logFilter: Be });
    return from(hr);
  }), tap(({ blockNumber: er, logs: hr }) => {
    if (m$2("stored", hr.length, "logs for block", er), Ct = er, dt != null && yt != null)
      if (er < yt) {
        let Ot = yt - dt, Qe = Ct - dt;
        oe == null || oe({ step: "rpc", percentage: Number(Qe * 1000n / Ot) / 10, latestBlockNumber: yt, lastBlockNumberProcessed: Ct, message: "Hydrating from RPC" });
      } else
        oe == null || oe({ step: "live", percentage: 100, latestBlockNumber: yt, lastBlockNumberProcessed: Ct, message: "All caught up!" });
  }), share()), Vt = concat(He, It).pipe(share()), Ut = 10, Zt = Vt.pipe(scan((er, hr) => [hr, ...er].slice(0, Ut), []), filter((er) => er.length > 0), shareReplay(1));
  async function tr(er) {
    m$2("waiting for tx", er);
    let hr = Zt.pipe(mergeMap(async (Ot) => {
      for (let Qe of Ot)
        if (Qe.logs.map((at) => at.transactionHash).includes(er))
          return { blockNumber: Qe.blockNumber, status: "success", transactionHash: er };
      try {
        let Qe = Ot[0];
        m$2("fetching tx receipt for block", Qe.blockNumber);
        let { status: at, blockNumber: wt, transactionHash: bt } = await ae.getTransactionReceipt({ hash: er });
        if (Qe.blockNumber >= wt)
          return { status: at, blockNumber: wt, transactionHash: bt };
      } catch (Qe) {
        if (Qe instanceof TransactionReceiptNotFoundError)
          return;
        throw Qe;
      }
    }), tap((Ot) => m$2("has tx?", er, Ot)));
    return await firstValueFrom(hr.pipe(filter(b$7)));
  }
  return { latestBlock$: Ye, latestBlockNumber$: pt, storedBlockLogs$: Vt, waitForTransaction: tr };
}
function L$1(ne) {
  return ne.eventName === "Store_SetRecord" && ne.args.tableId === L$2.tableId;
}
function K$2(ne) {
  let [oe, ...ae] = ne.args.keyTuple;
  ae.length && console.warn("registerSchema event is expected to have only one key in key tuple, but got multiple", ne);
  let fe = _$4(oe), ye = j$4(L$2.valueSchema, concatHex$1([ne.args.staticData, ne.args.encodedLengths, ne.args.dynamicData])), ve = D$3(ye.keySchema), _e = D$3(ye.valueSchema), xe = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedKeyNames)[0], Oe = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedFieldNames)[0], $e = [..._e.staticFields, ..._e.dynamicFields], Me = Object.fromEntries(ve.staticFields.map((je, Be) => [xe[Be], { type: je, internalType: je }])), Re = Object.fromEntries($e.map((je, Be) => [Oe[Be], { type: je, internalType: je }]));
  return { address: ne.address, type: fe.type, namespace: fe.namespace, name: fe.name, tableId: oe, schema: { ...Me, ...Re }, key: Object.keys(Me), keySchema: ia(Me), valueSchema: ia(Re) };
}
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function ne(oe, ae) {
    return "Cannot apply '" + oe + "' to '" + ae.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function ne(oe, ae) {
    return "[mobx.array] Index out of bounds, " + oe + " is larger than " + ae;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function ne(oe) {
    return "Cannot initialize from classes that inherit from Map: " + oe.constructor.name;
  },
  20: function ne(oe) {
    return "Cannot initialize map from " + oe;
  },
  21: function ne(oe) {
    return "Cannot convert to map from '" + oe + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function ne(oe) {
    return "Cannot obtain administration from " + oe;
  },
  25: function ne(oe, ae) {
    return "the entry '" + oe + "' does not exist in the observable map '" + ae + "'";
  },
  26: "please specify a property",
  27: function ne(oe, ae) {
    return "no observable property '" + oe.toString() + "' found on the observable object '" + ae + "'";
  },
  28: function ne(oe) {
    return "Cannot obtain atom from " + oe;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function ne(oe, ae) {
    return "Cycle detected in computation " + oe + ": " + ae;
  },
  33: function ne(oe) {
    return "The setter of computed value '" + oe + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function ne(oe) {
    return "[ComputedValue '" + oe + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function ne(oe) {
    return "[mobx] `observableArray." + oe + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + oe + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
}, errors = process.env.NODE_ENV !== "production" ? niceErrors : {};
function die(ne) {
  for (var oe = arguments.length, ae = new Array(oe > 1 ? oe - 1 : 0), fe = 1; fe < oe; fe++)
    ae[fe - 1] = arguments[fe];
  if (process.env.NODE_ENV !== "production") {
    var ye = typeof ne == "string" ? ne : errors[ne];
    throw typeof ye == "function" && (ye = ye.apply(null, ae)), new Error("[MobX] " + ye);
  }
  throw new Error(typeof ne == "number" ? "[MobX] minified error nr: " + ne + (ae.length ? " " + ae.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + ne);
}
var mockGlobal = {};
function getGlobal() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : mockGlobal;
}
var assign = Object.assign, getDescriptor = Object.getOwnPropertyDescriptor, defineProperty = Object.defineProperty, objectPrototype = Object.prototype, EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy < "u", plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  hasProxy || die(process.env.NODE_ENV !== "production" ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
}
function warnAboutProxyRequirement(ne) {
  process.env.NODE_ENV !== "production" && globalState.verifyProxies && die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + ne);
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(ne) {
  var oe = !1;
  return function() {
    if (!oe)
      return oe = !0, ne.apply(this, arguments);
  };
}
var noop = function ne() {
};
function isFunction(ne) {
  return typeof ne == "function";
}
function isStringish(ne) {
  var oe = typeof ne;
  switch (oe) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function isObject(ne) {
  return ne !== null && typeof ne == "object";
}
function isPlainObject(ne) {
  if (!isObject(ne))
    return !1;
  var oe = Object.getPrototypeOf(ne);
  if (oe == null)
    return !0;
  var ae = Object.hasOwnProperty.call(oe, "constructor") && oe.constructor;
  return typeof ae == "function" && ae.toString() === plainObjectString;
}
function isGenerator(ne) {
  var oe = ne == null ? void 0 : ne.constructor;
  return oe ? oe.name === "GeneratorFunction" || oe.displayName === "GeneratorFunction" : !1;
}
function addHiddenProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: ae
  });
}
function addHiddenFinalProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: ae
  });
}
function createInstanceofPredicate(ne, oe) {
  var ae = "isMobX" + ne;
  return oe.prototype[ae] = !0, function(fe) {
    return isObject(fe) && fe[ae] === !0;
  };
}
function isES6Map(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Map]";
}
function isPlainES6Map(ne) {
  var oe = Object.getPrototypeOf(ne), ae = Object.getPrototypeOf(oe), fe = Object.getPrototypeOf(ae);
  return fe === null;
}
function isES6Set(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols < "u";
function getPlainObjectKeys(ne) {
  var oe = Object.keys(ne);
  if (!hasGetOwnPropertySymbols)
    return oe;
  var ae = Object.getOwnPropertySymbols(ne);
  return ae.length ? [].concat(oe, ae.filter(function(fe) {
    return objectPrototype.propertyIsEnumerable.call(ne, fe);
  })) : oe;
}
var ownKeys = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(ne) {
  return Object.getOwnPropertyNames(ne).concat(Object.getOwnPropertySymbols(ne));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function stringifyKey(ne) {
  return typeof ne == "string" ? ne : typeof ne == "symbol" ? ne.toString() : new String(ne).toString();
}
function toPrimitive(ne) {
  return ne === null ? null : typeof ne == "object" ? "" + ne : ne;
}
function hasProp(ne, oe) {
  return objectPrototype.hasOwnProperty.call(ne, oe);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function ne(oe) {
  var ae = {};
  return ownKeys(oe).forEach(function(fe) {
    ae[fe] = getDescriptor(oe, fe);
  }), ae;
};
function getFlag(ne, oe) {
  return !!(ne & oe);
}
function setFlag(ne, oe, ae) {
  return ae ? ne |= oe : ne &= ~oe, ne;
}
function _arrayLikeToArray(ne, oe) {
  (oe == null || oe > ne.length) && (oe = ne.length);
  for (var ae = 0, fe = Array(oe); ae < oe; ae++)
    fe[ae] = ne[ae];
  return fe;
}
function _defineProperties(ne, oe) {
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(ne, _toPropertyKey(fe.key), fe);
  }
}
function _createClass(ne, oe, ae) {
  return oe && _defineProperties(ne.prototype, oe), ae && _defineProperties(ne, ae), Object.defineProperty(ne, "prototype", {
    writable: !1
  }), ne;
}
function _createForOfIteratorHelperLoose(ne, oe) {
  var ae = typeof Symbol < "u" && ne[Symbol.iterator] || ne["@@iterator"];
  if (ae)
    return (ae = ae.call(ne)).next.bind(ae);
  if (Array.isArray(ne) || (ae = _unsupportedIterableToArray(ne)) || oe && ne && typeof ne.length == "number") {
    ae && (ne = ae);
    var fe = 0;
    return function() {
      return fe >= ne.length ? {
        done: !0
      } : {
        done: !1,
        value: ne[fe++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        ({}).hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(ne, oe) {
  ne.prototype = Object.create(oe.prototype), ne.prototype.constructor = ne, _setPrototypeOf(ne, oe);
}
function _setPrototypeOf(ne, oe) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ae, fe) {
    return ae.__proto__ = fe, ae;
  }, _setPrototypeOf(ne, oe);
}
function _toPrimitive(ne, oe) {
  if (typeof ne != "object" || !ne)
    return ne;
  var ae = ne[Symbol.toPrimitive];
  if (ae !== void 0) {
    var fe = ae.call(ne, oe || "default");
    if (typeof fe != "object")
      return fe;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (oe === "string" ? String : Number)(ne);
}
function _toPropertyKey(ne) {
  var oe = _toPrimitive(ne, "string");
  return typeof oe == "symbol" ? oe : oe + "";
}
function _unsupportedIterableToArray(ne, oe) {
  if (ne) {
    if (typeof ne == "string")
      return _arrayLikeToArray(ne, oe);
    var ae = {}.toString.call(ne).slice(8, -1);
    return ae === "Object" && ne.constructor && (ae = ne.constructor.name), ae === "Map" || ae === "Set" ? Array.from(ne) : ae === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ae) ? _arrayLikeToArray(ne, oe) : void 0;
  }
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(ne) {
  function oe(ae, fe) {
    if (is20223Decorator(fe))
      return ne.decorate_20223_(ae, fe);
    storeAnnotation(ae, fe, ne);
  }
  return Object.assign(oe, ne);
}
function storeAnnotation(ne, oe, ae) {
  if (hasProp(ne, storedAnnotationsSymbol) || addHiddenProp(ne, storedAnnotationsSymbol, _extends({}, ne[storedAnnotationsSymbol])), process.env.NODE_ENV !== "production" && isOverride(ae) && !hasProp(ne[storedAnnotationsSymbol], oe)) {
    var fe = ne.constructor.name + ".prototype." + oe.toString();
    die("'" + fe + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(ne, ae, oe), isOverride(ae) || (ne[storedAnnotationsSymbol][oe] = ae);
}
function assertNotDecorated(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne[storedAnnotationsSymbol], ae)) {
    var fe = ne.constructor.name + ".prototype." + ae.toString(), ye = ne[storedAnnotationsSymbol][ae].annotationType_, ve = oe.annotationType_;
    die("Cannot apply '@" + ve + "' to '" + fe + "':" + (`
The field is already decorated with '@` + ye + "'.") + `
Re-decorating fields is not allowed.
Use '@override' decorator for methods overridden by subclass.`);
  }
}
function is20223Decorator(ne) {
  return typeof ne == "object" && typeof ne.kind == "string";
}
function assert20223DecoratorType(ne, oe) {
  process.env.NODE_ENV !== "production" && !oe.includes(ne.kind) && die("The decorator applied to '" + String(ne.name) + "' cannot be used on a " + ne.kind + " element");
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration"), Atom = /* @__PURE__ */ function() {
  function ne(ae) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Atom@" + getNextId() : "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = ae;
  }
  var oe = ne.prototype;
  return oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.reportObserved = function() {
    return reportObserved(this);
  }, oe.reportChanged = function() {
    startBatch(), propagateChanged(this), endBatch();
  }, oe.toString = function() {
    return this.name_;
  }, _createClass(ne, [{
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(ne, oe, ae) {
  oe === void 0 && (oe = noop), ae === void 0 && (ae = noop);
  var fe = new Atom(ne);
  return oe !== noop && onBecomeObserved(fe, oe), ae !== noop && onBecomeUnobserved(fe, ae), fe;
}
function identityComparer(ne, oe) {
  return ne === oe;
}
function structuralComparer(ne, oe) {
  return deepEqual(ne, oe);
}
function shallowComparer(ne, oe) {
  return deepEqual(ne, oe, 1);
}
function defaultComparer(ne, oe) {
  return Object.is ? Object.is(ne, oe) : ne === oe ? ne !== 0 || 1 / ne === 1 / oe : ne !== ne && oe !== oe;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(ne, oe, ae) {
  return isObservable(ne) ? ne : Array.isArray(ne) ? observable.array(ne, {
    name: ae
  }) : isPlainObject(ne) ? observable.object(ne, void 0, {
    name: ae
  }) : isES6Map(ne) ? observable.map(ne, {
    name: ae
  }) : isES6Set(ne) ? observable.set(ne, {
    name: ae
  }) : typeof ne == "function" && !isAction(ne) && !isFlow(ne) ? isGenerator(ne) ? flow(ne) : autoAction(ae, ne) : ne;
}
function shallowEnhancer(ne, oe, ae) {
  if (ne == null || isObservableObject(ne) || isObservableArray(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (Array.isArray(ne))
    return observable.array(ne, {
      name: ae,
      deep: !1
    });
  if (isPlainObject(ne))
    return observable.object(ne, void 0, {
      name: ae,
      deep: !1
    });
  if (isES6Map(ne))
    return observable.map(ne, {
      name: ae,
      deep: !1
    });
  if (isES6Set(ne))
    return observable.set(ne, {
      name: ae,
      deep: !1
    });
  process.env.NODE_ENV !== "production" && die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(ne) {
  return ne;
}
function refStructEnhancer(ne, oe) {
  return process.env.NODE_ENV !== "production" && isObservable(ne) && die("observable.struct should not be used with observable values"), deepEqual(ne, oe) ? oe : ne;
}
var OVERRIDE = "override";
function isOverride(ne) {
  return ne.annotationType_ === OVERRIDE;
}
function createActionAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(ne, oe, ae, fe) {
  var ye;
  if ((ye = this.options_) != null && ye.bound)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if (isAction(ae.value))
    return 1;
  var ve = createActionDescriptor(ne, this, oe, ae, !1);
  return defineProperty(fe, oe, ve), 2;
}
function extend_$1(ne, oe, ae, fe) {
  var ye = createActionDescriptor(ne, this, oe, ae);
  return ne.defineProperty_(oe, ye, fe);
}
function decorate_20223_$1(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method", "field"]);
  var ae = oe.kind, fe = oe.name, ye = oe.addInitializer, ve = this, _e = function($e) {
    var Me, Re, je, Be;
    return createAction((Me = (Re = ve.options_) == null ? void 0 : Re.name) != null ? Me : fe.toString(), $e, (je = (Be = ve.options_) == null ? void 0 : Be.autoAction) != null ? je : !1);
  };
  if (ae == "field") {
    ye(function() {
      storeAnnotation(this, fe, ve);
    });
    return;
  }
  if (ae == "method") {
    var xe;
    return isAction(ne) || (ne = _e(ne)), (xe = this.options_) != null && xe.bound && ye(function() {
      var Oe = this, $e = Oe[fe].bind(Oe);
      $e.isMobxAction = !0, Oe[fe] = $e;
    }), ne;
  }
  die("Cannot apply '" + ve.annotationType_ + "' to '" + String(fe) + "' (kind: " + ae + "):" + (`
'` + ve.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ve = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(ve) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a function value."));
}
function createActionDescriptor(ne, oe, ae, fe, ye) {
  var ve, _e, xe, Oe, $e, Me, Re;
  ye === void 0 && (ye = globalState.safeDescriptors), assertActionDescriptor(ne, oe, ae, fe);
  var je = fe.value;
  if ((ve = oe.options_) != null && ve.bound) {
    var Be;
    je = je.bind((Be = ne.proxy_) != null ? Be : ne.target_);
  }
  return {
    value: createAction(
      (_e = (xe = oe.options_) == null ? void 0 : xe.name) != null ? _e : ae.toString(),
      je,
      (Oe = ($e = oe.options_) == null ? void 0 : $e.autoAction) != null ? Oe : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (Me = oe.options_) != null && Me.bound ? (Re = ne.proxy_) != null ? Re : ne.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: ye ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !ye
  };
}
function createFlowAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(ne, oe, ae, fe) {
  var ye;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if ((ye = this.options_) != null && ye.bound && (!hasProp(ne.target_, oe) || !isFlow(ne.target_[oe])) && this.extend_(ne, oe, ae, !1) === null)
    return 0;
  if (isFlow(ae.value))
    return 1;
  var ve = createFlowDescriptor(ne, this, oe, ae, !1, !1);
  return defineProperty(fe, oe, ve), 2;
}
function extend_$2(ne, oe, ae, fe) {
  var ye, ve = createFlowDescriptor(ne, this, oe, ae, (ye = this.options_) == null ? void 0 : ye.bound);
  return ne.defineProperty_(oe, ve, fe);
}
function decorate_20223_$2(ne, oe) {
  var ae;
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method"]);
  var fe = oe.name, ye = oe.addInitializer;
  return isFlow(ne) || (ne = flow(ne)), (ae = this.options_) != null && ae.bound && ye(function() {
    var ve = this, _e = ve[fe].bind(ve);
    _e.isMobXFlow = !0, ve[fe] = _e;
  }), ne;
}
function assertFlowDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ve = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(ve) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a generator function value."));
}
function createFlowDescriptor(ne, oe, ae, fe, ye, ve) {
  ve === void 0 && (ve = globalState.safeDescriptors), assertFlowDescriptor(ne, oe, ae, fe);
  var _e = fe.value;
  if (isFlow(_e) || (_e = flow(_e)), ye) {
    var xe;
    _e = _e.bind((xe = ne.proxy_) != null ? xe : ne.target_), _e.isMobXFlow = !0;
  }
  return {
    value: _e,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: ve ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !ve
  };
}
function createComputedAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$3(ne, oe, ae, fe) {
  return assertComputedDescriptor(ne, this, oe, ae), ne.defineComputedProperty_(oe, _extends({}, this.options_, {
    get: ae.get,
    set: ae.set
  }), fe);
}
function decorate_20223_$3(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["getter"]);
  var ae = this, fe = oe.name, ye = oe.addInitializer;
  return ye(function() {
    var ve = asObservableObject(this)[$mobx], _e = _extends({}, ae.options_, {
      get: ne,
      context: this
    });
    _e.name || (_e.name = process.env.NODE_ENV !== "production" ? ve.name_ + "." + fe.toString() : "ObservableObject." + fe.toString()), ve.values_.set(fe, new ComputedValue(_e));
  }), function() {
    return this[$mobx].getObservablePropValue_(fe);
  };
}
function assertComputedDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ve = fe.get;
  process.env.NODE_ENV !== "production" && !ve && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on getter(+setter) properties."));
}
function createObservableAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$4(ne, oe, ae, fe) {
  var ye, ve;
  return assertObservableDescriptor(ne, this, oe, ae), ne.defineObservableProperty_(oe, ae.value, (ye = (ve = this.options_) == null ? void 0 : ve.enhancer) != null ? ye : deepEnhancer, fe);
}
function decorate_20223_$4(ne, oe) {
  if (process.env.NODE_ENV !== "production") {
    if (oe.kind === "field")
      throw die("Please use `@observable accessor " + String(oe.name) + "` instead of `@observable " + String(oe.name) + "`");
    assert20223DecoratorType(oe, ["accessor"]);
  }
  var ae = this, fe = oe.kind, ye = oe.name, ve = /* @__PURE__ */ new WeakSet();
  function _e(xe, Oe) {
    var $e, Me, Re = asObservableObject(xe)[$mobx], je = new ObservableValue(Oe, ($e = (Me = ae.options_) == null ? void 0 : Me.enhancer) != null ? $e : deepEnhancer, process.env.NODE_ENV !== "production" ? Re.name_ + "." + ye.toString() : "ObservableObject." + ye.toString(), !1);
    Re.values_.set(ye, je), ve.add(xe);
  }
  if (fe == "accessor")
    return {
      get: function() {
        return ve.has(this) || _e(this, ne.get.call(this)), this[$mobx].getObservablePropValue_(ye);
      },
      set: function(Oe) {
        return ve.has(this) || _e(this, Oe), this[$mobx].setObservablePropValue_(ye, Oe);
      },
      init: function(Oe) {
        return ve.has(this) || _e(this, Oe), Oe;
      }
    };
}
function assertObservableDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_;
  process.env.NODE_ENV !== "production" && !("value" in fe) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' cannot be used on getter/setter properties"));
}
var AUTO = "true", autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(ne) {
  return {
    annotationType_: AUTO,
    options_: ne,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(ne, oe, ae, fe) {
  var ye, ve;
  if (ae.get)
    return computed.make_(ne, oe, ae, fe);
  if (ae.set) {
    var _e = createAction(oe.toString(), ae.set);
    return fe === ne.target_ ? ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: _e
    }) === null ? 0 : 2 : (defineProperty(fe, oe, {
      configurable: !0,
      set: _e
    }), 2);
  }
  if (fe !== ne.target_ && typeof ae.value == "function") {
    var xe;
    if (isGenerator(ae.value)) {
      var Oe, $e = (Oe = this.options_) != null && Oe.autoBind ? flow.bound : flow;
      return $e.make_(ne, oe, ae, fe);
    }
    var Me = (xe = this.options_) != null && xe.autoBind ? autoAction.bound : autoAction;
    return Me.make_(ne, oe, ae, fe);
  }
  var Re = ((ye = this.options_) == null ? void 0 : ye.deep) === !1 ? observable.ref : observable;
  if (typeof ae.value == "function" && (ve = this.options_) != null && ve.autoBind) {
    var je;
    ae.value = ae.value.bind((je = ne.proxy_) != null ? je : ne.target_);
  }
  return Re.make_(ne, oe, ae, fe);
}
function extend_$5(ne, oe, ae, fe) {
  var ye, ve;
  if (ae.get)
    return computed.extend_(ne, oe, ae, fe);
  if (ae.set)
    return ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: createAction(oe.toString(), ae.set)
    }, fe);
  if (typeof ae.value == "function" && (ye = this.options_) != null && ye.autoBind) {
    var _e;
    ae.value = ae.value.bind((_e = ne.proxy_) != null ? _e : ne.target_);
  }
  var xe = ((ve = this.options_) == null ? void 0 : ve.deep) === !1 ? observable.ref : observable;
  return xe.extend_(ne, oe, ae, fe);
}
function decorate_20223_$5(ne, oe) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable", OBSERVABLE_REF = "observable.ref", OBSERVABLE_SHALLOW = "observable.shallow", OBSERVABLE_STRUCT = "observable.struct", defaultCreateObservableOptions = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(ne) {
  return ne || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE), observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
}), observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
}), observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
}), observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(ne) {
  return ne.deep === !0 ? deepEnhancer : ne.deep === !1 ? referenceEnhancer : getEnhancerFromAnnotation(ne.defaultDecorator);
}
function getAnnotationFromOptions(ne) {
  var oe;
  return ne ? (oe = ne.defaultDecorator) != null ? oe : createAutoAnnotation(ne) : void 0;
}
function getEnhancerFromAnnotation(ne) {
  var oe, ae;
  return ne && (oe = (ae = ne.options_) == null ? void 0 : ae.enhancer) != null ? oe : deepEnhancer;
}
function createObservable(ne, oe, ae) {
  if (is20223Decorator(oe))
    return observableAnnotation.decorate_20223_(ne, oe);
  if (isStringish(oe)) {
    storeAnnotation(ne, oe, observableAnnotation);
    return;
  }
  return isObservable(ne) ? ne : isPlainObject(ne) ? observable.object(ne, oe, ae) : Array.isArray(ne) ? observable.array(ne, oe) : isES6Map(ne) ? observable.map(ne, oe) : isES6Set(ne) ? observable.set(ne, oe) : typeof ne == "object" && ne !== null ? ne : observable.box(ne, oe);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableValue(oe, getEnhancerFromOptions(fe), fe.name, !0, fe.equals);
  },
  array: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return (globalState.useProxies === !1 || fe.proxy === !1 ? createLegacyArray : createObservableArray)(oe, getEnhancerFromOptions(fe), fe.name);
  },
  map: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableMap(oe, getEnhancerFromOptions(fe), fe.name);
  },
  set: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableSet(oe, getEnhancerFromOptions(fe), fe.name);
  },
  object: function ne(oe, ae, fe) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === !1 || (fe == null ? void 0 : fe.proxy) === !1 ? asObservableObject({}, fe) : asDynamicObservableObject({}, fe), oe, ae);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
}, observable = /* @__PURE__ */ assign(createObservable, observableFactories), COMPUTED = "computed", COMPUTED_STRUCT = "computed.struct", computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED), computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
}), computed = function ne(oe, ae) {
  if (is20223Decorator(ae))
    return computedAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, computedAnnotation);
  if (isPlainObject(oe))
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, oe));
  process.env.NODE_ENV !== "production" && (isFunction(oe) || die("First argument to `computed` should be an expression."), isFunction(ae) && die("A setter as second argument is no longer supported, use `{ set: fn }` option instead"));
  var fe = isPlainObject(ae) ? ae : {};
  return fe.get = oe, fe.name || (fe.name = oe.name || ""), new ComputedValue(fe);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor, currentActionId = 0, nextActionId = 1, isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : !1, tmpNameDescriptor = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function createAction(ne, oe, ae, fe) {
  ae === void 0 && (ae = !1), process.env.NODE_ENV !== "production" && (isFunction(oe) || die("`action` can only be invoked on functions"), (typeof ne != "string" || !ne) && die("actions should have valid names, got: '" + ne + "'"));
  function ye() {
    return executeAction(ne, ae, oe, fe || this, arguments);
  }
  return ye.isMobxAction = !0, ye.toString = function() {
    return oe.toString();
  }, isFunctionNameConfigurable && (tmpNameDescriptor.value = ne, defineProperty(ye, "name", tmpNameDescriptor)), ye;
}
function executeAction(ne, oe, ae, fe, ye) {
  var ve = _startAction(ne, oe, fe, ye);
  try {
    return ae.apply(fe, ye);
  } catch (_e) {
    throw ve.error_ = _e, _e;
  } finally {
    _endAction(ve);
  }
}
function _startAction(ne, oe, ae, fe) {
  var ye = process.env.NODE_ENV !== "production" && isSpyEnabled() && !!ne, ve = 0;
  if (process.env.NODE_ENV !== "production" && ye) {
    ve = Date.now();
    var _e = fe ? Array.from(fe) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: ne,
      object: ae,
      arguments: _e
    });
  }
  var xe = globalState.trackingDerivation, Oe = !oe || !xe;
  startBatch();
  var $e = globalState.allowStateChanges;
  Oe && (untrackedStart(), $e = allowStateChangesStart(!0));
  var Me = allowStateReadsStart(!0), Re = {
    runAsAction_: Oe,
    prevDerivation_: xe,
    prevAllowStateChanges_: $e,
    prevAllowStateReads_: Me,
    notifySpy_: ye,
    startTime_: ve,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  return currentActionId = Re.actionId_, Re;
}
function _endAction(ne) {
  currentActionId !== ne.actionId_ && die(30), currentActionId = ne.parentActionId_, ne.error_ !== void 0 && (globalState.suppressReactionErrors = !0), allowStateChangesEnd(ne.prevAllowStateChanges_), allowStateReadsEnd(ne.prevAllowStateReads_), endBatch(), ne.runAsAction_ && untrackedEnd(ne.prevDerivation_), process.env.NODE_ENV !== "production" && ne.notifySpy_ && spyReportEnd({
    time: Date.now() - ne.startTime_
  }), globalState.suppressReactionErrors = !1;
}
function allowStateChangesStart(ne) {
  var oe = globalState.allowStateChanges;
  return globalState.allowStateChanges = ne, oe;
}
function allowStateChangesEnd(ne) {
  globalState.allowStateChanges = ne;
}
var CREATE = "create", ObservableValue = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, ve, _e, xe) {
    var Oe;
    return ve === void 0 && (ve = process.env.NODE_ENV !== "production" ? "ObservableValue@" + getNextId() : "ObservableValue"), _e === void 0 && (_e = !0), xe === void 0 && (xe = comparer.default), Oe = ne.call(this, ve) || this, Oe.enhancer = void 0, Oe.name_ = void 0, Oe.equals = void 0, Oe.hasUnreportedChange_ = !1, Oe.interceptors_ = void 0, Oe.changeListeners_ = void 0, Oe.value_ = void 0, Oe.dehancer = void 0, Oe.enhancer = ye, Oe.name_ = ve, Oe.equals = xe, Oe.value_ = ye(fe, void 0, ve), process.env.NODE_ENV !== "production" && _e && isSpyEnabled() && spyReport({
      type: CREATE,
      object: Oe,
      observableKind: "value",
      debugObjectName: Oe.name_,
      newValue: "" + Oe.value_
    }), Oe;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.dehanceValue = function(ye) {
    return this.dehancer !== void 0 ? this.dehancer(ye) : ye;
  }, ae.set = function(ye) {
    var ve = this.value_;
    if (ye = this.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var _e = isSpyEnabled();
      process.env.NODE_ENV !== "production" && _e && spyReportStart({
        type: UPDATE,
        object: this,
        observableKind: "value",
        debugObjectName: this.name_,
        newValue: ye,
        oldValue: ve
      }), this.setNewValue_(ye), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
    }
  }, ae.prepareNewValue_ = function(ye) {
    if (checkIfStateModificationsAreAllowed(this), hasInterceptors(this)) {
      var ve = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: ye
      });
      if (!ve)
        return globalState.UNCHANGED;
      ye = ve.newValue;
    }
    return ye = this.enhancer(ye, this.value_, this.name_), this.equals(this.value_, ye) ? globalState.UNCHANGED : ye;
  }, ae.setNewValue_ = function(ye) {
    var ve = this.value_;
    this.value_ = ye, this.reportChanged(), hasListeners(this) && notifyListeners(this, {
      type: UPDATE,
      object: this,
      newValue: ye,
      oldValue: ve
    });
  }, ae.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, ae.intercept_ = function(ye) {
    return registerInterceptor(this, ye);
  }, ae.observe_ = function(ye, ve) {
    return ve && ye({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: void 0
    }), registerListener(this, ye);
  }, ae.raw = function() {
    return this.value_;
  }, ae.toJSON = function() {
    return this.get();
  }, ae.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, ae.valueOf = function() {
    return toPrimitive(this.get());
  }, ae[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, oe;
}(Atom), ComputedValue = /* @__PURE__ */ function() {
  function ne(ae) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new CaughtException(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = TraceMode.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, ae.get || die(31), this.derivation = ae.get, this.name_ = ae.name || (process.env.NODE_ENV !== "production" ? "ComputedValue@" + getNextId() : "ComputedValue"), ae.set && (this.setter_ = createAction(process.env.NODE_ENV !== "production" ? this.name_ + "-setter" : "ComputedValue-setter", ae.set)), this.equals_ = ae.equals || (ae.compareStructural || ae.struct ? comparer.structural : comparer.default), this.scope_ = ae.context, this.requiresReaction_ = ae.requiresReaction, this.keepAlive_ = !!ae.keepAlive;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    propagateMaybeChanged(this);
  }, oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.get = function() {
    if (this.isComputing && die(32, this.name_, this.derivation), globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      shouldCompute(this) && (this.warnAboutUntrackedRead_(), startBatch(), this.value_ = this.computeValue_(!1), endBatch());
    else if (reportObserved(this), shouldCompute(this)) {
      var fe = globalState.trackingContext;
      this.keepAlive_ && !fe && (globalState.trackingContext = this), this.trackAndCompute() && propagateChangeConfirmed(this), globalState.trackingContext = fe;
    }
    var ye = this.value_;
    if (isCaughtException(ye))
      throw ye.cause;
    return ye;
  }, oe.set = function(fe) {
    if (this.setter_) {
      this.isRunningSetter && die(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, fe);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      die(34, this.name_);
  }, oe.trackAndCompute = function() {
    var fe = this.value_, ye = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    ), ve = this.computeValue_(!0), _e = ye || isCaughtException(fe) || isCaughtException(ve) || !this.equals_(fe, ve);
    return _e && (this.value_ = ve, process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      observableKind: "computed",
      debugObjectName: this.name_,
      object: this.scope_,
      type: "update",
      oldValue: fe,
      newValue: ve
    })), _e;
  }, oe.computeValue_ = function(fe) {
    this.isComputing = !0;
    var ye = allowStateChangesStart(!1), ve;
    if (fe)
      ve = trackDerivedFunction(this, this.derivation, this.scope_);
    else if (globalState.disableErrorBoundaries === !0)
      ve = this.derivation.call(this.scope_);
    else
      try {
        ve = this.derivation.call(this.scope_);
      } catch (_e) {
        ve = new CaughtException(_e);
      }
    return allowStateChangesEnd(ye), this.isComputing = !1, ve;
  }, oe.suspend_ = function() {
    this.keepAlive_ || (clearObserving(this), this.value_ = void 0, process.env.NODE_ENV !== "production" && this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access."));
  }, oe.observe_ = function(fe, ye) {
    var ve = this, _e = !0, xe = void 0;
    return autorun(function() {
      var Oe = ve.get();
      if (!_e || ye) {
        var $e = untrackedStart();
        fe({
          observableKind: "computed",
          debugObjectName: ve.name_,
          type: UPDATE,
          object: ve,
          newValue: Oe,
          oldValue: xe
        }), untrackedEnd($e);
      }
      _e = !1, xe = Oe;
    });
  }, oe.warnAboutUntrackedRead_ = function() {
    process.env.NODE_ENV !== "production" && (this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."), (typeof this.requiresReaction_ == "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) && console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."));
  }, oe.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, oe.valueOf = function() {
    return toPrimitive(this.get());
  }, oe[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, _createClass(ne, [{
    key: "isComputing",
    get: function() {
      return getFlag(this.flags_, ne.isComputingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isComputingMask_, fe);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return getFlag(this.flags_, ne.isRunningSetterMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningSetterMask_, fe);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue), IDerivationState_;
(function(ne) {
  ne[ne.NOT_TRACKING_ = -1] = "NOT_TRACKING_", ne[ne.UP_TO_DATE_ = 0] = "UP_TO_DATE_", ne[ne.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", ne[ne.STALE_ = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(ne) {
  ne[ne.NONE = 0] = "NONE", ne[ne.LOG = 1] = "LOG", ne[ne.BREAK = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function ne(oe) {
  this.cause = void 0, this.cause = oe;
};
function isCaughtException(ne) {
  return ne instanceof CaughtException;
}
function shouldCompute(ne) {
  switch (ne.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return !1;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return !0;
    case IDerivationState_.POSSIBLY_STALE_: {
      for (var oe = allowStateReadsStart(!0), ae = untrackedStart(), fe = ne.observing_, ye = fe.length, ve = 0; ve < ye; ve++) {
        var _e = fe[ve];
        if (isComputedValue(_e)) {
          if (globalState.disableErrorBoundaries)
            _e.get();
          else
            try {
              _e.get();
            } catch {
              return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
            }
          if (ne.dependenciesState_ === IDerivationState_.STALE_)
            return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
        }
      }
      return changeDependenciesStateTo0(ne), untrackedEnd(ae), allowStateReadsEnd(oe), !1;
    }
  }
}
function checkIfStateModificationsAreAllowed(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = ne.observers_.size > 0;
    !globalState.allowStateChanges && (oe || globalState.enforceActions === "always") && console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + ne.name_);
  }
}
function checkIfStateReadsAreAllowed(ne) {
  process.env.NODE_ENV !== "production" && !globalState.allowStateReads && globalState.observableRequiresReaction && console.warn("[mobx] Observable '" + ne.name_ + "' being read outside a reactive context.");
}
function trackDerivedFunction(ne, oe, ae) {
  var fe = allowStateReadsStart(!0);
  changeDependenciesStateTo0(ne), ne.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    ne.runId_ === 0 ? 100 : ne.observing_.length
  ), ne.unboundDepsCount_ = 0, ne.runId_ = ++globalState.runId;
  var ye = globalState.trackingDerivation;
  globalState.trackingDerivation = ne, globalState.inBatch++;
  var ve;
  if (globalState.disableErrorBoundaries === !0)
    ve = oe.call(ae);
  else
    try {
      ve = oe.call(ae);
    } catch (_e) {
      ve = new CaughtException(_e);
    }
  return globalState.inBatch--, globalState.trackingDerivation = ye, bindDependencies(ne), warnAboutDerivationWithoutDependencies(ne), allowStateReadsEnd(fe), ve;
}
function warnAboutDerivationWithoutDependencies(ne) {
  process.env.NODE_ENV !== "production" && ne.observing_.length === 0 && (typeof ne.requiresObservable_ == "boolean" ? ne.requiresObservable_ : globalState.reactionRequiresObservable) && console.warn("[mobx] Derivation '" + ne.name_ + "' is created/updated without reading any observable value.");
}
function bindDependencies(ne) {
  for (var oe = ne.observing_, ae = ne.observing_ = ne.newObserving_, fe = IDerivationState_.UP_TO_DATE_, ye = 0, ve = ne.unboundDepsCount_, _e = 0; _e < ve; _e++) {
    var xe = ae[_e];
    xe.diffValue === 0 && (xe.diffValue = 1, ye !== _e && (ae[ye] = xe), ye++), xe.dependenciesState_ > fe && (fe = xe.dependenciesState_);
  }
  for (ae.length = ye, ne.newObserving_ = null, ve = oe.length; ve--; ) {
    var Oe = oe[ve];
    Oe.diffValue === 0 && removeObserver(Oe, ne), Oe.diffValue = 0;
  }
  for (; ye--; ) {
    var $e = ae[ye];
    $e.diffValue === 1 && ($e.diffValue = 0, addObserver($e, ne));
  }
  fe !== IDerivationState_.UP_TO_DATE_ && (ne.dependenciesState_ = fe, ne.onBecomeStale_());
}
function clearObserving(ne) {
  var oe = ne.observing_;
  ne.observing_ = [];
  for (var ae = oe.length; ae--; )
    removeObserver(oe[ae], ne);
  ne.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(ne) {
  var oe = untrackedStart();
  try {
    return ne();
  } finally {
    untrackedEnd(oe);
  }
}
function untrackedStart() {
  var ne = globalState.trackingDerivation;
  return globalState.trackingDerivation = null, ne;
}
function untrackedEnd(ne) {
  globalState.trackingDerivation = ne;
}
function allowStateReadsStart(ne) {
  var oe = globalState.allowStateReads;
  return globalState.allowStateReads = ne, oe;
}
function allowStateReadsEnd(ne) {
  globalState.allowStateReads = ne;
}
function changeDependenciesStateTo0(ne) {
  if (ne.dependenciesState_ !== IDerivationState_.UP_TO_DATE_) {
    ne.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    for (var oe = ne.observing_, ae = oe.length; ae--; )
      oe[ae].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function ne() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, canMergeGlobalState = !0, globalState = /* @__PURE__ */ function() {
  var ne = /* @__PURE__ */ getGlobal();
  return ne.__mobxInstanceCount > 0 && !ne.__mobxGlobals && (canMergeGlobalState = !1), ne.__mobxGlobals && ne.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = !1), canMergeGlobalState ? ne.__mobxGlobals ? (ne.__mobxInstanceCount += 1, ne.__mobxGlobals.UNCHANGED || (ne.__mobxGlobals.UNCHANGED = {}), ne.__mobxGlobals) : (ne.__mobxInstanceCount = 1, ne.__mobxGlobals = /* @__PURE__ */ new MobXGlobals()) : (setTimeout(function() {
    die(35);
  }, 1), new MobXGlobals());
}();
function addObserver(ne, oe) {
  ne.observers_.add(oe), ne.lowestObserverState_ > oe.dependenciesState_ && (ne.lowestObserverState_ = oe.dependenciesState_);
}
function removeObserver(ne, oe) {
  ne.observers_.delete(oe), ne.observers_.size === 0 && queueForUnobservation(ne);
}
function queueForUnobservation(ne) {
  ne.isPendingUnobservation === !1 && (ne.isPendingUnobservation = !0, globalState.pendingUnobservations.push(ne));
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    for (var ne = globalState.pendingUnobservations, oe = 0; oe < ne.length; oe++) {
      var ae = ne[oe];
      ae.isPendingUnobservation = !1, ae.observers_.size === 0 && (ae.isBeingObserved && (ae.isBeingObserved = !1, ae.onBUO()), ae instanceof ComputedValue && ae.suspend_());
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(ne) {
  checkIfStateReadsAreAllowed(ne);
  var oe = globalState.trackingDerivation;
  return oe !== null ? (oe.runId_ !== ne.lastAccessedBy_ && (ne.lastAccessedBy_ = oe.runId_, oe.newObserving_[oe.unboundDepsCount_++] = ne, !ne.isBeingObserved && globalState.trackingContext && (ne.isBeingObserved = !0, ne.onBO())), ne.isBeingObserved) : (ne.observers_.size === 0 && globalState.inBatch > 0 && queueForUnobservation(ne), !1);
}
function propagateChanged(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne), oe.onBecomeStale_()), oe.dependenciesState_ = IDerivationState_.STALE_;
  }));
}
function propagateChangeConfirmed(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_ ? (oe.dependenciesState_ = IDerivationState_.STALE_, process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne)) : oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.UP_TO_DATE_);
  }));
}
function propagateMaybeChanged(ne) {
  ne.lowestObserverState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (oe.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_, oe.onBecomeStale_());
  }));
}
function logTraceInfo(ne, oe) {
  if (console.log("[mobx.trace] '" + ne.name_ + "' is invalidated due to a change in: '" + oe.name_ + "'"), ne.isTracing_ === TraceMode.BREAK) {
    var ae = [];
    printDepTree(getDependencyTree(ne), ae, 1), new Function(`debugger;
/*
Tracing '` + ne.name_ + `'

You are entering this break point because derivation '` + ne.name_ + "' is being traced and '" + oe.name_ + `' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

` + (ne instanceof ComputedValue ? ne.derivation.toString().replace(/[*]\//g, "/") : "") + `

The dependencies for this derivation are:

` + ae.join(`
`) + `
*/
    `)();
  }
}
function printDepTree(ne, oe, ae) {
  if (oe.length >= 1e3) {
    oe.push("(and many more)");
    return;
  }
  oe.push("" + "	".repeat(ae - 1) + ne.name), ne.dependencies && ne.dependencies.forEach(function(fe) {
    return printDepTree(fe, oe, ae + 1);
  });
}
var Reaction = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ve) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Reaction@" + getNextId() : "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = TraceMode.NONE, this.name_ = ae, this.onInvalidate_ = fe, this.errorHandler_ = ye, this.requiresObservable_ = ve;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    this.schedule_();
  }, oe.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, globalState.pendingReactions.push(this), runReactions());
  }, oe.runReaction_ = function() {
    if (!this.isDisposed) {
      startBatch(), this.isScheduled = !1;
      var fe = globalState.trackingContext;
      if (globalState.trackingContext = this, shouldCompute(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_(), process.env.NODE_ENV !== "production" && this.isTrackPending && isSpyEnabled() && spyReport({
            name: this.name_,
            type: "scheduled-reaction"
          });
        } catch (ye) {
          this.reportExceptionInDerivation_(ye);
        }
      }
      globalState.trackingContext = fe, endBatch();
    }
  }, oe.track = function(fe) {
    if (!this.isDisposed) {
      startBatch();
      var ye = isSpyEnabled(), ve;
      process.env.NODE_ENV !== "production" && ye && (ve = Date.now(), spyReportStart({
        name: this.name_,
        type: "reaction"
      })), this.isRunning = !0;
      var _e = globalState.trackingContext;
      globalState.trackingContext = this;
      var xe = trackDerivedFunction(this, fe, void 0);
      globalState.trackingContext = _e, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && clearObserving(this), isCaughtException(xe) && this.reportExceptionInDerivation_(xe.cause), process.env.NODE_ENV !== "production" && ye && spyReportEnd({
        time: Date.now() - ve
      }), endBatch();
    }
  }, oe.reportExceptionInDerivation_ = function(fe) {
    var ye = this;
    if (this.errorHandler_) {
      this.errorHandler_(fe, this);
      return;
    }
    if (globalState.disableErrorBoundaries)
      throw fe;
    var ve = process.env.NODE_ENV !== "production" ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    globalState.suppressReactionErrors ? process.env.NODE_ENV !== "production" && console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(ve, fe), process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      type: "error",
      name: this.name_,
      message: ve,
      error: "" + fe
    }), globalState.globalReactionErrorHandlers.forEach(function(_e) {
      return _e(fe, ye);
    });
  }, oe.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (startBatch(), clearObserving(this), endBatch()));
  }, oe.getDisposer_ = function(fe) {
    var ye = this, ve = function _e() {
      ye.dispose(), fe == null || fe.removeEventListener == null || fe.removeEventListener("abort", _e);
    };
    return fe == null || fe.addEventListener == null || fe.addEventListener("abort", ve), ve[$mobx] = this, ve;
  }, oe.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, oe.trace = function(fe) {
    fe === void 0 && (fe = !1), trace(this, fe);
  }, _createClass(ne, [{
    key: "isDisposed",
    get: function() {
      return getFlag(this.flags_, ne.isDisposedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isDisposedMask_, fe);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return getFlag(this.flags_, ne.isScheduledMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isScheduledMask_, fe);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return getFlag(this.flags_, ne.isTrackPendingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isTrackPendingMask_, fe);
    }
  }, {
    key: "isRunning",
    get: function() {
      return getFlag(this.flags_, ne.isRunningMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100, reactionScheduler = function ne(oe) {
  return oe();
};
function runReactions() {
  globalState.inBatch > 0 || globalState.isRunningReactions || reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = !0;
  for (var ne = globalState.pendingReactions, oe = 0; ne.length > 0; ) {
    ++oe === MAX_REACTION_ITERATIONS && (console.error(process.env.NODE_ENV !== "production" ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + ne[0]) : "[mobx] cycle in reaction: " + ne[0]), ne.splice(0));
    for (var ae = ne.splice(0), fe = 0, ye = ae.length; fe < ye; fe++)
      ae[fe].runReaction_();
  }
  globalState.isRunningReactions = !1;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return process.env.NODE_ENV !== "production" && !!globalState.spyListeners.length;
}
function spyReport(ne) {
  if (process.env.NODE_ENV !== "production" && globalState.spyListeners.length)
    for (var oe = globalState.spyListeners, ae = 0, fe = oe.length; ae < fe; ae++)
      oe[ae](ne);
}
function spyReportStart(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = _extends({}, ne, {
      spyReportStart: !0
    });
    spyReport(oe);
  }
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: !0
};
function spyReportEnd(ne) {
  process.env.NODE_ENV !== "production" && spyReport(ne ? _extends({}, ne, {
    type: "report-end",
    spyReportEnd: !0
  }) : END_EVENT);
}
function spy(ne) {
  return process.env.NODE_ENV === "production" ? (console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  }) : (globalState.spyListeners.push(ne), once(function() {
    globalState.spyListeners = globalState.spyListeners.filter(function(oe) {
      return oe !== ne;
    });
  }));
}
var ACTION = "action", ACTION_BOUND = "action.bound", AUTOACTION = "autoAction", AUTOACTION_BOUND = "autoAction.bound", DEFAULT_ACTION_NAME = "<unnamed action>", actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION), actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: !0
}), autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: !0
}), autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: !0,
  bound: !0
});
function createActionFactory(ne) {
  var oe = function(fe, ye) {
    if (isFunction(fe))
      return createAction(fe.name || DEFAULT_ACTION_NAME, fe, ne);
    if (isFunction(ye))
      return createAction(fe, ye, ne);
    if (is20223Decorator(ye))
      return (ne ? autoActionAnnotation : actionAnnotation).decorate_20223_(fe, ye);
    if (isStringish(ye))
      return storeAnnotation(fe, ye, ne ? autoActionAnnotation : actionAnnotation);
    if (isStringish(fe))
      return createDecoratorAnnotation(createActionAnnotation(ne ? AUTOACTION : ACTION, {
        name: fe,
        autoAction: ne
      }));
    process.env.NODE_ENV !== "production" && die("Invalid arguments for `action`");
  };
  return oe;
}
var action = /* @__PURE__ */ createActionFactory(!1);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(!0);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(ne) {
  return isFunction(ne) && ne.isMobxAction === !0;
}
function autorun(ne, oe) {
  var ae, fe, ye, ve;
  oe === void 0 && (oe = EMPTY_OBJECT), process.env.NODE_ENV !== "production" && (isFunction(ne) || die("Autorun expects a function as first argument"), isAction(ne) && die("Autorun does not accept actions since actions are untrackable"));
  var _e = (ae = (fe = oe) == null ? void 0 : fe.name) != null ? ae : process.env.NODE_ENV !== "production" ? ne.name || "Autorun@" + getNextId() : "Autorun", xe = !oe.scheduler && !oe.delay, Oe;
  if (xe)
    Oe = new Reaction(_e, function() {
      this.track(Re);
    }, oe.onError, oe.requiresObservable);
  else {
    var $e = createSchedulerFromOptions(oe), Me = !1;
    Oe = new Reaction(_e, function() {
      Me || (Me = !0, $e(function() {
        Me = !1, Oe.isDisposed || Oe.track(Re);
      }));
    }, oe.onError, oe.requiresObservable);
  }
  function Re() {
    ne(Oe);
  }
  return (ye = oe) != null && (ye = ye.signal) != null && ye.aborted || Oe.schedule_(), Oe.getDisposer_((ve = oe) == null ? void 0 : ve.signal);
}
var run = function ne(oe) {
  return oe();
};
function createSchedulerFromOptions(ne) {
  return ne.scheduler ? ne.scheduler : ne.delay ? function(oe) {
    return setTimeout(oe, ne.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO", ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_OBSERVED, ne, oe, ae);
}
function onBecomeUnobserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_UNOBSERVED, ne, oe, ae);
}
function interceptHook(ne, oe, ae, fe) {
  var ye = typeof fe == "function" ? getAtom(oe, ae) : getAtom(oe), ve = isFunction(fe) ? fe : ae, _e = ne + "L";
  return ye[_e] ? ye[_e].add(ve) : ye[_e] = /* @__PURE__ */ new Set([ve]), function() {
    var xe = ye[_e];
    xe && (xe.delete(ve), xe.size === 0 && delete ye[_e]);
  };
}
function extendObservable(ne, oe, ae, fe) {
  process.env.NODE_ENV !== "production" && (arguments.length > 4 && die("'extendObservable' expected 2-4 arguments"), typeof ne != "object" && die("'extendObservable' expects an object as first argument"), isObservableMap(ne) && die("'extendObservable' should not be used on maps, use map.merge instead"), isPlainObject(oe) || die("'extendObservable' only accepts plain objects as second argument"), (isObservable(oe) || isObservable(ae)) && die("Extending an object with another observable (object) is not supported"));
  var ye = getOwnPropertyDescriptors(oe);
  return initObservable(function() {
    var ve = asObservableObject(ne, fe)[$mobx];
    ownKeys(ye).forEach(function(_e) {
      ve.extend_(
        _e,
        ye[_e],
        // must pass "undefined" for { key: undefined }
        ae && _e in ae ? ae[_e] : !0
      );
    });
  }), ne;
}
function getDependencyTree(ne, oe) {
  return nodeToDependencyTree(getAtom(ne, oe));
}
function nodeToDependencyTree(ne) {
  var oe = {
    name: ne.name_
  };
  return ne.observing_ && ne.observing_.length > 0 && (oe.dependencies = unique(ne.observing_).map(nodeToDependencyTree)), oe;
}
function unique(ne) {
  return Array.from(new Set(ne));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow"), flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: !0
}), flow = /* @__PURE__ */ Object.assign(function ne(oe, ae) {
  if (is20223Decorator(ae))
    return flowAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, flowAnnotation);
  process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("Flow expects single argument with generator function");
  var fe = oe, ye = fe.name || "<unnamed flow>", ve = function() {
    var xe = this, Oe = arguments, $e = ++generatorId, Me = action(ye + " - runid: " + $e + " - init", fe).apply(xe, Oe), Re, je = void 0, Be = new Promise(function(ze, He) {
      var qe = 0;
      Re = He;
      function Ye(yt) {
        je = void 0;
        var Ct;
        try {
          Ct = action(ye + " - runid: " + $e + " - yield " + qe++, Me.next).call(Me, yt);
        } catch (It) {
          return He(It);
        }
        dt(Ct);
      }
      function pt(yt) {
        je = void 0;
        var Ct;
        try {
          Ct = action(ye + " - runid: " + $e + " - yield " + qe++, Me.throw).call(Me, yt);
        } catch (It) {
          return He(It);
        }
        dt(Ct);
      }
      function dt(yt) {
        if (isFunction(yt == null ? void 0 : yt.then)) {
          yt.then(dt, He);
          return;
        }
        return yt.done ? ze(yt.value) : (je = Promise.resolve(yt.value), je.then(Ye, pt));
      }
      Ye(void 0);
    });
    return Be.cancel = action(ye + " - runid: " + $e + " - cancel", function() {
      try {
        je && cancelPromise(je);
        var ze = Me.return(void 0), He = Promise.resolve(ze.value);
        He.then(noop, noop), cancelPromise(He), Re(new FlowCancellationError());
      } catch (qe) {
        Re(qe);
      }
    }), Be;
  };
  return ve.isMobXFlow = !0, ve;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(ne) {
  isFunction(ne.cancel) && ne.cancel();
}
function isFlow(ne) {
  return (ne == null ? void 0 : ne.isMobXFlow) === !0;
}
function _isObservable(ne, oe) {
  return ne ? oe !== void 0 ? process.env.NODE_ENV !== "production" && (isObservableMap(ne) || isObservableArray(ne)) ? die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.") : isObservableObject(ne) ? ne[$mobx].values_.has(oe) : !1 : isObservableObject(ne) || !!ne[$mobx] || isAtom(ne) || isReaction(ne) || isComputedValue(ne) : !1;
}
function isObservable(ne) {
  return process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"), _isObservable(ne);
}
function trace() {
  if (process.env.NODE_ENV !== "production") {
    for (var ne = !1, oe = arguments.length, ae = new Array(oe), fe = 0; fe < oe; fe++)
      ae[fe] = arguments[fe];
    typeof ae[ae.length - 1] == "boolean" && (ne = ae.pop());
    var ye = getAtomFromArgs(ae);
    if (!ye)
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    ye.isTracing_ === TraceMode.NONE && console.log("[mobx.trace] '" + ye.name_ + "' tracing enabled"), ye.isTracing_ = ne ? TraceMode.BREAK : TraceMode.LOG;
  }
}
function getAtomFromArgs(ne) {
  switch (ne.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(ne[0]);
    case 2:
      return getAtom(ne[0], ne[1]);
  }
}
function transaction(ne, oe) {
  oe === void 0 && (oe = void 0), startBatch();
  try {
    return ne.apply(oe);
  } finally {
    endBatch();
  }
}
function getAdm(ne) {
  return ne[$mobx];
}
var objectProxyTraps = {
  has: function ne(oe, ae) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."), getAdm(oe).has_(ae);
  },
  get: function ne(oe, ae) {
    return getAdm(oe).get_(ae);
  },
  set: function ne(oe, ae, fe) {
    var ye;
    return isStringish(ae) ? (process.env.NODE_ENV !== "production" && !getAdm(oe).values_.has(ae) && warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead."), (ye = getAdm(oe).set_(ae, fe, !0)) != null ? ye : !0) : !1;
  },
  deleteProperty: function ne(oe, ae) {
    var fe;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead."), isStringish(ae) ? (fe = getAdm(oe).delete_(ae, !0)) != null ? fe : !0 : !1;
  },
  defineProperty: function ne(oe, ae, fe) {
    var ye;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead."), (ye = getAdm(oe).defineProperty_(ae, fe)) != null ? ye : !0;
  },
  ownKeys: function ne(oe) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."), getAdm(oe).ownKeys_();
  },
  preventExtensions: function ne(oe) {
    die(13);
  }
};
function asDynamicObservableObject(ne, oe) {
  var ae, fe;
  return assertProxies(), ne = asObservableObject(ne, oe), (fe = (ae = ne[$mobx]).proxy_) != null ? fe : ae.proxy_ = new Proxy(ne, objectProxyTraps);
}
function hasInterceptors(ne) {
  return ne.interceptors_ !== void 0 && ne.interceptors_.length > 0;
}
function registerInterceptor(ne, oe) {
  var ae = ne.interceptors_ || (ne.interceptors_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function interceptChange(ne, oe) {
  var ae = untrackedStart();
  try {
    for (var fe = [].concat(ne.interceptors_ || []), ye = 0, ve = fe.length; ye < ve && (oe = fe[ye](oe), oe && !oe.type && die(14), !!oe); ye++)
      ;
    return oe;
  } finally {
    untrackedEnd(ae);
  }
}
function hasListeners(ne) {
  return ne.changeListeners_ !== void 0 && ne.changeListeners_.length > 0;
}
function registerListener(ne, oe) {
  var ae = ne.changeListeners_ || (ne.changeListeners_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function notifyListeners(ne, oe) {
  var ae = untrackedStart(), fe = ne.changeListeners_;
  if (fe) {
    fe = fe.slice();
    for (var ye = 0, ve = fe.length; ye < ve; ye++)
      fe[ye](oe);
    untrackedEnd(ae);
  }
}
var SPLICE = "splice", UPDATE = "update", MAX_SPLICE_SIZE = 1e4, arrayTraps = {
  get: function ne(oe, ae) {
    var fe = oe[$mobx];
    return ae === $mobx ? fe : ae === "length" ? fe.getArrayLength_() : typeof ae == "string" && !isNaN(ae) ? fe.get_(parseInt(ae)) : hasProp(arrayExtensions, ae) ? arrayExtensions[ae] : oe[ae];
  },
  set: function ne(oe, ae, fe) {
    var ye = oe[$mobx];
    return ae === "length" && ye.setArrayLength_(fe), typeof ae == "symbol" || isNaN(ae) ? oe[ae] = fe : ye.set_(parseInt(ae), fe), !0;
  },
  preventExtensions: function ne() {
    die(15);
  }
}, ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ve) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = ye, this.legacyMode_ = ve, this.atom_ = new Atom(ae), this.enhancer_ = function(_e, xe) {
      return fe(_e, xe, process.env.NODE_ENV !== "production" ? ae + "[..]" : "ObservableArray[..]");
    };
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.dehanceValues_ = function(fe) {
    return this.dehancer !== void 0 && fe.length > 0 ? fe.map(this.dehancer) : fe;
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.observe_ = function(fe, ye) {
    return ye === void 0 && (ye = !1), ye && fe({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), registerListener(this, fe);
  }, oe.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, oe.setArrayLength_ = function(fe) {
    (typeof fe != "number" || isNaN(fe) || fe < 0) && die("Out of range: " + fe);
    var ye = this.values_.length;
    if (fe !== ye)
      if (fe > ye) {
        for (var ve = new Array(fe - ye), _e = 0; _e < fe - ye; _e++)
          ve[_e] = void 0;
        this.spliceWithArray_(ye, 0, ve);
      } else
        this.spliceWithArray_(fe, ye - fe);
  }, oe.updateArrayLength_ = function(fe, ye) {
    fe !== this.lastKnownLength_ && die(16), this.lastKnownLength_ += ye, this.legacyMode_ && ye > 0 && reserveArrayBuffer(fe + ye + 1);
  }, oe.spliceWithArray_ = function(fe, ye, ve) {
    var _e = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var xe = this.values_.length;
    if (fe === void 0 ? fe = 0 : fe > xe ? fe = xe : fe < 0 && (fe = Math.max(0, xe + fe)), arguments.length === 1 ? ye = xe - fe : ye == null ? ye = 0 : ye = Math.max(0, Math.min(ye, xe - fe)), ve === void 0 && (ve = EMPTY_ARRAY), hasInterceptors(this)) {
      var Oe = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: fe,
        removedCount: ye,
        added: ve
      });
      if (!Oe)
        return EMPTY_ARRAY;
      ye = Oe.removedCount, ve = Oe.added;
    }
    if (ve = ve.length === 0 ? ve : ve.map(function(Re) {
      return _e.enhancer_(Re, void 0);
    }), this.legacyMode_ || process.env.NODE_ENV !== "production") {
      var $e = ve.length - ye;
      this.updateArrayLength_(xe, $e);
    }
    var Me = this.spliceItemsIntoValues_(fe, ye, ve);
    return (ye !== 0 || ve.length !== 0) && this.notifyArraySplice_(fe, ve, Me), this.dehanceValues_(Me);
  }, oe.spliceItemsIntoValues_ = function(fe, ye, ve) {
    if (ve.length < MAX_SPLICE_SIZE) {
      var _e;
      return (_e = this.values_).splice.apply(_e, [fe, ye].concat(ve));
    } else {
      var xe = this.values_.slice(fe, fe + ye), Oe = this.values_.slice(fe + ye);
      this.values_.length += ve.length - ye;
      for (var $e = 0; $e < ve.length; $e++)
        this.values_[fe + $e] = ve[$e];
      for (var Me = 0; Me < Oe.length; Me++)
        this.values_[fe + ve.length + Me] = Oe[Me];
      return xe;
    }
  }, oe.notifyArrayChildUpdate_ = function(fe, ye, ve) {
    var _e = !this.owned_ && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: fe,
      newValue: ye,
      oldValue: ve
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), this.atom_.reportChanged(), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.notifyArraySplice_ = function(fe, ye, ve) {
    var _e = !this.owned_ && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: fe,
      removed: ve,
      added: ye,
      removedCount: ve.length,
      addedCount: ye.length
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), this.atom_.reportChanged(), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.get_ = function(fe) {
    if (this.legacyMode_ && fe >= this.values_.length) {
      console.warn(process.env.NODE_ENV !== "production" ? "[mobx.array] Attempt to read an array index (" + fe + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + fe);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[fe]);
  }, oe.set_ = function(fe, ye) {
    var ve = this.values_;
    if (this.legacyMode_ && fe > ve.length && die(17, fe, ve.length), fe < ve.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var _e = ve[fe];
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: fe,
          newValue: ye
        });
        if (!xe)
          return;
        ye = xe.newValue;
      }
      ye = this.enhancer_(ye, _e);
      var Oe = ye !== _e;
      Oe && (ve[fe] = ye, this.notifyArrayChildUpdate_(fe, ye, _e));
    } else {
      for (var $e = new Array(fe + 1 - ve.length), Me = 0; Me < $e.length - 1; Me++)
        $e[Me] = void 0;
      $e[$e.length - 1] = ye, this.spliceWithArray_(ve.length, 0, $e);
    }
  }, ne;
}();
function createObservableArray(ne, oe, ae, fe) {
  return ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), fe === void 0 && (fe = !1), assertProxies(), initObservable(function() {
    var ye = new ObservableArrayAdministration(ae, oe, fe, !1);
    addHiddenFinalProp(ye.values_, $mobx, ye);
    var ve = new Proxy(ye.values_, arrayTraps);
    return ye.proxy_ = ve, ne && ne.length && ye.spliceWithArray_(0, 0, ne), ve;
  });
}
var arrayExtensions = {
  clear: function ne() {
    return this.splice(0);
  },
  replace: function ne(oe) {
    var ae = this[$mobx];
    return ae.spliceWithArray_(0, ae.values_.length, oe);
  },
  // Used by JSON.stringify
  toJSON: function ne() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function ne(oe, ae) {
    for (var fe = arguments.length, ye = new Array(fe > 2 ? fe - 2 : 0), ve = 2; ve < fe; ve++)
      ye[ve - 2] = arguments[ve];
    var _e = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return _e.spliceWithArray_(oe);
      case 2:
        return _e.spliceWithArray_(oe, ae);
    }
    return _e.spliceWithArray_(oe, ae, ye);
  },
  spliceWithArray: function ne(oe, ae, fe) {
    return this[$mobx].spliceWithArray_(oe, ae, fe);
  },
  push: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(oe.values_.length, 0, fe), oe.values_.length;
  },
  pop: function ne() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function ne() {
    return this.splice(0, 1)[0];
  },
  unshift: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(0, 0, fe), oe.values_.length;
  },
  reverse: function ne() {
    return globalState.trackingDerivation && die(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function ne() {
    globalState.trackingDerivation && die(37, "sort");
    var oe = this.slice();
    return oe.sort.apply(oe, arguments), this.replace(oe), this;
  },
  remove: function ne(oe) {
    var ae = this[$mobx], fe = ae.dehanceValues_(ae.values_).indexOf(oe);
    return fe > -1 ? (this.splice(fe, 1), !0) : !1;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(ne, oe) {
  typeof Array.prototype[ne] == "function" && (arrayExtensions[ne] = oe(ne));
}
function simpleFunc(ne) {
  return function() {
    var oe = this[$mobx];
    oe.atom_.reportObserved();
    var ae = oe.dehanceValues_(oe.values_);
    return ae[ne].apply(ae, arguments);
  };
}
function mapLikeFunc(ne) {
  return function(oe, ae) {
    var fe = this, ye = this[$mobx];
    ye.atom_.reportObserved();
    var ve = ye.dehanceValues_(ye.values_);
    return ve[ne](function(_e, xe) {
      return oe.call(ae, _e, xe, fe);
    });
  };
}
function reduceLikeFunc(ne) {
  return function() {
    var oe = this, ae = this[$mobx];
    ae.atom_.reportObserved();
    var fe = ae.dehanceValues_(ae.values_), ye = arguments[0];
    return arguments[0] = function(ve, _e, xe) {
      return ye(ve, _e, xe, oe);
    }, fe[ne].apply(fe, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(ne) {
  return isObject(ne) && isObservableArrayAdministration(ne[$mobx]);
}
var ObservableMapMarker = {}, ADD = "add", DELETE = "delete", ObservableMap = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var ve = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableMap@" + getNextId() : "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[$mobx] = ObservableMapMarker, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = fe, this.name_ = ye, isFunction(Map) || die(18), initObservable(function() {
      ve.keysAtom_ = createAtom(process.env.NODE_ENV !== "production" ? ve.name_ + ".keys()" : "ObservableMap.keys()"), ve.data_ = /* @__PURE__ */ new Map(), ve.hasMap_ = /* @__PURE__ */ new Map(), ae && ve.merge(ae);
    });
  }
  var oe = ne.prototype;
  return oe.has_ = function(fe) {
    return this.data_.has(fe);
  }, oe.has = function(fe) {
    var ye = this;
    if (!globalState.trackingDerivation)
      return this.has_(fe);
    var ve = this.hasMap_.get(fe);
    if (!ve) {
      var _e = ve = new ObservableValue(this.has_(fe), referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableMap.key?", !1);
      this.hasMap_.set(fe, _e), onBecomeUnobserved(_e, function() {
        return ye.hasMap_.delete(fe);
      });
    }
    return ve.get();
  }, oe.set = function(fe, ye) {
    var ve = this.has_(fe);
    if (hasInterceptors(this)) {
      var _e = interceptChange(this, {
        type: ve ? UPDATE : ADD,
        object: this,
        newValue: ye,
        name: fe
      });
      if (!_e)
        return this;
      ye = _e.newValue;
    }
    return ve ? this.updateValue_(fe, ye) : this.addValue_(fe, ye), this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.keysAtom_), hasInterceptors(this)) {
      var ve = interceptChange(this, {
        type: DELETE,
        object: this,
        name: fe
      });
      if (!ve)
        return !1;
    }
    if (this.has_(fe)) {
      var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(fe).value_,
        name: fe
      } : null;
      return process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), transaction(function() {
        var $e;
        ye.keysAtom_.reportChanged(), ($e = ye.hasMap_.get(fe)) == null || $e.setNewValue_(!1);
        var Me = ye.data_.get(fe);
        Me.setNewValue_(void 0), ye.data_.delete(fe);
      }), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd(), !0;
    }
    return !1;
  }, oe.updateValue_ = function(fe, ye) {
    var ve = this.data_.get(fe);
    if (ye = ve.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: ve.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), ve.setNewValue_(ye), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
    }
  }, oe.addValue_ = function(fe, ye) {
    var ve = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_), transaction(function() {
      var $e, Me = new ObservableValue(ye, ve.enhancer_, process.env.NODE_ENV !== "production" ? ve.name_ + "." + stringifyKey(fe) : "ObservableMap.key", !1);
      ve.data_.set(fe, Me), ye = Me.value_, ($e = ve.hasMap_.get(fe)) == null || $e.setNewValue_(!0), ve.keysAtom_.reportChanged();
    });
    var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: fe,
      newValue: ye
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.get = function(fe) {
    return this.has(fe) ? this.dehanceValue_(this.data_.get(fe).get()) : this.dehanceValue_(void 0);
  }, oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, oe.values = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var _e = ye.next(), xe = _e.done, Oe = _e.value;
        return {
          done: xe,
          value: xe ? void 0 : fe.get(Oe)
        };
      }
    });
  }, oe.entries = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var _e = ye.next(), xe = _e.done, Oe = _e.value;
        return {
          done: xe,
          value: xe ? void 0 : [Oe, fe.get(Oe)]
        };
      }
    });
  }, oe[Symbol.iterator] = function() {
    return this.entries();
  }, oe.forEach = function(fe, ye) {
    for (var ve = _createForOfIteratorHelperLoose(this), _e; !(_e = ve()).done; ) {
      var xe = _e.value, Oe = xe[0], $e = xe[1];
      fe.call(ye, $e, Oe, this);
    }
  }, oe.merge = function(fe) {
    var ye = this;
    return isObservableMap(fe) && (fe = new Map(fe)), transaction(function() {
      isPlainObject(fe) ? getPlainObjectKeys(fe).forEach(function(ve) {
        return ye.set(ve, fe[ve]);
      }) : Array.isArray(fe) ? fe.forEach(function(ve) {
        var _e = ve[0], xe = ve[1];
        return ye.set(_e, xe);
      }) : isES6Map(fe) ? (isPlainES6Map(fe) || die(19, fe), fe.forEach(function(ve, _e) {
        return ye.set(_e, ve);
      })) : fe != null && die(20, fe);
    }), this;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.keys()), ve; !(ve = ye()).done; ) {
          var _e = ve.value;
          fe.delete(_e);
        }
      });
    });
  }, oe.replace = function(fe) {
    var ye = this;
    return transaction(function() {
      for (var ve = convertToMap(fe), _e = /* @__PURE__ */ new Map(), xe = !1, Oe = _createForOfIteratorHelperLoose(ye.data_.keys()), $e; !($e = Oe()).done; ) {
        var Me = $e.value;
        if (!ve.has(Me)) {
          var Re = ye.delete(Me);
          if (Re)
            xe = !0;
          else {
            var je = ye.data_.get(Me);
            _e.set(Me, je);
          }
        }
      }
      for (var Be = _createForOfIteratorHelperLoose(ve.entries()), ze; !(ze = Be()).done; ) {
        var He = ze.value, qe = He[0], Ye = He[1], pt = ye.data_.has(qe);
        if (ye.set(qe, Ye), ye.data_.has(qe)) {
          var dt = ye.data_.get(qe);
          _e.set(qe, dt), pt || (xe = !0);
        }
      }
      if (!xe)
        if (ye.data_.size !== _e.size)
          ye.keysAtom_.reportChanged();
        else
          for (var yt = ye.data_.keys(), Ct = _e.keys(), It = yt.next(), Vt = Ct.next(); !It.done; ) {
            if (It.value !== Vt.value) {
              ye.keysAtom_.reportChanged();
              break;
            }
            It = yt.next(), Vt = Ct.next();
          }
      ye.data_ = _e;
    }), this;
  }, oe.toString = function() {
    return "[object ObservableMap]";
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with maps."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(ne) {
  if (isES6Map(ne) || isObservableMap(ne))
    return ne;
  if (Array.isArray(ne))
    return new Map(ne);
  if (isPlainObject(ne)) {
    var oe = /* @__PURE__ */ new Map();
    for (var ae in ne)
      oe.set(ae, ne[ae]);
    return oe;
  } else
    return die(21, ne);
}
var ObservableSetMarker = {}, ObservableSet = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var ve = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableSet@" + getNextId() : "ObservableSet"), this.name_ = void 0, this[$mobx] = ObservableSetMarker, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = ye, isFunction(Set) || die(22), this.enhancer_ = function(_e, xe) {
      return fe(_e, xe, ye);
    }, initObservable(function() {
      ve.atom_ = createAtom(ve.name_), ae && ve.replace(ae);
    });
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.data_.values()), ve; !(ve = ye()).done; ) {
          var _e = ve.value;
          fe.delete(_e);
        }
      });
    });
  }, oe.forEach = function(fe, ye) {
    for (var ve = _createForOfIteratorHelperLoose(this), _e; !(_e = ve()).done; ) {
      var xe = _e.value;
      fe.call(ye, xe, xe, this);
    }
  }, oe.add = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.atom_), hasInterceptors(this)) {
      var ve = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: fe
      });
      if (!ve)
        return this;
    }
    if (!this.has(fe)) {
      transaction(function() {
        ye.data_.add(ye.enhancer_(fe, void 0)), ye.atom_.reportChanged();
      });
      var _e = process.env.NODE_ENV !== "production" && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: fe
      } : null;
      _e && process.env.NODE_ENV !== "production" && spyReportStart(Oe), xe && notifyListeners(this, Oe), _e && process.env.NODE_ENV !== "production" && spyReportEnd();
    }
    return this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (hasInterceptors(this)) {
      var ve = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: fe
      });
      if (!ve)
        return !1;
    }
    if (this.has(fe)) {
      var _e = process.env.NODE_ENV !== "production" && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: fe
      } : null;
      return _e && process.env.NODE_ENV !== "production" && spyReportStart(Oe), transaction(function() {
        ye.atom_.reportChanged(), ye.data_.delete(fe);
      }), xe && notifyListeners(this, Oe), _e && process.env.NODE_ENV !== "production" && spyReportEnd(), !0;
    }
    return !1;
  }, oe.has = function(fe) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(fe));
  }, oe.entries = function() {
    var fe = 0, ye = Array.from(this.keys()), ve = Array.from(this.values());
    return makeIterable({
      next: function() {
        var xe = fe;
        return fe += 1, xe < ve.length ? {
          value: [ye[xe], ve[xe]],
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.keys = function() {
    return this.values();
  }, oe.values = function() {
    this.atom_.reportObserved();
    var fe = this, ye = 0, ve = Array.from(this.data_.values());
    return makeIterable({
      next: function() {
        return ye < ve.length ? {
          value: fe.dehanceValue_(ve[ye++]),
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.intersection = function(fe) {
    if (isES6Set(fe))
      return fe.intersection(this);
    var ye = new Set(this);
    return ye.intersection(fe);
  }, oe.union = function(fe) {
    if (isES6Set(fe))
      return fe.union(this);
    var ye = new Set(this);
    return ye.union(fe);
  }, oe.difference = function(fe) {
    return new Set(this).difference(fe);
  }, oe.symmetricDifference = function(fe) {
    if (isES6Set(fe))
      return fe.symmetricDifference(this);
    var ye = new Set(this);
    return ye.symmetricDifference(fe);
  }, oe.isSubsetOf = function(fe) {
    return new Set(this).isSubsetOf(fe);
  }, oe.isSupersetOf = function(fe) {
    return new Set(this).isSupersetOf(fe);
  }, oe.isDisjointFrom = function(fe) {
    if (isES6Set(fe))
      return fe.isDisjointFrom(this);
    var ye = new Set(this);
    return ye.isDisjointFrom(fe);
  }, oe.replace = function(fe) {
    var ye = this;
    return isObservableSet(fe) && (fe = new Set(fe)), transaction(function() {
      Array.isArray(fe) ? (ye.clear(), fe.forEach(function(ve) {
        return ye.add(ve);
      })) : isES6Set(fe) ? (ye.clear(), fe.forEach(function(ve) {
        return ye.add(ve);
      })) : fe != null && die("Cannot initialize set from " + fe);
    }), this;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with sets."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.toString = function() {
    return "[object ObservableSet]";
  }, oe[Symbol.iterator] = function() {
    return this.values();
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet), descriptorCache = /* @__PURE__ */ Object.create(null), REMOVE = "remove", ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ve) {
    fe === void 0 && (fe = /* @__PURE__ */ new Map()), ve === void 0 && (ve = autoAnnotation), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = ae, this.values_ = fe, this.name_ = ye, this.defaultAnnotation_ = ve, this.keysAtom_ = new Atom(process.env.NODE_ENV !== "production" ? this.name_ + ".keys" : "ObservableObject.keys"), this.isPlainObject_ = isPlainObject(this.target_), process.env.NODE_ENV !== "production" && !isAnnotation(this.defaultAnnotation_) && die("defaultAnnotation must be valid annotation"), process.env.NODE_ENV !== "production" && (this.appliedAnnotations_ = {});
  }
  var oe = ne.prototype;
  return oe.getObservablePropValue_ = function(fe) {
    return this.values_.get(fe).get();
  }, oe.setObservablePropValue_ = function(fe, ye) {
    var ve = this.values_.get(fe);
    if (ve instanceof ComputedValue)
      return ve.set(ye), !0;
    if (hasInterceptors(this)) {
      var _e = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      });
      if (!_e)
        return null;
      ye = _e.newValue;
    }
    if (ye = ve.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var xe = hasListeners(this), Oe = process.env.NODE_ENV !== "production" && isSpyEnabled(), $e = xe || Oe ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: ve.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && Oe && spyReportStart($e), ve.setNewValue_(ye), xe && notifyListeners(this, $e), process.env.NODE_ENV !== "production" && Oe && spyReportEnd();
    }
    return !0;
  }, oe.get_ = function(fe) {
    return globalState.trackingDerivation && !hasProp(this.target_, fe) && this.has_(fe), this.target_[fe];
  }, oe.set_ = function(fe, ye, ve) {
    return ve === void 0 && (ve = !1), hasProp(this.target_, fe) ? this.values_.has(fe) ? this.setObservablePropValue_(fe, ye) : ve ? Reflect.set(this.target_, fe, ye) : (this.target_[fe] = ye, !0) : this.extend_(fe, {
      value: ye,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, ve);
  }, oe.has_ = function(fe) {
    if (!globalState.trackingDerivation)
      return fe in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var ye = this.pendingKeys_.get(fe);
    return ye || (ye = new ObservableValue(fe in this.target_, referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableObject.key?", !1), this.pendingKeys_.set(fe, ye)), ye.get();
  }, oe.make_ = function(fe, ye) {
    if (ye === !0 && (ye = this.defaultAnnotation_), ye !== !1) {
      if (assertAnnotable(this, ye, fe), !(fe in this.target_)) {
        var ve;
        if ((ve = this.target_[storedAnnotationsSymbol]) != null && ve[fe])
          return;
        die(1, ye.annotationType_, this.name_ + "." + fe.toString());
      }
      for (var _e = this.target_; _e && _e !== objectPrototype; ) {
        var xe = getDescriptor(_e, fe);
        if (xe) {
          var Oe = ye.make_(this, fe, xe, _e);
          if (Oe === 0)
            return;
          if (Oe === 1)
            break;
        }
        _e = Object.getPrototypeOf(_e);
      }
      recordAnnotationApplied(this, ye, fe);
    }
  }, oe.extend_ = function(fe, ye, ve, _e) {
    if (_e === void 0 && (_e = !1), ve === !0 && (ve = this.defaultAnnotation_), ve === !1)
      return this.defineProperty_(fe, ye, _e);
    assertAnnotable(this, ve, fe);
    var xe = ve.extend_(this, fe, ye, _e);
    return xe && recordAnnotationApplied(this, ve, fe), xe;
  }, oe.defineProperty_ = function(fe, ye, ve) {
    ve === void 0 && (ve = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var _e = this.delete_(fe);
      if (!_e)
        return _e;
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye.value
        });
        if (!xe)
          return null;
        var Oe = xe.newValue;
        ye.value !== Oe && (ye = _extends({}, ye, {
          value: Oe
        }));
      }
      if (ve) {
        if (!Reflect.defineProperty(this.target_, fe, ye))
          return !1;
      } else
        defineProperty(this.target_, fe, ye);
      this.notifyPropertyAddition_(fe, ye.value);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineObservableProperty_ = function(fe, ye, ve, _e) {
    _e === void 0 && (_e = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var xe = this.delete_(fe);
      if (!xe)
        return xe;
      if (hasInterceptors(this)) {
        var Oe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye
        });
        if (!Oe)
          return null;
        ye = Oe.newValue;
      }
      var $e = getCachedObservablePropDescriptor(fe), Me = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: $e.get,
        set: $e.set
      };
      if (_e) {
        if (!Reflect.defineProperty(this.target_, fe, Me))
          return !1;
      } else
        defineProperty(this.target_, fe, Me);
      var Re = new ObservableValue(ye, ve, process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key", !1);
      this.values_.set(fe, Re), this.notifyPropertyAddition_(fe, Re.value_);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineComputedProperty_ = function(fe, ye, ve) {
    ve === void 0 && (ve = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var _e = this.delete_(fe);
      if (!_e)
        return _e;
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: void 0
        });
        if (!xe)
          return null;
      }
      ye.name || (ye.name = process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key"), ye.context = this.proxy_ || this.target_;
      var Oe = getCachedObservablePropDescriptor(fe), $e = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: Oe.get,
        set: Oe.set
      };
      if (ve) {
        if (!Reflect.defineProperty(this.target_, fe, $e))
          return !1;
      } else
        defineProperty(this.target_, fe, $e);
      this.values_.set(fe, new ComputedValue(ye)), this.notifyPropertyAddition_(fe, void 0);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.delete_ = function(fe, ye) {
    if (ye === void 0 && (ye = !1), checkIfStateModificationsAreAllowed(this.keysAtom_), !hasProp(this.target_, fe))
      return !0;
    if (hasInterceptors(this)) {
      var ve = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: fe,
        type: REMOVE
      });
      if (!ve)
        return null;
    }
    try {
      var _e;
      startBatch();
      var xe = hasListeners(this), Oe = process.env.NODE_ENV !== "production" && isSpyEnabled(), $e = this.values_.get(fe), Me = void 0;
      if (!$e && (xe || Oe)) {
        var Re;
        Me = (Re = getDescriptor(this.target_, fe)) == null ? void 0 : Re.value;
      }
      if (ye) {
        if (!Reflect.deleteProperty(this.target_, fe))
          return !1;
      } else
        delete this.target_[fe];
      if (process.env.NODE_ENV !== "production" && delete this.appliedAnnotations_[fe], $e && (this.values_.delete(fe), $e instanceof ObservableValue && (Me = $e.value_), propagateChanged($e)), this.keysAtom_.reportChanged(), (_e = this.pendingKeys_) == null || (_e = _e.get(fe)) == null || _e.set(fe in this.target_), xe || Oe) {
        var je = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: Me,
          name: fe
        };
        process.env.NODE_ENV !== "production" && Oe && spyReportStart(je), xe && notifyListeners(this, je), process.env.NODE_ENV !== "production" && Oe && spyReportEnd();
      }
    } finally {
      endBatch();
    }
    return !0;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support the fire immediately property for observable objects."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.notifyPropertyAddition_ = function(fe, ye) {
    var ve, _e = hasListeners(this), xe = process.env.NODE_ENV !== "production" && isSpyEnabled();
    if (_e || xe) {
      var Oe = _e || xe ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && xe && spyReportStart(Oe), _e && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && xe && spyReportEnd();
    }
    (ve = this.pendingKeys_) == null || (ve = ve.get(fe)) == null || ve.set(!0), this.keysAtom_.reportChanged();
  }, oe.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), ownKeys(this.target_);
  }, oe.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, ne;
}();
function asObservableObject(ne, oe) {
  var ae;
  if (process.env.NODE_ENV !== "production" && oe && isObservableObject(ne) && die("Options can't be provided for already observable objects."), hasProp(ne, $mobx))
    return process.env.NODE_ENV !== "production" && !(getAdministration(ne) instanceof ObservableObjectAdministration) && die("Cannot convert '" + getDebugName(ne) + `' into observable object:
The target is already observable of different type.
Extending builtins is not supported.`), ne;
  process.env.NODE_ENV !== "production" && !Object.isExtensible(ne) && die("Cannot make the designated object observable; it is not extensible");
  var fe = (ae = oe == null ? void 0 : oe.name) != null ? ae : process.env.NODE_ENV !== "production" ? (isPlainObject(ne) ? "ObservableObject" : ne.constructor.name) + "@" + getNextId() : "ObservableObject", ye = new ObservableObjectAdministration(ne, /* @__PURE__ */ new Map(), String(fe), getAnnotationFromOptions(oe));
  return addHiddenProp(ne, $mobx, ye), ne;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(ne) {
  return descriptorCache[ne] || (descriptorCache[ne] = {
    get: function() {
      return this[$mobx].getObservablePropValue_(ne);
    },
    set: function(ae) {
      return this[$mobx].setObservablePropValue_(ne, ae);
    }
  });
}
function isObservableObject(ne) {
  return isObject(ne) ? isObservableObjectAdministration(ne[$mobx]) : !1;
}
function recordAnnotationApplied(ne, oe, ae) {
  var fe;
  process.env.NODE_ENV !== "production" && (ne.appliedAnnotations_[ae] = oe), (fe = ne.target_[storedAnnotationsSymbol]) == null || delete fe[ae];
}
function assertAnnotable(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isAnnotation(oe) && die("Cannot annotate '" + ne.name_ + "." + ae.toString() + "': Invalid annotation."), process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne.appliedAnnotations_, ae)) {
    var fe = ne.name_ + "." + ae.toString(), ye = ne.appliedAnnotations_[ae].annotationType_, ve = oe.annotationType_;
    die("Cannot apply '" + ve + "' to '" + fe + "':" + (`
The field is already annotated with '` + ye + "'.") + `
Re-annotating fields is not allowed.
Use 'override' annotation for methods overridden by subclass.`);
  }
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0), safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var ne = !1, oe = {};
  return Object.defineProperty(oe, "0", {
    set: function() {
      ne = !0;
    }
  }), Object.create(oe)[0] = 1, ne === !1;
}(), OBSERVABLE_ARRAY_BUFFER_SIZE = 0, StubArray = function ne() {
};
function inherit(ne, oe) {
  Object.setPrototypeOf ? Object.setPrototypeOf(ne.prototype, oe) : ne.prototype.__proto__ !== void 0 ? ne.prototype.__proto__ = oe : ne.prototype = oe;
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, ve, _e) {
    var xe;
    return ve === void 0 && (ve = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), _e === void 0 && (_e = !1), xe = ne.call(this) || this, initObservable(function() {
      var Oe = new ObservableArrayAdministration(ve, ye, _e, !0);
      Oe.proxy_ = xe, addHiddenFinalProp(xe, $mobx, Oe), fe && fe.length && xe.spliceWithArray(0, 0, fe), safariPrototypeSetterInheritanceBug && Object.defineProperty(xe, "0", ENTRY_0);
    }), xe;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.concat = function() {
    this[$mobx].atom_.reportObserved();
    for (var ye = arguments.length, ve = new Array(ye), _e = 0; _e < ye; _e++)
      ve[_e] = arguments[_e];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      ve.map(function(xe) {
        return isObservableArray(xe) ? xe.slice() : xe;
      })
    );
  }, ae[Symbol.iterator] = function() {
    var fe = this, ye = 0;
    return makeIterable({
      next: function() {
        return ye < fe.length ? {
          value: fe[ye++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, _createClass(oe, [{
    key: "length",
    get: function() {
      return this[$mobx].getArrayLength_();
    },
    set: function(ye) {
      this[$mobx].setArrayLength_(ye);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(ne) {
  var oe = ne[0], ae = ne[1];
  oe !== "concat" && addHiddenProp(LegacyObservableArray.prototype, oe, ae);
});
function createArrayEntryDescriptor(ne) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[$mobx].get_(ne);
    },
    set: function(ae) {
      this[$mobx].set_(ne, ae);
    }
  };
}
function createArrayBufferItem(ne) {
  defineProperty(LegacyObservableArray.prototype, "" + ne, createArrayEntryDescriptor(ne));
}
function reserveArrayBuffer(ne) {
  if (ne > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var oe = OBSERVABLE_ARRAY_BUFFER_SIZE; oe < ne + 100; oe++)
      createArrayBufferItem(oe);
    OBSERVABLE_ARRAY_BUFFER_SIZE = ne;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(ne, oe, ae) {
  return new LegacyObservableArray(ne, oe, ae);
}
function getAtom(ne, oe) {
  if (typeof ne == "object" && ne !== null) {
    if (isObservableArray(ne))
      return oe !== void 0 && die(23), ne[$mobx].atom_;
    if (isObservableSet(ne))
      return ne.atom_;
    if (isObservableMap(ne)) {
      if (oe === void 0)
        return ne.keysAtom_;
      var ae = ne.data_.get(oe) || ne.hasMap_.get(oe);
      return ae || die(25, oe, getDebugName(ne)), ae;
    }
    if (isObservableObject(ne)) {
      if (!oe)
        return die(26);
      var fe = ne[$mobx].values_.get(oe);
      return fe || die(27, oe, getDebugName(ne)), fe;
    }
    if (isAtom(ne) || isComputedValue(ne) || isReaction(ne))
      return ne;
  } else if (isFunction(ne) && isReaction(ne[$mobx]))
    return ne[$mobx];
  die(28);
}
function getAdministration(ne, oe) {
  if (ne || die(29), oe !== void 0)
    return getAdministration(getAtom(ne, oe));
  if (isAtom(ne) || isComputedValue(ne) || isReaction(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (ne[$mobx])
    return ne[$mobx];
  die(24, ne);
}
function getDebugName(ne, oe) {
  var ae;
  if (oe !== void 0)
    ae = getAtom(ne, oe);
  else {
    if (isAction(ne))
      return ne.name;
    isObservableObject(ne) || isObservableMap(ne) || isObservableSet(ne) ? ae = getAdministration(ne) : ae = getAtom(ne);
  }
  return ae.name_;
}
function initObservable(ne) {
  var oe = untrackedStart(), ae = allowStateChangesStart(!0);
  startBatch();
  try {
    return ne();
  } finally {
    endBatch(), allowStateChangesEnd(ae), untrackedEnd(oe);
  }
}
var toString = objectPrototype.toString;
function deepEqual(ne, oe, ae) {
  return ae === void 0 && (ae = -1), eq$1(ne, oe, ae);
}
function eq$1(ne, oe, ae, fe, ye) {
  if (ne === oe)
    return ne !== 0 || 1 / ne === 1 / oe;
  if (ne == null || oe == null)
    return !1;
  if (ne !== ne)
    return oe !== oe;
  var ve = typeof ne;
  if (ve !== "function" && ve !== "object" && typeof oe != "object")
    return !1;
  var _e = toString.call(ne);
  if (_e !== toString.call(oe))
    return !1;
  switch (_e) {
    case "[object RegExp]":
    case "[object String]":
      return "" + ne == "" + oe;
    case "[object Number]":
      return +ne != +ne ? +oe != +oe : +ne == 0 ? 1 / +ne === 1 / oe : +ne == +oe;
    case "[object Date]":
    case "[object Boolean]":
      return +ne == +oe;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(ne) === Symbol.valueOf.call(oe);
    case "[object Map]":
    case "[object Set]":
      ae >= 0 && ae++;
      break;
  }
  ne = unwrap(ne), oe = unwrap(oe);
  var xe = _e === "[object Array]";
  if (!xe) {
    if (typeof ne != "object" || typeof oe != "object")
      return !1;
    var Oe = ne.constructor, $e = oe.constructor;
    if (Oe !== $e && !(isFunction(Oe) && Oe instanceof Oe && isFunction($e) && $e instanceof $e) && "constructor" in ne && "constructor" in oe)
      return !1;
  }
  if (ae === 0)
    return !1;
  ae < 0 && (ae = -1), fe = fe || [], ye = ye || [];
  for (var Me = fe.length; Me--; )
    if (fe[Me] === ne)
      return ye[Me] === oe;
  if (fe.push(ne), ye.push(oe), xe) {
    if (Me = ne.length, Me !== oe.length)
      return !1;
    for (; Me--; )
      if (!eq$1(ne[Me], oe[Me], ae - 1, fe, ye))
        return !1;
  } else {
    var Re = Object.keys(ne), je;
    if (Me = Re.length, Object.keys(oe).length !== Me)
      return !1;
    for (; Me--; )
      if (je = Re[Me], !(hasProp(oe, je) && eq$1(ne[je], oe[je], ae - 1, fe, ye)))
        return !1;
  }
  return fe.pop(), ye.pop(), !0;
}
function unwrap(ne) {
  return isObservableArray(ne) ? ne.slice() : isES6Map(ne) || isObservableMap(ne) || isES6Set(ne) || isObservableSet(ne) ? Array.from(ne.entries()) : ne;
}
function makeIterable(ne) {
  return ne[Symbol.iterator] = getSelf, ne;
}
function getSelf() {
  return this;
}
function isAnnotation(ne) {
  return (
    // Can be function
    ne instanceof Object && typeof ne.annotationType_ == "string" && isFunction(ne.make_) && isFunction(ne.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(ne) {
  var oe = getGlobal();
  typeof oe[ne] > "u" && die("MobX requires global '" + ne + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy,
  extras: {
    getDebugName
  },
  $mobx
});
function $r(ne, oe) {
  let ae = {};
  for (let fe in ne)
    ae[fe] = oe(ne[fe], fe);
  return ae;
}
function ur() {
  return pipe(filter((ne) => ne != null));
}
var ue$1 = function() {
  let ne = cr, oe = mr;
  return oe(ne(32), 8) + "-" + oe(ne(16), 4) + "-" + oe(16384 | ne(12), 4) + "-" + oe(32768 | ne(14), 4) + "-" + oe(ne(48), 12);
}, cr = function(ne) {
  if (ne < 0 || ne > 53)
    return NaN;
  let oe = 0 | Math.random() * 1073741824;
  return ne > 30 ? oe + (0 | Math.random() * (1 << ne - 30)) * 1073741824 : oe >>> 30 - ne;
}, mr = function(ne, oe) {
  let ae = ne.toString(16), fe = oe - ae.length, ye = "0";
  for (; fe > 0; fe >>>= 1, ye += ye)
    fe & 1 && (ae = ye + ae);
  return ae;
};
function y$2(ne) {
  return { ...ne, [Symbol.iterator]() {
    return this;
  } };
}
function I$5(ne, oe) {
  return y$2({ next() {
    let { done: ae, value: fe } = ne.next();
    return { done: ae, value: ae ? fe : oe(fe) };
  } });
}
function yr$1(ne) {
  if (ne < 2)
    throw new Error("Minimum size is 2");
  if (ne > 64)
    throw new Error("Maximum size is 64");
  let oe = 2 ** (ne - 1) - 1, ae = -oe - 1;
  return (fe) => {
    if (fe = fe << 0, fe > oe || fe < ae)
      throw console.log("value", fe, oe, ae, fe > oe, fe < ae), new Error(`Int${ne} overflow`);
    return fe < 0 ? 2 ** ne + fe : fe;
  };
}
yr$1(32);
/**
* UUID.core.js - UUID.js for Minimalists
*
* @file
* @author  LiosK
* @version v4.2.0
* @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
* @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
*/
var P$3 = ((ne) => (ne[ne.Boolean = 0] = "Boolean", ne[ne.Number = 1] = "Number", ne[ne.OptionalNumber = 2] = "OptionalNumber", ne[ne.BigInt = 3] = "BigInt", ne[ne.OptionalBigInt = 4] = "OptionalBigInt", ne[ne.String = 5] = "String", ne[ne.OptionalString = 6] = "OptionalString", ne[ne.NumberArray = 7] = "NumberArray", ne[ne.OptionalNumberArray = 8] = "OptionalNumberArray", ne[ne.BigIntArray = 9] = "BigIntArray", ne[ne.OptionalBigIntArray = 10] = "OptionalBigIntArray", ne[ne.StringArray = 11] = "StringArray", ne[ne.OptionalStringArray = 12] = "OptionalStringArray", ne[ne.Entity = 13] = "Entity", ne[ne.OptionalEntity = 14] = "OptionalEntity", ne[ne.EntityArray = 15] = "EntityArray", ne[ne.OptionalEntityArray = 16] = "OptionalEntityArray", ne[ne.T = 17] = "T", ne[ne.OptionalT = 18] = "OptionalT", ne))(P$3 || {}), k$3 = ((ne) => (ne[ne.Enter = 0] = "Enter", ne[ne.Exit = 1] = "Exit", ne[ne.Update = 2] = "Update", ne[ne.Noop = 3] = "Noop", ne))(k$3 || {}), w$1 = [14, 16, 2, 8, 4, 10, 6, 12, 18];
function M$2(ne) {
  let oe = /* @__PURE__ */ new Map();
  function ae(xe) {
    let Oe = oe.get(fe(xe));
    return Oe ? new Set([...Oe].map(v$2)) : /* @__PURE__ */ new Set();
  }
  function fe(xe) {
    return Object.values(xe).join("/");
  }
  function ye(xe, Oe) {
    if (!Oe)
      return;
    let $e = fe(Oe), Me = oe.get($e);
    Me || (Me = /* @__PURE__ */ new Set(), oe.set($e, Me)), Me.add(xe);
  }
  function ve(xe, Oe) {
    if (!Oe)
      return;
    let $e = fe(Oe), Me = oe.get($e);
    Me && Me.delete(xe);
  }
  for (let xe of V$1(ne)) {
    let Oe = g$3(ne, xe);
    ye(p$1(xe), Oe);
  }
  let _e = ne.update$.subscribe(({ entity: xe, value: Oe }) => {
    ve(p$1(xe), Oe[1]), ye(p$1(xe), Oe[0]);
  });
  return ne.world.registerDisposer(() => _e == null ? void 0 : _e.unsubscribe()), { ...ne, getEntitiesWithValue: ae };
}
function U$2(ne, oe) {
  let ae = g$3(oe, ne);
  return { entity: ne, component: oe, value: [ae, void 0], type: ae == null ? 3 : 0 };
}
function Y$2(ne) {
  return pipe(map((oe) => U$2(oe, ne)));
}
function I$4(ne) {
  return "getEntitiesWithValue" in ne;
}
function T$3(ne, oe) {
  return Object.keys(ne.schema).every((ae) => ae in oe);
}
function b$3(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) ?? ((ae = ne.metadata) == null ? void 0 : ae.tableName) ?? ((fe = ne.metadata) == null ? void 0 : fe.tableId) ?? ((ye = ne.metadata) == null ? void 0 : ye.contractId) ?? ne.id;
}
function ie(ne, oe, ae) {
  if (Object.keys(oe).length === 0)
    throw new Error("Component schema must have at least one key");
  let fe = (ae == null ? void 0 : ae.id) ?? ue$1(), ye = $r(oe, () => /* @__PURE__ */ new Map()), ve = new Subject(), _e = ae == null ? void 0 : ae.metadata, xe = { values: ye, schema: oe, id: fe, update$: ve, metadata: _e, entities: () => I$5(Object.values(ye)[0].keys(), v$2), world: ne };
  return ae != null && ae.indexed && (xe = M$2(xe)), ne.registerComponent(xe), xe;
}
function E$2(ne, oe, ae, fe = {}) {
  var _e;
  let ye = p$1(oe), ve = g$3(ne, oe);
  for (let [xe, Oe] of Object.entries(ae))
    ne.values[xe] ? ne.values[xe].set(ye, Oe) : (_e = ne.metadata) != null && _e.tableId && /^\d+$/.test(xe) || console.warn("Component definition for", b$3(ne), "is missing key", xe, ", ignoring value", Oe, "for entity", oe, ". Existing keys: ", Object.keys(ne.values));
  fe.skipUpdateStream || ne.update$.next({ entity: oe, value: [ae, ve], component: ne });
}
function ue(ne, oe, ae = {}) {
  let fe = p$1(oe), ye = g$3(ne, oe);
  for (let ve of Object.keys(ne.values))
    ne.values[ve].delete(fe);
  ae.skipUpdateStream || ne.update$.next({ entity: oe, value: [void 0, ye], component: ne });
}
function le$1(ne, oe) {
  let ae = p$1(oe);
  return Object.values(ne.values)[0].has(ae);
}
function g$3(ne, oe) {
  let ae = {}, fe = p$1(oe), ye = Object.keys(ne.schema);
  for (let ve of ye) {
    let _e = ne.values[ve].get(fe);
    if (_e === void 0 && !w$1.includes(ne.schema[ve]))
      return;
    ae[ve] = _e;
  }
  return ae;
}
function de(ne, oe) {
  let ae = g$3(ne, oe);
  if (!ae)
    throw new Error(`No value for component ${b$3(ne)} on entity ${oe}`);
  return ae;
}
function K$1(ne, oe) {
  if (!ne && !oe)
    return !0;
  if (!ne || !oe)
    return !1;
  let ae = !0;
  for (let fe of Object.keys(ne))
    if (ae = ne[fe] === oe[fe], !ae)
      return !1;
  return ae;
}
function ce(ne, oe) {
  if (I$4(ne) && T$3(ne, oe))
    return ne.getEntitiesWithValue(oe);
  let ae = /* @__PURE__ */ new Set();
  for (let fe of V$1(ne)) {
    let ye = g$3(ne, fe);
    K$1(oe, ye) && ae.add(fe);
  }
  return ae;
}
function V$1(ne) {
  return ne.entities();
}
function p$1(ne) {
  return Symbol.for(ne);
}
function v$2(ne) {
  return Symbol.keyFor(ne);
}
var N$2 = ((ne) => (ne[ne.Has = 0] = "Has", ne[ne.HasValue = 1] = "HasValue", ne[ne.Not = 2] = "Not", ne[ne.NotValue = 3] = "NotValue", ne[ne.ProxyRead = 4] = "ProxyRead", ne[ne.ProxyExpand = 5] = "ProxyExpand", ne))(N$2 || {});
function Le(ne) {
  return { type: 0, component: ne };
}
function c$3(ne, oe) {
  if (oe.type === 0)
    return le$1(oe.component, ne);
  if (oe.type === 1)
    return K$1(oe.value, g$3(oe.component, ne));
  if (oe.type === 2)
    return !le$1(oe.component, ne);
  if (oe.type === 3)
    return !K$1(oe.value, g$3(oe.component, ne));
  throw new Error("Unknown query fragment");
}
function G$1(ne) {
  return ne.type === 0 || ne.type == 1;
}
function P$2(ne) {
  return ne.type === 2 || ne.type == 3;
}
function J(ne) {
  return ne.type === 5 || ne.type == 4;
}
function U$1(ne, oe) {
  return ne && G$1(oe) || !ne && P$2(oe);
}
function I$3(ne, oe, ae) {
  let fe = ne, ye = !1;
  for (let ve = 0; ve < ae.depth; ve++) {
    let _e = g$3(ae.component, fe);
    if (!_e)
      return null;
    let xe = _e.value;
    if (!xe)
      return null;
    if (fe = xe, ye = c$3(fe, oe), U$1(ye, oe))
      return ye;
  }
  return ye;
}
function Q$2(ne, oe, ae) {
  if (ae === 0)
    return /* @__PURE__ */ new Set();
  let fe = ce(oe, { value: ne });
  if (ae === 1)
    return fe;
  let ye = [...fe].map((ve) => [...Q$2(ve, oe, ae - 1)]).flat();
  return /* @__PURE__ */ new Set([...fe, ...ye]);
}
function A$2(ne, oe) {
  let ae = oe ? /* @__PURE__ */ new Set([...oe]) : void 0, fe, ye;
  for (let ve = 0; ve < ne.length; ve++) {
    let _e = ne[ve];
    if (J(_e))
      _e.type === 4 && (fe = _e), _e.type === 5 && (ye = _e);
    else if (ae)
      for (let xe of [...ae]) {
        let Oe = c$3(xe, _e);
        if (fe && fe.depth > 0 && !U$1(Oe, _e) && (Oe = I$3(xe, _e, fe) ?? Oe), Oe || ae.delete(xe), ye && ye.depth > 0) {
          let $e = Q$2(xe, ye.component, ye.depth);
          for (let Me of $e)
            (c$3(Me, _e) || fe && fe.depth > 0 && I$3(Me, _e, fe)) && ae.add(Me);
        }
      }
    else {
      if (P$2(_e))
        throw new Error("First EntityQueryFragment must be Has or HasValue");
      if (ae = _e.type === 0 ? /* @__PURE__ */ new Set([...V$1(_e.component)]) : ce(_e.component, _e.value), ye && ye.depth > 0)
        for (let xe of [...ae])
          for (let Oe of Q$2(xe, ye.component, ye.depth))
            ae.add(Oe);
    }
  }
  return ae ?? /* @__PURE__ */ new Set();
}
function f$2(ne, oe) {
  let ae = oe != null && oe.runOnInit || oe != null && oe.initialSet ? A$2(ne, oe.initialSet) : /* @__PURE__ */ new Set(), fe = observable(ae), ye = from(fe).pipe(Y$2(ne[0].component)), ve = ne.findIndex((xe) => [5, 4].includes(xe.type)) !== -1, _e = merge(...ne.map((xe) => xe.component.update$)).pipe(ve ? concatMap((xe) => {
    let Oe = A$2(ne, oe == null ? void 0 : oe.initialSet), $e = [];
    for (let Me of fe)
      Oe.has(Me) || (fe.delete(Me), $e.push({ entity: Me, type: 1, component: xe.component, value: [void 0, void 0] }));
    for (let Me of Oe)
      fe.has(Me) ? $e.push({ entity: Me, type: 2, component: xe.component, value: [g$3(xe.component, Me), void 0] }) : (fe.add(Me), $e.push({ entity: Me, type: 0, component: xe.component, value: [g$3(xe.component, Me), void 0] }));
    return of(...$e);
  }) : map((xe) => {
    if (fe.has(xe.entity))
      return ne.filter((Oe) => Oe.component.id === xe.component.id).every((Oe) => c$3(xe.entity, Oe)) ? { ...xe, type: 2 } : (fe.delete(xe.entity), { ...xe, type: 1 });
    if (ne.every((Oe) => c$3(xe.entity, Oe)))
      return fe.add(xe.entity), { ...xe, type: 0 };
  }), ur());
  return { matching: fe, update$: concat(ye, _e).pipe(share()) };
}
function lt() {
  let ne = /* @__PURE__ */ new Set(), oe = [], ae = [];
  function fe({ id: Me, idSuffix: Re } = {}) {
    let je = Me || ne.size + (Re ? "-" + Re : ""), Be = p$1(je);
    return ne.add(Be), je;
  }
  function ye() {
    return I$5(ne.values(), v$2);
  }
  function ve(Me) {
    oe.push(Me);
  }
  function _e(Me) {
    for (let [, Re] of ae.filter((je) => !Me || je[0] === Me))
      Re();
    ae = ae.filter((Re) => Me && Re[0] !== Me);
  }
  function xe(Me, Re = "") {
    ae.push([Re, Me]);
  }
  function Oe(Me) {
    let Re = p$1(Me);
    return ne.has(Re);
  }
  function $e(Me) {
    for (let Re of oe)
      le$1(Re, Me) && ue(Re, Me);
    ne.delete(p$1(Me));
  }
  return { registerEntity: fe, components: oe, registerComponent: ve, dispose: _e, registerDisposer: xe, hasEntity: Oe, getEntities: ye, entitySymbols: ne, deleteEntity: $e };
}
function v$1(ne) {
  if (!isHex$1(ne))
    throw new Error(`entity ${ne} is not a hex string`);
  let oe = size$2(ne);
  if (oe % 32 !== 0)
    throw new Error(`entity length ${oe} is not a multiple of 32 bytes`);
  return new Array(oe / 32).fill(0).map((ae, fe) => sliceHex(ne, fe * 32, (fe + 1) * 32));
}
var H$1 = /* @__PURE__ */ new Map();
function nt$1(ne) {
  let oe = H$1.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$4(8096);
  return H$1.set(ne, ae), ae;
}
function rt(ne, oe) {
  let ae = v$1(oe);
  if (ae.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ae.length} does not match key schema length ${Object.keys(ne).length}`);
  return Object.fromEntries(Object.entries(ne).map(([fe, ye], ve) => [fe, decodeAbiParameters([{ type: ye }], ae[ve])[0]]));
}
function vt(ne, oe) {
  let ae = nt$1(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = v$1(oe);
  if (ye.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ye.length} does not match key schema length ${Object.keys(ne).length}`);
  let ve = rt(ne, oe);
  return ae.set(oe, ve), ve;
}
function d$1(ne) {
  return concatHex$1(ne);
}
var j$1 = /* @__PURE__ */ new Map();
function st(ne) {
  let oe = j$1.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$4(8096);
  return j$1.set(ne, ae), ae;
}
function mt(ne, oe) {
  if (Object.keys(ne).length !== Object.keys(oe).length)
    throw new Error(`key length ${Object.keys(oe).length} does not match key schema length ${Object.keys(ne).length}`);
  return d$1(Object.entries(ne).map(([ae, fe]) => encodeAbiParameters([{ type: fe }], [oe[ae]])));
}
function M$1(ne, oe) {
  let ae = st(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = mt(ne, oe);
  return ae.set(oe, ye), ye;
}
function Pt(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) != null && ((ae = ne.metadata) == null ? void 0 : ae.tableName) != null && ((fe = ne.metadata) == null ? void 0 : fe.keySchema) != null && ((ye = ne.metadata) == null ? void 0 : ye.valueSchema) != null;
}
var b$2 = S.extend("recs"), ct = S.extend("reccs");
b$2.log = console.debug.bind(console);
ct.log = console.error.bind(console);
function V(ne) {
  return { RegisteredTables: ie(ne, { table: P$3.T }, { metadata: { componentName: "RegisteredTables" } }), SyncProgress: ie(ne, { step: P$3.String, message: P$3.String, percentage: P$3.Number, latestBlockNumber: P$3.BigInt, lastBlockNumberProcessed: P$3.BigInt }, { metadata: { componentName: "SyncProgress" } }) };
}
function E$1(ne) {
  return M$1({ address: "address", namespace: "bytes16", name: "bytes16" }, { address: ne.address, namespace: stringToHex$1(ne.namespace, { size: 16 }), name: stringToHex$1(ne.name, { size: 16 }) });
}
var T$2 = d$1([]), z = { uint8: P$3.Number, uint16: P$3.Number, uint24: P$3.Number, uint32: P$3.Number, uint40: P$3.Number, uint48: P$3.Number, uint56: P$3.BigInt, uint64: P$3.BigInt, uint72: P$3.BigInt, uint80: P$3.BigInt, uint88: P$3.BigInt, uint96: P$3.BigInt, uint104: P$3.BigInt, uint112: P$3.BigInt, uint120: P$3.BigInt, uint128: P$3.BigInt, uint136: P$3.BigInt, uint144: P$3.BigInt, uint152: P$3.BigInt, uint160: P$3.BigInt, uint168: P$3.BigInt, uint176: P$3.BigInt, uint184: P$3.BigInt, uint192: P$3.BigInt, uint200: P$3.BigInt, uint208: P$3.BigInt, uint216: P$3.BigInt, uint224: P$3.BigInt, uint232: P$3.BigInt, uint240: P$3.BigInt, uint248: P$3.BigInt, uint256: P$3.BigInt, int8: P$3.Number, int16: P$3.Number, int24: P$3.Number, int32: P$3.Number, int40: P$3.Number, int48: P$3.Number, int56: P$3.BigInt, int64: P$3.BigInt, int72: P$3.BigInt, int80: P$3.BigInt, int88: P$3.BigInt, int96: P$3.BigInt, int104: P$3.BigInt, int112: P$3.BigInt, int120: P$3.BigInt, int128: P$3.BigInt, int136: P$3.BigInt, int144: P$3.BigInt, int152: P$3.BigInt, int160: P$3.BigInt, int168: P$3.BigInt, int176: P$3.BigInt, int184: P$3.BigInt, int192: P$3.BigInt, int200: P$3.BigInt, int208: P$3.BigInt, int216: P$3.BigInt, int224: P$3.BigInt, int232: P$3.BigInt, int240: P$3.BigInt, int248: P$3.BigInt, int256: P$3.BigInt, bytes1: P$3.String, bytes2: P$3.String, bytes3: P$3.String, bytes4: P$3.String, bytes5: P$3.String, bytes6: P$3.String, bytes7: P$3.String, bytes8: P$3.String, bytes9: P$3.String, bytes10: P$3.String, bytes11: P$3.String, bytes12: P$3.String, bytes13: P$3.String, bytes14: P$3.String, bytes15: P$3.String, bytes16: P$3.String, bytes17: P$3.String, bytes18: P$3.String, bytes19: P$3.String, bytes20: P$3.String, bytes21: P$3.String, bytes22: P$3.String, bytes23: P$3.String, bytes24: P$3.String, bytes25: P$3.String, bytes26: P$3.String, bytes27: P$3.String, bytes28: P$3.String, bytes29: P$3.String, bytes30: P$3.String, bytes31: P$3.String, bytes32: P$3.String, bool: P$3.Boolean, address: P$3.String, "uint8[]": P$3.NumberArray, "uint16[]": P$3.NumberArray, "uint24[]": P$3.NumberArray, "uint32[]": P$3.NumberArray, "uint40[]": P$3.NumberArray, "uint48[]": P$3.NumberArray, "uint56[]": P$3.BigIntArray, "uint64[]": P$3.BigIntArray, "uint72[]": P$3.BigIntArray, "uint80[]": P$3.BigIntArray, "uint88[]": P$3.BigIntArray, "uint96[]": P$3.BigIntArray, "uint104[]": P$3.BigIntArray, "uint112[]": P$3.BigIntArray, "uint120[]": P$3.BigIntArray, "uint128[]": P$3.BigIntArray, "uint136[]": P$3.BigIntArray, "uint144[]": P$3.BigIntArray, "uint152[]": P$3.BigIntArray, "uint160[]": P$3.BigIntArray, "uint168[]": P$3.BigIntArray, "uint176[]": P$3.BigIntArray, "uint184[]": P$3.BigIntArray, "uint192[]": P$3.BigIntArray, "uint200[]": P$3.BigIntArray, "uint208[]": P$3.BigIntArray, "uint216[]": P$3.BigIntArray, "uint224[]": P$3.BigIntArray, "uint232[]": P$3.BigIntArray, "uint240[]": P$3.BigIntArray, "uint248[]": P$3.BigIntArray, "uint256[]": P$3.BigIntArray, "int8[]": P$3.NumberArray, "int16[]": P$3.NumberArray, "int24[]": P$3.NumberArray, "int32[]": P$3.NumberArray, "int40[]": P$3.NumberArray, "int48[]": P$3.NumberArray, "int56[]": P$3.BigIntArray, "int64[]": P$3.BigIntArray, "int72[]": P$3.BigIntArray, "int80[]": P$3.BigIntArray, "int88[]": P$3.BigIntArray, "int96[]": P$3.BigIntArray, "int104[]": P$3.BigIntArray, "int112[]": P$3.BigIntArray, "int120[]": P$3.BigIntArray, "int128[]": P$3.BigIntArray, "int136[]": P$3.BigIntArray, "int144[]": P$3.BigIntArray, "int152[]": P$3.BigIntArray, "int160[]": P$3.BigIntArray, "int168[]": P$3.BigIntArray, "int176[]": P$3.BigIntArray, "int184[]": P$3.BigIntArray, "int192[]": P$3.BigIntArray, "int200[]": P$3.BigIntArray, "int208[]": P$3.BigIntArray, "int216[]": P$3.BigIntArray, "int224[]": P$3.BigIntArray, "int232[]": P$3.BigIntArray, "int240[]": P$3.BigIntArray, "int248[]": P$3.BigIntArray, "int256[]": P$3.BigIntArray, "bytes1[]": P$3.StringArray, "bytes2[]": P$3.StringArray, "bytes3[]": P$3.StringArray, "bytes4[]": P$3.StringArray, "bytes5[]": P$3.StringArray, "bytes6[]": P$3.StringArray, "bytes7[]": P$3.StringArray, "bytes8[]": P$3.StringArray, "bytes9[]": P$3.StringArray, "bytes10[]": P$3.StringArray, "bytes11[]": P$3.StringArray, "bytes12[]": P$3.StringArray, "bytes13[]": P$3.StringArray, "bytes14[]": P$3.StringArray, "bytes15[]": P$3.StringArray, "bytes16[]": P$3.StringArray, "bytes17[]": P$3.StringArray, "bytes18[]": P$3.StringArray, "bytes19[]": P$3.StringArray, "bytes20[]": P$3.StringArray, "bytes21[]": P$3.StringArray, "bytes22[]": P$3.StringArray, "bytes23[]": P$3.StringArray, "bytes24[]": P$3.StringArray, "bytes25[]": P$3.StringArray, "bytes26[]": P$3.StringArray, "bytes27[]": P$3.StringArray, "bytes28[]": P$3.StringArray, "bytes29[]": P$3.StringArray, "bytes30[]": P$3.StringArray, "bytes31[]": P$3.StringArray, "bytes32[]": P$3.StringArray, "bool[]": P$3.T, "address[]": P$3.StringArray, bytes: P$3.String, string: P$3.String };
function q$1(ne, oe) {
  let ae = ia(Xi$1(oe)), fe = ia(Zi(oe));
  return ie(ne, { ...P$8(fe, (ye) => z[ye]), __staticData: P$3.OptionalString, __encodedLengths: P$3.OptionalString, __dynamicData: P$3.OptionalString }, { id: oe.tableId, metadata: { componentName: oe.label, tableName: oe.label, keySchema: ae, valueSchema: fe } });
}
function F(ne, oe) {
  return Object.fromEntries(Object.entries(oe).map(([, ae]) => [ae.label, q$1(ne, ae)]));
}
function Q$1({ world: ne, tables: oe, shouldSkipUpdateStream: ae }) {
  ne.registerEntity({ id: T$2 });
  let fe = { ...F(ne, oe), ...V(ne) };
  async function ye({ logs: ve }) {
    var xe, Oe;
    let _e = ve.filter(L$1).map(K$2);
    for (let $e of _e) {
      let Me = E$1($e);
      le$1(fe.RegisteredTables, Me) ? console.warn("table already registered, ignoring", { newTable: $e, existingTable: (xe = g$3(fe.RegisteredTables, Me)) == null ? void 0 : xe.table }) : E$2(fe.RegisteredTables, Me, { table: $e }, { skipUpdateStream: ae == null ? void 0 : ae() });
    }
    for (let $e of ve) {
      let { namespace: Me, name: Re } = _$4($e.args.tableId), je = (Oe = g$3(fe.RegisteredTables, E$1({ address: $e.address, namespace: Me, name: Re }))) == null ? void 0 : Oe.table;
      if (!je) {
        b$2(`skipping update for unknown table: ${i$6({ namespace: Me, name: Re })} at ${$e.address}`);
        continue;
      }
      let Be = ne.components.find((He) => He.id === je.tableId);
      if (!Be) {
        b$2(`skipping update for unknown component: ${je.tableId} (${i$6({ namespace: Me, name: Re })}). Available components: ${Object.keys(fe)}`);
        continue;
      }
      let ze = d$1($e.args.keyTuple);
      if ($e.eventName === "Store_SetRecord") {
        let He = zt$1(je.valueSchema, $e.args);
        b$2("setting component", { namespace: je.namespace, name: je.name, entity: ze, value: He }), E$2(Be, ze, { ...He, __staticData: $e.args.staticData, __encodedLengths: $e.args.encodedLengths, __dynamicData: $e.args.dynamicData }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if ($e.eventName === "Store_SpliceStaticData") {
        let He = g$3(Be, ze), qe = (He == null ? void 0 : He.__staticData) ?? "0x", Ye = Pe(qe, $e.args.start, size$2($e.args.data), $e.args.data), pt = zt$1(je.valueSchema, { staticData: Ye, encodedLengths: (He == null ? void 0 : He.__encodedLengths) ?? "0x", dynamicData: (He == null ? void 0 : He.__dynamicData) ?? "0x" });
        b$2("setting component via splice static", { namespace: je.namespace, name: je.name, entity: ze, previousStaticData: qe, newStaticData: Ye, previousValue: He, newValue: pt }), E$2(Be, ze, { ...pt, __staticData: Ye }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if ($e.eventName === "Store_SpliceDynamicData") {
        let He = g$3(Be, ze), qe = (He == null ? void 0 : He.__dynamicData) ?? "0x", Ye = Pe(qe, $e.args.start, $e.args.deleteCount, $e.args.data), pt = zt$1(je.valueSchema, { staticData: (He == null ? void 0 : He.__staticData) ?? "0x", encodedLengths: $e.args.encodedLengths, dynamicData: Ye });
        b$2("setting component via splice dynamic", { namespace: je.namespace, name: je.name, entity: ze, previousDynamicData: qe, newDynamicData: Ye, previousValue: He, newValue: pt }), E$2(Be, ze, { ...pt, __encodedLengths: $e.args.encodedLengths, __dynamicData: Ye }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else
        $e.eventName === "Store_DeleteRecord" && (b$2("deleting component", { namespace: je.namespace, name: je.name, entity: ze }), ue(Be, ze, { skipUpdateStream: ae == null ? void 0 : ae() }));
    }
  }
  return { storageAdapter: ye, components: fe };
}
async function Ke({ world: ne, config: oe, tables: ae = {}, startSync: fe = !0, ...ye }) {
  let ve = { ...O(oe), ...ae, ...A$3 }, { storageAdapter: _e, components: xe } = Q$1({ world: ne, tables: ve, shouldSkipUpdateStream: () => {
    var Re;
    return ((Re = g$3(xe.SyncProgress, T$2)) == null ? void 0 : Re.step) !== "live";
  } }), Oe = await Et({ storageAdapter: _e, config: oe, ...ye, onProgress: ({ step: Re, percentage: je, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }) => {
    var qe;
    if (((qe = g$3(xe.SyncProgress, T$2)) == null ? void 0 : qe.step) !== "live" && (E$2(xe.SyncProgress, T$2, { step: Re, percentage: je, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }), Re === "live"))
      for (let Ye of Object.values(xe)) {
        let pt = Ye;
        for (let dt of pt.entities()) {
          let yt = g$3(pt, dt);
          pt.update$.next({ component: pt, entity: dt, value: [yt, yt] });
        }
      }
  } }), $e = fe ? Oe.storedBlockLogs$.subscribe() : null, Me = () => {
    $e == null || $e.unsubscribe();
  };
  return ne.registerDisposer(Me), { ...Oe, components: xe, stopSync: Me };
}
const worldsJson = {
  4242: {
    address: "0x079f71c3f6e9f4813ef249980F2a3b22dDc1263c",
    ToadNumber: 27977825
  },
  17069: {
    address: "0xedaae3536b8b8694fc2cbf42c14c1137a7646c30",
    blockNumber: 6676117
  },
  31337: {
    address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
  }
}, contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(ne) {
      var ae;
      return {
        transactions: (ae = ne.transactions) == null ? void 0 : ae.map((fe) => {
          if (typeof fe == "string")
            return fe;
          const ye = formatTransaction(fe);
          return ye.typeHex === "0x7e" && (ye.isSystemTx = fe.isSystemTx, ye.mint = fe.mint ? hexToBigInt(fe.mint) : void 0, ye.sourceHash = fe.sourceHash, ye.type = "deposit"), ye;
        }),
        stateRoot: ne.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(ne) {
      const oe = {};
      return ne.type === "0x7e" && (oe.isSystemTx = ne.isSystemTx, oe.mint = ne.mint ? hexToBigInt(ne.mint) : void 0, oe.sourceHash = ne.sourceHash, oe.type = "deposit"), oe;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(ne) {
      return {
        l1GasPrice: ne.l1GasPrice ? hexToBigInt(ne.l1GasPrice) : null,
        l1GasUsed: ne.l1GasUsed ? hexToBigInt(ne.l1GasUsed) : null,
        l1Fee: ne.l1Fee ? hexToBigInt(ne.l1Fee) : null,
        l1FeeScalar: ne.l1FeeScalar ? Number(ne.l1FeeScalar) : null
      };
    }
  })
};
function serializeTransaction(ne, oe) {
  return isDeposit(ne) ? serializeTransactionDeposit(ne) : serializeTransaction$1(ne, oe);
}
const serializers = {
  transaction: serializeTransaction
};
function serializeTransactionDeposit(ne) {
  assertTransactionDeposit(ne);
  const { sourceHash: oe, data: ae, from: fe, gas: ye, isSystemTx: ve, mint: _e, to: xe, value: Oe } = ne, $e = [
    oe,
    fe,
    xe ?? "0x",
    _e ? toHex$1(_e) : "0x",
    Oe ? toHex$1(Oe) : "0x",
    ye ? toHex$1(ye) : "0x",
    ve ? "0x1" : "0x",
    ae ?? "0x"
  ];
  return concatHex$1([
    "0x7e",
    toRlp($e)
  ]);
}
function isDeposit(ne) {
  return ne.type === "deposit" || typeof ne.sourceHash < "u";
}
function assertTransactionDeposit(ne) {
  const { from: oe, to: ae } = ne;
  if (oe && !isAddress(oe))
    throw new InvalidAddressError({ address: oe });
  if (ae && !isAddress(ae))
    throw new InvalidAddressError({ address: ae });
}
const chainConfig = {
  contracts,
  formatters,
  serializers
}, foundry = /* @__PURE__ */ defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});
var o$3 = { ...foundry, fees: { defaultPriorityFee: 0n } }, e$2 = 17e3, c$2 = { ...chainConfig, id: 17069, sourceId: e$2, name: "Garnet Holesky", testnet: !0, nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 }, rpcUrls: { default: { http: ["https://rpc.garnetchain.com"], webSocket: ["wss://rpc.garnetchain.com"] } }, blockExplorers: { default: { name: "Blockscout", url: "https://explorer.garnetchain.com" } }, contracts: { ...chainConfig.contracts, multicall3: { address: "0xca11bde05977b3631167028862be2a173976ca11" }, portal: { [e$2]: { address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909", blockCreated: 1274684 } }, l2OutputOracle: { [e$2]: { address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B", blockCreated: 1274684 } }, l1StandardBridge: { [e$2]: { address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE", blockCreated: 1274684 } } }, iconUrls: ["https://redstone.xyz/chain-icons/garnet.png"], indexerUrl: "https://indexer.mud.garnetchain.com" }, t = 1;
({ ...chainConfig, contracts: { ...chainConfig.contracts, portal: t + "", l2OutputOracle: t + "", l1StandardBridge: t + "" } });
const supportedChains = [o$3, c$2], worlds = worldsJson;
async function getNetworkConfig() {
  const ne = new URLSearchParams(window.location.search), oe = Number(ne.get("chainId") || ne.get("chainid") || {}.VITE_CHAIN_ID || 17069), ae = supportedChains.findIndex((Oe) => Oe.id === oe), fe = supportedChains[ae];
  if (!fe)
    throw new Error(`Chain ${oe} not found`);
  const ye = worlds[fe.id.toString()], ve = ne.get("worldAddress") || (ye == null ? void 0 : ye.address);
  if (!ve)
    throw new Error(`No world address found for chain ${oe}. Did you run \`mud deploy\`?`);
  const _e = ne.has("initialBlockNumber") ? Number(ne.get("initialBlockNumber")) : (ye == null ? void 0 : ye.blockNumber) ?? 0n;
  return {
    privateKey: ne.get("pk") || "0x000000000000000000000000832cce0f0faef94f242adad051e015bed9ffa7d4",
    //getBurnerPrivateKey(),
    chainId: oe,
    chain: fe,
    faucetServiceUrl: ne.get("faucet") ?? fe.faucetUrl,
    worldAddress: ve,
    initialBlockNumber: _e
  };
}
const world = lt(), IWorldAbi = [
  {
    type: "function",
    name: "_calculateLosses",
    inputs: [
      {
        name: "armyKey",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "defenceLocation",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256[8]",
        internalType: "uint256[8]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "attack",
    inputs: [
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCall",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallData[]",
        components: [
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCallFrom",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallFromData[]",
        components: [
          {
            name: "from",
            type: "address",
            internalType: "address"
          },
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryA",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryC",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantry",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantryByToken",
    inputs: [
      {
        name: "token_type",
        type: "uint8",
        internalType: "enum TokenType"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "call",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "callFrom",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "claim",
    inputs: [
      {
        name: "proof",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "claimRewardB",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "creator",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "farming",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "garrison",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getArmyPower",
    inputs: [
      {
        name: "entityKey",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldSlice",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLayout",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getKeySchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLandPower",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPairAmounts",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStageOneEndTime",
    inputs: [],
    outputs: [
      {
        name: "timestamp",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getStakeLimit",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTokenAmounts",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getValueSchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initAllowance",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "initModule",
        type: "address",
        internalType: "contract IModule"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installRootModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "march",
    inputs: [
      {
        name: "destination",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "passiveUnStake",
    inputs: [
      {
        name: "defender",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "attacker",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "popFromDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "byteLengthToPop",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pushToDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "dataToPush",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespace",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerRootFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "worldFunctionSignature",
        type: "string",
        internalType: "string"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystem",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "system",
        type: "address",
        internalType: "contract System"
      },
      {
        name: "publicAccess",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerTable",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      },
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "keyNames",
        type: "string[]",
        internalType: "string[]"
      },
      {
        name: "fieldNames",
        type: "string[]",
        internalType: "string[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBurnRate",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setLastStakeTime",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setMerkleRoot",
    inputs: [
      {
        name: "_merkleRoot",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setNetValue",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setOwner",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPassiveUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setRewardPerSecondReward",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spawnCapital",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "spawnPlayer",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stakeTokenB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "storeVersion",
    inputs: [],
    outputs: [
      {
        name: "version",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "swapA2B",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "swapA2C",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToAddress",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToNamespace",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ultraBurnTokenB",
    inputs: [
      {
        name: "net_value",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "stake_reward",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ultraMintTokenB",
    inputs: [
      {
        name: "net_value",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "stake_reward",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unstakeB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "withdrawToken",
    inputs: [
      {
        name: "tokenAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "worldVersion",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "HelloStore",
    inputs: [
      {
        name: "storeVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "HelloWorld",
    inputs: [
      {
        name: "worldVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_DeleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SetRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        indexed: !1,
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "deleteCount",
        type: "uint40",
        indexed: !1,
        internalType: "uint40"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "EncodedLengths_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_Empty",
    inputs: []
  },
  {
    type: "error",
    name: "FieldLayout_InvalidStaticDataLength",
    inputs: [
      {
        name: "staticDataLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "computedStaticDataLength",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthDoesNotFitInAWord",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsNotZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyDynamicFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Module_AlreadyInstalled",
    inputs: []
  },
  {
    type: "error",
    name: "Module_MissingDependency",
    inputs: [
      {
        name: "dependency",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "Module_NonRootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Module_RootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Schema_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Schema_StaticTypeAfterDynamicType",
    inputs: []
  },
  {
    type: "error",
    name: "Slice_OutOfBounds",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_IndexOutOfBounds",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "accessedIndex",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidBounds",
    inputs: [
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidFieldNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidKeyNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidSplice",
    inputs: [
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "fieldLength",
        type: "uint40",
        internalType: "uint40"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidStaticDataLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaDynamicLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaStaticLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableAlreadyExists",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableNotFound",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_AccessDenied",
    inputs: [
      {
        name: "resource",
        type: "string",
        internalType: "string"
      },
      {
        name: "caller",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_AlreadyInitialized",
    inputs: []
  },
  {
    type: "error",
    name: "World_CallbackNotAllowed",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_DelegationNotFound",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorAlreadyExists",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorNotFound",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "World_InterfaceNotSupported",
    inputs: [
      {
        name: "contractAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidNamespace",
    inputs: [
      {
        name: "namespace",
        type: "bytes14",
        internalType: "bytes14"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceId",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceAlreadyExists",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceNotFound",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_SystemAlreadyExists",
    inputs: [
      {
        name: "system",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_UnlimitedDelegationNotAllowed",
    inputs: []
  }
], IERC20Abi = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "spender",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "balanceOf",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalSupply",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "transfer",
    inputs: [
      {
        name: "to",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferFrom",
    inputs: [
      {
        name: "from",
        type: "address",
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        name: "owner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  }
];
var n = ["uint8", "uint16", "uint24", "uint32", "uint40", "uint48", "uint56", "uint64", "uint72", "uint80", "uint88", "uint96", "uint104", "uint112", "uint120", "uint128", "uint136", "uint144", "uint152", "uint160", "uint168", "uint176", "uint184", "uint192", "uint200", "uint208", "uint216", "uint224", "uint232", "uint240", "uint248", "uint256", "int8", "int16", "int24", "int32", "int40", "int48", "int56", "int64", "int72", "int80", "int88", "int96", "int104", "int112", "int120", "int128", "int136", "int144", "int152", "int160", "int168", "int176", "int184", "int192", "int200", "int208", "int216", "int224", "int232", "int240", "int248", "int256", "bytes1", "bytes2", "bytes3", "bytes4", "bytes5", "bytes6", "bytes7", "bytes8", "bytes9", "bytes10", "bytes11", "bytes12", "bytes13", "bytes14", "bytes15", "bytes16", "bytes17", "bytes18", "bytes19", "bytes20", "bytes21", "bytes22", "bytes23", "bytes24", "bytes25", "bytes26", "bytes27", "bytes28", "bytes29", "bytes30", "bytes31", "bytes32", "bool", "address", "uint8[]", "uint16[]", "uint24[]", "uint32[]", "uint40[]", "uint48[]", "uint56[]", "uint64[]", "uint72[]", "uint80[]", "uint88[]", "uint96[]", "uint104[]", "uint112[]", "uint120[]", "uint128[]", "uint136[]", "uint144[]", "uint152[]", "uint160[]", "uint168[]", "uint176[]", "uint184[]", "uint192[]", "uint200[]", "uint208[]", "uint216[]", "uint224[]", "uint232[]", "uint240[]", "uint248[]", "uint256[]", "int8[]", "int16[]", "int24[]", "int32[]", "int40[]", "int48[]", "int56[]", "int64[]", "int72[]", "int80[]", "int88[]", "int96[]", "int104[]", "int112[]", "int120[]", "int128[]", "int136[]", "int144[]", "int152[]", "int160[]", "int168[]", "int176[]", "int184[]", "int192[]", "int200[]", "int208[]", "int216[]", "int224[]", "int232[]", "int240[]", "int248[]", "int256[]", "bytes1[]", "bytes2[]", "bytes3[]", "bytes4[]", "bytes5[]", "bytes6[]", "bytes7[]", "bytes8[]", "bytes9[]", "bytes10[]", "bytes11[]", "bytes12[]", "bytes13[]", "bytes14[]", "bytes15[]", "bytes16[]", "bytes17[]", "bytes18[]", "bytes19[]", "bytes20[]", "bytes21[]", "bytes22[]", "bytes23[]", "bytes24[]", "bytes25[]", "bytes26[]", "bytes27[]", "bytes28[]", "bytes29[]", "bytes30[]", "bytes31[]", "bytes32[]", "bool[]", "address[]", "bytes", "string"], a$1 = n.slice(0, 98);
function o$2(ne) {
  return n.includes(ne);
}
function e$1(ne) {
  return a$1.includes(ne);
}
var i$3 = /\[\d+\]$/;
function A$1(ne) {
  return typeof ne == "string" && i$3.test(ne) && e$1(ne.replace(i$3, ""));
}
function f$1(ne) {
  return ne.replace(i$3, "[]");
}
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var ne = 1e3, oe = ne * 60, ae = oe * 60, fe = ae * 24, ye = fe * 7, ve = fe * 365.25;
  ms = function(Me, Re) {
    Re = Re || {};
    var je = typeof Me;
    if (je === "string" && Me.length > 0)
      return _e(Me);
    if (je === "number" && isFinite(Me))
      return Re.long ? Oe(Me) : xe(Me);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(Me)
    );
  };
  function _e(Me) {
    if (Me = String(Me), !(Me.length > 100)) {
      var Re = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        Me
      );
      if (Re) {
        var je = parseFloat(Re[1]), Be = (Re[2] || "ms").toLowerCase();
        switch (Be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return je * ve;
          case "weeks":
          case "week":
          case "w":
            return je * ye;
          case "days":
          case "day":
          case "d":
            return je * fe;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return je * ae;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return je * oe;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return je * ne;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return je;
          default:
            return;
        }
      }
    }
  }
  function xe(Me) {
    var Re = Math.abs(Me);
    return Re >= fe ? Math.round(Me / fe) + "d" : Re >= ae ? Math.round(Me / ae) + "h" : Re >= oe ? Math.round(Me / oe) + "m" : Re >= ne ? Math.round(Me / ne) + "s" : Me + "ms";
  }
  function Oe(Me) {
    var Re = Math.abs(Me);
    return Re >= fe ? $e(Me, Re, fe, "day") : Re >= ae ? $e(Me, Re, ae, "hour") : Re >= oe ? $e(Me, Re, oe, "minute") : Re >= ne ? $e(Me, Re, ne, "second") : Me + " ms";
  }
  function $e(Me, Re, je, Be) {
    var ze = Re >= je * 1.5;
    return Math.round(Me / je) + " " + Be + (ze ? "s" : "");
  }
  return ms;
}
function setup$1(ne) {
  ae.debug = ae, ae.default = ae, ae.coerce = Oe, ae.disable = ve, ae.enable = ye, ae.enabled = _e, ae.humanize = requireMs(), ae.destroy = $e, Object.keys(ne).forEach((Me) => {
    ae[Me] = ne[Me];
  }), ae.names = [], ae.skips = [], ae.formatters = {};
  function oe(Me) {
    let Re = 0;
    for (let je = 0; je < Me.length; je++)
      Re = (Re << 5) - Re + Me.charCodeAt(je), Re |= 0;
    return ae.colors[Math.abs(Re) % ae.colors.length];
  }
  ae.selectColor = oe;
  function ae(Me) {
    let Re, je = null, Be, ze;
    function He(...qe) {
      if (!He.enabled)
        return;
      const Ye = He, pt = Number(/* @__PURE__ */ new Date()), dt = pt - (Re || pt);
      Ye.diff = dt, Ye.prev = Re, Ye.curr = pt, Re = pt, qe[0] = ae.coerce(qe[0]), typeof qe[0] != "string" && qe.unshift("%O");
      let yt = 0;
      qe[0] = qe[0].replace(/%([a-zA-Z%])/g, (It, Vt) => {
        if (It === "%%")
          return "%";
        yt++;
        const Ut = ae.formatters[Vt];
        if (typeof Ut == "function") {
          const Zt = qe[yt];
          It = Ut.call(Ye, Zt), qe.splice(yt, 1), yt--;
        }
        return It;
      }), ae.formatArgs.call(Ye, qe), (Ye.log || ae.log).apply(Ye, qe);
    }
    return He.namespace = Me, He.useColors = ae.useColors(), He.color = ae.selectColor(Me), He.extend = fe, He.destroy = ae.destroy, Object.defineProperty(He, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => je !== null ? je : (Be !== ae.namespaces && (Be = ae.namespaces, ze = ae.enabled(Me)), ze),
      set: (qe) => {
        je = qe;
      }
    }), typeof ae.init == "function" && ae.init(He), He;
  }
  function fe(Me, Re) {
    const je = ae(this.namespace + (typeof Re > "u" ? ":" : Re) + Me);
    return je.log = this.log, je;
  }
  function ye(Me) {
    ae.save(Me), ae.namespaces = Me, ae.names = [], ae.skips = [];
    let Re;
    const je = (typeof Me == "string" ? Me : "").split(/[\s,]+/), Be = je.length;
    for (Re = 0; Re < Be; Re++)
      je[Re] && (Me = je[Re].replace(/\*/g, ".*?"), Me[0] === "-" ? ae.skips.push(new RegExp("^" + Me.slice(1) + "$")) : ae.names.push(new RegExp("^" + Me + "$")));
  }
  function ve() {
    const Me = [
      ...ae.names.map(xe),
      ...ae.skips.map(xe).map((Re) => "-" + Re)
    ].join(",");
    return ae.enable(""), Me;
  }
  function _e(Me) {
    if (Me[Me.length - 1] === "*")
      return !0;
    let Re, je;
    for (Re = 0, je = ae.skips.length; Re < je; Re++)
      if (ae.skips[Re].test(Me))
        return !1;
    for (Re = 0, je = ae.names.length; Re < je; Re++)
      if (ae.names[Re].test(Me))
        return !0;
    return !1;
  }
  function xe(Me) {
    return Me.toString().substring(2, Me.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function Oe(Me) {
    return Me instanceof Error ? Me.stack || Me.message : Me;
  }
  function $e() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ae.enable(ae.load()), ae;
}
var common = setup$1;
(function(ne, oe) {
  oe.formatArgs = fe, oe.save = ye, oe.load = ve, oe.useColors = ae, oe.storage = _e(), oe.destroy = (() => {
    let Oe = !1;
    return () => {
      Oe || (Oe = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), oe.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ae() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let Oe;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (Oe = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Oe[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fe(Oe) {
    if (Oe[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Oe[0] + (this.useColors ? "%c " : " ") + "+" + ne.exports.humanize(this.diff), !this.useColors)
      return;
    const $e = "color: " + this.color;
    Oe.splice(1, 0, $e, "color: inherit");
    let Me = 0, Re = 0;
    Oe[0].replace(/%[a-zA-Z%]/g, (je) => {
      je !== "%%" && (Me++, je === "%c" && (Re = Me));
    }), Oe.splice(Re, 0, $e);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ye(Oe) {
    try {
      Oe ? oe.storage.setItem("debug", Oe) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function ve() {
    let Oe;
    try {
      Oe = oe.storage.getItem("debug");
    } catch {
    }
    return !Oe && typeof process < "u" && "env" in process && (Oe = process.env.DEBUG), Oe;
  }
  function _e() {
    try {
      return localStorage;
    } catch {
    }
  }
  ne.exports = common(oe);
  const { formatters: xe } = ne.exports;
  xe.j = function(Oe) {
    try {
      return JSON.stringify(Oe);
    } catch ($e) {
      return "[UnexpectedJSONParseError]: " + $e.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const k$2 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var e = k$2("mud:common"), r$2 = k$2("mud:common");
e.log = console.debug.bind(console);
r$2.log = console.error.bind(console);
function isHex(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
function size(ne) {
  return isHex(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
const version$3 = "2.9.20", getVersion = () => `viem@${version$3}`;
class BaseError extends Error {
  constructor(oe, ae = {}) {
    var ve;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion()
    });
    const fe = ae.cause instanceof BaseError ? ae.cause.details : (ve = ae.cause) != null && ve.message ? ae.cause.message : ae.details, ye = ae.cause instanceof BaseError && ae.cause.docsPath || ae.docsPath;
    this.message = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [
        `Docs: https://viem.sh${ye}${ae.docsSlug ? `#${ae.docsSlug}` : ""}`
      ] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
  walk(oe) {
    return walk(this, oe);
  }
}
function walk(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? walk(ne.cause, oe) : oe ? null : ne;
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} size (${oe}) exceeds padding size (${ae}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
function pad(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? padHex(ne, { dir: oe, size: ae }) : padBytes(ne, { dir: oe, size: ae });
}
function padHex(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  const fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(fe.length / 2),
      targetSize: ae,
      type: "hex"
    });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function padBytes(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new SizeExceedsPaddingSizeError({
      size: ne.length,
      targetSize: ae,
      type: "bytes"
    });
  const fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    const ve = oe === "right";
    fe[ve ? ye : ae - ye - 1] = ne[ve ? ye : ne.length - ye - 1];
  }
  return fe;
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize: oe, maxSize: ae }) {
    super(`Size cannot exceed ${ae} bytes. Given size: ${oe} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
}
function assertSize(ne, { size: oe }) {
  if (size(ne) > oe)
    throw new SizeOverflowError({
      givenSize: size(ne),
      maxSize: oe
    });
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function bytesToHex(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += hexes[ne[ye]];
  const fe = `0x${ae}`;
  return typeof oe.size == "number" ? (assertSize(fe, { size: oe.size }), pad(fe, { dir: "right", size: oe.size })) : fe;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(ne, oe = {}) {
  const ae = encoder.encode(ne);
  return bytesToHex(ae, oe);
}
function concatHex(ne) {
  return `0x${ne.reduce((oe, ae) => oe + ae.replace("0x", ""), "")}`;
}
var eventemitter3 = { exports: {} };
(function(ne) {
  var oe = Object.prototype.hasOwnProperty, ae = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (ae = !1));
  function ye(Oe, $e, Me) {
    this.fn = Oe, this.context = $e, this.once = Me || !1;
  }
  function ve(Oe, $e, Me, Re, je) {
    if (typeof Me != "function")
      throw new TypeError("The listener must be a function");
    var Be = new ye(Me, Re || Oe, je), ze = ae ? ae + $e : $e;
    return Oe._events[ze] ? Oe._events[ze].fn ? Oe._events[ze] = [Oe._events[ze], Be] : Oe._events[ze].push(Be) : (Oe._events[ze] = Be, Oe._eventsCount++), Oe;
  }
  function _e(Oe, $e) {
    --Oe._eventsCount === 0 ? Oe._events = new fe() : delete Oe._events[$e];
  }
  function xe() {
    this._events = new fe(), this._eventsCount = 0;
  }
  xe.prototype.eventNames = function() {
    var $e = [], Me, Re;
    if (this._eventsCount === 0)
      return $e;
    for (Re in Me = this._events)
      oe.call(Me, Re) && $e.push(ae ? Re.slice(1) : Re);
    return Object.getOwnPropertySymbols ? $e.concat(Object.getOwnPropertySymbols(Me)) : $e;
  }, xe.prototype.listeners = function($e) {
    var Me = ae ? ae + $e : $e, Re = this._events[Me];
    if (!Re)
      return [];
    if (Re.fn)
      return [Re.fn];
    for (var je = 0, Be = Re.length, ze = new Array(Be); je < Be; je++)
      ze[je] = Re[je].fn;
    return ze;
  }, xe.prototype.listenerCount = function($e) {
    var Me = ae ? ae + $e : $e, Re = this._events[Me];
    return Re ? Re.fn ? 1 : Re.length : 0;
  }, xe.prototype.emit = function($e, Me, Re, je, Be, ze) {
    var He = ae ? ae + $e : $e;
    if (!this._events[He])
      return !1;
    var qe = this._events[He], Ye = arguments.length, pt, dt;
    if (qe.fn) {
      switch (qe.once && this.removeListener($e, qe.fn, void 0, !0), Ye) {
        case 1:
          return qe.fn.call(qe.context), !0;
        case 2:
          return qe.fn.call(qe.context, Me), !0;
        case 3:
          return qe.fn.call(qe.context, Me, Re), !0;
        case 4:
          return qe.fn.call(qe.context, Me, Re, je), !0;
        case 5:
          return qe.fn.call(qe.context, Me, Re, je, Be), !0;
        case 6:
          return qe.fn.call(qe.context, Me, Re, je, Be, ze), !0;
      }
      for (dt = 1, pt = new Array(Ye - 1); dt < Ye; dt++)
        pt[dt - 1] = arguments[dt];
      qe.fn.apply(qe.context, pt);
    } else {
      var yt = qe.length, Ct;
      for (dt = 0; dt < yt; dt++)
        switch (qe[dt].once && this.removeListener($e, qe[dt].fn, void 0, !0), Ye) {
          case 1:
            qe[dt].fn.call(qe[dt].context);
            break;
          case 2:
            qe[dt].fn.call(qe[dt].context, Me);
            break;
          case 3:
            qe[dt].fn.call(qe[dt].context, Me, Re);
            break;
          case 4:
            qe[dt].fn.call(qe[dt].context, Me, Re, je);
            break;
          default:
            if (!pt)
              for (Ct = 1, pt = new Array(Ye - 1); Ct < Ye; Ct++)
                pt[Ct - 1] = arguments[Ct];
            qe[dt].fn.apply(qe[dt].context, pt);
        }
    }
    return !0;
  }, xe.prototype.on = function($e, Me, Re) {
    return ve(this, $e, Me, Re, !1);
  }, xe.prototype.once = function($e, Me, Re) {
    return ve(this, $e, Me, Re, !0);
  }, xe.prototype.removeListener = function($e, Me, Re, je) {
    var Be = ae ? ae + $e : $e;
    if (!this._events[Be])
      return this;
    if (!Me)
      return _e(this, Be), this;
    var ze = this._events[Be];
    if (ze.fn)
      ze.fn === Me && (!je || ze.once) && (!Re || ze.context === Re) && _e(this, Be);
    else {
      for (var He = 0, qe = [], Ye = ze.length; He < Ye; He++)
        (ze[He].fn !== Me || je && !ze[He].once || Re && ze[He].context !== Re) && qe.push(ze[He]);
      qe.length ? this._events[Be] = qe.length === 1 ? qe[0] : qe : _e(this, Be);
    }
    return this;
  }, xe.prototype.removeAllListeners = function($e) {
    var Me;
    return $e ? (Me = ae ? ae + $e : $e, this._events[Me] && _e(this, Me)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, xe.prototype.off = xe.prototype.removeListener, xe.prototype.addListener = xe.prototype.on, xe.prefixed = ae, xe.EventEmitter = xe, ne.exports = xe;
})(eventemitter3);
globalThis && globalThis.__classPrivateFieldGet;
globalThis && globalThis.__classPrivateFieldSet;
globalThis && globalThis.__classPrivateFieldGet;
var retry = {};
function RetryOperation(ne, oe) {
  typeof oe == "boolean" && (oe = { forever: oe }), this._originalTimeouts = JSON.parse(JSON.stringify(ne)), this._timeouts = ne, this._options = oe || {}, this._maxRetryTime = oe && oe.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(ne) {
  if (this._timeout && clearTimeout(this._timeout), !ne)
    return !1;
  var oe = (/* @__PURE__ */ new Date()).getTime();
  if (ne && oe - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ne), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ne);
  var ae = this._timeouts.shift();
  if (ae === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), ae = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, ae), this._options.unref && this._timer.unref(), !0;
};
RetryOperation.prototype.attempt = function(ne, oe) {
  this._fn = ne, oe && (oe.timeout && (this._operationTimeout = oe.timeout), oe.cb && (this._operationTimeoutCb = oe.cb));
  var ae = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    ae._operationTimeoutCb();
  }, ae._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation.prototype.try = function(ne) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = function(ne) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ne = {}, oe = null, ae = 0, fe = 0; fe < this._errors.length; fe++) {
    var ye = this._errors[fe], ve = ye.message, _e = (ne[ve] || 0) + 1;
    ne[ve] = _e, _e >= ae && (oe = ye, ae = _e);
  }
  return oe;
};
(function(ne) {
  var oe = retry_operation;
  ne.operation = function(ae) {
    var fe = ne.timeouts(ae);
    return new oe(fe, {
      forever: ae && (ae.forever || ae.retries === 1 / 0),
      unref: ae && ae.unref,
      maxRetryTime: ae && ae.maxRetryTime
    });
  }, ne.timeouts = function(ae) {
    if (ae instanceof Array)
      return [].concat(ae);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ye in ae)
      fe[ye] = ae[ye];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var ve = [], _e = 0; _e < fe.retries; _e++)
      ve.push(this.createTimeout(_e, fe));
    return ae && ae.forever && !ve.length && ve.push(this.createTimeout(_e, fe)), ve.sort(function(xe, Oe) {
      return xe - Oe;
    }), ve;
  }, ne.createTimeout = function(ae, fe) {
    var ye = fe.randomize ? Math.random() + 1 : 1, ve = Math.round(ye * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, ae));
    return ve = Math.min(ve, fe.maxTimeout), ve;
  }, ne.wrap = function(ae, fe, ye) {
    if (fe instanceof Array && (ye = fe, fe = null), !ye) {
      ye = [];
      for (var ve in ae)
        typeof ae[ve] == "function" && ye.push(ve);
    }
    for (var _e = 0; _e < ye.length; _e++) {
      var xe = ye[_e], Oe = ae[xe];
      ae[xe] = (function(Me) {
        var Re = ne.operation(fe), je = Array.prototype.slice.call(arguments, 1), Be = je.pop();
        je.push(function(ze) {
          Re.retry(ze) || (ze && (arguments[0] = Re.mainError()), Be.apply(this, arguments));
        }), Re.attempt(function() {
          Me.apply(ae, je);
        });
      }).bind(ae, Oe), ae[xe].options = fe;
    }
  };
})(retry);
e.extend("createNonceManager");
e.extend("writeContract");
e.extend("sendTransaction");
var o$1 = { table: "tb", offchainTable: "ot", namespace: "ns", system: "sy" };
function x$1(ne) {
  let oe = o$1[ne.type];
  if (ne.namespace.length > 14)
    throw new Error(`Namespaces must fit into \`bytes14\`, but "${ne.namespace}" is too long.`);
  return concatHex([stringToHex(oe, { size: 2 }), stringToHex(ne.namespace, { size: 14 }), stringToHex(ne.name.slice(0, 16), { size: 16 })]);
}
Object.fromEntries(Object.entries(o$1).map(([ne, oe]) => [oe, ne]));
var T$1 = k$2("mud:benchmark");
T$1.log = console.info.bind(console);
e.extend("transportObserver");
function y$1(ne, oe) {
  let ae = /* @__PURE__ */ new Map();
  for (let fe of ne) {
    let ye = oe(fe);
    ae.has(ye) || ae.set(ye, []), ae.get(ye).push(fe);
  }
  return ae;
}
function P$1(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, oe(fe, ae)]));
}
function flatMorph(ne, oe) {
  var ve;
  const ae = Array.isArray(ne), fe = Object.entries(ne).flatMap((_e, xe) => {
    const Oe = ae ? oe(xe, _e[1]) : oe(..._e, xe);
    return Array.isArray(Oe[0]) || Oe.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      Oe
    ) : [Oe];
  }), ye = Object.fromEntries(fe);
  return typeof ((ve = fe[0]) == null ? void 0 : ve[0]) == "number" ? Object.values(ye) : ye;
}
var Hkt;
(function(ne) {
  class oe {
  }
  ne.Kind = oe;
  class ae {
  }
  ne.Instantiable = ae, ne.reify = (ye) => ye.hkt;
  class fe {
  }
  ne.UnaryKind = fe, ne.pipe = (...ye) => (ve) => ye.reduce((_e, xe) => xe.hkt(_e), ve);
})(Hkt || (Hkt = {}));
const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);
const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);
const integerLikeMatcher = /^-?\d+$/;
integerLikeMatcher.test.bind(integerLikeMatcher);
const prototypeKeysOf = (ne) => {
  const oe = [];
  let ae = ne;
  for (; ae !== Object.prototype && ae !== null && ae !== void 0; ) {
    for (const fe of Object.getOwnPropertyNames(ae))
      fe !== "constructor" && !oe.includes(fe) && oe.push(fe);
    for (const fe of Object.getOwnPropertySymbols(ae))
      oe.includes(fe) || oe.push(fe);
    ae = Object.getPrototypeOf(ae);
  }
  return oe;
};
prototypeKeysOf(0n), prototypeKeysOf(!1), prototypeKeysOf(0), prototypeKeysOf(""), prototypeKeysOf(Symbol());
function c$1(ne, oe) {
  return typeof ne == "object" && ne != null && o(ne, oe) ? ne[oe] : void 0;
}
function o(ne, oe) {
  return typeof ne == "object" && ne !== null && ne.hasOwnProperty(oe);
}
function r$1(ne) {
  return ne != null && typeof ne == "object";
}
function i$2(ne, oe) {
  let ae = [.../* @__PURE__ */ new Set([...Object.keys(ne), ...Object.keys(oe)])];
  return Object.fromEntries(ae.map((fe) => [fe, typeof ne[fe] > "u" ? oe[fe] : ne[fe]]));
}
var b$1 = { storeImportPath: "@latticexyz/store/src", userTypesFilename: "common.sol", outputDirectory: "codegen", indexFilename: "index.sol" }, m$1 = { outputDirectory: "tables", tableIdArgument: !1, storeArgument: !1 }, N$1 = { disabled: !1 }, x = { namespace: "", type: "table" }, T = { sourceDirectory: "src", namespace: "" }, a = { types: Object.fromEntries(n.map((ne) => [ne, ne])) };
function u(ne, oe) {
  return { types: { ...ne.types, ...oe } };
}
function h$1(ne, oe = a) {
  if (!r$1(ne))
    throw new Error(`Expected schema, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    if (!A$1(ae) && !o(oe.types, ae))
      throw new Error(`"${String(ae)}" is not a valid type in this scope.`);
}
function k$1(ne, oe = a) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, { type: A$1(fe) ? f$1(fe) : oe.types[fe], internalType: fe }]));
}
function v(ne, oe = a) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((ae) => A$1(ae) || o(oe.types, ae));
}
function Y$1(ne, oe = a) {
  return Object.entries(ne).filter(([, ae]) => o(oe.types, ae) && e$1(oe.types[ae])).map(([ae]) => ae);
}
function q(ne, oe, ae = a) {
  return Array.isArray(ne) && ne.every((fe) => o(oe, fe) && o(ae.types, oe[fe]) && e$1(ae.types[oe[fe]]));
}
function g$2(ne, oe = a, ae = { inStoreContext: !1 }) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full table config, got \`${JSON.stringify(ne)}\``);
  if (!o(ne, "schema"))
    throw new Error("Missing schema input");
  if (h$1(ne.schema, oe), !o(ne, "key") || !q(ne.key, ne.schema, oe))
    throw new Error(`Invalid key. Expected \`(${Y$1(ne.schema, oe).map((fe) => `"${String(fe)}"`).join(" | ")})[]\`, received \`${o(ne, "key") && Array.isArray(ne.key) ? `[${ne.key.map((fe) => `"${fe}"`).join(", ")}]` : String(c$1(ne, "key"))}\``);
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`Table \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`Table \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
  if (ae.inStoreContext && (o(ne, "label") || o(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for tables in this context.");
}
function H(ne) {
  let oe = ne.codegen;
  return { outputDirectory: c$1(oe, "outputDirectory") ?? m$1.outputDirectory, tableIdArgument: c$1(oe, "tableIdArgument") ?? m$1.tableIdArgument, storeArgument: c$1(oe, "storeArgument") ?? m$1.storeArgument, dataStruct: c$1(oe, "dataStruct") ?? Object.keys(ne.schema).length - ne.key.length > 1 };
}
function E(ne, oe = a) {
  let ae = ne.label, fe = ne.type ?? x.type, ye = ne.namespace ?? x.namespace, ve = ne.name ?? ae.slice(0, 16), _e = x$1({ type: fe, namespace: ye, name: ve });
  return { label: ae, type: fe, namespace: ye, name: ve, tableId: _e, schema: k$1(ne.schema, oe), key: ne.key, codegen: H(ne), deploy: i$2(ne.deploy ?? {}, N$1) };
}
function D$1(ne) {
  return typeof ne == "string" || r$1(ne) && Object.values(ne).every((oe) => typeof oe == "string");
}
function A(ne, oe = a) {
  if (typeof ne == "string") {
    if (A$1(ne) || o(oe.types, ne))
      return;
    throw new Error(`Invalid ABI type. \`${ne}\` not found in scope.`);
  }
  if (typeof ne == "object" && ne !== null) {
    if (v(ne, oe)) {
      if (o(ne, "id") && e$1(oe.types[ne.id]))
        return;
      throw new Error("Invalid schema. Expected an `id` field with a static ABI type or an explicit `key` option.");
    }
    throw new Error("Invalid schema. Are you using invalid types or missing types in your scope?");
  }
  throw new Error("Invalid table shorthand.");
}
function l$2(ne, oe) {
  return typeof ne == "string" ? { schema: { id: "bytes32", value: ne }, key: ["id"] } : v(ne, oe) ? { schema: ne, key: ["id"] } : ne;
}
function d(ne, oe) {
  if (r$1(ne)) {
    for (let ae of Object.values(ne))
      D$1(ae) ? A(ae, oe) : g$2(ae, oe, { inStoreContext: !0 });
    return;
  }
  throw new Error(`Expected tables config, received ${JSON.stringify(ne)}`);
}
function I$2(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, E(i$2(l$2(fe, oe), { label: ae }), oe)]));
}
function Z(ne) {
  return P$1(ne, (oe) => oe.type);
}
function ee(ne) {
  return r$1(ne) && Object.values(ne).every((oe) => o$2(oe.type));
}
function U(ne, oe = a) {
  return ee(ne) ? u(oe, Z(ne)) : oe;
}
function L(ne) {
  if (!r$1(ne))
    throw new Error(`Expected userTypes, received ${JSON.stringify(ne)}`);
  for (let { type: oe } of Object.values(ne))
    if (!o(a.types, oe))
      throw new Error(`"${String(oe)}" is not a valid ABI type.`);
}
function te$1(ne) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((oe) => Array.isArray(oe) && oe.every((ae) => typeof ae == "string"));
}
function _$1(ne, oe = a) {
  if (te$1(ne)) {
    let ae = Object.fromEntries(Object.keys(ne).map((fe) => [fe, "uint8"]));
    return u(oe, ae);
  }
  return oe;
}
function j(ne) {
  return flatMorph(ne, (oe, ae) => [oe, flatMorph(ae, (fe, ye) => [ye, fe])]);
}
function C$1(ne) {
  return r$1(ne) ? i$2(ne, b$1) : b$1;
}
function K(ne, oe) {
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o(ne, "tables") && d(ne.tables, oe);
}
function $(ne, oe = a) {
  let ae = ne.label, fe = ne.namespace ?? ae.slice(0, 14);
  return { label: ae, namespace: fe, tables: I$2(flatMorph(ne.tables ?? {}, (ye, ve) => [ye, i$2(l$2(ve, oe), { namespace: fe })]), oe) };
}
function w(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    K(ae, oe);
}
function f(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, ve) => [ye, $(i$2(ve, { label: ye }), oe)]), fe = Array.from(y$1(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function B(ne) {
  return Object.fromEntries(Object.entries(ne.namespaces).flatMap(([oe, ae]) => Object.entries(ae.tables).map(([fe, ye]) => [oe === "" ? fe : `${oe}__${fe}`, ye])));
}
function G(ne) {
  return _$1(c$1(ne, "enums"), U(c$1(ne, "userTypes")));
}
function pe(ne) {
  let oe = G(ne);
  if (o(ne, "namespaces")) {
    if (o(ne, "namespace") || o(ne, "tables"))
      throw new Error("Cannot use `namespaces` with `namespace` or `tables` keys.");
    w(ne.namespaces, oe);
  }
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o(ne, "tables") && d(ne.tables, oe), o(ne, "userTypes") && L(ne.userTypes);
}
function re(ne) {
  let oe = G(ne), ae = ne.namespace ?? T.namespace, fe = ne.namespaces ? { multipleNamespaces: !0, namespace: null, namespaces: f(ne.namespaces, oe) } : { multipleNamespaces: !1, namespace: ae, namespaces: f({ [ae]: ne }, oe) }, ye = B(fe);
  return { ...fe, tables: ye, sourceDirectory: ne.sourceDirectory ?? T.sourceDirectory, userTypes: ne.userTypes ?? {}, enums: ne.enums ?? {}, enumValues: j(ne.enums ?? {}), codegen: C$1(ne.codegen) };
}
var m = { namespace: "", openAccess: !0, accessList: [] }, C = { root: !1, args: [], artifactPath: void 0 }, I$1 = { worldInterfaceName: "IWorld", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src" }, b = { customWorldContract: void 0, postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", upgradeableWorldImplementation: !1 }, P = { systems: {}, tables: {}, excludeSystems: [], modules: [], codegen: I$1, deploy: b };
function i$1(ne, oe = {}) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full system config, got \`${JSON.stringify(ne)}\``);
  if (oe.inNamespace && (o(ne, "label") || o(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for systems in this context.");
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`System \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`System \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
}
function c(ne) {
  let oe = ne.label, ae = ne.namespace ?? m.namespace, fe = ne.name ?? oe.slice(0, 16), ye = x$1({ type: "system", namespace: ae, name: fe });
  return i$2({ ...ne, label: oe, namespace: ae, name: fe, systemId: ye }, m);
}
function y(ne) {
  if (r$1(ne)) {
    for (let oe of Object.values(ne))
      i$1(oe, { inNamespace: !0 });
    return;
  }
  throw new Error(`Expected system config, received ${JSON.stringify(ne)}`);
}
function l$1(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, c({ ...fe, label: ae, namespace: oe })]));
}
function Q(ne, oe) {
  o(ne, "systems") && y(ne.systems), K(ne, oe);
}
function X(ne, oe = a) {
  let ae = $(ne, oe), fe = l$1(ne.systems ?? {}, ae.namespace);
  return { ...ae, systems: fe };
}
function l(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    Q(ae, oe);
}
function r(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, ve) => [ye, X(i$2(ve, { label: ye }), oe)]), fe = Array.from(y$1(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function N(ne) {
  return r$1(ne) ? i$2(ne, I$1) : I$1;
}
function g$1(ne) {
  return r$1(ne) ? i$2(ne, b) : b;
}
function W(ne) {
  let oe = G(ne);
  if (o(ne, "namespaces")) {
    if (o(ne, "namespace") || o(ne, "tables") || o(ne, "systems"))
      throw new Error("Cannot use `namespaces` with `namespace`, `tables`, or `systems` keys.");
    l(ne.namespaces, oe);
  }
  o(ne, "systems") && y(ne.systems), pe(ne);
}
function _(ne) {
  let oe = G(ne), ae = re(ne), fe = ne.namespaces ? r(ne.namespaces, oe) : r({ [ae.namespace]: ne }, oe), ye = B({ namespaces: fe }), ve = (ne.modules ?? P.modules).map((_e) => i$2(_e, C));
  return i$2({ ...ae, namespaces: fe, tables: ye, systems: !ae.multipleNamespaces && ne.systems ? l$1(ne.systems, ae.namespace) : P.systems, excludeSystems: c$1(ne, "excludeSystems"), codegen: i$2(ae.codegen, N(ne.codegen)), deploy: g$1(ne.deploy), modules: ve }, P);
}
function te(ne) {
  return W(ne), _(ne);
}
const mudConfig = te({
  worldContractName: "RoR",
  enums: {
    TokenType: ["TokenA", "TokenB", "TokenC"]
  },
  systems: {
    SpawnSystem: {
      name: "spwan",
      openAccess: !0
    },
    TokenManagerSystem: {
      name: "tokenManager",
      openAccess: !1
    }
  },
  tables: {
    Player: "bool",
    PlayerDetail: {
      schema: {
        id: "bytes32",
        wallet: "address",
        gold: "uint256",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lands: "uint16",
        isSpawnCapital: "bool"
      },
      key: ["id"]
    },
    Army: {
      key: ["key"],
      schema: {
        key: "bytes32",
        owner: "bytes32",
        id: "uint8",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        destination: "uint16"
      }
    },
    Capital: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        lastTime: "uint32"
      }
    },
    Land: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        attackAble: "bool"
      }
    },
    BattleReport: {
      key: ["key"],
      schema: {
        key: "bytes32",
        landId: "uint16",
        timestamp: "uint32",
        attacker: "address",
        defender: "address",
        attackWin: "bool",
        losses: "uint256[8]"
      }
    },
    GlobalStatistics: {
      schema: {
        consumptionTokenB: "uint256",
        consumptionTokenC: "uint256"
      },
      key: []
    },
    GlobalStake: {
      schema: {
        tokenB: "uint256",
        tokenC: "uint256",
        lastStakeTime: "uint256",
        isPositive: "bool",
        mintB: "uint256",
        burnB: "uint256",
        netValue: "uint256",
        burnRate: "uint256",
        perSecondReward: "uint256"
      },
      key: []
    },
    GlobalConfig: {
      schema: {
        unStakeFee: "uint256",
        passiveUnStakeFee: "uint256",
        owner: "address",
        merkleRoot: "bytes32"
      },
      key: []
    },
    PlayerStake: {
      schema: {
        wallet: "address",
        tokenB: "uint256",
        tokenC: "uint256",
        lastRewardTimeB: "uint256",
        lastRewardTimeC: "uint256"
      },
      key: ["wallet"]
    },
    PlayerAirdrop: {
      schema: {
        wallet: "address",
        isClaimed: "bool"
      },
      key: ["wallet"]
    }
    // PlayerStatistics:{
    //   schema: {
    //     id: "bytes32",
    //
    //   },
    //   key: ['id']
    // }
  },
  deploysDirectory: "./mud-deploys"
});
function p(ne = {}) {
  return (oe) => ({ writeContract: (ae) => Je(oe, ae, ne), sendTransaction: (ae) => Ve(oe, ae, ne) });
}
function h({ onWrite: ne }) {
  let oe = 0;
  return (ae) => ({ writeContract: (fe) => {
    let ye = getAction(ae, writeContract, "writeContract")(fe), ve = `${ae.chain.id}:${ae.account.address}:${oe++}`;
    return ne({ id: ve, request: fe, result: ye }), ye;
  } });
}
const createStoreImpl = (ne) => {
  let oe;
  const ae = /* @__PURE__ */ new Set(), fe = (Me, Re) => {
    const je = typeof Me == "function" ? Me(oe) : Me;
    if (!Object.is(je, oe)) {
      const Be = oe;
      oe = Re ?? (typeof je != "object" || je === null) ? je : Object.assign({}, oe, je), ae.forEach((ze) => ze(oe, Be));
    }
  }, ye = () => oe, Oe = { setState: fe, getState: ye, getInitialState: () => $e, subscribe: (Me) => (ae.add(Me), () => ae.delete(Me)), destroy: () => {
    ae.clear();
  } }, $e = oe = ne(fe, ye, Oe);
  return Oe;
}, createStore = (ne) => ne ? createStoreImpl(ne) : createStoreImpl;
var react = { exports: {} }, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min)
    return react_production_min;
  hasRequiredReact_production_min = 1;
  var ne = Symbol.for("react.element"), oe = Symbol.for("react.portal"), ae = Symbol.for("react.fragment"), fe = Symbol.for("react.strict_mode"), ye = Symbol.for("react.profiler"), ve = Symbol.for("react.provider"), _e = Symbol.for("react.context"), xe = Symbol.for("react.forward_ref"), Oe = Symbol.for("react.suspense"), $e = Symbol.for("react.memo"), Me = Symbol.for("react.lazy"), Re = Symbol.iterator;
  function je(ot) {
    return ot === null || typeof ot != "object" ? null : (ot = Re && ot[Re] || ot["@@iterator"], typeof ot == "function" ? ot : null);
  }
  var Be = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, ze = Object.assign, He = {};
  function qe(ot, et, Rt) {
    this.props = ot, this.context = et, this.refs = He, this.updater = Rt || Be;
  }
  qe.prototype.isReactComponent = {}, qe.prototype.setState = function(ot, et) {
    if (typeof ot != "object" && typeof ot != "function" && ot != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ot, et, "setState");
  }, qe.prototype.forceUpdate = function(ot) {
    this.updater.enqueueForceUpdate(this, ot, "forceUpdate");
  };
  function Ye() {
  }
  Ye.prototype = qe.prototype;
  function pt(ot, et, Rt) {
    this.props = ot, this.context = et, this.refs = He, this.updater = Rt || Be;
  }
  var dt = pt.prototype = new Ye();
  dt.constructor = pt, ze(dt, qe.prototype), dt.isPureReactComponent = !0;
  var yt = Array.isArray, Ct = Object.prototype.hasOwnProperty, It = { current: null }, Vt = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Ut(ot, et, Rt) {
    var xr, Xt = {}, dr = null, Nr = null;
    if (et != null)
      for (xr in et.ref !== void 0 && (Nr = et.ref), et.key !== void 0 && (dr = "" + et.key), et)
        Ct.call(et, xr) && !Vt.hasOwnProperty(xr) && (Xt[xr] = et[xr]);
    var Dr = arguments.length - 2;
    if (Dr === 1)
      Xt.children = Rt;
    else if (1 < Dr) {
      for (var jr = Array(Dr), un = 0; un < Dr; un++)
        jr[un] = arguments[un + 2];
      Xt.children = jr;
    }
    if (ot && ot.defaultProps)
      for (xr in Dr = ot.defaultProps, Dr)
        Xt[xr] === void 0 && (Xt[xr] = Dr[xr]);
    return { $$typeof: ne, type: ot, key: dr, ref: Nr, props: Xt, _owner: It.current };
  }
  function Zt(ot, et) {
    return { $$typeof: ne, type: ot.type, key: et, ref: ot.ref, props: ot.props, _owner: ot._owner };
  }
  function tr(ot) {
    return typeof ot == "object" && ot !== null && ot.$$typeof === ne;
  }
  function er(ot) {
    var et = { "=": "=0", ":": "=2" };
    return "$" + ot.replace(/[=:]/g, function(Rt) {
      return et[Rt];
    });
  }
  var hr = /\/+/g;
  function Ot(ot, et) {
    return typeof ot == "object" && ot !== null && ot.key != null ? er("" + ot.key) : et.toString(36);
  }
  function Qe(ot, et, Rt, xr, Xt) {
    var dr = typeof ot;
    (dr === "undefined" || dr === "boolean") && (ot = null);
    var Nr = !1;
    if (ot === null)
      Nr = !0;
    else
      switch (dr) {
        case "string":
        case "number":
          Nr = !0;
          break;
        case "object":
          switch (ot.$$typeof) {
            case ne:
            case oe:
              Nr = !0;
          }
      }
    if (Nr)
      return Nr = ot, Xt = Xt(Nr), ot = xr === "" ? "." + Ot(Nr, 0) : xr, yt(Xt) ? (Rt = "", ot != null && (Rt = ot.replace(hr, "$&/") + "/"), Qe(Xt, et, Rt, "", function(un) {
        return un;
      })) : Xt != null && (tr(Xt) && (Xt = Zt(Xt, Rt + (!Xt.key || Nr && Nr.key === Xt.key ? "" : ("" + Xt.key).replace(hr, "$&/") + "/") + ot)), et.push(Xt)), 1;
    if (Nr = 0, xr = xr === "" ? "." : xr + ":", yt(ot))
      for (var Dr = 0; Dr < ot.length; Dr++) {
        dr = ot[Dr];
        var jr = xr + Ot(dr, Dr);
        Nr += Qe(dr, et, Rt, jr, Xt);
      }
    else if (jr = je(ot), typeof jr == "function")
      for (ot = jr.call(ot), Dr = 0; !(dr = ot.next()).done; )
        dr = dr.value, jr = xr + Ot(dr, Dr++), Nr += Qe(dr, et, Rt, jr, Xt);
    else if (dr === "object")
      throw et = String(ot), Error("Objects are not valid as a React child (found: " + (et === "[object Object]" ? "object with keys {" + Object.keys(ot).join(", ") + "}" : et) + "). If you meant to render a collection of children, use an array instead.");
    return Nr;
  }
  function at(ot, et, Rt) {
    if (ot == null)
      return ot;
    var xr = [], Xt = 0;
    return Qe(ot, xr, "", "", function(dr) {
      return et.call(Rt, dr, Xt++);
    }), xr;
  }
  function wt(ot) {
    if (ot._status === -1) {
      var et = ot._result;
      et = et(), et.then(function(Rt) {
        (ot._status === 0 || ot._status === -1) && (ot._status = 1, ot._result = Rt);
      }, function(Rt) {
        (ot._status === 0 || ot._status === -1) && (ot._status = 2, ot._result = Rt);
      }), ot._status === -1 && (ot._status = 0, ot._result = et);
    }
    if (ot._status === 1)
      return ot._result.default;
    throw ot._result;
  }
  var bt = { current: null }, At = { transition: null }, Ft = { ReactCurrentDispatcher: bt, ReactCurrentBatchConfig: At, ReactCurrentOwner: It };
  function Gt() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return react_production_min.Children = { map: at, forEach: function(ot, et, Rt) {
    at(ot, function() {
      et.apply(this, arguments);
    }, Rt);
  }, count: function(ot) {
    var et = 0;
    return at(ot, function() {
      et++;
    }), et;
  }, toArray: function(ot) {
    return at(ot, function(et) {
      return et;
    }) || [];
  }, only: function(ot) {
    if (!tr(ot))
      throw Error("React.Children.only expected to receive a single React element child.");
    return ot;
  } }, react_production_min.Component = qe, react_production_min.Fragment = ae, react_production_min.Profiler = ye, react_production_min.PureComponent = pt, react_production_min.StrictMode = fe, react_production_min.Suspense = Oe, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ft, react_production_min.act = Gt, react_production_min.cloneElement = function(ot, et, Rt) {
    if (ot == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ot + ".");
    var xr = ze({}, ot.props), Xt = ot.key, dr = ot.ref, Nr = ot._owner;
    if (et != null) {
      if (et.ref !== void 0 && (dr = et.ref, Nr = It.current), et.key !== void 0 && (Xt = "" + et.key), ot.type && ot.type.defaultProps)
        var Dr = ot.type.defaultProps;
      for (jr in et)
        Ct.call(et, jr) && !Vt.hasOwnProperty(jr) && (xr[jr] = et[jr] === void 0 && Dr !== void 0 ? Dr[jr] : et[jr]);
    }
    var jr = arguments.length - 2;
    if (jr === 1)
      xr.children = Rt;
    else if (1 < jr) {
      Dr = Array(jr);
      for (var un = 0; un < jr; un++)
        Dr[un] = arguments[un + 2];
      xr.children = Dr;
    }
    return { $$typeof: ne, type: ot.type, key: Xt, ref: dr, props: xr, _owner: Nr };
  }, react_production_min.createContext = function(ot) {
    return ot = { $$typeof: _e, _currentValue: ot, _currentValue2: ot, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ot.Provider = { $$typeof: ve, _context: ot }, ot.Consumer = ot;
  }, react_production_min.createElement = Ut, react_production_min.createFactory = function(ot) {
    var et = Ut.bind(null, ot);
    return et.type = ot, et;
  }, react_production_min.createRef = function() {
    return { current: null };
  }, react_production_min.forwardRef = function(ot) {
    return { $$typeof: xe, render: ot };
  }, react_production_min.isValidElement = tr, react_production_min.lazy = function(ot) {
    return { $$typeof: Me, _payload: { _status: -1, _result: ot }, _init: wt };
  }, react_production_min.memo = function(ot, et) {
    return { $$typeof: $e, type: ot, compare: et === void 0 ? null : et };
  }, react_production_min.startTransition = function(ot) {
    var et = At.transition;
    At.transition = {};
    try {
      ot();
    } finally {
      At.transition = et;
    }
  }, react_production_min.unstable_act = Gt, react_production_min.useCallback = function(ot, et) {
    return bt.current.useCallback(ot, et);
  }, react_production_min.useContext = function(ot) {
    return bt.current.useContext(ot);
  }, react_production_min.useDebugValue = function() {
  }, react_production_min.useDeferredValue = function(ot) {
    return bt.current.useDeferredValue(ot);
  }, react_production_min.useEffect = function(ot, et) {
    return bt.current.useEffect(ot, et);
  }, react_production_min.useId = function() {
    return bt.current.useId();
  }, react_production_min.useImperativeHandle = function(ot, et, Rt) {
    return bt.current.useImperativeHandle(ot, et, Rt);
  }, react_production_min.useInsertionEffect = function(ot, et) {
    return bt.current.useInsertionEffect(ot, et);
  }, react_production_min.useLayoutEffect = function(ot, et) {
    return bt.current.useLayoutEffect(ot, et);
  }, react_production_min.useMemo = function(ot, et) {
    return bt.current.useMemo(ot, et);
  }, react_production_min.useReducer = function(ot, et, Rt) {
    return bt.current.useReducer(ot, et, Rt);
  }, react_production_min.useRef = function(ot) {
    return bt.current.useRef(ot);
  }, react_production_min.useState = function(ot) {
    return bt.current.useState(ot);
  }, react_production_min.useSyncExternalStore = function(ot, et, Rt) {
    return bt.current.useSyncExternalStore(ot, et, Rt);
  }, react_production_min.useTransition = function() {
    return bt.current.useTransition();
  }, react_production_min.version = "18.3.1", react_production_min;
}
var react_development = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  return hasRequiredReact_development || (hasRequiredReact_development = 1, function(ne, oe) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ae = "18.3.1", fe = Symbol.for("react.element"), ye = Symbol.for("react.portal"), ve = Symbol.for("react.fragment"), _e = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), Oe = Symbol.for("react.provider"), $e = Symbol.for("react.context"), Me = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), je = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), qe = Symbol.iterator, Ye = "@@iterator";
      function pt(Ge) {
        if (Ge === null || typeof Ge != "object")
          return null;
        var gt = qe && Ge[qe] || Ge[Ye];
        return typeof gt == "function" ? gt : null;
      }
      var dt = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, yt = {
        transition: null
      }, Ct = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, It = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, Vt = {}, Ut = null;
      function Zt(Ge) {
        Ut = Ge;
      }
      Vt.setExtraStackFrame = function(Ge) {
        Ut = Ge;
      }, Vt.getCurrentStack = null, Vt.getStackAddendum = function() {
        var Ge = "";
        Ut && (Ge += Ut);
        var gt = Vt.getCurrentStack;
        return gt && (Ge += gt() || ""), Ge;
      };
      var tr = !1, er = !1, hr = !1, Ot = !1, Qe = !1, at = {
        ReactCurrentDispatcher: dt,
        ReactCurrentBatchConfig: yt,
        ReactCurrentOwner: It
      };
      at.ReactDebugCurrentFrame = Vt, at.ReactCurrentActQueue = Ct;
      function wt(Ge) {
        {
          for (var gt = arguments.length, jt = new Array(gt > 1 ? gt - 1 : 0), Ht = 1; Ht < gt; Ht++)
            jt[Ht - 1] = arguments[Ht];
          At("warn", Ge, jt);
        }
      }
      function bt(Ge) {
        {
          for (var gt = arguments.length, jt = new Array(gt > 1 ? gt - 1 : 0), Ht = 1; Ht < gt; Ht++)
            jt[Ht - 1] = arguments[Ht];
          At("error", Ge, jt);
        }
      }
      function At(Ge, gt, jt) {
        {
          var Ht = at.ReactDebugCurrentFrame, sr = Ht.getStackAddendum();
          sr !== "" && (gt += "%s", jt = jt.concat([sr]));
          var Fr = jt.map(function(Or) {
            return String(Or);
          });
          Fr.unshift("Warning: " + gt), Function.prototype.apply.call(console[Ge], console, Fr);
        }
      }
      var Ft = {};
      function Gt(Ge, gt) {
        {
          var jt = Ge.constructor, Ht = jt && (jt.displayName || jt.name) || "ReactClass", sr = Ht + "." + gt;
          if (Ft[sr])
            return;
          bt("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", gt, Ht), Ft[sr] = !0;
        }
      }
      var ot = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(Ge) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(Ge, gt, jt) {
          Gt(Ge, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(Ge, gt, jt, Ht) {
          Gt(Ge, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(Ge, gt, jt, Ht) {
          Gt(Ge, "setState");
        }
      }, et = Object.assign, Rt = {};
      Object.freeze(Rt);
      function xr(Ge, gt, jt) {
        this.props = Ge, this.context = gt, this.refs = Rt, this.updater = jt || ot;
      }
      xr.prototype.isReactComponent = {}, xr.prototype.setState = function(Ge, gt) {
        if (typeof Ge != "object" && typeof Ge != "function" && Ge != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, Ge, gt, "setState");
      }, xr.prototype.forceUpdate = function(Ge) {
        this.updater.enqueueForceUpdate(this, Ge, "forceUpdate");
      };
      {
        var Xt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, dr = function(Ge, gt) {
          Object.defineProperty(xr.prototype, Ge, {
            get: function() {
              wt("%s(...) is deprecated in plain JavaScript React classes. %s", gt[0], gt[1]);
            }
          });
        };
        for (var Nr in Xt)
          Xt.hasOwnProperty(Nr) && dr(Nr, Xt[Nr]);
      }
      function Dr() {
      }
      Dr.prototype = xr.prototype;
      function jr(Ge, gt, jt) {
        this.props = Ge, this.context = gt, this.refs = Rt, this.updater = jt || ot;
      }
      var un = jr.prototype = new Dr();
      un.constructor = jr, et(un, xr.prototype), un.isPureReactComponent = !0;
      function so() {
        var Ge = {
          current: null
        };
        return Object.seal(Ge), Ge;
      }
      var Pn = Array.isArray;
      function co(Ge) {
        return Pn(Ge);
      }
      function kn(Ge) {
        {
          var gt = typeof Symbol == "function" && Symbol.toStringTag, jt = gt && Ge[Symbol.toStringTag] || Ge.constructor.name || "Object";
          return jt;
        }
      }
      function Yn(Ge) {
        try {
          return Ho(Ge), !1;
        } catch {
          return !0;
        }
      }
      function Ho(Ge) {
        return "" + Ge;
      }
      function Rn(Ge) {
        if (Yn(Ge))
          return bt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", kn(Ge)), Ho(Ge);
      }
      function fo(Ge, gt, jt) {
        var Ht = Ge.displayName;
        if (Ht)
          return Ht;
        var sr = gt.displayName || gt.name || "";
        return sr !== "" ? jt + "(" + sr + ")" : jt;
      }
      function pa(Ge) {
        return Ge.displayName || "Context";
      }
      function jn(Ge) {
        if (Ge == null)
          return null;
        if (typeof Ge.tag == "number" && bt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ge == "function")
          return Ge.displayName || Ge.name || null;
        if (typeof Ge == "string")
          return Ge;
        switch (Ge) {
          case ve:
            return "Fragment";
          case ye:
            return "Portal";
          case xe:
            return "Profiler";
          case _e:
            return "StrictMode";
          case Re:
            return "Suspense";
          case je:
            return "SuspenseList";
        }
        if (typeof Ge == "object")
          switch (Ge.$$typeof) {
            case $e:
              var gt = Ge;
              return pa(gt) + ".Consumer";
            case Oe:
              var jt = Ge;
              return pa(jt._context) + ".Provider";
            case Me:
              return fo(Ge, Ge.render, "ForwardRef");
            case Be:
              var Ht = Ge.displayName || null;
              return Ht !== null ? Ht : jn(Ge.type) || "Memo";
            case ze: {
              var sr = Ge, Fr = sr._payload, Or = sr._init;
              try {
                return jn(Or(Fr));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Xn = Object.prototype.hasOwnProperty, Ko = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, vo, Eo, ra;
      ra = {};
      function uo(Ge) {
        if (Xn.call(Ge, "ref")) {
          var gt = Object.getOwnPropertyDescriptor(Ge, "ref").get;
          if (gt && gt.isReactWarning)
            return !1;
        }
        return Ge.ref !== void 0;
      }
      function So(Ge) {
        if (Xn.call(Ge, "key")) {
          var gt = Object.getOwnPropertyDescriptor(Ge, "key").get;
          if (gt && gt.isReactWarning)
            return !1;
        }
        return Ge.key !== void 0;
      }
      function Jo(Ge, gt) {
        var jt = function() {
          vo || (vo = !0, bt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gt));
        };
        jt.isReactWarning = !0, Object.defineProperty(Ge, "key", {
          get: jt,
          configurable: !0
        });
      }
      function Po(Ge, gt) {
        var jt = function() {
          Eo || (Eo = !0, bt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gt));
        };
        jt.isReactWarning = !0, Object.defineProperty(Ge, "ref", {
          get: jt,
          configurable: !0
        });
      }
      function Jt(Ge) {
        if (typeof Ge.ref == "string" && It.current && Ge.__self && It.current.stateNode !== Ge.__self) {
          var gt = jn(It.current.type);
          ra[gt] || (bt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', gt, Ge.ref), ra[gt] = !0);
        }
      }
      var or = function(Ge, gt, jt, Ht, sr, Fr, Or) {
        var Br = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: fe,
          // Built-in properties that belong on the element
          type: Ge,
          key: gt,
          ref: jt,
          props: Or,
          // Record the component responsible for creating this element.
          _owner: Fr
        };
        return Br._store = {}, Object.defineProperty(Br._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Br, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ht
        }), Object.defineProperty(Br, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: sr
        }), Object.freeze && (Object.freeze(Br.props), Object.freeze(Br)), Br;
      };
      function fr(Ge, gt, jt) {
        var Ht, sr = {}, Fr = null, Or = null, Br = null, Kr = null;
        if (gt != null) {
          uo(gt) && (Or = gt.ref, Jt(gt)), So(gt) && (Rn(gt.key), Fr = "" + gt.key), Br = gt.__self === void 0 ? null : gt.__self, Kr = gt.__source === void 0 ? null : gt.__source;
          for (Ht in gt)
            Xn.call(gt, Ht) && !Ko.hasOwnProperty(Ht) && (sr[Ht] = gt[Ht]);
        }
        var Sn = arguments.length - 2;
        if (Sn === 1)
          sr.children = jt;
        else if (Sn > 1) {
          for (var In = Array(Sn), Un = 0; Un < Sn; Un++)
            In[Un] = arguments[Un + 2];
          Object.freeze && Object.freeze(In), sr.children = In;
        }
        if (Ge && Ge.defaultProps) {
          var Vn = Ge.defaultProps;
          for (Ht in Vn)
            sr[Ht] === void 0 && (sr[Ht] = Vn[Ht]);
        }
        if (Fr || Or) {
          var mo = typeof Ge == "function" ? Ge.displayName || Ge.name || "Unknown" : Ge;
          Fr && Jo(sr, mo), Or && Po(sr, mo);
        }
        return or(Ge, Fr, Or, Br, Kr, It.current, sr);
      }
      function Mr(Ge, gt) {
        var jt = or(Ge.type, gt, Ge.ref, Ge._self, Ge._source, Ge._owner, Ge.props);
        return jt;
      }
      function Wr(Ge, gt, jt) {
        if (Ge == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + Ge + ".");
        var Ht, sr = et({}, Ge.props), Fr = Ge.key, Or = Ge.ref, Br = Ge._self, Kr = Ge._source, Sn = Ge._owner;
        if (gt != null) {
          uo(gt) && (Or = gt.ref, Sn = It.current), So(gt) && (Rn(gt.key), Fr = "" + gt.key);
          var In;
          Ge.type && Ge.type.defaultProps && (In = Ge.type.defaultProps);
          for (Ht in gt)
            Xn.call(gt, Ht) && !Ko.hasOwnProperty(Ht) && (gt[Ht] === void 0 && In !== void 0 ? sr[Ht] = In[Ht] : sr[Ht] = gt[Ht]);
        }
        var Un = arguments.length - 2;
        if (Un === 1)
          sr.children = jt;
        else if (Un > 1) {
          for (var Vn = Array(Un), mo = 0; mo < Un; mo++)
            Vn[mo] = arguments[mo + 2];
          sr.children = Vn;
        }
        return or(Ge.type, Fr, Or, Br, Kr, Sn, sr);
      }
      function Vr(Ge) {
        return typeof Ge == "object" && Ge !== null && Ge.$$typeof === fe;
      }
      var Zr = ".", on = ":";
      function Lr(Ge) {
        var gt = /[=:]/g, jt = {
          "=": "=0",
          ":": "=2"
        }, Ht = Ge.replace(gt, function(sr) {
          return jt[sr];
        });
        return "$" + Ht;
      }
      var tn = !1, Qn = /\/+/g;
      function Fn(Ge) {
        return Ge.replace(Qn, "$&/");
      }
      function en(Ge, gt) {
        return typeof Ge == "object" && Ge !== null && Ge.key != null ? (Rn(Ge.key), Lr("" + Ge.key)) : gt.toString(36);
      }
      function An(Ge, gt, jt, Ht, sr) {
        var Fr = typeof Ge;
        (Fr === "undefined" || Fr === "boolean") && (Ge = null);
        var Or = !1;
        if (Ge === null)
          Or = !0;
        else
          switch (Fr) {
            case "string":
            case "number":
              Or = !0;
              break;
            case "object":
              switch (Ge.$$typeof) {
                case fe:
                case ye:
                  Or = !0;
              }
          }
        if (Or) {
          var Br = Ge, Kr = sr(Br), Sn = Ht === "" ? Zr + en(Br, 0) : Ht;
          if (co(Kr)) {
            var In = "";
            Sn != null && (In = Fn(Sn) + "/"), An(Kr, gt, In, "", function(lf) {
              return lf;
            });
          } else
            Kr != null && (Vr(Kr) && (Kr.key && (!Br || Br.key !== Kr.key) && Rn(Kr.key), Kr = Mr(
              Kr,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              jt + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Kr.key && (!Br || Br.key !== Kr.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Fn("" + Kr.key) + "/"
              ) : "") + Sn
            )), gt.push(Kr));
          return 1;
        }
        var Un, Vn, mo = 0, ko = Ht === "" ? Zr : Ht + on;
        if (co(Ge))
          for (var oa = 0; oa < Ge.length; oa++)
            Un = Ge[oa], Vn = ko + en(Un, oa), mo += An(Un, gt, jt, Vn, sr);
        else {
          var fu = pt(Ge);
          if (typeof fu == "function") {
            var mc = Ge;
            fu === mc.entries && (tn || wt("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), tn = !0);
            for (var uf = fu.call(mc), ad, pu = 0; !(ad = uf.next()).done; )
              Un = ad.value, Vn = ko + en(Un, pu++), mo += An(Un, gt, jt, Vn, sr);
          } else if (Fr === "object") {
            var Ol = String(Ge);
            throw new Error("Objects are not valid as a React child (found: " + (Ol === "[object Object]" ? "object with keys {" + Object.keys(Ge).join(", ") + "}" : Ol) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return mo;
      }
      function zn(Ge, gt, jt) {
        if (Ge == null)
          return Ge;
        var Ht = [], sr = 0;
        return An(Ge, Ht, "", "", function(Fr) {
          return gt.call(jt, Fr, sr++);
        }), Ht;
      }
      function Oo(Ge) {
        var gt = 0;
        return zn(Ge, function() {
          gt++;
        }), gt;
      }
      function ii(Ge, gt, jt) {
        zn(Ge, function() {
          gt.apply(this, arguments);
        }, jt);
      }
      function No(Ge) {
        return zn(Ge, function(gt) {
          return gt;
        }) || [];
      }
      function Ao(Ge) {
        if (!Vr(Ge))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return Ge;
      }
      function Da(Ge) {
        var gt = {
          $$typeof: $e,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: Ge,
          _currentValue2: Ge,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        gt.Provider = {
          $$typeof: Oe,
          _context: gt
        };
        var jt = !1, Ht = !1, sr = !1;
        {
          var Fr = {
            $$typeof: $e,
            _context: gt
          };
          Object.defineProperties(Fr, {
            Provider: {
              get: function() {
                return Ht || (Ht = !0, bt("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), gt.Provider;
              },
              set: function(Or) {
                gt.Provider = Or;
              }
            },
            _currentValue: {
              get: function() {
                return gt._currentValue;
              },
              set: function(Or) {
                gt._currentValue = Or;
              }
            },
            _currentValue2: {
              get: function() {
                return gt._currentValue2;
              },
              set: function(Or) {
                gt._currentValue2 = Or;
              }
            },
            _threadCount: {
              get: function() {
                return gt._threadCount;
              },
              set: function(Or) {
                gt._threadCount = Or;
              }
            },
            Consumer: {
              get: function() {
                return jt || (jt = !0, bt("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), gt.Consumer;
              }
            },
            displayName: {
              get: function() {
                return gt.displayName;
              },
              set: function(Or) {
                sr || (wt("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Or), sr = !0);
              }
            }
          }), gt.Consumer = Fr;
        }
        return gt._currentRenderer = null, gt._currentRenderer2 = null, gt;
      }
      var po = -1, _o = 0, Ba = 1, bo = 2;
      function $n(Ge) {
        if (Ge._status === po) {
          var gt = Ge._result, jt = gt();
          if (jt.then(function(Fr) {
            if (Ge._status === _o || Ge._status === po) {
              var Or = Ge;
              Or._status = Ba, Or._result = Fr;
            }
          }, function(Fr) {
            if (Ge._status === _o || Ge._status === po) {
              var Or = Ge;
              Or._status = bo, Or._result = Fr;
            }
          }), Ge._status === po) {
            var Ht = Ge;
            Ht._status = _o, Ht._result = jt;
          }
        }
        if (Ge._status === Ba) {
          var sr = Ge._result;
          return sr === void 0 && bt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, sr), "default" in sr || bt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, sr), sr.default;
        } else
          throw Ge._result;
      }
      function Bo(Ge) {
        var gt = {
          // We use these fields to store the result.
          _status: po,
          _result: Ge
        }, jt = {
          $$typeof: ze,
          _payload: gt,
          _init: $n
        };
        {
          var Ht, sr;
          Object.defineProperties(jt, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Ht;
              },
              set: function(Fr) {
                bt("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ht = Fr, Object.defineProperty(jt, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return sr;
              },
              set: function(Fr) {
                bt("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), sr = Fr, Object.defineProperty(jt, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return jt;
      }
      function ho(Ge) {
        Ge != null && Ge.$$typeof === Be ? bt("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof Ge != "function" ? bt("forwardRef requires a render function but was given %s.", Ge === null ? "null" : typeof Ge) : Ge.length !== 0 && Ge.length !== 2 && bt("forwardRef render functions accept exactly two parameters: props and ref. %s", Ge.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), Ge != null && (Ge.defaultProps != null || Ge.propTypes != null) && bt("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var gt = {
          $$typeof: Me,
          render: Ge
        };
        {
          var jt;
          Object.defineProperty(gt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return jt;
            },
            set: function(Ht) {
              jt = Ht, !Ge.name && !Ge.displayName && (Ge.displayName = Ht);
            }
          });
        }
        return gt;
      }
      var To;
      To = Symbol.for("react.module.reference");
      function Qt(Ge) {
        return !!(typeof Ge == "string" || typeof Ge == "function" || Ge === ve || Ge === xe || Qe || Ge === _e || Ge === Re || Ge === je || Ot || Ge === He || tr || er || hr || typeof Ge == "object" && Ge !== null && (Ge.$$typeof === ze || Ge.$$typeof === Be || Ge.$$typeof === Oe || Ge.$$typeof === $e || Ge.$$typeof === Me || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        Ge.$$typeof === To || Ge.getModuleId !== void 0));
      }
      function kr(Ge, gt) {
        Qt(Ge) || bt("memo: The first argument must be a component. Instead received: %s", Ge === null ? "null" : typeof Ge);
        var jt = {
          $$typeof: Be,
          type: Ge,
          compare: gt === void 0 ? null : gt
        };
        {
          var Ht;
          Object.defineProperty(jt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ht;
            },
            set: function(sr) {
              Ht = sr, !Ge.name && !Ge.displayName && (Ge.displayName = sr);
            }
          });
        }
        return jt;
      }
      function Tr() {
        var Ge = dt.current;
        return Ge === null && bt(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), Ge;
      }
      function vn(Ge) {
        var gt = Tr();
        if (Ge._context !== void 0) {
          var jt = Ge._context;
          jt.Consumer === Ge ? bt("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : jt.Provider === Ge && bt("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return gt.useContext(Ge);
      }
      function mn(Ge) {
        var gt = Tr();
        return gt.useState(Ge);
      }
      function En(Ge, gt, jt) {
        var Ht = Tr();
        return Ht.useReducer(Ge, gt, jt);
      }
      function Zn(Ge) {
        var gt = Tr();
        return gt.useRef(Ge);
      }
      function xn(Ge, gt) {
        var jt = Tr();
        return jt.useEffect(Ge, gt);
      }
      function na(Ge, gt) {
        var jt = Tr();
        return jt.useInsertionEffect(Ge, gt);
      }
      function Wo(Ge, gt) {
        var jt = Tr();
        return jt.useLayoutEffect(Ge, gt);
      }
      function Zo(Ge, gt) {
        var jt = Tr();
        return jt.useCallback(Ge, gt);
      }
      function va(Ge, gt) {
        var jt = Tr();
        return jt.useMemo(Ge, gt);
      }
      function yi(Ge, gt, jt) {
        var Ht = Tr();
        return Ht.useImperativeHandle(Ge, gt, jt);
      }
      function _s(Ge, gt) {
        {
          var jt = Tr();
          return jt.useDebugValue(Ge, gt);
        }
      }
      function xo() {
        var Ge = Tr();
        return Ge.useTransition();
      }
      function qu(Ge) {
        var gt = Tr();
        return gt.useDeferredValue(Ge);
      }
      function si() {
        var Ge = Tr();
        return Ge.useId();
      }
      function oo(Ge, gt, jt) {
        var Ht = Tr();
        return Ht.useSyncExternalStore(Ge, gt, jt);
      }
      var da = 0, xs, as, Ci, Ca, Es, ka, rl;
      function nl() {
      }
      nl.__reactDisabledLog = !0;
      function od() {
        {
          if (da === 0) {
            xs = console.log, as = console.info, Ci = console.warn, Ca = console.error, Es = console.group, ka = console.groupCollapsed, rl = console.groupEnd;
            var Ge = {
              configurable: !0,
              enumerable: !0,
              value: nl,
              writable: !0
            };
            Object.defineProperties(console, {
              info: Ge,
              log: Ge,
              warn: Ge,
              error: Ge,
              group: Ge,
              groupCollapsed: Ge,
              groupEnd: Ge
            });
          }
          da++;
        }
      }
      function ol() {
        {
          if (da--, da === 0) {
            var Ge = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: et({}, Ge, {
                value: xs
              }),
              info: et({}, Ge, {
                value: as
              }),
              warn: et({}, Ge, {
                value: Ci
              }),
              error: et({}, Ge, {
                value: Ca
              }),
              group: et({}, Ge, {
                value: Es
              }),
              groupCollapsed: et({}, Ge, {
                value: ka
              }),
              groupEnd: et({}, Ge, {
                value: rl
              })
            });
          }
          da < 0 && bt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Yi = at.ReactCurrentDispatcher, $i;
      function $a(Ge, gt, jt) {
        {
          if ($i === void 0)
            try {
              throw Error();
            } catch (sr) {
              var Ht = sr.stack.trim().match(/\n( *(at )?)/);
              $i = Ht && Ht[1] || "";
            }
          return `
` + $i + Ge;
        }
      }
      var Us = !1, ts;
      {
        var xl = typeof WeakMap == "function" ? WeakMap : Map;
        ts = new xl();
      }
      function lu(Ge, gt) {
        if (!Ge || Us)
          return "";
        {
          var jt = ts.get(Ge);
          if (jt !== void 0)
            return jt;
        }
        var Ht;
        Us = !0;
        var sr = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Fr;
        Fr = Yi.current, Yi.current = null, od();
        try {
          if (gt) {
            var Or = function() {
              throw Error();
            };
            if (Object.defineProperty(Or.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Or, []);
              } catch (ko) {
                Ht = ko;
              }
              Reflect.construct(Ge, [], Or);
            } else {
              try {
                Or.call();
              } catch (ko) {
                Ht = ko;
              }
              Ge.call(Or.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (ko) {
              Ht = ko;
            }
            Ge();
          }
        } catch (ko) {
          if (ko && Ht && typeof ko.stack == "string") {
            for (var Br = ko.stack.split(`
`), Kr = Ht.stack.split(`
`), Sn = Br.length - 1, In = Kr.length - 1; Sn >= 1 && In >= 0 && Br[Sn] !== Kr[In]; )
              In--;
            for (; Sn >= 1 && In >= 0; Sn--, In--)
              if (Br[Sn] !== Kr[In]) {
                if (Sn !== 1 || In !== 1)
                  do
                    if (Sn--, In--, In < 0 || Br[Sn] !== Kr[In]) {
                      var Un = `
` + Br[Sn].replace(" at new ", " at ");
                      return Ge.displayName && Un.includes("<anonymous>") && (Un = Un.replace("<anonymous>", Ge.displayName)), typeof Ge == "function" && ts.set(Ge, Un), Un;
                    }
                  while (Sn >= 1 && In >= 0);
                break;
              }
          }
        } finally {
          Us = !1, Yi.current = Fr, ol(), Error.prepareStackTrace = sr;
        }
        var Vn = Ge ? Ge.displayName || Ge.name : "", mo = Vn ? $a(Vn) : "";
        return typeof Ge == "function" && ts.set(Ge, mo), mo;
      }
      function El(Ge, gt, jt) {
        return lu(Ge, !1);
      }
      function Vs(Ge) {
        var gt = Ge.prototype;
        return !!(gt && gt.isReactComponent);
      }
      function Hs(Ge, gt, jt) {
        if (Ge == null)
          return "";
        if (typeof Ge == "function")
          return lu(Ge, Vs(Ge));
        if (typeof Ge == "string")
          return $a(Ge);
        switch (Ge) {
          case Re:
            return $a("Suspense");
          case je:
            return $a("SuspenseList");
        }
        if (typeof Ge == "object")
          switch (Ge.$$typeof) {
            case Me:
              return El(Ge.render);
            case Be:
              return Hs(Ge.type, gt, jt);
            case ze: {
              var Ht = Ge, sr = Ht._payload, Fr = Ht._init;
              try {
                return Hs(Fr(sr), gt, jt);
              } catch {
              }
            }
          }
        return "";
      }
      var qs = {}, jo = at.ReactDebugCurrentFrame;
      function is(Ge) {
        if (Ge) {
          var gt = Ge._owner, jt = Hs(Ge.type, Ge._source, gt ? gt.type : null);
          jo.setExtraStackFrame(jt);
        } else
          jo.setExtraStackFrame(null);
      }
      function hc(Ge, gt, jt, Ht, sr) {
        {
          var Fr = Function.call.bind(Xn);
          for (var Or in Ge)
            if (Fr(Ge, Or)) {
              var Br = void 0;
              try {
                if (typeof Ge[Or] != "function") {
                  var Kr = Error((Ht || "React class") + ": " + jt + " type `" + Or + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ge[Or] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Kr.name = "Invariant Violation", Kr;
                }
                Br = Ge[Or](gt, Or, Ht, jt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Sn) {
                Br = Sn;
              }
              Br && !(Br instanceof Error) && (is(sr), bt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ht || "React class", jt, Or, typeof Br), is(null)), Br instanceof Error && !(Br.message in qs) && (qs[Br.message] = !0, is(sr), bt("Failed %s type: %s", jt, Br.message), is(null));
            }
        }
      }
      function qa(Ge) {
        if (Ge) {
          var gt = Ge._owner, jt = Hs(Ge.type, Ge._source, gt ? gt.type : null);
          Zt(jt);
        } else
          Zt(null);
      }
      var Fo;
      Fo = !1;
      function al() {
        if (It.current) {
          var Ge = jn(It.current.type);
          if (Ge)
            return `

Check the render method of \`` + Ge + "`.";
        }
        return "";
      }
      function Sl(Ge) {
        if (Ge !== void 0) {
          var gt = Ge.fileName.replace(/^.*[\\\/]/, ""), jt = Ge.lineNumber;
          return `

Check your code at ` + gt + ":" + jt + ".";
        }
        return "";
      }
      function Gn(Ge) {
        return Ge != null ? Sl(Ge.__source) : "";
      }
      var Ws = {};
      function fa(Ge) {
        var gt = al();
        if (!gt) {
          var jt = typeof Ge == "string" ? Ge : Ge.displayName || Ge.name;
          jt && (gt = `

Check the top-level render call using <` + jt + ">.");
        }
        return gt;
      }
      function Ka(Ge, gt) {
        if (!(!Ge._store || Ge._store.validated || Ge.key != null)) {
          Ge._store.validated = !0;
          var jt = fa(gt);
          if (!Ws[jt]) {
            Ws[jt] = !0;
            var Ht = "";
            Ge && Ge._owner && Ge._owner !== It.current && (Ht = " It was passed a child from " + jn(Ge._owner.type) + "."), qa(Ge), bt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', jt, Ht), qa(null);
          }
        }
      }
      function Xa(Ge, gt) {
        if (typeof Ge == "object") {
          if (co(Ge))
            for (var jt = 0; jt < Ge.length; jt++) {
              var Ht = Ge[jt];
              Vr(Ht) && Ka(Ht, gt);
            }
          else if (Vr(Ge))
            Ge._store && (Ge._store.validated = !0);
          else if (Ge) {
            var sr = pt(Ge);
            if (typeof sr == "function" && sr !== Ge.entries)
              for (var Fr = sr.call(Ge), Or; !(Or = Fr.next()).done; )
                Vr(Or.value) && Ka(Or.value, gt);
          }
        }
      }
      function Zs(Ge) {
        {
          var gt = Ge.type;
          if (gt == null || typeof gt == "string")
            return;
          var jt;
          if (typeof gt == "function")
            jt = gt.propTypes;
          else if (typeof gt == "object" && (gt.$$typeof === Me || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          gt.$$typeof === Be))
            jt = gt.propTypes;
          else
            return;
          if (jt) {
            var Ht = jn(gt);
            hc(jt, Ge.props, "prop", Ht, Ge);
          } else if (gt.PropTypes !== void 0 && !Fo) {
            Fo = !0;
            var sr = jn(gt);
            bt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", sr || "Unknown");
          }
          typeof gt.getDefaultProps == "function" && !gt.getDefaultProps.isReactClassApproved && bt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function wa(Ge) {
        {
          for (var gt = Object.keys(Ge.props), jt = 0; jt < gt.length; jt++) {
            var Ht = gt[jt];
            if (Ht !== "children" && Ht !== "key") {
              qa(Ge), bt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ht), qa(null);
              break;
            }
          }
          Ge.ref !== null && (qa(Ge), bt("Invalid attribute `ref` supplied to `React.Fragment`."), qa(null));
        }
      }
      function Lo(Ge, gt, jt) {
        var Ht = Qt(Ge);
        if (!Ht) {
          var sr = "";
          (Ge === void 0 || typeof Ge == "object" && Ge !== null && Object.keys(Ge).length === 0) && (sr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Fr = Gn(gt);
          Fr ? sr += Fr : sr += al();
          var Or;
          Ge === null ? Or = "null" : co(Ge) ? Or = "array" : Ge !== void 0 && Ge.$$typeof === fe ? (Or = "<" + (jn(Ge.type) || "Unknown") + " />", sr = " Did you accidentally export a JSX literal instead of a component?") : Or = typeof Ge, bt("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Or, sr);
        }
        var Br = fr.apply(this, arguments);
        if (Br == null)
          return Br;
        if (Ht)
          for (var Kr = 2; Kr < arguments.length; Kr++)
            Xa(arguments[Kr], Ge);
        return Ge === ve ? wa(Br) : Zs(Br), Br;
      }
      var Pl = !1;
      function Ii(Ge) {
        var gt = Lo.bind(null, Ge);
        return gt.type = Ge, Pl || (Pl = !0, wt("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(gt, "type", {
          enumerable: !1,
          get: function() {
            return wt("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: Ge
            }), Ge;
          }
        }), gt;
      }
      function ja(Ge, gt, jt) {
        for (var Ht = Wr.apply(this, arguments), sr = 2; sr < arguments.length; sr++)
          Xa(arguments[sr], Ht.type);
        return Zs(Ht), Ht;
      }
      function Ss(Ge, gt) {
        var jt = yt.transition;
        yt.transition = {};
        var Ht = yt.transition;
        yt.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          Ge();
        } finally {
          if (yt.transition = jt, jt === null && Ht._updatedFibers) {
            var sr = Ht._updatedFibers.size;
            sr > 10 && wt("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ht._updatedFibers.clear();
          }
        }
      }
      var il = !1, vi = null;
      function Tl(Ge) {
        if (vi === null)
          try {
            var gt = ("require" + Math.random()).slice(0, 7), jt = ne && ne[gt];
            vi = jt.call(ne, "timers").setImmediate;
          } catch {
            vi = function(sr) {
              il === !1 && (il = !0, typeof MessageChannel > "u" && bt("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Fr = new MessageChannel();
              Fr.port1.onmessage = sr, Fr.port2.postMessage(void 0);
            };
          }
        return vi(Ge);
      }
      var bi = 0, Gs = !1;
      function cu(Ge) {
        {
          var gt = bi;
          bi++, Ct.current === null && (Ct.current = []);
          var jt = Ct.isBatchingLegacy, Ht;
          try {
            if (Ct.isBatchingLegacy = !0, Ht = Ge(), !jt && Ct.didScheduleLegacyUpdate) {
              var sr = Ct.current;
              sr !== null && (Ct.didScheduleLegacyUpdate = !1, Ps(sr));
            }
          } catch (Vn) {
            throw gi(gt), Vn;
          } finally {
            Ct.isBatchingLegacy = jt;
          }
          if (Ht !== null && typeof Ht == "object" && typeof Ht.then == "function") {
            var Fr = Ht, Or = !1, Br = {
              then: function(Vn, mo) {
                Or = !0, Fr.then(function(ko) {
                  gi(gt), bi === 0 ? Mi(ko, Vn, mo) : Vn(ko);
                }, function(ko) {
                  gi(gt), mo(ko);
                });
              }
            };
            return !Gs && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Or || (Gs = !0, bt("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Br;
          } else {
            var Kr = Ht;
            if (gi(gt), bi === 0) {
              var Sn = Ct.current;
              Sn !== null && (Ps(Sn), Ct.current = null);
              var In = {
                then: function(Vn, mo) {
                  Ct.current === null ? (Ct.current = [], Mi(Kr, Vn, mo)) : Vn(Kr);
                }
              };
              return In;
            } else {
              var Un = {
                then: function(Vn, mo) {
                  Vn(Kr);
                }
              };
              return Un;
            }
          }
        }
      }
      function gi(Ge) {
        Ge !== bi - 1 && bt("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), bi = Ge;
      }
      function Mi(Ge, gt, jt) {
        {
          var Ht = Ct.current;
          if (Ht !== null)
            try {
              Ps(Ht), Tl(function() {
                Ht.length === 0 ? (Ct.current = null, gt(Ge)) : Mi(Ge, gt, jt);
              });
            } catch (sr) {
              jt(sr);
            }
          else
            gt(Ge);
        }
      }
      var du = !1;
      function Ps(Ge) {
        if (!du) {
          du = !0;
          var gt = 0;
          try {
            for (; gt < Ge.length; gt++) {
              var jt = Ge[gt];
              do
                jt = jt(!0);
              while (jt !== null);
            }
            Ge.length = 0;
          } catch (Ht) {
            throw Ge = Ge.slice(gt + 1), Ht;
          } finally {
            du = !1;
          }
        }
      }
      var sl = Lo, Wu = ja, ul = Ii, kl = {
        map: zn,
        forEach: ii,
        count: Oo,
        toArray: No,
        only: Ao
      };
      oe.Children = kl, oe.Component = xr, oe.Fragment = ve, oe.Profiler = xe, oe.PureComponent = jr, oe.StrictMode = _e, oe.Suspense = Re, oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = at, oe.act = cu, oe.cloneElement = Wu, oe.createContext = Da, oe.createElement = sl, oe.createFactory = ul, oe.createRef = so, oe.forwardRef = ho, oe.isValidElement = Vr, oe.lazy = Bo, oe.memo = kr, oe.startTransition = Ss, oe.unstable_act = cu, oe.useCallback = Zo, oe.useContext = vn, oe.useDebugValue = _s, oe.useDeferredValue = qu, oe.useEffect = xn, oe.useId = si, oe.useImperativeHandle = yi, oe.useInsertionEffect = na, oe.useLayoutEffect = Wo, oe.useMemo = va, oe.useReducer = En, oe.useRef = Zn, oe.useState = mn, oe.useSyncExternalStore = oo, oe.useTransition = xo, oe.version = ae, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(react_development, react_development.exports)), react_development.exports;
}
process.env.NODE_ENV === "production" ? react.exports = requireReact_production_min() : react.exports = requireReact_development();
var reactExports = react.exports;
const ReactExports = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production_min;
function requireUseSyncExternalStoreShim_production_min() {
  if (hasRequiredUseSyncExternalStoreShim_production_min)
    return useSyncExternalStoreShim_production_min;
  hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var ne = reactExports;
  function oe(Re, je) {
    return Re === je && (Re !== 0 || 1 / Re === 1 / je) || Re !== Re && je !== je;
  }
  var ae = typeof Object.is == "function" ? Object.is : oe, fe = ne.useState, ye = ne.useEffect, ve = ne.useLayoutEffect, _e = ne.useDebugValue;
  function xe(Re, je) {
    var Be = je(), ze = fe({ inst: { value: Be, getSnapshot: je } }), He = ze[0].inst, qe = ze[1];
    return ve(function() {
      He.value = Be, He.getSnapshot = je, Oe(He) && qe({ inst: He });
    }, [Re, Be, je]), ye(function() {
      return Oe(He) && qe({ inst: He }), Re(function() {
        Oe(He) && qe({ inst: He });
      });
    }, [Re]), _e(Be), Be;
  }
  function Oe(Re) {
    var je = Re.getSnapshot;
    Re = Re.value;
    try {
      var Be = je();
      return !ae(Re, Be);
    } catch {
      return !0;
    }
  }
  function $e(Re, je) {
    return je();
  }
  var Me = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? $e : xe;
  return useSyncExternalStoreShim_production_min.useSyncExternalStore = ne.useSyncExternalStore !== void 0 ? ne.useSyncExternalStore : Me, useSyncExternalStoreShim_production_min;
}
var useSyncExternalStoreShim_development = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  return hasRequiredUseSyncExternalStoreShim_development || (hasRequiredUseSyncExternalStoreShim_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ne = reactExports, oe = ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ae(dt) {
      {
        for (var yt = arguments.length, Ct = new Array(yt > 1 ? yt - 1 : 0), It = 1; It < yt; It++)
          Ct[It - 1] = arguments[It];
        fe("error", dt, Ct);
      }
    }
    function fe(dt, yt, Ct) {
      {
        var It = oe.ReactDebugCurrentFrame, Vt = It.getStackAddendum();
        Vt !== "" && (yt += "%s", Ct = Ct.concat([Vt]));
        var Ut = Ct.map(function(Zt) {
          return String(Zt);
        });
        Ut.unshift("Warning: " + yt), Function.prototype.apply.call(console[dt], console, Ut);
      }
    }
    function ye(dt, yt) {
      return dt === yt && (dt !== 0 || 1 / dt === 1 / yt) || dt !== dt && yt !== yt;
    }
    var ve = typeof Object.is == "function" ? Object.is : ye, _e = ne.useState, xe = ne.useEffect, Oe = ne.useLayoutEffect, $e = ne.useDebugValue, Me = !1, Re = !1;
    function je(dt, yt, Ct) {
      Me || ne.startTransition !== void 0 && (Me = !0, ae("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var It = yt();
      if (!Re) {
        var Vt = yt();
        ve(It, Vt) || (ae("The result of getSnapshot should be cached to avoid an infinite loop"), Re = !0);
      }
      var Ut = _e({
        inst: {
          value: It,
          getSnapshot: yt
        }
      }), Zt = Ut[0].inst, tr = Ut[1];
      return Oe(function() {
        Zt.value = It, Zt.getSnapshot = yt, Be(Zt) && tr({
          inst: Zt
        });
      }, [dt, It, yt]), xe(function() {
        Be(Zt) && tr({
          inst: Zt
        });
        var er = function() {
          Be(Zt) && tr({
            inst: Zt
          });
        };
        return dt(er);
      }, [dt]), $e(It), It;
    }
    function Be(dt) {
      var yt = dt.getSnapshot, Ct = dt.value;
      try {
        var It = yt();
        return !ve(Ct, It);
      } catch {
        return !0;
      }
    }
    function ze(dt, yt, Ct) {
      return yt();
    }
    var He = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", qe = !He, Ye = qe ? ze : je, pt = ne.useSyncExternalStore !== void 0 ? ne.useSyncExternalStore : Ye;
    useSyncExternalStoreShim_development.useSyncExternalStore = pt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), useSyncExternalStoreShim_development;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, process.env.NODE_ENV === "production" ? shim.exports = requireUseSyncExternalStoreShim_production_min() : shim.exports = requireUseSyncExternalStoreShim_development()), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production_min;
function requireWithSelector_production_min() {
  if (hasRequiredWithSelector_production_min)
    return withSelector_production_min;
  hasRequiredWithSelector_production_min = 1;
  var ne = reactExports, oe = requireShim();
  function ae($e, Me) {
    return $e === Me && ($e !== 0 || 1 / $e === 1 / Me) || $e !== $e && Me !== Me;
  }
  var fe = typeof Object.is == "function" ? Object.is : ae, ye = oe.useSyncExternalStore, ve = ne.useRef, _e = ne.useEffect, xe = ne.useMemo, Oe = ne.useDebugValue;
  return withSelector_production_min.useSyncExternalStoreWithSelector = function($e, Me, Re, je, Be) {
    var ze = ve(null);
    if (ze.current === null) {
      var He = { hasValue: !1, value: null };
      ze.current = He;
    } else
      He = ze.current;
    ze = xe(function() {
      function Ye(It) {
        if (!pt) {
          if (pt = !0, dt = It, It = je(It), Be !== void 0 && He.hasValue) {
            var Vt = He.value;
            if (Be(Vt, It))
              return yt = Vt;
          }
          return yt = It;
        }
        if (Vt = yt, fe(dt, It))
          return Vt;
        var Ut = je(It);
        return Be !== void 0 && Be(Vt, Ut) ? Vt : (dt = It, yt = Ut);
      }
      var pt = !1, dt, yt, Ct = Re === void 0 ? null : Re;
      return [function() {
        return Ye(Me());
      }, Ct === null ? void 0 : function() {
        return Ye(Ct());
      }];
    }, [Me, Re, je, Be]);
    var qe = ye($e, ze[0], ze[1]);
    return _e(function() {
      He.hasValue = !0, He.value = qe;
    }, [qe]), Oe(qe), qe;
  }, withSelector_production_min;
}
var withSelector_development = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  return hasRequiredWithSelector_development || (hasRequiredWithSelector_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ne = reactExports, oe = requireShim();
    function ae(Me, Re) {
      return Me === Re && (Me !== 0 || 1 / Me === 1 / Re) || Me !== Me && Re !== Re;
    }
    var fe = typeof Object.is == "function" ? Object.is : ae, ye = oe.useSyncExternalStore, ve = ne.useRef, _e = ne.useEffect, xe = ne.useMemo, Oe = ne.useDebugValue;
    function $e(Me, Re, je, Be, ze) {
      var He = ve(null), qe;
      He.current === null ? (qe = {
        hasValue: !1,
        value: null
      }, He.current = qe) : qe = He.current;
      var Ye = xe(function() {
        var Ct = !1, It, Vt, Ut = function(hr) {
          if (!Ct) {
            Ct = !0, It = hr;
            var Ot = Be(hr);
            if (ze !== void 0 && qe.hasValue) {
              var Qe = qe.value;
              if (ze(Qe, Ot))
                return Vt = Qe, Qe;
            }
            return Vt = Ot, Ot;
          }
          var at = It, wt = Vt;
          if (fe(at, hr))
            return wt;
          var bt = Be(hr);
          return ze !== void 0 && ze(wt, bt) ? wt : (It = hr, Vt = bt, bt);
        }, Zt = je === void 0 ? null : je, tr = function() {
          return Ut(Re());
        }, er = Zt === null ? void 0 : function() {
          return Ut(Zt());
        };
        return [tr, er];
      }, [Re, je, Be, ze]), pt = Ye[0], dt = Ye[1], yt = ye(Me, pt, dt);
      return _e(function() {
        qe.hasValue = !0, qe.value = yt;
      }, [yt]), Oe(yt), yt;
    }
    withSelector_development.useSyncExternalStoreWithSelector = $e, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), withSelector_development;
}
process.env.NODE_ENV === "production" ? withSelector.exports = requireWithSelector_production_min() : withSelector.exports = requireWithSelector_development();
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), { useDebugValue } = ReactExports, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = !1;
const identity = (ne) => ne;
function useStore(ne, oe = identity, ae) {
  const fe = useSyncExternalStoreWithSelector(
    ne.subscribe,
    ne.getState,
    ne.getServerState || ne.getInitialState,
    oe,
    ae
  );
  return useDebugValue(fe), fe;
}
const createImpl = (ne) => {
  const oe = typeof ne == "function" ? createStore(ne) : ne, ae = (fe, ye) => useStore(oe, fe, ye);
  return Object.assign(ae, oe), ae;
}, create = (ne) => ne ? createImpl(ne) : createImpl;
var i = S.extend("zustand"), D = S.extend("zustand");
i.log = console.debug.bind(console);
D.log = console.error.bind(console);
function g({ tableId: ne, keyTuple: oe }) {
  return `${ne}:${concatHex$1(oe)}`;
}
function I({ store: ne }) {
  return async function({ logs: oe }) {
    let ae = /* @__PURE__ */ new Map(), fe = { ...ne.getState().rawRecords };
    for (let Oe of oe) {
      let $e = ne.getState().tables[Oe.args.tableId];
      if (!$e) {
        let { namespace: Re, name: je } = _$4(Oe.args.tableId);
        i(`skipping update for unknown table: ${i$6({ namespace: Re, name: je })} (${Oe.args.tableId}) at ${Oe.address}`);
        continue;
      }
      let Me = g(Oe.args);
      if (Oe.eventName === "Store_SetRecord")
        i("setting record", { namespace: $e.namespace, name: $e.name, id: Me, log: Oe }), fe[Me] = { id: Me, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: Oe.args.staticData, encodedLengths: Oe.args.encodedLengths, dynamicData: Oe.args.dynamicData }, ae.set(Me, !1);
      else if (Oe.eventName === "Store_SpliceStaticData") {
        i("splicing static data", { namespace: $e.namespace, name: $e.name, id: Me, log: Oe });
        let Re = fe[Me] ?? { id: Me, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: "0x", encodedLengths: "0x", dynamicData: "0x" }, je = Pe(Re.staticData, Oe.args.start, size$2(Oe.args.data), Oe.args.data);
        fe[Me] = { ...Re, staticData: je }, ae.set(Me, !1);
      } else if (Oe.eventName === "Store_SpliceDynamicData") {
        i("splicing dynamic data", { namespace: $e.namespace, name: $e.name, id: Me, log: Oe });
        let Re = fe[Me] ?? { id: Me, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: "0x", encodedLengths: "0x", dynamicData: "0x" }, je = Oe.args.encodedLengths, Be = Pe(Re.dynamicData, Oe.args.start, Oe.args.deleteCount, Oe.args.data);
        fe[Me] = { ...Re, encodedLengths: je, dynamicData: Be }, ae.set(Me, !1);
      } else
        Oe.eventName === "Store_DeleteRecord" && (i("deleting record", { namespace: $e.namespace, name: $e.name, id: Me, log: Oe }), delete fe[Me], ae.set(Me, !0));
    }
    if (!ae.size)
      return;
    let ye = Array.from(ae.keys()).filter((Oe) => ae.get(Oe) === !1), ve = Array.from(ae.keys()).filter((Oe) => ae.get(Oe) === !0), _e = ne.getState().records, xe = { ...Object.fromEntries(Object.entries(_e).filter(([Oe]) => !ve.includes(Oe))), ...Object.fromEntries(ye.map((Oe) => {
      let $e = fe[Oe];
      if (!$e) {
        console.warn("no raw record found for updated ID", Oe);
        return;
      }
      let Me = ne.getState().tables[$e.tableId];
      if (!Me) {
        console.warn("no table found for record", $e);
        return;
      }
      let Re = lt$1(ia(Xi$1(Me)), $e.keyTuple), je = zt$1(ia(Zi(Me)), $e);
      return [Oe, { id: Oe, table: ne.getState().tables[$e.tableId], keyTuple: $e.keyTuple, key: Re, value: je, fields: { ...Re, ...je } }];
    }).filter(b$7)) };
    ne.setState({ rawRecords: fe, records: xe });
  };
}
function k(ne) {
  return create((oe, ae) => ({ syncProgress: { step: "initialize", message: "Connecting", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n }, tables: Object.fromEntries(Object.entries(ne.tables).map(([, fe]) => [fe.tableId, fe])), rawRecords: {}, records: {}, getRecords: (fe) => {
    let ye = ae().records;
    return Object.fromEntries(Object.entries(ye).filter(([ve, _e]) => _e.table.tableId === fe.tableId));
  }, getRecord: (fe, ye) => {
    let ve = Yt(ia(Xi$1(fe)), ye), _e = g({ tableId: fe.tableId, keyTuple: ve });
    return ae().records[_e];
  }, getValue: (fe, ye) => {
    var ve;
    return (ve = ae().getRecord(fe, ye)) == null ? void 0 : ve.value;
  } }));
}
async function ge({ config: ne, tables: oe = {}, store: ae, startSync: fe = !0, ...ye }) {
  let ve = { ...O(ne), ...oe, ...A$3 }, _e = ae ?? k({ tables: ve }), xe = I({ store: _e }), Oe = await Et({ storageAdapter: xe, ...ye, onProgress: (Me) => {
    _e.getState().syncProgress.step !== "live" && _e.setState(() => ({ syncProgress: Me }));
  } }), $e = fe ? Oe.storedBlockLogs$.subscribe() : null;
  return { ...Oe, tables: ve, useStore: _e, stopSync: () => {
    $e == null || $e.unsubscribe();
  } };
}
async function setupNetwork() {
  const ne = await getNetworkConfig();
  console.log("chain", ne.chain);
  const oe = {
    chain: ne.chain,
    transport: Ee(fallback([webSocket(), http()])),
    pollingInterval: 1e3
  };
  console.log("clientOptions", oe);
  const ae = createPublicClient(oe);
  console.log("publicClient", ae);
  const fe = new Subject(), ye = Q$4(ne.privateKey), ve = createWalletClient({
    ...oe,
    account: ye
  }).extend(p()).extend(h({ onWrite: (He) => fe.next(He) }));
  console.log("burnerAccount", ye), console.log("burnerWalletClient", ve);
  const _e = getContract({
    address: ne.worldAddress,
    abi: IWorldAbi,
    client: { public: ae, wallet: ve }
  });
  console.log("worldContract", _e);
  const xe = getContract({
    address: "0x88b985C5515B646D5ae4afc56d0855051cea5b48",
    abi: IERC20Abi,
    client: { public: ae, wallet: ve }
  }), Oe = getContract({
    address: "0x45AD5640957673B6585a5500D35740fbf698498b",
    abi: IERC20Abi,
    client: { public: ae, wallet: ve }
  }), $e = getContract({
    address: "0x358CD91cb9E587b5990E4BBa1C49Bc5FB384674e",
    abi: IERC20Abi,
    client: { public: ae, wallet: ve }
  }), { components: Me, latestBlock$: Re, storedBlockLogs$: je, waitForTransaction: Be } = await Ke({
    world,
    config: mudConfig,
    address: ne.worldAddress,
    publicClient: ae,
    startBlock: BigInt(ne.initialBlockNumber)
  }), { useStore: ze } = await ge({
    world,
    config: mudConfig,
    address: ne.worldAddress,
    publicClient: ae,
    startBlock: BigInt(ne.initialBlockNumber)
  });
  if (ne.faucetServiceUrl) {
    const He = ye.address;
    console.info("[Dev Faucet]: Player address -> ", He);
    const qe = createFaucetService(ne.faucetServiceUrl), Ye = async () => {
      const pt = await ae.getBalance({ address: He });
      console.info(`[Dev Faucet]: Player balance -> ${pt}`), pt < parseEther("1") && (console.info("[Dev Faucet]: Balance is low, dripping funds to player"), await qe.dripDev({ address: He }), await qe.dripDev({ address: He }));
    };
    Ye(), setInterval(Ye, 2e4);
  }
  return console.log("components", Me), console.log("useStore", ze), {
    world,
    components: Me,
    playerEntity: M$1({ address: "address" }, { address: ve.account.address }),
    publicClient: ae,
    walletClient: ve,
    latestBlock$: Re,
    storedBlockLogs$: je,
    waitForTransaction: Be,
    worldContract: _e,
    write$: fe.asObservable().pipe(share()),
    useStore: ze,
    tokenAContract: xe,
    tokenBContract: Oe,
    tokenCContract: $e
    // tables
  };
}
async function setup() {
  const ne = await setupNetwork(), oe = createClientComponents(ne), ae = createSystemCalls(ne);
  return {
    network: ne,
    components: oe,
    systemCalls: ae
  };
}
var pX = Object.create, AR = Object.defineProperty, vX = Object.getOwnPropertyDescriptor, mX = Object.getOwnPropertyNames, hX = Object.getPrototypeOf, yX = Object.prototype.hasOwnProperty, Y = (ne, oe) => () => (ne && (oe = ne(ne = 0)), oe), M = (ne, oe) => () => (oe || ne((oe = { exports: {} }).exports, oe), oe.exports), Uj = (ne, oe) => {
  for (var ae in oe)
    AR(ne, ae, { get: oe[ae], enumerable: !0 });
}, gX = (ne, oe, ae, fe) => {
  if (oe && typeof oe == "object" || typeof oe == "function")
    for (let ye of mX(oe))
      !yX.call(ne, ye) && ye !== ae && AR(ne, ye, { get: () => oe[ye], enumerable: !(fe = vX(oe, ye)) || fe.enumerable });
  return ne;
}, le = (ne, oe, ae) => (ae = ne != null ? pX(hX(ne)) : {}, gX(oe || !ne || !ne.__esModule ? AR(ae, "default", { value: ne, enumerable: !0 }) : ae, ne)), Gj = M((ne) => {
  var oe = Symbol.for("react.element"), ae = Symbol.for("react.portal"), fe = Symbol.for("react.fragment"), ye = Symbol.for("react.strict_mode"), ve = Symbol.for("react.profiler"), _e = Symbol.for("react.provider"), xe = Symbol.for("react.context"), Oe = Symbol.for("react.forward_ref"), $e = Symbol.for("react.suspense"), Me = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), je = Symbol.iterator;
  function Be(ot) {
    return ot === null || typeof ot != "object" ? null : (ot = je && ot[je] || ot["@@iterator"], typeof ot == "function" ? ot : null);
  }
  var ze = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, He = Object.assign, qe = {};
  function Ye(ot, et, Rt) {
    this.props = ot, this.context = et, this.refs = qe, this.updater = Rt || ze;
  }
  Ye.prototype.isReactComponent = {}, Ye.prototype.setState = function(ot, et) {
    if (typeof ot != "object" && typeof ot != "function" && ot != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ot, et, "setState");
  }, Ye.prototype.forceUpdate = function(ot) {
    this.updater.enqueueForceUpdate(this, ot, "forceUpdate");
  };
  function pt() {
  }
  pt.prototype = Ye.prototype;
  function dt(ot, et, Rt) {
    this.props = ot, this.context = et, this.refs = qe, this.updater = Rt || ze;
  }
  var yt = dt.prototype = new pt();
  yt.constructor = dt, He(yt, Ye.prototype), yt.isPureReactComponent = !0;
  var Ct = Array.isArray, It = Object.prototype.hasOwnProperty, Vt = { current: null }, Ut = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Zt(ot, et, Rt) {
    var xr, Xt = {}, dr = null, Nr = null;
    if (et != null)
      for (xr in et.ref !== void 0 && (Nr = et.ref), et.key !== void 0 && (dr = "" + et.key), et)
        It.call(et, xr) && !Ut.hasOwnProperty(xr) && (Xt[xr] = et[xr]);
    var Dr = arguments.length - 2;
    if (Dr === 1)
      Xt.children = Rt;
    else if (1 < Dr) {
      for (var jr = Array(Dr), un = 0; un < Dr; un++)
        jr[un] = arguments[un + 2];
      Xt.children = jr;
    }
    if (ot && ot.defaultProps)
      for (xr in Dr = ot.defaultProps, Dr)
        Xt[xr] === void 0 && (Xt[xr] = Dr[xr]);
    return { $$typeof: oe, type: ot, key: dr, ref: Nr, props: Xt, _owner: Vt.current };
  }
  function tr(ot, et) {
    return { $$typeof: oe, type: ot.type, key: et, ref: ot.ref, props: ot.props, _owner: ot._owner };
  }
  function er(ot) {
    return typeof ot == "object" && ot !== null && ot.$$typeof === oe;
  }
  function hr(ot) {
    var et = { "=": "=0", ":": "=2" };
    return "$" + ot.replace(/[=:]/g, function(Rt) {
      return et[Rt];
    });
  }
  var Ot = /\/+/g;
  function Qe(ot, et) {
    return typeof ot == "object" && ot !== null && ot.key != null ? hr("" + ot.key) : et.toString(36);
  }
  function at(ot, et, Rt, xr, Xt) {
    var dr = typeof ot;
    (dr === "undefined" || dr === "boolean") && (ot = null);
    var Nr = !1;
    if (ot === null)
      Nr = !0;
    else
      switch (dr) {
        case "string":
        case "number":
          Nr = !0;
          break;
        case "object":
          switch (ot.$$typeof) {
            case oe:
            case ae:
              Nr = !0;
          }
      }
    if (Nr)
      return Nr = ot, Xt = Xt(Nr), ot = xr === "" ? "." + Qe(Nr, 0) : xr, Ct(Xt) ? (Rt = "", ot != null && (Rt = ot.replace(Ot, "$&/") + "/"), at(Xt, et, Rt, "", function(un) {
        return un;
      })) : Xt != null && (er(Xt) && (Xt = tr(Xt, Rt + (!Xt.key || Nr && Nr.key === Xt.key ? "" : ("" + Xt.key).replace(Ot, "$&/") + "/") + ot)), et.push(Xt)), 1;
    if (Nr = 0, xr = xr === "" ? "." : xr + ":", Ct(ot))
      for (var Dr = 0; Dr < ot.length; Dr++) {
        dr = ot[Dr];
        var jr = xr + Qe(dr, Dr);
        Nr += at(dr, et, Rt, jr, Xt);
      }
    else if (jr = Be(ot), typeof jr == "function")
      for (ot = jr.call(ot), Dr = 0; !(dr = ot.next()).done; )
        dr = dr.value, jr = xr + Qe(dr, Dr++), Nr += at(dr, et, Rt, jr, Xt);
    else if (dr === "object")
      throw et = String(ot), Error("Objects are not valid as a React child (found: " + (et === "[object Object]" ? "object with keys {" + Object.keys(ot).join(", ") + "}" : et) + "). If you meant to render a collection of children, use an array instead.");
    return Nr;
  }
  function wt(ot, et, Rt) {
    if (ot == null)
      return ot;
    var xr = [], Xt = 0;
    return at(ot, xr, "", "", function(dr) {
      return et.call(Rt, dr, Xt++);
    }), xr;
  }
  function bt(ot) {
    if (ot._status === -1) {
      var et = ot._result;
      et = et(), et.then(function(Rt) {
        (ot._status === 0 || ot._status === -1) && (ot._status = 1, ot._result = Rt);
      }, function(Rt) {
        (ot._status === 0 || ot._status === -1) && (ot._status = 2, ot._result = Rt);
      }), ot._status === -1 && (ot._status = 0, ot._result = et);
    }
    if (ot._status === 1)
      return ot._result.default;
    throw ot._result;
  }
  var At = { current: null }, Ft = { transition: null }, Gt = { ReactCurrentDispatcher: At, ReactCurrentBatchConfig: Ft, ReactCurrentOwner: Vt };
  ne.Children = { map: wt, forEach: function(ot, et, Rt) {
    wt(ot, function() {
      et.apply(this, arguments);
    }, Rt);
  }, count: function(ot) {
    var et = 0;
    return wt(ot, function() {
      et++;
    }), et;
  }, toArray: function(ot) {
    return wt(ot, function(et) {
      return et;
    }) || [];
  }, only: function(ot) {
    if (!er(ot))
      throw Error("React.Children.only expected to receive a single React element child.");
    return ot;
  } }, ne.Component = Ye, ne.Fragment = fe, ne.Profiler = ve, ne.PureComponent = dt, ne.StrictMode = ye, ne.Suspense = $e, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gt, ne.cloneElement = function(ot, et, Rt) {
    if (ot == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ot + ".");
    var xr = He({}, ot.props), Xt = ot.key, dr = ot.ref, Nr = ot._owner;
    if (et != null) {
      if (et.ref !== void 0 && (dr = et.ref, Nr = Vt.current), et.key !== void 0 && (Xt = "" + et.key), ot.type && ot.type.defaultProps)
        var Dr = ot.type.defaultProps;
      for (jr in et)
        It.call(et, jr) && !Ut.hasOwnProperty(jr) && (xr[jr] = et[jr] === void 0 && Dr !== void 0 ? Dr[jr] : et[jr]);
    }
    var jr = arguments.length - 2;
    if (jr === 1)
      xr.children = Rt;
    else if (1 < jr) {
      Dr = Array(jr);
      for (var un = 0; un < jr; un++)
        Dr[un] = arguments[un + 2];
      xr.children = Dr;
    }
    return { $$typeof: oe, type: ot.type, key: Xt, ref: dr, props: xr, _owner: Nr };
  }, ne.createContext = function(ot) {
    return ot = { $$typeof: xe, _currentValue: ot, _currentValue2: ot, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ot.Provider = { $$typeof: _e, _context: ot }, ot.Consumer = ot;
  }, ne.createElement = Zt, ne.createFactory = function(ot) {
    var et = Zt.bind(null, ot);
    return et.type = ot, et;
  }, ne.createRef = function() {
    return { current: null };
  }, ne.forwardRef = function(ot) {
    return { $$typeof: Oe, render: ot };
  }, ne.isValidElement = er, ne.lazy = function(ot) {
    return { $$typeof: Re, _payload: { _status: -1, _result: ot }, _init: bt };
  }, ne.memo = function(ot, et) {
    return { $$typeof: Me, type: ot, compare: et === void 0 ? null : et };
  }, ne.startTransition = function(ot) {
    var et = Ft.transition;
    Ft.transition = {};
    try {
      ot();
    } finally {
      Ft.transition = et;
    }
  }, ne.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, ne.useCallback = function(ot, et) {
    return At.current.useCallback(ot, et);
  }, ne.useContext = function(ot) {
    return At.current.useContext(ot);
  }, ne.useDebugValue = function() {
  }, ne.useDeferredValue = function(ot) {
    return At.current.useDeferredValue(ot);
  }, ne.useEffect = function(ot, et) {
    return At.current.useEffect(ot, et);
  }, ne.useId = function() {
    return At.current.useId();
  }, ne.useImperativeHandle = function(ot, et, Rt) {
    return At.current.useImperativeHandle(ot, et, Rt);
  }, ne.useInsertionEffect = function(ot, et) {
    return At.current.useInsertionEffect(ot, et);
  }, ne.useLayoutEffect = function(ot, et) {
    return At.current.useLayoutEffect(ot, et);
  }, ne.useMemo = function(ot, et) {
    return At.current.useMemo(ot, et);
  }, ne.useReducer = function(ot, et, Rt) {
    return At.current.useReducer(ot, et, Rt);
  }, ne.useRef = function(ot) {
    return At.current.useRef(ot);
  }, ne.useState = function(ot) {
    return At.current.useState(ot);
  }, ne.useSyncExternalStore = function(ot, et, Rt) {
    return At.current.useSyncExternalStore(ot, et, Rt);
  }, ne.useTransition = function() {
    return At.current.useTransition();
  }, ne.version = "18.2.0";
}), Qj = M((ne, oe) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ae = "18.2.0", fe = Symbol.for("react.element"), ye = Symbol.for("react.portal"), ve = Symbol.for("react.fragment"), _e = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), Oe = Symbol.for("react.provider"), $e = Symbol.for("react.context"), Me = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), je = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), qe = Symbol.iterator, Ye = "@@iterator";
    function pt(Ge) {
      if (Ge === null || typeof Ge != "object")
        return null;
      var gt = qe && Ge[qe] || Ge[Ye];
      return typeof gt == "function" ? gt : null;
    }
    var dt = { current: null }, yt = { transition: null }, Ct = { current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1 }, It = { current: null }, Vt = {}, Ut = null;
    function Zt(Ge) {
      Ut = Ge;
    }
    Vt.setExtraStackFrame = function(Ge) {
      Ut = Ge;
    }, Vt.getCurrentStack = null, Vt.getStackAddendum = function() {
      var Ge = "";
      Ut && (Ge += Ut);
      var gt = Vt.getCurrentStack;
      return gt && (Ge += gt() || ""), Ge;
    };
    var tr = !1, er = !1, hr = !1, Ot = !1, Qe = !1, at = { ReactCurrentDispatcher: dt, ReactCurrentBatchConfig: yt, ReactCurrentOwner: It };
    at.ReactDebugCurrentFrame = Vt, at.ReactCurrentActQueue = Ct;
    function wt(Ge) {
      {
        for (var gt = arguments.length, jt = new Array(gt > 1 ? gt - 1 : 0), Ht = 1; Ht < gt; Ht++)
          jt[Ht - 1] = arguments[Ht];
        At("warn", Ge, jt);
      }
    }
    function bt(Ge) {
      {
        for (var gt = arguments.length, jt = new Array(gt > 1 ? gt - 1 : 0), Ht = 1; Ht < gt; Ht++)
          jt[Ht - 1] = arguments[Ht];
        At("error", Ge, jt);
      }
    }
    function At(Ge, gt, jt) {
      {
        var Ht = at.ReactDebugCurrentFrame, sr = Ht.getStackAddendum();
        sr !== "" && (gt += "%s", jt = jt.concat([sr]));
        var Fr = jt.map(function(Or) {
          return String(Or);
        });
        Fr.unshift("Warning: " + gt), Function.prototype.apply.call(console[Ge], console, Fr);
      }
    }
    var Ft = {};
    function Gt(Ge, gt) {
      {
        var jt = Ge.constructor, Ht = jt && (jt.displayName || jt.name) || "ReactClass", sr = Ht + "." + gt;
        if (Ft[sr])
          return;
        bt("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", gt, Ht), Ft[sr] = !0;
      }
    }
    var ot = { isMounted: function(Ge) {
      return !1;
    }, enqueueForceUpdate: function(Ge, gt, jt) {
      Gt(Ge, "forceUpdate");
    }, enqueueReplaceState: function(Ge, gt, jt, Ht) {
      Gt(Ge, "replaceState");
    }, enqueueSetState: function(Ge, gt, jt, Ht) {
      Gt(Ge, "setState");
    } }, et = Object.assign, Rt = {};
    Object.freeze(Rt);
    function xr(Ge, gt, jt) {
      this.props = Ge, this.context = gt, this.refs = Rt, this.updater = jt || ot;
    }
    xr.prototype.isReactComponent = {}, xr.prototype.setState = function(Ge, gt) {
      if (typeof Ge != "object" && typeof Ge != "function" && Ge != null)
        throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, Ge, gt, "setState");
    }, xr.prototype.forceUpdate = function(Ge) {
      this.updater.enqueueForceUpdate(this, Ge, "forceUpdate");
    };
    {
      var Xt = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] }, dr = function(Ge, gt) {
        Object.defineProperty(xr.prototype, Ge, { get: function() {
          wt("%s(...) is deprecated in plain JavaScript React classes. %s", gt[0], gt[1]);
        } });
      };
      for (var Nr in Xt)
        Xt.hasOwnProperty(Nr) && dr(Nr, Xt[Nr]);
    }
    function Dr() {
    }
    Dr.prototype = xr.prototype;
    function jr(Ge, gt, jt) {
      this.props = Ge, this.context = gt, this.refs = Rt, this.updater = jt || ot;
    }
    var un = jr.prototype = new Dr();
    un.constructor = jr, et(un, xr.prototype), un.isPureReactComponent = !0;
    function so() {
      var Ge = { current: null };
      return Object.seal(Ge), Ge;
    }
    var Pn = Array.isArray;
    function co(Ge) {
      return Pn(Ge);
    }
    function kn(Ge) {
      {
        var gt = typeof Symbol == "function" && Symbol.toStringTag, jt = gt && Ge[Symbol.toStringTag] || Ge.constructor.name || "Object";
        return jt;
      }
    }
    function Yn(Ge) {
      try {
        return Ho(Ge), !1;
      } catch {
        return !0;
      }
    }
    function Ho(Ge) {
      return "" + Ge;
    }
    function Rn(Ge) {
      if (Yn(Ge))
        return bt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", kn(Ge)), Ho(Ge);
    }
    function fo(Ge, gt, jt) {
      var Ht = Ge.displayName;
      if (Ht)
        return Ht;
      var sr = gt.displayName || gt.name || "";
      return sr !== "" ? jt + "(" + sr + ")" : jt;
    }
    function pa(Ge) {
      return Ge.displayName || "Context";
    }
    function jn(Ge) {
      if (Ge == null)
        return null;
      if (typeof Ge.tag == "number" && bt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ge == "function")
        return Ge.displayName || Ge.name || null;
      if (typeof Ge == "string")
        return Ge;
      switch (Ge) {
        case ve:
          return "Fragment";
        case ye:
          return "Portal";
        case xe:
          return "Profiler";
        case _e:
          return "StrictMode";
        case Re:
          return "Suspense";
        case je:
          return "SuspenseList";
      }
      if (typeof Ge == "object")
        switch (Ge.$$typeof) {
          case $e:
            var gt = Ge;
            return pa(gt) + ".Consumer";
          case Oe:
            var jt = Ge;
            return pa(jt._context) + ".Provider";
          case Me:
            return fo(Ge, Ge.render, "ForwardRef");
          case Be:
            var Ht = Ge.displayName || null;
            return Ht !== null ? Ht : jn(Ge.type) || "Memo";
          case ze: {
            var sr = Ge, Fr = sr._payload, Or = sr._init;
            try {
              return jn(Or(Fr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Xn = Object.prototype.hasOwnProperty, Ko = { key: !0, ref: !0, __self: !0, __source: !0 }, vo, Eo, ra;
    ra = {};
    function uo(Ge) {
      if (Xn.call(Ge, "ref")) {
        var gt = Object.getOwnPropertyDescriptor(Ge, "ref").get;
        if (gt && gt.isReactWarning)
          return !1;
      }
      return Ge.ref !== void 0;
    }
    function So(Ge) {
      if (Xn.call(Ge, "key")) {
        var gt = Object.getOwnPropertyDescriptor(Ge, "key").get;
        if (gt && gt.isReactWarning)
          return !1;
      }
      return Ge.key !== void 0;
    }
    function Jo(Ge, gt) {
      var jt = function() {
        vo || (vo = !0, bt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gt));
      };
      jt.isReactWarning = !0, Object.defineProperty(Ge, "key", { get: jt, configurable: !0 });
    }
    function Po(Ge, gt) {
      var jt = function() {
        Eo || (Eo = !0, bt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gt));
      };
      jt.isReactWarning = !0, Object.defineProperty(Ge, "ref", { get: jt, configurable: !0 });
    }
    function Jt(Ge) {
      if (typeof Ge.ref == "string" && It.current && Ge.__self && It.current.stateNode !== Ge.__self) {
        var gt = jn(It.current.type);
        ra[gt] || (bt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', gt, Ge.ref), ra[gt] = !0);
      }
    }
    var or = function(Ge, gt, jt, Ht, sr, Fr, Or) {
      var Br = { $$typeof: fe, type: Ge, key: gt, ref: jt, props: Or, _owner: Fr };
      return Br._store = {}, Object.defineProperty(Br._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(Br, "_self", { configurable: !1, enumerable: !1, writable: !1, value: Ht }), Object.defineProperty(Br, "_source", { configurable: !1, enumerable: !1, writable: !1, value: sr }), Object.freeze && (Object.freeze(Br.props), Object.freeze(Br)), Br;
    };
    function fr(Ge, gt, jt) {
      var Ht, sr = {}, Fr = null, Or = null, Br = null, Kr = null;
      if (gt != null) {
        uo(gt) && (Or = gt.ref, Jt(gt)), So(gt) && (Rn(gt.key), Fr = "" + gt.key), Br = gt.__self === void 0 ? null : gt.__self, Kr = gt.__source === void 0 ? null : gt.__source;
        for (Ht in gt)
          Xn.call(gt, Ht) && !Ko.hasOwnProperty(Ht) && (sr[Ht] = gt[Ht]);
      }
      var Sn = arguments.length - 2;
      if (Sn === 1)
        sr.children = jt;
      else if (Sn > 1) {
        for (var In = Array(Sn), Un = 0; Un < Sn; Un++)
          In[Un] = arguments[Un + 2];
        Object.freeze && Object.freeze(In), sr.children = In;
      }
      if (Ge && Ge.defaultProps) {
        var Vn = Ge.defaultProps;
        for (Ht in Vn)
          sr[Ht] === void 0 && (sr[Ht] = Vn[Ht]);
      }
      if (Fr || Or) {
        var mo = typeof Ge == "function" ? Ge.displayName || Ge.name || "Unknown" : Ge;
        Fr && Jo(sr, mo), Or && Po(sr, mo);
      }
      return or(Ge, Fr, Or, Br, Kr, It.current, sr);
    }
    function Mr(Ge, gt) {
      var jt = or(Ge.type, gt, Ge.ref, Ge._self, Ge._source, Ge._owner, Ge.props);
      return jt;
    }
    function Wr(Ge, gt, jt) {
      if (Ge == null)
        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + Ge + ".");
      var Ht, sr = et({}, Ge.props), Fr = Ge.key, Or = Ge.ref, Br = Ge._self, Kr = Ge._source, Sn = Ge._owner;
      if (gt != null) {
        uo(gt) && (Or = gt.ref, Sn = It.current), So(gt) && (Rn(gt.key), Fr = "" + gt.key);
        var In;
        Ge.type && Ge.type.defaultProps && (In = Ge.type.defaultProps);
        for (Ht in gt)
          Xn.call(gt, Ht) && !Ko.hasOwnProperty(Ht) && (gt[Ht] === void 0 && In !== void 0 ? sr[Ht] = In[Ht] : sr[Ht] = gt[Ht]);
      }
      var Un = arguments.length - 2;
      if (Un === 1)
        sr.children = jt;
      else if (Un > 1) {
        for (var Vn = Array(Un), mo = 0; mo < Un; mo++)
          Vn[mo] = arguments[mo + 2];
        sr.children = Vn;
      }
      return or(Ge.type, Fr, Or, Br, Kr, Sn, sr);
    }
    function Vr(Ge) {
      return typeof Ge == "object" && Ge !== null && Ge.$$typeof === fe;
    }
    var Zr = ".", on = ":";
    function Lr(Ge) {
      var gt = /[=:]/g, jt = { "=": "=0", ":": "=2" }, Ht = Ge.replace(gt, function(sr) {
        return jt[sr];
      });
      return "$" + Ht;
    }
    var tn = !1, Qn = /\/+/g;
    function Fn(Ge) {
      return Ge.replace(Qn, "$&/");
    }
    function en(Ge, gt) {
      return typeof Ge == "object" && Ge !== null && Ge.key != null ? (Rn(Ge.key), Lr("" + Ge.key)) : gt.toString(36);
    }
    function An(Ge, gt, jt, Ht, sr) {
      var Fr = typeof Ge;
      (Fr === "undefined" || Fr === "boolean") && (Ge = null);
      var Or = !1;
      if (Ge === null)
        Or = !0;
      else
        switch (Fr) {
          case "string":
          case "number":
            Or = !0;
            break;
          case "object":
            switch (Ge.$$typeof) {
              case fe:
              case ye:
                Or = !0;
            }
        }
      if (Or) {
        var Br = Ge, Kr = sr(Br), Sn = Ht === "" ? Zr + en(Br, 0) : Ht;
        if (co(Kr)) {
          var In = "";
          Sn != null && (In = Fn(Sn) + "/"), An(Kr, gt, In, "", function(lf) {
            return lf;
          });
        } else
          Kr != null && (Vr(Kr) && (Kr.key && (!Br || Br.key !== Kr.key) && Rn(Kr.key), Kr = Mr(Kr, jt + (Kr.key && (!Br || Br.key !== Kr.key) ? Fn("" + Kr.key) + "/" : "") + Sn)), gt.push(Kr));
        return 1;
      }
      var Un, Vn, mo = 0, ko = Ht === "" ? Zr : Ht + on;
      if (co(Ge))
        for (var oa = 0; oa < Ge.length; oa++)
          Un = Ge[oa], Vn = ko + en(Un, oa), mo += An(Un, gt, jt, Vn, sr);
      else {
        var fu = pt(Ge);
        if (typeof fu == "function") {
          var mc = Ge;
          fu === mc.entries && (tn || wt("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), tn = !0);
          for (var uf = fu.call(mc), ad, pu = 0; !(ad = uf.next()).done; )
            Un = ad.value, Vn = ko + en(Un, pu++), mo += An(Un, gt, jt, Vn, sr);
        } else if (Fr === "object") {
          var Ol = String(Ge);
          throw new Error("Objects are not valid as a React child (found: " + (Ol === "[object Object]" ? "object with keys {" + Object.keys(Ge).join(", ") + "}" : Ol) + "). If you meant to render a collection of children, use an array instead.");
        }
      }
      return mo;
    }
    function zn(Ge, gt, jt) {
      if (Ge == null)
        return Ge;
      var Ht = [], sr = 0;
      return An(Ge, Ht, "", "", function(Fr) {
        return gt.call(jt, Fr, sr++);
      }), Ht;
    }
    function Oo(Ge) {
      var gt = 0;
      return zn(Ge, function() {
        gt++;
      }), gt;
    }
    function ii(Ge, gt, jt) {
      zn(Ge, function() {
        gt.apply(this, arguments);
      }, jt);
    }
    function No(Ge) {
      return zn(Ge, function(gt) {
        return gt;
      }) || [];
    }
    function Ao(Ge) {
      if (!Vr(Ge))
        throw new Error("React.Children.only expected to receive a single React element child.");
      return Ge;
    }
    function Da(Ge) {
      var gt = { $$typeof: $e, _currentValue: Ge, _currentValue2: Ge, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      gt.Provider = { $$typeof: Oe, _context: gt };
      var jt = !1, Ht = !1, sr = !1;
      {
        var Fr = { $$typeof: $e, _context: gt };
        Object.defineProperties(Fr, { Provider: { get: function() {
          return Ht || (Ht = !0, bt("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), gt.Provider;
        }, set: function(Or) {
          gt.Provider = Or;
        } }, _currentValue: { get: function() {
          return gt._currentValue;
        }, set: function(Or) {
          gt._currentValue = Or;
        } }, _currentValue2: { get: function() {
          return gt._currentValue2;
        }, set: function(Or) {
          gt._currentValue2 = Or;
        } }, _threadCount: { get: function() {
          return gt._threadCount;
        }, set: function(Or) {
          gt._threadCount = Or;
        } }, Consumer: { get: function() {
          return jt || (jt = !0, bt("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), gt.Consumer;
        } }, displayName: { get: function() {
          return gt.displayName;
        }, set: function(Or) {
          sr || (wt("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Or), sr = !0);
        } } }), gt.Consumer = Fr;
      }
      return gt._currentRenderer = null, gt._currentRenderer2 = null, gt;
    }
    var po = -1, _o = 0, Ba = 1, bo = 2;
    function $n(Ge) {
      if (Ge._status === po) {
        var gt = Ge._result, jt = gt();
        if (jt.then(function(Fr) {
          if (Ge._status === _o || Ge._status === po) {
            var Or = Ge;
            Or._status = Ba, Or._result = Fr;
          }
        }, function(Fr) {
          if (Ge._status === _o || Ge._status === po) {
            var Or = Ge;
            Or._status = bo, Or._result = Fr;
          }
        }), Ge._status === po) {
          var Ht = Ge;
          Ht._status = _o, Ht._result = jt;
        }
      }
      if (Ge._status === Ba) {
        var sr = Ge._result;
        return sr === void 0 && bt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, sr), "default" in sr || bt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, sr), sr.default;
      } else
        throw Ge._result;
    }
    function Bo(Ge) {
      var gt = { _status: po, _result: Ge }, jt = { $$typeof: ze, _payload: gt, _init: $n };
      {
        var Ht, sr;
        Object.defineProperties(jt, { defaultProps: { configurable: !0, get: function() {
          return Ht;
        }, set: function(Fr) {
          bt("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ht = Fr, Object.defineProperty(jt, "defaultProps", { enumerable: !0 });
        } }, propTypes: { configurable: !0, get: function() {
          return sr;
        }, set: function(Fr) {
          bt("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), sr = Fr, Object.defineProperty(jt, "propTypes", { enumerable: !0 });
        } } });
      }
      return jt;
    }
    function ho(Ge) {
      Ge != null && Ge.$$typeof === Be ? bt("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof Ge != "function" ? bt("forwardRef requires a render function but was given %s.", Ge === null ? "null" : typeof Ge) : Ge.length !== 0 && Ge.length !== 2 && bt("forwardRef render functions accept exactly two parameters: props and ref. %s", Ge.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), Ge != null && (Ge.defaultProps != null || Ge.propTypes != null) && bt("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
      var gt = { $$typeof: Me, render: Ge };
      {
        var jt;
        Object.defineProperty(gt, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return jt;
        }, set: function(Ht) {
          jt = Ht, !Ge.name && !Ge.displayName && (Ge.displayName = Ht);
        } });
      }
      return gt;
    }
    var To;
    To = Symbol.for("react.module.reference");
    function Qt(Ge) {
      return !!(typeof Ge == "string" || typeof Ge == "function" || Ge === ve || Ge === xe || Qe || Ge === _e || Ge === Re || Ge === je || Ot || Ge === He || tr || er || hr || typeof Ge == "object" && Ge !== null && (Ge.$$typeof === ze || Ge.$$typeof === Be || Ge.$$typeof === Oe || Ge.$$typeof === $e || Ge.$$typeof === Me || Ge.$$typeof === To || Ge.getModuleId !== void 0));
    }
    function kr(Ge, gt) {
      Qt(Ge) || bt("memo: The first argument must be a component. Instead received: %s", Ge === null ? "null" : typeof Ge);
      var jt = { $$typeof: Be, type: Ge, compare: gt === void 0 ? null : gt };
      {
        var Ht;
        Object.defineProperty(jt, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return Ht;
        }, set: function(sr) {
          Ht = sr, !Ge.name && !Ge.displayName && (Ge.displayName = sr);
        } });
      }
      return jt;
    }
    function Tr() {
      var Ge = dt.current;
      return Ge === null && bt(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), Ge;
    }
    function vn(Ge) {
      var gt = Tr();
      if (Ge._context !== void 0) {
        var jt = Ge._context;
        jt.Consumer === Ge ? bt("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : jt.Provider === Ge && bt("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
      }
      return gt.useContext(Ge);
    }
    function mn(Ge) {
      var gt = Tr();
      return gt.useState(Ge);
    }
    function En(Ge, gt, jt) {
      var Ht = Tr();
      return Ht.useReducer(Ge, gt, jt);
    }
    function Zn(Ge) {
      var gt = Tr();
      return gt.useRef(Ge);
    }
    function xn(Ge, gt) {
      var jt = Tr();
      return jt.useEffect(Ge, gt);
    }
    function na(Ge, gt) {
      var jt = Tr();
      return jt.useInsertionEffect(Ge, gt);
    }
    function Wo(Ge, gt) {
      var jt = Tr();
      return jt.useLayoutEffect(Ge, gt);
    }
    function Zo(Ge, gt) {
      var jt = Tr();
      return jt.useCallback(Ge, gt);
    }
    function va(Ge, gt) {
      var jt = Tr();
      return jt.useMemo(Ge, gt);
    }
    function yi(Ge, gt, jt) {
      var Ht = Tr();
      return Ht.useImperativeHandle(Ge, gt, jt);
    }
    function _s(Ge, gt) {
      {
        var jt = Tr();
        return jt.useDebugValue(Ge, gt);
      }
    }
    function xo() {
      var Ge = Tr();
      return Ge.useTransition();
    }
    function qu(Ge) {
      var gt = Tr();
      return gt.useDeferredValue(Ge);
    }
    function si() {
      var Ge = Tr();
      return Ge.useId();
    }
    function oo(Ge, gt, jt) {
      var Ht = Tr();
      return Ht.useSyncExternalStore(Ge, gt, jt);
    }
    var da = 0, xs, as, Ci, Ca, Es, ka, rl;
    function nl() {
    }
    nl.__reactDisabledLog = !0;
    function od() {
      {
        if (da === 0) {
          xs = console.log, as = console.info, Ci = console.warn, Ca = console.error, Es = console.group, ka = console.groupCollapsed, rl = console.groupEnd;
          var Ge = { configurable: !0, enumerable: !0, value: nl, writable: !0 };
          Object.defineProperties(console, { info: Ge, log: Ge, warn: Ge, error: Ge, group: Ge, groupCollapsed: Ge, groupEnd: Ge });
        }
        da++;
      }
    }
    function ol() {
      {
        if (da--, da === 0) {
          var Ge = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: et({}, Ge, { value: xs }), info: et({}, Ge, { value: as }), warn: et({}, Ge, { value: Ci }), error: et({}, Ge, { value: Ca }), group: et({}, Ge, { value: Es }), groupCollapsed: et({}, Ge, { value: ka }), groupEnd: et({}, Ge, { value: rl }) });
        }
        da < 0 && bt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Yi = at.ReactCurrentDispatcher, $i;
    function $a(Ge, gt, jt) {
      {
        if ($i === void 0)
          try {
            throw Error();
          } catch (sr) {
            var Ht = sr.stack.trim().match(/\n( *(at )?)/);
            $i = Ht && Ht[1] || "";
          }
        return `
` + $i + Ge;
      }
    }
    var Us = !1, ts;
    {
      var xl = typeof WeakMap == "function" ? WeakMap : Map;
      ts = new xl();
    }
    function lu(Ge, gt) {
      if (!Ge || Us)
        return "";
      {
        var jt = ts.get(Ge);
        if (jt !== void 0)
          return jt;
      }
      var Ht;
      Us = !0;
      var sr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Fr;
      Fr = Yi.current, Yi.current = null, od();
      try {
        if (gt) {
          var Or = function() {
            throw Error();
          };
          if (Object.defineProperty(Or.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Or, []);
            } catch (ko) {
              Ht = ko;
            }
            Reflect.construct(Ge, [], Or);
          } else {
            try {
              Or.call();
            } catch (ko) {
              Ht = ko;
            }
            Ge.call(Or.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ko) {
            Ht = ko;
          }
          Ge();
        }
      } catch (ko) {
        if (ko && Ht && typeof ko.stack == "string") {
          for (var Br = ko.stack.split(`
`), Kr = Ht.stack.split(`
`), Sn = Br.length - 1, In = Kr.length - 1; Sn >= 1 && In >= 0 && Br[Sn] !== Kr[In]; )
            In--;
          for (; Sn >= 1 && In >= 0; Sn--, In--)
            if (Br[Sn] !== Kr[In]) {
              if (Sn !== 1 || In !== 1)
                do
                  if (Sn--, In--, In < 0 || Br[Sn] !== Kr[In]) {
                    var Un = `
` + Br[Sn].replace(" at new ", " at ");
                    return Ge.displayName && Un.includes("<anonymous>") && (Un = Un.replace("<anonymous>", Ge.displayName)), typeof Ge == "function" && ts.set(Ge, Un), Un;
                  }
                while (Sn >= 1 && In >= 0);
              break;
            }
        }
      } finally {
        Us = !1, Yi.current = Fr, ol(), Error.prepareStackTrace = sr;
      }
      var Vn = Ge ? Ge.displayName || Ge.name : "", mo = Vn ? $a(Vn) : "";
      return typeof Ge == "function" && ts.set(Ge, mo), mo;
    }
    function El(Ge, gt, jt) {
      return lu(Ge, !1);
    }
    function Vs(Ge) {
      var gt = Ge.prototype;
      return !!(gt && gt.isReactComponent);
    }
    function Hs(Ge, gt, jt) {
      if (Ge == null)
        return "";
      if (typeof Ge == "function")
        return lu(Ge, Vs(Ge));
      if (typeof Ge == "string")
        return $a(Ge);
      switch (Ge) {
        case Re:
          return $a("Suspense");
        case je:
          return $a("SuspenseList");
      }
      if (typeof Ge == "object")
        switch (Ge.$$typeof) {
          case Me:
            return El(Ge.render);
          case Be:
            return Hs(Ge.type, gt, jt);
          case ze: {
            var Ht = Ge, sr = Ht._payload, Fr = Ht._init;
            try {
              return Hs(Fr(sr), gt, jt);
            } catch {
            }
          }
        }
      return "";
    }
    var qs = {}, jo = at.ReactDebugCurrentFrame;
    function is(Ge) {
      if (Ge) {
        var gt = Ge._owner, jt = Hs(Ge.type, Ge._source, gt ? gt.type : null);
        jo.setExtraStackFrame(jt);
      } else
        jo.setExtraStackFrame(null);
    }
    function hc(Ge, gt, jt, Ht, sr) {
      {
        var Fr = Function.call.bind(Xn);
        for (var Or in Ge)
          if (Fr(Ge, Or)) {
            var Br = void 0;
            try {
              if (typeof Ge[Or] != "function") {
                var Kr = Error((Ht || "React class") + ": " + jt + " type `" + Or + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ge[Or] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Kr.name = "Invariant Violation", Kr;
              }
              Br = Ge[Or](gt, Or, Ht, jt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Sn) {
              Br = Sn;
            }
            Br && !(Br instanceof Error) && (is(sr), bt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ht || "React class", jt, Or, typeof Br), is(null)), Br instanceof Error && !(Br.message in qs) && (qs[Br.message] = !0, is(sr), bt("Failed %s type: %s", jt, Br.message), is(null));
          }
      }
    }
    function qa(Ge) {
      if (Ge) {
        var gt = Ge._owner, jt = Hs(Ge.type, Ge._source, gt ? gt.type : null);
        Zt(jt);
      } else
        Zt(null);
    }
    var Fo;
    Fo = !1;
    function al() {
      if (It.current) {
        var Ge = jn(It.current.type);
        if (Ge)
          return `

Check the render method of \`` + Ge + "`.";
      }
      return "";
    }
    function Sl(Ge) {
      if (Ge !== void 0) {
        var gt = Ge.fileName.replace(/^.*[\\\/]/, ""), jt = Ge.lineNumber;
        return `

Check your code at ` + gt + ":" + jt + ".";
      }
      return "";
    }
    function Gn(Ge) {
      return Ge != null ? Sl(Ge.__source) : "";
    }
    var Ws = {};
    function fa(Ge) {
      var gt = al();
      if (!gt) {
        var jt = typeof Ge == "string" ? Ge : Ge.displayName || Ge.name;
        jt && (gt = `

Check the top-level render call using <` + jt + ">.");
      }
      return gt;
    }
    function Ka(Ge, gt) {
      if (!(!Ge._store || Ge._store.validated || Ge.key != null)) {
        Ge._store.validated = !0;
        var jt = fa(gt);
        if (!Ws[jt]) {
          Ws[jt] = !0;
          var Ht = "";
          Ge && Ge._owner && Ge._owner !== It.current && (Ht = " It was passed a child from " + jn(Ge._owner.type) + "."), qa(Ge), bt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', jt, Ht), qa(null);
        }
      }
    }
    function Xa(Ge, gt) {
      if (typeof Ge == "object") {
        if (co(Ge))
          for (var jt = 0; jt < Ge.length; jt++) {
            var Ht = Ge[jt];
            Vr(Ht) && Ka(Ht, gt);
          }
        else if (Vr(Ge))
          Ge._store && (Ge._store.validated = !0);
        else if (Ge) {
          var sr = pt(Ge);
          if (typeof sr == "function" && sr !== Ge.entries)
            for (var Fr = sr.call(Ge), Or; !(Or = Fr.next()).done; )
              Vr(Or.value) && Ka(Or.value, gt);
        }
      }
    }
    function Zs(Ge) {
      {
        var gt = Ge.type;
        if (gt == null || typeof gt == "string")
          return;
        var jt;
        if (typeof gt == "function")
          jt = gt.propTypes;
        else if (typeof gt == "object" && (gt.$$typeof === Me || gt.$$typeof === Be))
          jt = gt.propTypes;
        else
          return;
        if (jt) {
          var Ht = jn(gt);
          hc(jt, Ge.props, "prop", Ht, Ge);
        } else if (gt.PropTypes !== void 0 && !Fo) {
          Fo = !0;
          var sr = jn(gt);
          bt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", sr || "Unknown");
        }
        typeof gt.getDefaultProps == "function" && !gt.getDefaultProps.isReactClassApproved && bt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function wa(Ge) {
      {
        for (var gt = Object.keys(Ge.props), jt = 0; jt < gt.length; jt++) {
          var Ht = gt[jt];
          if (Ht !== "children" && Ht !== "key") {
            qa(Ge), bt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ht), qa(null);
            break;
          }
        }
        Ge.ref !== null && (qa(Ge), bt("Invalid attribute `ref` supplied to `React.Fragment`."), qa(null));
      }
    }
    function Lo(Ge, gt, jt) {
      var Ht = Qt(Ge);
      if (!Ht) {
        var sr = "";
        (Ge === void 0 || typeof Ge == "object" && Ge !== null && Object.keys(Ge).length === 0) && (sr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var Fr = Gn(gt);
        Fr ? sr += Fr : sr += al();
        var Or;
        Ge === null ? Or = "null" : co(Ge) ? Or = "array" : Ge !== void 0 && Ge.$$typeof === fe ? (Or = "<" + (jn(Ge.type) || "Unknown") + " />", sr = " Did you accidentally export a JSX literal instead of a component?") : Or = typeof Ge, bt("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Or, sr);
      }
      var Br = fr.apply(this, arguments);
      if (Br == null)
        return Br;
      if (Ht)
        for (var Kr = 2; Kr < arguments.length; Kr++)
          Xa(arguments[Kr], Ge);
      return Ge === ve ? wa(Br) : Zs(Br), Br;
    }
    var Pl = !1;
    function Ii(Ge) {
      var gt = Lo.bind(null, Ge);
      return gt.type = Ge, Pl || (Pl = !0, wt("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(gt, "type", { enumerable: !1, get: function() {
        return wt("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: Ge }), Ge;
      } }), gt;
    }
    function ja(Ge, gt, jt) {
      for (var Ht = Wr.apply(this, arguments), sr = 2; sr < arguments.length; sr++)
        Xa(arguments[sr], Ht.type);
      return Zs(Ht), Ht;
    }
    function Ss(Ge, gt) {
      var jt = yt.transition;
      yt.transition = {};
      var Ht = yt.transition;
      yt.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        Ge();
      } finally {
        if (yt.transition = jt, jt === null && Ht._updatedFibers) {
          var sr = Ht._updatedFibers.size;
          sr > 10 && wt("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ht._updatedFibers.clear();
        }
      }
    }
    var il = !1, vi = null;
    function Tl(Ge) {
      if (vi === null)
        try {
          var gt = ("require" + Math.random()).slice(0, 7), jt = oe && oe[gt];
          vi = jt.call(oe, "timers").setImmediate;
        } catch {
          vi = function(Ht) {
            il === !1 && (il = !0, typeof MessageChannel > "u" && bt("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var sr = new MessageChannel();
            sr.port1.onmessage = Ht, sr.port2.postMessage(void 0);
          };
        }
      return vi(Ge);
    }
    var bi = 0, Gs = !1;
    function cu(Ge) {
      {
        var gt = bi;
        bi++, Ct.current === null && (Ct.current = []);
        var jt = Ct.isBatchingLegacy, Ht;
        try {
          if (Ct.isBatchingLegacy = !0, Ht = Ge(), !jt && Ct.didScheduleLegacyUpdate) {
            var sr = Ct.current;
            sr !== null && (Ct.didScheduleLegacyUpdate = !1, Ps(sr));
          }
        } catch (Vn) {
          throw gi(gt), Vn;
        } finally {
          Ct.isBatchingLegacy = jt;
        }
        if (Ht !== null && typeof Ht == "object" && typeof Ht.then == "function") {
          var Fr = Ht, Or = !1, Br = { then: function(Vn, mo) {
            Or = !0, Fr.then(function(ko) {
              gi(gt), bi === 0 ? Mi(ko, Vn, mo) : Vn(ko);
            }, function(ko) {
              gi(gt), mo(ko);
            });
          } };
          return !Gs && typeof Promise < "u" && Promise.resolve().then(function() {
          }).then(function() {
            Or || (Gs = !0, bt("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
          }), Br;
        } else {
          var Kr = Ht;
          if (gi(gt), bi === 0) {
            var Sn = Ct.current;
            Sn !== null && (Ps(Sn), Ct.current = null);
            var In = { then: function(Vn, mo) {
              Ct.current === null ? (Ct.current = [], Mi(Kr, Vn, mo)) : Vn(Kr);
            } };
            return In;
          } else {
            var Un = { then: function(Vn, mo) {
              Vn(Kr);
            } };
            return Un;
          }
        }
      }
    }
    function gi(Ge) {
      Ge !== bi - 1 && bt("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), bi = Ge;
    }
    function Mi(Ge, gt, jt) {
      {
        var Ht = Ct.current;
        if (Ht !== null)
          try {
            Ps(Ht), Tl(function() {
              Ht.length === 0 ? (Ct.current = null, gt(Ge)) : Mi(Ge, gt, jt);
            });
          } catch (sr) {
            jt(sr);
          }
        else
          gt(Ge);
      }
    }
    var du = !1;
    function Ps(Ge) {
      if (!du) {
        du = !0;
        var gt = 0;
        try {
          for (; gt < Ge.length; gt++) {
            var jt = Ge[gt];
            do
              jt = jt(!0);
            while (jt !== null);
          }
          Ge.length = 0;
        } catch (Ht) {
          throw Ge = Ge.slice(gt + 1), Ht;
        } finally {
          du = !1;
        }
      }
    }
    var sl = Lo, Wu = ja, ul = Ii, kl = { map: zn, forEach: ii, count: Oo, toArray: No, only: Ao };
    ne.Children = kl, ne.Component = xr, ne.Fragment = ve, ne.Profiler = xe, ne.PureComponent = jr, ne.StrictMode = _e, ne.Suspense = Re, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = at, ne.cloneElement = Wu, ne.createContext = Da, ne.createElement = sl, ne.createFactory = ul, ne.createRef = so, ne.forwardRef = ho, ne.isValidElement = Vr, ne.lazy = Bo, ne.memo = kr, ne.startTransition = Ss, ne.unstable_act = cu, ne.useCallback = Zo, ne.useContext = vn, ne.useDebugValue = _s, ne.useDeferredValue = qu, ne.useEffect = xn, ne.useId = si, ne.useImperativeHandle = yi, ne.useInsertionEffect = na, ne.useLayoutEffect = Wo, ne.useMemo = va, ne.useReducer = En, ne.useRef = Zn, ne.useState = mn, ne.useSyncExternalStore = oo, ne.useTransition = xo, ne.version = ae, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), ir = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Gj() : oe.exports = Qj();
}), Xj = M((ne) => {
  var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.fragment"), ye = Object.prototype.hasOwnProperty, ve = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, _e = { key: !0, ref: !0, __self: !0, __source: !0 };
  function xe(Oe, $e, Me) {
    var Re, je = {}, Be = null, ze = null;
    Me !== void 0 && (Be = "" + Me), $e.key !== void 0 && (Be = "" + $e.key), $e.ref !== void 0 && (ze = $e.ref);
    for (Re in $e)
      ye.call($e, Re) && !_e.hasOwnProperty(Re) && (je[Re] = $e[Re]);
    if (Oe && Oe.defaultProps)
      for (Re in $e = Oe.defaultProps, $e)
        je[Re] === void 0 && (je[Re] = $e[Re]);
    return { $$typeof: ae, type: Oe, key: Be, ref: ze, props: je, _owner: ve.current };
  }
  ne.Fragment = fe, ne.jsx = xe, ne.jsxs = xe;
}), Jj = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.portal"), ye = Symbol.for("react.fragment"), ve = Symbol.for("react.strict_mode"), _e = Symbol.for("react.profiler"), xe = Symbol.for("react.provider"), Oe = Symbol.for("react.context"), $e = Symbol.for("react.forward_ref"), Me = Symbol.for("react.suspense"), Re = Symbol.for("react.suspense_list"), je = Symbol.for("react.memo"), Be = Symbol.for("react.lazy"), ze = Symbol.for("react.offscreen"), He = Symbol.iterator, qe = "@@iterator";
    function Ye(Qt) {
      if (Qt === null || typeof Qt != "object")
        return null;
      var kr = He && Qt[He] || Qt[qe];
      return typeof kr == "function" ? kr : null;
    }
    var pt = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function dt(Qt) {
      {
        for (var kr = arguments.length, Tr = new Array(kr > 1 ? kr - 1 : 0), vn = 1; vn < kr; vn++)
          Tr[vn - 1] = arguments[vn];
        yt("error", Qt, Tr);
      }
    }
    function yt(Qt, kr, Tr) {
      {
        var vn = pt.ReactDebugCurrentFrame, mn = vn.getStackAddendum();
        mn !== "" && (kr += "%s", Tr = Tr.concat([mn]));
        var En = Tr.map(function(Zn) {
          return String(Zn);
        });
        En.unshift("Warning: " + kr), Function.prototype.apply.call(console[Qt], console, En);
      }
    }
    var Ct = !1, It = !1, Vt = !1, Ut = !1, Zt = !1, tr;
    tr = Symbol.for("react.module.reference");
    function er(Qt) {
      return !!(typeof Qt == "string" || typeof Qt == "function" || Qt === ye || Qt === _e || Zt || Qt === ve || Qt === Me || Qt === Re || Ut || Qt === ze || Ct || It || Vt || typeof Qt == "object" && Qt !== null && (Qt.$$typeof === Be || Qt.$$typeof === je || Qt.$$typeof === xe || Qt.$$typeof === Oe || Qt.$$typeof === $e || Qt.$$typeof === tr || Qt.getModuleId !== void 0));
    }
    function hr(Qt, kr, Tr) {
      var vn = Qt.displayName;
      if (vn)
        return vn;
      var mn = kr.displayName || kr.name || "";
      return mn !== "" ? Tr + "(" + mn + ")" : Tr;
    }
    function Ot(Qt) {
      return Qt.displayName || "Context";
    }
    function Qe(Qt) {
      if (Qt == null)
        return null;
      if (typeof Qt.tag == "number" && dt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Qt == "function")
        return Qt.displayName || Qt.name || null;
      if (typeof Qt == "string")
        return Qt;
      switch (Qt) {
        case ye:
          return "Fragment";
        case fe:
          return "Portal";
        case _e:
          return "Profiler";
        case ve:
          return "StrictMode";
        case Me:
          return "Suspense";
        case Re:
          return "SuspenseList";
      }
      if (typeof Qt == "object")
        switch (Qt.$$typeof) {
          case Oe:
            var kr = Qt;
            return Ot(kr) + ".Consumer";
          case xe:
            var Tr = Qt;
            return Ot(Tr._context) + ".Provider";
          case $e:
            return hr(Qt, Qt.render, "ForwardRef");
          case je:
            var vn = Qt.displayName || null;
            return vn !== null ? vn : Qe(Qt.type) || "Memo";
          case Be: {
            var mn = Qt, En = mn._payload, Zn = mn._init;
            try {
              return Qe(Zn(En));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var at = Object.assign, wt = 0, bt, At, Ft, Gt, ot, et, Rt;
    function xr() {
    }
    xr.__reactDisabledLog = !0;
    function Xt() {
      {
        if (wt === 0) {
          bt = console.log, At = console.info, Ft = console.warn, Gt = console.error, ot = console.group, et = console.groupCollapsed, Rt = console.groupEnd;
          var Qt = { configurable: !0, enumerable: !0, value: xr, writable: !0 };
          Object.defineProperties(console, { info: Qt, log: Qt, warn: Qt, error: Qt, group: Qt, groupCollapsed: Qt, groupEnd: Qt });
        }
        wt++;
      }
    }
    function dr() {
      {
        if (wt--, wt === 0) {
          var Qt = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: at({}, Qt, { value: bt }), info: at({}, Qt, { value: At }), warn: at({}, Qt, { value: Ft }), error: at({}, Qt, { value: Gt }), group: at({}, Qt, { value: ot }), groupCollapsed: at({}, Qt, { value: et }), groupEnd: at({}, Qt, { value: Rt }) });
        }
        wt < 0 && dt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Nr = pt.ReactCurrentDispatcher, Dr;
    function jr(Qt, kr, Tr) {
      {
        if (Dr === void 0)
          try {
            throw Error();
          } catch (mn) {
            var vn = mn.stack.trim().match(/\n( *(at )?)/);
            Dr = vn && vn[1] || "";
          }
        return `
` + Dr + Qt;
      }
    }
    var un = !1, so;
    {
      var Pn = typeof WeakMap == "function" ? WeakMap : Map;
      so = new Pn();
    }
    function co(Qt, kr) {
      if (!Qt || un)
        return "";
      {
        var Tr = so.get(Qt);
        if (Tr !== void 0)
          return Tr;
      }
      var vn;
      un = !0;
      var mn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var En;
      En = Nr.current, Nr.current = null, Xt();
      try {
        if (kr) {
          var Zn = function() {
            throw Error();
          };
          if (Object.defineProperty(Zn.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Zn, []);
            } catch (xo) {
              vn = xo;
            }
            Reflect.construct(Qt, [], Zn);
          } else {
            try {
              Zn.call();
            } catch (xo) {
              vn = xo;
            }
            Qt.call(Zn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (xo) {
            vn = xo;
          }
          Qt();
        }
      } catch (xo) {
        if (xo && vn && typeof xo.stack == "string") {
          for (var xn = xo.stack.split(`
`), na = vn.stack.split(`
`), Wo = xn.length - 1, Zo = na.length - 1; Wo >= 1 && Zo >= 0 && xn[Wo] !== na[Zo]; )
            Zo--;
          for (; Wo >= 1 && Zo >= 0; Wo--, Zo--)
            if (xn[Wo] !== na[Zo]) {
              if (Wo !== 1 || Zo !== 1)
                do
                  if (Wo--, Zo--, Zo < 0 || xn[Wo] !== na[Zo]) {
                    var va = `
` + xn[Wo].replace(" at new ", " at ");
                    return Qt.displayName && va.includes("<anonymous>") && (va = va.replace("<anonymous>", Qt.displayName)), typeof Qt == "function" && so.set(Qt, va), va;
                  }
                while (Wo >= 1 && Zo >= 0);
              break;
            }
        }
      } finally {
        un = !1, Nr.current = En, dr(), Error.prepareStackTrace = mn;
      }
      var yi = Qt ? Qt.displayName || Qt.name : "", _s = yi ? jr(yi) : "";
      return typeof Qt == "function" && so.set(Qt, _s), _s;
    }
    function kn(Qt, kr, Tr) {
      return co(Qt, !1);
    }
    function Yn(Qt) {
      var kr = Qt.prototype;
      return !!(kr && kr.isReactComponent);
    }
    function Ho(Qt, kr, Tr) {
      if (Qt == null)
        return "";
      if (typeof Qt == "function")
        return co(Qt, Yn(Qt));
      if (typeof Qt == "string")
        return jr(Qt);
      switch (Qt) {
        case Me:
          return jr("Suspense");
        case Re:
          return jr("SuspenseList");
      }
      if (typeof Qt == "object")
        switch (Qt.$$typeof) {
          case $e:
            return kn(Qt.render);
          case je:
            return Ho(Qt.type, kr, Tr);
          case Be: {
            var vn = Qt, mn = vn._payload, En = vn._init;
            try {
              return Ho(En(mn), kr, Tr);
            } catch {
            }
          }
        }
      return "";
    }
    var Rn = Object.prototype.hasOwnProperty, fo = {}, pa = pt.ReactDebugCurrentFrame;
    function jn(Qt) {
      if (Qt) {
        var kr = Qt._owner, Tr = Ho(Qt.type, Qt._source, kr ? kr.type : null);
        pa.setExtraStackFrame(Tr);
      } else
        pa.setExtraStackFrame(null);
    }
    function Xn(Qt, kr, Tr, vn, mn) {
      {
        var En = Function.call.bind(Rn);
        for (var Zn in Qt)
          if (En(Qt, Zn)) {
            var xn = void 0;
            try {
              if (typeof Qt[Zn] != "function") {
                var na = Error((vn || "React class") + ": " + Tr + " type `" + Zn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Qt[Zn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw na.name = "Invariant Violation", na;
              }
              xn = Qt[Zn](kr, Zn, vn, Tr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Wo) {
              xn = Wo;
            }
            xn && !(xn instanceof Error) && (jn(mn), dt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", vn || "React class", Tr, Zn, typeof xn), jn(null)), xn instanceof Error && !(xn.message in fo) && (fo[xn.message] = !0, jn(mn), dt("Failed %s type: %s", Tr, xn.message), jn(null));
          }
      }
    }
    var Ko = Array.isArray;
    function vo(Qt) {
      return Ko(Qt);
    }
    function Eo(Qt) {
      {
        var kr = typeof Symbol == "function" && Symbol.toStringTag, Tr = kr && Qt[Symbol.toStringTag] || Qt.constructor.name || "Object";
        return Tr;
      }
    }
    function ra(Qt) {
      try {
        return uo(Qt), !1;
      } catch {
        return !0;
      }
    }
    function uo(Qt) {
      return "" + Qt;
    }
    function So(Qt) {
      if (ra(Qt))
        return dt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Eo(Qt)), uo(Qt);
    }
    var Jo = pt.ReactCurrentOwner, Po = { key: !0, ref: !0, __self: !0, __source: !0 }, Jt, or, fr;
    fr = {};
    function Mr(Qt) {
      if (Rn.call(Qt, "ref")) {
        var kr = Object.getOwnPropertyDescriptor(Qt, "ref").get;
        if (kr && kr.isReactWarning)
          return !1;
      }
      return Qt.ref !== void 0;
    }
    function Wr(Qt) {
      if (Rn.call(Qt, "key")) {
        var kr = Object.getOwnPropertyDescriptor(Qt, "key").get;
        if (kr && kr.isReactWarning)
          return !1;
      }
      return Qt.key !== void 0;
    }
    function Vr(Qt, kr) {
      if (typeof Qt.ref == "string" && Jo.current && kr && Jo.current.stateNode !== kr) {
        var Tr = Qe(Jo.current.type);
        fr[Tr] || (dt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Qe(Jo.current.type), Qt.ref), fr[Tr] = !0);
      }
    }
    function Zr(Qt, kr) {
      {
        var Tr = function() {
          Jt || (Jt = !0, dt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", kr));
        };
        Tr.isReactWarning = !0, Object.defineProperty(Qt, "key", { get: Tr, configurable: !0 });
      }
    }
    function on(Qt, kr) {
      {
        var Tr = function() {
          or || (or = !0, dt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", kr));
        };
        Tr.isReactWarning = !0, Object.defineProperty(Qt, "ref", { get: Tr, configurable: !0 });
      }
    }
    var Lr = function(Qt, kr, Tr, vn, mn, En, Zn) {
      var xn = { $$typeof: ae, type: Qt, key: kr, ref: Tr, props: Zn, _owner: En };
      return xn._store = {}, Object.defineProperty(xn._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(xn, "_self", { configurable: !1, enumerable: !1, writable: !1, value: vn }), Object.defineProperty(xn, "_source", { configurable: !1, enumerable: !1, writable: !1, value: mn }), Object.freeze && (Object.freeze(xn.props), Object.freeze(xn)), xn;
    };
    function tn(Qt, kr, Tr, vn, mn) {
      {
        var En, Zn = {}, xn = null, na = null;
        Tr !== void 0 && (So(Tr), xn = "" + Tr), Wr(kr) && (So(kr.key), xn = "" + kr.key), Mr(kr) && (na = kr.ref, Vr(kr, mn));
        for (En in kr)
          Rn.call(kr, En) && !Po.hasOwnProperty(En) && (Zn[En] = kr[En]);
        if (Qt && Qt.defaultProps) {
          var Wo = Qt.defaultProps;
          for (En in Wo)
            Zn[En] === void 0 && (Zn[En] = Wo[En]);
        }
        if (xn || na) {
          var Zo = typeof Qt == "function" ? Qt.displayName || Qt.name || "Unknown" : Qt;
          xn && Zr(Zn, Zo), na && on(Zn, Zo);
        }
        return Lr(Qt, xn, na, mn, vn, Jo.current, Zn);
      }
    }
    var Qn = pt.ReactCurrentOwner, Fn = pt.ReactDebugCurrentFrame;
    function en(Qt) {
      if (Qt) {
        var kr = Qt._owner, Tr = Ho(Qt.type, Qt._source, kr ? kr.type : null);
        Fn.setExtraStackFrame(Tr);
      } else
        Fn.setExtraStackFrame(null);
    }
    var An;
    An = !1;
    function zn(Qt) {
      return typeof Qt == "object" && Qt !== null && Qt.$$typeof === ae;
    }
    function Oo() {
      {
        if (Qn.current) {
          var Qt = Qe(Qn.current.type);
          if (Qt)
            return `

Check the render method of \`` + Qt + "`.";
        }
        return "";
      }
    }
    function ii(Qt) {
      {
        if (Qt !== void 0) {
          var kr = Qt.fileName.replace(/^.*[\\\/]/, ""), Tr = Qt.lineNumber;
          return `

Check your code at ` + kr + ":" + Tr + ".";
        }
        return "";
      }
    }
    var No = {};
    function Ao(Qt) {
      {
        var kr = Oo();
        if (!kr) {
          var Tr = typeof Qt == "string" ? Qt : Qt.displayName || Qt.name;
          Tr && (kr = `

Check the top-level render call using <` + Tr + ">.");
        }
        return kr;
      }
    }
    function Da(Qt, kr) {
      {
        if (!Qt._store || Qt._store.validated || Qt.key != null)
          return;
        Qt._store.validated = !0;
        var Tr = Ao(kr);
        if (No[Tr])
          return;
        No[Tr] = !0;
        var vn = "";
        Qt && Qt._owner && Qt._owner !== Qn.current && (vn = " It was passed a child from " + Qe(Qt._owner.type) + "."), en(Qt), dt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Tr, vn), en(null);
      }
    }
    function po(Qt, kr) {
      {
        if (typeof Qt != "object")
          return;
        if (vo(Qt))
          for (var Tr = 0; Tr < Qt.length; Tr++) {
            var vn = Qt[Tr];
            zn(vn) && Da(vn, kr);
          }
        else if (zn(Qt))
          Qt._store && (Qt._store.validated = !0);
        else if (Qt) {
          var mn = Ye(Qt);
          if (typeof mn == "function" && mn !== Qt.entries)
            for (var En = mn.call(Qt), Zn; !(Zn = En.next()).done; )
              zn(Zn.value) && Da(Zn.value, kr);
        }
      }
    }
    function _o(Qt) {
      {
        var kr = Qt.type;
        if (kr == null || typeof kr == "string")
          return;
        var Tr;
        if (typeof kr == "function")
          Tr = kr.propTypes;
        else if (typeof kr == "object" && (kr.$$typeof === $e || kr.$$typeof === je))
          Tr = kr.propTypes;
        else
          return;
        if (Tr) {
          var vn = Qe(kr);
          Xn(Tr, Qt.props, "prop", vn, Qt);
        } else if (kr.PropTypes !== void 0 && !An) {
          An = !0;
          var mn = Qe(kr);
          dt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", mn || "Unknown");
        }
        typeof kr.getDefaultProps == "function" && !kr.getDefaultProps.isReactClassApproved && dt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ba(Qt) {
      {
        for (var kr = Object.keys(Qt.props), Tr = 0; Tr < kr.length; Tr++) {
          var vn = kr[Tr];
          if (vn !== "children" && vn !== "key") {
            en(Qt), dt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", vn), en(null);
            break;
          }
        }
        Qt.ref !== null && (en(Qt), dt("Invalid attribute `ref` supplied to `React.Fragment`."), en(null));
      }
    }
    function bo(Qt, kr, Tr, vn, mn, En) {
      {
        var Zn = er(Qt);
        if (!Zn) {
          var xn = "";
          (Qt === void 0 || typeof Qt == "object" && Qt !== null && Object.keys(Qt).length === 0) && (xn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var na = ii(mn);
          na ? xn += na : xn += Oo();
          var Wo;
          Qt === null ? Wo = "null" : vo(Qt) ? Wo = "array" : Qt !== void 0 && Qt.$$typeof === ae ? (Wo = "<" + (Qe(Qt.type) || "Unknown") + " />", xn = " Did you accidentally export a JSX literal instead of a component?") : Wo = typeof Qt, dt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Wo, xn);
        }
        var Zo = tn(Qt, kr, Tr, mn, En);
        if (Zo == null)
          return Zo;
        if (Zn) {
          var va = kr.children;
          if (va !== void 0)
            if (vn)
              if (vo(va)) {
                for (var yi = 0; yi < va.length; yi++)
                  po(va[yi], Qt);
                Object.freeze && Object.freeze(va);
              } else
                dt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              po(va, Qt);
        }
        return Qt === ye ? Ba(Zo) : _o(Zo), Zo;
      }
    }
    function $n(Qt, kr, Tr) {
      return bo(Qt, kr, Tr, !0);
    }
    function Bo(Qt, kr, Tr) {
      return bo(Qt, kr, Tr, !1);
    }
    var ho = Bo, To = $n;
    ne.Fragment = ye, ne.jsx = ho, ne.jsxs = To;
  }();
}), ke = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Xj() : oe.exports = Jj();
}), l2 = M((ne) => {
  function oe(At, Ft) {
    var Gt = At.length;
    At.push(Ft);
    e:
      for (; 0 < Gt; ) {
        var ot = Gt - 1 >>> 1, et = At[ot];
        if (0 < ye(et, Ft))
          At[ot] = Ft, At[Gt] = et, Gt = ot;
        else
          break e;
      }
  }
  function ae(At) {
    return At.length === 0 ? null : At[0];
  }
  function fe(At) {
    if (At.length === 0)
      return null;
    var Ft = At[0], Gt = At.pop();
    if (Gt !== Ft) {
      At[0] = Gt;
      e:
        for (var ot = 0, et = At.length, Rt = et >>> 1; ot < Rt; ) {
          var xr = 2 * (ot + 1) - 1, Xt = At[xr], dr = xr + 1, Nr = At[dr];
          if (0 > ye(Xt, Gt))
            dr < et && 0 > ye(Nr, Xt) ? (At[ot] = Nr, At[dr] = Gt, ot = dr) : (At[ot] = Xt, At[xr] = Gt, ot = xr);
          else if (dr < et && 0 > ye(Nr, Gt))
            At[ot] = Nr, At[dr] = Gt, ot = dr;
          else
            break e;
        }
    }
    return Ft;
  }
  function ye(At, Ft) {
    var Gt = At.sortIndex - Ft.sortIndex;
    return Gt !== 0 ? Gt : At.id - Ft.id;
  }
  typeof performance == "object" && typeof performance.now == "function" ? (ve = performance, ne.unstable_now = function() {
    return ve.now();
  }) : (_e = Date, xe = _e.now(), ne.unstable_now = function() {
    return _e.now() - xe;
  });
  var ve, _e, xe, Oe = [], $e = [], Me = 1, Re = null, je = 3, Be = !1, ze = !1, He = !1, qe = typeof setTimeout == "function" ? setTimeout : null, Ye = typeof clearTimeout == "function" ? clearTimeout : null, pt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function dt(At) {
    for (var Ft = ae($e); Ft !== null; ) {
      if (Ft.callback === null)
        fe($e);
      else if (Ft.startTime <= At)
        fe($e), Ft.sortIndex = Ft.expirationTime, oe(Oe, Ft);
      else
        break;
      Ft = ae($e);
    }
  }
  function yt(At) {
    if (He = !1, dt(At), !ze)
      if (ae(Oe) !== null)
        ze = !0, wt(Ct);
      else {
        var Ft = ae($e);
        Ft !== null && bt(yt, Ft.startTime - At);
      }
  }
  function Ct(At, Ft) {
    ze = !1, He && (He = !1, Ye(Ut), Ut = -1), Be = !0;
    var Gt = je;
    try {
      for (dt(Ft), Re = ae(Oe); Re !== null && (!(Re.expirationTime > Ft) || At && !er()); ) {
        var ot = Re.callback;
        if (typeof ot == "function") {
          Re.callback = null, je = Re.priorityLevel;
          var et = ot(Re.expirationTime <= Ft);
          Ft = ne.unstable_now(), typeof et == "function" ? Re.callback = et : Re === ae(Oe) && fe(Oe), dt(Ft);
        } else
          fe(Oe);
        Re = ae(Oe);
      }
      if (Re !== null)
        var Rt = !0;
      else {
        var xr = ae($e);
        xr !== null && bt(yt, xr.startTime - Ft), Rt = !1;
      }
      return Rt;
    } finally {
      Re = null, je = Gt, Be = !1;
    }
  }
  var It = !1, Vt = null, Ut = -1, Zt = 5, tr = -1;
  function er() {
    return !(ne.unstable_now() - tr < Zt);
  }
  function hr() {
    if (Vt !== null) {
      var At = ne.unstable_now();
      tr = At;
      var Ft = !0;
      try {
        Ft = Vt(!0, At);
      } finally {
        Ft ? Ot() : (It = !1, Vt = null);
      }
    } else
      It = !1;
  }
  var Ot;
  typeof pt == "function" ? Ot = function() {
    pt(hr);
  } : typeof MessageChannel < "u" ? (Qe = new MessageChannel(), at = Qe.port2, Qe.port1.onmessage = hr, Ot = function() {
    at.postMessage(null);
  }) : Ot = function() {
    qe(hr, 0);
  };
  var Qe, at;
  function wt(At) {
    Vt = At, It || (It = !0, Ot());
  }
  function bt(At, Ft) {
    Ut = qe(function() {
      At(ne.unstable_now());
    }, Ft);
  }
  ne.unstable_IdlePriority = 5, ne.unstable_ImmediatePriority = 1, ne.unstable_LowPriority = 4, ne.unstable_NormalPriority = 3, ne.unstable_Profiling = null, ne.unstable_UserBlockingPriority = 2, ne.unstable_cancelCallback = function(At) {
    At.callback = null;
  }, ne.unstable_continueExecution = function() {
    ze || Be || (ze = !0, wt(Ct));
  }, ne.unstable_forceFrameRate = function(At) {
    0 > At || 125 < At ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Zt = 0 < At ? Math.floor(1e3 / At) : 5;
  }, ne.unstable_getCurrentPriorityLevel = function() {
    return je;
  }, ne.unstable_getFirstCallbackNode = function() {
    return ae(Oe);
  }, ne.unstable_next = function(At) {
    switch (je) {
      case 1:
      case 2:
      case 3:
        var Ft = 3;
        break;
      default:
        Ft = je;
    }
    var Gt = je;
    je = Ft;
    try {
      return At();
    } finally {
      je = Gt;
    }
  }, ne.unstable_pauseExecution = function() {
  }, ne.unstable_requestPaint = function() {
  }, ne.unstable_runWithPriority = function(At, Ft) {
    switch (At) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        At = 3;
    }
    var Gt = je;
    je = At;
    try {
      return Ft();
    } finally {
      je = Gt;
    }
  }, ne.unstable_scheduleCallback = function(At, Ft, Gt) {
    var ot = ne.unstable_now();
    switch (typeof Gt == "object" && Gt !== null ? (Gt = Gt.delay, Gt = typeof Gt == "number" && 0 < Gt ? ot + Gt : ot) : Gt = ot, At) {
      case 1:
        var et = -1;
        break;
      case 2:
        et = 250;
        break;
      case 5:
        et = 1073741823;
        break;
      case 4:
        et = 1e4;
        break;
      default:
        et = 5e3;
    }
    return et = Gt + et, At = { id: Me++, callback: Ft, priorityLevel: At, startTime: Gt, expirationTime: et, sortIndex: -1 }, Gt > ot ? (At.sortIndex = Gt, oe($e, At), ae(Oe) === null && At === ae($e) && (He ? (Ye(Ut), Ut = -1) : He = !0, bt(yt, Gt - ot))) : (At.sortIndex = et, oe(Oe, At), ze || Be || (ze = !0, wt(Ct))), At;
  }, ne.unstable_shouldYield = er, ne.unstable_wrapCallback = function(At) {
    var Ft = je;
    return function() {
      var Gt = je;
      je = Ft;
      try {
        return At.apply(this, arguments);
      } finally {
        je = Gt;
      }
    };
  };
}), s2 = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = !1, ae = !1, fe = 5;
    function ye(Jt, or) {
      var fr = Jt.length;
      Jt.push(or), xe(Jt, or, fr);
    }
    function ve(Jt) {
      return Jt.length === 0 ? null : Jt[0];
    }
    function _e(Jt) {
      if (Jt.length === 0)
        return null;
      var or = Jt[0], fr = Jt.pop();
      return fr !== or && (Jt[0] = fr, Oe(Jt, fr, 0)), or;
    }
    function xe(Jt, or, fr) {
      for (var Mr = fr; Mr > 0; ) {
        var Wr = Mr - 1 >>> 1, Vr = Jt[Wr];
        if ($e(Vr, or) > 0)
          Jt[Wr] = or, Jt[Mr] = Vr, Mr = Wr;
        else
          return;
      }
    }
    function Oe(Jt, or, fr) {
      for (var Mr = fr, Wr = Jt.length, Vr = Wr >>> 1; Mr < Vr; ) {
        var Zr = (Mr + 1) * 2 - 1, on = Jt[Zr], Lr = Zr + 1, tn = Jt[Lr];
        if ($e(on, or) < 0)
          Lr < Wr && $e(tn, on) < 0 ? (Jt[Mr] = tn, Jt[Lr] = or, Mr = Lr) : (Jt[Mr] = on, Jt[Zr] = or, Mr = Zr);
        else if (Lr < Wr && $e(tn, or) < 0)
          Jt[Mr] = tn, Jt[Lr] = or, Mr = Lr;
        else
          return;
      }
    }
    function $e(Jt, or) {
      var fr = Jt.sortIndex - or.sortIndex;
      return fr !== 0 ? fr : Jt.id - or.id;
    }
    var Me = 1, Re = 2, je = 3, Be = 4, ze = 5, He = typeof performance == "object" && typeof performance.now == "function";
    if (He) {
      var qe = performance;
      ne.unstable_now = function() {
        return qe.now();
      };
    } else {
      var Ye = Date, pt = Ye.now();
      ne.unstable_now = function() {
        return Ye.now() - pt;
      };
    }
    var dt = 1073741823, yt = -1, Ct = 250, It = 5e3, Vt = 1e4, Ut = dt, Zt = [], tr = [], er = 1, hr = null, Ot = je, Qe = !1, at = !1, wt = !1, bt = typeof setTimeout == "function" ? setTimeout : null, At = typeof clearTimeout == "function" ? clearTimeout : null, Ft = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Gt(Jt) {
      for (var or = ve(tr); or !== null; ) {
        if (or.callback === null)
          _e(tr);
        else if (or.startTime <= Jt)
          _e(tr), or.sortIndex = or.expirationTime, ye(Zt, or);
        else
          return;
        or = ve(tr);
      }
    }
    function ot(Jt) {
      if (wt = !1, Gt(Jt), !at)
        if (ve(Zt) !== null)
          at = !0, ra(et);
        else {
          var or = ve(tr);
          or !== null && uo(ot, or.startTime - Jt);
        }
    }
    function et(Jt, or) {
      at = !1, wt && (wt = !1, So()), Qe = !0;
      var fr = Ot;
      try {
        var Mr;
        if (!ae)
          return Rt(Jt, or);
      } finally {
        hr = null, Ot = fr, Qe = !1;
      }
    }
    function Rt(Jt, or) {
      var fr = or;
      for (Gt(fr), hr = ve(Zt); hr !== null && !oe && !(hr.expirationTime > fr && (!Jt || fo())); ) {
        var Mr = hr.callback;
        if (typeof Mr == "function") {
          hr.callback = null, Ot = hr.priorityLevel;
          var Wr = hr.expirationTime <= fr, Vr = Mr(Wr);
          fr = ne.unstable_now(), typeof Vr == "function" ? hr.callback = Vr : hr === ve(Zt) && _e(Zt), Gt(fr);
        } else
          _e(Zt);
        hr = ve(Zt);
      }
      if (hr !== null)
        return !0;
      var Zr = ve(tr);
      return Zr !== null && uo(ot, Zr.startTime - fr), !1;
    }
    function xr(Jt, or) {
      switch (Jt) {
        case Me:
        case Re:
        case je:
        case Be:
        case ze:
          break;
        default:
          Jt = je;
      }
      var fr = Ot;
      Ot = Jt;
      try {
        return or();
      } finally {
        Ot = fr;
      }
    }
    function Xt(Jt) {
      var or;
      switch (Ot) {
        case Me:
        case Re:
        case je:
          or = je;
          break;
        default:
          or = Ot;
          break;
      }
      var fr = Ot;
      Ot = or;
      try {
        return Jt();
      } finally {
        Ot = fr;
      }
    }
    function dr(Jt) {
      var or = Ot;
      return function() {
        var fr = Ot;
        Ot = or;
        try {
          return Jt.apply(this, arguments);
        } finally {
          Ot = fr;
        }
      };
    }
    function Nr(Jt, or, fr) {
      var Mr = ne.unstable_now(), Wr;
      if (typeof fr == "object" && fr !== null) {
        var Vr = fr.delay;
        typeof Vr == "number" && Vr > 0 ? Wr = Mr + Vr : Wr = Mr;
      } else
        Wr = Mr;
      var Zr;
      switch (Jt) {
        case Me:
          Zr = yt;
          break;
        case Re:
          Zr = Ct;
          break;
        case ze:
          Zr = Ut;
          break;
        case Be:
          Zr = Vt;
          break;
        case je:
        default:
          Zr = It;
          break;
      }
      var on = Wr + Zr, Lr = { id: er++, callback: or, priorityLevel: Jt, startTime: Wr, expirationTime: on, sortIndex: -1 };
      return Wr > Mr ? (Lr.sortIndex = Wr, ye(tr, Lr), ve(Zt) === null && Lr === ve(tr) && (wt ? So() : wt = !0, uo(ot, Wr - Mr))) : (Lr.sortIndex = on, ye(Zt, Lr), !at && !Qe && (at = !0, ra(et))), Lr;
    }
    function Dr() {
    }
    function jr() {
      !at && !Qe && (at = !0, ra(et));
    }
    function un() {
      return ve(Zt);
    }
    function so(Jt) {
      Jt.callback = null;
    }
    function Pn() {
      return Ot;
    }
    var co = !1, kn = null, Yn = -1, Ho = fe, Rn = -1;
    function fo() {
      var Jt = ne.unstable_now() - Rn;
      return !(Jt < Ho);
    }
    function pa() {
    }
    function jn(Jt) {
      if (Jt < 0 || Jt > 125) {
        console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
        return;
      }
      Jt > 0 ? Ho = Math.floor(1e3 / Jt) : Ho = fe;
    }
    var Xn = function() {
      if (kn !== null) {
        var Jt = ne.unstable_now();
        Rn = Jt;
        var or = !0, fr = !0;
        try {
          fr = kn(or, Jt);
        } finally {
          fr ? Ko() : (co = !1, kn = null);
        }
      } else
        co = !1;
    }, Ko;
    if (typeof Ft == "function")
      Ko = function() {
        Ft(Xn);
      };
    else if (typeof MessageChannel < "u") {
      var vo = new MessageChannel(), Eo = vo.port2;
      vo.port1.onmessage = Xn, Ko = function() {
        Eo.postMessage(null);
      };
    } else
      Ko = function() {
        bt(Xn, 0);
      };
    function ra(Jt) {
      kn = Jt, co || (co = !0, Ko());
    }
    function uo(Jt, or) {
      Yn = bt(function() {
        Jt(ne.unstable_now());
      }, or);
    }
    function So() {
      At(Yn), Yn = -1;
    }
    var Jo = pa, Po = null;
    ne.unstable_IdlePriority = ze, ne.unstable_ImmediatePriority = Me, ne.unstable_LowPriority = Be, ne.unstable_NormalPriority = je, ne.unstable_Profiling = Po, ne.unstable_UserBlockingPriority = Re, ne.unstable_cancelCallback = so, ne.unstable_continueExecution = jr, ne.unstable_forceFrameRate = jn, ne.unstable_getCurrentPriorityLevel = Pn, ne.unstable_getFirstCallbackNode = un, ne.unstable_next = Xt, ne.unstable_pauseExecution = Dr, ne.unstable_requestPaint = Jo, ne.unstable_runWithPriority = xr, ne.unstable_scheduleCallback = Nr, ne.unstable_shouldYield = fo, ne.unstable_wrapCallback = dr, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), GR = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = l2() : oe.exports = s2();
}), mz = M((ne) => {
  var oe = ir(), ae = GR();
  function fe(Se) {
    for (var Ce = "https://reactjs.org/docs/error-decoder.html?invariant=" + Se, Fe = 1; Fe < arguments.length; Fe++)
      Ce += "&args[]=" + encodeURIComponent(arguments[Fe]);
    return "Minified React error #" + Se + "; visit " + Ce + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var ye = /* @__PURE__ */ new Set(), ve = {};
  function _e(Se, Ce) {
    xe(Se, Ce), xe(Se + "Capture", Ce);
  }
  function xe(Se, Ce) {
    for (ve[Se] = Ce, Se = 0; Se < Ce.length; Se++)
      ye.add(Ce[Se]);
  }
  var Oe = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), $e = Object.prototype.hasOwnProperty, Me = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Re = {}, je = {};
  function Be(Se) {
    return $e.call(je, Se) ? !0 : $e.call(Re, Se) ? !1 : Me.test(Se) ? je[Se] = !0 : (Re[Se] = !0, !1);
  }
  function ze(Se, Ce, Fe, Ue) {
    if (Fe !== null && Fe.type === 0)
      return !1;
    switch (typeof Ce) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return Ue ? !1 : Fe !== null ? !Fe.acceptsBooleans : (Se = Se.toLowerCase().slice(0, 5), Se !== "data-" && Se !== "aria-");
      default:
        return !1;
    }
  }
  function He(Se, Ce, Fe, Ue) {
    if (Ce === null || typeof Ce > "u" || ze(Se, Ce, Fe, Ue))
      return !0;
    if (Ue)
      return !1;
    if (Fe !== null)
      switch (Fe.type) {
        case 3:
          return !Ce;
        case 4:
          return Ce === !1;
        case 5:
          return isNaN(Ce);
        case 6:
          return isNaN(Ce) || 1 > Ce;
      }
    return !1;
  }
  function qe(Se, Ce, Fe, Ue, Xe, it, $t) {
    this.acceptsBooleans = Ce === 2 || Ce === 3 || Ce === 4, this.attributeName = Ue, this.attributeNamespace = Xe, this.mustUseProperty = Fe, this.propertyName = Se, this.type = Ce, this.sanitizeURL = it, this.removeEmptyString = $t;
  }
  var Ye = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(Se) {
    Ye[Se] = new qe(Se, 0, !1, Se, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(Se) {
    var Ce = Se[0];
    Ye[Ce] = new qe(Ce, 1, !1, Se[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 2, !1, Se.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 2, !1, Se, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(Se) {
    Ye[Se] = new qe(Se, 3, !1, Se.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 3, !0, Se, null, !1, !1);
  }), ["capture", "download"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 4, !1, Se, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 6, !1, Se, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 5, !1, Se.toLowerCase(), null, !1, !1);
  });
  var pt = /[\-:]([a-z])/g;
  function dt(Se) {
    return Se[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(Se) {
    var Ce = Se.replace(pt, dt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(Se) {
    var Ce = Se.replace(pt, dt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(Se) {
    var Ce = Se.replace(pt, dt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 1, !1, Se.toLowerCase(), null, !1, !1);
  }), Ye.xlinkHref = new qe("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 1, !1, Se.toLowerCase(), null, !0, !0);
  });
  function yt(Se, Ce, Fe, Ue) {
    var Xe = Ye.hasOwnProperty(Ce) ? Ye[Ce] : null;
    (Xe !== null ? Xe.type !== 0 : Ue || !(2 < Ce.length) || Ce[0] !== "o" && Ce[0] !== "O" || Ce[1] !== "n" && Ce[1] !== "N") && (He(Ce, Fe, Xe, Ue) && (Fe = null), Ue || Xe === null ? Be(Ce) && (Fe === null ? Se.removeAttribute(Ce) : Se.setAttribute(Ce, "" + Fe)) : Xe.mustUseProperty ? Se[Xe.propertyName] = Fe === null ? Xe.type === 3 ? !1 : "" : Fe : (Ce = Xe.attributeName, Ue = Xe.attributeNamespace, Fe === null ? Se.removeAttribute(Ce) : (Xe = Xe.type, Fe = Xe === 3 || Xe === 4 && Fe === !0 ? "" : "" + Fe, Ue ? Se.setAttributeNS(Ue, Ce, Fe) : Se.setAttribute(Ce, Fe))));
  }
  var Ct = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, It = Symbol.for("react.element"), Vt = Symbol.for("react.portal"), Ut = Symbol.for("react.fragment"), Zt = Symbol.for("react.strict_mode"), tr = Symbol.for("react.profiler"), er = Symbol.for("react.provider"), hr = Symbol.for("react.context"), Ot = Symbol.for("react.forward_ref"), Qe = Symbol.for("react.suspense"), at = Symbol.for("react.suspense_list"), wt = Symbol.for("react.memo"), bt = Symbol.for("react.lazy"), At = Symbol.for("react.offscreen"), Ft = Symbol.iterator;
  function Gt(Se) {
    return Se === null || typeof Se != "object" ? null : (Se = Ft && Se[Ft] || Se["@@iterator"], typeof Se == "function" ? Se : null);
  }
  var ot = Object.assign, et;
  function Rt(Se) {
    if (et === void 0)
      try {
        throw Error();
      } catch (Fe) {
        var Ce = Fe.stack.trim().match(/\n( *(at )?)/);
        et = Ce && Ce[1] || "";
      }
    return `
` + et + Se;
  }
  var xr = !1;
  function Xt(Se, Ce) {
    if (!Se || xr)
      return "";
    xr = !0;
    var Fe = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (Ce)
        if (Ce = function() {
          throw Error();
        }, Object.defineProperty(Ce.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(Ce, []);
          } catch (Sr) {
            var Ue = Sr;
          }
          Reflect.construct(Se, [], Ce);
        } else {
          try {
            Ce.call();
          } catch (Sr) {
            Ue = Sr;
          }
          Se.call(Ce.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Sr) {
          Ue = Sr;
        }
        Se();
      }
    } catch (Sr) {
      if (Sr && Ue && typeof Sr.stack == "string") {
        for (var Xe = Sr.stack.split(`
`), it = Ue.stack.split(`
`), $t = Xe.length - 1, Kt = it.length - 1; 1 <= $t && 0 <= Kt && Xe[$t] !== it[Kt]; )
          Kt--;
        for (; 1 <= $t && 0 <= Kt; $t--, Kt--)
          if (Xe[$t] !== it[Kt]) {
            if ($t !== 1 || Kt !== 1)
              do
                if ($t--, Kt--, 0 > Kt || Xe[$t] !== it[Kt]) {
                  var rr = `
` + Xe[$t].replace(" at new ", " at ");
                  return Se.displayName && rr.includes("<anonymous>") && (rr = rr.replace("<anonymous>", Se.displayName)), rr;
                }
              while (1 <= $t && 0 <= Kt);
            break;
          }
      }
    } finally {
      xr = !1, Error.prepareStackTrace = Fe;
    }
    return (Se = Se ? Se.displayName || Se.name : "") ? Rt(Se) : "";
  }
  function dr(Se) {
    switch (Se.tag) {
      case 5:
        return Rt(Se.type);
      case 16:
        return Rt("Lazy");
      case 13:
        return Rt("Suspense");
      case 19:
        return Rt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return Se = Xt(Se.type, !1), Se;
      case 11:
        return Se = Xt(Se.type.render, !1), Se;
      case 1:
        return Se = Xt(Se.type, !0), Se;
      default:
        return "";
    }
  }
  function Nr(Se) {
    if (Se == null)
      return null;
    if (typeof Se == "function")
      return Se.displayName || Se.name || null;
    if (typeof Se == "string")
      return Se;
    switch (Se) {
      case Ut:
        return "Fragment";
      case Vt:
        return "Portal";
      case tr:
        return "Profiler";
      case Zt:
        return "StrictMode";
      case Qe:
        return "Suspense";
      case at:
        return "SuspenseList";
    }
    if (typeof Se == "object")
      switch (Se.$$typeof) {
        case hr:
          return (Se.displayName || "Context") + ".Consumer";
        case er:
          return (Se._context.displayName || "Context") + ".Provider";
        case Ot:
          var Ce = Se.render;
          return Se = Se.displayName, Se || (Se = Ce.displayName || Ce.name || "", Se = Se !== "" ? "ForwardRef(" + Se + ")" : "ForwardRef"), Se;
        case wt:
          return Ce = Se.displayName || null, Ce !== null ? Ce : Nr(Se.type) || "Memo";
        case bt:
          Ce = Se._payload, Se = Se._init;
          try {
            return Nr(Se(Ce));
          } catch {
          }
      }
    return null;
  }
  function Dr(Se) {
    var Ce = Se.type;
    switch (Se.tag) {
      case 24:
        return "Cache";
      case 9:
        return (Ce.displayName || "Context") + ".Consumer";
      case 10:
        return (Ce._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return Se = Ce.render, Se = Se.displayName || Se.name || "", Ce.displayName || (Se !== "" ? "ForwardRef(" + Se + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return Ce;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Nr(Ce);
      case 8:
        return Ce === Zt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof Ce == "function")
          return Ce.displayName || Ce.name || null;
        if (typeof Ce == "string")
          return Ce;
    }
    return null;
  }
  function jr(Se) {
    switch (typeof Se) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return Se;
      case "object":
        return Se;
      default:
        return "";
    }
  }
  function un(Se) {
    var Ce = Se.type;
    return (Se = Se.nodeName) && Se.toLowerCase() === "input" && (Ce === "checkbox" || Ce === "radio");
  }
  function so(Se) {
    var Ce = un(Se) ? "checked" : "value", Fe = Object.getOwnPropertyDescriptor(Se.constructor.prototype, Ce), Ue = "" + Se[Ce];
    if (!Se.hasOwnProperty(Ce) && typeof Fe < "u" && typeof Fe.get == "function" && typeof Fe.set == "function") {
      var Xe = Fe.get, it = Fe.set;
      return Object.defineProperty(Se, Ce, { configurable: !0, get: function() {
        return Xe.call(this);
      }, set: function($t) {
        Ue = "" + $t, it.call(this, $t);
      } }), Object.defineProperty(Se, Ce, { enumerable: Fe.enumerable }), { getValue: function() {
        return Ue;
      }, setValue: function($t) {
        Ue = "" + $t;
      }, stopTracking: function() {
        Se._valueTracker = null, delete Se[Ce];
      } };
    }
  }
  function Pn(Se) {
    Se._valueTracker || (Se._valueTracker = so(Se));
  }
  function co(Se) {
    if (!Se)
      return !1;
    var Ce = Se._valueTracker;
    if (!Ce)
      return !0;
    var Fe = Ce.getValue(), Ue = "";
    return Se && (Ue = un(Se) ? Se.checked ? "true" : "false" : Se.value), Se = Ue, Se !== Fe ? (Ce.setValue(Se), !0) : !1;
  }
  function kn(Se) {
    if (Se = Se || (typeof document < "u" ? document : void 0), typeof Se > "u")
      return null;
    try {
      return Se.activeElement || Se.body;
    } catch {
      return Se.body;
    }
  }
  function Yn(Se, Ce) {
    var Fe = Ce.checked;
    return ot({}, Ce, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Fe ?? Se._wrapperState.initialChecked });
  }
  function Ho(Se, Ce) {
    var Fe = Ce.defaultValue == null ? "" : Ce.defaultValue, Ue = Ce.checked != null ? Ce.checked : Ce.defaultChecked;
    Fe = jr(Ce.value != null ? Ce.value : Fe), Se._wrapperState = { initialChecked: Ue, initialValue: Fe, controlled: Ce.type === "checkbox" || Ce.type === "radio" ? Ce.checked != null : Ce.value != null };
  }
  function Rn(Se, Ce) {
    Ce = Ce.checked, Ce != null && yt(Se, "checked", Ce, !1);
  }
  function fo(Se, Ce) {
    Rn(Se, Ce);
    var Fe = jr(Ce.value), Ue = Ce.type;
    if (Fe != null)
      Ue === "number" ? (Fe === 0 && Se.value === "" || Se.value != Fe) && (Se.value = "" + Fe) : Se.value !== "" + Fe && (Se.value = "" + Fe);
    else if (Ue === "submit" || Ue === "reset") {
      Se.removeAttribute("value");
      return;
    }
    Ce.hasOwnProperty("value") ? jn(Se, Ce.type, Fe) : Ce.hasOwnProperty("defaultValue") && jn(Se, Ce.type, jr(Ce.defaultValue)), Ce.checked == null && Ce.defaultChecked != null && (Se.defaultChecked = !!Ce.defaultChecked);
  }
  function pa(Se, Ce, Fe) {
    if (Ce.hasOwnProperty("value") || Ce.hasOwnProperty("defaultValue")) {
      var Ue = Ce.type;
      if (!(Ue !== "submit" && Ue !== "reset" || Ce.value !== void 0 && Ce.value !== null))
        return;
      Ce = "" + Se._wrapperState.initialValue, Fe || Ce === Se.value || (Se.value = Ce), Se.defaultValue = Ce;
    }
    Fe = Se.name, Fe !== "" && (Se.name = ""), Se.defaultChecked = !!Se._wrapperState.initialChecked, Fe !== "" && (Se.name = Fe);
  }
  function jn(Se, Ce, Fe) {
    (Ce !== "number" || kn(Se.ownerDocument) !== Se) && (Fe == null ? Se.defaultValue = "" + Se._wrapperState.initialValue : Se.defaultValue !== "" + Fe && (Se.defaultValue = "" + Fe));
  }
  var Xn = Array.isArray;
  function Ko(Se, Ce, Fe, Ue) {
    if (Se = Se.options, Ce) {
      Ce = {};
      for (var Xe = 0; Xe < Fe.length; Xe++)
        Ce["$" + Fe[Xe]] = !0;
      for (Fe = 0; Fe < Se.length; Fe++)
        Xe = Ce.hasOwnProperty("$" + Se[Fe].value), Se[Fe].selected !== Xe && (Se[Fe].selected = Xe), Xe && Ue && (Se[Fe].defaultSelected = !0);
    } else {
      for (Fe = "" + jr(Fe), Ce = null, Xe = 0; Xe < Se.length; Xe++) {
        if (Se[Xe].value === Fe) {
          Se[Xe].selected = !0, Ue && (Se[Xe].defaultSelected = !0);
          return;
        }
        Ce !== null || Se[Xe].disabled || (Ce = Se[Xe]);
      }
      Ce !== null && (Ce.selected = !0);
    }
  }
  function vo(Se, Ce) {
    if (Ce.dangerouslySetInnerHTML != null)
      throw Error(fe(91));
    return ot({}, Ce, { value: void 0, defaultValue: void 0, children: "" + Se._wrapperState.initialValue });
  }
  function Eo(Se, Ce) {
    var Fe = Ce.value;
    if (Fe == null) {
      if (Fe = Ce.children, Ce = Ce.defaultValue, Fe != null) {
        if (Ce != null)
          throw Error(fe(92));
        if (Xn(Fe)) {
          if (1 < Fe.length)
            throw Error(fe(93));
          Fe = Fe[0];
        }
        Ce = Fe;
      }
      Ce == null && (Ce = ""), Fe = Ce;
    }
    Se._wrapperState = { initialValue: jr(Fe) };
  }
  function ra(Se, Ce) {
    var Fe = jr(Ce.value), Ue = jr(Ce.defaultValue);
    Fe != null && (Fe = "" + Fe, Fe !== Se.value && (Se.value = Fe), Ce.defaultValue == null && Se.defaultValue !== Fe && (Se.defaultValue = Fe)), Ue != null && (Se.defaultValue = "" + Ue);
  }
  function uo(Se) {
    var Ce = Se.textContent;
    Ce === Se._wrapperState.initialValue && Ce !== "" && Ce !== null && (Se.value = Ce);
  }
  function So(Se) {
    switch (Se) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Jo(Se, Ce) {
    return Se == null || Se === "http://www.w3.org/1999/xhtml" ? So(Ce) : Se === "http://www.w3.org/2000/svg" && Ce === "foreignObject" ? "http://www.w3.org/1999/xhtml" : Se;
  }
  var Po, Jt = function(Se) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(Ce, Fe, Ue, Xe) {
      MSApp.execUnsafeLocalFunction(function() {
        return Se(Ce, Fe, Ue, Xe);
      });
    } : Se;
  }(function(Se, Ce) {
    if (Se.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in Se)
      Se.innerHTML = Ce;
    else {
      for (Po = Po || document.createElement("div"), Po.innerHTML = "<svg>" + Ce.valueOf().toString() + "</svg>", Ce = Po.firstChild; Se.firstChild; )
        Se.removeChild(Se.firstChild);
      for (; Ce.firstChild; )
        Se.appendChild(Ce.firstChild);
    }
  });
  function or(Se, Ce) {
    if (Ce) {
      var Fe = Se.firstChild;
      if (Fe && Fe === Se.lastChild && Fe.nodeType === 3) {
        Fe.nodeValue = Ce;
        return;
      }
    }
    Se.textContent = Ce;
  }
  var fr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Mr = ["Webkit", "ms", "Moz", "O"];
  Object.keys(fr).forEach(function(Se) {
    Mr.forEach(function(Ce) {
      Ce = Ce + Se.charAt(0).toUpperCase() + Se.substring(1), fr[Ce] = fr[Se];
    });
  });
  function Wr(Se, Ce, Fe) {
    return Ce == null || typeof Ce == "boolean" || Ce === "" ? "" : Fe || typeof Ce != "number" || Ce === 0 || fr.hasOwnProperty(Se) && fr[Se] ? ("" + Ce).trim() : Ce + "px";
  }
  function Vr(Se, Ce) {
    Se = Se.style;
    for (var Fe in Ce)
      if (Ce.hasOwnProperty(Fe)) {
        var Ue = Fe.indexOf("--") === 0, Xe = Wr(Fe, Ce[Fe], Ue);
        Fe === "float" && (Fe = "cssFloat"), Ue ? Se.setProperty(Fe, Xe) : Se[Fe] = Xe;
      }
  }
  var Zr = ot({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function on(Se, Ce) {
    if (Ce) {
      if (Zr[Se] && (Ce.children != null || Ce.dangerouslySetInnerHTML != null))
        throw Error(fe(137, Se));
      if (Ce.dangerouslySetInnerHTML != null) {
        if (Ce.children != null)
          throw Error(fe(60));
        if (typeof Ce.dangerouslySetInnerHTML != "object" || !("__html" in Ce.dangerouslySetInnerHTML))
          throw Error(fe(61));
      }
      if (Ce.style != null && typeof Ce.style != "object")
        throw Error(fe(62));
    }
  }
  function Lr(Se, Ce) {
    if (Se.indexOf("-") === -1)
      return typeof Ce.is == "string";
    switch (Se) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var tn = null;
  function Qn(Se) {
    return Se = Se.target || Se.srcElement || window, Se.correspondingUseElement && (Se = Se.correspondingUseElement), Se.nodeType === 3 ? Se.parentNode : Se;
  }
  var Fn = null, en = null, An = null;
  function zn(Se) {
    if (Se = Sp(Se)) {
      if (typeof Fn != "function")
        throw Error(fe(280));
      var Ce = Se.stateNode;
      Ce && (Ce = Nn(Ce), Fn(Se.stateNode, Se.type, Ce));
    }
  }
  function Oo(Se) {
    en ? An ? An.push(Se) : An = [Se] : en = Se;
  }
  function ii() {
    if (en) {
      var Se = en, Ce = An;
      if (An = en = null, zn(Se), Ce)
        for (Se = 0; Se < Ce.length; Se++)
          zn(Ce[Se]);
    }
  }
  function No(Se, Ce) {
    return Se(Ce);
  }
  function Ao() {
  }
  var Da = !1;
  function po(Se, Ce, Fe) {
    if (Da)
      return Se(Ce, Fe);
    Da = !0;
    try {
      return No(Se, Ce, Fe);
    } finally {
      Da = !1, (en !== null || An !== null) && (Ao(), ii());
    }
  }
  function _o(Se, Ce) {
    var Fe = Se.stateNode;
    if (Fe === null)
      return null;
    var Ue = Nn(Fe);
    if (Ue === null)
      return null;
    Fe = Ue[Ce];
    e:
      switch (Ce) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (Ue = !Ue.disabled) || (Se = Se.type, Ue = !(Se === "button" || Se === "input" || Se === "select" || Se === "textarea")), Se = !Ue;
          break e;
        default:
          Se = !1;
      }
    if (Se)
      return null;
    if (Fe && typeof Fe != "function")
      throw Error(fe(231, Ce, typeof Fe));
    return Fe;
  }
  var Ba = !1;
  if (Oe)
    try {
      bo = {}, Object.defineProperty(bo, "passive", { get: function() {
        Ba = !0;
      } }), window.addEventListener("test", bo, bo), window.removeEventListener("test", bo, bo);
    } catch {
      Ba = !1;
    }
  var bo;
  function $n(Se, Ce, Fe, Ue, Xe, it, $t, Kt, rr) {
    var Sr = Array.prototype.slice.call(arguments, 3);
    try {
      Ce.apply(Fe, Sr);
    } catch (zr) {
      this.onError(zr);
    }
  }
  var Bo = !1, ho = null, To = !1, Qt = null, kr = { onError: function(Se) {
    Bo = !0, ho = Se;
  } };
  function Tr(Se, Ce, Fe, Ue, Xe, it, $t, Kt, rr) {
    Bo = !1, ho = null, $n.apply(kr, arguments);
  }
  function vn(Se, Ce, Fe, Ue, Xe, it, $t, Kt, rr) {
    if (Tr.apply(this, arguments), Bo) {
      if (Bo) {
        var Sr = ho;
        Bo = !1, ho = null;
      } else
        throw Error(fe(198));
      To || (To = !0, Qt = Sr);
    }
  }
  function mn(Se) {
    var Ce = Se, Fe = Se;
    if (Se.alternate)
      for (; Ce.return; )
        Ce = Ce.return;
    else {
      Se = Ce;
      do
        Ce = Se, Ce.flags & 4098 && (Fe = Ce.return), Se = Ce.return;
      while (Se);
    }
    return Ce.tag === 3 ? Fe : null;
  }
  function En(Se) {
    if (Se.tag === 13) {
      var Ce = Se.memoizedState;
      if (Ce === null && (Se = Se.alternate, Se !== null && (Ce = Se.memoizedState)), Ce !== null)
        return Ce.dehydrated;
    }
    return null;
  }
  function Zn(Se) {
    if (mn(Se) !== Se)
      throw Error(fe(188));
  }
  function xn(Se) {
    var Ce = Se.alternate;
    if (!Ce) {
      if (Ce = mn(Se), Ce === null)
        throw Error(fe(188));
      return Ce !== Se ? null : Se;
    }
    for (var Fe = Se, Ue = Ce; ; ) {
      var Xe = Fe.return;
      if (Xe === null)
        break;
      var it = Xe.alternate;
      if (it === null) {
        if (Ue = Xe.return, Ue !== null) {
          Fe = Ue;
          continue;
        }
        break;
      }
      if (Xe.child === it.child) {
        for (it = Xe.child; it; ) {
          if (it === Fe)
            return Zn(Xe), Se;
          if (it === Ue)
            return Zn(Xe), Ce;
          it = it.sibling;
        }
        throw Error(fe(188));
      }
      if (Fe.return !== Ue.return)
        Fe = Xe, Ue = it;
      else {
        for (var $t = !1, Kt = Xe.child; Kt; ) {
          if (Kt === Fe) {
            $t = !0, Fe = Xe, Ue = it;
            break;
          }
          if (Kt === Ue) {
            $t = !0, Ue = Xe, Fe = it;
            break;
          }
          Kt = Kt.sibling;
        }
        if (!$t) {
          for (Kt = it.child; Kt; ) {
            if (Kt === Fe) {
              $t = !0, Fe = it, Ue = Xe;
              break;
            }
            if (Kt === Ue) {
              $t = !0, Ue = it, Fe = Xe;
              break;
            }
            Kt = Kt.sibling;
          }
          if (!$t)
            throw Error(fe(189));
        }
      }
      if (Fe.alternate !== Ue)
        throw Error(fe(190));
    }
    if (Fe.tag !== 3)
      throw Error(fe(188));
    return Fe.stateNode.current === Fe ? Se : Ce;
  }
  function na(Se) {
    return Se = xn(Se), Se !== null ? Wo(Se) : null;
  }
  function Wo(Se) {
    if (Se.tag === 5 || Se.tag === 6)
      return Se;
    for (Se = Se.child; Se !== null; ) {
      var Ce = Wo(Se);
      if (Ce !== null)
        return Ce;
      Se = Se.sibling;
    }
    return null;
  }
  var Zo = ae.unstable_scheduleCallback, va = ae.unstable_cancelCallback, yi = ae.unstable_shouldYield, _s = ae.unstable_requestPaint, xo = ae.unstable_now, qu = ae.unstable_getCurrentPriorityLevel, si = ae.unstable_ImmediatePriority, oo = ae.unstable_UserBlockingPriority, da = ae.unstable_NormalPriority, xs = ae.unstable_LowPriority, as = ae.unstable_IdlePriority, Ci = null, Ca = null;
  function Es(Se) {
    if (Ca && typeof Ca.onCommitFiberRoot == "function")
      try {
        Ca.onCommitFiberRoot(Ci, Se, void 0, (Se.current.flags & 128) === 128);
      } catch {
      }
  }
  var ka = Math.clz32 ? Math.clz32 : od, rl = Math.log, nl = Math.LN2;
  function od(Se) {
    return Se >>>= 0, Se === 0 ? 32 : 31 - (rl(Se) / nl | 0) | 0;
  }
  var ol = 64, Yi = 4194304;
  function $i(Se) {
    switch (Se & -Se) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return Se & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return Se & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return Se;
    }
  }
  function $a(Se, Ce) {
    var Fe = Se.pendingLanes;
    if (Fe === 0)
      return 0;
    var Ue = 0, Xe = Se.suspendedLanes, it = Se.pingedLanes, $t = Fe & 268435455;
    if ($t !== 0) {
      var Kt = $t & ~Xe;
      Kt !== 0 ? Ue = $i(Kt) : (it &= $t, it !== 0 && (Ue = $i(it)));
    } else
      $t = Fe & ~Xe, $t !== 0 ? Ue = $i($t) : it !== 0 && (Ue = $i(it));
    if (Ue === 0)
      return 0;
    if (Ce !== 0 && Ce !== Ue && !(Ce & Xe) && (Xe = Ue & -Ue, it = Ce & -Ce, Xe >= it || Xe === 16 && (it & 4194240) !== 0))
      return Ce;
    if (Ue & 4 && (Ue |= Fe & 16), Ce = Se.entangledLanes, Ce !== 0)
      for (Se = Se.entanglements, Ce &= Ue; 0 < Ce; )
        Fe = 31 - ka(Ce), Xe = 1 << Fe, Ue |= Se[Fe], Ce &= ~Xe;
    return Ue;
  }
  function Us(Se, Ce) {
    switch (Se) {
      case 1:
      case 2:
      case 4:
        return Ce + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return Ce + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ts(Se, Ce) {
    for (var Fe = Se.suspendedLanes, Ue = Se.pingedLanes, Xe = Se.expirationTimes, it = Se.pendingLanes; 0 < it; ) {
      var $t = 31 - ka(it), Kt = 1 << $t, rr = Xe[$t];
      rr === -1 ? (!(Kt & Fe) || Kt & Ue) && (Xe[$t] = Us(Kt, Ce)) : rr <= Ce && (Se.expiredLanes |= Kt), it &= ~Kt;
    }
  }
  function xl(Se) {
    return Se = Se.pendingLanes & -1073741825, Se !== 0 ? Se : Se & 1073741824 ? 1073741824 : 0;
  }
  function lu() {
    var Se = ol;
    return ol <<= 1, !(ol & 4194240) && (ol = 64), Se;
  }
  function El(Se) {
    for (var Ce = [], Fe = 0; 31 > Fe; Fe++)
      Ce.push(Se);
    return Ce;
  }
  function Vs(Se, Ce, Fe) {
    Se.pendingLanes |= Ce, Ce !== 536870912 && (Se.suspendedLanes = 0, Se.pingedLanes = 0), Se = Se.eventTimes, Ce = 31 - ka(Ce), Se[Ce] = Fe;
  }
  function Hs(Se, Ce) {
    var Fe = Se.pendingLanes & ~Ce;
    Se.pendingLanes = Ce, Se.suspendedLanes = 0, Se.pingedLanes = 0, Se.expiredLanes &= Ce, Se.mutableReadLanes &= Ce, Se.entangledLanes &= Ce, Ce = Se.entanglements;
    var Ue = Se.eventTimes;
    for (Se = Se.expirationTimes; 0 < Fe; ) {
      var Xe = 31 - ka(Fe), it = 1 << Xe;
      Ce[Xe] = 0, Ue[Xe] = -1, Se[Xe] = -1, Fe &= ~it;
    }
  }
  function qs(Se, Ce) {
    var Fe = Se.entangledLanes |= Ce;
    for (Se = Se.entanglements; Fe; ) {
      var Ue = 31 - ka(Fe), Xe = 1 << Ue;
      Xe & Ce | Se[Ue] & Ce && (Se[Ue] |= Ce), Fe &= ~Xe;
    }
  }
  var jo = 0;
  function is(Se) {
    return Se &= -Se, 1 < Se ? 4 < Se ? Se & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var hc, qa, Fo, al, Sl, Gn = !1, Ws = [], fa = null, Ka = null, Xa = null, Zs = /* @__PURE__ */ new Map(), wa = /* @__PURE__ */ new Map(), Lo = [], Pl = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ii(Se, Ce) {
    switch (Se) {
      case "focusin":
      case "focusout":
        fa = null;
        break;
      case "dragenter":
      case "dragleave":
        Ka = null;
        break;
      case "mouseover":
      case "mouseout":
        Xa = null;
        break;
      case "pointerover":
      case "pointerout":
        Zs.delete(Ce.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        wa.delete(Ce.pointerId);
    }
  }
  function ja(Se, Ce, Fe, Ue, Xe, it) {
    return Se === null || Se.nativeEvent !== it ? (Se = { blockedOn: Ce, domEventName: Fe, eventSystemFlags: Ue, nativeEvent: it, targetContainers: [Xe] }, Ce !== null && (Ce = Sp(Ce), Ce !== null && qa(Ce)), Se) : (Se.eventSystemFlags |= Ue, Ce = Se.targetContainers, Xe !== null && Ce.indexOf(Xe) === -1 && Ce.push(Xe), Se);
  }
  function Ss(Se, Ce, Fe, Ue, Xe) {
    switch (Ce) {
      case "focusin":
        return fa = ja(fa, Se, Ce, Fe, Ue, Xe), !0;
      case "dragenter":
        return Ka = ja(Ka, Se, Ce, Fe, Ue, Xe), !0;
      case "mouseover":
        return Xa = ja(Xa, Se, Ce, Fe, Ue, Xe), !0;
      case "pointerover":
        var it = Xe.pointerId;
        return Zs.set(it, ja(Zs.get(it) || null, Se, Ce, Fe, Ue, Xe)), !0;
      case "gotpointercapture":
        return it = Xe.pointerId, wa.set(it, ja(wa.get(it) || null, Se, Ce, Fe, Ue, Xe)), !0;
    }
    return !1;
  }
  function il(Se) {
    var Ce = mu(Se.target);
    if (Ce !== null) {
      var Fe = mn(Ce);
      if (Fe !== null) {
        if (Ce = Fe.tag, Ce === 13) {
          if (Ce = En(Fe), Ce !== null) {
            Se.blockedOn = Ce, Sl(Se.priority, function() {
              Fo(Fe);
            });
            return;
          }
        } else if (Ce === 3 && Fe.stateNode.current.memoizedState.isDehydrated) {
          Se.blockedOn = Fe.tag === 3 ? Fe.stateNode.containerInfo : null;
          return;
        }
      }
    }
    Se.blockedOn = null;
  }
  function vi(Se) {
    if (Se.blockedOn !== null)
      return !1;
    for (var Ce = Se.targetContainers; 0 < Ce.length; ) {
      var Fe = ul(Se.domEventName, Se.eventSystemFlags, Ce[0], Se.nativeEvent);
      if (Fe === null) {
        Fe = Se.nativeEvent;
        var Ue = new Fe.constructor(Fe.type, Fe);
        tn = Ue, Fe.target.dispatchEvent(Ue), tn = null;
      } else
        return Ce = Sp(Fe), Ce !== null && qa(Ce), Se.blockedOn = Fe, !1;
      Ce.shift();
    }
    return !0;
  }
  function Tl(Se, Ce, Fe) {
    vi(Se) && Fe.delete(Ce);
  }
  function bi() {
    Gn = !1, fa !== null && vi(fa) && (fa = null), Ka !== null && vi(Ka) && (Ka = null), Xa !== null && vi(Xa) && (Xa = null), Zs.forEach(Tl), wa.forEach(Tl);
  }
  function Gs(Se, Ce) {
    Se.blockedOn === Ce && (Se.blockedOn = null, Gn || (Gn = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, bi)));
  }
  function cu(Se) {
    function Ce(Xe) {
      return Gs(Xe, Se);
    }
    if (0 < Ws.length) {
      Gs(Ws[0], Se);
      for (var Fe = 1; Fe < Ws.length; Fe++) {
        var Ue = Ws[Fe];
        Ue.blockedOn === Se && (Ue.blockedOn = null);
      }
    }
    for (fa !== null && Gs(fa, Se), Ka !== null && Gs(Ka, Se), Xa !== null && Gs(Xa, Se), Zs.forEach(Ce), wa.forEach(Ce), Fe = 0; Fe < Lo.length; Fe++)
      Ue = Lo[Fe], Ue.blockedOn === Se && (Ue.blockedOn = null);
    for (; 0 < Lo.length && (Fe = Lo[0], Fe.blockedOn === null); )
      il(Fe), Fe.blockedOn === null && Lo.shift();
  }
  var gi = Ct.ReactCurrentBatchConfig, Mi = !0;
  function du(Se, Ce, Fe, Ue) {
    var Xe = jo, it = gi.transition;
    gi.transition = null;
    try {
      jo = 1, sl(Se, Ce, Fe, Ue);
    } finally {
      jo = Xe, gi.transition = it;
    }
  }
  function Ps(Se, Ce, Fe, Ue) {
    var Xe = jo, it = gi.transition;
    gi.transition = null;
    try {
      jo = 4, sl(Se, Ce, Fe, Ue);
    } finally {
      jo = Xe, gi.transition = it;
    }
  }
  function sl(Se, Ce, Fe, Ue) {
    if (Mi) {
      var Xe = ul(Se, Ce, Fe, Ue);
      if (Xe === null)
        mm(Se, Ce, Ue, Wu, Fe), Ii(Se, Ue);
      else if (Ss(Xe, Se, Ce, Fe, Ue))
        Ue.stopPropagation();
      else if (Ii(Se, Ue), Ce & 4 && -1 < Pl.indexOf(Se)) {
        for (; Xe !== null; ) {
          var it = Sp(Xe);
          if (it !== null && hc(it), it = ul(Se, Ce, Fe, Ue), it === null && mm(Se, Ce, Ue, Wu, Fe), it === Xe)
            break;
          Xe = it;
        }
        Xe !== null && Ue.stopPropagation();
      } else
        mm(Se, Ce, Ue, null, Fe);
    }
  }
  var Wu = null;
  function ul(Se, Ce, Fe, Ue) {
    if (Wu = null, Se = Qn(Ue), Se = mu(Se), Se !== null)
      if (Ce = mn(Se), Ce === null)
        Se = null;
      else if (Fe = Ce.tag, Fe === 13) {
        if (Se = En(Ce), Se !== null)
          return Se;
        Se = null;
      } else if (Fe === 3) {
        if (Ce.stateNode.current.memoizedState.isDehydrated)
          return Ce.tag === 3 ? Ce.stateNode.containerInfo : null;
        Se = null;
      } else
        Ce !== Se && (Se = null);
    return Wu = Se, null;
  }
  function kl(Se) {
    switch (Se) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (qu()) {
          case si:
            return 1;
          case oo:
            return 4;
          case da:
          case xs:
            return 16;
          case as:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ge = null, gt = null, jt = null;
  function Ht() {
    if (jt)
      return jt;
    var Se, Ce = gt, Fe = Ce.length, Ue, Xe = "value" in Ge ? Ge.value : Ge.textContent, it = Xe.length;
    for (Se = 0; Se < Fe && Ce[Se] === Xe[Se]; Se++)
      ;
    var $t = Fe - Se;
    for (Ue = 1; Ue <= $t && Ce[Fe - Ue] === Xe[it - Ue]; Ue++)
      ;
    return jt = Xe.slice(Se, 1 < Ue ? 1 - Ue : void 0);
  }
  function sr(Se) {
    var Ce = Se.keyCode;
    return "charCode" in Se ? (Se = Se.charCode, Se === 0 && Ce === 13 && (Se = 13)) : Se = Ce, Se === 10 && (Se = 13), 32 <= Se || Se === 13 ? Se : 0;
  }
  function Fr() {
    return !0;
  }
  function Or() {
    return !1;
  }
  function Br(Se) {
    function Ce(Fe, Ue, Xe, it, $t) {
      this._reactName = Fe, this._targetInst = Xe, this.type = Ue, this.nativeEvent = it, this.target = $t, this.currentTarget = null;
      for (var Kt in Se)
        Se.hasOwnProperty(Kt) && (Fe = Se[Kt], this[Kt] = Fe ? Fe(it) : it[Kt]);
      return this.isDefaultPrevented = (it.defaultPrevented != null ? it.defaultPrevented : it.returnValue === !1) ? Fr : Or, this.isPropagationStopped = Or, this;
    }
    return ot(Ce.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var Fe = this.nativeEvent;
      Fe && (Fe.preventDefault ? Fe.preventDefault() : typeof Fe.returnValue != "unknown" && (Fe.returnValue = !1), this.isDefaultPrevented = Fr);
    }, stopPropagation: function() {
      var Fe = this.nativeEvent;
      Fe && (Fe.stopPropagation ? Fe.stopPropagation() : typeof Fe.cancelBubble != "unknown" && (Fe.cancelBubble = !0), this.isPropagationStopped = Fr);
    }, persist: function() {
    }, isPersistent: Fr }), Ce;
  }
  var Kr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(Se) {
    return Se.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Sn = Br(Kr), In = ot({}, Kr, { view: 0, detail: 0 }), Un = Br(In), Vn, mo, ko, oa = ot({}, In, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ky, button: 0, buttons: 0, relatedTarget: function(Se) {
    return Se.relatedTarget === void 0 ? Se.fromElement === Se.srcElement ? Se.toElement : Se.fromElement : Se.relatedTarget;
  }, movementX: function(Se) {
    return "movementX" in Se ? Se.movementX : (Se !== ko && (ko && Se.type === "mousemove" ? (Vn = Se.screenX - ko.screenX, mo = Se.screenY - ko.screenY) : mo = Vn = 0, ko = Se), Vn);
  }, movementY: function(Se) {
    return "movementY" in Se ? Se.movementY : mo;
  } }), fu = Br(oa), mc = ot({}, oa, { dataTransfer: 0 }), uf = Br(mc), ad = ot({}, In, { relatedTarget: 0 }), pu = Br(ad), Ol = ot({}, Kr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), lf = Br(Ol), n_ = ot({}, Kr, { clipboardData: function(Se) {
    return "clipboardData" in Se ? Se.clipboardData : window.clipboardData;
  } }), o_ = Br(n_), a_ = ot({}, Kr, { data: 0 }), Yy = Br(a_), Qy = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Gb = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Yb = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Qb(Se) {
    var Ce = this.nativeEvent;
    return Ce.getModifierState ? Ce.getModifierState(Se) : (Se = Yb[Se]) ? !!Ce[Se] : !1;
  }
  function Ky() {
    return Qb;
  }
  var Al = ot({}, In, { key: function(Se) {
    if (Se.key) {
      var Ce = Qy[Se.key] || Se.key;
      if (Ce !== "Unidentified")
        return Ce;
    }
    return Se.type === "keypress" ? (Se = sr(Se), Se === 13 ? "Enter" : String.fromCharCode(Se)) : Se.type === "keydown" || Se.type === "keyup" ? Gb[Se.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ky, charCode: function(Se) {
    return Se.type === "keypress" ? sr(Se) : 0;
  }, keyCode: function(Se) {
    return Se.type === "keydown" || Se.type === "keyup" ? Se.keyCode : 0;
  }, which: function(Se) {
    return Se.type === "keypress" ? sr(Se) : Se.type === "keydown" || Se.type === "keyup" ? Se.keyCode : 0;
  } }), i_ = Br(Al), Xy = ot({}, oa, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), im = Br(Xy), Jy = ot({}, In, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ky }), s_ = Br(Jy), sm = ot({}, Kr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Kb = Br(sm), Ts = ot({}, oa, { deltaX: function(Se) {
    return "deltaX" in Se ? Se.deltaX : "wheelDeltaX" in Se ? -Se.wheelDeltaX : 0;
  }, deltaY: function(Se) {
    return "deltaY" in Se ? Se.deltaY : "wheelDeltaY" in Se ? -Se.wheelDeltaY : "wheelDelta" in Se ? -Se.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 }), Cl = Br(Ts), ei = [9, 13, 27, 32], Zu = Oe && "CompositionEvent" in window, id = null;
  Oe && "documentMode" in document && (id = document.documentMode);
  var um = Oe && "TextEvent" in window && !id, Xb = Oe && (!Zu || id && 8 < id && 11 >= id), cf = String.fromCharCode(32), Jb = !1;
  function eg(Se, Ce) {
    switch (Se) {
      case "keyup":
        return ei.indexOf(Ce.keyCode) !== -1;
      case "keydown":
        return Ce.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function lm(Se) {
    return Se = Se.detail, typeof Se == "object" && "data" in Se ? Se.data : null;
  }
  var df = !1;
  function u_(Se, Ce) {
    switch (Se) {
      case "compositionend":
        return lm(Ce);
      case "keypress":
        return Ce.which !== 32 ? null : (Jb = !0, cf);
      case "textInput":
        return Se = Ce.data, Se === cf && Jb ? null : Se;
      default:
        return null;
    }
  }
  function l_(Se, Ce) {
    if (df)
      return Se === "compositionend" || !Zu && eg(Se, Ce) ? (Se = Ht(), jt = gt = Ge = null, df = !1, Se) : null;
    switch (Se) {
      case "paste":
        return null;
      case "keypress":
        if (!(Ce.ctrlKey || Ce.altKey || Ce.metaKey) || Ce.ctrlKey && Ce.altKey) {
          if (Ce.char && 1 < Ce.char.length)
            return Ce.char;
          if (Ce.which)
            return String.fromCharCode(Ce.which);
        }
        return null;
      case "compositionend":
        return Xb && Ce.locale !== "ko" ? null : Ce.data;
      default:
        return null;
    }
  }
  var tg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function rg(Se) {
    var Ce = Se && Se.nodeName && Se.nodeName.toLowerCase();
    return Ce === "input" ? !!tg[Se.type] : Ce === "textarea";
  }
  function ng(Se, Ce, Fe, Ue) {
    Oo(Ue), Ce = _p(Ce, "onChange"), 0 < Ce.length && (Fe = new Sn("onChange", "change", null, Fe, Ue), Se.push({ event: Fe, listeners: Ce }));
  }
  var mp = null, ff = null;
  function pf(Se) {
    hm(Se, 0);
  }
  function hf(Se) {
    var Ce = bf(Se);
    if (co(Ce))
      return Se;
  }
  function og(Se, Ce) {
    if (Se === "change")
      return Ce;
  }
  var ev = !1;
  Oe && (Oe ? (cm = "oninput" in document, cm || (rv = document.createElement("div"), rv.setAttribute("oninput", "return;"), cm = typeof rv.oninput == "function"), tv = cm) : tv = !1, ev = tv && (!document.documentMode || 9 < document.documentMode));
  var tv, cm, rv;
  function ag() {
    mp && (mp.detachEvent("onpropertychange", ig), ff = mp = null);
  }
  function ig(Se) {
    if (Se.propertyName === "value" && hf(ff)) {
      var Ce = [];
      ng(Ce, ff, Se, Qn(Se)), po(pf, Ce);
    }
  }
  function c_(Se, Ce, Fe) {
    Se === "focusin" ? (ag(), mp = Ce, ff = Fe, mp.attachEvent("onpropertychange", ig)) : Se === "focusout" && ag();
  }
  function d_(Se) {
    if (Se === "selectionchange" || Se === "keyup" || Se === "keydown")
      return hf(ff);
  }
  function f_(Se, Ce) {
    if (Se === "click")
      return hf(Ce);
  }
  function sg(Se, Ce) {
    if (Se === "input" || Se === "change")
      return hf(Ce);
  }
  function p_(Se, Ce) {
    return Se === Ce && (Se !== 0 || 1 / Se === 1 / Ce) || Se !== Se && Ce !== Ce;
  }
  var hu = typeof Object.is == "function" ? Object.is : p_;
  function yp(Se, Ce) {
    if (hu(Se, Ce))
      return !0;
    if (typeof Se != "object" || Se === null || typeof Ce != "object" || Ce === null)
      return !1;
    var Fe = Object.keys(Se), Ue = Object.keys(Ce);
    if (Fe.length !== Ue.length)
      return !1;
    for (Ue = 0; Ue < Fe.length; Ue++) {
      var Xe = Fe[Ue];
      if (!$e.call(Ce, Xe) || !hu(Se[Xe], Ce[Xe]))
        return !1;
    }
    return !0;
  }
  function ug(Se) {
    for (; Se && Se.firstChild; )
      Se = Se.firstChild;
    return Se;
  }
  function lg(Se, Ce) {
    var Fe = ug(Se);
    Se = 0;
    for (var Ue; Fe; ) {
      if (Fe.nodeType === 3) {
        if (Ue = Se + Fe.textContent.length, Se <= Ce && Ue >= Ce)
          return { node: Fe, offset: Ce - Se };
        Se = Ue;
      }
      e: {
        for (; Fe; ) {
          if (Fe.nextSibling) {
            Fe = Fe.nextSibling;
            break e;
          }
          Fe = Fe.parentNode;
        }
        Fe = void 0;
      }
      Fe = ug(Fe);
    }
  }
  function cg(Se, Ce) {
    return Se && Ce ? Se === Ce ? !0 : Se && Se.nodeType === 3 ? !1 : Ce && Ce.nodeType === 3 ? cg(Se, Ce.parentNode) : "contains" in Se ? Se.contains(Ce) : Se.compareDocumentPosition ? !!(Se.compareDocumentPosition(Ce) & 16) : !1 : !1;
  }
  function dm() {
    for (var Se = window, Ce = kn(); Ce instanceof Se.HTMLIFrameElement; ) {
      try {
        var Fe = typeof Ce.contentWindow.location.href == "string";
      } catch {
        Fe = !1;
      }
      if (Fe)
        Se = Ce.contentWindow;
      else
        break;
      Ce = kn(Se.document);
    }
    return Ce;
  }
  function Ml(Se) {
    var Ce = Se && Se.nodeName && Se.nodeName.toLowerCase();
    return Ce && (Ce === "input" && (Se.type === "text" || Se.type === "search" || Se.type === "tel" || Se.type === "url" || Se.type === "password") || Ce === "textarea" || Se.contentEditable === "true");
  }
  function fm(Se) {
    var Ce = dm(), Fe = Se.focusedElem, Ue = Se.selectionRange;
    if (Ce !== Fe && Fe && Fe.ownerDocument && cg(Fe.ownerDocument.documentElement, Fe)) {
      if (Ue !== null && Ml(Fe)) {
        if (Ce = Ue.start, Se = Ue.end, Se === void 0 && (Se = Ce), "selectionStart" in Fe)
          Fe.selectionStart = Ce, Fe.selectionEnd = Math.min(Se, Fe.value.length);
        else if (Se = (Ce = Fe.ownerDocument || document) && Ce.defaultView || window, Se.getSelection) {
          Se = Se.getSelection();
          var Xe = Fe.textContent.length, it = Math.min(Ue.start, Xe);
          Ue = Ue.end === void 0 ? it : Math.min(Ue.end, Xe), !Se.extend && it > Ue && (Xe = Ue, Ue = it, it = Xe), Xe = lg(Fe, it);
          var $t = lg(Fe, Ue);
          Xe && $t && (Se.rangeCount !== 1 || Se.anchorNode !== Xe.node || Se.anchorOffset !== Xe.offset || Se.focusNode !== $t.node || Se.focusOffset !== $t.offset) && (Ce = Ce.createRange(), Ce.setStart(Xe.node, Xe.offset), Se.removeAllRanges(), it > Ue ? (Se.addRange(Ce), Se.extend($t.node, $t.offset)) : (Ce.setEnd($t.node, $t.offset), Se.addRange(Ce)));
        }
      }
      for (Ce = [], Se = Fe; Se = Se.parentNode; )
        Se.nodeType === 1 && Ce.push({ element: Se, left: Se.scrollLeft, top: Se.scrollTop });
      for (typeof Fe.focus == "function" && Fe.focus(), Fe = 0; Fe < Ce.length; Fe++)
        Se = Ce[Fe], Se.element.scrollLeft = Se.left, Se.element.scrollTop = Se.top;
    }
  }
  var dg = Oe && "documentMode" in document && 11 >= document.documentMode, Gu = null, nv = null, bp = null, ov = !1;
  function fg(Se, Ce, Fe) {
    var Ue = Fe.window === Fe ? Fe.document : Fe.nodeType === 9 ? Fe : Fe.ownerDocument;
    ov || Gu == null || Gu !== kn(Ue) || (Ue = Gu, "selectionStart" in Ue && Ml(Ue) ? Ue = { start: Ue.selectionStart, end: Ue.selectionEnd } : (Ue = (Ue.ownerDocument && Ue.ownerDocument.defaultView || window).getSelection(), Ue = { anchorNode: Ue.anchorNode, anchorOffset: Ue.anchorOffset, focusNode: Ue.focusNode, focusOffset: Ue.focusOffset }), bp && yp(bp, Ue) || (bp = Ue, Ue = _p(nv, "onSelect"), 0 < Ue.length && (Ce = new Sn("onSelect", "select", null, Ce, Fe), Se.push({ event: Ce, listeners: Ue }), Ce.target = Gu)));
  }
  function pm(Se, Ce) {
    var Fe = {};
    return Fe[Se.toLowerCase()] = Ce.toLowerCase(), Fe["Webkit" + Se] = "webkit" + Ce, Fe["Moz" + Se] = "moz" + Ce, Fe;
  }
  var ud = { animationend: pm("Animation", "AnimationEnd"), animationiteration: pm("Animation", "AnimationIteration"), animationstart: pm("Animation", "AnimationStart"), transitionend: pm("Transition", "TransitionEnd") }, av = {}, iv = {};
  Oe && (iv = document.createElement("div").style, "AnimationEvent" in window || (delete ud.animationend.animation, delete ud.animationiteration.animation, delete ud.animationstart.animation), "TransitionEvent" in window || delete ud.transitionend.transition);
  function wi(Se) {
    if (av[Se])
      return av[Se];
    if (!ud[Se])
      return Se;
    var Ce = ud[Se], Fe;
    for (Fe in Ce)
      if (Ce.hasOwnProperty(Fe) && Fe in iv)
        return av[Se] = Ce[Fe];
    return Se;
  }
  var sv = wi("animationend"), pg = wi("animationiteration"), hg = wi("animationstart"), mg = wi("transitionend"), yg = /* @__PURE__ */ new Map(), vg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Rl(Se, Ce) {
    yg.set(Se, Ce), _e(Ce, [Se]);
  }
  for (yc = 0; yc < vg.length; yc++)
    mf = vg[yc], yf = mf.toLowerCase(), bg = mf[0].toUpperCase() + mf.slice(1), Rl(yf, "on" + bg);
  var mf, yf, bg, yc;
  Rl(sv, "onAnimationEnd"), Rl(pg, "onAnimationIteration"), Rl(hg, "onAnimationStart"), Rl("dblclick", "onDoubleClick"), Rl("focusin", "onFocus"), Rl("focusout", "onBlur"), Rl(mg, "onTransitionEnd"), xe("onMouseEnter", ["mouseout", "mouseover"]), xe("onMouseLeave", ["mouseout", "mouseover"]), xe("onPointerEnter", ["pointerout", "pointerover"]), xe("onPointerLeave", ["pointerout", "pointerover"]), _e("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), _e("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), _e("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), _e("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), _e("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), _e("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var gp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), m_ = new Set("cancel close invalid load scroll toggle".split(" ").concat(gp));
  function gg(Se, Ce, Fe) {
    var Ue = Se.type || "unknown-event";
    Se.currentTarget = Fe, vn(Ue, Ce, void 0, Se), Se.currentTarget = null;
  }
  function hm(Se, Ce) {
    Ce = (Ce & 4) !== 0;
    for (var Fe = 0; Fe < Se.length; Fe++) {
      var Ue = Se[Fe], Xe = Ue.event;
      Ue = Ue.listeners;
      e: {
        var it = void 0;
        if (Ce)
          for (var $t = Ue.length - 1; 0 <= $t; $t--) {
            var Kt = Ue[$t], rr = Kt.instance, Sr = Kt.currentTarget;
            if (Kt = Kt.listener, rr !== it && Xe.isPropagationStopped())
              break e;
            gg(Xe, Kt, Sr), it = rr;
          }
        else
          for ($t = 0; $t < Ue.length; $t++) {
            if (Kt = Ue[$t], rr = Kt.instance, Sr = Kt.currentTarget, Kt = Kt.listener, rr !== it && Xe.isPropagationStopped())
              break e;
            gg(Xe, Kt, Sr), it = rr;
          }
      }
    }
    if (To)
      throw Se = Qt, To = !1, Qt = null, Se;
  }
  function ua(Se, Ce) {
    var Fe = Ce[hv];
    Fe === void 0 && (Fe = Ce[hv] = /* @__PURE__ */ new Set());
    var Ue = Se + "__bubble";
    Fe.has(Ue) || (wg(Ce, Se, 2, !1), Fe.add(Ue));
  }
  function vc(Se, Ce, Fe) {
    var Ue = 0;
    Ce && (Ue |= 4), wg(Fe, Se, Ue, Ce);
  }
  var Nl = "_reactListening" + Math.random().toString(36).slice(2);
  function vf(Se) {
    if (!Se[Nl]) {
      Se[Nl] = !0, ye.forEach(function(Fe) {
        Fe !== "selectionchange" && (m_.has(Fe) || vc(Fe, !1, Se), vc(Fe, !0, Se));
      });
      var Ce = Se.nodeType === 9 ? Se : Se.ownerDocument;
      Ce === null || Ce[Nl] || (Ce[Nl] = !0, vc("selectionchange", !1, Ce));
    }
  }
  function wg(Se, Ce, Fe, Ue) {
    switch (kl(Ce)) {
      case 1:
        var Xe = du;
        break;
      case 4:
        Xe = Ps;
        break;
      default:
        Xe = sl;
    }
    Fe = Xe.bind(null, Ce, Fe, Se), Xe = void 0, !Ba || Ce !== "touchstart" && Ce !== "touchmove" && Ce !== "wheel" || (Xe = !0), Ue ? Xe !== void 0 ? Se.addEventListener(Ce, Fe, { capture: !0, passive: Xe }) : Se.addEventListener(Ce, Fe, !0) : Xe !== void 0 ? Se.addEventListener(Ce, Fe, { passive: Xe }) : Se.addEventListener(Ce, Fe, !1);
  }
  function mm(Se, Ce, Fe, Ue, Xe) {
    var it = Ue;
    if (!(Ce & 1) && !(Ce & 2) && Ue !== null)
      e:
        for (; ; ) {
          if (Ue === null)
            return;
          var $t = Ue.tag;
          if ($t === 3 || $t === 4) {
            var Kt = Ue.stateNode.containerInfo;
            if (Kt === Xe || Kt.nodeType === 8 && Kt.parentNode === Xe)
              break;
            if ($t === 4)
              for ($t = Ue.return; $t !== null; ) {
                var rr = $t.tag;
                if ((rr === 3 || rr === 4) && (rr = $t.stateNode.containerInfo, rr === Xe || rr.nodeType === 8 && rr.parentNode === Xe))
                  return;
                $t = $t.return;
              }
            for (; Kt !== null; ) {
              if ($t = mu(Kt), $t === null)
                return;
              if (rr = $t.tag, rr === 5 || rr === 6) {
                Ue = it = $t;
                continue e;
              }
              Kt = Kt.parentNode;
            }
          }
          Ue = Ue.return;
        }
    po(function() {
      var Sr = it, zr = Qn(Fe), Hr = [];
      e: {
        var Ur = yg.get(Se);
        if (Ur !== void 0) {
          var dn = Sn, gn = Se;
          switch (Se) {
            case "keypress":
              if (sr(Fe) === 0)
                break e;
            case "keydown":
            case "keyup":
              dn = i_;
              break;
            case "focusin":
              gn = "focus", dn = pu;
              break;
            case "focusout":
              gn = "blur", dn = pu;
              break;
            case "beforeblur":
            case "afterblur":
              dn = pu;
              break;
            case "click":
              if (Fe.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              dn = fu;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              dn = uf;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              dn = s_;
              break;
            case sv:
            case pg:
            case hg:
              dn = lf;
              break;
            case mg:
              dn = Kb;
              break;
            case "scroll":
              dn = Un;
              break;
            case "wheel":
              dn = Cl;
              break;
            case "copy":
            case "cut":
            case "paste":
              dn = o_;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              dn = im;
          }
          var _n = (Ce & 4) !== 0, Va = !_n && Se === "scroll", vr = _n ? Ur !== null ? Ur + "Capture" : null : Ur;
          _n = [];
          for (var ar = Sr, wr; ar !== null; ) {
            wr = ar;
            var Yr = wr.stateNode;
            if (wr.tag === 5 && Yr !== null && (wr = Yr, vr !== null && (Yr = _o(ar, vr), Yr != null && _n.push(wp(ar, Yr, wr)))), Va)
              break;
            ar = ar.return;
          }
          0 < _n.length && (Ur = new dn(Ur, gn, null, Fe, zr), Hr.push({ event: Ur, listeners: _n }));
        }
      }
      if (!(Ce & 7)) {
        e: {
          if (Ur = Se === "mouseover" || Se === "pointerover", dn = Se === "mouseout" || Se === "pointerout", Ur && Fe !== tn && (gn = Fe.relatedTarget || Fe.fromElement) && (mu(gn) || gn[Dl]))
            break e;
          if ((dn || Ur) && (Ur = zr.window === zr ? zr : (Ur = zr.ownerDocument) ? Ur.defaultView || Ur.parentWindow : window, dn ? (gn = Fe.relatedTarget || Fe.toElement, dn = Sr, gn = gn ? mu(gn) : null, gn !== null && (Va = mn(gn), gn !== Va || gn.tag !== 5 && gn.tag !== 6) && (gn = null)) : (dn = null, gn = Sr), dn !== gn)) {
            if (_n = fu, Yr = "onMouseLeave", vr = "onMouseEnter", ar = "mouse", (Se === "pointerout" || Se === "pointerover") && (_n = im, Yr = "onPointerLeave", vr = "onPointerEnter", ar = "pointer"), Va = dn == null ? Ur : bf(dn), wr = gn == null ? Ur : bf(gn), Ur = new _n(Yr, ar + "leave", dn, Fe, zr), Ur.target = Va, Ur.relatedTarget = wr, Yr = null, mu(zr) === Sr && (_n = new _n(vr, ar + "enter", gn, Fe, zr), _n.target = wr, _n.relatedTarget = Va, Yr = _n), Va = Yr, dn && gn)
              t: {
                for (_n = dn, vr = gn, ar = 0, wr = _n; wr; wr = ld(wr))
                  ar++;
                for (wr = 0, Yr = vr; Yr; Yr = ld(Yr))
                  wr++;
                for (; 0 < ar - wr; )
                  _n = ld(_n), ar--;
                for (; 0 < wr - ar; )
                  vr = ld(vr), wr--;
                for (; ar--; ) {
                  if (_n === vr || vr !== null && _n === vr.alternate)
                    break t;
                  _n = ld(_n), vr = ld(vr);
                }
                _n = null;
              }
            else
              _n = null;
            dn !== null && uv(Hr, Ur, dn, _n, !1), gn !== null && Va !== null && uv(Hr, Va, gn, _n, !0);
          }
        }
        e: {
          if (Ur = Sr ? bf(Sr) : window, dn = Ur.nodeName && Ur.nodeName.toLowerCase(), dn === "select" || dn === "input" && Ur.type === "file")
            var an = og;
          else if (rg(Ur))
            if (ev)
              an = sg;
            else {
              an = d_;
              var Mn = c_;
            }
          else
            (dn = Ur.nodeName) && dn.toLowerCase() === "input" && (Ur.type === "checkbox" || Ur.type === "radio") && (an = f_);
          if (an && (an = an(Se, Sr))) {
            ng(Hr, an, Fe, zr);
            break e;
          }
          Mn && Mn(Se, Ur, Sr), Se === "focusout" && (Mn = Ur._wrapperState) && Mn.controlled && Ur.type === "number" && jn(Ur, "number", Ur.value);
        }
        switch (Mn = Sr ? bf(Sr) : window, Se) {
          case "focusin":
            (rg(Mn) || Mn.contentEditable === "true") && (Gu = Mn, nv = Sr, bp = null);
            break;
          case "focusout":
            bp = nv = Gu = null;
            break;
          case "mousedown":
            ov = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ov = !1, fg(Hr, Fe, zr);
            break;
          case "selectionchange":
            if (dg)
              break;
          case "keydown":
          case "keyup":
            fg(Hr, Fe, zr);
        }
        var Dn;
        if (Zu)
          e: {
            switch (Se) {
              case "compositionstart":
                var ao = "onCompositionStart";
                break e;
              case "compositionend":
                ao = "onCompositionEnd";
                break e;
              case "compositionupdate":
                ao = "onCompositionUpdate";
                break e;
            }
            ao = void 0;
          }
        else
          df ? eg(Se, Fe) && (ao = "onCompositionEnd") : Se === "keydown" && Fe.keyCode === 229 && (ao = "onCompositionStart");
        ao && (Xb && Fe.locale !== "ko" && (df || ao !== "onCompositionStart" ? ao === "onCompositionEnd" && df && (Dn = Ht()) : (Ge = zr, gt = "value" in Ge ? Ge.value : Ge.textContent, df = !0)), Mn = _p(Sr, ao), 0 < Mn.length && (ao = new Yy(ao, Se, null, Fe, zr), Hr.push({ event: ao, listeners: Mn }), Dn ? ao.data = Dn : (Dn = lm(Fe), Dn !== null && (ao.data = Dn)))), (Dn = um ? u_(Se, Fe) : l_(Se, Fe)) && (Sr = _p(Sr, "onBeforeInput"), 0 < Sr.length && (zr = new Yy("onBeforeInput", "beforeinput", null, Fe, zr), Hr.push({ event: zr, listeners: Sr }), zr.data = Dn));
      }
      hm(Hr, Ce);
    });
  }
  function wp(Se, Ce, Fe) {
    return { instance: Se, listener: Ce, currentTarget: Fe };
  }
  function _p(Se, Ce) {
    for (var Fe = Ce + "Capture", Ue = []; Se !== null; ) {
      var Xe = Se, it = Xe.stateNode;
      Xe.tag === 5 && it !== null && (Xe = it, it = _o(Se, Fe), it != null && Ue.unshift(wp(Se, it, Xe)), it = _o(Se, Ce), it != null && Ue.push(wp(Se, it, Xe))), Se = Se.return;
    }
    return Ue;
  }
  function ld(Se) {
    if (Se === null)
      return null;
    do
      Se = Se.return;
    while (Se && Se.tag !== 5);
    return Se || null;
  }
  function uv(Se, Ce, Fe, Ue, Xe) {
    for (var it = Ce._reactName, $t = []; Fe !== null && Fe !== Ue; ) {
      var Kt = Fe, rr = Kt.alternate, Sr = Kt.stateNode;
      if (rr !== null && rr === Ue)
        break;
      Kt.tag === 5 && Sr !== null && (Kt = Sr, Xe ? (rr = _o(Fe, it), rr != null && $t.unshift(wp(Fe, rr, Kt))) : Xe || (rr = _o(Fe, it), rr != null && $t.push(wp(Fe, rr, Kt)))), Fe = Fe.return;
    }
    $t.length !== 0 && Se.push({ event: Ce, listeners: $t });
  }
  var lv = /\r\n?/g, y_ = /\u0000|\uFFFD/g;
  function cv(Se) {
    return (typeof Se == "string" ? Se : "" + Se).replace(lv, `
`).replace(y_, "");
  }
  function ym(Se, Ce, Fe) {
    if (Ce = cv(Ce), cv(Se) !== Ce && Fe)
      throw Error(fe(425));
  }
  function vm() {
  }
  var dv = null, bd = null;
  function xp(Se, Ce) {
    return Se === "textarea" || Se === "noscript" || typeof Ce.children == "string" || typeof Ce.children == "number" || typeof Ce.dangerouslySetInnerHTML == "object" && Ce.dangerouslySetInnerHTML !== null && Ce.dangerouslySetInnerHTML.__html != null;
  }
  var wd = typeof setTimeout == "function" ? setTimeout : void 0, _g = typeof clearTimeout == "function" ? clearTimeout : void 0, fv = typeof Promise == "function" ? Promise : void 0, pv = typeof queueMicrotask == "function" ? queueMicrotask : typeof fv < "u" ? function(Se) {
    return fv.resolve(null).then(Se).catch(v_);
  } : wd;
  function v_(Se) {
    setTimeout(function() {
      throw Se;
    });
  }
  function bc(Se, Ce) {
    var Fe = Ce, Ue = 0;
    do {
      var Xe = Fe.nextSibling;
      if (Se.removeChild(Fe), Xe && Xe.nodeType === 8)
        if (Fe = Xe.data, Fe === "/$") {
          if (Ue === 0) {
            Se.removeChild(Xe), cu(Ce);
            return;
          }
          Ue--;
        } else
          Fe !== "$" && Fe !== "$?" && Fe !== "$!" || Ue++;
      Fe = Xe;
    } while (Fe);
    cu(Ce);
  }
  function Yu(Se) {
    for (; Se != null; Se = Se.nextSibling) {
      var Ce = Se.nodeType;
      if (Ce === 1 || Ce === 3)
        break;
      if (Ce === 8) {
        if (Ce = Se.data, Ce === "$" || Ce === "$!" || Ce === "$?")
          break;
        if (Ce === "/$")
          return null;
      }
    }
    return Se;
  }
  function Ep(Se) {
    Se = Se.previousSibling;
    for (var Ce = 0; Se; ) {
      if (Se.nodeType === 8) {
        var Fe = Se.data;
        if (Fe === "$" || Fe === "$!" || Fe === "$?") {
          if (Ce === 0)
            return Se;
          Ce--;
        } else
          Fe === "/$" && Ce++;
      }
      Se = Se.previousSibling;
    }
    return null;
  }
  var gc = Math.random().toString(36).slice(2), ll = "__reactFiber$" + gc, _d = "__reactProps$" + gc, Dl = "__reactContainer$" + gc, hv = "__reactEvents$" + gc, b_ = "__reactListeners$" + gc, mv = "__reactHandles$" + gc;
  function mu(Se) {
    var Ce = Se[ll];
    if (Ce)
      return Ce;
    for (var Fe = Se.parentNode; Fe; ) {
      if (Ce = Fe[Dl] || Fe[ll]) {
        if (Fe = Ce.alternate, Ce.child !== null || Fe !== null && Fe.child !== null)
          for (Se = Ep(Se); Se !== null; ) {
            if (Fe = Se[ll])
              return Fe;
            Se = Ep(Se);
          }
        return Ce;
      }
      Se = Fe, Fe = Se.parentNode;
    }
    return null;
  }
  function Sp(Se) {
    return Se = Se[ll] || Se[Dl], !Se || Se.tag !== 5 && Se.tag !== 6 && Se.tag !== 13 && Se.tag !== 3 ? null : Se;
  }
  function bf(Se) {
    if (Se.tag === 5 || Se.tag === 6)
      return Se.stateNode;
    throw Error(fe(33));
  }
  function Nn(Se) {
    return Se[_d] || null;
  }
  var wc = [], xa = -1;
  function go(Se) {
    return { current: Se };
  }
  function Xo(Se) {
    0 > xa || (Se.current = wc[xa], wc[xa] = null, xa--);
  }
  function ea(Se, Ce) {
    xa++, wc[xa] = Se.current, Se.current = Ce;
  }
  var cl = {}, Jn = go(cl), Fa = go(!1), ks = cl;
  function yu(Se, Ce) {
    var Fe = Se.type.contextTypes;
    if (!Fe)
      return cl;
    var Ue = Se.stateNode;
    if (Ue && Ue.__reactInternalMemoizedUnmaskedChildContext === Ce)
      return Ue.__reactInternalMemoizedMaskedChildContext;
    var Xe = {}, it;
    for (it in Fe)
      Xe[it] = Ce[it];
    return Ue && (Se = Se.stateNode, Se.__reactInternalMemoizedUnmaskedChildContext = Ce, Se.__reactInternalMemoizedMaskedChildContext = Xe), Xe;
  }
  function Oa(Se) {
    return Se = Se.childContextTypes, Se != null;
  }
  function vu() {
    Xo(Fa), Xo(Jn);
  }
  function Pc(Se, Ce, Fe) {
    if (Jn.current !== cl)
      throw Error(fe(168));
    ea(Jn, Ce), ea(Fa, Fe);
  }
  function Pp(Se, Ce, Fe) {
    var Ue = Se.stateNode;
    if (Ce = Ce.childContextTypes, typeof Ue.getChildContext != "function")
      return Fe;
    Ue = Ue.getChildContext();
    for (var Xe in Ue)
      if (!(Xe in Ce))
        throw Error(fe(108, Dr(Se) || "Unknown", Xe));
    return ot({}, Fe, Ue);
  }
  function bm(Se) {
    return Se = (Se = Se.stateNode) && Se.__reactInternalMemoizedMergedChildContext || cl, ks = Jn.current, ea(Jn, Se), ea(Fa, Fa.current), !0;
  }
  function xg(Se, Ce, Fe) {
    var Ue = Se.stateNode;
    if (!Ue)
      throw Error(fe(169));
    Fe ? (Se = Pp(Se, Ce, ks), Ue.__reactInternalMemoizedMergedChildContext = Se, Xo(Fa), Xo(Jn), ea(Jn, Se)) : Xo(Fa), ea(Fa, Fe);
  }
  var Ys = null, xi = !1, Tp = !1;
  function yv(Se) {
    Ys === null ? Ys = [Se] : Ys.push(Se);
  }
  function vv(Se) {
    xi = !0, yv(Se);
  }
  function Os() {
    if (!Tp && Ys !== null) {
      Tp = !0;
      var Se = 0, Ce = jo;
      try {
        var Fe = Ys;
        for (jo = 1; Se < Fe.length; Se++) {
          var Ue = Fe[Se];
          do
            Ue = Ue(!0);
          while (Ue !== null);
        }
        Ys = null, xi = !1;
      } catch (Xe) {
        throw Ys !== null && (Ys = Ys.slice(Se + 1)), Zo(si, Os), Xe;
      } finally {
        jo = Ce, Tp = !1;
      }
    }
    return null;
  }
  var kc = [], As = 0, xd = null, gf = 0, Cs = [], rs = 0, bu = null, Ri = 1, Bl = "";
  function Qs(Se, Ce) {
    kc[As++] = gf, kc[As++] = xd, xd = Se, gf = Ce;
  }
  function bv(Se, Ce, Fe) {
    Cs[rs++] = Ri, Cs[rs++] = Bl, Cs[rs++] = bu, bu = Se;
    var Ue = Ri;
    Se = Bl;
    var Xe = 32 - ka(Ue) - 1;
    Ue &= ~(1 << Xe), Fe += 1;
    var it = 32 - ka(Ce) + Xe;
    if (30 < it) {
      var $t = Xe - Xe % 5;
      it = (Ue & (1 << $t) - 1).toString(32), Ue >>= $t, Xe -= $t, Ri = 1 << 32 - ka(Ce) + Xe | Fe << Xe | Ue, Bl = it + Se;
    } else
      Ri = 1 << it | Fe << Xe | Ue, Bl = Se;
  }
  function gm(Se) {
    Se.return !== null && (Qs(Se, 1), bv(Se, 1, 0));
  }
  function gv(Se) {
    for (; Se === xd; )
      xd = kc[--As], kc[As] = null, gf = kc[--As], kc[As] = null;
    for (; Se === bu; )
      bu = Cs[--rs], Cs[rs] = null, Bl = Cs[--rs], Cs[rs] = null, Ri = Cs[--rs], Cs[rs] = null;
  }
  var Ks = null, $s = null, Ea = !1, gu = null;
  function wv(Se, Ce) {
    var Fe = Fu(5, null, null, 0);
    Fe.elementType = "DELETED", Fe.stateNode = Ce, Fe.return = Se, Ce = Se.deletions, Ce === null ? (Se.deletions = [Fe], Se.flags |= 16) : Ce.push(Fe);
  }
  function Eg(Se, Ce) {
    switch (Se.tag) {
      case 5:
        var Fe = Se.type;
        return Ce = Ce.nodeType !== 1 || Fe.toLowerCase() !== Ce.nodeName.toLowerCase() ? null : Ce, Ce !== null ? (Se.stateNode = Ce, Ks = Se, $s = Yu(Ce.firstChild), !0) : !1;
      case 6:
        return Ce = Se.pendingProps === "" || Ce.nodeType !== 3 ? null : Ce, Ce !== null ? (Se.stateNode = Ce, Ks = Se, $s = null, !0) : !1;
      case 13:
        return Ce = Ce.nodeType !== 8 ? null : Ce, Ce !== null ? (Fe = bu !== null ? { id: Ri, overflow: Bl } : null, Se.memoizedState = { dehydrated: Ce, treeContext: Fe, retryLane: 1073741824 }, Fe = Fu(18, null, null, 0), Fe.stateNode = Ce, Fe.return = Se, Se.child = Fe, Ks = Se, $s = null, !0) : !1;
      default:
        return !1;
    }
  }
  function wm(Se) {
    return (Se.mode & 1) !== 0 && (Se.flags & 128) === 0;
  }
  function _m(Se) {
    if (Ea) {
      var Ce = $s;
      if (Ce) {
        var Fe = Ce;
        if (!Eg(Se, Ce)) {
          if (wm(Se))
            throw Error(fe(418));
          Ce = Yu(Fe.nextSibling);
          var Ue = Ks;
          Ce && Eg(Se, Ce) ? wv(Ue, Fe) : (Se.flags = Se.flags & -4097 | 2, Ea = !1, Ks = Se);
        }
      } else {
        if (wm(Se))
          throw Error(fe(418));
        Se.flags = Se.flags & -4097 | 2, Ea = !1, Ks = Se;
      }
    }
  }
  function Sg(Se) {
    for (Se = Se.return; Se !== null && Se.tag !== 5 && Se.tag !== 3 && Se.tag !== 13; )
      Se = Se.return;
    Ks = Se;
  }
  function xm(Se) {
    if (Se !== Ks)
      return !1;
    if (!Ea)
      return Sg(Se), Ea = !0, !1;
    var Ce;
    if ((Ce = Se.tag !== 3) && !(Ce = Se.tag !== 5) && (Ce = Se.type, Ce = Ce !== "head" && Ce !== "body" && !xp(Se.type, Se.memoizedProps)), Ce && (Ce = $s)) {
      if (wm(Se))
        throw Pg(), Error(fe(418));
      for (; Ce; )
        wv(Se, Ce), Ce = Yu(Ce.nextSibling);
    }
    if (Sg(Se), Se.tag === 13) {
      if (Se = Se.memoizedState, Se = Se !== null ? Se.dehydrated : null, !Se)
        throw Error(fe(317));
      e: {
        for (Se = Se.nextSibling, Ce = 0; Se; ) {
          if (Se.nodeType === 8) {
            var Fe = Se.data;
            if (Fe === "/$") {
              if (Ce === 0) {
                $s = Yu(Se.nextSibling);
                break e;
              }
              Ce--;
            } else
              Fe !== "$" && Fe !== "$!" && Fe !== "$?" || Ce++;
          }
          Se = Se.nextSibling;
        }
        $s = null;
      }
    } else
      $s = Ks ? Yu(Se.stateNode.nextSibling) : null;
    return !0;
  }
  function Pg() {
    for (var Se = $s; Se; )
      Se = Yu(Se.nextSibling);
  }
  function Ia() {
    $s = Ks = null, Ea = !1;
  }
  function _v(Se) {
    gu === null ? gu = [Se] : gu.push(Se);
  }
  var Em = Ct.ReactCurrentBatchConfig;
  function Xs(Se, Ce) {
    if (Se && Se.defaultProps) {
      Ce = ot({}, Ce), Se = Se.defaultProps;
      for (var Fe in Se)
        Ce[Fe] === void 0 && (Ce[Fe] = Se[Fe]);
      return Ce;
    }
    return Ce;
  }
  var dl = go(null), Sm = null, Ac = null, xv = null;
  function Ev() {
    xv = Ac = Sm = null;
  }
  function $c(Se) {
    var Ce = dl.current;
    Xo(dl), Se._currentValue = Ce;
  }
  function Ei(Se, Ce, Fe) {
    for (; Se !== null; ) {
      var Ue = Se.alternate;
      if ((Se.childLanes & Ce) !== Ce ? (Se.childLanes |= Ce, Ue !== null && (Ue.childLanes |= Ce)) : Ue !== null && (Ue.childLanes & Ce) !== Ce && (Ue.childLanes |= Ce), Se === Fe)
        break;
      Se = Se.return;
    }
  }
  function Xr(Se, Ce) {
    Sm = Se, xv = Ac = null, Se = Se.dependencies, Se !== null && Se.firstContext !== null && (Se.lanes & Ce && (ti = !0), Se.firstContext = null);
  }
  function za(Se) {
    var Ce = Se._currentValue;
    if (xv !== Se)
      if (Se = { context: Se, memoizedValue: Ce, next: null }, Ac === null) {
        if (Sm === null)
          throw Error(fe(308));
        Ac = Se, Sm.dependencies = { lanes: 0, firstContext: Se };
      } else
        Ac = Ac.next = Se;
    return Ce;
  }
  var Ni = null;
  function Sv(Se) {
    Ni === null ? Ni = [Se] : Ni.push(Se);
  }
  function Tg(Se, Ce, Fe, Ue) {
    var Xe = Ce.interleaved;
    return Xe === null ? (Fe.next = Fe, Sv(Ce)) : (Fe.next = Xe.next, Xe.next = Fe), Ce.interleaved = Fe, Vl(Se, Ue);
  }
  function Vl(Se, Ce) {
    Se.lanes |= Ce;
    var Fe = Se.alternate;
    for (Fe !== null && (Fe.lanes |= Ce), Fe = Se, Se = Se.return; Se !== null; )
      Se.childLanes |= Ce, Fe = Se.alternate, Fe !== null && (Fe.childLanes |= Ce), Fe = Se, Se = Se.return;
    return Fe.tag === 3 ? Fe.stateNode : null;
  }
  var Ic = !1;
  function Pv(Se) {
    Se.updateQueue = { baseState: Se.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function ci(Se, Ce) {
    Se = Se.updateQueue, Ce.updateQueue === Se && (Ce.updateQueue = { baseState: Se.baseState, firstBaseUpdate: Se.firstBaseUpdate, lastBaseUpdate: Se.lastBaseUpdate, shared: Se.shared, effects: Se.effects });
  }
  function Hl(Se, Ce) {
    return { eventTime: Se, lane: Ce, tag: 0, payload: null, callback: null, next: null };
  }
  function Mc(Se, Ce, Fe) {
    var Ue = Se.updateQueue;
    if (Ue === null)
      return null;
    if (Ue = Ue.shared, Io & 2) {
      var Xe = Ue.pending;
      return Xe === null ? Ce.next = Ce : (Ce.next = Xe.next, Xe.next = Ce), Ue.pending = Ce, Vl(Se, Fe);
    }
    return Xe = Ue.interleaved, Xe === null ? (Ce.next = Ce, Sv(Ue)) : (Ce.next = Xe.next, Xe.next = Ce), Ue.interleaved = Ce, Vl(Se, Fe);
  }
  function Pm(Se, Ce, Fe) {
    if (Ce = Ce.updateQueue, Ce !== null && (Ce = Ce.shared, (Fe & 4194240) !== 0)) {
      var Ue = Ce.lanes;
      Ue &= Se.pendingLanes, Fe |= Ue, Ce.lanes = Fe, qs(Se, Fe);
    }
  }
  function Tv(Se, Ce) {
    var Fe = Se.updateQueue, Ue = Se.alternate;
    if (Ue !== null && (Ue = Ue.updateQueue, Fe === Ue)) {
      var Xe = null, it = null;
      if (Fe = Fe.firstBaseUpdate, Fe !== null) {
        do {
          var $t = { eventTime: Fe.eventTime, lane: Fe.lane, tag: Fe.tag, payload: Fe.payload, callback: Fe.callback, next: null };
          it === null ? Xe = it = $t : it = it.next = $t, Fe = Fe.next;
        } while (Fe !== null);
        it === null ? Xe = it = Ce : it = it.next = Ce;
      } else
        Xe = it = Ce;
      Fe = { baseState: Ue.baseState, firstBaseUpdate: Xe, lastBaseUpdate: it, shared: Ue.shared, effects: Ue.effects }, Se.updateQueue = Fe;
      return;
    }
    Se = Fe.lastBaseUpdate, Se === null ? Fe.firstBaseUpdate = Ce : Se.next = Ce, Fe.lastBaseUpdate = Ce;
  }
  function Nc(Se, Ce, Fe, Ue) {
    var Xe = Se.updateQueue;
    Ic = !1;
    var it = Xe.firstBaseUpdate, $t = Xe.lastBaseUpdate, Kt = Xe.shared.pending;
    if (Kt !== null) {
      Xe.shared.pending = null;
      var rr = Kt, Sr = rr.next;
      rr.next = null, $t === null ? it = Sr : $t.next = Sr, $t = rr;
      var zr = Se.alternate;
      zr !== null && (zr = zr.updateQueue, Kt = zr.lastBaseUpdate, Kt !== $t && (Kt === null ? zr.firstBaseUpdate = Sr : Kt.next = Sr, zr.lastBaseUpdate = rr));
    }
    if (it !== null) {
      var Hr = Xe.baseState;
      $t = 0, zr = Sr = rr = null, Kt = it;
      do {
        var Ur = Kt.lane, dn = Kt.eventTime;
        if ((Ue & Ur) === Ur) {
          zr !== null && (zr = zr.next = { eventTime: dn, lane: 0, tag: Kt.tag, payload: Kt.payload, callback: Kt.callback, next: null });
          e: {
            var gn = Se, _n = Kt;
            switch (Ur = Ce, dn = Fe, _n.tag) {
              case 1:
                if (gn = _n.payload, typeof gn == "function") {
                  Hr = gn.call(dn, Hr, Ur);
                  break e;
                }
                Hr = gn;
                break e;
              case 3:
                gn.flags = gn.flags & -65537 | 128;
              case 0:
                if (gn = _n.payload, Ur = typeof gn == "function" ? gn.call(dn, Hr, Ur) : gn, Ur == null)
                  break e;
                Hr = ot({}, Hr, Ur);
                break e;
              case 2:
                Ic = !0;
            }
          }
          Kt.callback !== null && Kt.lane !== 0 && (Se.flags |= 64, Ur = Xe.effects, Ur === null ? Xe.effects = [Kt] : Ur.push(Kt));
        } else
          dn = { eventTime: dn, lane: Ur, tag: Kt.tag, payload: Kt.payload, callback: Kt.callback, next: null }, zr === null ? (Sr = zr = dn, rr = Hr) : zr = zr.next = dn, $t |= Ur;
        if (Kt = Kt.next, Kt === null) {
          if (Kt = Xe.shared.pending, Kt === null)
            break;
          Ur = Kt, Kt = Ur.next, Ur.next = null, Xe.lastBaseUpdate = Ur, Xe.shared.pending = null;
        }
      } while (1);
      if (zr === null && (rr = Hr), Xe.baseState = rr, Xe.firstBaseUpdate = Sr, Xe.lastBaseUpdate = zr, Ce = Xe.shared.interleaved, Ce !== null) {
        Xe = Ce;
        do
          $t |= Xe.lane, Xe = Xe.next;
        while (Xe !== Ce);
      } else
        it === null && (Xe.shared.lanes = 0);
      Ld |= $t, Se.lanes = $t, Se.memoizedState = Hr;
    }
  }
  function Ed(Se, Ce, Fe) {
    if (Se = Ce.effects, Ce.effects = null, Se !== null)
      for (Ce = 0; Ce < Se.length; Ce++) {
        var Ue = Se[Ce], Xe = Ue.callback;
        if (Xe !== null) {
          if (Ue.callback = null, Ue = Fe, typeof Xe != "function")
            throw Error(fe(191, Xe));
          Xe.call(Ue);
        }
      }
  }
  var kg = new oe.Component().refs;
  function kv(Se, Ce, Fe, Ue) {
    Ce = Se.memoizedState, Fe = Fe(Ue, Ce), Fe = Fe == null ? Ce : ot({}, Ce, Fe), Se.memoizedState = Fe, Se.lanes === 0 && (Se.updateQueue.baseState = Fe);
  }
  var Tm = { isMounted: function(Se) {
    return (Se = Se._reactInternals) ? mn(Se) === Se : !1;
  }, enqueueSetState: function(Se, Ce, Fe) {
    Se = Se._reactInternals;
    var Ue = ca(), Xe = ru(Se), it = Hl(Ue, Xe);
    it.payload = Ce, Fe != null && (it.callback = Fe), Ce = Mc(Se, it, Xe), Ce !== null && (nu(Ce, Se, Xe, Ue), Pm(Ce, Se, Xe));
  }, enqueueReplaceState: function(Se, Ce, Fe) {
    Se = Se._reactInternals;
    var Ue = ca(), Xe = ru(Se), it = Hl(Ue, Xe);
    it.tag = 1, it.payload = Ce, Fe != null && (it.callback = Fe), Ce = Mc(Se, it, Xe), Ce !== null && (nu(Ce, Se, Xe, Ue), Pm(Ce, Se, Xe));
  }, enqueueForceUpdate: function(Se, Ce) {
    Se = Se._reactInternals;
    var Fe = ca(), Ue = ru(Se), Xe = Hl(Fe, Ue);
    Xe.tag = 2, Ce != null && (Xe.callback = Ce), Ce = Mc(Se, Xe, Ue), Ce !== null && (nu(Ce, Se, Ue, Fe), Pm(Ce, Se, Ue));
  } };
  function Og(Se, Ce, Fe, Ue, Xe, it, $t) {
    return Se = Se.stateNode, typeof Se.shouldComponentUpdate == "function" ? Se.shouldComponentUpdate(Ue, it, $t) : Ce.prototype && Ce.prototype.isPureReactComponent ? !yp(Fe, Ue) || !yp(Xe, it) : !0;
  }
  function Ag(Se, Ce, Fe) {
    var Ue = !1, Xe = cl, it = Ce.contextType;
    return typeof it == "object" && it !== null ? it = za(it) : (Xe = Oa(Ce) ? ks : Jn.current, Ue = Ce.contextTypes, it = (Ue = Ue != null) ? yu(Se, Xe) : cl), Ce = new Ce(Fe, it), Se.memoizedState = Ce.state !== null && Ce.state !== void 0 ? Ce.state : null, Ce.updater = Tm, Se.stateNode = Ce, Ce._reactInternals = Se, Ue && (Se = Se.stateNode, Se.__reactInternalMemoizedUnmaskedChildContext = Xe, Se.__reactInternalMemoizedMaskedChildContext = it), Ce;
  }
  function Cg(Se, Ce, Fe, Ue) {
    Se = Ce.state, typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps(Fe, Ue), typeof Ce.UNSAFE_componentWillReceiveProps == "function" && Ce.UNSAFE_componentWillReceiveProps(Fe, Ue), Ce.state !== Se && Tm.enqueueReplaceState(Ce, Ce.state, null);
  }
  function km(Se, Ce, Fe, Ue) {
    var Xe = Se.stateNode;
    Xe.props = Fe, Xe.state = Se.memoizedState, Xe.refs = kg, Pv(Se);
    var it = Ce.contextType;
    typeof it == "object" && it !== null ? Xe.context = za(it) : (it = Oa(Ce) ? ks : Jn.current, Xe.context = yu(Se, it)), Xe.state = Se.memoizedState, it = Ce.getDerivedStateFromProps, typeof it == "function" && (kv(Se, Ce, it, Fe), Xe.state = Se.memoizedState), typeof Ce.getDerivedStateFromProps == "function" || typeof Xe.getSnapshotBeforeUpdate == "function" || typeof Xe.UNSAFE_componentWillMount != "function" && typeof Xe.componentWillMount != "function" || (Ce = Xe.state, typeof Xe.componentWillMount == "function" && Xe.componentWillMount(), typeof Xe.UNSAFE_componentWillMount == "function" && Xe.UNSAFE_componentWillMount(), Ce !== Xe.state && Tm.enqueueReplaceState(Xe, Xe.state, null), Nc(Se, Fe, Xe, Ue), Xe.state = Se.memoizedState), typeof Xe.componentDidMount == "function" && (Se.flags |= 4194308);
  }
  function wf(Se, Ce, Fe) {
    if (Se = Fe.ref, Se !== null && typeof Se != "function" && typeof Se != "object") {
      if (Fe._owner) {
        if (Fe = Fe._owner, Fe) {
          if (Fe.tag !== 1)
            throw Error(fe(309));
          var Ue = Fe.stateNode;
        }
        if (!Ue)
          throw Error(fe(147, Se));
        var Xe = Ue, it = "" + Se;
        return Ce !== null && Ce.ref !== null && typeof Ce.ref == "function" && Ce.ref._stringRef === it ? Ce.ref : (Ce = function($t) {
          var Kt = Xe.refs;
          Kt === kg && (Kt = Xe.refs = {}), $t === null ? delete Kt[it] : Kt[it] = $t;
        }, Ce._stringRef = it, Ce);
      }
      if (typeof Se != "string")
        throw Error(fe(284));
      if (!Fe._owner)
        throw Error(fe(290, Se));
    }
    return Se;
  }
  function Om(Se, Ce) {
    throw Se = Object.prototype.toString.call(Ce), Error(fe(31, Se === "[object Object]" ? "object with keys {" + Object.keys(Ce).join(", ") + "}" : Se));
  }
  function $g(Se) {
    var Ce = Se._init;
    return Ce(Se._payload);
  }
  function Ig(Se) {
    function Ce(vr, ar) {
      if (Se) {
        var wr = vr.deletions;
        wr === null ? (vr.deletions = [ar], vr.flags |= 16) : wr.push(ar);
      }
    }
    function Fe(vr, ar) {
      if (!Se)
        return null;
      for (; ar !== null; )
        Ce(vr, ar), ar = ar.sibling;
      return null;
    }
    function Ue(vr, ar) {
      for (vr = /* @__PURE__ */ new Map(); ar !== null; )
        ar.key !== null ? vr.set(ar.key, ar) : vr.set(ar.index, ar), ar = ar.sibling;
      return vr;
    }
    function Xe(vr, ar) {
      return vr = Hc(vr, ar), vr.index = 0, vr.sibling = null, vr;
    }
    function it(vr, ar, wr) {
      return vr.index = wr, Se ? (wr = vr.alternate, wr !== null ? (wr = wr.index, wr < ar ? (vr.flags |= 2, ar) : wr) : (vr.flags |= 2, ar)) : (vr.flags |= 1048576, ar);
    }
    function $t(vr) {
      return Se && vr.alternate === null && (vr.flags |= 2), vr;
    }
    function Kt(vr, ar, wr, Yr) {
      return ar === null || ar.tag !== 6 ? (ar = qd(wr, vr.mode, Yr), ar.return = vr, ar) : (ar = Xe(ar, wr), ar.return = vr, ar);
    }
    function rr(vr, ar, wr, Yr) {
      var an = wr.type;
      return an === Ut ? zr(vr, ar, wr.props.children, Yr, wr.key) : ar !== null && (ar.elementType === an || typeof an == "object" && an !== null && an.$$typeof === bt && $g(an) === ar.type) ? (Yr = Xe(ar, wr.props), Yr.ref = wf(vr, ar, wr), Yr.return = vr, Yr) : (Yr = dy(wr.type, wr.key, wr.props, null, vr.mode, Yr), Yr.ref = wf(vr, ar, wr), Yr.return = vr, Yr);
    }
    function Sr(vr, ar, wr, Yr) {
      return ar === null || ar.tag !== 4 || ar.stateNode.containerInfo !== wr.containerInfo || ar.stateNode.implementation !== wr.implementation ? (ar = Gv(wr, vr.mode, Yr), ar.return = vr, ar) : (ar = Xe(ar, wr.children || []), ar.return = vr, ar);
    }
    function zr(vr, ar, wr, Yr, an) {
      return ar === null || ar.tag !== 7 ? (ar = qc(wr, vr.mode, Yr, an), ar.return = vr, ar) : (ar = Xe(ar, wr), ar.return = vr, ar);
    }
    function Hr(vr, ar, wr) {
      if (typeof ar == "string" && ar !== "" || typeof ar == "number")
        return ar = qd("" + ar, vr.mode, wr), ar.return = vr, ar;
      if (typeof ar == "object" && ar !== null) {
        switch (ar.$$typeof) {
          case It:
            return wr = dy(ar.type, ar.key, ar.props, null, vr.mode, wr), wr.ref = wf(vr, null, ar), wr.return = vr, wr;
          case Vt:
            return ar = Gv(ar, vr.mode, wr), ar.return = vr, ar;
          case bt:
            var Yr = ar._init;
            return Hr(vr, Yr(ar._payload), wr);
        }
        if (Xn(ar) || Gt(ar))
          return ar = qc(ar, vr.mode, wr, null), ar.return = vr, ar;
        Om(vr, ar);
      }
      return null;
    }
    function Ur(vr, ar, wr, Yr) {
      var an = ar !== null ? ar.key : null;
      if (typeof wr == "string" && wr !== "" || typeof wr == "number")
        return an !== null ? null : Kt(vr, ar, "" + wr, Yr);
      if (typeof wr == "object" && wr !== null) {
        switch (wr.$$typeof) {
          case It:
            return wr.key === an ? rr(vr, ar, wr, Yr) : null;
          case Vt:
            return wr.key === an ? Sr(vr, ar, wr, Yr) : null;
          case bt:
            return an = wr._init, Ur(vr, ar, an(wr._payload), Yr);
        }
        if (Xn(wr) || Gt(wr))
          return an !== null ? null : zr(vr, ar, wr, Yr, null);
        Om(vr, wr);
      }
      return null;
    }
    function dn(vr, ar, wr, Yr, an) {
      if (typeof Yr == "string" && Yr !== "" || typeof Yr == "number")
        return vr = vr.get(wr) || null, Kt(ar, vr, "" + Yr, an);
      if (typeof Yr == "object" && Yr !== null) {
        switch (Yr.$$typeof) {
          case It:
            return vr = vr.get(Yr.key === null ? wr : Yr.key) || null, rr(ar, vr, Yr, an);
          case Vt:
            return vr = vr.get(Yr.key === null ? wr : Yr.key) || null, Sr(ar, vr, Yr, an);
          case bt:
            var Mn = Yr._init;
            return dn(vr, ar, wr, Mn(Yr._payload), an);
        }
        if (Xn(Yr) || Gt(Yr))
          return vr = vr.get(wr) || null, zr(ar, vr, Yr, an, null);
        Om(ar, Yr);
      }
      return null;
    }
    function gn(vr, ar, wr, Yr) {
      for (var an = null, Mn = null, Dn = ar, ao = ar = 0, hi = null; Dn !== null && ao < wr.length; ao++) {
        Dn.index > ao ? (hi = Dn, Dn = null) : hi = Dn.sibling;
        var Go = Ur(vr, Dn, wr[ao], Yr);
        if (Go === null) {
          Dn === null && (Dn = hi);
          break;
        }
        Se && Dn && Go.alternate === null && Ce(vr, Dn), ar = it(Go, ar, ao), Mn === null ? an = Go : Mn.sibling = Go, Mn = Go, Dn = hi;
      }
      if (ao === wr.length)
        return Fe(vr, Dn), Ea && Qs(vr, ao), an;
      if (Dn === null) {
        for (; ao < wr.length; ao++)
          Dn = Hr(vr, wr[ao], Yr), Dn !== null && (ar = it(Dn, ar, ao), Mn === null ? an = Dn : Mn.sibling = Dn, Mn = Dn);
        return Ea && Qs(vr, ao), an;
      }
      for (Dn = Ue(vr, Dn); ao < wr.length; ao++)
        hi = dn(Dn, vr, ao, wr[ao], Yr), hi !== null && (Se && hi.alternate !== null && Dn.delete(hi.key === null ? ao : hi.key), ar = it(hi, ar, ao), Mn === null ? an = hi : Mn.sibling = hi, Mn = hi);
      return Se && Dn.forEach(function(Zc) {
        return Ce(vr, Zc);
      }), Ea && Qs(vr, ao), an;
    }
    function _n(vr, ar, wr, Yr) {
      var an = Gt(wr);
      if (typeof an != "function")
        throw Error(fe(150));
      if (wr = an.call(wr), wr == null)
        throw Error(fe(151));
      for (var Mn = an = null, Dn = ar, ao = ar = 0, hi = null, Go = wr.next(); Dn !== null && !Go.done; ao++, Go = wr.next()) {
        Dn.index > ao ? (hi = Dn, Dn = null) : hi = Dn.sibling;
        var Zc = Ur(vr, Dn, Go.value, Yr);
        if (Zc === null) {
          Dn === null && (Dn = hi);
          break;
        }
        Se && Dn && Zc.alternate === null && Ce(vr, Dn), ar = it(Zc, ar, ao), Mn === null ? an = Zc : Mn.sibling = Zc, Mn = Zc, Dn = hi;
      }
      if (Go.done)
        return Fe(vr, Dn), Ea && Qs(vr, ao), an;
      if (Dn === null) {
        for (; !Go.done; ao++, Go = wr.next())
          Go = Hr(vr, Go.value, Yr), Go !== null && (ar = it(Go, ar, ao), Mn === null ? an = Go : Mn.sibling = Go, Mn = Go);
        return Ea && Qs(vr, ao), an;
      }
      for (Dn = Ue(vr, Dn); !Go.done; ao++, Go = wr.next())
        Go = dn(Dn, vr, ao, Go.value, Yr), Go !== null && (Se && Go.alternate !== null && Dn.delete(Go.key === null ? ao : Go.key), ar = it(Go, ar, ao), Mn === null ? an = Go : Mn.sibling = Go, Mn = Go);
      return Se && Dn.forEach(function(j_) {
        return Ce(vr, j_);
      }), Ea && Qs(vr, ao), an;
    }
    function Va(vr, ar, wr, Yr) {
      if (typeof wr == "object" && wr !== null && wr.type === Ut && wr.key === null && (wr = wr.props.children), typeof wr == "object" && wr !== null) {
        switch (wr.$$typeof) {
          case It:
            e: {
              for (var an = wr.key, Mn = ar; Mn !== null; ) {
                if (Mn.key === an) {
                  if (an = wr.type, an === Ut) {
                    if (Mn.tag === 7) {
                      Fe(vr, Mn.sibling), ar = Xe(Mn, wr.props.children), ar.return = vr, vr = ar;
                      break e;
                    }
                  } else if (Mn.elementType === an || typeof an == "object" && an !== null && an.$$typeof === bt && $g(an) === Mn.type) {
                    Fe(vr, Mn.sibling), ar = Xe(Mn, wr.props), ar.ref = wf(vr, Mn, wr), ar.return = vr, vr = ar;
                    break e;
                  }
                  Fe(vr, Mn);
                  break;
                } else
                  Ce(vr, Mn);
                Mn = Mn.sibling;
              }
              wr.type === Ut ? (ar = qc(wr.props.children, vr.mode, Yr, wr.key), ar.return = vr, vr = ar) : (Yr = dy(wr.type, wr.key, wr.props, null, vr.mode, Yr), Yr.ref = wf(vr, ar, wr), Yr.return = vr, vr = Yr);
            }
            return $t(vr);
          case Vt:
            e: {
              for (Mn = wr.key; ar !== null; ) {
                if (ar.key === Mn)
                  if (ar.tag === 4 && ar.stateNode.containerInfo === wr.containerInfo && ar.stateNode.implementation === wr.implementation) {
                    Fe(vr, ar.sibling), ar = Xe(ar, wr.children || []), ar.return = vr, vr = ar;
                    break e;
                  } else {
                    Fe(vr, ar);
                    break;
                  }
                else
                  Ce(vr, ar);
                ar = ar.sibling;
              }
              ar = Gv(wr, vr.mode, Yr), ar.return = vr, vr = ar;
            }
            return $t(vr);
          case bt:
            return Mn = wr._init, Va(vr, ar, Mn(wr._payload), Yr);
        }
        if (Xn(wr))
          return gn(vr, ar, wr, Yr);
        if (Gt(wr))
          return _n(vr, ar, wr, Yr);
        Om(vr, wr);
      }
      return typeof wr == "string" && wr !== "" || typeof wr == "number" ? (wr = "" + wr, ar !== null && ar.tag === 6 ? (Fe(vr, ar.sibling), ar = Xe(ar, wr), ar.return = vr, vr = ar) : (Fe(vr, ar), ar = qd(wr, vr.mode, Yr), ar.return = vr, vr = ar), $t(vr)) : Fe(vr, ar);
    }
    return Va;
  }
  var _f = Ig(!0), Mg = Ig(!1), kp = {}, Qu = go(kp), Ap = go(kp), xf = go(kp);
  function Pd(Se) {
    if (Se === kp)
      throw Error(fe(174));
    return Se;
  }
  function Ov(Se, Ce) {
    switch (ea(xf, Ce), ea(Ap, Se), ea(Qu, kp), Se = Ce.nodeType, Se) {
      case 9:
      case 11:
        Ce = (Ce = Ce.documentElement) ? Ce.namespaceURI : Jo(null, "");
        break;
      default:
        Se = Se === 8 ? Ce.parentNode : Ce, Ce = Se.namespaceURI || null, Se = Se.tagName, Ce = Jo(Ce, Se);
    }
    Xo(Qu), ea(Qu, Ce);
  }
  function jc() {
    Xo(Qu), Xo(Ap), Xo(xf);
  }
  function Ln(Se) {
    Pd(xf.current);
    var Ce = Pd(Qu.current), Fe = Jo(Ce, Se.type);
    Ce !== Fe && (ea(Ap, Se), ea(Qu, Fe));
  }
  function $o(Se) {
    Ap.current === Se && (Xo(Qu), Xo(Ap));
  }
  var qn = go(0);
  function Ma(Se) {
    for (var Ce = Se; Ce !== null; ) {
      if (Ce.tag === 13) {
        var Fe = Ce.memoizedState;
        if (Fe !== null && (Fe = Fe.dehydrated, Fe === null || Fe.data === "$?" || Fe.data === "$!"))
          return Ce;
      } else if (Ce.tag === 19 && Ce.memoizedProps.revealOrder !== void 0) {
        if (Ce.flags & 128)
          return Ce;
      } else if (Ce.child !== null) {
        Ce.child.return = Ce, Ce = Ce.child;
        continue;
      }
      if (Ce === Se)
        break;
      for (; Ce.sibling === null; ) {
        if (Ce.return === null || Ce.return === Se)
          return null;
        Ce = Ce.return;
      }
      Ce.sibling.return = Ce.return, Ce = Ce.sibling;
    }
    return null;
  }
  var _u = [];
  function Am() {
    for (var Se = 0; Se < _u.length; Se++)
      _u[Se]._workInProgressVersionPrimary = null;
    _u.length = 0;
  }
  var Cm = Ct.ReactCurrentDispatcher, Av = Ct.ReactCurrentBatchConfig, Td = 0, Sa = null, Ir = null, Uo = null, Wn = !1, fl = !1, Js = 0, Od = 0;
  function Pa() {
    throw Error(fe(321));
  }
  function Ad(Se, Ce) {
    if (Ce === null)
      return !1;
    for (var Fe = 0; Fe < Ce.length && Fe < Se.length; Fe++)
      if (!hu(Se[Fe], Ce[Fe]))
        return !1;
    return !0;
  }
  function Fc(Se, Ce, Fe, Ue, Xe, it) {
    if (Td = it, Sa = Ce, Ce.memoizedState = null, Ce.updateQueue = null, Ce.lanes = 0, Cm.current = Se === null || Se.memoizedState === null ? w_ : __, Se = Fe(Ue, Xe), fl) {
      it = 0;
      do {
        if (fl = !1, Js = 0, 25 <= it)
          throw Error(fe(301));
        it += 1, Uo = Ir = null, Ce.updateQueue = null, Cm.current = $v, Se = Fe(Ue, Xe);
      } while (fl);
    }
    if (Cm.current = Wm, Ce = Ir !== null && Ir.next !== null, Td = 0, Uo = Ir = Sa = null, Wn = !1, Ce)
      throw Error(fe(300));
    return Se;
  }
  function Cd() {
    var Se = Js !== 0;
    return Js = 0, Se;
  }
  function Su() {
    var Se = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Uo === null ? Sa.memoizedState = Uo = Se : Uo = Uo.next = Se, Uo;
  }
  function Is() {
    if (Ir === null) {
      var Se = Sa.alternate;
      Se = Se !== null ? Se.memoizedState : null;
    } else
      Se = Ir.next;
    var Ce = Uo === null ? Sa.memoizedState : Uo.next;
    if (Ce !== null)
      Uo = Ce, Ir = Se;
    else {
      if (Se === null)
        throw Error(fe(310));
      Ir = Se, Se = { memoizedState: Ir.memoizedState, baseState: Ir.baseState, baseQueue: Ir.baseQueue, queue: Ir.queue, next: null }, Uo === null ? Sa.memoizedState = Uo = Se : Uo = Uo.next = Se;
    }
    return Uo;
  }
  function $d(Se, Ce) {
    return typeof Ce == "function" ? Ce(Se) : Ce;
  }
  function Cp(Se) {
    var Ce = Is(), Fe = Ce.queue;
    if (Fe === null)
      throw Error(fe(311));
    Fe.lastRenderedReducer = Se;
    var Ue = Ir, Xe = Ue.baseQueue, it = Fe.pending;
    if (it !== null) {
      if (Xe !== null) {
        var $t = Xe.next;
        Xe.next = it.next, it.next = $t;
      }
      Ue.baseQueue = Xe = it, Fe.pending = null;
    }
    if (Xe !== null) {
      it = Xe.next, Ue = Ue.baseState;
      var Kt = $t = null, rr = null, Sr = it;
      do {
        var zr = Sr.lane;
        if ((Td & zr) === zr)
          rr !== null && (rr = rr.next = { lane: 0, action: Sr.action, hasEagerState: Sr.hasEagerState, eagerState: Sr.eagerState, next: null }), Ue = Sr.hasEagerState ? Sr.eagerState : Se(Ue, Sr.action);
        else {
          var Hr = { lane: zr, action: Sr.action, hasEagerState: Sr.hasEagerState, eagerState: Sr.eagerState, next: null };
          rr === null ? (Kt = rr = Hr, $t = Ue) : rr = rr.next = Hr, Sa.lanes |= zr, Ld |= zr;
        }
        Sr = Sr.next;
      } while (Sr !== null && Sr !== it);
      rr === null ? $t = Ue : rr.next = Kt, hu(Ue, Ce.memoizedState) || (ti = !0), Ce.memoizedState = Ue, Ce.baseState = $t, Ce.baseQueue = rr, Fe.lastRenderedState = Ue;
    }
    if (Se = Fe.interleaved, Se !== null) {
      Xe = Se;
      do
        it = Xe.lane, Sa.lanes |= it, Ld |= it, Xe = Xe.next;
      while (Xe !== Se);
    } else
      Xe === null && (Fe.lanes = 0);
    return [Ce.memoizedState, Fe.dispatch];
  }
  function $p(Se) {
    var Ce = Is(), Fe = Ce.queue;
    if (Fe === null)
      throw Error(fe(311));
    Fe.lastRenderedReducer = Se;
    var Ue = Fe.dispatch, Xe = Fe.pending, it = Ce.memoizedState;
    if (Xe !== null) {
      Fe.pending = null;
      var $t = Xe = Xe.next;
      do
        it = Se(it, $t.action), $t = $t.next;
      while ($t !== Xe);
      hu(it, Ce.memoizedState) || (ti = !0), Ce.memoizedState = it, Ce.baseQueue === null && (Ce.baseState = it), Fe.lastRenderedState = it;
    }
    return [it, Ue];
  }
  function $m() {
  }
  function Im(Se, Ce) {
    var Fe = Sa, Ue = Is(), Xe = Ce(), it = !hu(Ue.memoizedState, Xe);
    if (it && (Ue.memoizedState = Xe, ti = !0), Ue = Ue.queue, Ip(Nm.bind(null, Fe, Ue, Se), [Se]), Ue.getSnapshot !== Ce || it || Uo !== null && Uo.memoizedState.tag & 1) {
      if (Fe.flags |= 2048, Id(9, Rm.bind(null, Fe, Ue, Xe, Ce), void 0, null), ri === null)
        throw Error(fe(349));
      Td & 30 || Mm(Fe, Ce, Xe);
    }
    return Xe;
  }
  function Mm(Se, Ce, Fe) {
    Se.flags |= 16384, Se = { getSnapshot: Ce, value: Fe }, Ce = Sa.updateQueue, Ce === null ? (Ce = { lastEffect: null, stores: null }, Sa.updateQueue = Ce, Ce.stores = [Se]) : (Fe = Ce.stores, Fe === null ? Ce.stores = [Se] : Fe.push(Se));
  }
  function Rm(Se, Ce, Fe, Ue) {
    Ce.value = Fe, Ce.getSnapshot = Ue, jm(Ce) && Fm(Se);
  }
  function Nm(Se, Ce, Fe) {
    return Fe(function() {
      jm(Ce) && Fm(Se);
    });
  }
  function jm(Se) {
    var Ce = Se.getSnapshot;
    Se = Se.value;
    try {
      var Fe = Ce();
      return !hu(Se, Fe);
    } catch {
      return !0;
    }
  }
  function Fm(Se) {
    var Ce = Vl(Se, 1);
    Ce !== null && nu(Ce, Se, 1, -1);
  }
  function Lm(Se) {
    var Ce = Su();
    return typeof Se == "function" && (Se = Se()), Ce.memoizedState = Ce.baseState = Se, Se = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: $d, lastRenderedState: Se }, Ce.queue = Se, Se = Se.dispatch = qm.bind(null, Sa, Se), [Ce.memoizedState, Se];
  }
  function Id(Se, Ce, Fe, Ue) {
    return Se = { tag: Se, create: Ce, destroy: Fe, deps: Ue, next: null }, Ce = Sa.updateQueue, Ce === null ? (Ce = { lastEffect: null, stores: null }, Sa.updateQueue = Ce, Ce.lastEffect = Se.next = Se) : (Fe = Ce.lastEffect, Fe === null ? Ce.lastEffect = Se.next = Se : (Ue = Fe.next, Fe.next = Se, Se.next = Ue, Ce.lastEffect = Se)), Se;
  }
  function Dm() {
    return Is().memoizedState;
  }
  function Md(Se, Ce, Fe, Ue) {
    var Xe = Su();
    Sa.flags |= Se, Xe.memoizedState = Id(1 | Ce, Fe, void 0, Ue === void 0 ? null : Ue);
  }
  function Zl(Se, Ce, Fe, Ue) {
    var Xe = Is();
    Ue = Ue === void 0 ? null : Ue;
    var it = void 0;
    if (Ir !== null) {
      var $t = Ir.memoizedState;
      if (it = $t.destroy, Ue !== null && Ad(Ue, $t.deps)) {
        Xe.memoizedState = Id(Ce, Fe, it, Ue);
        return;
      }
    }
    Sa.flags |= Se, Xe.memoizedState = Id(1 | Ce, Fe, it, Ue);
  }
  function Bm(Se, Ce) {
    return Md(8390656, 8, Se, Ce);
  }
  function Ip(Se, Ce) {
    return Zl(2048, 8, Se, Ce);
  }
  function zm(Se, Ce) {
    return Zl(4, 2, Se, Ce);
  }
  function Um(Se, Ce) {
    return Zl(4, 4, Se, Ce);
  }
  function Cv(Se, Ce) {
    if (typeof Ce == "function")
      return Se = Se(), Ce(Se), function() {
        Ce(null);
      };
    if (Ce != null)
      return Se = Se(), Ce.current = Se, function() {
        Ce.current = null;
      };
  }
  function Ef(Se, Ce, Fe) {
    return Fe = Fe != null ? Fe.concat([Se]) : null, Zl(4, 4, Cv.bind(null, Ce, Se), Fe);
  }
  function Vm() {
  }
  function Sf(Se, Ce) {
    var Fe = Is();
    Ce = Ce === void 0 ? null : Ce;
    var Ue = Fe.memoizedState;
    return Ue !== null && Ce !== null && Ad(Ce, Ue[1]) ? Ue[0] : (Fe.memoizedState = [Se, Ce], Se);
  }
  function Lc(Se, Ce) {
    var Fe = Is();
    Ce = Ce === void 0 ? null : Ce;
    var Ue = Fe.memoizedState;
    return Ue !== null && Ce !== null && Ad(Ce, Ue[1]) ? Ue[0] : (Se = Se(), Fe.memoizedState = [Se, Ce], Se);
  }
  function Ms(Se, Ce, Fe) {
    return Td & 21 ? (hu(Fe, Ce) || (Fe = lu(), Sa.lanes |= Fe, Ld |= Fe, Se.baseState = !0), Ce) : (Se.baseState && (Se.baseState = !1, ti = !0), Se.memoizedState = Fe);
  }
  function g_(Se, Ce) {
    var Fe = jo;
    jo = Fe !== 0 && 4 > Fe ? Fe : 4, Se(!0);
    var Ue = Av.transition;
    Av.transition = {};
    try {
      Se(!1), Ce();
    } finally {
      jo = Fe, Av.transition = Ue;
    }
  }
  function la() {
    return Is().memoizedState;
  }
  function Hm(Se, Ce, Fe) {
    var Ue = ru(Se);
    if (Fe = { lane: Ue, action: Fe, hasEagerState: !1, eagerState: null, next: null }, Pf(Se))
      Mp(Ce, Fe);
    else if (Fe = Tg(Se, Ce, Fe, Ue), Fe !== null) {
      var Xe = ca();
      nu(Fe, Se, Ue, Xe), Rg(Fe, Ce, Ue);
    }
  }
  function qm(Se, Ce, Fe) {
    var Ue = ru(Se), Xe = { lane: Ue, action: Fe, hasEagerState: !1, eagerState: null, next: null };
    if (Pf(Se))
      Mp(Ce, Xe);
    else {
      var it = Se.alternate;
      if (Se.lanes === 0 && (it === null || it.lanes === 0) && (it = Ce.lastRenderedReducer, it !== null))
        try {
          var $t = Ce.lastRenderedState, Kt = it($t, Fe);
          if (Xe.hasEagerState = !0, Xe.eagerState = Kt, hu(Kt, $t)) {
            var rr = Ce.interleaved;
            rr === null ? (Xe.next = Xe, Sv(Ce)) : (Xe.next = rr.next, rr.next = Xe), Ce.interleaved = Xe;
            return;
          }
        } catch {
        } finally {
        }
      Fe = Tg(Se, Ce, Xe, Ue), Fe !== null && (Xe = ca(), nu(Fe, Se, Ue, Xe), Rg(Fe, Ce, Ue));
    }
  }
  function Pf(Se) {
    var Ce = Se.alternate;
    return Se === Sa || Ce !== null && Ce === Sa;
  }
  function Mp(Se, Ce) {
    fl = Wn = !0;
    var Fe = Se.pending;
    Fe === null ? Ce.next = Ce : (Ce.next = Fe.next, Fe.next = Ce), Se.pending = Ce;
  }
  function Rg(Se, Ce, Fe) {
    if (Fe & 4194240) {
      var Ue = Ce.lanes;
      Ue &= Se.pendingLanes, Fe |= Ue, Ce.lanes = Fe, qs(Se, Fe);
    }
  }
  var Wm = { readContext: za, useCallback: Pa, useContext: Pa, useEffect: Pa, useImperativeHandle: Pa, useInsertionEffect: Pa, useLayoutEffect: Pa, useMemo: Pa, useReducer: Pa, useRef: Pa, useState: Pa, useDebugValue: Pa, useDeferredValue: Pa, useTransition: Pa, useMutableSource: Pa, useSyncExternalStore: Pa, useId: Pa, unstable_isNewReconciler: !1 }, w_ = { readContext: za, useCallback: function(Se, Ce) {
    return Su().memoizedState = [Se, Ce === void 0 ? null : Ce], Se;
  }, useContext: za, useEffect: Bm, useImperativeHandle: function(Se, Ce, Fe) {
    return Fe = Fe != null ? Fe.concat([Se]) : null, Md(4194308, 4, Cv.bind(null, Ce, Se), Fe);
  }, useLayoutEffect: function(Se, Ce) {
    return Md(4194308, 4, Se, Ce);
  }, useInsertionEffect: function(Se, Ce) {
    return Md(4, 2, Se, Ce);
  }, useMemo: function(Se, Ce) {
    var Fe = Su();
    return Ce = Ce === void 0 ? null : Ce, Se = Se(), Fe.memoizedState = [Se, Ce], Se;
  }, useReducer: function(Se, Ce, Fe) {
    var Ue = Su();
    return Ce = Fe !== void 0 ? Fe(Ce) : Ce, Ue.memoizedState = Ue.baseState = Ce, Se = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Se, lastRenderedState: Ce }, Ue.queue = Se, Se = Se.dispatch = Hm.bind(null, Sa, Se), [Ue.memoizedState, Se];
  }, useRef: function(Se) {
    var Ce = Su();
    return Se = { current: Se }, Ce.memoizedState = Se;
  }, useState: Lm, useDebugValue: Vm, useDeferredValue: function(Se) {
    return Su().memoizedState = Se;
  }, useTransition: function() {
    var Se = Lm(!1), Ce = Se[0];
    return Se = g_.bind(null, Se[1]), Su().memoizedState = Se, [Ce, Se];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(Se, Ce, Fe) {
    var Ue = Sa, Xe = Su();
    if (Ea) {
      if (Fe === void 0)
        throw Error(fe(407));
      Fe = Fe();
    } else {
      if (Fe = Ce(), ri === null)
        throw Error(fe(349));
      Td & 30 || Mm(Ue, Ce, Fe);
    }
    Xe.memoizedState = Fe;
    var it = { value: Fe, getSnapshot: Ce };
    return Xe.queue = it, Bm(Nm.bind(null, Ue, it, Se), [Se]), Ue.flags |= 2048, Id(9, Rm.bind(null, Ue, it, Fe, Ce), void 0, null), Fe;
  }, useId: function() {
    var Se = Su(), Ce = ri.identifierPrefix;
    if (Ea) {
      var Fe = Bl, Ue = Ri;
      Fe = (Ue & ~(1 << 32 - ka(Ue) - 1)).toString(32) + Fe, Ce = ":" + Ce + "R" + Fe, Fe = Js++, 0 < Fe && (Ce += "H" + Fe.toString(32)), Ce += ":";
    } else
      Fe = Od++, Ce = ":" + Ce + "r" + Fe.toString(32) + ":";
    return Se.memoizedState = Ce;
  }, unstable_isNewReconciler: !1 }, __ = { readContext: za, useCallback: Sf, useContext: za, useEffect: Ip, useImperativeHandle: Ef, useInsertionEffect: zm, useLayoutEffect: Um, useMemo: Lc, useReducer: Cp, useRef: Dm, useState: function() {
    return Cp($d);
  }, useDebugValue: Vm, useDeferredValue: function(Se) {
    var Ce = Is();
    return Ms(Ce, Ir.memoizedState, Se);
  }, useTransition: function() {
    var Se = Cp($d)[0], Ce = Is().memoizedState;
    return [Se, Ce];
  }, useMutableSource: $m, useSyncExternalStore: Im, useId: la, unstable_isNewReconciler: !1 }, $v = { readContext: za, useCallback: Sf, useContext: za, useEffect: Ip, useImperativeHandle: Ef, useInsertionEffect: zm, useLayoutEffect: Um, useMemo: Lc, useReducer: $p, useRef: Dm, useState: function() {
    return $p($d);
  }, useDebugValue: Vm, useDeferredValue: function(Se) {
    var Ce = Is();
    return Ir === null ? Ce.memoizedState = Se : Ms(Ce, Ir.memoizedState, Se);
  }, useTransition: function() {
    var Se = $p($d)[0], Ce = Is().memoizedState;
    return [Se, Ce];
  }, useMutableSource: $m, useSyncExternalStore: Im, useId: la, unstable_isNewReconciler: !1 };
  function Tf(Se, Ce) {
    try {
      var Fe = "", Ue = Ce;
      do
        Fe += dr(Ue), Ue = Ue.return;
      while (Ue);
      var Xe = Fe;
    } catch (it) {
      Xe = `
Error generating stack: ` + it.message + `
` + it.stack;
    }
    return { value: Se, source: Ce, stack: Xe, digest: null };
  }
  function Rp(Se, Ce, Fe) {
    return { value: Se, source: null, stack: Fe ?? null, digest: Ce ?? null };
  }
  function Gm(Se, Ce) {
    try {
      console.error(Ce.value);
    } catch (Fe) {
      setTimeout(function() {
        throw Fe;
      });
    }
  }
  var x_ = typeof WeakMap == "function" ? WeakMap : Map;
  function Ng(Se, Ce, Fe) {
    Fe = Hl(-1, Fe), Fe.tag = 3, Fe.payload = { element: null };
    var Ue = Ce.value;
    return Fe.callback = function() {
      zc || (zc = !0, Vp = Ue), Gm(Se, Ce);
    }, Fe;
  }
  function Np(Se, Ce, Fe) {
    Fe = Hl(-1, Fe), Fe.tag = 3;
    var Ue = Se.type.getDerivedStateFromError;
    if (typeof Ue == "function") {
      var Xe = Ce.value;
      Fe.payload = function() {
        return Ue(Xe);
      }, Fe.callback = function() {
        Gm(Se, Ce);
      };
    }
    var it = Se.stateNode;
    return it !== null && typeof it.componentDidCatch == "function" && (Fe.callback = function() {
      Gm(Se, Ce), typeof Ue != "function" && (Iu === null ? Iu = /* @__PURE__ */ new Set([this]) : Iu.add(this));
      var $t = Ce.stack;
      this.componentDidCatch(Ce.value, { componentStack: $t !== null ? $t : "" });
    }), Fe;
  }
  function jg(Se, Ce, Fe) {
    var Ue = Se.pingCache;
    if (Ue === null) {
      Ue = Se.pingCache = new x_();
      var Xe = /* @__PURE__ */ new Set();
      Ue.set(Ce, Xe);
    } else
      Xe = Ue.get(Ce), Xe === void 0 && (Xe = /* @__PURE__ */ new Set(), Ue.set(Ce, Xe));
    Xe.has(Fe) || (Xe.add(Fe), Se = qv.bind(null, Se, Ce, Fe), Ce.then(Se, Se));
  }
  function Iv(Se) {
    do {
      var Ce;
      if ((Ce = Se.tag === 13) && (Ce = Se.memoizedState, Ce = Ce !== null ? Ce.dehydrated !== null : !0), Ce)
        return Se;
      Se = Se.return;
    } while (Se !== null);
    return null;
  }
  function Mv(Se, Ce, Fe, Ue, Xe) {
    return Se.mode & 1 ? (Se.flags |= 65536, Se.lanes = Xe, Se) : (Se === Ce ? Se.flags |= 65536 : (Se.flags |= 128, Fe.flags |= 131072, Fe.flags &= -52805, Fe.tag === 1 && (Fe.alternate === null ? Fe.tag = 17 : (Ce = Hl(-1, 1), Ce.tag = 2, Mc(Fe, Ce, 1))), Fe.lanes |= 1), Se);
  }
  var E_ = Ct.ReactCurrentOwner, ti = !1;
  function di(Se, Ce, Fe, Ue) {
    Ce.child = Se === null ? Mg(Ce, null, Fe, Ue) : _f(Ce, Se.child, Fe, Ue);
  }
  function Dc(Se, Ce, Fe, Ue, Xe) {
    Fe = Fe.render;
    var it = Ce.ref;
    return Xr(Ce, Xe), Ue = Fc(Se, Ce, Fe, Ue, it, Xe), Fe = Cd(), Se !== null && !ti ? (Ce.updateQueue = Se.updateQueue, Ce.flags &= -2053, Se.lanes &= ~Xe, ji(Se, Ce, Xe)) : (Ea && Fe && gm(Ce), Ce.flags |= 1, di(Se, Ce, Ue, Xe), Ce.child);
  }
  function Ym(Se, Ce, Fe, Ue, Xe) {
    if (Se === null) {
      var it = Fe.type;
      return typeof it == "function" && !Zv(it) && it.defaultProps === void 0 && Fe.compare === null && Fe.defaultProps === void 0 ? (Ce.tag = 15, Ce.type = it, Rs(Se, Ce, it, Ue, Xe)) : (Se = dy(Fe.type, null, Ue, Ce, Ce.mode, Xe), Se.ref = Ce.ref, Se.return = Ce, Ce.child = Se);
    }
    if (it = Se.child, !(Se.lanes & Xe)) {
      var $t = it.memoizedProps;
      if (Fe = Fe.compare, Fe = Fe !== null ? Fe : yp, Fe($t, Ue) && Se.ref === Ce.ref)
        return ji(Se, Ce, Xe);
    }
    return Ce.flags |= 1, Se = Hc(it, Ue), Se.ref = Ce.ref, Se.return = Ce, Ce.child = Se;
  }
  function Rs(Se, Ce, Fe, Ue, Xe) {
    if (Se !== null) {
      var it = Se.memoizedProps;
      if (yp(it, Ue) && Se.ref === Ce.ref)
        if (ti = !1, Ce.pendingProps = Ue = it, (Se.lanes & Xe) !== 0)
          Se.flags & 131072 && (ti = !0);
        else
          return Ce.lanes = Se.lanes, ji(Se, Ce, Xe);
    }
    return kf(Se, Ce, Fe, Ue, Xe);
  }
  function Rd(Se, Ce, Fe) {
    var Ue = Ce.pendingProps, Xe = Ue.children, it = Se !== null ? Se.memoizedState : null;
    if (Ue.mode === "hidden")
      if (!(Ce.mode & 1))
        Ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ea($f, tu), tu |= Fe;
      else {
        if (!(Fe & 1073741824))
          return Se = it !== null ? it.baseLanes | Fe : Fe, Ce.lanes = Ce.childLanes = 1073741824, Ce.memoizedState = { baseLanes: Se, cachePool: null, transitions: null }, Ce.updateQueue = null, ea($f, tu), tu |= Se, null;
        Ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ue = it !== null ? it.baseLanes : Fe, ea($f, tu), tu |= Ue;
      }
    else
      it !== null ? (Ue = it.baseLanes | Fe, Ce.memoizedState = null) : Ue = Fe, ea($f, tu), tu |= Ue;
    return di(Se, Ce, Xe, Fe), Ce.child;
  }
  function wo(Se, Ce) {
    var Fe = Ce.ref;
    (Se === null && Fe !== null || Se !== null && Se.ref !== Fe) && (Ce.flags |= 512, Ce.flags |= 2097152);
  }
  function kf(Se, Ce, Fe, Ue, Xe) {
    var it = Oa(Fe) ? ks : Jn.current;
    return it = yu(Ce, it), Xr(Ce, Xe), Fe = Fc(Se, Ce, Fe, Ue, it, Xe), Ue = Cd(), Se !== null && !ti ? (Ce.updateQueue = Se.updateQueue, Ce.flags &= -2053, Se.lanes &= ~Xe, ji(Se, Ce, Xe)) : (Ea && Ue && gm(Ce), Ce.flags |= 1, di(Se, Ce, Fe, Xe), Ce.child);
  }
  function Rv(Se, Ce, Fe, Ue, Xe) {
    if (Oa(Fe)) {
      var it = !0;
      bm(Ce);
    } else
      it = !1;
    if (Xr(Ce, Xe), Ce.stateNode === null)
      Pu(Se, Ce), Ag(Ce, Fe, Ue), km(Ce, Fe, Ue, Xe), Ue = !0;
    else if (Se === null) {
      var $t = Ce.stateNode, Kt = Ce.memoizedProps;
      $t.props = Kt;
      var rr = $t.context, Sr = Fe.contextType;
      typeof Sr == "object" && Sr !== null ? Sr = za(Sr) : (Sr = Oa(Fe) ? ks : Jn.current, Sr = yu(Ce, Sr));
      var zr = Fe.getDerivedStateFromProps, Hr = typeof zr == "function" || typeof $t.getSnapshotBeforeUpdate == "function";
      Hr || typeof $t.UNSAFE_componentWillReceiveProps != "function" && typeof $t.componentWillReceiveProps != "function" || (Kt !== Ue || rr !== Sr) && Cg(Ce, $t, Ue, Sr), Ic = !1;
      var Ur = Ce.memoizedState;
      $t.state = Ur, Nc(Ce, Ue, $t, Xe), rr = Ce.memoizedState, Kt !== Ue || Ur !== rr || Fa.current || Ic ? (typeof zr == "function" && (kv(Ce, Fe, zr, Ue), rr = Ce.memoizedState), (Kt = Ic || Og(Ce, Fe, Kt, Ue, Ur, rr, Sr)) ? (Hr || typeof $t.UNSAFE_componentWillMount != "function" && typeof $t.componentWillMount != "function" || (typeof $t.componentWillMount == "function" && $t.componentWillMount(), typeof $t.UNSAFE_componentWillMount == "function" && $t.UNSAFE_componentWillMount()), typeof $t.componentDidMount == "function" && (Ce.flags |= 4194308)) : (typeof $t.componentDidMount == "function" && (Ce.flags |= 4194308), Ce.memoizedProps = Ue, Ce.memoizedState = rr), $t.props = Ue, $t.state = rr, $t.context = Sr, Ue = Kt) : (typeof $t.componentDidMount == "function" && (Ce.flags |= 4194308), Ue = !1);
    } else {
      $t = Ce.stateNode, ci(Se, Ce), Kt = Ce.memoizedProps, Sr = Ce.type === Ce.elementType ? Kt : Xs(Ce.type, Kt), $t.props = Sr, Hr = Ce.pendingProps, Ur = $t.context, rr = Fe.contextType, typeof rr == "object" && rr !== null ? rr = za(rr) : (rr = Oa(Fe) ? ks : Jn.current, rr = yu(Ce, rr));
      var dn = Fe.getDerivedStateFromProps;
      (zr = typeof dn == "function" || typeof $t.getSnapshotBeforeUpdate == "function") || typeof $t.UNSAFE_componentWillReceiveProps != "function" && typeof $t.componentWillReceiveProps != "function" || (Kt !== Hr || Ur !== rr) && Cg(Ce, $t, Ue, rr), Ic = !1, Ur = Ce.memoizedState, $t.state = Ur, Nc(Ce, Ue, $t, Xe);
      var gn = Ce.memoizedState;
      Kt !== Hr || Ur !== gn || Fa.current || Ic ? (typeof dn == "function" && (kv(Ce, Fe, dn, Ue), gn = Ce.memoizedState), (Sr = Ic || Og(Ce, Fe, Sr, Ue, Ur, gn, rr) || !1) ? (zr || typeof $t.UNSAFE_componentWillUpdate != "function" && typeof $t.componentWillUpdate != "function" || (typeof $t.componentWillUpdate == "function" && $t.componentWillUpdate(Ue, gn, rr), typeof $t.UNSAFE_componentWillUpdate == "function" && $t.UNSAFE_componentWillUpdate(Ue, gn, rr)), typeof $t.componentDidUpdate == "function" && (Ce.flags |= 4), typeof $t.getSnapshotBeforeUpdate == "function" && (Ce.flags |= 1024)) : (typeof $t.componentDidUpdate != "function" || Kt === Se.memoizedProps && Ur === Se.memoizedState || (Ce.flags |= 4), typeof $t.getSnapshotBeforeUpdate != "function" || Kt === Se.memoizedProps && Ur === Se.memoizedState || (Ce.flags |= 1024), Ce.memoizedProps = Ue, Ce.memoizedState = gn), $t.props = Ue, $t.state = gn, $t.context = rr, Ue = Sr) : (typeof $t.componentDidUpdate != "function" || Kt === Se.memoizedProps && Ur === Se.memoizedState || (Ce.flags |= 4), typeof $t.getSnapshotBeforeUpdate != "function" || Kt === Se.memoizedProps && Ur === Se.memoizedState || (Ce.flags |= 1024), Ue = !1);
    }
    return Nv(Se, Ce, Fe, Ue, it, Xe);
  }
  function Nv(Se, Ce, Fe, Ue, Xe, it) {
    wo(Se, Ce);
    var $t = (Ce.flags & 128) !== 0;
    if (!Ue && !$t)
      return Xe && xg(Ce, Fe, !1), ji(Se, Ce, it);
    Ue = Ce.stateNode, E_.current = Ce;
    var Kt = $t && typeof Fe.getDerivedStateFromError != "function" ? null : Ue.render();
    return Ce.flags |= 1, Se !== null && $t ? (Ce.child = _f(Ce, Se.child, null, it), Ce.child = _f(Ce, null, Kt, it)) : di(Se, Ce, Kt, it), Ce.memoizedState = Ue.state, Xe && xg(Ce, Fe, !0), Ce.child;
  }
  function Qm(Se) {
    var Ce = Se.stateNode;
    Ce.pendingContext ? Pc(Se, Ce.pendingContext, Ce.pendingContext !== Ce.context) : Ce.context && Pc(Se, Ce.context, !1), Ov(Se, Ce.containerInfo);
  }
  function Of(Se, Ce, Fe, Ue, Xe) {
    return Ia(), _v(Xe), Ce.flags |= 256, di(Se, Ce, Fe, Ue), Ce.child;
  }
  var jv = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Km(Se) {
    return { baseLanes: Se, cachePool: null, transitions: null };
  }
  function Fg(Se, Ce, Fe) {
    var Ue = Ce.pendingProps, Xe = qn.current, it = !1, $t = (Ce.flags & 128) !== 0, Kt;
    if ((Kt = $t) || (Kt = Se !== null && Se.memoizedState === null ? !1 : (Xe & 2) !== 0), Kt ? (it = !0, Ce.flags &= -129) : (Se === null || Se.memoizedState !== null) && (Xe |= 1), ea(qn, Xe & 1), Se === null)
      return _m(Ce), Se = Ce.memoizedState, Se !== null && (Se = Se.dehydrated, Se !== null) ? (Ce.mode & 1 ? Se.data === "$!" ? Ce.lanes = 8 : Ce.lanes = 1073741824 : Ce.lanes = 1, null) : ($t = Ue.children, Se = Ue.fallback, it ? (Ue = Ce.mode, it = Ce.child, $t = { mode: "hidden", children: $t }, !(Ue & 1) && it !== null ? (it.childLanes = 0, it.pendingProps = $t) : it = Ff($t, Ue, 0, null), Se = qc(Se, Ue, Fe, null), it.return = Ce, Se.return = Ce, it.sibling = Se, Ce.child = it, Ce.child.memoizedState = Km(Fe), Ce.memoizedState = jv, Se) : jp(Ce, $t));
    if (Xe = Se.memoizedState, Xe !== null && (Kt = Xe.dehydrated, Kt !== null))
      return Lg(Se, Ce, $t, Ue, Kt, Xe, Fe);
    if (it) {
      it = Ue.fallback, $t = Ce.mode, Xe = Se.child, Kt = Xe.sibling;
      var rr = { mode: "hidden", children: Ue.children };
      return !($t & 1) && Ce.child !== Xe ? (Ue = Ce.child, Ue.childLanes = 0, Ue.pendingProps = rr, Ce.deletions = null) : (Ue = Hc(Xe, rr), Ue.subtreeFlags = Xe.subtreeFlags & 14680064), Kt !== null ? it = Hc(Kt, it) : (it = qc(it, $t, Fe, null), it.flags |= 2), it.return = Ce, Ue.return = Ce, Ue.sibling = it, Ce.child = Ue, Ue = it, it = Ce.child, $t = Se.child.memoizedState, $t = $t === null ? Km(Fe) : { baseLanes: $t.baseLanes | Fe, cachePool: null, transitions: $t.transitions }, it.memoizedState = $t, it.childLanes = Se.childLanes & ~Fe, Ce.memoizedState = jv, Ue;
    }
    return it = Se.child, Se = it.sibling, Ue = Hc(it, { mode: "visible", children: Ue.children }), !(Ce.mode & 1) && (Ue.lanes = Fe), Ue.return = Ce, Ue.sibling = null, Se !== null && (Fe = Ce.deletions, Fe === null ? (Ce.deletions = [Se], Ce.flags |= 16) : Fe.push(Se)), Ce.child = Ue, Ce.memoizedState = null, Ue;
  }
  function jp(Se, Ce) {
    return Ce = Ff({ mode: "visible", children: Ce }, Se.mode, 0, null), Ce.return = Se, Se.child = Ce;
  }
  function ey(Se, Ce, Fe, Ue) {
    return Ue !== null && _v(Ue), _f(Ce, Se.child, null, Fe), Se = jp(Ce, Ce.pendingProps.children), Se.flags |= 2, Ce.memoizedState = null, Se;
  }
  function Lg(Se, Ce, Fe, Ue, Xe, it, $t) {
    if (Fe)
      return Ce.flags & 256 ? (Ce.flags &= -257, Ue = Rp(Error(fe(422))), ey(Se, Ce, $t, Ue)) : Ce.memoizedState !== null ? (Ce.child = Se.child, Ce.flags |= 128, null) : (it = Ue.fallback, Xe = Ce.mode, Ue = Ff({ mode: "visible", children: Ue.children }, Xe, 0, null), it = qc(it, Xe, $t, null), it.flags |= 2, Ue.return = Ce, it.return = Ce, Ue.sibling = it, Ce.child = Ue, Ce.mode & 1 && _f(Ce, Se.child, null, $t), Ce.child.memoizedState = Km($t), Ce.memoizedState = jv, it);
    if (!(Ce.mode & 1))
      return ey(Se, Ce, $t, null);
    if (Xe.data === "$!") {
      if (Ue = Xe.nextSibling && Xe.nextSibling.dataset, Ue)
        var Kt = Ue.dgst;
      return Ue = Kt, it = Error(fe(419)), Ue = Rp(it, Ue, void 0), ey(Se, Ce, $t, Ue);
    }
    if (Kt = ($t & Se.childLanes) !== 0, ti || Kt) {
      if (Ue = ri, Ue !== null) {
        switch ($t & -$t) {
          case 4:
            Xe = 2;
            break;
          case 16:
            Xe = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            Xe = 32;
            break;
          case 536870912:
            Xe = 268435456;
            break;
          default:
            Xe = 0;
        }
        Xe = Xe & (Ue.suspendedLanes | $t) ? 0 : Xe, Xe !== 0 && Xe !== it.retryLane && (it.retryLane = Xe, Vl(Se, Xe), nu(Ue, Se, Xe, -1));
      }
      return Vv(), Ue = Rp(Error(fe(421))), ey(Se, Ce, $t, Ue);
    }
    return Xe.data === "$?" ? (Ce.flags |= 128, Ce.child = Se.child, Ce = A_.bind(null, Se), Xe._reactRetry = Ce, null) : (Se = it.treeContext, $s = Yu(Xe.nextSibling), Ks = Ce, Ea = !0, gu = null, Se !== null && (Cs[rs++] = Ri, Cs[rs++] = Bl, Cs[rs++] = bu, Ri = Se.id, Bl = Se.overflow, bu = Ce), Ce = jp(Ce, Ue.children), Ce.flags |= 4096, Ce);
  }
  function Fv(Se, Ce, Fe) {
    Se.lanes |= Ce;
    var Ue = Se.alternate;
    Ue !== null && (Ue.lanes |= Ce), Ei(Se.return, Ce, Fe);
  }
  function ty(Se, Ce, Fe, Ue, Xe) {
    var it = Se.memoizedState;
    it === null ? Se.memoizedState = { isBackwards: Ce, rendering: null, renderingStartTime: 0, last: Ue, tail: Fe, tailMode: Xe } : (it.isBackwards = Ce, it.rendering = null, it.renderingStartTime = 0, it.last = Ue, it.tail = Fe, it.tailMode = Xe);
  }
  function Ns(Se, Ce, Fe) {
    var Ue = Ce.pendingProps, Xe = Ue.revealOrder, it = Ue.tail;
    if (di(Se, Ce, Ue.children, Fe), Ue = qn.current, Ue & 2)
      Ue = Ue & 1 | 2, Ce.flags |= 128;
    else {
      if (Se !== null && Se.flags & 128)
        e:
          for (Se = Ce.child; Se !== null; ) {
            if (Se.tag === 13)
              Se.memoizedState !== null && Fv(Se, Fe, Ce);
            else if (Se.tag === 19)
              Fv(Se, Fe, Ce);
            else if (Se.child !== null) {
              Se.child.return = Se, Se = Se.child;
              continue;
            }
            if (Se === Ce)
              break e;
            for (; Se.sibling === null; ) {
              if (Se.return === null || Se.return === Ce)
                break e;
              Se = Se.return;
            }
            Se.sibling.return = Se.return, Se = Se.sibling;
          }
      Ue &= 1;
    }
    if (ea(qn, Ue), !(Ce.mode & 1))
      Ce.memoizedState = null;
    else
      switch (Xe) {
        case "forwards":
          for (Fe = Ce.child, Xe = null; Fe !== null; )
            Se = Fe.alternate, Se !== null && Ma(Se) === null && (Xe = Fe), Fe = Fe.sibling;
          Fe = Xe, Fe === null ? (Xe = Ce.child, Ce.child = null) : (Xe = Fe.sibling, Fe.sibling = null), ty(Ce, !1, Xe, Fe, it);
          break;
        case "backwards":
          for (Fe = null, Xe = Ce.child, Ce.child = null; Xe !== null; ) {
            if (Se = Xe.alternate, Se !== null && Ma(Se) === null) {
              Ce.child = Xe;
              break;
            }
            Se = Xe.sibling, Xe.sibling = Fe, Fe = Xe, Xe = Se;
          }
          ty(Ce, !0, Fe, null, it);
          break;
        case "together":
          ty(Ce, !1, null, null, void 0);
          break;
        default:
          Ce.memoizedState = null;
      }
    return Ce.child;
  }
  function Pu(Se, Ce) {
    !(Ce.mode & 1) && Se !== null && (Se.alternate = null, Ce.alternate = null, Ce.flags |= 2);
  }
  function ji(Se, Ce, Fe) {
    if (Se !== null && (Ce.dependencies = Se.dependencies), Ld |= Ce.lanes, !(Fe & Ce.childLanes))
      return null;
    if (Se !== null && Ce.child !== Se.child)
      throw Error(fe(153));
    if (Ce.child !== null) {
      for (Se = Ce.child, Fe = Hc(Se, Se.pendingProps), Ce.child = Fe, Fe.return = Ce; Se.sibling !== null; )
        Se = Se.sibling, Fe = Fe.sibling = Hc(Se, Se.pendingProps), Fe.return = Ce;
      Fe.sibling = null;
    }
    return Ce.child;
  }
  function ry(Se, Ce, Fe) {
    switch (Ce.tag) {
      case 3:
        Qm(Ce), Ia();
        break;
      case 5:
        Ln(Ce);
        break;
      case 1:
        Oa(Ce.type) && bm(Ce);
        break;
      case 4:
        Ov(Ce, Ce.stateNode.containerInfo);
        break;
      case 10:
        var Ue = Ce.type._context, Xe = Ce.memoizedProps.value;
        ea(dl, Ue._currentValue), Ue._currentValue = Xe;
        break;
      case 13:
        if (Ue = Ce.memoizedState, Ue !== null)
          return Ue.dehydrated !== null ? (ea(qn, qn.current & 1), Ce.flags |= 128, null) : Fe & Ce.child.childLanes ? Fg(Se, Ce, Fe) : (ea(qn, qn.current & 1), Se = ji(Se, Ce, Fe), Se !== null ? Se.sibling : null);
        ea(qn, qn.current & 1);
        break;
      case 19:
        if (Ue = (Fe & Ce.childLanes) !== 0, Se.flags & 128) {
          if (Ue)
            return Ns(Se, Ce, Fe);
          Ce.flags |= 128;
        }
        if (Xe = Ce.memoizedState, Xe !== null && (Xe.rendering = null, Xe.tail = null, Xe.lastEffect = null), ea(qn, qn.current), Ue)
          break;
        return null;
      case 22:
      case 23:
        return Ce.lanes = 0, Rd(Se, Ce, Fe);
    }
    return ji(Se, Ce, Fe);
  }
  var Af, eu, fi, Dg;
  Af = function(Se, Ce) {
    for (var Fe = Ce.child; Fe !== null; ) {
      if (Fe.tag === 5 || Fe.tag === 6)
        Se.appendChild(Fe.stateNode);
      else if (Fe.tag !== 4 && Fe.child !== null) {
        Fe.child.return = Fe, Fe = Fe.child;
        continue;
      }
      if (Fe === Ce)
        break;
      for (; Fe.sibling === null; ) {
        if (Fe.return === null || Fe.return === Ce)
          return;
        Fe = Fe.return;
      }
      Fe.sibling.return = Fe.return, Fe = Fe.sibling;
    }
  }, eu = function() {
  }, fi = function(Se, Ce, Fe, Ue) {
    var Xe = Se.memoizedProps;
    if (Xe !== Ue) {
      Se = Ce.stateNode, Pd(Qu.current);
      var it = null;
      switch (Fe) {
        case "input":
          Xe = Yn(Se, Xe), Ue = Yn(Se, Ue), it = [];
          break;
        case "select":
          Xe = ot({}, Xe, { value: void 0 }), Ue = ot({}, Ue, { value: void 0 }), it = [];
          break;
        case "textarea":
          Xe = vo(Se, Xe), Ue = vo(Se, Ue), it = [];
          break;
        default:
          typeof Xe.onClick != "function" && typeof Ue.onClick == "function" && (Se.onclick = vm);
      }
      on(Fe, Ue);
      var $t;
      Fe = null;
      for (Sr in Xe)
        if (!Ue.hasOwnProperty(Sr) && Xe.hasOwnProperty(Sr) && Xe[Sr] != null)
          if (Sr === "style") {
            var Kt = Xe[Sr];
            for ($t in Kt)
              Kt.hasOwnProperty($t) && (Fe || (Fe = {}), Fe[$t] = "");
          } else
            Sr !== "dangerouslySetInnerHTML" && Sr !== "children" && Sr !== "suppressContentEditableWarning" && Sr !== "suppressHydrationWarning" && Sr !== "autoFocus" && (ve.hasOwnProperty(Sr) ? it || (it = []) : (it = it || []).push(Sr, null));
      for (Sr in Ue) {
        var rr = Ue[Sr];
        if (Kt = Xe == null ? void 0 : Xe[Sr], Ue.hasOwnProperty(Sr) && rr !== Kt && (rr != null || Kt != null))
          if (Sr === "style")
            if (Kt) {
              for ($t in Kt)
                !Kt.hasOwnProperty($t) || rr && rr.hasOwnProperty($t) || (Fe || (Fe = {}), Fe[$t] = "");
              for ($t in rr)
                rr.hasOwnProperty($t) && Kt[$t] !== rr[$t] && (Fe || (Fe = {}), Fe[$t] = rr[$t]);
            } else
              Fe || (it || (it = []), it.push(Sr, Fe)), Fe = rr;
          else
            Sr === "dangerouslySetInnerHTML" ? (rr = rr ? rr.__html : void 0, Kt = Kt ? Kt.__html : void 0, rr != null && Kt !== rr && (it = it || []).push(Sr, rr)) : Sr === "children" ? typeof rr != "string" && typeof rr != "number" || (it = it || []).push(Sr, "" + rr) : Sr !== "suppressContentEditableWarning" && Sr !== "suppressHydrationWarning" && (ve.hasOwnProperty(Sr) ? (rr != null && Sr === "onScroll" && ua("scroll", Se), it || Kt === rr || (it = [])) : (it = it || []).push(Sr, rr));
      }
      Fe && (it = it || []).push("style", Fe);
      var Sr = it;
      (Ce.updateQueue = Sr) && (Ce.flags |= 4);
    }
  }, Dg = function(Se, Ce, Fe, Ue) {
    Fe !== Ue && (Ce.flags |= 4);
  };
  function Lp(Se, Ce) {
    if (!Ea)
      switch (Se.tailMode) {
        case "hidden":
          Ce = Se.tail;
          for (var Fe = null; Ce !== null; )
            Ce.alternate !== null && (Fe = Ce), Ce = Ce.sibling;
          Fe === null ? Se.tail = null : Fe.sibling = null;
          break;
        case "collapsed":
          Fe = Se.tail;
          for (var Ue = null; Fe !== null; )
            Fe.alternate !== null && (Ue = Fe), Fe = Fe.sibling;
          Ue === null ? Ce || Se.tail === null ? Se.tail = null : Se.tail.sibling = null : Ue.sibling = null;
      }
  }
  function ns(Se) {
    var Ce = Se.alternate !== null && Se.alternate.child === Se.child, Fe = 0, Ue = 0;
    if (Ce)
      for (var Xe = Se.child; Xe !== null; )
        Fe |= Xe.lanes | Xe.childLanes, Ue |= Xe.subtreeFlags & 14680064, Ue |= Xe.flags & 14680064, Xe.return = Se, Xe = Xe.sibling;
    else
      for (Xe = Se.child; Xe !== null; )
        Fe |= Xe.lanes | Xe.childLanes, Ue |= Xe.subtreeFlags, Ue |= Xe.flags, Xe.return = Se, Xe = Xe.sibling;
    return Se.subtreeFlags |= Ue, Se.childLanes = Fe, Ce;
  }
  function Lv(Se, Ce, Fe) {
    var Ue = Ce.pendingProps;
    switch (gv(Ce), Ce.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ns(Ce), null;
      case 1:
        return Oa(Ce.type) && vu(), ns(Ce), null;
      case 3:
        return Ue = Ce.stateNode, jc(), Xo(Fa), Xo(Jn), Am(), Ue.pendingContext && (Ue.context = Ue.pendingContext, Ue.pendingContext = null), (Se === null || Se.child === null) && (xm(Ce) ? Ce.flags |= 4 : Se === null || Se.memoizedState.isDehydrated && !(Ce.flags & 256) || (Ce.flags |= 1024, gu !== null && (Zp(gu), gu = null))), eu(Se, Ce), ns(Ce), null;
      case 5:
        $o(Ce);
        var Xe = Pd(xf.current);
        if (Fe = Ce.type, Se !== null && Ce.stateNode != null)
          fi(Se, Ce, Fe, Ue, Xe), Se.ref !== Ce.ref && (Ce.flags |= 512, Ce.flags |= 2097152);
        else {
          if (!Ue) {
            if (Ce.stateNode === null)
              throw Error(fe(166));
            return ns(Ce), null;
          }
          if (Se = Pd(Qu.current), xm(Ce)) {
            Ue = Ce.stateNode, Fe = Ce.type;
            var it = Ce.memoizedProps;
            switch (Ue[ll] = Ce, Ue[_d] = it, Se = (Ce.mode & 1) !== 0, Fe) {
              case "dialog":
                ua("cancel", Ue), ua("close", Ue);
                break;
              case "iframe":
              case "object":
              case "embed":
                ua("load", Ue);
                break;
              case "video":
              case "audio":
                for (Xe = 0; Xe < gp.length; Xe++)
                  ua(gp[Xe], Ue);
                break;
              case "source":
                ua("error", Ue);
                break;
              case "img":
              case "image":
              case "link":
                ua("error", Ue), ua("load", Ue);
                break;
              case "details":
                ua("toggle", Ue);
                break;
              case "input":
                Ho(Ue, it), ua("invalid", Ue);
                break;
              case "select":
                Ue._wrapperState = { wasMultiple: !!it.multiple }, ua("invalid", Ue);
                break;
              case "textarea":
                Eo(Ue, it), ua("invalid", Ue);
            }
            on(Fe, it), Xe = null;
            for (var $t in it)
              if (it.hasOwnProperty($t)) {
                var Kt = it[$t];
                $t === "children" ? typeof Kt == "string" ? Ue.textContent !== Kt && (it.suppressHydrationWarning !== !0 && ym(Ue.textContent, Kt, Se), Xe = ["children", Kt]) : typeof Kt == "number" && Ue.textContent !== "" + Kt && (it.suppressHydrationWarning !== !0 && ym(Ue.textContent, Kt, Se), Xe = ["children", "" + Kt]) : ve.hasOwnProperty($t) && Kt != null && $t === "onScroll" && ua("scroll", Ue);
              }
            switch (Fe) {
              case "input":
                Pn(Ue), pa(Ue, it, !0);
                break;
              case "textarea":
                Pn(Ue), uo(Ue);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof it.onClick == "function" && (Ue.onclick = vm);
            }
            Ue = Xe, Ce.updateQueue = Ue, Ue !== null && (Ce.flags |= 4);
          } else {
            $t = Xe.nodeType === 9 ? Xe : Xe.ownerDocument, Se === "http://www.w3.org/1999/xhtml" && (Se = So(Fe)), Se === "http://www.w3.org/1999/xhtml" ? Fe === "script" ? (Se = $t.createElement("div"), Se.innerHTML = "<script><\/script>", Se = Se.removeChild(Se.firstChild)) : typeof Ue.is == "string" ? Se = $t.createElement(Fe, { is: Ue.is }) : (Se = $t.createElement(Fe), Fe === "select" && ($t = Se, Ue.multiple ? $t.multiple = !0 : Ue.size && ($t.size = Ue.size))) : Se = $t.createElementNS(Se, Fe), Se[ll] = Ce, Se[_d] = Ue, Af(Se, Ce, !1, !1), Ce.stateNode = Se;
            e: {
              switch ($t = Lr(Fe, Ue), Fe) {
                case "dialog":
                  ua("cancel", Se), ua("close", Se), Xe = Ue;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  ua("load", Se), Xe = Ue;
                  break;
                case "video":
                case "audio":
                  for (Xe = 0; Xe < gp.length; Xe++)
                    ua(gp[Xe], Se);
                  Xe = Ue;
                  break;
                case "source":
                  ua("error", Se), Xe = Ue;
                  break;
                case "img":
                case "image":
                case "link":
                  ua("error", Se), ua("load", Se), Xe = Ue;
                  break;
                case "details":
                  ua("toggle", Se), Xe = Ue;
                  break;
                case "input":
                  Ho(Se, Ue), Xe = Yn(Se, Ue), ua("invalid", Se);
                  break;
                case "option":
                  Xe = Ue;
                  break;
                case "select":
                  Se._wrapperState = { wasMultiple: !!Ue.multiple }, Xe = ot({}, Ue, { value: void 0 }), ua("invalid", Se);
                  break;
                case "textarea":
                  Eo(Se, Ue), Xe = vo(Se, Ue), ua("invalid", Se);
                  break;
                default:
                  Xe = Ue;
              }
              on(Fe, Xe), Kt = Xe;
              for (it in Kt)
                if (Kt.hasOwnProperty(it)) {
                  var rr = Kt[it];
                  it === "style" ? Vr(Se, rr) : it === "dangerouslySetInnerHTML" ? (rr = rr ? rr.__html : void 0, rr != null && Jt(Se, rr)) : it === "children" ? typeof rr == "string" ? (Fe !== "textarea" || rr !== "") && or(Se, rr) : typeof rr == "number" && or(Se, "" + rr) : it !== "suppressContentEditableWarning" && it !== "suppressHydrationWarning" && it !== "autoFocus" && (ve.hasOwnProperty(it) ? rr != null && it === "onScroll" && ua("scroll", Se) : rr != null && yt(Se, it, rr, $t));
                }
              switch (Fe) {
                case "input":
                  Pn(Se), pa(Se, Ue, !1);
                  break;
                case "textarea":
                  Pn(Se), uo(Se);
                  break;
                case "option":
                  Ue.value != null && Se.setAttribute("value", "" + jr(Ue.value));
                  break;
                case "select":
                  Se.multiple = !!Ue.multiple, it = Ue.value, it != null ? Ko(Se, !!Ue.multiple, it, !1) : Ue.defaultValue != null && Ko(Se, !!Ue.multiple, Ue.defaultValue, !0);
                  break;
                default:
                  typeof Xe.onClick == "function" && (Se.onclick = vm);
              }
              switch (Fe) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  Ue = !!Ue.autoFocus;
                  break e;
                case "img":
                  Ue = !0;
                  break e;
                default:
                  Ue = !1;
              }
            }
            Ue && (Ce.flags |= 4);
          }
          Ce.ref !== null && (Ce.flags |= 512, Ce.flags |= 2097152);
        }
        return ns(Ce), null;
      case 6:
        if (Se && Ce.stateNode != null)
          Dg(Se, Ce, Se.memoizedProps, Ue);
        else {
          if (typeof Ue != "string" && Ce.stateNode === null)
            throw Error(fe(166));
          if (Fe = Pd(xf.current), Pd(Qu.current), xm(Ce)) {
            if (Ue = Ce.stateNode, Fe = Ce.memoizedProps, Ue[ll] = Ce, (it = Ue.nodeValue !== Fe) && (Se = Ks, Se !== null))
              switch (Se.tag) {
                case 3:
                  ym(Ue.nodeValue, Fe, (Se.mode & 1) !== 0);
                  break;
                case 5:
                  Se.memoizedProps.suppressHydrationWarning !== !0 && ym(Ue.nodeValue, Fe, (Se.mode & 1) !== 0);
              }
            it && (Ce.flags |= 4);
          } else
            Ue = (Fe.nodeType === 9 ? Fe : Fe.ownerDocument).createTextNode(Ue), Ue[ll] = Ce, Ce.stateNode = Ue;
        }
        return ns(Ce), null;
      case 13:
        if (Xo(qn), Ue = Ce.memoizedState, Se === null || Se.memoizedState !== null && Se.memoizedState.dehydrated !== null) {
          if (Ea && $s !== null && Ce.mode & 1 && !(Ce.flags & 128))
            Pg(), Ia(), Ce.flags |= 98560, it = !1;
          else if (it = xm(Ce), Ue !== null && Ue.dehydrated !== null) {
            if (Se === null) {
              if (!it)
                throw Error(fe(318));
              if (it = Ce.memoizedState, it = it !== null ? it.dehydrated : null, !it)
                throw Error(fe(317));
              it[ll] = Ce;
            } else
              Ia(), !(Ce.flags & 128) && (Ce.memoizedState = null), Ce.flags |= 4;
            ns(Ce), it = !1;
          } else
            gu !== null && (Zp(gu), gu = null), it = !0;
          if (!it)
            return Ce.flags & 65536 ? Ce : null;
        }
        return Ce.flags & 128 ? (Ce.lanes = Fe, Ce) : (Ue = Ue !== null, Ue !== (Se !== null && Se.memoizedState !== null) && Ue && (Ce.child.flags |= 8192, Ce.mode & 1 && (Se === null || qn.current & 1 ? pi === 0 && (pi = 3) : Vv())), Ce.updateQueue !== null && (Ce.flags |= 4), ns(Ce), null);
      case 4:
        return jc(), eu(Se, Ce), Se === null && vf(Ce.stateNode.containerInfo), ns(Ce), null;
      case 10:
        return $c(Ce.type._context), ns(Ce), null;
      case 17:
        return Oa(Ce.type) && vu(), ns(Ce), null;
      case 19:
        if (Xo(qn), it = Ce.memoizedState, it === null)
          return ns(Ce), null;
        if (Ue = (Ce.flags & 128) !== 0, $t = it.rendering, $t === null)
          if (Ue)
            Lp(it, !1);
          else {
            if (pi !== 0 || Se !== null && Se.flags & 128)
              for (Se = Ce.child; Se !== null; ) {
                if ($t = Ma(Se), $t !== null) {
                  for (Ce.flags |= 128, Lp(it, !1), Ue = $t.updateQueue, Ue !== null && (Ce.updateQueue = Ue, Ce.flags |= 4), Ce.subtreeFlags = 0, Ue = Fe, Fe = Ce.child; Fe !== null; )
                    it = Fe, Se = Ue, it.flags &= 14680066, $t = it.alternate, $t === null ? (it.childLanes = 0, it.lanes = Se, it.child = null, it.subtreeFlags = 0, it.memoizedProps = null, it.memoizedState = null, it.updateQueue = null, it.dependencies = null, it.stateNode = null) : (it.childLanes = $t.childLanes, it.lanes = $t.lanes, it.child = $t.child, it.subtreeFlags = 0, it.deletions = null, it.memoizedProps = $t.memoizedProps, it.memoizedState = $t.memoizedState, it.updateQueue = $t.updateQueue, it.type = $t.type, Se = $t.dependencies, it.dependencies = Se === null ? null : { lanes: Se.lanes, firstContext: Se.firstContext }), Fe = Fe.sibling;
                  return ea(qn, qn.current & 1 | 2), Ce.child;
                }
                Se = Se.sibling;
              }
            it.tail !== null && xo() > Mf && (Ce.flags |= 128, Ue = !0, Lp(it, !1), Ce.lanes = 4194304);
          }
        else {
          if (!Ue)
            if (Se = Ma($t), Se !== null) {
              if (Ce.flags |= 128, Ue = !0, Fe = Se.updateQueue, Fe !== null && (Ce.updateQueue = Fe, Ce.flags |= 4), Lp(it, !0), it.tail === null && it.tailMode === "hidden" && !$t.alternate && !Ea)
                return ns(Ce), null;
            } else
              2 * xo() - it.renderingStartTime > Mf && Fe !== 1073741824 && (Ce.flags |= 128, Ue = !0, Lp(it, !1), Ce.lanes = 4194304);
          it.isBackwards ? ($t.sibling = Ce.child, Ce.child = $t) : (Fe = it.last, Fe !== null ? Fe.sibling = $t : Ce.child = $t, it.last = $t);
        }
        return it.tail !== null ? (Ce = it.tail, it.rendering = Ce, it.tail = Ce.sibling, it.renderingStartTime = xo(), Ce.sibling = null, Fe = qn.current, ea(qn, Ue ? Fe & 1 | 2 : Fe & 1), Ce) : (ns(Ce), null);
      case 22:
      case 23:
        return Uv(), Ue = Ce.memoizedState !== null, Se !== null && Se.memoizedState !== null !== Ue && (Ce.flags |= 8192), Ue && Ce.mode & 1 ? tu & 1073741824 && (ns(Ce), Ce.subtreeFlags & 6 && (Ce.flags |= 8192)) : ns(Ce), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(fe(156, Ce.tag));
  }
  function Bg(Se, Ce) {
    switch (gv(Ce), Ce.tag) {
      case 1:
        return Oa(Ce.type) && vu(), Se = Ce.flags, Se & 65536 ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 3:
        return jc(), Xo(Fa), Xo(Jn), Am(), Se = Ce.flags, Se & 65536 && !(Se & 128) ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 5:
        return $o(Ce), null;
      case 13:
        if (Xo(qn), Se = Ce.memoizedState, Se !== null && Se.dehydrated !== null) {
          if (Ce.alternate === null)
            throw Error(fe(340));
          Ia();
        }
        return Se = Ce.flags, Se & 65536 ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 19:
        return Xo(qn), null;
      case 4:
        return jc(), null;
      case 10:
        return $c(Ce.type._context), null;
      case 22:
      case 23:
        return Uv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Nd = !1, Fi = !1, S_ = typeof WeakSet == "function" ? WeakSet : Set, yn = null;
  function Bc(Se, Ce) {
    var Fe = Se.ref;
    if (Fe !== null)
      if (typeof Fe == "function")
        try {
          Fe(null);
        } catch (Ue) {
          La(Se, Ce, Ue);
        }
      else
        Fe.current = null;
  }
  function zg(Se, Ce, Fe) {
    try {
      Fe();
    } catch (Ue) {
      La(Se, Ce, Ue);
    }
  }
  var Dv = !1;
  function P_(Se, Ce) {
    if (dv = Mi, Se = dm(), Ml(Se)) {
      if ("selectionStart" in Se)
        var Fe = { start: Se.selectionStart, end: Se.selectionEnd };
      else
        e: {
          Fe = (Fe = Se.ownerDocument) && Fe.defaultView || window;
          var Ue = Fe.getSelection && Fe.getSelection();
          if (Ue && Ue.rangeCount !== 0) {
            Fe = Ue.anchorNode;
            var Xe = Ue.anchorOffset, it = Ue.focusNode;
            Ue = Ue.focusOffset;
            try {
              Fe.nodeType, it.nodeType;
            } catch {
              Fe = null;
              break e;
            }
            var $t = 0, Kt = -1, rr = -1, Sr = 0, zr = 0, Hr = Se, Ur = null;
            t:
              for (; ; ) {
                for (var dn; Hr !== Fe || Xe !== 0 && Hr.nodeType !== 3 || (Kt = $t + Xe), Hr !== it || Ue !== 0 && Hr.nodeType !== 3 || (rr = $t + Ue), Hr.nodeType === 3 && ($t += Hr.nodeValue.length), (dn = Hr.firstChild) !== null; )
                  Ur = Hr, Hr = dn;
                for (; ; ) {
                  if (Hr === Se)
                    break t;
                  if (Ur === Fe && ++Sr === Xe && (Kt = $t), Ur === it && ++zr === Ue && (rr = $t), (dn = Hr.nextSibling) !== null)
                    break;
                  Hr = Ur, Ur = Hr.parentNode;
                }
                Hr = dn;
              }
            Fe = Kt === -1 || rr === -1 ? null : { start: Kt, end: rr };
          } else
            Fe = null;
        }
      Fe = Fe || { start: 0, end: 0 };
    } else
      Fe = null;
    for (bd = { focusedElem: Se, selectionRange: Fe }, Mi = !1, yn = Ce; yn !== null; )
      if (Ce = yn, Se = Ce.child, (Ce.subtreeFlags & 1028) !== 0 && Se !== null)
        Se.return = Ce, yn = Se;
      else
        for (; yn !== null; ) {
          Ce = yn;
          try {
            var gn = Ce.alternate;
            if (Ce.flags & 1024)
              switch (Ce.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (gn !== null) {
                    var _n = gn.memoizedProps, Va = gn.memoizedState, vr = Ce.stateNode, ar = vr.getSnapshotBeforeUpdate(Ce.elementType === Ce.type ? _n : Xs(Ce.type, _n), Va);
                    vr.__reactInternalSnapshotBeforeUpdate = ar;
                  }
                  break;
                case 3:
                  var wr = Ce.stateNode.containerInfo;
                  wr.nodeType === 1 ? wr.textContent = "" : wr.nodeType === 9 && wr.documentElement && wr.removeChild(wr.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(fe(163));
              }
          } catch (Yr) {
            La(Ce, Ce.return, Yr);
          }
          if (Se = Ce.sibling, Se !== null) {
            Se.return = Ce.return, yn = Se;
            break;
          }
          yn = Ce.return;
        }
    return gn = Dv, Dv = !1, gn;
  }
  function Cf(Se, Ce, Fe) {
    var Ue = Ce.updateQueue;
    if (Ue = Ue !== null ? Ue.lastEffect : null, Ue !== null) {
      var Xe = Ue = Ue.next;
      do {
        if ((Xe.tag & Se) === Se) {
          var it = Xe.destroy;
          Xe.destroy = void 0, it !== void 0 && zg(Ce, Fe, it);
        }
        Xe = Xe.next;
      } while (Xe !== Ue);
    }
  }
  function ny(Se, Ce) {
    if (Ce = Ce.updateQueue, Ce = Ce !== null ? Ce.lastEffect : null, Ce !== null) {
      var Fe = Ce = Ce.next;
      do {
        if ((Fe.tag & Se) === Se) {
          var Ue = Fe.create;
          Fe.destroy = Ue();
        }
        Fe = Fe.next;
      } while (Fe !== Ce);
    }
  }
  function oy(Se) {
    var Ce = Se.ref;
    if (Ce !== null) {
      var Fe = Se.stateNode;
      switch (Se.tag) {
        case 5:
          Se = Fe;
          break;
        default:
          Se = Fe;
      }
      typeof Ce == "function" ? Ce(Se) : Ce.current = Se;
    }
  }
  function Ug(Se) {
    var Ce = Se.alternate;
    Ce !== null && (Se.alternate = null, Ug(Ce)), Se.child = null, Se.deletions = null, Se.sibling = null, Se.tag === 5 && (Ce = Se.stateNode, Ce !== null && (delete Ce[ll], delete Ce[_d], delete Ce[hv], delete Ce[b_], delete Ce[mv])), Se.stateNode = null, Se.return = null, Se.dependencies = null, Se.memoizedProps = null, Se.memoizedState = null, Se.pendingProps = null, Se.stateNode = null, Se.updateQueue = null;
  }
  function ay(Se) {
    return Se.tag === 5 || Se.tag === 3 || Se.tag === 4;
  }
  function Dp(Se) {
    e:
      for (; ; ) {
        for (; Se.sibling === null; ) {
          if (Se.return === null || ay(Se.return))
            return null;
          Se = Se.return;
        }
        for (Se.sibling.return = Se.return, Se = Se.sibling; Se.tag !== 5 && Se.tag !== 6 && Se.tag !== 18; ) {
          if (Se.flags & 2 || Se.child === null || Se.tag === 4)
            continue e;
          Se.child.return = Se, Se = Se.child;
        }
        if (!(Se.flags & 2))
          return Se.stateNode;
      }
  }
  function pl(Se, Ce, Fe) {
    var Ue = Se.tag;
    if (Ue === 5 || Ue === 6)
      Se = Se.stateNode, Ce ? Fe.nodeType === 8 ? Fe.parentNode.insertBefore(Se, Ce) : Fe.insertBefore(Se, Ce) : (Fe.nodeType === 8 ? (Ce = Fe.parentNode, Ce.insertBefore(Se, Fe)) : (Ce = Fe, Ce.appendChild(Se)), Fe = Fe._reactRootContainer, Fe != null || Ce.onclick !== null || (Ce.onclick = vm));
    else if (Ue !== 4 && (Se = Se.child, Se !== null))
      for (pl(Se, Ce, Fe), Se = Se.sibling; Se !== null; )
        pl(Se, Ce, Fe), Se = Se.sibling;
  }
  function hl(Se, Ce, Fe) {
    var Ue = Se.tag;
    if (Ue === 5 || Ue === 6)
      Se = Se.stateNode, Ce ? Fe.insertBefore(Se, Ce) : Fe.appendChild(Se);
    else if (Ue !== 4 && (Se = Se.child, Se !== null))
      for (hl(Se, Ce, Fe), Se = Se.sibling; Se !== null; )
        hl(Se, Ce, Fe), Se = Se.sibling;
  }
  var Aa = null, ss = !1;
  function $u(Se, Ce, Fe) {
    for (Fe = Fe.child; Fe !== null; )
      Yl(Se, Ce, Fe), Fe = Fe.sibling;
  }
  function Yl(Se, Ce, Fe) {
    if (Ca && typeof Ca.onCommitFiberUnmount == "function")
      try {
        Ca.onCommitFiberUnmount(Ci, Fe);
      } catch {
      }
    switch (Fe.tag) {
      case 5:
        Fi || Bc(Fe, Ce);
      case 6:
        var Ue = Aa, Xe = ss;
        Aa = null, $u(Se, Ce, Fe), Aa = Ue, ss = Xe, Aa !== null && (ss ? (Se = Aa, Fe = Fe.stateNode, Se.nodeType === 8 ? Se.parentNode.removeChild(Fe) : Se.removeChild(Fe)) : Aa.removeChild(Fe.stateNode));
        break;
      case 18:
        Aa !== null && (ss ? (Se = Aa, Fe = Fe.stateNode, Se.nodeType === 8 ? bc(Se.parentNode, Fe) : Se.nodeType === 1 && bc(Se, Fe), cu(Se)) : bc(Aa, Fe.stateNode));
        break;
      case 4:
        Ue = Aa, Xe = ss, Aa = Fe.stateNode.containerInfo, ss = !0, $u(Se, Ce, Fe), Aa = Ue, ss = Xe;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Fi && (Ue = Fe.updateQueue, Ue !== null && (Ue = Ue.lastEffect, Ue !== null))) {
          Xe = Ue = Ue.next;
          do {
            var it = Xe, $t = it.destroy;
            it = it.tag, $t !== void 0 && (it & 2 || it & 4) && zg(Fe, Ce, $t), Xe = Xe.next;
          } while (Xe !== Ue);
        }
        $u(Se, Ce, Fe);
        break;
      case 1:
        if (!Fi && (Bc(Fe, Ce), Ue = Fe.stateNode, typeof Ue.componentWillUnmount == "function"))
          try {
            Ue.props = Fe.memoizedProps, Ue.state = Fe.memoizedState, Ue.componentWillUnmount();
          } catch (Kt) {
            La(Fe, Ce, Kt);
          }
        $u(Se, Ce, Fe);
        break;
      case 21:
        $u(Se, Ce, Fe);
        break;
      case 22:
        Fe.mode & 1 ? (Fi = (Ue = Fi) || Fe.memoizedState !== null, $u(Se, Ce, Fe), Fi = Ue) : $u(Se, Ce, Fe);
        break;
      default:
        $u(Se, Ce, Fe);
    }
  }
  function Vg(Se) {
    var Ce = Se.updateQueue;
    if (Ce !== null) {
      Se.updateQueue = null;
      var Fe = Se.stateNode;
      Fe === null && (Fe = Se.stateNode = new S_()), Ce.forEach(function(Ue) {
        var Xe = C_.bind(null, Se, Ue);
        Fe.has(Ue) || (Fe.add(Ue), Ue.then(Xe, Xe));
      });
    }
  }
  function Ku(Se, Ce) {
    var Fe = Ce.deletions;
    if (Fe !== null)
      for (var Ue = 0; Ue < Fe.length; Ue++) {
        var Xe = Fe[Ue];
        try {
          var it = Se, $t = Ce, Kt = $t;
          e:
            for (; Kt !== null; ) {
              switch (Kt.tag) {
                case 5:
                  Aa = Kt.stateNode, ss = !1;
                  break e;
                case 3:
                  Aa = Kt.stateNode.containerInfo, ss = !0;
                  break e;
                case 4:
                  Aa = Kt.stateNode.containerInfo, ss = !0;
                  break e;
              }
              Kt = Kt.return;
            }
          if (Aa === null)
            throw Error(fe(160));
          Yl(it, $t, Xe), Aa = null, ss = !1;
          var rr = Xe.alternate;
          rr !== null && (rr.return = null), Xe.return = null;
        } catch (Sr) {
          La(Xe, Ce, Sr);
        }
      }
    if (Ce.subtreeFlags & 12854)
      for (Ce = Ce.child; Ce !== null; )
        Hg(Ce, Se), Ce = Ce.sibling;
  }
  function Hg(Se, Ce) {
    var Fe = Se.alternate, Ue = Se.flags;
    switch (Se.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Ku(Ce, Se), Xu(Se), Ue & 4) {
          try {
            Cf(3, Se, Se.return), ny(3, Se);
          } catch (_n) {
            La(Se, Se.return, _n);
          }
          try {
            Cf(5, Se, Se.return);
          } catch (_n) {
            La(Se, Se.return, _n);
          }
        }
        break;
      case 1:
        Ku(Ce, Se), Xu(Se), Ue & 512 && Fe !== null && Bc(Fe, Fe.return);
        break;
      case 5:
        if (Ku(Ce, Se), Xu(Se), Ue & 512 && Fe !== null && Bc(Fe, Fe.return), Se.flags & 32) {
          var Xe = Se.stateNode;
          try {
            or(Xe, "");
          } catch (_n) {
            La(Se, Se.return, _n);
          }
        }
        if (Ue & 4 && (Xe = Se.stateNode, Xe != null)) {
          var it = Se.memoizedProps, $t = Fe !== null ? Fe.memoizedProps : it, Kt = Se.type, rr = Se.updateQueue;
          if (Se.updateQueue = null, rr !== null)
            try {
              Kt === "input" && it.type === "radio" && it.name != null && Rn(Xe, it), Lr(Kt, $t);
              var Sr = Lr(Kt, it);
              for ($t = 0; $t < rr.length; $t += 2) {
                var zr = rr[$t], Hr = rr[$t + 1];
                zr === "style" ? Vr(Xe, Hr) : zr === "dangerouslySetInnerHTML" ? Jt(Xe, Hr) : zr === "children" ? or(Xe, Hr) : yt(Xe, zr, Hr, Sr);
              }
              switch (Kt) {
                case "input":
                  fo(Xe, it);
                  break;
                case "textarea":
                  ra(Xe, it);
                  break;
                case "select":
                  var Ur = Xe._wrapperState.wasMultiple;
                  Xe._wrapperState.wasMultiple = !!it.multiple;
                  var dn = it.value;
                  dn != null ? Ko(Xe, !!it.multiple, dn, !1) : Ur !== !!it.multiple && (it.defaultValue != null ? Ko(Xe, !!it.multiple, it.defaultValue, !0) : Ko(Xe, !!it.multiple, it.multiple ? [] : "", !1));
              }
              Xe[_d] = it;
            } catch (_n) {
              La(Se, Se.return, _n);
            }
        }
        break;
      case 6:
        if (Ku(Ce, Se), Xu(Se), Ue & 4) {
          if (Se.stateNode === null)
            throw Error(fe(162));
          Xe = Se.stateNode, it = Se.memoizedProps;
          try {
            Xe.nodeValue = it;
          } catch (_n) {
            La(Se, Se.return, _n);
          }
        }
        break;
      case 3:
        if (Ku(Ce, Se), Xu(Se), Ue & 4 && Fe !== null && Fe.memoizedState.isDehydrated)
          try {
            cu(Ce.containerInfo);
          } catch (_n) {
            La(Se, Se.return, _n);
          }
        break;
      case 4:
        Ku(Ce, Se), Xu(Se);
        break;
      case 13:
        Ku(Ce, Se), Xu(Se), Xe = Se.child, Xe.flags & 8192 && (it = Xe.memoizedState !== null, Xe.stateNode.isHidden = it, !it || Xe.alternate !== null && Xe.alternate.memoizedState !== null || (zv = xo())), Ue & 4 && Vg(Se);
        break;
      case 22:
        if (zr = Fe !== null && Fe.memoizedState !== null, Se.mode & 1 ? (Fi = (Sr = Fi) || zr, Ku(Ce, Se), Fi = Sr) : Ku(Ce, Se), Xu(Se), Ue & 8192) {
          if (Sr = Se.memoizedState !== null, (Se.stateNode.isHidden = Sr) && !zr && Se.mode & 1)
            for (yn = Se, zr = Se.child; zr !== null; ) {
              for (Hr = yn = zr; yn !== null; ) {
                switch (Ur = yn, dn = Ur.child, Ur.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Cf(4, Ur, Ur.return);
                    break;
                  case 1:
                    Bc(Ur, Ur.return);
                    var gn = Ur.stateNode;
                    if (typeof gn.componentWillUnmount == "function") {
                      Ue = Ur, Fe = Ur.return;
                      try {
                        Ce = Ue, gn.props = Ce.memoizedProps, gn.state = Ce.memoizedState, gn.componentWillUnmount();
                      } catch (_n) {
                        La(Ue, Fe, _n);
                      }
                    }
                    break;
                  case 5:
                    Bc(Ur, Ur.return);
                    break;
                  case 22:
                    if (Ur.memoizedState !== null) {
                      Wg(Hr);
                      continue;
                    }
                }
                dn !== null ? (dn.return = Ur, yn = dn) : Wg(Hr);
              }
              zr = zr.sibling;
            }
          e:
            for (zr = null, Hr = Se; ; ) {
              if (Hr.tag === 5) {
                if (zr === null) {
                  zr = Hr;
                  try {
                    Xe = Hr.stateNode, Sr ? (it = Xe.style, typeof it.setProperty == "function" ? it.setProperty("display", "none", "important") : it.display = "none") : (Kt = Hr.stateNode, rr = Hr.memoizedProps.style, $t = rr != null && rr.hasOwnProperty("display") ? rr.display : null, Kt.style.display = Wr("display", $t));
                  } catch (_n) {
                    La(Se, Se.return, _n);
                  }
                }
              } else if (Hr.tag === 6) {
                if (zr === null)
                  try {
                    Hr.stateNode.nodeValue = Sr ? "" : Hr.memoizedProps;
                  } catch (_n) {
                    La(Se, Se.return, _n);
                  }
              } else if ((Hr.tag !== 22 && Hr.tag !== 23 || Hr.memoizedState === null || Hr === Se) && Hr.child !== null) {
                Hr.child.return = Hr, Hr = Hr.child;
                continue;
              }
              if (Hr === Se)
                break e;
              for (; Hr.sibling === null; ) {
                if (Hr.return === null || Hr.return === Se)
                  break e;
                zr === Hr && (zr = null), Hr = Hr.return;
              }
              zr === Hr && (zr = null), Hr.sibling.return = Hr.return, Hr = Hr.sibling;
            }
        }
        break;
      case 19:
        Ku(Ce, Se), Xu(Se), Ue & 4 && Vg(Se);
        break;
      case 21:
        break;
      default:
        Ku(Ce, Se), Xu(Se);
    }
  }
  function Xu(Se) {
    var Ce = Se.flags;
    if (Ce & 2) {
      try {
        e: {
          for (var Fe = Se.return; Fe !== null; ) {
            if (ay(Fe)) {
              var Ue = Fe;
              break e;
            }
            Fe = Fe.return;
          }
          throw Error(fe(160));
        }
        switch (Ue.tag) {
          case 5:
            var Xe = Ue.stateNode;
            Ue.flags & 32 && (or(Xe, ""), Ue.flags &= -33);
            var it = Dp(Se);
            hl(Se, it, Xe);
            break;
          case 3:
          case 4:
            var $t = Ue.stateNode.containerInfo, Kt = Dp(Se);
            pl(Se, Kt, $t);
            break;
          default:
            throw Error(fe(161));
        }
      } catch (rr) {
        La(Se, Se.return, rr);
      }
      Se.flags &= -3;
    }
    Ce & 4096 && (Se.flags &= -4097);
  }
  function Bp(Se, Ce, Fe) {
    yn = Se, qg(Se);
  }
  function qg(Se, Ce, Fe) {
    for (var Ue = (Se.mode & 1) !== 0; yn !== null; ) {
      var Xe = yn, it = Xe.child;
      if (Xe.tag === 22 && Ue) {
        var $t = Xe.memoizedState !== null || Nd;
        if (!$t) {
          var Kt = Xe.alternate, rr = Kt !== null && Kt.memoizedState !== null || Fi;
          Kt = Nd;
          var Sr = Fi;
          if (Nd = $t, (Fi = rr) && !Sr)
            for (yn = Xe; yn !== null; )
              $t = yn, rr = $t.child, $t.tag === 22 && $t.memoizedState !== null ? zp(Xe) : rr !== null ? (rr.return = $t, yn = rr) : zp(Xe);
          for (; it !== null; )
            yn = it, qg(it), it = it.sibling;
          yn = Xe, Nd = Kt, Fi = Sr;
        }
        Bv(Se);
      } else
        Xe.subtreeFlags & 8772 && it !== null ? (it.return = Xe, yn = it) : Bv(Se);
    }
  }
  function Bv(Se) {
    for (; yn !== null; ) {
      var Ce = yn;
      if (Ce.flags & 8772) {
        var Fe = Ce.alternate;
        try {
          if (Ce.flags & 8772)
            switch (Ce.tag) {
              case 0:
              case 11:
              case 15:
                Fi || ny(5, Ce);
                break;
              case 1:
                var Ue = Ce.stateNode;
                if (Ce.flags & 4 && !Fi)
                  if (Fe === null)
                    Ue.componentDidMount();
                  else {
                    var Xe = Ce.elementType === Ce.type ? Fe.memoizedProps : Xs(Ce.type, Fe.memoizedProps);
                    Ue.componentDidUpdate(Xe, Fe.memoizedState, Ue.__reactInternalSnapshotBeforeUpdate);
                  }
                var it = Ce.updateQueue;
                it !== null && Ed(Ce, it, Ue);
                break;
              case 3:
                var $t = Ce.updateQueue;
                if ($t !== null) {
                  if (Fe = null, Ce.child !== null)
                    switch (Ce.child.tag) {
                      case 5:
                        Fe = Ce.child.stateNode;
                        break;
                      case 1:
                        Fe = Ce.child.stateNode;
                    }
                  Ed(Ce, $t, Fe);
                }
                break;
              case 5:
                var Kt = Ce.stateNode;
                if (Fe === null && Ce.flags & 4) {
                  Fe = Kt;
                  var rr = Ce.memoizedProps;
                  switch (Ce.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      rr.autoFocus && Fe.focus();
                      break;
                    case "img":
                      rr.src && (Fe.src = rr.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Ce.memoizedState === null) {
                  var Sr = Ce.alternate;
                  if (Sr !== null) {
                    var zr = Sr.memoizedState;
                    if (zr !== null) {
                      var Hr = zr.dehydrated;
                      Hr !== null && cu(Hr);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(fe(163));
            }
          Fi || Ce.flags & 512 && oy(Ce);
        } catch (Ur) {
          La(Ce, Ce.return, Ur);
        }
      }
      if (Ce === Se) {
        yn = null;
        break;
      }
      if (Fe = Ce.sibling, Fe !== null) {
        Fe.return = Ce.return, yn = Fe;
        break;
      }
      yn = Ce.return;
    }
  }
  function Wg(Se) {
    for (; yn !== null; ) {
      var Ce = yn;
      if (Ce === Se) {
        yn = null;
        break;
      }
      var Fe = Ce.sibling;
      if (Fe !== null) {
        Fe.return = Ce.return, yn = Fe;
        break;
      }
      yn = Ce.return;
    }
  }
  function zp(Se) {
    for (; yn !== null; ) {
      var Ce = yn;
      try {
        switch (Ce.tag) {
          case 0:
          case 11:
          case 15:
            var Fe = Ce.return;
            try {
              ny(4, Ce);
            } catch (rr) {
              La(Ce, Fe, rr);
            }
            break;
          case 1:
            var Ue = Ce.stateNode;
            if (typeof Ue.componentDidMount == "function") {
              var Xe = Ce.return;
              try {
                Ue.componentDidMount();
              } catch (rr) {
                La(Ce, Xe, rr);
              }
            }
            var it = Ce.return;
            try {
              oy(Ce);
            } catch (rr) {
              La(Ce, it, rr);
            }
            break;
          case 5:
            var $t = Ce.return;
            try {
              oy(Ce);
            } catch (rr) {
              La(Ce, $t, rr);
            }
        }
      } catch (rr) {
        La(Ce, Ce.return, rr);
      }
      if (Ce === Se) {
        yn = null;
        break;
      }
      var Kt = Ce.sibling;
      if (Kt !== null) {
        Kt.return = Ce.return, yn = Kt;
        break;
      }
      yn = Ce.return;
    }
  }
  var Zg = Math.ceil, iy = Ct.ReactCurrentDispatcher, jd = Ct.ReactCurrentOwner, os = Ct.ReactCurrentBatchConfig, Io = 0, ri = null, Ua = null, Li = 0, tu = 0, $f = go(0), pi = 0, Fd = null, Ld = 0, Bd = 0, Up = 0, If = null, js = null, zv = 0, Mf = 1 / 0, Ql = null, zc = !1, Vp = null, Iu = null, sy = !1, Uc = null, Hp = 0, Rf = 0, Nf = null, zd = -1, qp = 0;
  function ca() {
    return Io & 6 ? xo() : zd !== -1 ? zd : zd = xo();
  }
  function ru(Se) {
    return Se.mode & 1 ? Io & 2 && Li !== 0 ? Li & -Li : Em.transition !== null ? (qp === 0 && (qp = lu()), qp) : (Se = jo, Se !== 0 || (Se = window.event, Se = Se === void 0 ? 16 : kl(Se.type)), Se) : 1;
  }
  function nu(Se, Ce, Fe, Ue) {
    if (50 < Rf)
      throw Rf = 0, Nf = null, Error(fe(185));
    Vs(Se, Fe, Ue), (!(Io & 2) || Se !== ri) && (Se === ri && (!(Io & 2) && (Bd |= Fe), pi === 4 && Vc(Se, Li)), Si(Se, Ue), Fe === 1 && Io === 0 && !(Ce.mode & 1) && (Mf = xo() + 500, xi && Os()));
  }
  function Si(Se, Ce) {
    var Fe = Se.callbackNode;
    ts(Se, Ce);
    var Ue = $a(Se, Se === ri ? Li : 0);
    if (Ue === 0)
      Fe !== null && va(Fe), Se.callbackNode = null, Se.callbackPriority = 0;
    else if (Ce = Ue & -Ue, Se.callbackPriority !== Ce) {
      if (Fe != null && va(Fe), Ce === 1)
        Se.tag === 0 ? vv(Yp.bind(null, Se)) : yv(Yp.bind(null, Se)), pv(function() {
          !(Io & 6) && Os();
        }), Fe = null;
      else {
        switch (is(Ue)) {
          case 1:
            Fe = si;
            break;
          case 4:
            Fe = oo;
            break;
          case 16:
            Fe = da;
            break;
          case 536870912:
            Fe = as;
            break;
          default:
            Fe = da;
        }
        Fe = Jg(Fe, Gg.bind(null, Se));
      }
      Se.callbackPriority = Ce, Se.callbackNode = Fe;
    }
  }
  function Gg(Se, Ce) {
    if (zd = -1, qp = 0, Io & 6)
      throw Error(fe(327));
    var Fe = Se.callbackNode;
    if (jf() && Se.callbackNode !== Fe)
      return null;
    var Ue = $a(Se, Se === ri ? Li : 0);
    if (Ue === 0)
      return null;
    if (Ue & 30 || Ue & Se.expiredLanes || Ce)
      Ce = cy(Se, Ue);
    else {
      Ce = Ue;
      var Xe = Io;
      Io |= 2;
      var it = Yg();
      (ri !== Se || Li !== Ce) && (Ql = null, Mf = xo() + 500, Vd(Se, Ce));
      do
        try {
          k_();
          break;
        } catch (Kt) {
          ly(Se, Kt);
        }
      while (1);
      Ev(), iy.current = it, Io = Xe, Ua !== null ? Ce = 0 : (ri = null, Li = 0, Ce = pi);
    }
    if (Ce !== 0) {
      if (Ce === 2 && (Xe = xl(Se), Xe !== 0 && (Ue = Xe, Ce = Wp(Se, Xe))), Ce === 1)
        throw Fe = Fd, Vd(Se, 0), Vc(Se, Ue), Si(Se, xo()), Fe;
      if (Ce === 6)
        Vc(Se, Ue);
      else {
        if (Xe = Se.current.alternate, !(Ue & 30) && !Gp(Xe) && (Ce = cy(Se, Ue), Ce === 2 && (it = xl(Se), it !== 0 && (Ue = it, Ce = Wp(Se, it))), Ce === 1))
          throw Fe = Fd, Vd(Se, 0), Vc(Se, Ue), Si(Se, xo()), Fe;
        switch (Se.finishedWork = Xe, Se.finishedLanes = Ue, Ce) {
          case 0:
          case 1:
            throw Error(fe(345));
          case 2:
            Hd(Se, js, Ql);
            break;
          case 3:
            if (Vc(Se, Ue), (Ue & 130023424) === Ue && (Ce = zv + 500 - xo(), 10 < Ce)) {
              if ($a(Se, 0) !== 0)
                break;
              if (Xe = Se.suspendedLanes, (Xe & Ue) !== Ue) {
                ca(), Se.pingedLanes |= Se.suspendedLanes & Xe;
                break;
              }
              Se.timeoutHandle = wd(Hd.bind(null, Se, js, Ql), Ce);
              break;
            }
            Hd(Se, js, Ql);
            break;
          case 4:
            if (Vc(Se, Ue), (Ue & 4194240) === Ue)
              break;
            for (Ce = Se.eventTimes, Xe = -1; 0 < Ue; ) {
              var $t = 31 - ka(Ue);
              it = 1 << $t, $t = Ce[$t], $t > Xe && (Xe = $t), Ue &= ~it;
            }
            if (Ue = Xe, Ue = xo() - Ue, Ue = (120 > Ue ? 120 : 480 > Ue ? 480 : 1080 > Ue ? 1080 : 1920 > Ue ? 1920 : 3e3 > Ue ? 3e3 : 4320 > Ue ? 4320 : 1960 * Zg(Ue / 1960)) - Ue, 10 < Ue) {
              Se.timeoutHandle = wd(Hd.bind(null, Se, js, Ql), Ue);
              break;
            }
            Hd(Se, js, Ql);
            break;
          case 5:
            Hd(Se, js, Ql);
            break;
          default:
            throw Error(fe(329));
        }
      }
    }
    return Si(Se, xo()), Se.callbackNode === Fe ? Gg.bind(null, Se) : null;
  }
  function Wp(Se, Ce) {
    var Fe = If;
    return Se.current.memoizedState.isDehydrated && (Vd(Se, Ce).flags |= 256), Se = cy(Se, Ce), Se !== 2 && (Ce = js, js = Fe, Ce !== null && Zp(Ce)), Se;
  }
  function Zp(Se) {
    js === null ? js = Se : js.push.apply(js, Se);
  }
  function Gp(Se) {
    for (var Ce = Se; ; ) {
      if (Ce.flags & 16384) {
        var Fe = Ce.updateQueue;
        if (Fe !== null && (Fe = Fe.stores, Fe !== null))
          for (var Ue = 0; Ue < Fe.length; Ue++) {
            var Xe = Fe[Ue], it = Xe.getSnapshot;
            Xe = Xe.value;
            try {
              if (!hu(it(), Xe))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (Fe = Ce.child, Ce.subtreeFlags & 16384 && Fe !== null)
        Fe.return = Ce, Ce = Fe;
      else {
        if (Ce === Se)
          break;
        for (; Ce.sibling === null; ) {
          if (Ce.return === null || Ce.return === Se)
            return !0;
          Ce = Ce.return;
        }
        Ce.sibling.return = Ce.return, Ce = Ce.sibling;
      }
    }
    return !0;
  }
  function Vc(Se, Ce) {
    for (Ce &= ~Up, Ce &= ~Bd, Se.suspendedLanes |= Ce, Se.pingedLanes &= ~Ce, Se = Se.expirationTimes; 0 < Ce; ) {
      var Fe = 31 - ka(Ce), Ue = 1 << Fe;
      Se[Fe] = -1, Ce &= ~Ue;
    }
  }
  function Yp(Se) {
    if (Io & 6)
      throw Error(fe(327));
    jf();
    var Ce = $a(Se, 0);
    if (!(Ce & 1))
      return Si(Se, xo()), null;
    var Fe = cy(Se, Ce);
    if (Se.tag !== 0 && Fe === 2) {
      var Ue = xl(Se);
      Ue !== 0 && (Ce = Ue, Fe = Wp(Se, Ue));
    }
    if (Fe === 1)
      throw Fe = Fd, Vd(Se, 0), Vc(Se, Ce), Si(Se, xo()), Fe;
    if (Fe === 6)
      throw Error(fe(345));
    return Se.finishedWork = Se.current.alternate, Se.finishedLanes = Ce, Hd(Se, js, Ql), Si(Se, xo()), null;
  }
  function uy(Se, Ce) {
    var Fe = Io;
    Io |= 1;
    try {
      return Se(Ce);
    } finally {
      Io = Fe, Io === 0 && (Mf = xo() + 500, xi && Os());
    }
  }
  function Ud(Se) {
    Uc !== null && Uc.tag === 0 && !(Io & 6) && jf();
    var Ce = Io;
    Io |= 1;
    var Fe = os.transition, Ue = jo;
    try {
      if (os.transition = null, jo = 1, Se)
        return Se();
    } finally {
      jo = Ue, os.transition = Fe, Io = Ce, !(Io & 6) && Os();
    }
  }
  function Uv() {
    tu = $f.current, Xo($f);
  }
  function Vd(Se, Ce) {
    Se.finishedWork = null, Se.finishedLanes = 0;
    var Fe = Se.timeoutHandle;
    if (Fe !== -1 && (Se.timeoutHandle = -1, _g(Fe)), Ua !== null)
      for (Fe = Ua.return; Fe !== null; ) {
        var Ue = Fe;
        switch (gv(Ue), Ue.tag) {
          case 1:
            Ue = Ue.type.childContextTypes, Ue != null && vu();
            break;
          case 3:
            jc(), Xo(Fa), Xo(Jn), Am();
            break;
          case 5:
            $o(Ue);
            break;
          case 4:
            jc();
            break;
          case 13:
            Xo(qn);
            break;
          case 19:
            Xo(qn);
            break;
          case 10:
            $c(Ue.type._context);
            break;
          case 22:
          case 23:
            Uv();
        }
        Fe = Fe.return;
      }
    if (ri = Se, Ua = Se = Hc(Se.current, null), Li = tu = Ce, pi = 0, Fd = null, Up = Bd = Ld = 0, js = If = null, Ni !== null) {
      for (Ce = 0; Ce < Ni.length; Ce++)
        if (Fe = Ni[Ce], Ue = Fe.interleaved, Ue !== null) {
          Fe.interleaved = null;
          var Xe = Ue.next, it = Fe.pending;
          if (it !== null) {
            var $t = it.next;
            it.next = Xe, Ue.next = $t;
          }
          Fe.pending = Ue;
        }
      Ni = null;
    }
    return Se;
  }
  function ly(Se, Ce) {
    do {
      var Fe = Ua;
      try {
        if (Ev(), Cm.current = Wm, Wn) {
          for (var Ue = Sa.memoizedState; Ue !== null; ) {
            var Xe = Ue.queue;
            Xe !== null && (Xe.pending = null), Ue = Ue.next;
          }
          Wn = !1;
        }
        if (Td = 0, Uo = Ir = Sa = null, fl = !1, Js = 0, jd.current = null, Fe === null || Fe.return === null) {
          pi = 1, Fd = Ce, Ua = null;
          break;
        }
        e: {
          var it = Se, $t = Fe.return, Kt = Fe, rr = Ce;
          if (Ce = Li, Kt.flags |= 32768, rr !== null && typeof rr == "object" && typeof rr.then == "function") {
            var Sr = rr, zr = Kt, Hr = zr.tag;
            if (!(zr.mode & 1) && (Hr === 0 || Hr === 11 || Hr === 15)) {
              var Ur = zr.alternate;
              Ur ? (zr.updateQueue = Ur.updateQueue, zr.memoizedState = Ur.memoizedState, zr.lanes = Ur.lanes) : (zr.updateQueue = null, zr.memoizedState = null);
            }
            var dn = Iv($t);
            if (dn !== null) {
              dn.flags &= -257, Mv(dn, $t, Kt, it, Ce), dn.mode & 1 && jg(it, Sr, Ce), Ce = dn, rr = Sr;
              var gn = Ce.updateQueue;
              if (gn === null) {
                var _n = /* @__PURE__ */ new Set();
                _n.add(rr), Ce.updateQueue = _n;
              } else
                gn.add(rr);
              break e;
            } else {
              if (!(Ce & 1)) {
                jg(it, Sr, Ce), Vv();
                break e;
              }
              rr = Error(fe(426));
            }
          } else if (Ea && Kt.mode & 1) {
            var Va = Iv($t);
            if (Va !== null) {
              !(Va.flags & 65536) && (Va.flags |= 256), Mv(Va, $t, Kt, it, Ce), _v(Tf(rr, Kt));
              break e;
            }
          }
          it = rr = Tf(rr, Kt), pi !== 4 && (pi = 2), If === null ? If = [it] : If.push(it), it = $t;
          do {
            switch (it.tag) {
              case 3:
                it.flags |= 65536, Ce &= -Ce, it.lanes |= Ce;
                var vr = Ng(it, rr, Ce);
                Tv(it, vr);
                break e;
              case 1:
                Kt = rr;
                var ar = it.type, wr = it.stateNode;
                if (!(it.flags & 128) && (typeof ar.getDerivedStateFromError == "function" || wr !== null && typeof wr.componentDidCatch == "function" && (Iu === null || !Iu.has(wr)))) {
                  it.flags |= 65536, Ce &= -Ce, it.lanes |= Ce;
                  var Yr = Np(it, Kt, Ce);
                  Tv(it, Yr);
                  break e;
                }
            }
            it = it.return;
          } while (it !== null);
        }
        Qg(Fe);
      } catch (an) {
        Ce = an, Ua === Fe && Fe !== null && (Ua = Fe = Fe.return);
        continue;
      }
      break;
    } while (1);
  }
  function Yg() {
    var Se = iy.current;
    return iy.current = Wm, Se === null ? Wm : Se;
  }
  function Vv() {
    (pi === 0 || pi === 3 || pi === 2) && (pi = 4), ri === null || !(Ld & 268435455) && !(Bd & 268435455) || Vc(ri, Li);
  }
  function cy(Se, Ce) {
    var Fe = Io;
    Io |= 2;
    var Ue = Yg();
    (ri !== Se || Li !== Ce) && (Ql = null, Vd(Se, Ce));
    do
      try {
        T_();
        break;
      } catch (Xe) {
        ly(Se, Xe);
      }
    while (1);
    if (Ev(), Io = Fe, iy.current = Ue, Ua !== null)
      throw Error(fe(261));
    return ri = null, Li = 0, pi;
  }
  function T_() {
    for (; Ua !== null; )
      Hv(Ua);
  }
  function k_() {
    for (; Ua !== null && !yi(); )
      Hv(Ua);
  }
  function Hv(Se) {
    var Ce = Wv(Se.alternate, Se, tu);
    Se.memoizedProps = Se.pendingProps, Ce === null ? Qg(Se) : Ua = Ce, jd.current = null;
  }
  function Qg(Se) {
    var Ce = Se;
    do {
      var Fe = Ce.alternate;
      if (Se = Ce.return, Ce.flags & 32768) {
        if (Fe = Bg(Fe, Ce), Fe !== null) {
          Fe.flags &= 32767, Ua = Fe;
          return;
        }
        if (Se !== null)
          Se.flags |= 32768, Se.subtreeFlags = 0, Se.deletions = null;
        else {
          pi = 6, Ua = null;
          return;
        }
      } else if (Fe = Lv(Fe, Ce, tu), Fe !== null) {
        Ua = Fe;
        return;
      }
      if (Ce = Ce.sibling, Ce !== null) {
        Ua = Ce;
        return;
      }
      Ua = Ce = Se;
    } while (Ce !== null);
    pi === 0 && (pi = 5);
  }
  function Hd(Se, Ce, Fe) {
    var Ue = jo, Xe = os.transition;
    try {
      os.transition = null, jo = 1, O_(Se, Ce, Fe, Ue);
    } finally {
      os.transition = Xe, jo = Ue;
    }
    return null;
  }
  function O_(Se, Ce, Fe, Ue) {
    do
      jf();
    while (Uc !== null);
    if (Io & 6)
      throw Error(fe(327));
    Fe = Se.finishedWork;
    var Xe = Se.finishedLanes;
    if (Fe === null)
      return null;
    if (Se.finishedWork = null, Se.finishedLanes = 0, Fe === Se.current)
      throw Error(fe(177));
    Se.callbackNode = null, Se.callbackPriority = 0;
    var it = Fe.lanes | Fe.childLanes;
    if (Hs(Se, it), Se === ri && (Ua = ri = null, Li = 0), !(Fe.subtreeFlags & 2064) && !(Fe.flags & 2064) || sy || (sy = !0, Jg(da, function() {
      return jf(), null;
    })), it = (Fe.flags & 15990) !== 0, Fe.subtreeFlags & 15990 || it) {
      it = os.transition, os.transition = null;
      var $t = jo;
      jo = 1;
      var Kt = Io;
      Io |= 4, jd.current = null, P_(Se, Fe), Hg(Fe, Se), fm(bd), Mi = !!dv, bd = dv = null, Se.current = Fe, Bp(Fe), _s(), Io = Kt, jo = $t, os.transition = it;
    } else
      Se.current = Fe;
    if (sy && (sy = !1, Uc = Se, Hp = Xe), it = Se.pendingLanes, it === 0 && (Iu = null), Es(Fe.stateNode), Si(Se, xo()), Ce !== null)
      for (Ue = Se.onRecoverableError, Fe = 0; Fe < Ce.length; Fe++)
        Xe = Ce[Fe], Ue(Xe.value, { componentStack: Xe.stack, digest: Xe.digest });
    if (zc)
      throw zc = !1, Se = Vp, Vp = null, Se;
    return Hp & 1 && Se.tag !== 0 && jf(), it = Se.pendingLanes, it & 1 ? Se === Nf ? Rf++ : (Rf = 0, Nf = Se) : Rf = 0, Os(), null;
  }
  function jf() {
    if (Uc !== null) {
      var Se = is(Hp), Ce = os.transition, Fe = jo;
      try {
        if (os.transition = null, jo = 16 > Se ? 16 : Se, Uc === null)
          var Ue = !1;
        else {
          if (Se = Uc, Uc = null, Hp = 0, Io & 6)
            throw Error(fe(331));
          var Xe = Io;
          for (Io |= 4, yn = Se.current; yn !== null; ) {
            var it = yn, $t = it.child;
            if (yn.flags & 16) {
              var Kt = it.deletions;
              if (Kt !== null) {
                for (var rr = 0; rr < Kt.length; rr++) {
                  var Sr = Kt[rr];
                  for (yn = Sr; yn !== null; ) {
                    var zr = yn;
                    switch (zr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Cf(8, zr, it);
                    }
                    var Hr = zr.child;
                    if (Hr !== null)
                      Hr.return = zr, yn = Hr;
                    else
                      for (; yn !== null; ) {
                        zr = yn;
                        var Ur = zr.sibling, dn = zr.return;
                        if (Ug(zr), zr === Sr) {
                          yn = null;
                          break;
                        }
                        if (Ur !== null) {
                          Ur.return = dn, yn = Ur;
                          break;
                        }
                        yn = dn;
                      }
                  }
                }
                var gn = it.alternate;
                if (gn !== null) {
                  var _n = gn.child;
                  if (_n !== null) {
                    gn.child = null;
                    do {
                      var Va = _n.sibling;
                      _n.sibling = null, _n = Va;
                    } while (_n !== null);
                  }
                }
                yn = it;
              }
            }
            if (it.subtreeFlags & 2064 && $t !== null)
              $t.return = it, yn = $t;
            else
              e:
                for (; yn !== null; ) {
                  if (it = yn, it.flags & 2048)
                    switch (it.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Cf(9, it, it.return);
                    }
                  var vr = it.sibling;
                  if (vr !== null) {
                    vr.return = it.return, yn = vr;
                    break e;
                  }
                  yn = it.return;
                }
          }
          var ar = Se.current;
          for (yn = ar; yn !== null; ) {
            $t = yn;
            var wr = $t.child;
            if ($t.subtreeFlags & 2064 && wr !== null)
              wr.return = $t, yn = wr;
            else
              e:
                for ($t = ar; yn !== null; ) {
                  if (Kt = yn, Kt.flags & 2048)
                    try {
                      switch (Kt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          ny(9, Kt);
                      }
                    } catch (an) {
                      La(Kt, Kt.return, an);
                    }
                  if (Kt === $t) {
                    yn = null;
                    break e;
                  }
                  var Yr = Kt.sibling;
                  if (Yr !== null) {
                    Yr.return = Kt.return, yn = Yr;
                    break e;
                  }
                  yn = Kt.return;
                }
          }
          if (Io = Xe, Os(), Ca && typeof Ca.onPostCommitFiberRoot == "function")
            try {
              Ca.onPostCommitFiberRoot(Ci, Se);
            } catch {
            }
          Ue = !0;
        }
        return Ue;
      } finally {
        jo = Fe, os.transition = Ce;
      }
    }
    return !1;
  }
  function Kg(Se, Ce, Fe) {
    Ce = Tf(Fe, Ce), Ce = Ng(Se, Ce, 1), Se = Mc(Se, Ce, 1), Ce = ca(), Se !== null && (Vs(Se, 1, Ce), Si(Se, Ce));
  }
  function La(Se, Ce, Fe) {
    if (Se.tag === 3)
      Kg(Se, Se, Fe);
    else
      for (; Ce !== null; ) {
        if (Ce.tag === 3) {
          Kg(Ce, Se, Fe);
          break;
        } else if (Ce.tag === 1) {
          var Ue = Ce.stateNode;
          if (typeof Ce.type.getDerivedStateFromError == "function" || typeof Ue.componentDidCatch == "function" && (Iu === null || !Iu.has(Ue))) {
            Se = Tf(Fe, Se), Se = Np(Ce, Se, 1), Ce = Mc(Ce, Se, 1), Se = ca(), Ce !== null && (Vs(Ce, 1, Se), Si(Ce, Se));
            break;
          }
        }
        Ce = Ce.return;
      }
  }
  function qv(Se, Ce, Fe) {
    var Ue = Se.pingCache;
    Ue !== null && Ue.delete(Ce), Ce = ca(), Se.pingedLanes |= Se.suspendedLanes & Fe, ri === Se && (Li & Fe) === Fe && (pi === 4 || pi === 3 && (Li & 130023424) === Li && 500 > xo() - zv ? Vd(Se, 0) : Up |= Fe), Si(Se, Ce);
  }
  function Xg(Se, Ce) {
    Ce === 0 && (Se.mode & 1 ? (Ce = Yi, Yi <<= 1, !(Yi & 130023424) && (Yi = 4194304)) : Ce = 1);
    var Fe = ca();
    Se = Vl(Se, Ce), Se !== null && (Vs(Se, Ce, Fe), Si(Se, Fe));
  }
  function A_(Se) {
    var Ce = Se.memoizedState, Fe = 0;
    Ce !== null && (Fe = Ce.retryLane), Xg(Se, Fe);
  }
  function C_(Se, Ce) {
    var Fe = 0;
    switch (Se.tag) {
      case 13:
        var Ue = Se.stateNode, Xe = Se.memoizedState;
        Xe !== null && (Fe = Xe.retryLane);
        break;
      case 19:
        Ue = Se.stateNode;
        break;
      default:
        throw Error(fe(314));
    }
    Ue !== null && Ue.delete(Ce), Xg(Se, Fe);
  }
  var Wv;
  Wv = function(Se, Ce, Fe) {
    if (Se !== null)
      if (Se.memoizedProps !== Ce.pendingProps || Fa.current)
        ti = !0;
      else {
        if (!(Se.lanes & Fe) && !(Ce.flags & 128))
          return ti = !1, ry(Se, Ce, Fe);
        ti = !!(Se.flags & 131072);
      }
    else
      ti = !1, Ea && Ce.flags & 1048576 && bv(Ce, gf, Ce.index);
    switch (Ce.lanes = 0, Ce.tag) {
      case 2:
        var Ue = Ce.type;
        Pu(Se, Ce), Se = Ce.pendingProps;
        var Xe = yu(Ce, Jn.current);
        Xr(Ce, Fe), Xe = Fc(null, Ce, Ue, Se, Xe, Fe);
        var it = Cd();
        return Ce.flags |= 1, typeof Xe == "object" && Xe !== null && typeof Xe.render == "function" && Xe.$$typeof === void 0 ? (Ce.tag = 1, Ce.memoizedState = null, Ce.updateQueue = null, Oa(Ue) ? (it = !0, bm(Ce)) : it = !1, Ce.memoizedState = Xe.state !== null && Xe.state !== void 0 ? Xe.state : null, Pv(Ce), Xe.updater = Tm, Ce.stateNode = Xe, Xe._reactInternals = Ce, km(Ce, Ue, Se, Fe), Ce = Nv(null, Ce, Ue, !0, it, Fe)) : (Ce.tag = 0, Ea && it && gm(Ce), di(null, Ce, Xe, Fe), Ce = Ce.child), Ce;
      case 16:
        Ue = Ce.elementType;
        e: {
          switch (Pu(Se, Ce), Se = Ce.pendingProps, Xe = Ue._init, Ue = Xe(Ue._payload), Ce.type = Ue, Xe = Ce.tag = I_(Ue), Se = Xs(Ue, Se), Xe) {
            case 0:
              Ce = kf(null, Ce, Ue, Se, Fe);
              break e;
            case 1:
              Ce = Rv(null, Ce, Ue, Se, Fe);
              break e;
            case 11:
              Ce = Dc(null, Ce, Ue, Se, Fe);
              break e;
            case 14:
              Ce = Ym(null, Ce, Ue, Xs(Ue.type, Se), Fe);
              break e;
          }
          throw Error(fe(306, Ue, ""));
        }
        return Ce;
      case 0:
        return Ue = Ce.type, Xe = Ce.pendingProps, Xe = Ce.elementType === Ue ? Xe : Xs(Ue, Xe), kf(Se, Ce, Ue, Xe, Fe);
      case 1:
        return Ue = Ce.type, Xe = Ce.pendingProps, Xe = Ce.elementType === Ue ? Xe : Xs(Ue, Xe), Rv(Se, Ce, Ue, Xe, Fe);
      case 3:
        e: {
          if (Qm(Ce), Se === null)
            throw Error(fe(387));
          Ue = Ce.pendingProps, it = Ce.memoizedState, Xe = it.element, ci(Se, Ce), Nc(Ce, Ue, null, Fe);
          var $t = Ce.memoizedState;
          if (Ue = $t.element, it.isDehydrated)
            if (it = { element: Ue, isDehydrated: !1, cache: $t.cache, pendingSuspenseBoundaries: $t.pendingSuspenseBoundaries, transitions: $t.transitions }, Ce.updateQueue.baseState = it, Ce.memoizedState = it, Ce.flags & 256) {
              Xe = Tf(Error(fe(423)), Ce), Ce = Of(Se, Ce, Ue, Fe, Xe);
              break e;
            } else if (Ue !== Xe) {
              Xe = Tf(Error(fe(424)), Ce), Ce = Of(Se, Ce, Ue, Fe, Xe);
              break e;
            } else
              for ($s = Yu(Ce.stateNode.containerInfo.firstChild), Ks = Ce, Ea = !0, gu = null, Fe = Mg(Ce, null, Ue, Fe), Ce.child = Fe; Fe; )
                Fe.flags = Fe.flags & -3 | 4096, Fe = Fe.sibling;
          else {
            if (Ia(), Ue === Xe) {
              Ce = ji(Se, Ce, Fe);
              break e;
            }
            di(Se, Ce, Ue, Fe);
          }
          Ce = Ce.child;
        }
        return Ce;
      case 5:
        return Ln(Ce), Se === null && _m(Ce), Ue = Ce.type, Xe = Ce.pendingProps, it = Se !== null ? Se.memoizedProps : null, $t = Xe.children, xp(Ue, Xe) ? $t = null : it !== null && xp(Ue, it) && (Ce.flags |= 32), wo(Se, Ce), di(Se, Ce, $t, Fe), Ce.child;
      case 6:
        return Se === null && _m(Ce), null;
      case 13:
        return Fg(Se, Ce, Fe);
      case 4:
        return Ov(Ce, Ce.stateNode.containerInfo), Ue = Ce.pendingProps, Se === null ? Ce.child = _f(Ce, null, Ue, Fe) : di(Se, Ce, Ue, Fe), Ce.child;
      case 11:
        return Ue = Ce.type, Xe = Ce.pendingProps, Xe = Ce.elementType === Ue ? Xe : Xs(Ue, Xe), Dc(Se, Ce, Ue, Xe, Fe);
      case 7:
        return di(Se, Ce, Ce.pendingProps, Fe), Ce.child;
      case 8:
        return di(Se, Ce, Ce.pendingProps.children, Fe), Ce.child;
      case 12:
        return di(Se, Ce, Ce.pendingProps.children, Fe), Ce.child;
      case 10:
        e: {
          if (Ue = Ce.type._context, Xe = Ce.pendingProps, it = Ce.memoizedProps, $t = Xe.value, ea(dl, Ue._currentValue), Ue._currentValue = $t, it !== null)
            if (hu(it.value, $t)) {
              if (it.children === Xe.children && !Fa.current) {
                Ce = ji(Se, Ce, Fe);
                break e;
              }
            } else
              for (it = Ce.child, it !== null && (it.return = Ce); it !== null; ) {
                var Kt = it.dependencies;
                if (Kt !== null) {
                  $t = it.child;
                  for (var rr = Kt.firstContext; rr !== null; ) {
                    if (rr.context === Ue) {
                      if (it.tag === 1) {
                        rr = Hl(-1, Fe & -Fe), rr.tag = 2;
                        var Sr = it.updateQueue;
                        if (Sr !== null) {
                          Sr = Sr.shared;
                          var zr = Sr.pending;
                          zr === null ? rr.next = rr : (rr.next = zr.next, zr.next = rr), Sr.pending = rr;
                        }
                      }
                      it.lanes |= Fe, rr = it.alternate, rr !== null && (rr.lanes |= Fe), Ei(it.return, Fe, Ce), Kt.lanes |= Fe;
                      break;
                    }
                    rr = rr.next;
                  }
                } else if (it.tag === 10)
                  $t = it.type === Ce.type ? null : it.child;
                else if (it.tag === 18) {
                  if ($t = it.return, $t === null)
                    throw Error(fe(341));
                  $t.lanes |= Fe, Kt = $t.alternate, Kt !== null && (Kt.lanes |= Fe), Ei($t, Fe, Ce), $t = it.sibling;
                } else
                  $t = it.child;
                if ($t !== null)
                  $t.return = it;
                else
                  for ($t = it; $t !== null; ) {
                    if ($t === Ce) {
                      $t = null;
                      break;
                    }
                    if (it = $t.sibling, it !== null) {
                      it.return = $t.return, $t = it;
                      break;
                    }
                    $t = $t.return;
                  }
                it = $t;
              }
          di(Se, Ce, Xe.children, Fe), Ce = Ce.child;
        }
        return Ce;
      case 9:
        return Xe = Ce.type, Ue = Ce.pendingProps.children, Xr(Ce, Fe), Xe = za(Xe), Ue = Ue(Xe), Ce.flags |= 1, di(Se, Ce, Ue, Fe), Ce.child;
      case 14:
        return Ue = Ce.type, Xe = Xs(Ue, Ce.pendingProps), Xe = Xs(Ue.type, Xe), Ym(Se, Ce, Ue, Xe, Fe);
      case 15:
        return Rs(Se, Ce, Ce.type, Ce.pendingProps, Fe);
      case 17:
        return Ue = Ce.type, Xe = Ce.pendingProps, Xe = Ce.elementType === Ue ? Xe : Xs(Ue, Xe), Pu(Se, Ce), Ce.tag = 1, Oa(Ue) ? (Se = !0, bm(Ce)) : Se = !1, Xr(Ce, Fe), Ag(Ce, Ue, Xe), km(Ce, Ue, Xe, Fe), Nv(null, Ce, Ue, !0, Se, Fe);
      case 19:
        return Ns(Se, Ce, Fe);
      case 22:
        return Rd(Se, Ce, Fe);
    }
    throw Error(fe(156, Ce.tag));
  };
  function Jg(Se, Ce) {
    return Zo(Se, Ce);
  }
  function $_(Se, Ce, Fe, Ue) {
    this.tag = Se, this.key = Fe, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = Ce, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Ue, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Fu(Se, Ce, Fe, Ue) {
    return new $_(Se, Ce, Fe, Ue);
  }
  function Zv(Se) {
    return Se = Se.prototype, !(!Se || !Se.isReactComponent);
  }
  function I_(Se) {
    if (typeof Se == "function")
      return Zv(Se) ? 1 : 0;
    if (Se != null) {
      if (Se = Se.$$typeof, Se === Ot)
        return 11;
      if (Se === wt)
        return 14;
    }
    return 2;
  }
  function Hc(Se, Ce) {
    var Fe = Se.alternate;
    return Fe === null ? (Fe = Fu(Se.tag, Ce, Se.key, Se.mode), Fe.elementType = Se.elementType, Fe.type = Se.type, Fe.stateNode = Se.stateNode, Fe.alternate = Se, Se.alternate = Fe) : (Fe.pendingProps = Ce, Fe.type = Se.type, Fe.flags = 0, Fe.subtreeFlags = 0, Fe.deletions = null), Fe.flags = Se.flags & 14680064, Fe.childLanes = Se.childLanes, Fe.lanes = Se.lanes, Fe.child = Se.child, Fe.memoizedProps = Se.memoizedProps, Fe.memoizedState = Se.memoizedState, Fe.updateQueue = Se.updateQueue, Ce = Se.dependencies, Fe.dependencies = Ce === null ? null : { lanes: Ce.lanes, firstContext: Ce.firstContext }, Fe.sibling = Se.sibling, Fe.index = Se.index, Fe.ref = Se.ref, Fe;
  }
  function dy(Se, Ce, Fe, Ue, Xe, it) {
    var $t = 2;
    if (Ue = Se, typeof Se == "function")
      Zv(Se) && ($t = 1);
    else if (typeof Se == "string")
      $t = 5;
    else
      e:
        switch (Se) {
          case Ut:
            return qc(Fe.children, Xe, it, Ce);
          case Zt:
            $t = 8, Xe |= 8;
            break;
          case tr:
            return Se = Fu(12, Fe, Ce, Xe | 2), Se.elementType = tr, Se.lanes = it, Se;
          case Qe:
            return Se = Fu(13, Fe, Ce, Xe), Se.elementType = Qe, Se.lanes = it, Se;
          case at:
            return Se = Fu(19, Fe, Ce, Xe), Se.elementType = at, Se.lanes = it, Se;
          case At:
            return Ff(Fe, Xe, it, Ce);
          default:
            if (typeof Se == "object" && Se !== null)
              switch (Se.$$typeof) {
                case er:
                  $t = 10;
                  break e;
                case hr:
                  $t = 9;
                  break e;
                case Ot:
                  $t = 11;
                  break e;
                case wt:
                  $t = 14;
                  break e;
                case bt:
                  $t = 16, Ue = null;
                  break e;
              }
            throw Error(fe(130, Se == null ? Se : typeof Se, ""));
        }
    return Ce = Fu($t, Fe, Ce, Xe), Ce.elementType = Se, Ce.type = Ue, Ce.lanes = it, Ce;
  }
  function qc(Se, Ce, Fe, Ue) {
    return Se = Fu(7, Se, Ue, Ce), Se.lanes = Fe, Se;
  }
  function Ff(Se, Ce, Fe, Ue) {
    return Se = Fu(22, Se, Ue, Ce), Se.elementType = At, Se.lanes = Fe, Se.stateNode = { isHidden: !1 }, Se;
  }
  function qd(Se, Ce, Fe) {
    return Se = Fu(6, Se, null, Ce), Se.lanes = Fe, Se;
  }
  function Gv(Se, Ce, Fe) {
    return Ce = Fu(4, Se.children !== null ? Se.children : [], Se.key, Ce), Ce.lanes = Fe, Ce.stateNode = { containerInfo: Se.containerInfo, pendingChildren: null, implementation: Se.implementation }, Ce;
  }
  function e0(Se, Ce, Fe, Ue, Xe) {
    this.tag = Ce, this.containerInfo = Se, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = El(0), this.expirationTimes = El(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = El(0), this.identifierPrefix = Ue, this.onRecoverableError = Xe, this.mutableSourceEagerHydrationData = null;
  }
  function fy(Se, Ce, Fe, Ue, Xe, it, $t, Kt, rr) {
    return Se = new e0(Se, Ce, Fe, Kt, rr), Ce === 1 ? (Ce = 1, it === !0 && (Ce |= 8)) : Ce = 0, it = Fu(3, null, null, Ce), Se.current = it, it.stateNode = Se, it.memoizedState = { element: Ue, isDehydrated: Fe, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Pv(it), Se;
  }
  function t0(Se, Ce, Fe) {
    var Ue = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Vt, key: Ue == null ? null : "" + Ue, children: Se, containerInfo: Ce, implementation: Fe };
  }
  function r0(Se) {
    if (!Se)
      return cl;
    Se = Se._reactInternals;
    e: {
      if (mn(Se) !== Se || Se.tag !== 1)
        throw Error(fe(170));
      var Ce = Se;
      do {
        switch (Ce.tag) {
          case 3:
            Ce = Ce.stateNode.context;
            break e;
          case 1:
            if (Oa(Ce.type)) {
              Ce = Ce.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        Ce = Ce.return;
      } while (Ce !== null);
      throw Error(fe(171));
    }
    if (Se.tag === 1) {
      var Fe = Se.type;
      if (Oa(Fe))
        return Pp(Se, Fe, Ce);
    }
    return Ce;
  }
  function Yv(Se, Ce, Fe, Ue, Xe, it, $t, Kt, rr) {
    return Se = fy(Fe, Ue, !0, Se, Xe, it, $t, Kt, rr), Se.context = r0(null), Fe = Se.current, Ue = ca(), Xe = ru(Fe), it = Hl(Ue, Xe), it.callback = Ce ?? null, Mc(Fe, it, Xe), Se.current.lanes = Xe, Vs(Se, Xe, Ue), Si(Se, Ue), Se;
  }
  function py(Se, Ce, Fe, Ue) {
    var Xe = Ce.current, it = ca(), $t = ru(Xe);
    return Fe = r0(Fe), Ce.context === null ? Ce.context = Fe : Ce.pendingContext = Fe, Ce = Hl(it, $t), Ce.payload = { element: Se }, Ue = Ue === void 0 ? null : Ue, Ue !== null && (Ce.callback = Ue), Se = Mc(Xe, Ce, $t), Se !== null && (nu(Se, Xe, $t, it), Pm(Se, Xe, $t)), $t;
  }
  function hy(Se) {
    if (Se = Se.current, !Se.child)
      return null;
    switch (Se.child.tag) {
      case 5:
        return Se.child.stateNode;
      default:
        return Se.child.stateNode;
    }
  }
  function n0(Se, Ce) {
    if (Se = Se.memoizedState, Se !== null && Se.dehydrated !== null) {
      var Fe = Se.retryLane;
      Se.retryLane = Fe !== 0 && Fe < Ce ? Fe : Ce;
    }
  }
  function my(Se, Ce) {
    n0(Se, Ce), (Se = Se.alternate) && n0(Se, Ce);
  }
  function o0() {
    return null;
  }
  var Qv = typeof reportError == "function" ? reportError : function(Se) {
    console.error(Se);
  };
  function Wc(Se) {
    this._internalRoot = Se;
  }
  yy.prototype.render = Wc.prototype.render = function(Se) {
    var Ce = this._internalRoot;
    if (Ce === null)
      throw Error(fe(409));
    py(Se, Ce, null, null);
  }, yy.prototype.unmount = Wc.prototype.unmount = function() {
    var Se = this._internalRoot;
    if (Se !== null) {
      this._internalRoot = null;
      var Ce = Se.containerInfo;
      Ud(function() {
        py(null, Se, null, null);
      }), Ce[Dl] = null;
    }
  };
  function yy(Se) {
    this._internalRoot = Se;
  }
  yy.prototype.unstable_scheduleHydration = function(Se) {
    if (Se) {
      var Ce = al();
      Se = { blockedOn: null, target: Se, priority: Ce };
      for (var Fe = 0; Fe < Lo.length && Ce !== 0 && Ce < Lo[Fe].priority; Fe++)
        ;
      Lo.splice(Fe, 0, Se), Fe === 0 && il(Se);
    }
  };
  function Kv(Se) {
    return !(!Se || Se.nodeType !== 1 && Se.nodeType !== 9 && Se.nodeType !== 11);
  }
  function vy(Se) {
    return !(!Se || Se.nodeType !== 1 && Se.nodeType !== 9 && Se.nodeType !== 11 && (Se.nodeType !== 8 || Se.nodeValue !== " react-mount-point-unstable "));
  }
  function a0() {
  }
  function R_(Se, Ce, Fe, Ue, Xe) {
    if (Xe) {
      if (typeof Ue == "function") {
        var it = Ue;
        Ue = function() {
          var Sr = hy($t);
          it.call(Sr);
        };
      }
      var $t = Yv(Ce, Ue, Se, 0, null, !1, !1, "", a0);
      return Se._reactRootContainer = $t, Se[Dl] = $t.current, vf(Se.nodeType === 8 ? Se.parentNode : Se), Ud(), $t;
    }
    for (; Xe = Se.lastChild; )
      Se.removeChild(Xe);
    if (typeof Ue == "function") {
      var Kt = Ue;
      Ue = function() {
        var Sr = hy(rr);
        Kt.call(Sr);
      };
    }
    var rr = fy(Se, 0, !1, null, null, !1, !1, "", a0);
    return Se._reactRootContainer = rr, Se[Dl] = rr.current, vf(Se.nodeType === 8 ? Se.parentNode : Se), Ud(function() {
      py(Ce, rr, Fe, Ue);
    }), rr;
  }
  function by(Se, Ce, Fe, Ue, Xe) {
    var it = Fe._reactRootContainer;
    if (it) {
      var $t = it;
      if (typeof Xe == "function") {
        var Kt = Xe;
        Xe = function() {
          var rr = hy($t);
          Kt.call(rr);
        };
      }
      py(Ce, $t, Se, Xe);
    } else
      $t = R_(Fe, Ce, Se, Xe, Ue);
    return hy($t);
  }
  hc = function(Se) {
    switch (Se.tag) {
      case 3:
        var Ce = Se.stateNode;
        if (Ce.current.memoizedState.isDehydrated) {
          var Fe = $i(Ce.pendingLanes);
          Fe !== 0 && (qs(Ce, Fe | 1), Si(Ce, xo()), !(Io & 6) && (Mf = xo() + 500, Os()));
        }
        break;
      case 13:
        Ud(function() {
          var Ue = Vl(Se, 1);
          if (Ue !== null) {
            var Xe = ca();
            nu(Ue, Se, 1, Xe);
          }
        }), my(Se, 1);
    }
  }, qa = function(Se) {
    if (Se.tag === 13) {
      var Ce = Vl(Se, 134217728);
      if (Ce !== null) {
        var Fe = ca();
        nu(Ce, Se, 134217728, Fe);
      }
      my(Se, 134217728);
    }
  }, Fo = function(Se) {
    if (Se.tag === 13) {
      var Ce = ru(Se), Fe = Vl(Se, Ce);
      if (Fe !== null) {
        var Ue = ca();
        nu(Fe, Se, Ce, Ue);
      }
      my(Se, Ce);
    }
  }, al = function() {
    return jo;
  }, Sl = function(Se, Ce) {
    var Fe = jo;
    try {
      return jo = Se, Ce();
    } finally {
      jo = Fe;
    }
  }, Fn = function(Se, Ce, Fe) {
    switch (Ce) {
      case "input":
        if (fo(Se, Fe), Ce = Fe.name, Fe.type === "radio" && Ce != null) {
          for (Fe = Se; Fe.parentNode; )
            Fe = Fe.parentNode;
          for (Fe = Fe.querySelectorAll("input[name=" + JSON.stringify("" + Ce) + '][type="radio"]'), Ce = 0; Ce < Fe.length; Ce++) {
            var Ue = Fe[Ce];
            if (Ue !== Se && Ue.form === Se.form) {
              var Xe = Nn(Ue);
              if (!Xe)
                throw Error(fe(90));
              co(Ue), fo(Ue, Xe);
            }
          }
        }
        break;
      case "textarea":
        ra(Se, Fe);
        break;
      case "select":
        Ce = Fe.value, Ce != null && Ko(Se, !!Fe.multiple, Ce, !1);
    }
  }, No = uy, Ao = Ud;
  var i0 = { usingClientEntryPoint: !1, Events: [Sp, bf, Nn, Oo, ii, uy] }, Qp = { findFiberByHostInstance: mu, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, N_ = { bundleType: Qp.bundleType, version: Qp.version, rendererPackageName: Qp.rendererPackageName, rendererConfig: Qp.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ct.ReactCurrentDispatcher, findHostInstanceByFiber: function(Se) {
    return Se = na(Se), Se === null ? null : Se.stateNode;
  }, findFiberByHostInstance: Qp.findFiberByHostInstance || o0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Lf = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Lf.isDisabled && Lf.supportsFiber))
    try {
      Ci = Lf.inject(N_), Ca = Lf;
    } catch {
    }
  var Lf;
  ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = i0, ne.createPortal = function(Se, Ce) {
    var Fe = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Kv(Ce))
      throw Error(fe(200));
    return t0(Se, Ce, null, Fe);
  }, ne.createRoot = function(Se, Ce) {
    if (!Kv(Se))
      throw Error(fe(299));
    var Fe = !1, Ue = "", Xe = Qv;
    return Ce != null && (Ce.unstable_strictMode === !0 && (Fe = !0), Ce.identifierPrefix !== void 0 && (Ue = Ce.identifierPrefix), Ce.onRecoverableError !== void 0 && (Xe = Ce.onRecoverableError)), Ce = fy(Se, 1, !1, null, null, Fe, !1, Ue, Xe), Se[Dl] = Ce.current, vf(Se.nodeType === 8 ? Se.parentNode : Se), new Wc(Ce);
  }, ne.findDOMNode = function(Se) {
    if (Se == null)
      return null;
    if (Se.nodeType === 1)
      return Se;
    var Ce = Se._reactInternals;
    if (Ce === void 0)
      throw typeof Se.render == "function" ? Error(fe(188)) : (Se = Object.keys(Se).join(","), Error(fe(268, Se)));
    return Se = na(Ce), Se = Se === null ? null : Se.stateNode, Se;
  }, ne.flushSync = function(Se) {
    return Ud(Se);
  }, ne.hydrate = function(Se, Ce, Fe) {
    if (!vy(Ce))
      throw Error(fe(200));
    return by(null, Se, Ce, !0, Fe);
  }, ne.hydrateRoot = function(Se, Ce, Fe) {
    if (!Kv(Se))
      throw Error(fe(405));
    var Ue = Fe != null && Fe.hydratedSources || null, Xe = !1, it = "", $t = Qv;
    if (Fe != null && (Fe.unstable_strictMode === !0 && (Xe = !0), Fe.identifierPrefix !== void 0 && (it = Fe.identifierPrefix), Fe.onRecoverableError !== void 0 && ($t = Fe.onRecoverableError)), Ce = Yv(Ce, null, Se, 1, Fe ?? null, Xe, !1, it, $t), Se[Dl] = Ce.current, vf(Se), Ue)
      for (Se = 0; Se < Ue.length; Se++)
        Fe = Ue[Se], Xe = Fe._getVersion, Xe = Xe(Fe._source), Ce.mutableSourceEagerHydrationData == null ? Ce.mutableSourceEagerHydrationData = [Fe, Xe] : Ce.mutableSourceEagerHydrationData.push(Fe, Xe);
    return new yy(Ce);
  }, ne.render = function(Se, Ce, Fe) {
    if (!vy(Ce))
      throw Error(fe(200));
    return by(null, Se, Ce, !1, Fe);
  }, ne.unmountComponentAtNode = function(Se) {
    if (!vy(Se))
      throw Error(fe(40));
    return Se._reactRootContainer ? (Ud(function() {
      by(null, null, Se, !1, function() {
        Se._reactRootContainer = null, Se[Dl] = null;
      });
    }), !0) : !1;
  }, ne.unstable_batchedUpdates = uy, ne.unstable_renderSubtreeIntoContainer = function(Se, Ce, Fe, Ue) {
    if (!vy(Fe))
      throw Error(fe(200));
    if (Se == null || Se._reactInternals === void 0)
      throw Error(fe(38));
    return by(Se, Ce, Fe, !1, Ue);
  }, ne.version = "18.2.0-next-9e3b772b8-20220608";
}), hz = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = ir(), ae = GR(), fe = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ye = !1;
    function ve(me) {
      ye = me;
    }
    function _e(me) {
      if (!ye) {
        for (var we = arguments.length, Ie = new Array(we > 1 ? we - 1 : 0), Ne = 1; Ne < we; Ne++)
          Ie[Ne - 1] = arguments[Ne];
        Oe("warn", me, Ie);
      }
    }
    function xe(me) {
      if (!ye) {
        for (var we = arguments.length, Ie = new Array(we > 1 ? we - 1 : 0), Ne = 1; Ne < we; Ne++)
          Ie[Ne - 1] = arguments[Ne];
        Oe("error", me, Ie);
      }
    }
    function Oe(me, we, Ie) {
      {
        var Ne = fe.ReactDebugCurrentFrame, De = Ne.getStackAddendum();
        De !== "" && (we += "%s", Ie = Ie.concat([De]));
        var Ze = Ie.map(function(tt) {
          return String(tt);
        });
        Ze.unshift("Warning: " + we), Function.prototype.apply.call(console[me], console, Ze);
      }
    }
    var $e = 0, Me = 1, Re = 2, je = 3, Be = 4, ze = 5, He = 6, qe = 7, Ye = 8, pt = 9, dt = 10, yt = 11, Ct = 12, It = 13, Vt = 14, Ut = 15, Zt = 16, tr = 17, er = 18, hr = 19, Ot = 21, Qe = 22, at = 23, wt = 24, bt = 25, At = !0, Ft = !1, Gt = !1, ot = !1, et = !1, Rt = !0, xr = !1, Xt = !1, dr = !0, Nr = !0, Dr = !0, jr = /* @__PURE__ */ new Set(), un = {}, so = {};
    function Pn(me, we) {
      co(me, we), co(me + "Capture", we);
    }
    function co(me, we) {
      un[me] && xe("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", me), un[me] = we;
      {
        var Ie = me.toLowerCase();
        so[Ie] = me, me === "onDoubleClick" && (so.ondblclick = me);
      }
      for (var Ne = 0; Ne < we.length; Ne++)
        jr.add(we[Ne]);
    }
    var kn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Yn = Object.prototype.hasOwnProperty;
    function Ho(me) {
      {
        var we = typeof Symbol == "function" && Symbol.toStringTag, Ie = we && me[Symbol.toStringTag] || me.constructor.name || "Object";
        return Ie;
      }
    }
    function Rn(me) {
      try {
        return fo(me), !1;
      } catch {
        return !0;
      }
    }
    function fo(me) {
      return "" + me;
    }
    function pa(me, we) {
      if (Rn(me))
        return xe("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", we, Ho(me)), fo(me);
    }
    function jn(me) {
      if (Rn(me))
        return xe("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ho(me)), fo(me);
    }
    function Xn(me, we) {
      if (Rn(me))
        return xe("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", we, Ho(me)), fo(me);
    }
    function Ko(me, we) {
      if (Rn(me))
        return xe("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", we, Ho(me)), fo(me);
    }
    function vo(me) {
      if (Rn(me))
        return xe("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Ho(me)), fo(me);
    }
    function Eo(me) {
      if (Rn(me))
        return xe("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Ho(me)), fo(me);
    }
    var ra = 0, uo = 1, So = 2, Jo = 3, Po = 4, Jt = 5, or = 6, fr = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Mr = fr + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Wr = new RegExp("^[" + fr + "][" + Mr + "]*$"), Vr = {}, Zr = {};
    function on(me) {
      return Yn.call(Zr, me) ? !0 : Yn.call(Vr, me) ? !1 : Wr.test(me) ? (Zr[me] = !0, !0) : (Vr[me] = !0, xe("Invalid attribute name: `%s`", me), !1);
    }
    function Lr(me, we, Ie) {
      return we !== null ? we.type === ra : Ie ? !1 : me.length > 2 && (me[0] === "o" || me[0] === "O") && (me[1] === "n" || me[1] === "N");
    }
    function tn(me, we, Ie, Ne) {
      if (Ie !== null && Ie.type === ra)
        return !1;
      switch (typeof we) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (Ne)
            return !1;
          if (Ie !== null)
            return !Ie.acceptsBooleans;
          var De = me.toLowerCase().slice(0, 5);
          return De !== "data-" && De !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Qn(me, we, Ie, Ne) {
      if (we === null || typeof we > "u" || tn(me, we, Ie, Ne))
        return !0;
      if (Ne)
        return !1;
      if (Ie !== null)
        switch (Ie.type) {
          case Jo:
            return !we;
          case Po:
            return we === !1;
          case Jt:
            return isNaN(we);
          case or:
            return isNaN(we) || we < 1;
        }
      return !1;
    }
    function Fn(me) {
      return An.hasOwnProperty(me) ? An[me] : null;
    }
    function en(me, we, Ie, Ne, De, Ze, tt) {
      this.acceptsBooleans = we === So || we === Jo || we === Po, this.attributeName = Ne, this.attributeNamespace = De, this.mustUseProperty = Ie, this.propertyName = me, this.type = we, this.sanitizeURL = Ze, this.removeEmptyString = tt;
    }
    var An = {}, zn = ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"];
    zn.forEach(function(me) {
      An[me] = new en(me, ra, !1, me, null, !1, !1);
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(me) {
      var we = me[0], Ie = me[1];
      An[we] = new en(we, uo, !1, Ie, null, !1, !1);
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(me) {
      An[me] = new en(me, So, !1, me.toLowerCase(), null, !1, !1);
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(me) {
      An[me] = new en(me, So, !1, me, null, !1, !1);
    }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(function(me) {
      An[me] = new en(me, Jo, !1, me.toLowerCase(), null, !1, !1);
    }), ["checked", "multiple", "muted", "selected"].forEach(function(me) {
      An[me] = new en(me, Jo, !0, me, null, !1, !1);
    }), ["capture", "download"].forEach(function(me) {
      An[me] = new en(me, Po, !1, me, null, !1, !1);
    }), ["cols", "rows", "size", "span"].forEach(function(me) {
      An[me] = new en(me, or, !1, me, null, !1, !1);
    }), ["rowSpan", "start"].forEach(function(me) {
      An[me] = new en(me, Jt, !1, me.toLowerCase(), null, !1, !1);
    });
    var Oo = /[\-\:]([a-z])/g, ii = function(me) {
      return me[1].toUpperCase();
    };
    ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(function(me) {
      var we = me.replace(Oo, ii);
      An[we] = new en(we, uo, !1, me, null, !1, !1);
    }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(function(me) {
      var we = me.replace(Oo, ii);
      An[we] = new en(we, uo, !1, me, "http://www.w3.org/1999/xlink", !1, !1);
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function(me) {
      var we = me.replace(Oo, ii);
      An[we] = new en(we, uo, !1, me, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }), ["tabIndex", "crossOrigin"].forEach(function(me) {
      An[me] = new en(me, uo, !1, me.toLowerCase(), null, !1, !1);
    });
    var No = "xlinkHref";
    An[No] = new en("xlinkHref", uo, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(me) {
      An[me] = new en(me, uo, !1, me.toLowerCase(), null, !0, !0);
    });
    var Ao = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Da = !1;
    function po(me) {
      !Da && Ao.test(me) && (Da = !0, xe("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(me)));
    }
    function _o(me, we, Ie, Ne) {
      if (Ne.mustUseProperty) {
        var De = Ne.propertyName;
        return me[De];
      } else {
        pa(Ie, we), Ne.sanitizeURL && po("" + Ie);
        var Ze = Ne.attributeName, tt = null;
        if (Ne.type === Po) {
          if (me.hasAttribute(Ze)) {
            var ht = me.getAttribute(Ze);
            return ht === "" ? !0 : Qn(we, Ie, Ne, !1) ? ht : ht === "" + Ie ? Ie : ht;
          }
        } else if (me.hasAttribute(Ze)) {
          if (Qn(we, Ie, Ne, !1))
            return me.getAttribute(Ze);
          if (Ne.type === Jo)
            return Ie;
          tt = me.getAttribute(Ze);
        }
        return Qn(we, Ie, Ne, !1) ? tt === null ? Ie : tt : tt === "" + Ie ? Ie : tt;
      }
    }
    function Ba(me, we, Ie, Ne) {
      {
        if (!on(we))
          return;
        if (!me.hasAttribute(we))
          return Ie === void 0 ? void 0 : null;
        var De = me.getAttribute(we);
        return pa(Ie, we), De === "" + Ie ? Ie : De;
      }
    }
    function bo(me, we, Ie, Ne) {
      var De = Fn(we);
      if (!Lr(we, De, Ne)) {
        if (Qn(we, Ie, De, Ne) && (Ie = null), Ne || De === null) {
          if (on(we)) {
            var Ze = we;
            Ie === null ? me.removeAttribute(Ze) : (pa(Ie, we), me.setAttribute(Ze, "" + Ie));
          }
          return;
        }
        var tt = De.mustUseProperty;
        if (tt) {
          var ht = De.propertyName;
          if (Ie === null) {
            var St = De.type;
            me[ht] = St === Jo ? !1 : "";
          } else
            me[ht] = Ie;
          return;
        }
        var Nt = De.attributeName, Bt = De.attributeNamespace;
        if (Ie === null)
          me.removeAttribute(Nt);
        else {
          var lr = De.type, nr;
          lr === Jo || lr === Po && Ie === !0 ? nr = "" : (pa(Ie, Nt), nr = "" + Ie, De.sanitizeURL && po(nr.toString())), Bt ? me.setAttributeNS(Bt, Nt, nr) : me.setAttribute(Nt, nr);
        }
      }
    }
    var $n = Symbol.for("react.element"), Bo = Symbol.for("react.portal"), ho = Symbol.for("react.fragment"), To = Symbol.for("react.strict_mode"), Qt = Symbol.for("react.profiler"), kr = Symbol.for("react.provider"), Tr = Symbol.for("react.context"), vn = Symbol.for("react.forward_ref"), mn = Symbol.for("react.suspense"), En = Symbol.for("react.suspense_list"), Zn = Symbol.for("react.memo"), xn = Symbol.for("react.lazy"), na = Symbol.for("react.scope"), Wo = Symbol.for("react.debug_trace_mode"), Zo = Symbol.for("react.offscreen"), va = Symbol.for("react.legacy_hidden"), yi = Symbol.for("react.cache"), _s = Symbol.for("react.tracing_marker"), xo = Symbol.iterator, qu = "@@iterator";
    function si(me) {
      if (me === null || typeof me != "object")
        return null;
      var we = xo && me[xo] || me[qu];
      return typeof we == "function" ? we : null;
    }
    var oo = Object.assign, da = 0, xs, as, Ci, Ca, Es, ka, rl;
    function nl() {
    }
    nl.__reactDisabledLog = !0;
    function od() {
      {
        if (da === 0) {
          xs = console.log, as = console.info, Ci = console.warn, Ca = console.error, Es = console.group, ka = console.groupCollapsed, rl = console.groupEnd;
          var me = { configurable: !0, enumerable: !0, value: nl, writable: !0 };
          Object.defineProperties(console, { info: me, log: me, warn: me, error: me, group: me, groupCollapsed: me, groupEnd: me });
        }
        da++;
      }
    }
    function ol() {
      {
        if (da--, da === 0) {
          var me = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: oo({}, me, { value: xs }), info: oo({}, me, { value: as }), warn: oo({}, me, { value: Ci }), error: oo({}, me, { value: Ca }), group: oo({}, me, { value: Es }), groupCollapsed: oo({}, me, { value: ka }), groupEnd: oo({}, me, { value: rl }) });
        }
        da < 0 && xe("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Yi = fe.ReactCurrentDispatcher, $i;
    function $a(me, we, Ie) {
      {
        if ($i === void 0)
          try {
            throw Error();
          } catch (De) {
            var Ne = De.stack.trim().match(/\n( *(at )?)/);
            $i = Ne && Ne[1] || "";
          }
        return `
` + $i + me;
      }
    }
    var Us = !1, ts;
    {
      var xl = typeof WeakMap == "function" ? WeakMap : Map;
      ts = new xl();
    }
    function lu(me, we) {
      if (!me || Us)
        return "";
      {
        var Ie = ts.get(me);
        if (Ie !== void 0)
          return Ie;
      }
      var Ne;
      Us = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ze;
      Ze = Yi.current, Yi.current = null, od();
      try {
        if (we) {
          var tt = function() {
            throw Error();
          };
          if (Object.defineProperty(tt.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(tt, []);
            } catch (Er) {
              Ne = Er;
            }
            Reflect.construct(me, [], tt);
          } else {
            try {
              tt.call();
            } catch (Er) {
              Ne = Er;
            }
            me.call(tt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Er) {
            Ne = Er;
          }
          me();
        }
      } catch (Er) {
        if (Er && Ne && typeof Er.stack == "string") {
          for (var ht = Er.stack.split(`
`), St = Ne.stack.split(`
`), Nt = ht.length - 1, Bt = St.length - 1; Nt >= 1 && Bt >= 0 && ht[Nt] !== St[Bt]; )
            Bt--;
          for (; Nt >= 1 && Bt >= 0; Nt--, Bt--)
            if (ht[Nt] !== St[Bt]) {
              if (Nt !== 1 || Bt !== 1)
                do
                  if (Nt--, Bt--, Bt < 0 || ht[Nt] !== St[Bt]) {
                    var lr = `
` + ht[Nt].replace(" at new ", " at ");
                    return me.displayName && lr.includes("<anonymous>") && (lr = lr.replace("<anonymous>", me.displayName)), typeof me == "function" && ts.set(me, lr), lr;
                  }
                while (Nt >= 1 && Bt >= 0);
              break;
            }
        }
      } finally {
        Us = !1, Yi.current = Ze, ol(), Error.prepareStackTrace = De;
      }
      var nr = me ? me.displayName || me.name : "", _r = nr ? $a(nr) : "";
      return typeof me == "function" && ts.set(me, _r), _r;
    }
    function El(me, we, Ie) {
      return lu(me, !0);
    }
    function Vs(me, we, Ie) {
      return lu(me, !1);
    }
    function Hs(me) {
      var we = me.prototype;
      return !!(we && we.isReactComponent);
    }
    function qs(me, we, Ie) {
      if (me == null)
        return "";
      if (typeof me == "function")
        return lu(me, Hs(me));
      if (typeof me == "string")
        return $a(me);
      switch (me) {
        case mn:
          return $a("Suspense");
        case En:
          return $a("SuspenseList");
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case vn:
            return Vs(me.render);
          case Zn:
            return qs(me.type, we, Ie);
          case xn: {
            var Ne = me, De = Ne._payload, Ze = Ne._init;
            try {
              return qs(Ze(De), we, Ie);
            } catch {
            }
          }
        }
      return "";
    }
    function jo(me) {
      switch (me._debugOwner && me._debugOwner.type, me._debugSource, me.tag) {
        case ze:
          return $a(me.type);
        case Zt:
          return $a("Lazy");
        case It:
          return $a("Suspense");
        case hr:
          return $a("SuspenseList");
        case $e:
        case Re:
        case Ut:
          return Vs(me.type);
        case yt:
          return Vs(me.type.render);
        case Me:
          return El(me.type);
        default:
          return "";
      }
    }
    function is(me) {
      try {
        var we = "", Ie = me;
        do
          we += jo(Ie), Ie = Ie.return;
        while (Ie);
        return we;
      } catch (Ne) {
        return `
Error generating stack: ` + Ne.message + `
` + Ne.stack;
      }
    }
    function hc(me, we, Ie) {
      var Ne = me.displayName;
      if (Ne)
        return Ne;
      var De = we.displayName || we.name || "";
      return De !== "" ? Ie + "(" + De + ")" : Ie;
    }
    function qa(me) {
      return me.displayName || "Context";
    }
    function Fo(me) {
      if (me == null)
        return null;
      if (typeof me.tag == "number" && xe("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof me == "function")
        return me.displayName || me.name || null;
      if (typeof me == "string")
        return me;
      switch (me) {
        case ho:
          return "Fragment";
        case Bo:
          return "Portal";
        case Qt:
          return "Profiler";
        case To:
          return "StrictMode";
        case mn:
          return "Suspense";
        case En:
          return "SuspenseList";
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case Tr:
            var we = me;
            return qa(we) + ".Consumer";
          case kr:
            var Ie = me;
            return qa(Ie._context) + ".Provider";
          case vn:
            return hc(me, me.render, "ForwardRef");
          case Zn:
            var Ne = me.displayName || null;
            return Ne !== null ? Ne : Fo(me.type) || "Memo";
          case xn: {
            var De = me, Ze = De._payload, tt = De._init;
            try {
              return Fo(tt(Ze));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function al(me, we, Ie) {
      var Ne = we.displayName || we.name || "";
      return me.displayName || (Ne !== "" ? Ie + "(" + Ne + ")" : Ie);
    }
    function Sl(me) {
      return me.displayName || "Context";
    }
    function Gn(me) {
      var we = me.tag, Ie = me.type;
      switch (we) {
        case wt:
          return "Cache";
        case pt:
          var Ne = Ie;
          return Sl(Ne) + ".Consumer";
        case dt:
          var De = Ie;
          return Sl(De._context) + ".Provider";
        case er:
          return "DehydratedFragment";
        case yt:
          return al(Ie, Ie.render, "ForwardRef");
        case qe:
          return "Fragment";
        case ze:
          return Ie;
        case Be:
          return "Portal";
        case je:
          return "Root";
        case He:
          return "Text";
        case Zt:
          return Fo(Ie);
        case Ye:
          return Ie === To ? "StrictMode" : "Mode";
        case Qe:
          return "Offscreen";
        case Ct:
          return "Profiler";
        case Ot:
          return "Scope";
        case It:
          return "Suspense";
        case hr:
          return "SuspenseList";
        case bt:
          return "TracingMarker";
        case Me:
        case $e:
        case tr:
        case Re:
        case Vt:
        case Ut:
          if (typeof Ie == "function")
            return Ie.displayName || Ie.name || null;
          if (typeof Ie == "string")
            return Ie;
          break;
      }
      return null;
    }
    var Ws = fe.ReactDebugCurrentFrame, fa = null, Ka = !1;
    function Xa() {
      {
        if (fa === null)
          return null;
        var me = fa._debugOwner;
        if (me !== null && typeof me < "u")
          return Gn(me);
      }
      return null;
    }
    function Zs() {
      return fa === null ? "" : is(fa);
    }
    function wa() {
      Ws.getCurrentStack = null, fa = null, Ka = !1;
    }
    function Lo(me) {
      Ws.getCurrentStack = me === null ? null : Zs, fa = me, Ka = !1;
    }
    function Pl() {
      return fa;
    }
    function Ii(me) {
      Ka = me;
    }
    function ja(me) {
      return "" + me;
    }
    function Ss(me) {
      switch (typeof me) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return me;
        case "object":
          return Eo(me), me;
        default:
          return "";
      }
    }
    var il = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 };
    function vi(me, we) {
      il[we.type] || we.onChange || we.onInput || we.readOnly || we.disabled || we.value == null || xe("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), we.onChange || we.readOnly || we.disabled || we.checked == null || xe("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Tl(me) {
      var we = me.type, Ie = me.nodeName;
      return Ie && Ie.toLowerCase() === "input" && (we === "checkbox" || we === "radio");
    }
    function bi(me) {
      return me._valueTracker;
    }
    function Gs(me) {
      me._valueTracker = null;
    }
    function cu(me) {
      var we = "";
      return me && (Tl(me) ? we = me.checked ? "true" : "false" : we = me.value), we;
    }
    function gi(me) {
      var we = Tl(me) ? "checked" : "value", Ie = Object.getOwnPropertyDescriptor(me.constructor.prototype, we);
      Eo(me[we]);
      var Ne = "" + me[we];
      if (!(me.hasOwnProperty(we) || typeof Ie > "u" || typeof Ie.get != "function" || typeof Ie.set != "function")) {
        var De = Ie.get, Ze = Ie.set;
        Object.defineProperty(me, we, { configurable: !0, get: function() {
          return De.call(this);
        }, set: function(ht) {
          Eo(ht), Ne = "" + ht, Ze.call(this, ht);
        } }), Object.defineProperty(me, we, { enumerable: Ie.enumerable });
        var tt = { getValue: function() {
          return Ne;
        }, setValue: function(ht) {
          Eo(ht), Ne = "" + ht;
        }, stopTracking: function() {
          Gs(me), delete me[we];
        } };
        return tt;
      }
    }
    function Mi(me) {
      bi(me) || (me._valueTracker = gi(me));
    }
    function du(me) {
      if (!me)
        return !1;
      var we = bi(me);
      if (!we)
        return !0;
      var Ie = we.getValue(), Ne = cu(me);
      return Ne !== Ie ? (we.setValue(Ne), !0) : !1;
    }
    function Ps(me) {
      if (me = me || (typeof document < "u" ? document : void 0), typeof me > "u")
        return null;
      try {
        return me.activeElement || me.body;
      } catch {
        return me.body;
      }
    }
    var sl = !1, Wu = !1, ul = !1, kl = !1;
    function Ge(me) {
      var we = me.type === "checkbox" || me.type === "radio";
      return we ? me.checked != null : me.value != null;
    }
    function gt(me, we) {
      var Ie = me, Ne = we.checked, De = oo({}, we, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Ne ?? Ie._wrapperState.initialChecked });
      return De;
    }
    function jt(me, we) {
      vi("input", we), we.checked !== void 0 && we.defaultChecked !== void 0 && !Wu && (xe("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Xa() || "A component", we.type), Wu = !0), we.value !== void 0 && we.defaultValue !== void 0 && !sl && (xe("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Xa() || "A component", we.type), sl = !0);
      var Ie = me, Ne = we.defaultValue == null ? "" : we.defaultValue;
      Ie._wrapperState = { initialChecked: we.checked != null ? we.checked : we.defaultChecked, initialValue: Ss(we.value != null ? we.value : Ne), controlled: Ge(we) };
    }
    function Ht(me, we) {
      var Ie = me, Ne = we.checked;
      Ne != null && bo(Ie, "checked", Ne, !1);
    }
    function sr(me, we) {
      var Ie = me;
      {
        var Ne = Ge(we);
        !Ie._wrapperState.controlled && Ne && !kl && (xe("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), kl = !0), Ie._wrapperState.controlled && !Ne && !ul && (xe("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ul = !0);
      }
      Ht(me, we);
      var De = Ss(we.value), Ze = we.type;
      if (De != null)
        Ze === "number" ? (De === 0 && Ie.value === "" || Ie.value != De) && (Ie.value = ja(De)) : Ie.value !== ja(De) && (Ie.value = ja(De));
      else if (Ze === "submit" || Ze === "reset") {
        Ie.removeAttribute("value");
        return;
      }
      we.hasOwnProperty("value") ? Kr(Ie, we.type, De) : we.hasOwnProperty("defaultValue") && Kr(Ie, we.type, Ss(we.defaultValue)), we.checked == null && we.defaultChecked != null && (Ie.defaultChecked = !!we.defaultChecked);
    }
    function Fr(me, we, Ie) {
      var Ne = me;
      if (we.hasOwnProperty("value") || we.hasOwnProperty("defaultValue")) {
        var De = we.type, Ze = De === "submit" || De === "reset";
        if (Ze && (we.value === void 0 || we.value === null))
          return;
        var tt = ja(Ne._wrapperState.initialValue);
        Ie || tt !== Ne.value && (Ne.value = tt), Ne.defaultValue = tt;
      }
      var ht = Ne.name;
      ht !== "" && (Ne.name = ""), Ne.defaultChecked = !Ne.defaultChecked, Ne.defaultChecked = !!Ne._wrapperState.initialChecked, ht !== "" && (Ne.name = ht);
    }
    function Or(me, we) {
      var Ie = me;
      sr(Ie, we), Br(Ie, we);
    }
    function Br(me, we) {
      var Ie = we.name;
      if (we.type === "radio" && Ie != null) {
        for (var Ne = me; Ne.parentNode; )
          Ne = Ne.parentNode;
        pa(Ie, "name");
        for (var De = Ne.querySelectorAll("input[name=" + JSON.stringify("" + Ie) + '][type="radio"]'), Ze = 0; Ze < De.length; Ze++) {
          var tt = De[Ze];
          if (!(tt === me || tt.form !== me.form)) {
            var ht = E0(tt);
            if (!ht)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            du(tt), sr(tt, ht);
          }
        }
      }
    }
    function Kr(me, we, Ie) {
      (we !== "number" || Ps(me.ownerDocument) !== me) && (Ie == null ? me.defaultValue = ja(me._wrapperState.initialValue) : me.defaultValue !== ja(Ie) && (me.defaultValue = ja(Ie)));
    }
    var Sn = !1, In = !1, Un = !1;
    function Vn(me, we) {
      we.value == null && (typeof we.children == "object" && we.children !== null ? oe.Children.forEach(we.children, function(Ie) {
        Ie != null && (typeof Ie == "string" || typeof Ie == "number" || In || (In = !0, xe("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : we.dangerouslySetInnerHTML != null && (Un || (Un = !0, xe("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), we.selected != null && !Sn && (xe("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Sn = !0);
    }
    function mo(me, we) {
      we.value != null && me.setAttribute("value", ja(Ss(we.value)));
    }
    var ko = Array.isArray;
    function oa(me) {
      return ko(me);
    }
    var fu;
    fu = !1;
    function mc() {
      var me = Xa();
      return me ? `

Check the render method of \`` + me + "`." : "";
    }
    var uf = ["value", "defaultValue"];
    function ad(me) {
      {
        vi("select", me);
        for (var we = 0; we < uf.length; we++) {
          var Ie = uf[we];
          if (me[Ie] != null) {
            var Ne = oa(me[Ie]);
            me.multiple && !Ne ? xe("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", Ie, mc()) : !me.multiple && Ne && xe("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", Ie, mc());
          }
        }
      }
    }
    function pu(me, we, Ie, Ne) {
      var De = me.options;
      if (we) {
        for (var Ze = Ie, tt = {}, ht = 0; ht < Ze.length; ht++)
          tt["$" + Ze[ht]] = !0;
        for (var St = 0; St < De.length; St++) {
          var Nt = tt.hasOwnProperty("$" + De[St].value);
          De[St].selected !== Nt && (De[St].selected = Nt), Nt && Ne && (De[St].defaultSelected = !0);
        }
      } else {
        for (var Bt = ja(Ss(Ie)), lr = null, nr = 0; nr < De.length; nr++) {
          if (De[nr].value === Bt) {
            De[nr].selected = !0, Ne && (De[nr].defaultSelected = !0);
            return;
          }
          lr === null && !De[nr].disabled && (lr = De[nr]);
        }
        lr !== null && (lr.selected = !0);
      }
    }
    function Ol(me, we) {
      return oo({}, we, { value: void 0 });
    }
    function lf(me, we) {
      var Ie = me;
      ad(we), Ie._wrapperState = { wasMultiple: !!we.multiple }, we.value !== void 0 && we.defaultValue !== void 0 && !fu && (xe("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), fu = !0);
    }
    function n_(me, we) {
      var Ie = me;
      Ie.multiple = !!we.multiple;
      var Ne = we.value;
      Ne != null ? pu(Ie, !!we.multiple, Ne, !1) : we.defaultValue != null && pu(Ie, !!we.multiple, we.defaultValue, !0);
    }
    function o_(me, we) {
      var Ie = me, Ne = Ie._wrapperState.wasMultiple;
      Ie._wrapperState.wasMultiple = !!we.multiple;
      var De = we.value;
      De != null ? pu(Ie, !!we.multiple, De, !1) : Ne !== !!we.multiple && (we.defaultValue != null ? pu(Ie, !!we.multiple, we.defaultValue, !0) : pu(Ie, !!we.multiple, we.multiple ? [] : "", !1));
    }
    function a_(me, we) {
      var Ie = me, Ne = we.value;
      Ne != null && pu(Ie, !!we.multiple, Ne, !1);
    }
    var Yy = !1;
    function Qy(me, we) {
      var Ie = me;
      if (we.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var Ne = oo({}, we, { value: void 0, defaultValue: void 0, children: ja(Ie._wrapperState.initialValue) });
      return Ne;
    }
    function Gb(me, we) {
      var Ie = me;
      vi("textarea", we), we.value !== void 0 && we.defaultValue !== void 0 && !Yy && (xe("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Xa() || "A component"), Yy = !0);
      var Ne = we.value;
      if (Ne == null) {
        var De = we.children, Ze = we.defaultValue;
        if (De != null) {
          xe("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (Ze != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (oa(De)) {
              if (De.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              De = De[0];
            }
            Ze = De;
          }
        }
        Ze == null && (Ze = ""), Ne = Ze;
      }
      Ie._wrapperState = { initialValue: Ss(Ne) };
    }
    function Yb(me, we) {
      var Ie = me, Ne = Ss(we.value), De = Ss(we.defaultValue);
      if (Ne != null) {
        var Ze = ja(Ne);
        Ze !== Ie.value && (Ie.value = Ze), we.defaultValue == null && Ie.defaultValue !== Ze && (Ie.defaultValue = Ze);
      }
      De != null && (Ie.defaultValue = ja(De));
    }
    function Qb(me, we) {
      var Ie = me, Ne = Ie.textContent;
      Ne === Ie._wrapperState.initialValue && Ne !== "" && Ne !== null && (Ie.value = Ne);
    }
    function Ky(me, we) {
      Yb(me, we);
    }
    var Al = "http://www.w3.org/1999/xhtml", i_ = "http://www.w3.org/1998/Math/MathML", Xy = "http://www.w3.org/2000/svg";
    function im(me) {
      switch (me) {
        case "svg":
          return Xy;
        case "math":
          return i_;
        default:
          return Al;
      }
    }
    function Jy(me, we) {
      return me == null || me === Al ? im(we) : me === Xy && we === "foreignObject" ? Al : me;
    }
    var s_ = function(me) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(we, Ie, Ne, De) {
        MSApp.execUnsafeLocalFunction(function() {
          return me(we, Ie, Ne, De);
        });
      } : me;
    }, sm, Kb = s_(function(me, we) {
      if (me.namespaceURI === Xy && !("innerHTML" in me)) {
        sm = sm || document.createElement("div"), sm.innerHTML = "<svg>" + we.valueOf().toString() + "</svg>";
        for (var Ie = sm.firstChild; me.firstChild; )
          me.removeChild(me.firstChild);
        for (; Ie.firstChild; )
          me.appendChild(Ie.firstChild);
        return;
      }
      me.innerHTML = we;
    }), Ts = 1, Cl = 3, ei = 8, Zu = 9, id = 11, um = function(me, we) {
      if (we) {
        var Ie = me.firstChild;
        if (Ie && Ie === me.lastChild && Ie.nodeType === Cl) {
          Ie.nodeValue = we;
          return;
        }
      }
      me.textContent = we;
    }, Xb = { animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"], background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"], backgroundPosition: ["backgroundPositionX", "backgroundPositionY"], border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"], borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"], borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"], borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"], borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"], borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"], borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"], borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"], borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"], borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"], borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"], borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"], borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"], borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"], columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"], columns: ["columnCount", "columnWidth"], flex: ["flexBasis", "flexGrow", "flexShrink"], flexFlow: ["flexDirection", "flexWrap"], font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"], fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"], gap: ["columnGap", "rowGap"], grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"], gridColumn: ["gridColumnEnd", "gridColumnStart"], gridColumnGap: ["columnGap"], gridGap: ["columnGap", "rowGap"], gridRow: ["gridRowEnd", "gridRowStart"], gridRowGap: ["rowGap"], gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], listStyle: ["listStyleImage", "listStylePosition", "listStyleType"], margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"], marker: ["markerEnd", "markerMid", "markerStart"], mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"], maskPosition: ["maskPositionX", "maskPositionY"], outline: ["outlineColor", "outlineStyle", "outlineWidth"], overflow: ["overflowX", "overflowY"], padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"], placeContent: ["alignContent", "justifyContent"], placeItems: ["alignItems", "justifyItems"], placeSelf: ["alignSelf", "justifySelf"], textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"], textEmphasis: ["textEmphasisColor", "textEmphasisStyle"], transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"], wordWrap: ["overflowWrap"] }, cf = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 };
    function Jb(me, we) {
      return me + we.charAt(0).toUpperCase() + we.substring(1);
    }
    var eg = ["Webkit", "ms", "Moz", "O"];
    Object.keys(cf).forEach(function(me) {
      eg.forEach(function(we) {
        cf[Jb(we, me)] = cf[me];
      });
    });
    function lm(me, we, Ie) {
      var Ne = we == null || typeof we == "boolean" || we === "";
      return Ne ? "" : !Ie && typeof we == "number" && we !== 0 && !(cf.hasOwnProperty(me) && cf[me]) ? we + "px" : (Ko(we, me), ("" + we).trim());
    }
    var df = /([A-Z])/g, u_ = /^ms-/;
    function l_(me) {
      return me.replace(df, "-$1").toLowerCase().replace(u_, "-ms-");
    }
    var tg = function() {
    };
    {
      var rg = /^(?:webkit|moz|o)[A-Z]/, ng = /^-ms-/, mp = /-(.)/g, ff = /;\s*$/, pf = {}, hf = {}, og = !1, ev = !1, tv = function(me) {
        return me.replace(mp, function(we, Ie) {
          return Ie.toUpperCase();
        });
      }, cm = function(me) {
        pf.hasOwnProperty(me) && pf[me] || (pf[me] = !0, xe("Unsupported style property %s. Did you mean %s?", me, tv(me.replace(ng, "ms-"))));
      }, rv = function(me) {
        pf.hasOwnProperty(me) && pf[me] || (pf[me] = !0, xe("Unsupported vendor-prefixed style property %s. Did you mean %s?", me, me.charAt(0).toUpperCase() + me.slice(1)));
      }, ag = function(me, we) {
        hf.hasOwnProperty(we) && hf[we] || (hf[we] = !0, xe(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, me, we.replace(ff, "")));
      }, ig = function(me, we) {
        og || (og = !0, xe("`NaN` is an invalid value for the `%s` css style property.", me));
      }, c_ = function(me, we) {
        ev || (ev = !0, xe("`Infinity` is an invalid value for the `%s` css style property.", me));
      };
      tg = function(me, we) {
        me.indexOf("-") > -1 ? cm(me) : rg.test(me) ? rv(me) : ff.test(we) && ag(me, we), typeof we == "number" && (isNaN(we) ? ig(me, we) : isFinite(we) || c_(me, we));
      };
    }
    var d_ = tg;
    function f_(me) {
      {
        var we = "", Ie = "";
        for (var Ne in me)
          if (me.hasOwnProperty(Ne)) {
            var De = me[Ne];
            if (De != null) {
              var Ze = Ne.indexOf("--") === 0;
              we += Ie + (Ze ? Ne : l_(Ne)) + ":", we += lm(Ne, De, Ze), Ie = ";";
            }
          }
        return we || null;
      }
    }
    function sg(me, we) {
      var Ie = me.style;
      for (var Ne in we)
        if (we.hasOwnProperty(Ne)) {
          var De = Ne.indexOf("--") === 0;
          De || d_(Ne, we[Ne]);
          var Ze = lm(Ne, we[Ne], De);
          Ne === "float" && (Ne = "cssFloat"), De ? Ie.setProperty(Ne, Ze) : Ie[Ne] = Ze;
        }
    }
    function p_(me) {
      return me == null || typeof me == "boolean" || me === "";
    }
    function hu(me) {
      var we = {};
      for (var Ie in me)
        for (var Ne = Xb[Ie] || [Ie], De = 0; De < Ne.length; De++)
          we[Ne[De]] = Ie;
      return we;
    }
    function yp(me, we) {
      {
        if (!we)
          return;
        var Ie = hu(me), Ne = hu(we), De = {};
        for (var Ze in Ie) {
          var tt = Ie[Ze], ht = Ne[Ze];
          if (ht && tt !== ht) {
            var St = tt + "," + ht;
            if (De[St])
              continue;
            De[St] = !0, xe("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", p_(me[tt]) ? "Removing" : "Updating", tt, ht);
          }
        }
      }
    }
    var ug = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, lg = oo({ menuitem: !0 }, ug), cg = "__html";
    function dm(me, we) {
      if (we) {
        if (lg[me] && (we.children != null || we.dangerouslySetInnerHTML != null))
          throw new Error(me + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (we.dangerouslySetInnerHTML != null) {
          if (we.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof we.dangerouslySetInnerHTML != "object" || !(cg in we.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!we.suppressContentEditableWarning && we.contentEditable && we.children != null && xe("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), we.style != null && typeof we.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Ml(me, we) {
      if (me.indexOf("-") === -1)
        return typeof we.is == "string";
      switch (me) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var fm = { accept: "accept", acceptcharset: "acceptCharset", "accept-charset": "acceptCharset", accesskey: "accessKey", action: "action", allowfullscreen: "allowFullScreen", alt: "alt", as: "as", async: "async", autocapitalize: "autoCapitalize", autocomplete: "autoComplete", autocorrect: "autoCorrect", autofocus: "autoFocus", autoplay: "autoPlay", autosave: "autoSave", capture: "capture", cellpadding: "cellPadding", cellspacing: "cellSpacing", challenge: "challenge", charset: "charSet", checked: "checked", children: "children", cite: "cite", class: "className", classid: "classID", classname: "className", cols: "cols", colspan: "colSpan", content: "content", contenteditable: "contentEditable", contextmenu: "contextMenu", controls: "controls", controlslist: "controlsList", coords: "coords", crossorigin: "crossOrigin", dangerouslysetinnerhtml: "dangerouslySetInnerHTML", data: "data", datetime: "dateTime", default: "default", defaultchecked: "defaultChecked", defaultvalue: "defaultValue", defer: "defer", dir: "dir", disabled: "disabled", disablepictureinpicture: "disablePictureInPicture", disableremoteplayback: "disableRemotePlayback", download: "download", draggable: "draggable", enctype: "encType", enterkeyhint: "enterKeyHint", for: "htmlFor", form: "form", formmethod: "formMethod", formaction: "formAction", formenctype: "formEncType", formnovalidate: "formNoValidate", formtarget: "formTarget", frameborder: "frameBorder", headers: "headers", height: "height", hidden: "hidden", high: "high", href: "href", hreflang: "hrefLang", htmlfor: "htmlFor", httpequiv: "httpEquiv", "http-equiv": "httpEquiv", icon: "icon", id: "id", imagesizes: "imageSizes", imagesrcset: "imageSrcSet", innerhtml: "innerHTML", inputmode: "inputMode", integrity: "integrity", is: "is", itemid: "itemID", itemprop: "itemProp", itemref: "itemRef", itemscope: "itemScope", itemtype: "itemType", keyparams: "keyParams", keytype: "keyType", kind: "kind", label: "label", lang: "lang", list: "list", loop: "loop", low: "low", manifest: "manifest", marginwidth: "marginWidth", marginheight: "marginHeight", max: "max", maxlength: "maxLength", media: "media", mediagroup: "mediaGroup", method: "method", min: "min", minlength: "minLength", multiple: "multiple", muted: "muted", name: "name", nomodule: "noModule", nonce: "nonce", novalidate: "noValidate", open: "open", optimum: "optimum", pattern: "pattern", placeholder: "placeholder", playsinline: "playsInline", poster: "poster", preload: "preload", profile: "profile", radiogroup: "radioGroup", readonly: "readOnly", referrerpolicy: "referrerPolicy", rel: "rel", required: "required", reversed: "reversed", role: "role", rows: "rows", rowspan: "rowSpan", sandbox: "sandbox", scope: "scope", scoped: "scoped", scrolling: "scrolling", seamless: "seamless", selected: "selected", shape: "shape", size: "size", sizes: "sizes", span: "span", spellcheck: "spellCheck", src: "src", srcdoc: "srcDoc", srclang: "srcLang", srcset: "srcSet", start: "start", step: "step", style: "style", summary: "summary", tabindex: "tabIndex", target: "target", title: "title", type: "type", usemap: "useMap", value: "value", width: "width", wmode: "wmode", wrap: "wrap", about: "about", accentheight: "accentHeight", "accent-height": "accentHeight", accumulate: "accumulate", additive: "additive", alignmentbaseline: "alignmentBaseline", "alignment-baseline": "alignmentBaseline", allowreorder: "allowReorder", alphabetic: "alphabetic", amplitude: "amplitude", arabicform: "arabicForm", "arabic-form": "arabicForm", ascent: "ascent", attributename: "attributeName", attributetype: "attributeType", autoreverse: "autoReverse", azimuth: "azimuth", basefrequency: "baseFrequency", baselineshift: "baselineShift", "baseline-shift": "baselineShift", baseprofile: "baseProfile", bbox: "bbox", begin: "begin", bias: "bias", by: "by", calcmode: "calcMode", capheight: "capHeight", "cap-height": "capHeight", clip: "clip", clippath: "clipPath", "clip-path": "clipPath", clippathunits: "clipPathUnits", cliprule: "clipRule", "clip-rule": "clipRule", color: "color", colorinterpolation: "colorInterpolation", "color-interpolation": "colorInterpolation", colorinterpolationfilters: "colorInterpolationFilters", "color-interpolation-filters": "colorInterpolationFilters", colorprofile: "colorProfile", "color-profile": "colorProfile", colorrendering: "colorRendering", "color-rendering": "colorRendering", contentscripttype: "contentScriptType", contentstyletype: "contentStyleType", cursor: "cursor", cx: "cx", cy: "cy", d: "d", datatype: "datatype", decelerate: "decelerate", descent: "descent", diffuseconstant: "diffuseConstant", direction: "direction", display: "display", divisor: "divisor", dominantbaseline: "dominantBaseline", "dominant-baseline": "dominantBaseline", dur: "dur", dx: "dx", dy: "dy", edgemode: "edgeMode", elevation: "elevation", enablebackground: "enableBackground", "enable-background": "enableBackground", end: "end", exponent: "exponent", externalresourcesrequired: "externalResourcesRequired", fill: "fill", fillopacity: "fillOpacity", "fill-opacity": "fillOpacity", fillrule: "fillRule", "fill-rule": "fillRule", filter: "filter", filterres: "filterRes", filterunits: "filterUnits", floodopacity: "floodOpacity", "flood-opacity": "floodOpacity", floodcolor: "floodColor", "flood-color": "floodColor", focusable: "focusable", fontfamily: "fontFamily", "font-family": "fontFamily", fontsize: "fontSize", "font-size": "fontSize", fontsizeadjust: "fontSizeAdjust", "font-size-adjust": "fontSizeAdjust", fontstretch: "fontStretch", "font-stretch": "fontStretch", fontstyle: "fontStyle", "font-style": "fontStyle", fontvariant: "fontVariant", "font-variant": "fontVariant", fontweight: "fontWeight", "font-weight": "fontWeight", format: "format", from: "from", fx: "fx", fy: "fy", g1: "g1", g2: "g2", glyphname: "glyphName", "glyph-name": "glyphName", glyphorientationhorizontal: "glyphOrientationHorizontal", "glyph-orientation-horizontal": "glyphOrientationHorizontal", glyphorientationvertical: "glyphOrientationVertical", "glyph-orientation-vertical": "glyphOrientationVertical", glyphref: "glyphRef", gradienttransform: "gradientTransform", gradientunits: "gradientUnits", hanging: "hanging", horizadvx: "horizAdvX", "horiz-adv-x": "horizAdvX", horizoriginx: "horizOriginX", "horiz-origin-x": "horizOriginX", ideographic: "ideographic", imagerendering: "imageRendering", "image-rendering": "imageRendering", in2: "in2", in: "in", inlist: "inlist", intercept: "intercept", k1: "k1", k2: "k2", k3: "k3", k4: "k4", k: "k", kernelmatrix: "kernelMatrix", kernelunitlength: "kernelUnitLength", kerning: "kerning", keypoints: "keyPoints", keysplines: "keySplines", keytimes: "keyTimes", lengthadjust: "lengthAdjust", letterspacing: "letterSpacing", "letter-spacing": "letterSpacing", lightingcolor: "lightingColor", "lighting-color": "lightingColor", limitingconeangle: "limitingConeAngle", local: "local", markerend: "markerEnd", "marker-end": "markerEnd", markerheight: "markerHeight", markermid: "markerMid", "marker-mid": "markerMid", markerstart: "markerStart", "marker-start": "markerStart", markerunits: "markerUnits", markerwidth: "markerWidth", mask: "mask", maskcontentunits: "maskContentUnits", maskunits: "maskUnits", mathematical: "mathematical", mode: "mode", numoctaves: "numOctaves", offset: "offset", opacity: "opacity", operator: "operator", order: "order", orient: "orient", orientation: "orientation", origin: "origin", overflow: "overflow", overlineposition: "overlinePosition", "overline-position": "overlinePosition", overlinethickness: "overlineThickness", "overline-thickness": "overlineThickness", paintorder: "paintOrder", "paint-order": "paintOrder", panose1: "panose1", "panose-1": "panose1", pathlength: "pathLength", patterncontentunits: "patternContentUnits", patterntransform: "patternTransform", patternunits: "patternUnits", pointerevents: "pointerEvents", "pointer-events": "pointerEvents", points: "points", pointsatx: "pointsAtX", pointsaty: "pointsAtY", pointsatz: "pointsAtZ", prefix: "prefix", preservealpha: "preserveAlpha", preserveaspectratio: "preserveAspectRatio", primitiveunits: "primitiveUnits", property: "property", r: "r", radius: "radius", refx: "refX", refy: "refY", renderingintent: "renderingIntent", "rendering-intent": "renderingIntent", repeatcount: "repeatCount", repeatdur: "repeatDur", requiredextensions: "requiredExtensions", requiredfeatures: "requiredFeatures", resource: "resource", restart: "restart", result: "result", results: "results", rotate: "rotate", rx: "rx", ry: "ry", scale: "scale", security: "security", seed: "seed", shaperendering: "shapeRendering", "shape-rendering": "shapeRendering", slope: "slope", spacing: "spacing", specularconstant: "specularConstant", specularexponent: "specularExponent", speed: "speed", spreadmethod: "spreadMethod", startoffset: "startOffset", stddeviation: "stdDeviation", stemh: "stemh", stemv: "stemv", stitchtiles: "stitchTiles", stopcolor: "stopColor", "stop-color": "stopColor", stopopacity: "stopOpacity", "stop-opacity": "stopOpacity", strikethroughposition: "strikethroughPosition", "strikethrough-position": "strikethroughPosition", strikethroughthickness: "strikethroughThickness", "strikethrough-thickness": "strikethroughThickness", string: "string", stroke: "stroke", strokedasharray: "strokeDasharray", "stroke-dasharray": "strokeDasharray", strokedashoffset: "strokeDashoffset", "stroke-dashoffset": "strokeDashoffset", strokelinecap: "strokeLinecap", "stroke-linecap": "strokeLinecap", strokelinejoin: "strokeLinejoin", "stroke-linejoin": "strokeLinejoin", strokemiterlimit: "strokeMiterlimit", "stroke-miterlimit": "strokeMiterlimit", strokewidth: "strokeWidth", "stroke-width": "strokeWidth", strokeopacity: "strokeOpacity", "stroke-opacity": "strokeOpacity", suppresscontenteditablewarning: "suppressContentEditableWarning", suppresshydrationwarning: "suppressHydrationWarning", surfacescale: "surfaceScale", systemlanguage: "systemLanguage", tablevalues: "tableValues", targetx: "targetX", targety: "targetY", textanchor: "textAnchor", "text-anchor": "textAnchor", textdecoration: "textDecoration", "text-decoration": "textDecoration", textlength: "textLength", textrendering: "textRendering", "text-rendering": "textRendering", to: "to", transform: "transform", typeof: "typeof", u1: "u1", u2: "u2", underlineposition: "underlinePosition", "underline-position": "underlinePosition", underlinethickness: "underlineThickness", "underline-thickness": "underlineThickness", unicode: "unicode", unicodebidi: "unicodeBidi", "unicode-bidi": "unicodeBidi", unicoderange: "unicodeRange", "unicode-range": "unicodeRange", unitsperem: "unitsPerEm", "units-per-em": "unitsPerEm", unselectable: "unselectable", valphabetic: "vAlphabetic", "v-alphabetic": "vAlphabetic", values: "values", vectoreffect: "vectorEffect", "vector-effect": "vectorEffect", version: "version", vertadvy: "vertAdvY", "vert-adv-y": "vertAdvY", vertoriginx: "vertOriginX", "vert-origin-x": "vertOriginX", vertoriginy: "vertOriginY", "vert-origin-y": "vertOriginY", vhanging: "vHanging", "v-hanging": "vHanging", videographic: "vIdeographic", "v-ideographic": "vIdeographic", viewbox: "viewBox", viewtarget: "viewTarget", visibility: "visibility", vmathematical: "vMathematical", "v-mathematical": "vMathematical", vocab: "vocab", widths: "widths", wordspacing: "wordSpacing", "word-spacing": "wordSpacing", writingmode: "writingMode", "writing-mode": "writingMode", x1: "x1", x2: "x2", x: "x", xchannelselector: "xChannelSelector", xheight: "xHeight", "x-height": "xHeight", xlinkactuate: "xlinkActuate", "xlink:actuate": "xlinkActuate", xlinkarcrole: "xlinkArcrole", "xlink:arcrole": "xlinkArcrole", xlinkhref: "xlinkHref", "xlink:href": "xlinkHref", xlinkrole: "xlinkRole", "xlink:role": "xlinkRole", xlinkshow: "xlinkShow", "xlink:show": "xlinkShow", xlinktitle: "xlinkTitle", "xlink:title": "xlinkTitle", xlinktype: "xlinkType", "xlink:type": "xlinkType", xmlbase: "xmlBase", "xml:base": "xmlBase", xmllang: "xmlLang", "xml:lang": "xmlLang", xmlns: "xmlns", "xml:space": "xmlSpace", xmlnsxlink: "xmlnsXlink", "xmlns:xlink": "xmlnsXlink", xmlspace: "xmlSpace", y1: "y1", y2: "y2", y: "y", ychannelselector: "yChannelSelector", z: "z", zoomandpan: "zoomAndPan" }, dg = { "aria-current": 0, "aria-description": 0, "aria-details": 0, "aria-disabled": 0, "aria-hidden": 0, "aria-invalid": 0, "aria-keyshortcuts": 0, "aria-label": 0, "aria-roledescription": 0, "aria-autocomplete": 0, "aria-checked": 0, "aria-expanded": 0, "aria-haspopup": 0, "aria-level": 0, "aria-modal": 0, "aria-multiline": 0, "aria-multiselectable": 0, "aria-orientation": 0, "aria-placeholder": 0, "aria-pressed": 0, "aria-readonly": 0, "aria-required": 0, "aria-selected": 0, "aria-sort": 0, "aria-valuemax": 0, "aria-valuemin": 0, "aria-valuenow": 0, "aria-valuetext": 0, "aria-atomic": 0, "aria-busy": 0, "aria-live": 0, "aria-relevant": 0, "aria-dropeffect": 0, "aria-grabbed": 0, "aria-activedescendant": 0, "aria-colcount": 0, "aria-colindex": 0, "aria-colspan": 0, "aria-controls": 0, "aria-describedby": 0, "aria-errormessage": 0, "aria-flowto": 0, "aria-labelledby": 0, "aria-owns": 0, "aria-posinset": 0, "aria-rowcount": 0, "aria-rowindex": 0, "aria-rowspan": 0, "aria-setsize": 0 }, Gu = {}, nv = new RegExp("^(aria)-[" + Mr + "]*$"), bp = new RegExp("^(aria)[A-Z][" + Mr + "]*$");
    function ov(me, we) {
      {
        if (Yn.call(Gu, we) && Gu[we])
          return !0;
        if (bp.test(we)) {
          var Ie = "aria-" + we.slice(4).toLowerCase(), Ne = dg.hasOwnProperty(Ie) ? Ie : null;
          if (Ne == null)
            return xe("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", we), Gu[we] = !0, !0;
          if (we !== Ne)
            return xe("Invalid ARIA attribute `%s`. Did you mean `%s`?", we, Ne), Gu[we] = !0, !0;
        }
        if (nv.test(we)) {
          var De = we.toLowerCase(), Ze = dg.hasOwnProperty(De) ? De : null;
          if (Ze == null)
            return Gu[we] = !0, !1;
          if (we !== Ze)
            return xe("Unknown ARIA attribute `%s`. Did you mean `%s`?", we, Ze), Gu[we] = !0, !0;
        }
      }
      return !0;
    }
    function fg(me, we) {
      {
        var Ie = [];
        for (var Ne in we) {
          var De = ov(me, Ne);
          De || Ie.push(Ne);
        }
        var Ze = Ie.map(function(tt) {
          return "`" + tt + "`";
        }).join(", ");
        Ie.length === 1 ? xe("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ze, me) : Ie.length > 1 && xe("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ze, me);
      }
    }
    function pm(me, we) {
      Ml(me, we) || fg(me, we);
    }
    var ud = !1;
    function av(me, we) {
      {
        if (me !== "input" && me !== "textarea" && me !== "select")
          return;
        we != null && we.value === null && !ud && (ud = !0, me === "select" && we.multiple ? xe("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", me) : xe("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", me));
      }
    }
    var iv = function() {
    };
    {
      var wi = {}, sv = /^on./, pg = /^on[^A-Z]/, hg = new RegExp("^(aria)-[" + Mr + "]*$"), mg = new RegExp("^(aria)[A-Z][" + Mr + "]*$");
      iv = function(me, we, Ie, Ne) {
        if (Yn.call(wi, we) && wi[we])
          return !0;
        var De = we.toLowerCase();
        if (De === "onfocusin" || De === "onfocusout")
          return xe("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), wi[we] = !0, !0;
        if (Ne != null) {
          var Ze = Ne.registrationNameDependencies, tt = Ne.possibleRegistrationNames;
          if (Ze.hasOwnProperty(we))
            return !0;
          var ht = tt.hasOwnProperty(De) ? tt[De] : null;
          if (ht != null)
            return xe("Invalid event handler property `%s`. Did you mean `%s`?", we, ht), wi[we] = !0, !0;
          if (sv.test(we))
            return xe("Unknown event handler property `%s`. It will be ignored.", we), wi[we] = !0, !0;
        } else if (sv.test(we))
          return pg.test(we) && xe("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", we), wi[we] = !0, !0;
        if (hg.test(we) || mg.test(we))
          return !0;
        if (De === "innerhtml")
          return xe("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), wi[we] = !0, !0;
        if (De === "aria")
          return xe("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), wi[we] = !0, !0;
        if (De === "is" && Ie !== null && Ie !== void 0 && typeof Ie != "string")
          return xe("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof Ie), wi[we] = !0, !0;
        if (typeof Ie == "number" && isNaN(Ie))
          return xe("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", we), wi[we] = !0, !0;
        var St = Fn(we), Nt = St !== null && St.type === ra;
        if (fm.hasOwnProperty(De)) {
          var Bt = fm[De];
          if (Bt !== we)
            return xe("Invalid DOM property `%s`. Did you mean `%s`?", we, Bt), wi[we] = !0, !0;
        } else if (!Nt && we !== De)
          return xe("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", we, De), wi[we] = !0, !0;
        return typeof Ie == "boolean" && tn(we, Ie, St, !1) ? (Ie ? xe('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', Ie, we, we, Ie, we) : xe('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', Ie, we, we, Ie, we, we, we), wi[we] = !0, !0) : Nt ? !0 : tn(we, Ie, St, !1) ? (wi[we] = !0, !1) : ((Ie === "false" || Ie === "true") && St !== null && St.type === Jo && (xe("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", Ie, we, Ie === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', we, Ie), wi[we] = !0), !0);
      };
    }
    var yg = function(me, we, Ie) {
      {
        var Ne = [];
        for (var De in we) {
          var Ze = iv(me, De, we[De], Ie);
          Ze || Ne.push(De);
        }
        var tt = Ne.map(function(ht) {
          return "`" + ht + "`";
        }).join(", ");
        Ne.length === 1 ? xe("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", tt, me) : Ne.length > 1 && xe("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", tt, me);
      }
    };
    function vg(me, we, Ie) {
      Ml(me, we) || yg(me, we, Ie);
    }
    var Rl = 1, mf = 2, yf = 4, bg = Rl | mf | yf, yc = null;
    function gp(me) {
      yc !== null && xe("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), yc = me;
    }
    function m_() {
      yc === null && xe("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), yc = null;
    }
    function gg(me) {
      return me === yc;
    }
    function hm(me) {
      var we = me.target || me.srcElement || window;
      return we.correspondingUseElement && (we = we.correspondingUseElement), we.nodeType === Cl ? we.parentNode : we;
    }
    var ua = null, vc = null, Nl = null;
    function vf(me) {
      var we = zf(me);
      if (we) {
        if (typeof ua != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var Ie = we.stateNode;
        if (Ie) {
          var Ne = E0(Ie);
          ua(we.stateNode, we.type, Ne);
        }
      }
    }
    function wg(me) {
      ua = me;
    }
    function mm(me) {
      vc ? Nl ? Nl.push(me) : Nl = [me] : vc = me;
    }
    function wp() {
      return vc !== null || Nl !== null;
    }
    function _p() {
      if (vc) {
        var me = vc, we = Nl;
        if (vc = null, Nl = null, vf(me), we)
          for (var Ie = 0; Ie < we.length; Ie++)
            vf(we[Ie]);
      }
    }
    var ld = function(me, we) {
      return me(we);
    }, uv = function() {
    }, lv = !1;
    function y_() {
      var me = wp();
      me && (uv(), _p());
    }
    function cv(me, we, Ie) {
      if (lv)
        return me(we, Ie);
      lv = !0;
      try {
        return ld(me, we, Ie);
      } finally {
        lv = !1, y_();
      }
    }
    function ym(me, we, Ie) {
      ld = me, uv = Ie;
    }
    function vm(me) {
      return me === "button" || me === "input" || me === "select" || me === "textarea";
    }
    function dv(me, we, Ie) {
      switch (me) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(Ie.disabled && vm(we));
        default:
          return !1;
      }
    }
    function bd(me, we) {
      var Ie = me.stateNode;
      if (Ie === null)
        return null;
      var Ne = E0(Ie);
      if (Ne === null)
        return null;
      var De = Ne[we];
      if (dv(we, me.type, Ne))
        return null;
      if (De && typeof De != "function")
        throw new Error("Expected `" + we + "` listener to be a function, instead got a value of `" + typeof De + "` type.");
      return De;
    }
    var xp = !1;
    if (kn)
      try {
        var wd = {};
        Object.defineProperty(wd, "passive", { get: function() {
          xp = !0;
        } }), window.addEventListener("test", wd, wd), window.removeEventListener("test", wd, wd);
      } catch {
        xp = !1;
      }
    function _g(me, we, Ie, Ne, De, Ze, tt, ht, St) {
      var Nt = Array.prototype.slice.call(arguments, 3);
      try {
        we.apply(Ie, Nt);
      } catch (Bt) {
        this.onError(Bt);
      }
    }
    var fv = _g;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var pv = document.createElement("react");
      fv = function(me, we, Ie, Ne, De, Ze, tt, ht, St) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Nt = document.createEvent("Event"), Bt = !1, lr = !0, nr = window.event, _r = Object.getOwnPropertyDescriptor(window, "event");
        function Er() {
          pv.removeEventListener(br, rn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = nr);
        }
        var Cr = Array.prototype.slice.call(arguments, 3);
        function rn() {
          Bt = !0, Er(), we.apply(Ie, Cr), lr = !1;
        }
        var Cn, Bn = !1, Ro = !1;
        function Co(Ar) {
          if (Cn = Ar.error, Bn = !0, Cn === null && Ar.colno === 0 && Ar.lineno === 0 && (Ro = !0), Ar.defaultPrevented && Cn != null && typeof Cn == "object")
            try {
              Cn._suppressLogging = !0;
            } catch {
            }
        }
        var br = "react-" + (me || "invokeguardedcallback");
        if (window.addEventListener("error", Co), pv.addEventListener(br, rn, !1), Nt.initEvent(br, !1, !1), pv.dispatchEvent(Nt), _r && Object.defineProperty(window, "event", _r), Bt && lr && (Bn ? Ro && (Cn = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Cn = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Cn)), window.removeEventListener("error", Co), !Bt)
          return Er(), _g.apply(this, arguments);
      };
    }
    var v_ = fv, bc = !1, Yu = null, Ep = !1, gc = null, ll = { onError: function(me) {
      bc = !0, Yu = me;
    } };
    function _d(me, we, Ie, Ne, De, Ze, tt, ht, St) {
      bc = !1, Yu = null, v_.apply(ll, arguments);
    }
    function Dl(me, we, Ie, Ne, De, Ze, tt, ht, St) {
      if (_d.apply(this, arguments), bc) {
        var Nt = mv();
        Ep || (Ep = !0, gc = Nt);
      }
    }
    function hv() {
      if (Ep) {
        var me = gc;
        throw Ep = !1, gc = null, me;
      }
    }
    function b_() {
      return bc;
    }
    function mv() {
      if (bc) {
        var me = Yu;
        return bc = !1, Yu = null, me;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function mu(me) {
      return me._reactInternals;
    }
    function Sp(me) {
      return me._reactInternals !== void 0;
    }
    function bf(me, we) {
      me._reactInternals = we;
    }
    var Nn = 0, wc = 1, xa = 2, go = 4, Xo = 16, ea = 32, cl = 64, Jn = 128, Fa = 256, ks = 512, yu = 1024, Oa = 2048, vu = 4096, Pc = 8192, Pp = 16384, bm = Oa | go | cl | ks | yu | Pp, xg = 32767, Ys = 32768, xi = 65536, Tp = 131072, yv = 1048576, vv = 2097152, Os = 4194304, kc = 8388608, As = 16777216, xd = 33554432, gf = go | yu | 0, Cs = xa | go | Xo | ea | ks | vu | Pc, rs = go | cl | ks | Pc, bu = Oa | Xo, Ri = Os | kc | vv, Bl = fe.ReactCurrentOwner;
    function Qs(me) {
      var we = me, Ie = me;
      if (me.alternate)
        for (; we.return; )
          we = we.return;
      else {
        var Ne = we;
        do
          we = Ne, (we.flags & (xa | vu)) !== Nn && (Ie = we.return), Ne = we.return;
        while (Ne);
      }
      return we.tag === je ? Ie : null;
    }
    function bv(me) {
      if (me.tag === It) {
        var we = me.memoizedState;
        if (we === null) {
          var Ie = me.alternate;
          Ie !== null && (we = Ie.memoizedState);
        }
        if (we !== null)
          return we.dehydrated;
      }
      return null;
    }
    function gm(me) {
      return me.tag === je ? me.stateNode.containerInfo : null;
    }
    function gv(me) {
      return Qs(me) === me;
    }
    function Ks(me) {
      {
        var we = Bl.current;
        if (we !== null && we.tag === Me) {
          var Ie = we, Ne = Ie.stateNode;
          Ne._warnedAboutRefsInRender || xe("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Gn(Ie) || "A component"), Ne._warnedAboutRefsInRender = !0;
        }
      }
      var De = mu(me);
      return De ? Qs(De) === De : !1;
    }
    function $s(me) {
      if (Qs(me) !== me)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ea(me) {
      var we = me.alternate;
      if (!we) {
        var Ie = Qs(me);
        if (Ie === null)
          throw new Error("Unable to find node on an unmounted component.");
        return Ie !== me ? null : me;
      }
      for (var Ne = me, De = we; ; ) {
        var Ze = Ne.return;
        if (Ze === null)
          break;
        var tt = Ze.alternate;
        if (tt === null) {
          var ht = Ze.return;
          if (ht !== null) {
            Ne = De = ht;
            continue;
          }
          break;
        }
        if (Ze.child === tt.child) {
          for (var St = Ze.child; St; ) {
            if (St === Ne)
              return $s(Ze), me;
            if (St === De)
              return $s(Ze), we;
            St = St.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (Ne.return !== De.return)
          Ne = Ze, De = tt;
        else {
          for (var Nt = !1, Bt = Ze.child; Bt; ) {
            if (Bt === Ne) {
              Nt = !0, Ne = Ze, De = tt;
              break;
            }
            if (Bt === De) {
              Nt = !0, De = Ze, Ne = tt;
              break;
            }
            Bt = Bt.sibling;
          }
          if (!Nt) {
            for (Bt = tt.child; Bt; ) {
              if (Bt === Ne) {
                Nt = !0, Ne = tt, De = Ze;
                break;
              }
              if (Bt === De) {
                Nt = !0, De = tt, Ne = Ze;
                break;
              }
              Bt = Bt.sibling;
            }
            if (!Nt)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (Ne.alternate !== De)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (Ne.tag !== je)
        throw new Error("Unable to find node on an unmounted component.");
      return Ne.stateNode.current === Ne ? me : we;
    }
    function gu(me) {
      var we = Ea(me);
      return we !== null ? wv(we) : null;
    }
    function wv(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var we = me.child; we !== null; ) {
        var Ie = wv(we);
        if (Ie !== null)
          return Ie;
        we = we.sibling;
      }
      return null;
    }
    function Eg(me) {
      var we = Ea(me);
      return we !== null ? wm(we) : null;
    }
    function wm(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var we = me.child; we !== null; ) {
        if (we.tag !== Be) {
          var Ie = wm(we);
          if (Ie !== null)
            return Ie;
        }
        we = we.sibling;
      }
      return null;
    }
    var _m = ae.unstable_scheduleCallback, Sg = ae.unstable_cancelCallback, xm = ae.unstable_shouldYield, Pg = ae.unstable_requestPaint, Ia = ae.unstable_now, _v = ae.unstable_getCurrentPriorityLevel, Em = ae.unstable_ImmediatePriority, Xs = ae.unstable_UserBlockingPriority, dl = ae.unstable_NormalPriority, Sm = ae.unstable_LowPriority, Ac = ae.unstable_IdlePriority, xv = ae.unstable_yieldValue, Ev = ae.unstable_setDisableYieldValue, $c = null, Ei = null, Xr = null, za = !1, Ni = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Sv(me) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var we = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (we.isDisabled)
        return !0;
      if (!we.supportsFiber)
        return xe("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        dr && (me = oo({}, me, { getLaneLabelMap: Mc, injectProfilingHooks: Hl })), $c = we.inject(me), Ei = we;
      } catch (Ie) {
        xe("React instrumentation encountered an error: %s.", Ie);
      }
      return !!we.checkDCE;
    }
    function Tg(me, we) {
      if (Ei && typeof Ei.onScheduleFiberRoot == "function")
        try {
          Ei.onScheduleFiberRoot($c, me, we);
        } catch (Ie) {
          za || (za = !0, xe("React instrumentation encountered an error: %s", Ie));
        }
    }
    function Vl(me, we) {
      if (Ei && typeof Ei.onCommitFiberRoot == "function")
        try {
          var Ie = (me.current.flags & Jn) === Jn;
          if (Nr) {
            var Ne;
            switch (we) {
              case Ns:
                Ne = Em;
                break;
              case Pu:
                Ne = Xs;
                break;
              case ji:
                Ne = dl;
                break;
              case ry:
                Ne = Ac;
                break;
              default:
                Ne = dl;
                break;
            }
            Ei.onCommitFiberRoot($c, me, Ne, Ie);
          }
        } catch (De) {
          za || (za = !0, xe("React instrumentation encountered an error: %s", De));
        }
    }
    function Ic(me) {
      if (Ei && typeof Ei.onPostCommitFiberRoot == "function")
        try {
          Ei.onPostCommitFiberRoot($c, me);
        } catch (we) {
          za || (za = !0, xe("React instrumentation encountered an error: %s", we));
        }
    }
    function Pv(me) {
      if (Ei && typeof Ei.onCommitFiberUnmount == "function")
        try {
          Ei.onCommitFiberUnmount($c, me);
        } catch (we) {
          za || (za = !0, xe("React instrumentation encountered an error: %s", we));
        }
    }
    function ci(me) {
      if (typeof xv == "function" && (Ev(me), ve(me)), Ei && typeof Ei.setStrictMode == "function")
        try {
          Ei.setStrictMode($c, me);
        } catch (we) {
          za || (za = !0, xe("React instrumentation encountered an error: %s", we));
        }
    }
    function Hl(me) {
      Xr = me;
    }
    function Mc() {
      {
        for (var me = /* @__PURE__ */ new Map(), we = 1, Ie = 0; Ie < Sa; Ie++) {
          var Ne = g_(we);
          me.set(we, Ne), we *= 2;
        }
        return me;
      }
    }
    function Pm(me) {
      Xr !== null && typeof Xr.markCommitStarted == "function" && Xr.markCommitStarted(me);
    }
    function Tv() {
      Xr !== null && typeof Xr.markCommitStopped == "function" && Xr.markCommitStopped();
    }
    function Nc(me) {
      Xr !== null && typeof Xr.markComponentRenderStarted == "function" && Xr.markComponentRenderStarted(me);
    }
    function Ed() {
      Xr !== null && typeof Xr.markComponentRenderStopped == "function" && Xr.markComponentRenderStopped();
    }
    function kg(me) {
      Xr !== null && typeof Xr.markComponentPassiveEffectMountStarted == "function" && Xr.markComponentPassiveEffectMountStarted(me);
    }
    function kv() {
      Xr !== null && typeof Xr.markComponentPassiveEffectMountStopped == "function" && Xr.markComponentPassiveEffectMountStopped();
    }
    function Tm(me) {
      Xr !== null && typeof Xr.markComponentPassiveEffectUnmountStarted == "function" && Xr.markComponentPassiveEffectUnmountStarted(me);
    }
    function Og() {
      Xr !== null && typeof Xr.markComponentPassiveEffectUnmountStopped == "function" && Xr.markComponentPassiveEffectUnmountStopped();
    }
    function Ag(me) {
      Xr !== null && typeof Xr.markComponentLayoutEffectMountStarted == "function" && Xr.markComponentLayoutEffectMountStarted(me);
    }
    function Cg() {
      Xr !== null && typeof Xr.markComponentLayoutEffectMountStopped == "function" && Xr.markComponentLayoutEffectMountStopped();
    }
    function km(me) {
      Xr !== null && typeof Xr.markComponentLayoutEffectUnmountStarted == "function" && Xr.markComponentLayoutEffectUnmountStarted(me);
    }
    function wf() {
      Xr !== null && typeof Xr.markComponentLayoutEffectUnmountStopped == "function" && Xr.markComponentLayoutEffectUnmountStopped();
    }
    function Om(me, we, Ie) {
      Xr !== null && typeof Xr.markComponentErrored == "function" && Xr.markComponentErrored(me, we, Ie);
    }
    function $g(me, we, Ie) {
      Xr !== null && typeof Xr.markComponentSuspended == "function" && Xr.markComponentSuspended(me, we, Ie);
    }
    function Ig(me) {
      Xr !== null && typeof Xr.markLayoutEffectsStarted == "function" && Xr.markLayoutEffectsStarted(me);
    }
    function _f() {
      Xr !== null && typeof Xr.markLayoutEffectsStopped == "function" && Xr.markLayoutEffectsStopped();
    }
    function Mg(me) {
      Xr !== null && typeof Xr.markPassiveEffectsStarted == "function" && Xr.markPassiveEffectsStarted(me);
    }
    function kp() {
      Xr !== null && typeof Xr.markPassiveEffectsStopped == "function" && Xr.markPassiveEffectsStopped();
    }
    function Qu(me) {
      Xr !== null && typeof Xr.markRenderStarted == "function" && Xr.markRenderStarted(me);
    }
    function Ap() {
      Xr !== null && typeof Xr.markRenderYielded == "function" && Xr.markRenderYielded();
    }
    function xf() {
      Xr !== null && typeof Xr.markRenderStopped == "function" && Xr.markRenderStopped();
    }
    function Pd(me) {
      Xr !== null && typeof Xr.markRenderScheduled == "function" && Xr.markRenderScheduled(me);
    }
    function Ov(me, we) {
      Xr !== null && typeof Xr.markForceUpdateScheduled == "function" && Xr.markForceUpdateScheduled(me, we);
    }
    function jc(me, we) {
      Xr !== null && typeof Xr.markStateUpdateScheduled == "function" && Xr.markStateUpdateScheduled(me, we);
    }
    var Ln = 0, $o = 1, qn = 2, Ma = 8, _u = 16, Am = Math.clz32 ? Math.clz32 : Td, Cm = Math.log, Av = Math.LN2;
    function Td(me) {
      var we = me >>> 0;
      return we === 0 ? 32 : 31 - (Cm(we) / Av | 0) | 0;
    }
    var Sa = 31, Ir = 0, Uo = 0, Wn = 1, fl = 2, Js = 4, Od = 8, Pa = 16, Ad = 32, Fc = 4194240, Cd = 64, Su = 128, Is = 256, $d = 512, Cp = 1024, $p = 2048, $m = 4096, Im = 8192, Mm = 16384, Rm = 32768, Nm = 65536, jm = 131072, Fm = 262144, Lm = 524288, Id = 1048576, Dm = 2097152, Md = 130023424, Zl = 4194304, Bm = 8388608, Ip = 16777216, zm = 33554432, Um = 67108864, Cv = Zl, Ef = 134217728, Vm = 268435455, Sf = 268435456, Lc = 536870912, Ms = 1073741824;
    function g_(me) {
      {
        if (me & Wn)
          return "Sync";
        if (me & fl)
          return "InputContinuousHydration";
        if (me & Js)
          return "InputContinuous";
        if (me & Od)
          return "DefaultHydration";
        if (me & Pa)
          return "Default";
        if (me & Ad)
          return "TransitionHydration";
        if (me & Fc)
          return "Transition";
        if (me & Md)
          return "Retry";
        if (me & Ef)
          return "SelectiveHydration";
        if (me & Sf)
          return "IdleHydration";
        if (me & Lc)
          return "Idle";
        if (me & Ms)
          return "Offscreen";
      }
    }
    var la = -1, Hm = Cd, qm = Zl;
    function Pf(me) {
      switch (ti(me)) {
        case Wn:
          return Wn;
        case fl:
          return fl;
        case Js:
          return Js;
        case Od:
          return Od;
        case Pa:
          return Pa;
        case Ad:
          return Ad;
        case Cd:
        case Su:
        case Is:
        case $d:
        case Cp:
        case $p:
        case $m:
        case Im:
        case Mm:
        case Rm:
        case Nm:
        case jm:
        case Fm:
        case Lm:
        case Id:
        case Dm:
          return me & Fc;
        case Zl:
        case Bm:
        case Ip:
        case zm:
        case Um:
          return me & Md;
        case Ef:
          return Ef;
        case Sf:
          return Sf;
        case Lc:
          return Lc;
        case Ms:
          return Ms;
        default:
          return xe("Should have found matching lanes. This is a bug in React."), me;
      }
    }
    function Mp(me, we) {
      var Ie = me.pendingLanes;
      if (Ie === Ir)
        return Ir;
      var Ne = Ir, De = me.suspendedLanes, Ze = me.pingedLanes, tt = Ie & Vm;
      if (tt !== Ir) {
        var ht = tt & ~De;
        if (ht !== Ir)
          Ne = Pf(ht);
        else {
          var St = tt & Ze;
          St !== Ir && (Ne = Pf(St));
        }
      } else {
        var Nt = Ie & ~De;
        Nt !== Ir ? Ne = Pf(Nt) : Ze !== Ir && (Ne = Pf(Ze));
      }
      if (Ne === Ir)
        return Ir;
      if (we !== Ir && we !== Ne && (we & De) === Ir) {
        var Bt = ti(Ne), lr = ti(we);
        if (Bt >= lr || Bt === Pa && (lr & Fc) !== Ir)
          return we;
      }
      (Ne & Js) !== Ir && (Ne |= Ie & Pa);
      var nr = me.entangledLanes;
      if (nr !== Ir)
        for (var _r = me.entanglements, Er = Ne & nr; Er > 0; ) {
          var Cr = Dc(Er), rn = 1 << Cr;
          Ne |= _r[Cr], Er &= ~rn;
        }
      return Ne;
    }
    function Rg(me, we) {
      for (var Ie = me.eventTimes, Ne = la; we > 0; ) {
        var De = Dc(we), Ze = 1 << De, tt = Ie[De];
        tt > Ne && (Ne = tt), we &= ~Ze;
      }
      return Ne;
    }
    function Wm(me, we) {
      switch (me) {
        case Wn:
        case fl:
        case Js:
          return we + 250;
        case Od:
        case Pa:
        case Ad:
        case Cd:
        case Su:
        case Is:
        case $d:
        case Cp:
        case $p:
        case $m:
        case Im:
        case Mm:
        case Rm:
        case Nm:
        case jm:
        case Fm:
        case Lm:
        case Id:
        case Dm:
          return we + 5e3;
        case Zl:
        case Bm:
        case Ip:
        case zm:
        case Um:
          return la;
        case Ef:
        case Sf:
        case Lc:
        case Ms:
          return la;
        default:
          return xe("Should have found matching lanes. This is a bug in React."), la;
      }
    }
    function w_(me, we) {
      for (var Ie = me.pendingLanes, Ne = me.suspendedLanes, De = me.pingedLanes, Ze = me.expirationTimes, tt = Ie; tt > 0; ) {
        var ht = Dc(tt), St = 1 << ht, Nt = Ze[ht];
        Nt === la ? ((St & Ne) === Ir || (St & De) !== Ir) && (Ze[ht] = Wm(St, we)) : Nt <= we && (me.expiredLanes |= St), tt &= ~St;
      }
    }
    function __(me) {
      return Pf(me.pendingLanes);
    }
    function $v(me) {
      var we = me.pendingLanes & ~Ms;
      return we !== Ir ? we : we & Ms ? Ms : Ir;
    }
    function Tf(me) {
      return (me & Wn) !== Ir;
    }
    function Rp(me) {
      return (me & Vm) !== Ir;
    }
    function Gm(me) {
      return (me & Md) === me;
    }
    function x_(me) {
      var we = Wn | Js | Pa;
      return (me & we) === Ir;
    }
    function Ng(me) {
      return (me & Fc) === me;
    }
    function Np(me, we) {
      var Ie = fl | Js | Od | Pa;
      return (we & Ie) !== Ir;
    }
    function jg(me, we) {
      return (we & me.expiredLanes) !== Ir;
    }
    function Iv(me) {
      return (me & Fc) !== Ir;
    }
    function Mv() {
      var me = Hm;
      return Hm <<= 1, (Hm & Fc) === Ir && (Hm = Cd), me;
    }
    function E_() {
      var me = qm;
      return qm <<= 1, (qm & Md) === Ir && (qm = Zl), me;
    }
    function ti(me) {
      return me & -me;
    }
    function di(me) {
      return ti(me);
    }
    function Dc(me) {
      return 31 - Am(me);
    }
    function Ym(me) {
      return Dc(me);
    }
    function Rs(me, we) {
      return (me & we) !== Ir;
    }
    function Rd(me, we) {
      return (me & we) === we;
    }
    function wo(me, we) {
      return me | we;
    }
    function kf(me, we) {
      return me & ~we;
    }
    function Rv(me, we) {
      return me & we;
    }
    function Nv(me, we) {
      return me !== Uo && me < we ? me : we;
    }
    function Qm(me) {
      for (var we = [], Ie = 0; Ie < Sa; Ie++)
        we.push(me);
      return we;
    }
    function Of(me, we, Ie) {
      me.pendingLanes |= we, we !== Lc && (me.suspendedLanes = Ir, me.pingedLanes = Ir);
      var Ne = me.eventTimes, De = Ym(we);
      Ne[De] = Ie;
    }
    function jv(me, we) {
      me.suspendedLanes |= we, me.pingedLanes &= ~we;
      for (var Ie = me.expirationTimes, Ne = we; Ne > 0; ) {
        var De = Dc(Ne), Ze = 1 << De;
        Ie[De] = la, Ne &= ~Ze;
      }
    }
    function Km(me, we, Ie) {
      me.pingedLanes |= me.suspendedLanes & we;
    }
    function Fg(me, we) {
      var Ie = me.pendingLanes & ~we;
      me.pendingLanes = we, me.suspendedLanes = Ir, me.pingedLanes = Ir, me.expiredLanes &= we, me.mutableReadLanes &= we, me.entangledLanes &= we;
      for (var Ne = me.entanglements, De = me.eventTimes, Ze = me.expirationTimes, tt = Ie; tt > 0; ) {
        var ht = Dc(tt), St = 1 << ht;
        Ne[ht] = Ir, De[ht] = la, Ze[ht] = la, tt &= ~St;
      }
    }
    function jp(me, we) {
      for (var Ie = me.entangledLanes |= we, Ne = me.entanglements, De = Ie; De; ) {
        var Ze = Dc(De), tt = 1 << Ze;
        tt & we | Ne[Ze] & we && (Ne[Ze] |= we), De &= ~tt;
      }
    }
    function ey(me, we) {
      var Ie = ti(we), Ne;
      switch (Ie) {
        case Js:
          Ne = fl;
          break;
        case Pa:
          Ne = Od;
          break;
        case Cd:
        case Su:
        case Is:
        case $d:
        case Cp:
        case $p:
        case $m:
        case Im:
        case Mm:
        case Rm:
        case Nm:
        case jm:
        case Fm:
        case Lm:
        case Id:
        case Dm:
        case Zl:
        case Bm:
        case Ip:
        case zm:
        case Um:
          Ne = Ad;
          break;
        case Lc:
          Ne = Sf;
          break;
        default:
          Ne = Uo;
          break;
      }
      return (Ne & (me.suspendedLanes | we)) !== Uo ? Uo : Ne;
    }
    function Lg(me, we, Ie) {
      if (Ni)
        for (var Ne = me.pendingUpdatersLaneMap; Ie > 0; ) {
          var De = Ym(Ie), Ze = 1 << De, tt = Ne[De];
          tt.add(we), Ie &= ~Ze;
        }
    }
    function Fv(me, we) {
      if (Ni)
        for (var Ie = me.pendingUpdatersLaneMap, Ne = me.memoizedUpdaters; we > 0; ) {
          var De = Ym(we), Ze = 1 << De, tt = Ie[De];
          tt.size > 0 && (tt.forEach(function(ht) {
            var St = ht.alternate;
            (St === null || !Ne.has(St)) && Ne.add(ht);
          }), tt.clear()), we &= ~Ze;
        }
    }
    function ty(me, we) {
      return null;
    }
    var Ns = Wn, Pu = Js, ji = Pa, ry = Lc, Af = Uo;
    function eu() {
      return Af;
    }
    function fi(me) {
      Af = me;
    }
    function Dg(me, we) {
      var Ie = Af;
      try {
        return Af = me, we();
      } finally {
        Af = Ie;
      }
    }
    function Lp(me, we) {
      return me !== 0 && me < we ? me : we;
    }
    function ns(me, we) {
      return me === 0 || me > we ? me : we;
    }
    function Lv(me, we) {
      return me !== 0 && me < we;
    }
    function Bg(me) {
      var we = ti(me);
      return Lv(Ns, we) ? Lv(Pu, we) ? Rp(we) ? ji : ry : Pu : Ns;
    }
    function Nd(me) {
      var we = me.current.memoizedState;
      return we.isDehydrated;
    }
    var Fi;
    function S_(me) {
      Fi = me;
    }
    function yn(me) {
      Fi(me);
    }
    var Bc;
    function zg(me) {
      Bc = me;
    }
    var Dv;
    function P_(me) {
      Dv = me;
    }
    var Cf;
    function ny(me) {
      Cf = me;
    }
    var oy;
    function Ug(me) {
      oy = me;
    }
    var ay = !1, Dp = [], pl = null, hl = null, Aa = null, ss = /* @__PURE__ */ new Map(), $u = /* @__PURE__ */ new Map(), Yl = [], Vg = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset", "submit"];
    function Ku(me) {
      return Vg.indexOf(me) > -1;
    }
    function Hg(me, we, Ie, Ne, De) {
      return { blockedOn: me, domEventName: we, eventSystemFlags: Ie, nativeEvent: De, targetContainers: [Ne] };
    }
    function Xu(me, we) {
      switch (me) {
        case "focusin":
        case "focusout":
          pl = null;
          break;
        case "dragenter":
        case "dragleave":
          hl = null;
          break;
        case "mouseover":
        case "mouseout":
          Aa = null;
          break;
        case "pointerover":
        case "pointerout": {
          var Ie = we.pointerId;
          ss.delete(Ie);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var Ne = we.pointerId;
          $u.delete(Ne);
          break;
        }
      }
    }
    function Bp(me, we, Ie, Ne, De, Ze) {
      if (me === null || me.nativeEvent !== Ze) {
        var tt = Hg(we, Ie, Ne, De, Ze);
        if (we !== null) {
          var ht = zf(we);
          ht !== null && Bc(ht);
        }
        return tt;
      }
      me.eventSystemFlags |= Ne;
      var St = me.targetContainers;
      return De !== null && St.indexOf(De) === -1 && St.push(De), me;
    }
    function qg(me, we, Ie, Ne, De) {
      switch (we) {
        case "focusin": {
          var Ze = De;
          return pl = Bp(pl, me, we, Ie, Ne, Ze), !0;
        }
        case "dragenter": {
          var tt = De;
          return hl = Bp(hl, me, we, Ie, Ne, tt), !0;
        }
        case "mouseover": {
          var ht = De;
          return Aa = Bp(Aa, me, we, Ie, Ne, ht), !0;
        }
        case "pointerover": {
          var St = De, Nt = St.pointerId;
          return ss.set(Nt, Bp(ss.get(Nt) || null, me, we, Ie, Ne, St)), !0;
        }
        case "gotpointercapture": {
          var Bt = De, lr = Bt.pointerId;
          return $u.set(lr, Bp($u.get(lr) || null, me, we, Ie, Ne, Bt)), !0;
        }
      }
      return !1;
    }
    function Bv(me) {
      var we = Jp(me.target);
      if (we !== null) {
        var Ie = Qs(we);
        if (Ie !== null) {
          var Ne = Ie.tag;
          if (Ne === It) {
            var De = bv(Ie);
            if (De !== null) {
              me.blockedOn = De, oy(me.priority, function() {
                Dv(Ie);
              });
              return;
            }
          } else if (Ne === je) {
            var Ze = Ie.stateNode;
            if (Nd(Ze)) {
              me.blockedOn = gm(Ie);
              return;
            }
          }
        }
      }
      me.blockedOn = null;
    }
    function Wg(me) {
      for (var we = Cf(), Ie = { blockedOn: null, target: me, priority: we }, Ne = 0; Ne < Yl.length && Lv(we, Yl[Ne].priority); Ne++)
        ;
      Yl.splice(Ne, 0, Ie), Ne === 0 && Bv(Ie);
    }
    function zp(me) {
      if (me.blockedOn !== null)
        return !1;
      for (var we = me.targetContainers; we.length > 0; ) {
        var Ie = we[0], Ne = Up(me.domEventName, me.eventSystemFlags, Ie, me.nativeEvent);
        if (Ne === null) {
          var De = me.nativeEvent, Ze = new De.constructor(De.type, De);
          gp(Ze), De.target.dispatchEvent(Ze), m_();
        } else {
          var tt = zf(Ne);
          return tt !== null && Bc(tt), me.blockedOn = Ne, !1;
        }
        we.shift();
      }
      return !0;
    }
    function Zg(me, we, Ie) {
      zp(me) && Ie.delete(we);
    }
    function iy() {
      ay = !1, pl !== null && zp(pl) && (pl = null), hl !== null && zp(hl) && (hl = null), Aa !== null && zp(Aa) && (Aa = null), ss.forEach(Zg), $u.forEach(Zg);
    }
    function jd(me, we) {
      me.blockedOn === we && (me.blockedOn = null, ay || (ay = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, iy)));
    }
    function os(me) {
      if (Dp.length > 0) {
        jd(Dp[0], me);
        for (var we = 1; we < Dp.length; we++) {
          var Ie = Dp[we];
          Ie.blockedOn === me && (Ie.blockedOn = null);
        }
      }
      pl !== null && jd(pl, me), hl !== null && jd(hl, me), Aa !== null && jd(Aa, me);
      var Ne = function(ht) {
        return jd(ht, me);
      };
      ss.forEach(Ne), $u.forEach(Ne);
      for (var De = 0; De < Yl.length; De++) {
        var Ze = Yl[De];
        Ze.blockedOn === me && (Ze.blockedOn = null);
      }
      for (; Yl.length > 0; ) {
        var tt = Yl[0];
        if (tt.blockedOn !== null)
          break;
        Bv(tt), tt.blockedOn === null && Yl.shift();
      }
    }
    var Io = fe.ReactCurrentBatchConfig, ri = !0;
    function Ua(me) {
      ri = !!me;
    }
    function Li() {
      return ri;
    }
    function tu(me, we, Ie) {
      var Ne = If(we), De;
      switch (Ne) {
        case Ns:
          De = $f;
          break;
        case Pu:
          De = pi;
          break;
        case ji:
        default:
          De = Fd;
          break;
      }
      return De.bind(null, we, Ie, me);
    }
    function $f(me, we, Ie, Ne) {
      var De = eu(), Ze = Io.transition;
      Io.transition = null;
      try {
        fi(Ns), Fd(me, we, Ie, Ne);
      } finally {
        fi(De), Io.transition = Ze;
      }
    }
    function pi(me, we, Ie, Ne) {
      var De = eu(), Ze = Io.transition;
      Io.transition = null;
      try {
        fi(Pu), Fd(me, we, Ie, Ne);
      } finally {
        fi(De), Io.transition = Ze;
      }
    }
    function Fd(me, we, Ie, Ne) {
      ri && Ld(me, we, Ie, Ne);
    }
    function Ld(me, we, Ie, Ne) {
      var De = Up(me, we, Ie, Ne);
      if (De === null) {
        V_(me, we, Ne, Bd, Ie), Xu(me, Ne);
        return;
      }
      if (qg(De, me, we, Ie, Ne)) {
        Ne.stopPropagation();
        return;
      }
      if (Xu(me, Ne), we & yf && Ku(me)) {
        for (; De !== null; ) {
          var Ze = zf(De);
          Ze !== null && yn(Ze);
          var tt = Up(me, we, Ie, Ne);
          if (tt === null && V_(me, we, Ne, Bd, Ie), tt === De)
            break;
          De = tt;
        }
        De !== null && Ne.stopPropagation();
        return;
      }
      V_(me, we, Ne, null, Ie);
    }
    var Bd = null;
    function Up(me, we, Ie, Ne) {
      Bd = null;
      var De = hm(Ne), Ze = Jp(De);
      if (Ze !== null) {
        var tt = Qs(Ze);
        if (tt === null)
          Ze = null;
        else {
          var ht = tt.tag;
          if (ht === It) {
            var St = bv(tt);
            if (St !== null)
              return St;
            Ze = null;
          } else if (ht === je) {
            var Nt = tt.stateNode;
            if (Nd(Nt))
              return gm(tt);
            Ze = null;
          } else
            tt !== Ze && (Ze = null);
        }
      }
      return Bd = Ze, null;
    }
    function If(me) {
      switch (me) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ns;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Pu;
        case "message": {
          var we = _v();
          switch (we) {
            case Em:
              return Ns;
            case Xs:
              return Pu;
            case dl:
            case Sm:
              return ji;
            case Ac:
              return ry;
            default:
              return ji;
          }
        }
        default:
          return ji;
      }
    }
    function js(me, we, Ie) {
      return me.addEventListener(we, Ie, !1), Ie;
    }
    function zv(me, we, Ie) {
      return me.addEventListener(we, Ie, !0), Ie;
    }
    function Mf(me, we, Ie, Ne) {
      return me.addEventListener(we, Ie, { capture: !0, passive: Ne }), Ie;
    }
    function Ql(me, we, Ie, Ne) {
      return me.addEventListener(we, Ie, { passive: Ne }), Ie;
    }
    var zc = null, Vp = null, Iu = null;
    function sy(me) {
      return zc = me, Vp = Rf(), !0;
    }
    function Uc() {
      zc = null, Vp = null, Iu = null;
    }
    function Hp() {
      if (Iu)
        return Iu;
      var me, we = Vp, Ie = we.length, Ne, De = Rf(), Ze = De.length;
      for (me = 0; me < Ie && we[me] === De[me]; me++)
        ;
      var tt = Ie - me;
      for (Ne = 1; Ne <= tt && we[Ie - Ne] === De[Ze - Ne]; Ne++)
        ;
      var ht = Ne > 1 ? 1 - Ne : void 0;
      return Iu = De.slice(me, ht), Iu;
    }
    function Rf() {
      return "value" in zc ? zc.value : zc.textContent;
    }
    function Nf(me) {
      var we, Ie = me.keyCode;
      return "charCode" in me ? (we = me.charCode, we === 0 && Ie === 13 && (we = 13)) : we = Ie, we === 10 && (we = 13), we >= 32 || we === 13 ? we : 0;
    }
    function zd() {
      return !0;
    }
    function qp() {
      return !1;
    }
    function ca(me) {
      function we(Ie, Ne, De, Ze, tt) {
        this._reactName = Ie, this._targetInst = De, this.type = Ne, this.nativeEvent = Ze, this.target = tt, this.currentTarget = null;
        for (var ht in me)
          if (me.hasOwnProperty(ht)) {
            var St = me[ht];
            St ? this[ht] = St(Ze) : this[ht] = Ze[ht];
          }
        var Nt = Ze.defaultPrevented != null ? Ze.defaultPrevented : Ze.returnValue === !1;
        return Nt ? this.isDefaultPrevented = zd : this.isDefaultPrevented = qp, this.isPropagationStopped = qp, this;
      }
      return oo(we.prototype, { preventDefault: function() {
        this.defaultPrevented = !0;
        var Ie = this.nativeEvent;
        Ie && (Ie.preventDefault ? Ie.preventDefault() : typeof Ie.returnValue != "unknown" && (Ie.returnValue = !1), this.isDefaultPrevented = zd);
      }, stopPropagation: function() {
        var Ie = this.nativeEvent;
        Ie && (Ie.stopPropagation ? Ie.stopPropagation() : typeof Ie.cancelBubble != "unknown" && (Ie.cancelBubble = !0), this.isPropagationStopped = zd);
      }, persist: function() {
      }, isPersistent: zd }), we;
    }
    var ru = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(me) {
      return me.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, nu = ca(ru), Si = oo({}, ru, { view: 0, detail: 0 }), Gg = ca(Si), Wp, Zp, Gp;
    function Vc(me) {
      me !== Gp && (Gp && me.type === "mousemove" ? (Wp = me.screenX - Gp.screenX, Zp = me.screenY - Gp.screenY) : (Wp = 0, Zp = 0), Gp = me);
    }
    var Yp = oo({}, Si, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: qv, button: 0, buttons: 0, relatedTarget: function(me) {
      return me.relatedTarget === void 0 ? me.fromElement === me.srcElement ? me.toElement : me.fromElement : me.relatedTarget;
    }, movementX: function(me) {
      return "movementX" in me ? me.movementX : (Vc(me), Wp);
    }, movementY: function(me) {
      return "movementY" in me ? me.movementY : Zp;
    } }), uy = ca(Yp), Ud = oo({}, Yp, { dataTransfer: 0 }), Uv = ca(Ud), Vd = oo({}, Si, { relatedTarget: 0 }), ly = ca(Vd), Yg = oo({}, ru, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Vv = ca(Yg), cy = oo({}, ru, { clipboardData: function(me) {
      return "clipboardData" in me ? me.clipboardData : window.clipboardData;
    } }), T_ = ca(cy), k_ = oo({}, ru, { data: 0 }), Hv = ca(k_), Qg = Hv, Hd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, O_ = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
    function jf(me) {
      if (me.key) {
        var we = Hd[me.key] || me.key;
        if (we !== "Unidentified")
          return we;
      }
      if (me.type === "keypress") {
        var Ie = Nf(me);
        return Ie === 13 ? "Enter" : String.fromCharCode(Ie);
      }
      return me.type === "keydown" || me.type === "keyup" ? O_[me.keyCode] || "Unidentified" : "";
    }
    var Kg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function La(me) {
      var we = this, Ie = we.nativeEvent;
      if (Ie.getModifierState)
        return Ie.getModifierState(me);
      var Ne = Kg[me];
      return Ne ? !!Ie[Ne] : !1;
    }
    function qv(me) {
      return La;
    }
    var Xg = oo({}, Si, { key: jf, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: qv, charCode: function(me) {
      return me.type === "keypress" ? Nf(me) : 0;
    }, keyCode: function(me) {
      return me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    }, which: function(me) {
      return me.type === "keypress" ? Nf(me) : me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    } }), A_ = ca(Xg), C_ = oo({}, Yp, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Wv = ca(C_), Jg = oo({}, Si, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: qv }), $_ = ca(Jg), Fu = oo({}, ru, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Zv = ca(Fu), I_ = oo({}, Yp, { deltaX: function(me) {
      return "deltaX" in me ? me.deltaX : "wheelDeltaX" in me ? -me.wheelDeltaX : 0;
    }, deltaY: function(me) {
      return "deltaY" in me ? me.deltaY : "wheelDeltaY" in me ? -me.wheelDeltaY : "wheelDelta" in me ? -me.wheelDelta : 0;
    }, deltaZ: 0, deltaMode: 0 }), Hc = ca(I_), dy = [9, 13, 27, 32], qc = 229, Ff = kn && "CompositionEvent" in window, qd = null;
    kn && "documentMode" in document && (qd = document.documentMode);
    var Gv = kn && "TextEvent" in window && !qd, e0 = kn && (!Ff || qd && qd > 8 && qd <= 11), fy = 32, t0 = String.fromCharCode(fy);
    function r0() {
      Pn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Pn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Pn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Pn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Yv = !1;
    function py(me) {
      return (me.ctrlKey || me.altKey || me.metaKey) && !(me.ctrlKey && me.altKey);
    }
    function hy(me) {
      switch (me) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function n0(me, we) {
      return me === "keydown" && we.keyCode === qc;
    }
    function my(me, we) {
      switch (me) {
        case "keyup":
          return dy.indexOf(we.keyCode) !== -1;
        case "keydown":
          return we.keyCode !== qc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function o0(me) {
      var we = me.detail;
      return typeof we == "object" && "data" in we ? we.data : null;
    }
    function Qv(me) {
      return me.locale === "ko";
    }
    var Wc = !1;
    function yy(me, we, Ie, Ne, De) {
      var Ze, tt;
      if (Ff ? Ze = hy(we) : Wc ? my(we, Ne) && (Ze = "onCompositionEnd") : n0(we, Ne) && (Ze = "onCompositionStart"), !Ze)
        return null;
      e0 && !Qv(Ne) && (!Wc && Ze === "onCompositionStart" ? Wc = sy(De) : Ze === "onCompositionEnd" && Wc && (tt = Hp()));
      var ht = c0(Ie, Ze);
      if (ht.length > 0) {
        var St = new Hv(Ze, we, null, Ne, De);
        if (me.push({ event: St, listeners: ht }), tt)
          St.data = tt;
        else {
          var Nt = o0(Ne);
          Nt !== null && (St.data = Nt);
        }
      }
    }
    function Kv(me, we) {
      switch (me) {
        case "compositionend":
          return o0(we);
        case "keypress":
          var Ie = we.which;
          return Ie !== fy ? null : (Yv = !0, t0);
        case "textInput":
          var Ne = we.data;
          return Ne === t0 && Yv ? null : Ne;
        default:
          return null;
      }
    }
    function vy(me, we) {
      if (Wc) {
        if (me === "compositionend" || !Ff && my(me, we)) {
          var Ie = Hp();
          return Uc(), Wc = !1, Ie;
        }
        return null;
      }
      switch (me) {
        case "paste":
          return null;
        case "keypress":
          if (!py(we)) {
            if (we.char && we.char.length > 1)
              return we.char;
            if (we.which)
              return String.fromCharCode(we.which);
          }
          return null;
        case "compositionend":
          return e0 && !Qv(we) ? null : we.data;
        default:
          return null;
      }
    }
    function a0(me, we, Ie, Ne, De) {
      var Ze;
      if (Gv ? Ze = Kv(we, Ne) : Ze = vy(we, Ne), !Ze)
        return null;
      var tt = c0(Ie, "onBeforeInput");
      if (tt.length > 0) {
        var ht = new Qg("onBeforeInput", "beforeinput", null, Ne, De);
        me.push({ event: ht, listeners: tt }), ht.data = Ze;
      }
    }
    function R_(me, we, Ie, Ne, De, Ze, tt) {
      yy(me, we, Ie, Ne, De), a0(me, we, Ie, Ne, De);
    }
    var by = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
    function i0(me) {
      var we = me && me.nodeName && me.nodeName.toLowerCase();
      return we === "input" ? !!by[me.type] : we === "textarea";
    }
    function Qp(me) {
      if (!kn)
        return !1;
      var we = "on" + me, Ie = we in document;
      if (!Ie) {
        var Ne = document.createElement("div");
        Ne.setAttribute(we, "return;"), Ie = typeof Ne[we] == "function";
      }
      return Ie;
    }
    function N_() {
      Pn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Lf(me, we, Ie, Ne) {
      mm(Ne);
      var De = c0(we, "onChange");
      if (De.length > 0) {
        var Ze = new nu("onChange", "change", null, Ie, Ne);
        me.push({ event: Ze, listeners: De });
      }
    }
    var Se = null, Ce = null;
    function Fe(me) {
      var we = me.nodeName && me.nodeName.toLowerCase();
      return we === "select" || we === "input" && me.type === "file";
    }
    function Ue(me) {
      var we = [];
      Lf(we, Ce, me, hm(me)), cv(Xe, we);
    }
    function Xe(me) {
      fS(me, 0);
    }
    function it(me) {
      var we = Sy(me);
      if (du(we))
        return me;
    }
    function $t(me, we) {
      if (me === "change")
        return we;
    }
    var Kt = !1;
    kn && (Kt = Qp("input") && (!document.documentMode || document.documentMode > 9));
    function rr(me, we) {
      Se = me, Ce = we, Se.attachEvent("onpropertychange", zr);
    }
    function Sr() {
      Se && (Se.detachEvent("onpropertychange", zr), Se = null, Ce = null);
    }
    function zr(me) {
      me.propertyName === "value" && it(Ce) && Ue(me);
    }
    function Hr(me, we, Ie) {
      me === "focusin" ? (Sr(), rr(we, Ie)) : me === "focusout" && Sr();
    }
    function Ur(me, we) {
      if (me === "selectionchange" || me === "keyup" || me === "keydown")
        return it(Ce);
    }
    function dn(me) {
      var we = me.nodeName;
      return we && we.toLowerCase() === "input" && (me.type === "checkbox" || me.type === "radio");
    }
    function gn(me, we) {
      if (me === "click")
        return it(we);
    }
    function _n(me, we) {
      if (me === "input" || me === "change")
        return it(we);
    }
    function Va(me) {
      var we = me._wrapperState;
      !we || !we.controlled || me.type !== "number" || Kr(me, "number", me.value);
    }
    function vr(me, we, Ie, Ne, De, Ze, tt) {
      var ht = Ie ? Sy(Ie) : window, St, Nt;
      if (Fe(ht) ? St = $t : i0(ht) ? Kt ? St = _n : (St = Ur, Nt = Hr) : dn(ht) && (St = gn), St) {
        var Bt = St(we, Ie);
        if (Bt) {
          Lf(me, Bt, Ne, De);
          return;
        }
      }
      Nt && Nt(we, ht, Ie), we === "focusout" && Va(ht);
    }
    function ar() {
      co("onMouseEnter", ["mouseout", "mouseover"]), co("onMouseLeave", ["mouseout", "mouseover"]), co("onPointerEnter", ["pointerout", "pointerover"]), co("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function wr(me, we, Ie, Ne, De, Ze, tt) {
      var ht = we === "mouseover" || we === "pointerover", St = we === "mouseout" || we === "pointerout";
      if (ht && !gg(Ne)) {
        var Nt = Ne.relatedTarget || Ne.fromElement;
        if (Nt && (Jp(Nt) || db(Nt)))
          return;
      }
      if (!(!St && !ht)) {
        var Bt;
        if (De.window === De)
          Bt = De;
        else {
          var lr = De.ownerDocument;
          lr ? Bt = lr.defaultView || lr.parentWindow : Bt = window;
        }
        var nr, _r;
        if (St) {
          var Er = Ne.relatedTarget || Ne.toElement;
          if (nr = Ie, _r = Er ? Jp(Er) : null, _r !== null) {
            var Cr = Qs(_r);
            (_r !== Cr || _r.tag !== ze && _r.tag !== He) && (_r = null);
          }
        } else
          nr = null, _r = Ie;
        if (nr !== _r) {
          var rn = uy, Cn = "onMouseLeave", Bn = "onMouseEnter", Ro = "mouse";
          (we === "pointerout" || we === "pointerover") && (rn = Wv, Cn = "onPointerLeave", Bn = "onPointerEnter", Ro = "pointer");
          var Co = nr == null ? Bt : Sy(nr), br = _r == null ? Bt : Sy(_r), Ar = new rn(Cn, Ro + "leave", nr, Ne, De);
          Ar.target = Co, Ar.relatedTarget = br;
          var gr = null, qr = Jp(De);
          if (qr === Ie) {
            var hn = new rn(Bn, Ro + "enter", _r, Ne, De);
            hn.target = br, hn.relatedTarget = Co, gr = hn;
          }
          OO(me, Ar, gr, nr, _r);
        }
      }
    }
    function Yr(me, we) {
      return me === we && (me !== 0 || 1 / me === 1 / we) || me !== me && we !== we;
    }
    var an = typeof Object.is == "function" ? Object.is : Yr;
    function Mn(me, we) {
      if (an(me, we))
        return !0;
      if (typeof me != "object" || me === null || typeof we != "object" || we === null)
        return !1;
      var Ie = Object.keys(me), Ne = Object.keys(we);
      if (Ie.length !== Ne.length)
        return !1;
      for (var De = 0; De < Ie.length; De++) {
        var Ze = Ie[De];
        if (!Yn.call(we, Ze) || !an(me[Ze], we[Ze]))
          return !1;
      }
      return !0;
    }
    function Dn(me) {
      for (; me && me.firstChild; )
        me = me.firstChild;
      return me;
    }
    function ao(me) {
      for (; me; ) {
        if (me.nextSibling)
          return me.nextSibling;
        me = me.parentNode;
      }
    }
    function hi(me, we) {
      for (var Ie = Dn(me), Ne = 0, De = 0; Ie; ) {
        if (Ie.nodeType === Cl) {
          if (De = Ne + Ie.textContent.length, Ne <= we && De >= we)
            return { node: Ie, offset: we - Ne };
          Ne = De;
        }
        Ie = Dn(ao(Ie));
      }
    }
    function Go(me) {
      var we = me.ownerDocument, Ie = we && we.defaultView || window, Ne = Ie.getSelection && Ie.getSelection();
      if (!Ne || Ne.rangeCount === 0)
        return null;
      var De = Ne.anchorNode, Ze = Ne.anchorOffset, tt = Ne.focusNode, ht = Ne.focusOffset;
      try {
        De.nodeType, tt.nodeType;
      } catch {
        return null;
      }
      return Zc(me, De, Ze, tt, ht);
    }
    function Zc(me, we, Ie, Ne, De) {
      var Ze = 0, tt = -1, ht = -1, St = 0, Nt = 0, Bt = me, lr = null;
      e:
        for (; ; ) {
          for (var nr = null; Bt === we && (Ie === 0 || Bt.nodeType === Cl) && (tt = Ze + Ie), Bt === Ne && (De === 0 || Bt.nodeType === Cl) && (ht = Ze + De), Bt.nodeType === Cl && (Ze += Bt.nodeValue.length), (nr = Bt.firstChild) !== null; )
            lr = Bt, Bt = nr;
          for (; ; ) {
            if (Bt === me)
              break e;
            if (lr === we && ++St === Ie && (tt = Ze), lr === Ne && ++Nt === De && (ht = Ze), (nr = Bt.nextSibling) !== null)
              break;
            Bt = lr, lr = Bt.parentNode;
          }
          Bt = nr;
        }
      return tt === -1 || ht === -1 ? null : { start: tt, end: ht };
    }
    function j_(me, we) {
      var Ie = me.ownerDocument || document, Ne = Ie && Ie.defaultView || window;
      if (Ne.getSelection) {
        var De = Ne.getSelection(), Ze = me.textContent.length, tt = Math.min(we.start, Ze), ht = we.end === void 0 ? tt : Math.min(we.end, Ze);
        if (!De.extend && tt > ht) {
          var St = ht;
          ht = tt, tt = St;
        }
        var Nt = hi(me, tt), Bt = hi(me, ht);
        if (Nt && Bt) {
          if (De.rangeCount === 1 && De.anchorNode === Nt.node && De.anchorOffset === Nt.offset && De.focusNode === Bt.node && De.focusOffset === Bt.offset)
            return;
          var lr = Ie.createRange();
          lr.setStart(Nt.node, Nt.offset), De.removeAllRanges(), tt > ht ? (De.addRange(lr), De.extend(Bt.node, Bt.offset)) : (lr.setEnd(Bt.node, Bt.offset), De.addRange(lr));
        }
      }
    }
    function QE(me) {
      return me && me.nodeType === Cl;
    }
    function KE(me, we) {
      return !me || !we ? !1 : me === we ? !0 : QE(me) ? !1 : QE(we) ? KE(me, we.parentNode) : "contains" in me ? me.contains(we) : me.compareDocumentPosition ? !!(me.compareDocumentPosition(we) & 16) : !1;
    }
    function cO(me) {
      return me && me.ownerDocument && KE(me.ownerDocument.documentElement, me);
    }
    function dO(me) {
      try {
        return typeof me.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function XE() {
      for (var me = window, we = Ps(); we instanceof me.HTMLIFrameElement; ) {
        if (dO(we))
          me = we.contentWindow;
        else
          return we;
        we = Ps(me.document);
      }
      return we;
    }
    function F_(me) {
      var we = me && me.nodeName && me.nodeName.toLowerCase();
      return we && (we === "input" && (me.type === "text" || me.type === "search" || me.type === "tel" || me.type === "url" || me.type === "password") || we === "textarea" || me.contentEditable === "true");
    }
    function fO() {
      var me = XE();
      return { focusedElem: me, selectionRange: F_(me) ? hO(me) : null };
    }
    function pO(me) {
      var we = XE(), Ie = me.focusedElem, Ne = me.selectionRange;
      if (we !== Ie && cO(Ie)) {
        Ne !== null && F_(Ie) && mO(Ie, Ne);
        for (var De = [], Ze = Ie; Ze = Ze.parentNode; )
          Ze.nodeType === Ts && De.push({ element: Ze, left: Ze.scrollLeft, top: Ze.scrollTop });
        typeof Ie.focus == "function" && Ie.focus();
        for (var tt = 0; tt < De.length; tt++) {
          var ht = De[tt];
          ht.element.scrollLeft = ht.left, ht.element.scrollTop = ht.top;
        }
      }
    }
    function hO(me) {
      var we;
      return "selectionStart" in me ? we = { start: me.selectionStart, end: me.selectionEnd } : we = Go(me), we || { start: 0, end: 0 };
    }
    function mO(me, we) {
      var Ie = we.start, Ne = we.end;
      Ne === void 0 && (Ne = Ie), "selectionStart" in me ? (me.selectionStart = Ie, me.selectionEnd = Math.min(Ne, me.value.length)) : j_(me, we);
    }
    var yO = kn && "documentMode" in document && document.documentMode <= 11;
    function vO() {
      Pn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var gy = null, L_ = null, Xv = null, D_ = !1;
    function bO(me) {
      if ("selectionStart" in me && F_(me))
        return { start: me.selectionStart, end: me.selectionEnd };
      var we = me.ownerDocument && me.ownerDocument.defaultView || window, Ie = we.getSelection();
      return { anchorNode: Ie.anchorNode, anchorOffset: Ie.anchorOffset, focusNode: Ie.focusNode, focusOffset: Ie.focusOffset };
    }
    function gO(me) {
      return me.window === me ? me.document : me.nodeType === Zu ? me : me.ownerDocument;
    }
    function JE(me, we, Ie) {
      var Ne = gO(Ie);
      if (!(D_ || gy == null || gy !== Ps(Ne))) {
        var De = bO(gy);
        if (!Xv || !Mn(Xv, De)) {
          Xv = De;
          var Ze = c0(L_, "onSelect");
          if (Ze.length > 0) {
            var tt = new nu("onSelect", "select", null, we, Ie);
            me.push({ event: tt, listeners: Ze }), tt.target = gy;
          }
        }
      }
    }
    function wO(me, we, Ie, Ne, De, Ze, tt) {
      var ht = Ie ? Sy(Ie) : window;
      switch (we) {
        case "focusin":
          (i0(ht) || ht.contentEditable === "true") && (gy = ht, L_ = Ie, Xv = null);
          break;
        case "focusout":
          gy = null, L_ = null, Xv = null;
          break;
        case "mousedown":
          D_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          D_ = !1, JE(me, Ne, De);
          break;
        case "selectionchange":
          if (yO)
            break;
        case "keydown":
        case "keyup":
          JE(me, Ne, De);
      }
    }
    function s0(me, we) {
      var Ie = {};
      return Ie[me.toLowerCase()] = we.toLowerCase(), Ie["Webkit" + me] = "webkit" + we, Ie["Moz" + me] = "moz" + we, Ie;
    }
    var wy = { animationend: s0("Animation", "AnimationEnd"), animationiteration: s0("Animation", "AnimationIteration"), animationstart: s0("Animation", "AnimationStart"), transitionend: s0("Transition", "TransitionEnd") }, B_ = {}, eS = {};
    kn && (eS = document.createElement("div").style, "AnimationEvent" in window || (delete wy.animationend.animation, delete wy.animationiteration.animation, delete wy.animationstart.animation), "TransitionEvent" in window || delete wy.transitionend.transition);
    function u0(me) {
      if (B_[me])
        return B_[me];
      if (!wy[me])
        return me;
      var we = wy[me];
      for (var Ie in we)
        if (we.hasOwnProperty(Ie) && Ie in eS)
          return B_[me] = we[Ie];
      return me;
    }
    var tS = u0("animationend"), oS = u0("animationiteration"), aS = u0("animationstart"), uS = u0("transitionend"), lS = /* @__PURE__ */ new Map(), cS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Df(me, we) {
      lS.set(me, we), Pn(we, [me]);
    }
    function _O() {
      for (var me = 0; me < cS.length; me++) {
        var we = cS[me], Ie = we.toLowerCase(), Ne = we[0].toUpperCase() + we.slice(1);
        Df(Ie, "on" + Ne);
      }
      Df(tS, "onAnimationEnd"), Df(oS, "onAnimationIteration"), Df(aS, "onAnimationStart"), Df("dblclick", "onDoubleClick"), Df("focusin", "onFocus"), Df("focusout", "onBlur"), Df(uS, "onTransitionEnd");
    }
    function xO(me, we, Ie, Ne, De, Ze, tt) {
      var ht = lS.get(we);
      if (ht !== void 0) {
        var St = nu, Nt = we;
        switch (we) {
          case "keypress":
            if (Nf(Ne) === 0)
              return;
          case "keydown":
          case "keyup":
            St = A_;
            break;
          case "focusin":
            Nt = "focus", St = ly;
            break;
          case "focusout":
            Nt = "blur", St = ly;
            break;
          case "beforeblur":
          case "afterblur":
            St = ly;
            break;
          case "click":
            if (Ne.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            St = uy;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            St = Uv;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            St = $_;
            break;
          case tS:
          case oS:
          case aS:
            St = Vv;
            break;
          case uS:
            St = Zv;
            break;
          case "scroll":
            St = Gg;
            break;
          case "wheel":
            St = Hc;
            break;
          case "copy":
          case "cut":
          case "paste":
            St = T_;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            St = Wv;
            break;
        }
        var Bt = (Ze & yf) !== 0;
        {
          var lr = !Bt && we === "scroll", nr = TO(Ie, ht, Ne.type, Bt, lr);
          if (nr.length > 0) {
            var _r = new St(ht, Nt, null, Ne, De);
            me.push({ event: _r, listeners: nr });
          }
        }
      }
    }
    _O(), ar(), N_(), vO(), r0();
    function EO(me, we, Ie, Ne, De, Ze, tt) {
      xO(me, we, Ie, Ne, De, Ze);
      var ht = (Ze & bg) === 0;
      ht && (wr(me, we, Ie, Ne, De), vr(me, we, Ie, Ne, De), wO(me, we, Ie, Ne, De), R_(me, we, Ie, Ne, De));
    }
    var Jv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], z_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Jv));
    function dS(me, we, Ie) {
      var Ne = me.type || "unknown-event";
      me.currentTarget = Ie, Dl(Ne, we, void 0, me), me.currentTarget = null;
    }
    function SO(me, we, Ie) {
      var Ne;
      if (Ie)
        for (var De = we.length - 1; De >= 0; De--) {
          var Ze = we[De], tt = Ze.instance, ht = Ze.currentTarget, St = Ze.listener;
          if (tt !== Ne && me.isPropagationStopped())
            return;
          dS(me, St, ht), Ne = tt;
        }
      else
        for (var Nt = 0; Nt < we.length; Nt++) {
          var Bt = we[Nt], lr = Bt.instance, nr = Bt.currentTarget, _r = Bt.listener;
          if (lr !== Ne && me.isPropagationStopped())
            return;
          dS(me, _r, nr), Ne = lr;
        }
    }
    function fS(me, we) {
      for (var Ie = (we & yf) !== 0, Ne = 0; Ne < me.length; Ne++) {
        var De = me[Ne], Ze = De.event, tt = De.listeners;
        SO(Ze, tt, Ie);
      }
      hv();
    }
    function PO(me, we, Ie, Ne, De) {
      var Ze = hm(Ie), tt = [];
      EO(tt, me, Ne, Ie, Ze, we), fS(tt, we);
    }
    function Ra(me, we) {
      z_.has(me) || xe('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', me);
      var Ie = !1, Ne = HC(we), De = AO(me, Ie);
      Ne.has(De) || (pS(we, me, mf, Ie), Ne.add(De));
    }
    function U_(me, we, Ie) {
      z_.has(me) && !we && xe('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', me);
      var Ne = 0;
      we && (Ne |= yf), pS(Ie, me, Ne, we);
    }
    var l0 = "_reactListening" + Math.random().toString(36).slice(2);
    function eb(me) {
      if (!me[l0]) {
        me[l0] = !0, jr.forEach(function(Ie) {
          Ie !== "selectionchange" && (z_.has(Ie) || U_(Ie, !1, me), U_(Ie, !0, me));
        });
        var we = me.nodeType === Zu ? me : me.ownerDocument;
        we !== null && (we[l0] || (we[l0] = !0, U_("selectionchange", !1, we)));
      }
    }
    function pS(me, we, Ie, Ne, De) {
      var Ze = tu(me, we, Ie), tt = void 0;
      xp && (we === "touchstart" || we === "touchmove" || we === "wheel") && (tt = !0), me = me, Ne ? tt !== void 0 ? Mf(me, we, Ze, tt) : zv(me, we, Ze) : tt !== void 0 ? Ql(me, we, Ze, tt) : js(me, we, Ze);
    }
    function hS(me, we) {
      return me === we || me.nodeType === ei && me.parentNode === we;
    }
    function V_(me, we, Ie, Ne, De) {
      var Ze = Ne;
      if (!(we & Rl) && !(we & mf)) {
        var tt = De;
        if (Ne !== null) {
          var ht = Ne;
          e:
            for (; ; ) {
              if (ht === null)
                return;
              var St = ht.tag;
              if (St === je || St === Be) {
                var Nt = ht.stateNode.containerInfo;
                if (hS(Nt, tt))
                  break;
                if (St === Be)
                  for (var Bt = ht.return; Bt !== null; ) {
                    var lr = Bt.tag;
                    if (lr === je || lr === Be) {
                      var nr = Bt.stateNode.containerInfo;
                      if (hS(nr, tt))
                        return;
                    }
                    Bt = Bt.return;
                  }
                for (; Nt !== null; ) {
                  var _r = Jp(Nt);
                  if (_r === null)
                    return;
                  var Er = _r.tag;
                  if (Er === ze || Er === He) {
                    ht = Ze = _r;
                    continue e;
                  }
                  Nt = Nt.parentNode;
                }
              }
              ht = ht.return;
            }
        }
      }
      cv(function() {
        return PO(me, we, Ie, Ze);
      });
    }
    function tb(me, we, Ie) {
      return { instance: me, listener: we, currentTarget: Ie };
    }
    function TO(me, we, Ie, Ne, De, Ze) {
      for (var tt = we !== null ? we + "Capture" : null, ht = Ne ? tt : we, St = [], Nt = me, Bt = null; Nt !== null; ) {
        var lr = Nt, nr = lr.stateNode, _r = lr.tag;
        if (_r === ze && nr !== null && (Bt = nr, ht !== null)) {
          var Er = bd(Nt, ht);
          Er != null && St.push(tb(Nt, Er, Bt));
        }
        if (De)
          break;
        Nt = Nt.return;
      }
      return St;
    }
    function c0(me, we) {
      for (var Ie = we + "Capture", Ne = [], De = me; De !== null; ) {
        var Ze = De, tt = Ze.stateNode, ht = Ze.tag;
        if (ht === ze && tt !== null) {
          var St = tt, Nt = bd(De, Ie);
          Nt != null && Ne.unshift(tb(De, Nt, St));
          var Bt = bd(De, we);
          Bt != null && Ne.push(tb(De, Bt, St));
        }
        De = De.return;
      }
      return Ne;
    }
    function _y(me) {
      if (me === null)
        return null;
      do
        me = me.return;
      while (me && me.tag !== ze);
      return me || null;
    }
    function kO(me, we) {
      for (var Ie = me, Ne = we, De = 0, Ze = Ie; Ze; Ze = _y(Ze))
        De++;
      for (var tt = 0, ht = Ne; ht; ht = _y(ht))
        tt++;
      for (; De - tt > 0; )
        Ie = _y(Ie), De--;
      for (; tt - De > 0; )
        Ne = _y(Ne), tt--;
      for (var St = De; St--; ) {
        if (Ie === Ne || Ne !== null && Ie === Ne.alternate)
          return Ie;
        Ie = _y(Ie), Ne = _y(Ne);
      }
      return null;
    }
    function yS(me, we, Ie, Ne, De) {
      for (var Ze = we._reactName, tt = [], ht = Ie; ht !== null && ht !== Ne; ) {
        var St = ht, Nt = St.alternate, Bt = St.stateNode, lr = St.tag;
        if (Nt !== null && Nt === Ne)
          break;
        if (lr === ze && Bt !== null) {
          var nr = Bt;
          if (De) {
            var _r = bd(ht, Ze);
            _r != null && tt.unshift(tb(ht, _r, nr));
          } else if (!De) {
            var Er = bd(ht, Ze);
            Er != null && tt.push(tb(ht, Er, nr));
          }
        }
        ht = ht.return;
      }
      tt.length !== 0 && me.push({ event: we, listeners: tt });
    }
    function OO(me, we, Ie, Ne, De) {
      var Ze = Ne && De ? kO(Ne, De) : null;
      Ne !== null && yS(me, we, Ne, Ze, !1), De !== null && Ie !== null && yS(me, Ie, De, Ze, !0);
    }
    function AO(me, we) {
      return me + "__" + (we ? "capture" : "bubble");
    }
    var Bu = !1, rb = "dangerouslySetInnerHTML", d0 = "suppressContentEditableWarning", Bf = "suppressHydrationWarning", vS = "autoFocus", Kp = "children", Xp = "style", f0 = "__html", H_, p0, nb, bS, h0, gS, wS;
    H_ = { dialog: !0, webview: !0 }, p0 = function(me, we) {
      pm(me, we), av(me, we), vg(me, we, { registrationNameDependencies: un, possibleRegistrationNames: so });
    }, gS = kn && !document.documentMode, nb = function(me, we, Ie) {
      if (!Bu) {
        var Ne = m0(Ie), De = m0(we);
        De !== Ne && (Bu = !0, xe("Prop `%s` did not match. Server: %s Client: %s", me, JSON.stringify(De), JSON.stringify(Ne)));
      }
    }, bS = function(me) {
      if (!Bu) {
        Bu = !0;
        var we = [];
        me.forEach(function(Ie) {
          we.push(Ie);
        }), xe("Extra attributes from the server: %s", we);
      }
    }, h0 = function(me, we) {
      we === !1 ? xe("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", me, me, me) : xe("Expected `%s` listener to be a function, instead got a value of `%s` type.", me, typeof we);
    }, wS = function(me, we) {
      var Ie = me.namespaceURI === Al ? me.ownerDocument.createElement(me.tagName) : me.ownerDocument.createElementNS(me.namespaceURI, me.tagName);
      return Ie.innerHTML = we, Ie.innerHTML;
    };
    var CO = /\r\n?/g, $O = /\u0000|\uFFFD/g;
    function m0(me) {
      vo(me);
      var we = typeof me == "string" ? me : "" + me;
      return we.replace(CO, `
`).replace($O, "");
    }
    function y0(me, we, Ie, Ne) {
      var De = m0(we), Ze = m0(me);
      if (Ze !== De && (Ne && (Bu || (Bu = !0, xe('Text content did not match. Server: "%s" Client: "%s"', Ze, De))), Ie && At))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function _S(me) {
      return me.nodeType === Zu ? me : me.ownerDocument;
    }
    function IO() {
    }
    function v0(me) {
      me.onclick = IO;
    }
    function MO(me, we, Ie, Ne, De) {
      for (var Ze in Ne)
        if (Ne.hasOwnProperty(Ze)) {
          var tt = Ne[Ze];
          if (Ze === Xp)
            tt && Object.freeze(tt), sg(we, tt);
          else if (Ze === rb) {
            var ht = tt ? tt[f0] : void 0;
            ht != null && Kb(we, ht);
          } else if (Ze === Kp)
            if (typeof tt == "string") {
              var St = me !== "textarea" || tt !== "";
              St && um(we, tt);
            } else
              typeof tt == "number" && um(we, "" + tt);
          else
            Ze === d0 || Ze === Bf || Ze === vS || (un.hasOwnProperty(Ze) ? tt != null && (typeof tt != "function" && h0(Ze, tt), Ze === "onScroll" && Ra("scroll", we)) : tt != null && bo(we, Ze, tt, De));
        }
    }
    function RO(me, we, Ie, Ne) {
      for (var De = 0; De < we.length; De += 2) {
        var Ze = we[De], tt = we[De + 1];
        Ze === Xp ? sg(me, tt) : Ze === rb ? Kb(me, tt) : Ze === Kp ? um(me, tt) : bo(me, Ze, tt, Ne);
      }
    }
    function NO(me, we, Ie, Ne) {
      var De, Ze = _S(Ie), tt, ht = Ne;
      if (ht === Al && (ht = im(me)), ht === Al) {
        if (De = Ml(me, we), !De && me !== me.toLowerCase() && xe("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", me), me === "script") {
          var St = Ze.createElement("div");
          St.innerHTML = "<script><\/script>";
          var Nt = St.firstChild;
          tt = St.removeChild(Nt);
        } else if (typeof we.is == "string")
          tt = Ze.createElement(me, { is: we.is });
        else if (tt = Ze.createElement(me), me === "select") {
          var Bt = tt;
          we.multiple ? Bt.multiple = !0 : we.size && (Bt.size = we.size);
        }
      } else
        tt = Ze.createElementNS(ht, me);
      return ht === Al && !De && Object.prototype.toString.call(tt) === "[object HTMLUnknownElement]" && !Yn.call(H_, me) && (H_[me] = !0, xe("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", me)), tt;
    }
    function jO(me, we) {
      return _S(we).createTextNode(me);
    }
    function FO(me, we, Ie, Ne) {
      var De = Ml(we, Ie);
      p0(we, Ie);
      var Ze;
      switch (we) {
        case "dialog":
          Ra("cancel", me), Ra("close", me), Ze = Ie;
          break;
        case "iframe":
        case "object":
        case "embed":
          Ra("load", me), Ze = Ie;
          break;
        case "video":
        case "audio":
          for (var tt = 0; tt < Jv.length; tt++)
            Ra(Jv[tt], me);
          Ze = Ie;
          break;
        case "source":
          Ra("error", me), Ze = Ie;
          break;
        case "img":
        case "image":
        case "link":
          Ra("error", me), Ra("load", me), Ze = Ie;
          break;
        case "details":
          Ra("toggle", me), Ze = Ie;
          break;
        case "input":
          jt(me, Ie), Ze = gt(me, Ie), Ra("invalid", me);
          break;
        case "option":
          Vn(me, Ie), Ze = Ie;
          break;
        case "select":
          lf(me, Ie), Ze = Ol(me, Ie), Ra("invalid", me);
          break;
        case "textarea":
          Gb(me, Ie), Ze = Qy(me, Ie), Ra("invalid", me);
          break;
        default:
          Ze = Ie;
      }
      switch (dm(we, Ze), MO(we, me, Ne, Ze, De), we) {
        case "input":
          Mi(me), Fr(me, Ie, !1);
          break;
        case "textarea":
          Mi(me), Qb(me);
          break;
        case "option":
          mo(me, Ie);
          break;
        case "select":
          n_(me, Ie);
          break;
        default:
          typeof Ze.onClick == "function" && v0(me);
          break;
      }
    }
    function LO(me, we, Ie, Ne, De) {
      p0(we, Ne);
      var Ze = null, tt, ht;
      switch (we) {
        case "input":
          tt = gt(me, Ie), ht = gt(me, Ne), Ze = [];
          break;
        case "select":
          tt = Ol(me, Ie), ht = Ol(me, Ne), Ze = [];
          break;
        case "textarea":
          tt = Qy(me, Ie), ht = Qy(me, Ne), Ze = [];
          break;
        default:
          tt = Ie, ht = Ne, typeof tt.onClick != "function" && typeof ht.onClick == "function" && v0(me);
          break;
      }
      dm(we, ht);
      var St, Nt, Bt = null;
      for (St in tt)
        if (!(ht.hasOwnProperty(St) || !tt.hasOwnProperty(St) || tt[St] == null))
          if (St === Xp) {
            var lr = tt[St];
            for (Nt in lr)
              lr.hasOwnProperty(Nt) && (Bt || (Bt = {}), Bt[Nt] = "");
          } else
            St === rb || St === Kp || St === d0 || St === Bf || St === vS || (un.hasOwnProperty(St) ? Ze || (Ze = []) : (Ze = Ze || []).push(St, null));
      for (St in ht) {
        var nr = ht[St], _r = tt == null ? void 0 : tt[St];
        if (!(!ht.hasOwnProperty(St) || nr === _r || nr == null && _r == null))
          if (St === Xp)
            if (nr && Object.freeze(nr), _r) {
              for (Nt in _r)
                _r.hasOwnProperty(Nt) && (!nr || !nr.hasOwnProperty(Nt)) && (Bt || (Bt = {}), Bt[Nt] = "");
              for (Nt in nr)
                nr.hasOwnProperty(Nt) && _r[Nt] !== nr[Nt] && (Bt || (Bt = {}), Bt[Nt] = nr[Nt]);
            } else
              Bt || (Ze || (Ze = []), Ze.push(St, Bt)), Bt = nr;
          else if (St === rb) {
            var Er = nr ? nr[f0] : void 0, Cr = _r ? _r[f0] : void 0;
            Er != null && Cr !== Er && (Ze = Ze || []).push(St, Er);
          } else
            St === Kp ? (typeof nr == "string" || typeof nr == "number") && (Ze = Ze || []).push(St, "" + nr) : St === d0 || St === Bf || (un.hasOwnProperty(St) ? (nr != null && (typeof nr != "function" && h0(St, nr), St === "onScroll" && Ra("scroll", me)), !Ze && _r !== nr && (Ze = [])) : (Ze = Ze || []).push(St, nr));
      }
      return Bt && (yp(Bt, ht[Xp]), (Ze = Ze || []).push(Xp, Bt)), Ze;
    }
    function DO(me, we, Ie, Ne, De) {
      Ie === "input" && De.type === "radio" && De.name != null && Ht(me, De);
      var Ze = Ml(Ie, Ne), tt = Ml(Ie, De);
      switch (RO(me, we, Ze, tt), Ie) {
        case "input":
          sr(me, De);
          break;
        case "textarea":
          Yb(me, De);
          break;
        case "select":
          o_(me, De);
          break;
      }
    }
    function BO(me) {
      {
        var we = me.toLowerCase();
        return fm.hasOwnProperty(we) && fm[we] || null;
      }
    }
    function zO(me, we, Ie, Ne, De, Ze, tt) {
      var ht, St;
      switch (ht = Ml(we, Ie), p0(we, Ie), we) {
        case "dialog":
          Ra("cancel", me), Ra("close", me);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ra("load", me);
          break;
        case "video":
        case "audio":
          for (var Nt = 0; Nt < Jv.length; Nt++)
            Ra(Jv[Nt], me);
          break;
        case "source":
          Ra("error", me);
          break;
        case "img":
        case "image":
        case "link":
          Ra("error", me), Ra("load", me);
          break;
        case "details":
          Ra("toggle", me);
          break;
        case "input":
          jt(me, Ie), Ra("invalid", me);
          break;
        case "option":
          Vn(me, Ie);
          break;
        case "select":
          lf(me, Ie), Ra("invalid", me);
          break;
        case "textarea":
          Gb(me, Ie), Ra("invalid", me);
          break;
      }
      dm(we, Ie);
      {
        St = /* @__PURE__ */ new Set();
        for (var Bt = me.attributes, lr = 0; lr < Bt.length; lr++) {
          var nr = Bt[lr].name.toLowerCase();
          switch (nr) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              St.add(Bt[lr].name);
          }
        }
      }
      var _r = null;
      for (var Er in Ie)
        if (Ie.hasOwnProperty(Er)) {
          var Cr = Ie[Er];
          if (Er === Kp)
            typeof Cr == "string" ? me.textContent !== Cr && (Ie[Bf] !== !0 && y0(me.textContent, Cr, Ze, tt), _r = [Kp, Cr]) : typeof Cr == "number" && me.textContent !== "" + Cr && (Ie[Bf] !== !0 && y0(me.textContent, Cr, Ze, tt), _r = [Kp, "" + Cr]);
          else if (un.hasOwnProperty(Er))
            Cr != null && (typeof Cr != "function" && h0(Er, Cr), Er === "onScroll" && Ra("scroll", me));
          else if (tt && typeof ht == "boolean") {
            var rn = void 0, Cn = ht && xr ? null : Fn(Er);
            if (Ie[Bf] !== !0 && !(Er === d0 || Er === Bf || Er === "value" || Er === "checked" || Er === "selected")) {
              if (Er === rb) {
                var Bn = me.innerHTML, Ro = Cr ? Cr[f0] : void 0;
                if (Ro != null) {
                  var Co = wS(me, Ro);
                  Co !== Bn && nb(Er, Bn, Co);
                }
              } else if (Er === Xp) {
                if (St.delete(Er), gS) {
                  var br = f_(Cr);
                  rn = me.getAttribute("style"), br !== rn && nb(Er, rn, br);
                }
              } else if (ht && !xr)
                St.delete(Er.toLowerCase()), rn = Ba(me, Er, Cr), Cr !== rn && nb(Er, rn, Cr);
              else if (!Lr(Er, Cn, ht) && !Qn(Er, Cr, Cn, ht)) {
                var Ar = !1;
                if (Cn !== null)
                  St.delete(Cn.attributeName), rn = _o(me, Er, Cr, Cn);
                else {
                  var gr = Ne;
                  if (gr === Al && (gr = im(we)), gr === Al)
                    St.delete(Er.toLowerCase());
                  else {
                    var qr = BO(Er);
                    qr !== null && qr !== Er && (Ar = !0, St.delete(qr)), St.delete(Er);
                  }
                  rn = Ba(me, Er, Cr);
                }
                var hn = xr;
                !hn && Cr !== rn && !Ar && nb(Er, rn, Cr);
              }
            }
          }
        }
      switch (tt && St.size > 0 && Ie[Bf] !== !0 && bS(St), we) {
        case "input":
          Mi(me), Fr(me, Ie, !0);
          break;
        case "textarea":
          Mi(me), Qb(me);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof Ie.onClick == "function" && v0(me);
          break;
      }
      return _r;
    }
    function UO(me, we, Ie) {
      var Ne = me.nodeValue !== we;
      return Ne;
    }
    function q_(me, we) {
      {
        if (Bu)
          return;
        Bu = !0, xe("Did not expect server HTML to contain a <%s> in <%s>.", we.nodeName.toLowerCase(), me.nodeName.toLowerCase());
      }
    }
    function W_(me, we) {
      {
        if (Bu)
          return;
        Bu = !0, xe('Did not expect server HTML to contain the text node "%s" in <%s>.', we.nodeValue, me.nodeName.toLowerCase());
      }
    }
    function Z_(me, we, Ie) {
      {
        if (Bu)
          return;
        Bu = !0, xe("Expected server HTML to contain a matching <%s> in <%s>.", we, me.nodeName.toLowerCase());
      }
    }
    function G_(me, we) {
      {
        if (we === "" || Bu)
          return;
        Bu = !0, xe('Expected server HTML to contain a matching text node for "%s" in <%s>.', we, me.nodeName.toLowerCase());
      }
    }
    function VO(me, we, Ie) {
      switch (we) {
        case "input":
          Or(me, Ie);
          return;
        case "textarea":
          Ky(me, Ie);
          return;
        case "select":
          a_(me, Ie);
          return;
      }
    }
    var ob = function() {
    }, ab = function() {
    };
    {
      var HO = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], xS = ["applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title"], qO = xS.concat(["button"]), WO = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], ES = { current: null, formTag: null, aTagInScope: null, buttonTagInScope: null, nobrTagInScope: null, pTagInButtonScope: null, listItemTagAutoclosing: null, dlItemTagAutoclosing: null };
      ab = function(me, we) {
        var Ie = oo({}, me || ES), Ne = { tag: we };
        return xS.indexOf(we) !== -1 && (Ie.aTagInScope = null, Ie.buttonTagInScope = null, Ie.nobrTagInScope = null), qO.indexOf(we) !== -1 && (Ie.pTagInButtonScope = null), HO.indexOf(we) !== -1 && we !== "address" && we !== "div" && we !== "p" && (Ie.listItemTagAutoclosing = null, Ie.dlItemTagAutoclosing = null), Ie.current = Ne, we === "form" && (Ie.formTag = Ne), we === "a" && (Ie.aTagInScope = Ne), we === "button" && (Ie.buttonTagInScope = Ne), we === "nobr" && (Ie.nobrTagInScope = Ne), we === "p" && (Ie.pTagInButtonScope = Ne), we === "li" && (Ie.listItemTagAutoclosing = Ne), (we === "dd" || we === "dt") && (Ie.dlItemTagAutoclosing = Ne), Ie;
      };
      var ZO = function(me, we) {
        switch (we) {
          case "select":
            return me === "option" || me === "optgroup" || me === "#text";
          case "optgroup":
            return me === "option" || me === "#text";
          case "option":
            return me === "#text";
          case "tr":
            return me === "th" || me === "td" || me === "style" || me === "script" || me === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return me === "tr" || me === "style" || me === "script" || me === "template";
          case "colgroup":
            return me === "col" || me === "template";
          case "table":
            return me === "caption" || me === "colgroup" || me === "tbody" || me === "tfoot" || me === "thead" || me === "style" || me === "script" || me === "template";
          case "head":
            return me === "base" || me === "basefont" || me === "bgsound" || me === "link" || me === "meta" || me === "title" || me === "noscript" || me === "noframes" || me === "style" || me === "script" || me === "template";
          case "html":
            return me === "head" || me === "body" || me === "frameset";
          case "frameset":
            return me === "frame";
          case "#document":
            return me === "html";
        }
        switch (me) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return we !== "h1" && we !== "h2" && we !== "h3" && we !== "h4" && we !== "h5" && we !== "h6";
          case "rp":
          case "rt":
            return WO.indexOf(we) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return we == null;
        }
        return !0;
      }, GO = function(me, we) {
        switch (me) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return we.pTagInButtonScope;
          case "form":
            return we.formTag || we.pTagInButtonScope;
          case "li":
            return we.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return we.dlItemTagAutoclosing;
          case "button":
            return we.buttonTagInScope;
          case "a":
            return we.aTagInScope;
          case "nobr":
            return we.nobrTagInScope;
        }
        return null;
      }, SS = {};
      ob = function(me, we, Ie) {
        Ie = Ie || ES;
        var Ne = Ie.current, De = Ne && Ne.tag;
        we != null && (me != null && xe("validateDOMNesting: when childText is passed, childTag should be null"), me = "#text");
        var Ze = ZO(me, De) ? null : Ne, tt = Ze ? null : GO(me, Ie), ht = Ze || tt;
        if (ht) {
          var St = ht.tag, Nt = !!Ze + "|" + me + "|" + St;
          if (!SS[Nt]) {
            SS[Nt] = !0;
            var Bt = me, lr = "";
            if (me === "#text" ? /\S/.test(we) ? Bt = "Text nodes" : (Bt = "Whitespace text nodes", lr = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Bt = "<" + me + ">", Ze) {
              var nr = "";
              St === "table" && me === "tr" && (nr += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), xe("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Bt, St, lr, nr);
            } else
              xe("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Bt, St);
          }
        }
      };
    }
    var b0 = "suppressHydrationWarning", g0 = "$", w0 = "/$", ib = "$?", sb = "$!", YO = "style", Y_ = null, Q_ = null;
    function QO(me) {
      var we, Ie, Ne = me.nodeType;
      switch (Ne) {
        case Zu:
        case id: {
          we = Ne === Zu ? "#document" : "#fragment";
          var De = me.documentElement;
          Ie = De ? De.namespaceURI : Jy(null, "");
          break;
        }
        default: {
          var Ze = Ne === ei ? me.parentNode : me, tt = Ze.namespaceURI || null;
          we = Ze.tagName, Ie = Jy(tt, we);
          break;
        }
      }
      {
        var ht = we.toLowerCase(), St = ab(null, ht);
        return { namespace: Ie, ancestorInfo: St };
      }
    }
    function KO(me, we, Ie) {
      {
        var Ne = me, De = Jy(Ne.namespace, we), Ze = ab(Ne.ancestorInfo, we);
        return { namespace: De, ancestorInfo: Ze };
      }
    }
    function XO(me) {
      Y_ = Li(), Q_ = fO();
      var we = null;
      return Ua(!1), we;
    }
    function JO(me) {
      pO(Q_), Ua(Y_), Y_ = null, Q_ = null;
    }
    function eA(me, we, Ie, Ne, De) {
      var Ze;
      {
        var tt = Ne;
        if (ob(me, null, tt.ancestorInfo), typeof we.children == "string" || typeof we.children == "number") {
          var ht = "" + we.children, St = ab(tt.ancestorInfo, me);
          ob(null, ht, St);
        }
        Ze = tt.namespace;
      }
      var Nt = NO(me, we, Ie, Ze);
      return cb(De, Nt), o1(Nt, we), Nt;
    }
    function sA(me, we) {
      me.appendChild(we);
    }
    function uA(me, we, Ie, Ne, De) {
      switch (FO(me, we, Ie, Ne), we) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!Ie.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function lA(me, we, Ie, Ne, De, Ze) {
      {
        var tt = Ze;
        if (typeof Ne.children != typeof Ie.children && (typeof Ne.children == "string" || typeof Ne.children == "number")) {
          var ht = "" + Ne.children, St = ab(tt.ancestorInfo, we);
          ob(null, ht, St);
        }
      }
      return LO(me, we, Ie, Ne);
    }
    function K_(me, we) {
      return me === "textarea" || me === "noscript" || typeof we.children == "string" || typeof we.children == "number" || typeof we.dangerouslySetInnerHTML == "object" && we.dangerouslySetInnerHTML !== null && we.dangerouslySetInnerHTML.__html != null;
    }
    function yA(me, we, Ie, Ne) {
      {
        var De = Ie;
        ob(null, me, De.ancestorInfo);
      }
      var Ze = jO(me, we);
      return cb(Ne, Ze), Ze;
    }
    function _A() {
      var me = window.event;
      return me === void 0 ? ji : If(me.type);
    }
    var X_ = typeof setTimeout == "function" ? setTimeout : void 0, OA = typeof clearTimeout == "function" ? clearTimeout : void 0, J_ = -1, PS = typeof Promise == "function" ? Promise : void 0, $A = typeof queueMicrotask == "function" ? queueMicrotask : typeof PS < "u" ? function(me) {
      return PS.resolve(null).then(me).catch(RA);
    } : X_;
    function RA(me) {
      setTimeout(function() {
        throw me;
      });
    }
    function BA(me, we, Ie, Ne) {
      switch (we) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          Ie.autoFocus && me.focus();
          return;
        case "img": {
          Ie.src && (me.src = Ie.src);
          return;
        }
      }
    }
    function qA(me, we, Ie, Ne, De, Ze) {
      DO(me, we, Ie, Ne, De), o1(me, De);
    }
    function kS(me) {
      um(me, "");
    }
    function eC(me, we, Ie) {
      me.nodeValue = Ie;
    }
    function tC(me, we) {
      me.appendChild(we);
    }
    function rC(me, we) {
      var Ie;
      me.nodeType === ei ? (Ie = me.parentNode, Ie.insertBefore(we, me)) : (Ie = me, Ie.appendChild(we));
      var Ne = me._reactRootContainer;
      Ne == null && Ie.onclick === null && v0(Ie);
    }
    function nC(me, we, Ie) {
      me.insertBefore(we, Ie);
    }
    function oC(me, we, Ie) {
      me.nodeType === ei ? me.parentNode.insertBefore(we, Ie) : me.insertBefore(we, Ie);
    }
    function aC(me, we) {
      me.removeChild(we);
    }
    function iC(me, we) {
      me.nodeType === ei ? me.parentNode.removeChild(we) : me.removeChild(we);
    }
    function e1(me, we) {
      var Ie = we, Ne = 0;
      do {
        var De = Ie.nextSibling;
        if (me.removeChild(Ie), De && De.nodeType === ei) {
          var Ze = De.data;
          if (Ze === w0)
            if (Ne === 0) {
              me.removeChild(De), os(we);
              return;
            } else
              Ne--;
          else
            (Ze === g0 || Ze === ib || Ze === sb) && Ne++;
        }
        Ie = De;
      } while (Ie);
      os(we);
    }
    function sC(me, we) {
      me.nodeType === ei ? e1(me.parentNode, we) : me.nodeType === Ts && e1(me, we), os(me);
    }
    function uC(me) {
      me = me;
      var we = me.style;
      typeof we.setProperty == "function" ? we.setProperty("display", "none", "important") : we.display = "none";
    }
    function lC(me) {
      me.nodeValue = "";
    }
    function cC(me, we) {
      me = me;
      var Ie = we[YO], Ne = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
      me.style.display = lm("display", Ne);
    }
    function dC(me, we) {
      me.nodeValue = we;
    }
    function fC(me) {
      me.nodeType === Ts ? me.textContent = "" : me.nodeType === Zu && me.documentElement && me.removeChild(me.documentElement);
    }
    function pC(me, we, Ie) {
      return me.nodeType !== Ts || we.toLowerCase() !== me.nodeName.toLowerCase() ? null : me;
    }
    function hC(me, we) {
      return we === "" || me.nodeType !== Cl ? null : me;
    }
    function mC(me) {
      return me.nodeType !== ei ? null : me;
    }
    function OS(me) {
      return me.data === ib;
    }
    function t1(me) {
      return me.data === sb;
    }
    function yC(me) {
      var we = me.nextSibling && me.nextSibling.dataset, Ie, Ne, De;
      return we && (Ie = we.dgst, Ne = we.msg, De = we.stck), { message: Ne, digest: Ie, stack: De };
    }
    function vC(me, we) {
      me._reactRetry = we;
    }
    function _0(me) {
      for (; me != null; me = me.nextSibling) {
        var we = me.nodeType;
        if (we === Ts || we === Cl)
          break;
        if (we === ei) {
          var Ie = me.data;
          if (Ie === g0 || Ie === sb || Ie === ib)
            break;
          if (Ie === w0)
            return null;
        }
      }
      return me;
    }
    function ub(me) {
      return _0(me.nextSibling);
    }
    function bC(me) {
      return _0(me.firstChild);
    }
    function gC(me) {
      return _0(me.firstChild);
    }
    function wC(me) {
      return _0(me.nextSibling);
    }
    function _C(me, we, Ie, Ne, De, Ze, tt) {
      cb(Ze, me), o1(me, Ie);
      var ht;
      {
        var St = De;
        ht = St.namespace;
      }
      var Nt = (Ze.mode & $o) !== Ln;
      return zO(me, we, Ie, ht, Ne, Nt, tt);
    }
    function xC(me, we, Ie, Ne) {
      return cb(Ie, me), Ie.mode & $o, UO(me, we);
    }
    function EC(me, we) {
      cb(we, me);
    }
    function SC(me) {
      for (var we = me.nextSibling, Ie = 0; we; ) {
        if (we.nodeType === ei) {
          var Ne = we.data;
          if (Ne === w0) {
            if (Ie === 0)
              return ub(we);
            Ie--;
          } else
            (Ne === g0 || Ne === sb || Ne === ib) && Ie++;
        }
        we = we.nextSibling;
      }
      return null;
    }
    function CS(me) {
      for (var we = me.previousSibling, Ie = 0; we; ) {
        if (we.nodeType === ei) {
          var Ne = we.data;
          if (Ne === g0 || Ne === sb || Ne === ib) {
            if (Ie === 0)
              return we;
            Ie--;
          } else
            Ne === w0 && Ie++;
        }
        we = we.previousSibling;
      }
      return null;
    }
    function PC(me) {
      os(me);
    }
    function TC(me) {
      os(me);
    }
    function kC(me) {
      return me !== "head" && me !== "body";
    }
    function OC(me, we, Ie, Ne) {
      var De = !0;
      y0(we.nodeValue, Ie, Ne, De);
    }
    function AC(me, we, Ie, Ne, De, Ze) {
      if (we[b0] !== !0) {
        var tt = !0;
        y0(Ne.nodeValue, De, Ze, tt);
      }
    }
    function CC(me, we) {
      we.nodeType === Ts ? q_(me, we) : we.nodeType === ei || W_(me, we);
    }
    function $C(me, we) {
      {
        var Ie = me.parentNode;
        Ie !== null && (we.nodeType === Ts ? q_(Ie, we) : we.nodeType === ei || W_(Ie, we));
      }
    }
    function IC(me, we, Ie, Ne, De) {
      (De || we[b0] !== !0) && (Ne.nodeType === Ts ? q_(Ie, Ne) : Ne.nodeType === ei || W_(Ie, Ne));
    }
    function MC(me, we, Ie) {
      Z_(me, we);
    }
    function RC(me, we) {
      G_(me, we);
    }
    function NC(me, we, Ie) {
      {
        var Ne = me.parentNode;
        Ne !== null && Z_(Ne, we);
      }
    }
    function jC(me, we) {
      {
        var Ie = me.parentNode;
        Ie !== null && G_(Ie, we);
      }
    }
    function FC(me, we, Ie, Ne, De, Ze) {
      (Ze || we[b0] !== !0) && Z_(Ie, Ne);
    }
    function LC(me, we, Ie, Ne, De) {
      (De || we[b0] !== !0) && G_(Ie, Ne);
    }
    function DC(me) {
      xe("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", me.nodeName.toLowerCase());
    }
    function BC(me) {
      eb(me);
    }
    var xy = Math.random().toString(36).slice(2), Ey = "__reactFiber$" + xy, r1 = "__reactProps$" + xy, lb = "__reactContainer$" + xy, n1 = "__reactEvents$" + xy, zC = "__reactListeners$" + xy, UC = "__reactHandles$" + xy;
    function VC(me) {
      delete me[Ey], delete me[r1], delete me[n1], delete me[zC], delete me[UC];
    }
    function cb(me, we) {
      we[Ey] = me;
    }
    function x0(me, we) {
      we[lb] = me;
    }
    function $S(me) {
      me[lb] = null;
    }
    function db(me) {
      return !!me[lb];
    }
    function Jp(me) {
      var we = me[Ey];
      if (we)
        return we;
      for (var Ie = me.parentNode; Ie; ) {
        if (we = Ie[lb] || Ie[Ey], we) {
          var Ne = we.alternate;
          if (we.child !== null || Ne !== null && Ne.child !== null)
            for (var De = CS(me); De !== null; ) {
              var Ze = De[Ey];
              if (Ze)
                return Ze;
              De = CS(De);
            }
          return we;
        }
        me = Ie, Ie = me.parentNode;
      }
      return null;
    }
    function zf(me) {
      var we = me[Ey] || me[lb];
      return we && (we.tag === ze || we.tag === He || we.tag === It || we.tag === je) ? we : null;
    }
    function Sy(me) {
      if (me.tag === ze || me.tag === He)
        return me.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function E0(me) {
      return me[r1] || null;
    }
    function o1(me, we) {
      me[r1] = we;
    }
    function HC(me) {
      var we = me[n1];
      return we === void 0 && (we = me[n1] = /* @__PURE__ */ new Set()), we;
    }
    var IS = {}, MS = fe.ReactDebugCurrentFrame;
    function S0(me) {
      if (me) {
        var we = me._owner, Ie = qs(me.type, me._source, we ? we.type : null);
        MS.setExtraStackFrame(Ie);
      } else
        MS.setExtraStackFrame(null);
    }
    function Xl(me, we, Ie, Ne, De) {
      {
        var Ze = Function.call.bind(Yn);
        for (var tt in me)
          if (Ze(me, tt)) {
            var ht = void 0;
            try {
              if (typeof me[tt] != "function") {
                var St = Error((Ne || "React class") + ": " + Ie + " type `" + tt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof me[tt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw St.name = "Invariant Violation", St;
              }
              ht = me[tt](we, tt, Ne, Ie, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Nt) {
              ht = Nt;
            }
            ht && !(ht instanceof Error) && (S0(De), xe("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ne || "React class", Ie, tt, typeof ht), S0(null)), ht instanceof Error && !(ht.message in IS) && (IS[ht.message] = !0, S0(De), xe("Failed %s type: %s", Ie, ht.message), S0(null));
          }
      }
    }
    var a1 = [], O0;
    O0 = [];
    var Wd = -1;
    function Uf(me) {
      return { current: me };
    }
    function Fs(me, we) {
      if (Wd < 0) {
        xe("Unexpected pop.");
        return;
      }
      we !== O0[Wd] && xe("Unexpected Fiber popped."), me.current = a1[Wd], a1[Wd] = null, O0[Wd] = null, Wd--;
    }
    function Ls(me, we, Ie) {
      Wd++, a1[Wd] = me.current, O0[Wd] = Ie, me.current = we;
    }
    var i1;
    i1 = {};
    var Ju = {};
    Object.freeze(Ju);
    var Zd = Uf(Ju), Gc = Uf(!1), s1 = Ju;
    function Py(me, we, Ie) {
      return Ie && Yc(we) ? s1 : Zd.current;
    }
    function RS(me, we, Ie) {
      {
        var Ne = me.stateNode;
        Ne.__reactInternalMemoizedUnmaskedChildContext = we, Ne.__reactInternalMemoizedMaskedChildContext = Ie;
      }
    }
    function Ty(me, we) {
      {
        var Ie = me.type, Ne = Ie.contextTypes;
        if (!Ne)
          return Ju;
        var De = me.stateNode;
        if (De && De.__reactInternalMemoizedUnmaskedChildContext === we)
          return De.__reactInternalMemoizedMaskedChildContext;
        var Ze = {};
        for (var tt in Ne)
          Ze[tt] = we[tt];
        {
          var ht = Gn(me) || "Unknown";
          Xl(Ne, Ze, "context", ht);
        }
        return De && RS(me, we, Ze), Ze;
      }
    }
    function C0() {
      return Gc.current;
    }
    function Yc(me) {
      {
        var we = me.childContextTypes;
        return we != null;
      }
    }
    function $0(me) {
      Fs(Gc, me), Fs(Zd, me);
    }
    function u1(me) {
      Fs(Gc, me), Fs(Zd, me);
    }
    function NS(me, we, Ie) {
      {
        if (Zd.current !== Ju)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Ls(Zd, we, me), Ls(Gc, Ie, me);
      }
    }
    function jS(me, we, Ie) {
      {
        var Ne = me.stateNode, De = we.childContextTypes;
        if (typeof Ne.getChildContext != "function") {
          {
            var Ze = Gn(me) || "Unknown";
            i1[Ze] || (i1[Ze] = !0, xe("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", Ze, Ze));
          }
          return Ie;
        }
        var tt = Ne.getChildContext();
        for (var ht in tt)
          if (!(ht in De))
            throw new Error((Gn(me) || "Unknown") + '.getChildContext(): key "' + ht + '" is not defined in childContextTypes.');
        {
          var St = Gn(me) || "Unknown";
          Xl(De, tt, "child context", St);
        }
        return oo({}, Ie, tt);
      }
    }
    function I0(me) {
      {
        var we = me.stateNode, Ie = we && we.__reactInternalMemoizedMergedChildContext || Ju;
        return s1 = Zd.current, Ls(Zd, Ie, me), Ls(Gc, Gc.current, me), !0;
      }
    }
    function FS(me, we, Ie) {
      {
        var Ne = me.stateNode;
        if (!Ne)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (Ie) {
          var De = jS(me, we, s1);
          Ne.__reactInternalMemoizedMergedChildContext = De, Fs(Gc, me), Fs(Zd, me), Ls(Zd, De, me), Ls(Gc, Ie, me);
        } else
          Fs(Gc, me), Ls(Gc, Ie, me);
      }
    }
    function qC(me) {
      {
        if (!gv(me) || me.tag !== Me)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var we = me;
        do {
          switch (we.tag) {
            case je:
              return we.stateNode.context;
            case Me: {
              var Ie = we.type;
              if (Yc(Ie))
                return we.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          we = we.return;
        } while (we !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Vf = 0, R0 = 1, Gd = null, l1 = !1, c1 = !1;
    function LS(me) {
      Gd === null ? Gd = [me] : Gd.push(me);
    }
    function WC(me) {
      l1 = !0, LS(me);
    }
    function DS() {
      l1 && Hf();
    }
    function Hf() {
      if (!c1 && Gd !== null) {
        c1 = !0;
        var me = 0, we = eu();
        try {
          var Ie = !0, Ne = Gd;
          for (fi(Ns); me < Ne.length; me++) {
            var De = Ne[me];
            do
              De = De(Ie);
            while (De !== null);
          }
          Gd = null, l1 = !1;
        } catch (Ze) {
          throw Gd !== null && (Gd = Gd.slice(me + 1)), _m(Em, Hf), Ze;
        } finally {
          fi(we), c1 = !1;
        }
      }
      return null;
    }
    var ky = [], Oy = 0, D0 = null, B0 = 0, ml = [], yl = 0, oh = null, Yd = 1, Xd = "";
    function ZC(me) {
      return fh(), (me.flags & yv) !== Nn;
    }
    function GC(me) {
      return fh(), B0;
    }
    function YC() {
      var me = Xd, we = Yd, Ie = we & ~QC(we);
      return Ie.toString(32) + me;
    }
    function ch(me, we) {
      fh(), ky[Oy++] = B0, ky[Oy++] = D0, D0 = me, B0 = we;
    }
    function BS(me, we, Ie) {
      fh(), ml[yl++] = Yd, ml[yl++] = Xd, ml[yl++] = oh, oh = me;
      var Ne = Yd, De = Xd, Ze = V0(Ne) - 1, tt = Ne & ~(1 << Ze), ht = Ie + 1, St = V0(we) + Ze;
      if (St > 30) {
        var Nt = Ze - Ze % 5, Bt = (1 << Nt) - 1, lr = (tt & Bt).toString(32), nr = tt >> Nt, _r = Ze - Nt, Er = V0(we) + _r, Cr = ht << _r, rn = Cr | nr, Cn = lr + De;
        Yd = 1 << Er | rn, Xd = Cn;
      } else {
        var Bn = ht << Ze, Ro = Bn | tt, Co = De;
        Yd = 1 << St | Ro, Xd = Co;
      }
    }
    function d1(me) {
      fh();
      var we = me.return;
      if (we !== null) {
        var Ie = 1, Ne = 0;
        ch(me, Ie), BS(me, Ie, Ne);
      }
    }
    function V0(me) {
      return 32 - Am(me);
    }
    function QC(me) {
      return 1 << V0(me) - 1;
    }
    function f1(me) {
      for (; me === D0; )
        D0 = ky[--Oy], ky[Oy] = null, B0 = ky[--Oy], ky[Oy] = null;
      for (; me === oh; )
        oh = ml[--yl], ml[yl] = null, Xd = ml[--yl], ml[yl] = null, Yd = ml[--yl], ml[yl] = null;
    }
    function KC() {
      return fh(), oh !== null ? { id: Yd, overflow: Xd } : null;
    }
    function XC(me, we) {
      fh(), ml[yl++] = Yd, ml[yl++] = Xd, ml[yl++] = oh, Yd = we.id, Xd = we.overflow, oh = me;
    }
    function fh() {
      ls() || xe("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var us = null, vl = null, Jl = !1, Zh = !1, qf = null;
    function JC() {
      Jl && xe("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function US() {
      Zh = !0;
    }
    function x$() {
      return Zh;
    }
    function W$(me) {
      var we = me.stateNode.containerInfo;
      return vl = gC(we), us = me, Jl = !0, qf = null, Zh = !1, !0;
    }
    function Z$(me, we, Ie) {
      return vl = wC(we), us = me, Jl = !0, qf = null, Zh = !1, Ie !== null && XC(me, Ie), !0;
    }
    function VS(me, we) {
      switch (me.tag) {
        case je: {
          CC(me.stateNode.containerInfo, we);
          break;
        }
        case ze: {
          var Ie = (me.mode & $o) !== Ln;
          IC(me.type, me.memoizedProps, me.stateNode, we, Ie);
          break;
        }
        case It: {
          var Ne = me.memoizedState;
          Ne.dehydrated !== null && $C(Ne.dehydrated, we);
          break;
        }
      }
    }
    function HS(me, we) {
      VS(me, we);
      var Ie = vN();
      Ie.stateNode = we, Ie.return = me;
      var Ne = me.deletions;
      Ne === null ? (me.deletions = [Ie], me.flags |= Xo) : Ne.push(Ie);
    }
    function p1(me, we) {
      {
        if (Zh)
          return;
        switch (me.tag) {
          case je: {
            var Ie = me.stateNode.containerInfo;
            switch (we.tag) {
              case ze:
                var Ne = we.type;
                we.pendingProps, MC(Ie, Ne);
                break;
              case He:
                var De = we.pendingProps;
                RC(Ie, De);
                break;
            }
            break;
          }
          case ze: {
            var Ze = me.type, tt = me.memoizedProps, ht = me.stateNode;
            switch (we.tag) {
              case ze: {
                var St = we.type, Nt = we.pendingProps, Bt = (me.mode & $o) !== Ln;
                FC(Ze, tt, ht, St, Nt, Bt);
                break;
              }
              case He: {
                var lr = we.pendingProps, nr = (me.mode & $o) !== Ln;
                LC(Ze, tt, ht, lr, nr);
                break;
              }
            }
            break;
          }
          case It: {
            var _r = me.memoizedState, Er = _r.dehydrated;
            if (Er !== null)
              switch (we.tag) {
                case ze:
                  var Cr = we.type;
                  we.pendingProps, NC(Er, Cr);
                  break;
                case He:
                  var rn = we.pendingProps;
                  jC(Er, rn);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function ZS(me, we) {
      we.flags = we.flags & ~vu | xa, p1(me, we);
    }
    function YS(me, we) {
      switch (me.tag) {
        case ze: {
          var Ie = me.type;
          me.pendingProps;
          var Ne = pC(we, Ie);
          return Ne !== null ? (me.stateNode = Ne, us = me, vl = bC(Ne), !0) : !1;
        }
        case He: {
          var De = me.pendingProps, Ze = hC(we, De);
          return Ze !== null ? (me.stateNode = Ze, us = me, vl = null, !0) : !1;
        }
        case It: {
          var tt = mC(we);
          if (tt !== null) {
            var ht = { dehydrated: tt, treeContext: KC(), retryLane: Ms };
            me.memoizedState = ht;
            var St = bN(tt);
            return St.return = me, me.child = St, us = me, vl = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function h1(me) {
      return (me.mode & $o) !== Ln && (me.flags & Jn) === Nn;
    }
    function m1(me) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function y1(me) {
      if (Jl) {
        var we = vl;
        if (!we) {
          h1(me) && (p1(us, me), m1()), ZS(us, me), Jl = !1, us = me;
          return;
        }
        var Ie = we;
        if (!YS(me, we)) {
          h1(me) && (p1(us, me), m1()), we = ub(Ie);
          var Ne = us;
          if (!we || !YS(me, we)) {
            ZS(us, me), Jl = !1, us = me;
            return;
          }
          HS(Ne, Ie);
        }
      }
    }
    function G$(me, we, Ie) {
      var Ne = me.stateNode, De = !Zh, Ze = _C(Ne, me.type, me.memoizedProps, we, Ie, me, De);
      return me.updateQueue = Ze, Ze !== null;
    }
    function Y$(me) {
      var we = me.stateNode, Ie = me.memoizedProps, Ne = xC(we, Ie, me);
      if (Ne) {
        var De = us;
        if (De !== null)
          switch (De.tag) {
            case je: {
              var Ze = De.stateNode.containerInfo, tt = (De.mode & $o) !== Ln;
              OC(Ze, we, Ie, tt);
              break;
            }
            case ze: {
              var ht = De.type, St = De.memoizedProps, Nt = De.stateNode, Bt = (De.mode & $o) !== Ln;
              AC(ht, St, Nt, we, Ie, Bt);
              break;
            }
          }
      }
      return Ne;
    }
    function Q$(me) {
      var we = me.memoizedState, Ie = we !== null ? we.dehydrated : null;
      if (!Ie)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      EC(Ie, me);
    }
    function K$(me) {
      var we = me.memoizedState, Ie = we !== null ? we.dehydrated : null;
      if (!Ie)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return SC(Ie);
    }
    function QS(me) {
      for (var we = me.return; we !== null && we.tag !== ze && we.tag !== je && we.tag !== It; )
        we = we.return;
      us = we;
    }
    function H0(me) {
      if (me !== us)
        return !1;
      if (!Jl)
        return QS(me), Jl = !0, !1;
      if (me.tag !== je && (me.tag !== ze || kC(me.type) && !K_(me.type, me.memoizedProps))) {
        var we = vl;
        if (we)
          if (h1(me))
            KS(me), m1();
          else
            for (; we; )
              HS(me, we), we = ub(we);
      }
      return QS(me), me.tag === It ? vl = K$(me) : vl = us ? ub(me.stateNode) : null, !0;
    }
    function X$() {
      return Jl && vl !== null;
    }
    function KS(me) {
      for (var we = vl; we; )
        VS(me, we), we = ub(we);
    }
    function Ay() {
      us = null, vl = null, Jl = !1, Zh = !1;
    }
    function XS() {
      qf !== null && (c2(qf), qf = null);
    }
    function ls() {
      return Jl;
    }
    function v1(me) {
      qf === null ? qf = [me] : qf.push(me);
    }
    var J$ = fe.ReactCurrentBatchConfig, tI = null;
    function rI() {
      return J$.transition;
    }
    var ec = { recordUnsafeLifecycleWarnings: function(me, we) {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function(me, we) {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } };
    {
      var nI = function(me) {
        for (var we = null, Ie = me; Ie !== null; )
          Ie.mode & Ma && (we = Ie), Ie = Ie.return;
        return we;
      }, Gh = function(me) {
        var we = [];
        return me.forEach(function(Ie) {
          we.push(Ie);
        }), we.sort().join(", ");
      }, fb = [], pb = [], hb = [], mb = [], yb = [], vb = [], Qh = /* @__PURE__ */ new Set();
      ec.recordUnsafeLifecycleWarnings = function(me, we) {
        Qh.has(me.type) || (typeof we.componentWillMount == "function" && we.componentWillMount.__suppressDeprecationWarning !== !0 && fb.push(me), me.mode & Ma && typeof we.UNSAFE_componentWillMount == "function" && pb.push(me), typeof we.componentWillReceiveProps == "function" && we.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && hb.push(me), me.mode & Ma && typeof we.UNSAFE_componentWillReceiveProps == "function" && mb.push(me), typeof we.componentWillUpdate == "function" && we.componentWillUpdate.__suppressDeprecationWarning !== !0 && yb.push(me), me.mode & Ma && typeof we.UNSAFE_componentWillUpdate == "function" && vb.push(me));
      }, ec.flushPendingUnsafeLifecycleWarnings = function() {
        var me = /* @__PURE__ */ new Set();
        fb.length > 0 && (fb.forEach(function(nr) {
          me.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), fb = []);
        var we = /* @__PURE__ */ new Set();
        pb.length > 0 && (pb.forEach(function(nr) {
          we.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), pb = []);
        var Ie = /* @__PURE__ */ new Set();
        hb.length > 0 && (hb.forEach(function(nr) {
          Ie.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), hb = []);
        var Ne = /* @__PURE__ */ new Set();
        mb.length > 0 && (mb.forEach(function(nr) {
          Ne.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), mb = []);
        var De = /* @__PURE__ */ new Set();
        yb.length > 0 && (yb.forEach(function(nr) {
          De.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), yb = []);
        var Ze = /* @__PURE__ */ new Set();
        if (vb.length > 0 && (vb.forEach(function(nr) {
          Ze.add(Gn(nr) || "Component"), Qh.add(nr.type);
        }), vb = []), we.size > 0) {
          var tt = Gh(we);
          xe(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, tt);
        }
        if (Ne.size > 0) {
          var ht = Gh(Ne);
          xe(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, ht);
        }
        if (Ze.size > 0) {
          var St = Gh(Ze);
          xe(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, St);
        }
        if (me.size > 0) {
          var Nt = Gh(me);
          _e(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Nt);
        }
        if (Ie.size > 0) {
          var Bt = Gh(Ie);
          _e(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Bt);
        }
        if (De.size > 0) {
          var lr = Gh(De);
          _e(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, lr);
        }
      };
      var q0 = /* @__PURE__ */ new Map(), PP = /* @__PURE__ */ new Set();
      ec.recordLegacyContextWarning = function(me, we) {
        var Ie = nI(me);
        if (Ie === null) {
          xe("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!PP.has(me.type)) {
          var Ne = q0.get(Ie);
          (me.type.contextTypes != null || me.type.childContextTypes != null || we !== null && typeof we.getChildContext == "function") && (Ne === void 0 && (Ne = [], q0.set(Ie, Ne)), Ne.push(me));
        }
      }, ec.flushLegacyContextWarning = function() {
        q0.forEach(function(me, we) {
          if (me.length !== 0) {
            var Ie = me[0], Ne = /* @__PURE__ */ new Set();
            me.forEach(function(Ze) {
              Ne.add(Gn(Ze) || "Component"), PP.add(Ze.type);
            });
            var De = Gh(Ne);
            try {
              Lo(Ie), xe(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, De);
            } finally {
              wa();
            }
          }
        });
      }, ec.discardPendingWarnings = function() {
        fb = [], pb = [], hb = [], mb = [], yb = [], vb = [], q0 = /* @__PURE__ */ new Map();
      };
    }
    function tc(me, we) {
      if (me && me.defaultProps) {
        var Ie = oo({}, we), Ne = me.defaultProps;
        for (var De in Ne)
          Ie[De] === void 0 && (Ie[De] = Ne[De]);
        return Ie;
      }
      return we;
    }
    var b1 = Uf(null), g1;
    g1 = {};
    var W0 = null, Cy = null, w1 = null, Z0 = !1;
    function Y0() {
      W0 = null, Cy = null, w1 = null, Z0 = !1;
    }
    function kP() {
      Z0 = !0;
    }
    function AP() {
      Z0 = !1;
    }
    function $P(me, we, Ie) {
      Ls(b1, we._currentValue, me), we._currentValue = Ie, we._currentRenderer !== void 0 && we._currentRenderer !== null && we._currentRenderer !== g1 && xe("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), we._currentRenderer = g1;
    }
    function _1(me, we) {
      var Ie = b1.current;
      Fs(b1, we), me._currentValue = Ie;
    }
    function x1(me, we, Ie) {
      for (var Ne = me; Ne !== null; ) {
        var De = Ne.alternate;
        if (Rd(Ne.childLanes, we) ? De !== null && !Rd(De.childLanes, we) && (De.childLanes = wo(De.childLanes, we)) : (Ne.childLanes = wo(Ne.childLanes, we), De !== null && (De.childLanes = wo(De.childLanes, we))), Ne === Ie)
          break;
        Ne = Ne.return;
      }
      Ne !== Ie && xe("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function oI(me, we, Ie) {
      aI(me, we, Ie);
    }
    function aI(me, we, Ie) {
      var Ne = me.child;
      for (Ne !== null && (Ne.return = me); Ne !== null; ) {
        var De = void 0, Ze = Ne.dependencies;
        if (Ze !== null) {
          De = Ne.child;
          for (var tt = Ze.firstContext; tt !== null; ) {
            if (tt.context === we) {
              if (Ne.tag === Me) {
                var ht = di(Ie), St = Jd(la, ht);
                St.tag = K0;
                var Nt = Ne.updateQueue;
                if (Nt !== null) {
                  var Bt = Nt.shared, lr = Bt.pending;
                  lr === null ? St.next = St : (St.next = lr.next, lr.next = St), Bt.pending = St;
                }
              }
              Ne.lanes = wo(Ne.lanes, Ie);
              var nr = Ne.alternate;
              nr !== null && (nr.lanes = wo(nr.lanes, Ie)), x1(Ne.return, Ie, me), Ze.lanes = wo(Ze.lanes, Ie);
              break;
            }
            tt = tt.next;
          }
        } else if (Ne.tag === dt)
          De = Ne.type === me.type ? null : Ne.child;
        else if (Ne.tag === er) {
          var _r = Ne.return;
          if (_r === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          _r.lanes = wo(_r.lanes, Ie);
          var Er = _r.alternate;
          Er !== null && (Er.lanes = wo(Er.lanes, Ie)), x1(_r, Ie, me), De = Ne.sibling;
        } else
          De = Ne.child;
        if (De !== null)
          De.return = Ne;
        else
          for (De = Ne; De !== null; ) {
            if (De === me) {
              De = null;
              break;
            }
            var Cr = De.sibling;
            if (Cr !== null) {
              Cr.return = De.return, De = Cr;
              break;
            }
            De = De.return;
          }
        Ne = De;
      }
    }
    function $y(me, we) {
      W0 = me, Cy = null, w1 = null;
      var Ie = me.dependencies;
      if (Ie !== null) {
        var Ne = Ie.firstContext;
        Ne !== null && (Rs(Ie.lanes, we) && $b(), Ie.firstContext = null);
      }
    }
    function Pi(me) {
      Z0 && xe("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var we = me._currentValue;
      if (w1 !== me) {
        var Ie = { context: me, memoizedValue: we, next: null };
        if (Cy === null) {
          if (W0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Cy = Ie, W0.dependencies = { lanes: Ir, firstContext: Ie };
        } else
          Cy = Cy.next = Ie;
      }
      return we;
    }
    var Kh = null;
    function E1(me) {
      Kh === null ? Kh = [me] : Kh.push(me);
    }
    function iI() {
      if (Kh !== null) {
        for (var me = 0; me < Kh.length; me++) {
          var we = Kh[me], Ie = we.interleaved;
          if (Ie !== null) {
            we.interleaved = null;
            var Ne = Ie.next, De = we.pending;
            if (De !== null) {
              var Ze = De.next;
              De.next = Ne, Ie.next = Ze;
            }
            we.pending = Ie;
          }
        }
        Kh = null;
      }
    }
    function IP(me, we, Ie, Ne) {
      var De = we.interleaved;
      return De === null ? (Ie.next = Ie, E1(we)) : (Ie.next = De.next, De.next = Ie), we.interleaved = Ie, Q0(me, Ne);
    }
    function sI(me, we, Ie, Ne) {
      var De = we.interleaved;
      De === null ? (Ie.next = Ie, E1(we)) : (Ie.next = De.next, De.next = Ie), we.interleaved = Ie;
    }
    function uI(me, we, Ie, Ne) {
      var De = we.interleaved;
      return De === null ? (Ie.next = Ie, E1(we)) : (Ie.next = De.next, De.next = Ie), we.interleaved = Ie, Q0(me, Ne);
    }
    function zu(me, we) {
      return Q0(me, we);
    }
    var lI = Q0;
    function Q0(me, we) {
      me.lanes = wo(me.lanes, we);
      var Ie = me.alternate;
      Ie !== null && (Ie.lanes = wo(Ie.lanes, we)), Ie === null && (me.flags & (xa | vu)) !== Nn && x2(me);
      for (var Ne = me, De = me.return; De !== null; )
        De.childLanes = wo(De.childLanes, we), Ie = De.alternate, Ie !== null ? Ie.childLanes = wo(Ie.childLanes, we) : (De.flags & (xa | vu)) !== Nn && x2(me), Ne = De, De = De.return;
      if (Ne.tag === je) {
        var Ze = Ne.stateNode;
        return Ze;
      } else
        return null;
    }
    var MP = 0, NP = 1, K0 = 2, S1 = 3, X0 = !1, P1, J0;
    P1 = !1, J0 = null;
    function T1(me) {
      var we = { baseState: me.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: Ir }, effects: null };
      me.updateQueue = we;
    }
    function jP(me, we) {
      var Ie = we.updateQueue, Ne = me.updateQueue;
      if (Ie === Ne) {
        var De = { baseState: Ne.baseState, firstBaseUpdate: Ne.firstBaseUpdate, lastBaseUpdate: Ne.lastBaseUpdate, shared: Ne.shared, effects: Ne.effects };
        we.updateQueue = De;
      }
    }
    function Jd(me, we) {
      var Ie = { eventTime: me, lane: we, tag: MP, payload: null, callback: null, next: null };
      return Ie;
    }
    function Wf(me, we, Ie) {
      var Ne = me.updateQueue;
      if (Ne === null)
        return null;
      var De = Ne.shared;
      if (J0 === De && !P1 && (xe("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), P1 = !0), kR()) {
        var Ze = De.pending;
        return Ze === null ? we.next = we : (we.next = Ze.next, Ze.next = we), De.pending = we, lI(me, Ie);
      } else
        return uI(me, De, we, Ie);
    }
    function ew(me, we, Ie) {
      var Ne = we.updateQueue;
      if (Ne !== null) {
        var De = Ne.shared;
        if (Iv(Ie)) {
          var Ze = De.lanes;
          Ze = Rv(Ze, me.pendingLanes);
          var tt = wo(Ze, Ie);
          De.lanes = tt, jp(me, tt);
        }
      }
    }
    function k1(me, we) {
      var Ie = me.updateQueue, Ne = me.alternate;
      if (Ne !== null) {
        var De = Ne.updateQueue;
        if (Ie === De) {
          var Ze = null, tt = null, ht = Ie.firstBaseUpdate;
          if (ht !== null) {
            var St = ht;
            do {
              var Nt = { eventTime: St.eventTime, lane: St.lane, tag: St.tag, payload: St.payload, callback: St.callback, next: null };
              tt === null ? Ze = tt = Nt : (tt.next = Nt, tt = Nt), St = St.next;
            } while (St !== null);
            tt === null ? Ze = tt = we : (tt.next = we, tt = we);
          } else
            Ze = tt = we;
          Ie = { baseState: De.baseState, firstBaseUpdate: Ze, lastBaseUpdate: tt, shared: De.shared, effects: De.effects }, me.updateQueue = Ie;
          return;
        }
      }
      var Bt = Ie.lastBaseUpdate;
      Bt === null ? Ie.firstBaseUpdate = we : Bt.next = we, Ie.lastBaseUpdate = we;
    }
    function cI(me, we, Ie, Ne, De, Ze) {
      switch (Ie.tag) {
        case NP: {
          var tt = Ie.payload;
          if (typeof tt == "function") {
            kP();
            var ht = tt.call(Ze, Ne, De);
            {
              if (me.mode & Ma) {
                ci(!0);
                try {
                  tt.call(Ze, Ne, De);
                } finally {
                  ci(!1);
                }
              }
              AP();
            }
            return ht;
          }
          return tt;
        }
        case S1:
          me.flags = me.flags & ~xi | Jn;
        case MP: {
          var St = Ie.payload, Nt;
          if (typeof St == "function") {
            kP(), Nt = St.call(Ze, Ne, De);
            {
              if (me.mode & Ma) {
                ci(!0);
                try {
                  St.call(Ze, Ne, De);
                } finally {
                  ci(!1);
                }
              }
              AP();
            }
          } else
            Nt = St;
          return Nt == null ? Ne : oo({}, Ne, Nt);
        }
        case K0:
          return X0 = !0, Ne;
      }
      return Ne;
    }
    function tw(me, we, Ie, Ne) {
      var De = me.updateQueue;
      X0 = !1, J0 = De.shared;
      var Ze = De.firstBaseUpdate, tt = De.lastBaseUpdate, ht = De.shared.pending;
      if (ht !== null) {
        De.shared.pending = null;
        var St = ht, Nt = St.next;
        St.next = null, tt === null ? Ze = Nt : tt.next = Nt, tt = St;
        var Bt = me.alternate;
        if (Bt !== null) {
          var lr = Bt.updateQueue, nr = lr.lastBaseUpdate;
          nr !== tt && (nr === null ? lr.firstBaseUpdate = Nt : nr.next = Nt, lr.lastBaseUpdate = St);
        }
      }
      if (Ze !== null) {
        var _r = De.baseState, Er = Ir, Cr = null, rn = null, Cn = null, Bn = Ze;
        do {
          var Ro = Bn.lane, Co = Bn.eventTime;
          if (Rd(Ne, Ro)) {
            if (Cn !== null) {
              var br = { eventTime: Co, lane: Uo, tag: Bn.tag, payload: Bn.payload, callback: Bn.callback, next: null };
              Cn = Cn.next = br;
            }
            _r = cI(me, De, Bn, _r, we, Ie);
            var Ar = Bn.callback;
            if (Ar !== null && Bn.lane !== Uo) {
              me.flags |= cl;
              var gr = De.effects;
              gr === null ? De.effects = [Bn] : gr.push(Bn);
            }
          } else {
            var qr = { eventTime: Co, lane: Ro, tag: Bn.tag, payload: Bn.payload, callback: Bn.callback, next: null };
            Cn === null ? (rn = Cn = qr, Cr = _r) : Cn = Cn.next = qr, Er = wo(Er, Ro);
          }
          if (Bn = Bn.next, Bn === null) {
            if (ht = De.shared.pending, ht === null)
              break;
            var hn = ht, nn = hn.next;
            hn.next = null, Bn = nn, De.lastBaseUpdate = hn, De.shared.pending = null;
          }
        } while (!0);
        Cn === null && (Cr = _r), De.baseState = Cr, De.firstBaseUpdate = rn, De.lastBaseUpdate = Cn;
        var Kn = De.shared.interleaved;
        if (Kn !== null) {
          var yo = Kn;
          do
            Er = wo(Er, yo.lane), yo = yo.next;
          while (yo !== Kn);
        } else
          Ze === null && (De.shared.lanes = Ir);
        Ub(Er), me.lanes = Er, me.memoizedState = _r;
      }
      J0 = null;
    }
    function fI(me, we) {
      if (typeof me != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + me));
      me.call(we);
    }
    function FP() {
      X0 = !1;
    }
    function rw() {
      return X0;
    }
    function LP(me, we, Ie) {
      var Ne = we.effects;
      if (we.effects = null, Ne !== null)
        for (var De = 0; De < Ne.length; De++) {
          var Ze = Ne[De], tt = Ze.callback;
          tt !== null && (Ze.callback = null, fI(tt, Ie));
        }
    }
    var O1 = {}, DP = new oe.Component().refs, A1, C1, $1, I1, M1, BP, nw, R1, N1, j1;
    {
      A1 = /* @__PURE__ */ new Set(), C1 = /* @__PURE__ */ new Set(), $1 = /* @__PURE__ */ new Set(), I1 = /* @__PURE__ */ new Set(), R1 = /* @__PURE__ */ new Set(), M1 = /* @__PURE__ */ new Set(), N1 = /* @__PURE__ */ new Set(), j1 = /* @__PURE__ */ new Set();
      var zP = /* @__PURE__ */ new Set();
      nw = function(me, we) {
        if (!(me === null || typeof me == "function")) {
          var Ie = we + "_" + me;
          zP.has(Ie) || (zP.add(Ie), xe("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", we, me));
        }
      }, BP = function(me, we) {
        if (we === void 0) {
          var Ie = Fo(me) || "Component";
          M1.has(Ie) || (M1.add(Ie), xe("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", Ie));
        }
      }, Object.defineProperty(O1, "_processChildContext", { enumerable: !1, value: function() {
        throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
      } }), Object.freeze(O1);
    }
    function F1(me, we, Ie, Ne) {
      var De = me.memoizedState, Ze = Ie(Ne, De);
      {
        if (me.mode & Ma) {
          ci(!0);
          try {
            Ze = Ie(Ne, De);
          } finally {
            ci(!1);
          }
        }
        BP(we, Ze);
      }
      var tt = Ze == null ? De : oo({}, De, Ze);
      if (me.memoizedState = tt, me.lanes === Ir) {
        var ht = me.updateQueue;
        ht.baseState = tt;
      }
    }
    var L1 = { isMounted: Ks, enqueueSetState: function(me, we, Ie) {
      var Ne = mu(me), De = iu(), Ze = ep(Ne), tt = Jd(De, Ze);
      tt.payload = we, Ie != null && (nw(Ie, "setState"), tt.callback = Ie);
      var ht = Wf(Ne, tt, Ze);
      ht !== null && (Gi(ht, Ne, Ze, De), ew(ht, Ne, Ze)), jc(Ne, Ze);
    }, enqueueReplaceState: function(me, we, Ie) {
      var Ne = mu(me), De = iu(), Ze = ep(Ne), tt = Jd(De, Ze);
      tt.tag = NP, tt.payload = we, Ie != null && (nw(Ie, "replaceState"), tt.callback = Ie);
      var ht = Wf(Ne, tt, Ze);
      ht !== null && (Gi(ht, Ne, Ze, De), ew(ht, Ne, Ze)), jc(Ne, Ze);
    }, enqueueForceUpdate: function(me, we) {
      var Ie = mu(me), Ne = iu(), De = ep(Ie), Ze = Jd(Ne, De);
      Ze.tag = K0, we != null && (nw(we, "forceUpdate"), Ze.callback = we);
      var tt = Wf(Ie, Ze, De);
      tt !== null && (Gi(tt, Ie, De, Ne), ew(tt, Ie, De)), Ov(Ie, De);
    } };
    function UP(me, we, Ie, Ne, De, Ze, tt) {
      var ht = me.stateNode;
      if (typeof ht.shouldComponentUpdate == "function") {
        var St = ht.shouldComponentUpdate(Ne, Ze, tt);
        {
          if (me.mode & Ma) {
            ci(!0);
            try {
              St = ht.shouldComponentUpdate(Ne, Ze, tt);
            } finally {
              ci(!1);
            }
          }
          St === void 0 && xe("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Fo(we) || "Component");
        }
        return St;
      }
      return we.prototype && we.prototype.isPureReactComponent ? !Mn(Ie, Ne) || !Mn(De, Ze) : !0;
    }
    function pI(me, we, Ie) {
      var Ne = me.stateNode;
      {
        var De = Fo(we) || "Component", Ze = Ne.render;
        Ze || (we.prototype && typeof we.prototype.render == "function" ? xe("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", De) : xe("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", De)), Ne.getInitialState && !Ne.getInitialState.isReactClassApproved && !Ne.state && xe("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", De), Ne.getDefaultProps && !Ne.getDefaultProps.isReactClassApproved && xe("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", De), Ne.propTypes && xe("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", De), Ne.contextType && xe("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", De), Ne.contextTypes && xe("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", De), we.contextType && we.contextTypes && !N1.has(we) && (N1.add(we), xe("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", De)), typeof Ne.componentShouldUpdate == "function" && xe("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", De), we.prototype && we.prototype.isPureReactComponent && typeof Ne.shouldComponentUpdate < "u" && xe("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Fo(we) || "A pure component"), typeof Ne.componentDidUnmount == "function" && xe("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", De), typeof Ne.componentDidReceiveProps == "function" && xe("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", De), typeof Ne.componentWillRecieveProps == "function" && xe("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", De), typeof Ne.UNSAFE_componentWillRecieveProps == "function" && xe("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", De);
        var tt = Ne.props !== Ie;
        Ne.props !== void 0 && tt && xe("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", De, De), Ne.defaultProps && xe("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", De, De), typeof Ne.getSnapshotBeforeUpdate == "function" && typeof Ne.componentDidUpdate != "function" && !$1.has(we) && ($1.add(we), xe("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Fo(we))), typeof Ne.getDerivedStateFromProps == "function" && xe("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", De), typeof Ne.getDerivedStateFromError == "function" && xe("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", De), typeof we.getSnapshotBeforeUpdate == "function" && xe("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", De);
        var ht = Ne.state;
        ht && (typeof ht != "object" || oa(ht)) && xe("%s.state: must be set to an object or null", De), typeof Ne.getChildContext == "function" && typeof we.childContextTypes != "object" && xe("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", De);
      }
    }
    function VP(me, we) {
      we.updater = L1, me.stateNode = we, bf(we, me), we._reactInternalInstance = O1;
    }
    function HP(me, we, Ie) {
      var Ne = !1, De = Ju, Ze = Ju, tt = we.contextType;
      if ("contextType" in we) {
        var ht = tt === null || tt !== void 0 && tt.$$typeof === Tr && tt._context === void 0;
        if (!ht && !j1.has(we)) {
          j1.add(we);
          var St = "";
          tt === void 0 ? St = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof tt != "object" ? St = " However, it is set to a " + typeof tt + "." : tt.$$typeof === kr ? St = " Did you accidentally pass the Context.Provider instead?" : tt._context !== void 0 ? St = " Did you accidentally pass the Context.Consumer instead?" : St = " However, it is set to an object with keys {" + Object.keys(tt).join(", ") + "}.", xe("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Fo(we) || "Component", St);
        }
      }
      if (typeof tt == "object" && tt !== null)
        Ze = Pi(tt);
      else {
        De = Py(me, we, !0);
        var Nt = we.contextTypes;
        Ne = Nt != null, Ze = Ne ? Ty(me, De) : Ju;
      }
      var Bt = new we(Ie, Ze);
      if (me.mode & Ma) {
        ci(!0);
        try {
          Bt = new we(Ie, Ze);
        } finally {
          ci(!1);
        }
      }
      var lr = me.memoizedState = Bt.state !== null && Bt.state !== void 0 ? Bt.state : null;
      VP(me, Bt);
      {
        if (typeof we.getDerivedStateFromProps == "function" && lr === null) {
          var nr = Fo(we) || "Component";
          C1.has(nr) || (C1.add(nr), xe("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", nr, Bt.state === null ? "null" : "undefined", nr));
        }
        if (typeof we.getDerivedStateFromProps == "function" || typeof Bt.getSnapshotBeforeUpdate == "function") {
          var _r = null, Er = null, Cr = null;
          if (typeof Bt.componentWillMount == "function" && Bt.componentWillMount.__suppressDeprecationWarning !== !0 ? _r = "componentWillMount" : typeof Bt.UNSAFE_componentWillMount == "function" && (_r = "UNSAFE_componentWillMount"), typeof Bt.componentWillReceiveProps == "function" && Bt.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Er = "componentWillReceiveProps" : typeof Bt.UNSAFE_componentWillReceiveProps == "function" && (Er = "UNSAFE_componentWillReceiveProps"), typeof Bt.componentWillUpdate == "function" && Bt.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Cr = "componentWillUpdate" : typeof Bt.UNSAFE_componentWillUpdate == "function" && (Cr = "UNSAFE_componentWillUpdate"), _r !== null || Er !== null || Cr !== null) {
            var rn = Fo(we) || "Component", Cn = typeof we.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            I1.has(rn) || (I1.add(rn), xe(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, rn, Cn, _r !== null ? `
  ` + _r : "", Er !== null ? `
  ` + Er : "", Cr !== null ? `
  ` + Cr : ""));
          }
        }
      }
      return Ne && RS(me, De, Ze), Bt;
    }
    function mI(me, we) {
      var Ie = we.state;
      typeof we.componentWillMount == "function" && we.componentWillMount(), typeof we.UNSAFE_componentWillMount == "function" && we.UNSAFE_componentWillMount(), Ie !== we.state && (xe("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Gn(me) || "Component"), L1.enqueueReplaceState(we, we.state, null));
    }
    function qP(me, we, Ie, Ne) {
      var De = we.state;
      if (typeof we.componentWillReceiveProps == "function" && we.componentWillReceiveProps(Ie, Ne), typeof we.UNSAFE_componentWillReceiveProps == "function" && we.UNSAFE_componentWillReceiveProps(Ie, Ne), we.state !== De) {
        {
          var Ze = Gn(me) || "Component";
          A1.has(Ze) || (A1.add(Ze), xe("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ze));
        }
        L1.enqueueReplaceState(we, we.state, null);
      }
    }
    function D1(me, we, Ie, Ne) {
      pI(me, we, Ie);
      var De = me.stateNode;
      De.props = Ie, De.state = me.memoizedState, De.refs = DP, T1(me);
      var Ze = we.contextType;
      if (typeof Ze == "object" && Ze !== null)
        De.context = Pi(Ze);
      else {
        var tt = Py(me, we, !0);
        De.context = Ty(me, tt);
      }
      {
        if (De.state === Ie) {
          var ht = Fo(we) || "Component";
          R1.has(ht) || (R1.add(ht), xe("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", ht));
        }
        me.mode & Ma && ec.recordLegacyContextWarning(me, De), ec.recordUnsafeLifecycleWarnings(me, De);
      }
      De.state = me.memoizedState;
      var St = we.getDerivedStateFromProps;
      if (typeof St == "function" && (F1(me, we, St, Ie), De.state = me.memoizedState), typeof we.getDerivedStateFromProps != "function" && typeof De.getSnapshotBeforeUpdate != "function" && (typeof De.UNSAFE_componentWillMount == "function" || typeof De.componentWillMount == "function") && (mI(me, De), tw(me, Ie, De, Ne), De.state = me.memoizedState), typeof De.componentDidMount == "function") {
        var Nt = go;
        Nt |= Os, (me.mode & _u) !== Ln && (Nt |= As), me.flags |= Nt;
      }
    }
    function yI(me, we, Ie, Ne) {
      var De = me.stateNode, Ze = me.memoizedProps;
      De.props = Ze;
      var tt = De.context, ht = we.contextType, St = Ju;
      if (typeof ht == "object" && ht !== null)
        St = Pi(ht);
      else {
        var Nt = Py(me, we, !0);
        St = Ty(me, Nt);
      }
      var Bt = we.getDerivedStateFromProps, lr = typeof Bt == "function" || typeof De.getSnapshotBeforeUpdate == "function";
      !lr && (typeof De.UNSAFE_componentWillReceiveProps == "function" || typeof De.componentWillReceiveProps == "function") && (Ze !== Ie || tt !== St) && qP(me, De, Ie, St), FP();
      var nr = me.memoizedState, _r = De.state = nr;
      if (tw(me, Ie, De, Ne), _r = me.memoizedState, Ze === Ie && nr === _r && !C0() && !rw()) {
        if (typeof De.componentDidMount == "function") {
          var Er = go;
          Er |= Os, (me.mode & _u) !== Ln && (Er |= As), me.flags |= Er;
        }
        return !1;
      }
      typeof Bt == "function" && (F1(me, we, Bt, Ie), _r = me.memoizedState);
      var Cr = rw() || UP(me, we, Ze, Ie, nr, _r, St);
      if (Cr) {
        if (!lr && (typeof De.UNSAFE_componentWillMount == "function" || typeof De.componentWillMount == "function") && (typeof De.componentWillMount == "function" && De.componentWillMount(), typeof De.UNSAFE_componentWillMount == "function" && De.UNSAFE_componentWillMount()), typeof De.componentDidMount == "function") {
          var rn = go;
          rn |= Os, (me.mode & _u) !== Ln && (rn |= As), me.flags |= rn;
        }
      } else {
        if (typeof De.componentDidMount == "function") {
          var Cn = go;
          Cn |= Os, (me.mode & _u) !== Ln && (Cn |= As), me.flags |= Cn;
        }
        me.memoizedProps = Ie, me.memoizedState = _r;
      }
      return De.props = Ie, De.state = _r, De.context = St, Cr;
    }
    function vI(me, we, Ie, Ne, De) {
      var Ze = we.stateNode;
      jP(me, we);
      var tt = we.memoizedProps, ht = we.type === we.elementType ? tt : tc(we.type, tt);
      Ze.props = ht;
      var St = we.pendingProps, Nt = Ze.context, Bt = Ie.contextType, lr = Ju;
      if (typeof Bt == "object" && Bt !== null)
        lr = Pi(Bt);
      else {
        var nr = Py(we, Ie, !0);
        lr = Ty(we, nr);
      }
      var _r = Ie.getDerivedStateFromProps, Er = typeof _r == "function" || typeof Ze.getSnapshotBeforeUpdate == "function";
      !Er && (typeof Ze.UNSAFE_componentWillReceiveProps == "function" || typeof Ze.componentWillReceiveProps == "function") && (tt !== St || Nt !== lr) && qP(we, Ze, Ne, lr), FP();
      var Cr = we.memoizedState, rn = Ze.state = Cr;
      if (tw(we, Ne, Ze, De), rn = we.memoizedState, tt === St && Cr === rn && !C0() && !rw() && !Gt)
        return typeof Ze.componentDidUpdate == "function" && (tt !== me.memoizedProps || Cr !== me.memoizedState) && (we.flags |= go), typeof Ze.getSnapshotBeforeUpdate == "function" && (tt !== me.memoizedProps || Cr !== me.memoizedState) && (we.flags |= yu), !1;
      typeof _r == "function" && (F1(we, Ie, _r, Ne), rn = we.memoizedState);
      var Cn = rw() || UP(we, Ie, ht, Ne, Cr, rn, lr) || Gt;
      return Cn ? (!Er && (typeof Ze.UNSAFE_componentWillUpdate == "function" || typeof Ze.componentWillUpdate == "function") && (typeof Ze.componentWillUpdate == "function" && Ze.componentWillUpdate(Ne, rn, lr), typeof Ze.UNSAFE_componentWillUpdate == "function" && Ze.UNSAFE_componentWillUpdate(Ne, rn, lr)), typeof Ze.componentDidUpdate == "function" && (we.flags |= go), typeof Ze.getSnapshotBeforeUpdate == "function" && (we.flags |= yu)) : (typeof Ze.componentDidUpdate == "function" && (tt !== me.memoizedProps || Cr !== me.memoizedState) && (we.flags |= go), typeof Ze.getSnapshotBeforeUpdate == "function" && (tt !== me.memoizedProps || Cr !== me.memoizedState) && (we.flags |= yu), we.memoizedProps = Ne, we.memoizedState = rn), Ze.props = Ne, Ze.state = rn, Ze.context = lr, Cn;
    }
    var B1, z1, U1, V1, H1, WP = function(me, we) {
    };
    B1 = !1, z1 = !1, U1 = {}, V1 = {}, H1 = {}, WP = function(me, we) {
      if (!(me === null || typeof me != "object") && !(!me._store || me._store.validated || me.key != null)) {
        if (typeof me._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        me._store.validated = !0;
        var Ie = Gn(we) || "Component";
        V1[Ie] || (V1[Ie] = !0, xe('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function bb(me, we, Ie) {
      var Ne = Ie.ref;
      if (Ne !== null && typeof Ne != "function" && typeof Ne != "object") {
        if ((me.mode & Ma || Xt) && !(Ie._owner && Ie._self && Ie._owner.stateNode !== Ie._self)) {
          var De = Gn(me) || "Component";
          U1[De] || (xe('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ne), U1[De] = !0);
        }
        if (Ie._owner) {
          var Ze = Ie._owner, tt;
          if (Ze) {
            var ht = Ze;
            if (ht.tag !== Me)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            tt = ht.stateNode;
          }
          if (!tt)
            throw new Error("Missing owner for string ref " + Ne + ". This error is likely caused by a bug in React. Please file an issue.");
          var St = tt;
          Xn(Ne, "ref");
          var Nt = "" + Ne;
          if (we !== null && we.ref !== null && typeof we.ref == "function" && we.ref._stringRef === Nt)
            return we.ref;
          var Bt = function(lr) {
            var nr = St.refs;
            nr === DP && (nr = St.refs = {}), lr === null ? delete nr[Nt] : nr[Nt] = lr;
          };
          return Bt._stringRef = Nt, Bt;
        } else {
          if (typeof Ne != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!Ie._owner)
            throw new Error("Element ref was specified as a string (" + Ne + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return Ne;
    }
    function ow(me, we) {
      var Ie = Object.prototype.toString.call(we);
      throw new Error("Objects are not valid as a React child (found: " + (Ie === "[object Object]" ? "object with keys {" + Object.keys(we).join(", ") + "}" : Ie) + "). If you meant to render a collection of children, use an array instead.");
    }
    function aw(me) {
      {
        var we = Gn(me) || "Component";
        if (H1[we])
          return;
        H1[we] = !0, xe("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function ZP(me) {
      var we = me._payload, Ie = me._init;
      return Ie(we);
    }
    function GP(me) {
      function we(br, Ar) {
        if (me) {
          var gr = br.deletions;
          gr === null ? (br.deletions = [Ar], br.flags |= Xo) : gr.push(Ar);
        }
      }
      function Ie(br, Ar) {
        if (!me)
          return null;
        for (var gr = Ar; gr !== null; )
          we(br, gr), gr = gr.sibling;
        return null;
      }
      function Ne(br, Ar) {
        for (var gr = /* @__PURE__ */ new Map(), qr = Ar; qr !== null; )
          qr.key !== null ? gr.set(qr.key, qr) : gr.set(qr.index, qr), qr = qr.sibling;
        return gr;
      }
      function De(br, Ar) {
        var gr = am(br, Ar);
        return gr.index = 0, gr.sibling = null, gr;
      }
      function Ze(br, Ar, gr) {
        if (br.index = gr, !me)
          return br.flags |= yv, Ar;
        var qr = br.alternate;
        if (qr !== null) {
          var hn = qr.index;
          return hn < Ar ? (br.flags |= xa, Ar) : hn;
        } else
          return br.flags |= xa, Ar;
      }
      function tt(br) {
        return me && br.alternate === null && (br.flags |= xa), br;
      }
      function ht(br, Ar, gr, qr) {
        if (Ar === null || Ar.tag !== He) {
          var hn = LE(gr, br.mode, qr);
          return hn.return = br, hn;
        } else {
          var nn = De(Ar, gr);
          return nn.return = br, nn;
        }
      }
      function St(br, Ar, gr, qr) {
        var hn = gr.type;
        if (hn === ho)
          return Bt(br, Ar, gr.props.children, qr, gr.key);
        if (Ar !== null && (Ar.elementType === hn || T2(Ar, gr) || typeof hn == "object" && hn !== null && hn.$$typeof === xn && ZP(hn) === Ar.type)) {
          var nn = De(Ar, gr.props);
          return nn.ref = bb(br, Ar, gr), nn.return = br, nn._debugSource = gr._source, nn._debugOwner = gr._owner, nn;
        }
        var Kn = FE(gr, br.mode, qr);
        return Kn.ref = bb(br, Ar, gr), Kn.return = br, Kn;
      }
      function Nt(br, Ar, gr, qr) {
        if (Ar === null || Ar.tag !== Be || Ar.stateNode.containerInfo !== gr.containerInfo || Ar.stateNode.implementation !== gr.implementation) {
          var hn = DE(gr, br.mode, qr);
          return hn.return = br, hn;
        } else {
          var nn = De(Ar, gr.children || []);
          return nn.return = br, nn;
        }
      }
      function Bt(br, Ar, gr, qr, hn) {
        if (Ar === null || Ar.tag !== qe) {
          var nn = hp(gr, br.mode, qr, hn);
          return nn.return = br, nn;
        } else {
          var Kn = De(Ar, gr);
          return Kn.return = br, Kn;
        }
      }
      function lr(br, Ar, gr) {
        if (typeof Ar == "string" && Ar !== "" || typeof Ar == "number") {
          var qr = LE("" + Ar, br.mode, gr);
          return qr.return = br, qr;
        }
        if (typeof Ar == "object" && Ar !== null) {
          switch (Ar.$$typeof) {
            case $n: {
              var hn = FE(Ar, br.mode, gr);
              return hn.ref = bb(br, null, Ar), hn.return = br, hn;
            }
            case Bo: {
              var nn = DE(Ar, br.mode, gr);
              return nn.return = br, nn;
            }
            case xn: {
              var Kn = Ar._payload, yo = Ar._init;
              return lr(br, yo(Kn), gr);
            }
          }
          if (oa(Ar) || si(Ar)) {
            var sa = hp(Ar, br.mode, gr, null);
            return sa.return = br, sa;
          }
          ow(br, Ar);
        }
        return typeof Ar == "function" && aw(br), null;
      }
      function nr(br, Ar, gr, qr) {
        var hn = Ar !== null ? Ar.key : null;
        if (typeof gr == "string" && gr !== "" || typeof gr == "number")
          return hn !== null ? null : ht(br, Ar, "" + gr, qr);
        if (typeof gr == "object" && gr !== null) {
          switch (gr.$$typeof) {
            case $n:
              return gr.key === hn ? St(br, Ar, gr, qr) : null;
            case Bo:
              return gr.key === hn ? Nt(br, Ar, gr, qr) : null;
            case xn: {
              var nn = gr._payload, Kn = gr._init;
              return nr(br, Ar, Kn(nn), qr);
            }
          }
          if (oa(gr) || si(gr))
            return hn !== null ? null : Bt(br, Ar, gr, qr, null);
          ow(br, gr);
        }
        return typeof gr == "function" && aw(br), null;
      }
      function _r(br, Ar, gr, qr, hn) {
        if (typeof qr == "string" && qr !== "" || typeof qr == "number") {
          var nn = br.get(gr) || null;
          return ht(Ar, nn, "" + qr, hn);
        }
        if (typeof qr == "object" && qr !== null) {
          switch (qr.$$typeof) {
            case $n: {
              var Kn = br.get(qr.key === null ? gr : qr.key) || null;
              return St(Ar, Kn, qr, hn);
            }
            case Bo: {
              var yo = br.get(qr.key === null ? gr : qr.key) || null;
              return Nt(Ar, yo, qr, hn);
            }
            case xn:
              var sa = qr._payload, Yo = qr._init;
              return _r(br, Ar, gr, Yo(sa), hn);
          }
          if (oa(qr) || si(qr)) {
            var mi = br.get(gr) || null;
            return Bt(Ar, mi, qr, hn, null);
          }
          ow(Ar, qr);
        }
        return typeof qr == "function" && aw(Ar), null;
      }
      function Er(br, Ar, gr) {
        {
          if (typeof br != "object" || br === null)
            return Ar;
          switch (br.$$typeof) {
            case $n:
            case Bo:
              WP(br, gr);
              var qr = br.key;
              if (typeof qr != "string")
                break;
              if (Ar === null) {
                Ar = /* @__PURE__ */ new Set(), Ar.add(qr);
                break;
              }
              if (!Ar.has(qr)) {
                Ar.add(qr);
                break;
              }
              xe("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", qr);
              break;
            case xn:
              var hn = br._payload, nn = br._init;
              Er(nn(hn), Ar, gr);
              break;
          }
        }
        return Ar;
      }
      function Cr(br, Ar, gr, qr) {
        for (var hn = null, nn = 0; nn < gr.length; nn++) {
          var Kn = gr[nn];
          hn = Er(Kn, hn, br);
        }
        for (var yo = null, sa = null, Yo = Ar, mi = 0, Qo = 0, ni = null; Yo !== null && Qo < gr.length; Qo++) {
          Yo.index > Qo ? (ni = Yo, Yo = null) : ni = Yo.sibling;
          var Bs = nr(br, Yo, gr[Qo], qr);
          if (Bs === null) {
            Yo === null && (Yo = ni);
            break;
          }
          me && Yo && Bs.alternate === null && we(br, Yo), mi = Ze(Bs, mi, Qo), sa === null ? yo = Bs : sa.sibling = Bs, sa = Bs, Yo = ni;
        }
        if (Qo === gr.length) {
          if (Ie(br, Yo), ls()) {
            var ws = Qo;
            ch(br, ws);
          }
          return yo;
        }
        if (Yo === null) {
          for (; Qo < gr.length; Qo++) {
            var tl = lr(br, gr[Qo], qr);
            tl !== null && (mi = Ze(tl, mi, Qo), sa === null ? yo = tl : sa.sibling = tl, sa = tl);
          }
          if (ls()) {
            var su = Qo;
            ch(br, su);
          }
          return yo;
        }
        for (var uu = Ne(br, Yo); Qo < gr.length; Qo++) {
          var zs = _r(uu, br, Qo, gr[Qo], qr);
          zs !== null && (me && zs.alternate !== null && uu.delete(zs.key === null ? Qo : zs.key), mi = Ze(zs, mi, Qo), sa === null ? yo = zs : sa.sibling = zs, sa = zs);
        }
        if (me && uu.forEach(function(Gy) {
          return we(br, Gy);
        }), ls()) {
          var sf = Qo;
          ch(br, sf);
        }
        return yo;
      }
      function rn(br, Ar, gr, qr) {
        var hn = si(gr);
        if (typeof hn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && gr[Symbol.toStringTag] === "Generator" && (z1 || xe("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), z1 = !0), gr.entries === hn && (B1 || xe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), B1 = !0);
          var nn = hn.call(gr);
          if (nn)
            for (var Kn = null, yo = nn.next(); !yo.done; yo = nn.next()) {
              var sa = yo.value;
              Kn = Er(sa, Kn, br);
            }
        }
        var Yo = hn.call(gr);
        if (Yo == null)
          throw new Error("An iterable object provided no iterator.");
        for (var mi = null, Qo = null, ni = Ar, Bs = 0, ws = 0, tl = null, su = Yo.next(); ni !== null && !su.done; ws++, su = Yo.next()) {
          ni.index > ws ? (tl = ni, ni = null) : tl = ni.sibling;
          var uu = nr(br, ni, su.value, qr);
          if (uu === null) {
            ni === null && (ni = tl);
            break;
          }
          me && ni && uu.alternate === null && we(br, ni), Bs = Ze(uu, Bs, ws), Qo === null ? mi = uu : Qo.sibling = uu, Qo = uu, ni = tl;
        }
        if (su.done) {
          if (Ie(br, ni), ls()) {
            var zs = ws;
            ch(br, zs);
          }
          return mi;
        }
        if (ni === null) {
          for (; !su.done; ws++, su = Yo.next()) {
            var sf = lr(br, su.value, qr);
            sf !== null && (Bs = Ze(sf, Bs, ws), Qo === null ? mi = sf : Qo.sibling = sf, Qo = sf);
          }
          if (ls()) {
            var Gy = ws;
            ch(br, Gy);
          }
          return mi;
        }
        for (var Zb = Ne(br, ni); !su.done; ws++, su = Yo.next()) {
          var nd = _r(Zb, br, ws, su.value, qr);
          nd !== null && (me && nd.alternate !== null && Zb.delete(nd.key === null ? ws : nd.key), Bs = Ze(nd, Bs, ws), Qo === null ? mi = nd : Qo.sibling = nd, Qo = nd);
        }
        if (me && Zb.forEach(function(QN) {
          return we(br, QN);
        }), ls()) {
          var YN = ws;
          ch(br, YN);
        }
        return mi;
      }
      function Cn(br, Ar, gr, qr) {
        if (Ar !== null && Ar.tag === He) {
          Ie(br, Ar.sibling);
          var hn = De(Ar, gr);
          return hn.return = br, hn;
        }
        Ie(br, Ar);
        var nn = LE(gr, br.mode, qr);
        return nn.return = br, nn;
      }
      function Bn(br, Ar, gr, qr) {
        for (var hn = gr.key, nn = Ar; nn !== null; ) {
          if (nn.key === hn) {
            var Kn = gr.type;
            if (Kn === ho) {
              if (nn.tag === qe) {
                Ie(br, nn.sibling);
                var yo = De(nn, gr.props.children);
                return yo.return = br, yo._debugSource = gr._source, yo._debugOwner = gr._owner, yo;
              }
            } else if (nn.elementType === Kn || T2(nn, gr) || typeof Kn == "object" && Kn !== null && Kn.$$typeof === xn && ZP(Kn) === nn.type) {
              Ie(br, nn.sibling);
              var sa = De(nn, gr.props);
              return sa.ref = bb(br, nn, gr), sa.return = br, sa._debugSource = gr._source, sa._debugOwner = gr._owner, sa;
            }
            Ie(br, nn);
            break;
          } else
            we(br, nn);
          nn = nn.sibling;
        }
        if (gr.type === ho) {
          var Yo = hp(gr.props.children, br.mode, qr, gr.key);
          return Yo.return = br, Yo;
        } else {
          var mi = FE(gr, br.mode, qr);
          return mi.ref = bb(br, Ar, gr), mi.return = br, mi;
        }
      }
      function Ro(br, Ar, gr, qr) {
        for (var hn = gr.key, nn = Ar; nn !== null; ) {
          if (nn.key === hn)
            if (nn.tag === Be && nn.stateNode.containerInfo === gr.containerInfo && nn.stateNode.implementation === gr.implementation) {
              Ie(br, nn.sibling);
              var Kn = De(nn, gr.children || []);
              return Kn.return = br, Kn;
            } else {
              Ie(br, nn);
              break;
            }
          else
            we(br, nn);
          nn = nn.sibling;
        }
        var yo = DE(gr, br.mode, qr);
        return yo.return = br, yo;
      }
      function Co(br, Ar, gr, qr) {
        var hn = typeof gr == "object" && gr !== null && gr.type === ho && gr.key === null;
        if (hn && (gr = gr.props.children), typeof gr == "object" && gr !== null) {
          switch (gr.$$typeof) {
            case $n:
              return tt(Bn(br, Ar, gr, qr));
            case Bo:
              return tt(Ro(br, Ar, gr, qr));
            case xn:
              var nn = gr._payload, Kn = gr._init;
              return Co(br, Ar, Kn(nn), qr);
          }
          if (oa(gr))
            return Cr(br, Ar, gr, qr);
          if (si(gr))
            return rn(br, Ar, gr, qr);
          ow(br, gr);
        }
        return typeof gr == "string" && gr !== "" || typeof gr == "number" ? tt(Cn(br, Ar, "" + gr, qr)) : (typeof gr == "function" && aw(br), Ie(br, Ar));
      }
      return Co;
    }
    var Iy = GP(!0), YP = GP(!1);
    function bI(me, we) {
      if (me !== null && we.child !== me.child)
        throw new Error("Resuming work not yet implemented.");
      if (we.child !== null) {
        var Ie = we.child, Ne = am(Ie, Ie.pendingProps);
        for (we.child = Ne, Ne.return = we; Ie.sibling !== null; )
          Ie = Ie.sibling, Ne = Ne.sibling = am(Ie, Ie.pendingProps), Ne.return = we;
        Ne.sibling = null;
      }
    }
    function gI(me, we) {
      for (var Ie = me.child; Ie !== null; )
        fN(Ie, we), Ie = Ie.sibling;
    }
    var gb = {}, Zf = Uf(gb), wb = Uf(gb), iw = Uf(gb);
    function sw(me) {
      if (me === gb)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return me;
    }
    function QP() {
      var me = sw(iw.current);
      return me;
    }
    function q1(me, we) {
      Ls(iw, we, me), Ls(wb, me, me), Ls(Zf, gb, me);
      var Ie = QO(we);
      Fs(Zf, me), Ls(Zf, Ie, me);
    }
    function My(me) {
      Fs(Zf, me), Fs(wb, me), Fs(iw, me);
    }
    function W1() {
      var me = sw(Zf.current);
      return me;
    }
    function KP(me) {
      sw(iw.current);
      var we = sw(Zf.current), Ie = KO(we, me.type);
      we !== Ie && (Ls(wb, me, me), Ls(Zf, Ie, me));
    }
    function Z1(me) {
      wb.current === me && (Fs(Zf, me), Fs(wb, me));
    }
    var wI = 0, XP = 1, JP = 1, _b = 2, rc = Uf(wI);
    function G1(me, we) {
      return (me & we) !== 0;
    }
    function Ry(me) {
      return me & XP;
    }
    function Y1(me, we) {
      return me & XP | we;
    }
    function _I(me, we) {
      return me | we;
    }
    function Gf(me, we) {
      Ls(rc, we, me);
    }
    function Ny(me) {
      Fs(rc, me);
    }
    function EI(me, we) {
      var Ie = me.memoizedState;
      return Ie !== null ? Ie.dehydrated !== null : (me.memoizedProps, !0);
    }
    function uw(me) {
      for (var we = me; we !== null; ) {
        if (we.tag === It) {
          var Ie = we.memoizedState;
          if (Ie !== null) {
            var Ne = Ie.dehydrated;
            if (Ne === null || OS(Ne) || t1(Ne))
              return we;
          }
        } else if (we.tag === hr && we.memoizedProps.revealOrder !== void 0) {
          var De = (we.flags & Jn) !== Nn;
          if (De)
            return we;
        } else if (we.child !== null) {
          we.child.return = we, we = we.child;
          continue;
        }
        if (we === me)
          return null;
        for (; we.sibling === null; ) {
          if (we.return === null || we.return === me)
            return null;
          we = we.return;
        }
        we.sibling.return = we.return, we = we.sibling;
      }
      return null;
    }
    var Uu = 0, Di = 1, Qc = 2, Bi = 4, cs = 8, Q1 = [];
    function K1() {
      for (var me = 0; me < Q1.length; me++) {
        var we = Q1[me];
        we._workInProgressVersionPrimary = null;
      }
      Q1.length = 0;
    }
    function PI(me, we) {
      var Ie = we._getVersion, Ne = Ie(we._source);
      me.mutableSourceEagerHydrationData == null ? me.mutableSourceEagerHydrationData = [we, Ne] : me.mutableSourceEagerHydrationData.push(we, Ne);
    }
    var pn = fe.ReactCurrentDispatcher, xb = fe.ReactCurrentBatchConfig, X1, jy;
    X1 = /* @__PURE__ */ new Set();
    var Xh = Ir, aa = null, Ui = null, Vi = null, lw = !1, Eb = !1, Sb = 0, kI = 0, OI = 25, Rr = null, bl = null, Yf = -1, J1 = !1;
    function ta() {
      {
        var me = Rr;
        bl === null ? bl = [me] : bl.push(me);
      }
    }
    function Jr() {
      {
        var me = Rr;
        bl !== null && (Yf++, bl[Yf] !== me && CI(me));
      }
    }
    function Fy(me) {
      me != null && !oa(me) && xe("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Rr, typeof me);
    }
    function CI(me) {
      {
        var we = Gn(aa);
        if (!X1.has(we) && (X1.add(we), bl !== null)) {
          for (var Ie = "", Ne = 30, De = 0; De <= Yf; De++) {
            for (var Ze = bl[De], tt = De === Yf ? me : Ze, ht = De + 1 + ". " + Ze; ht.length < Ne; )
              ht += " ";
            ht += tt + `
`, Ie += ht;
          }
          xe(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, we, Ie);
        }
      }
    }
    function Ds() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function wx(me, we) {
      if (J1)
        return !1;
      if (we === null)
        return xe("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Rr), !1;
      me.length !== we.length && xe(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Rr, "[" + we.join(", ") + "]", "[" + me.join(", ") + "]");
      for (var Ie = 0; Ie < we.length && Ie < me.length; Ie++)
        if (!an(me[Ie], we[Ie]))
          return !1;
      return !0;
    }
    function Ly(me, we, Ie, Ne, De, Ze) {
      Xh = Ze, aa = we, bl = me !== null ? me._debugHookTypes : null, Yf = -1, J1 = me !== null && me.type !== we.type, we.memoizedState = null, we.updateQueue = null, we.lanes = Ir, me !== null && me.memoizedState !== null ? pn.current = _T : bl !== null ? pn.current = wT : pn.current = gT;
      var tt = Ie(Ne, De);
      if (Eb) {
        var ht = 0;
        do {
          if (Eb = !1, Sb = 0, ht >= OI)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          ht += 1, J1 = !1, Ui = null, Vi = null, we.updateQueue = null, Yf = -1, pn.current = xT, tt = Ie(Ne, De);
        } while (Eb);
      }
      pn.current = Ew, we._debugHookTypes = bl;
      var St = Ui !== null && Ui.next !== null;
      if (Xh = Ir, aa = null, Ui = null, Vi = null, Rr = null, bl = null, Yf = -1, me !== null && (me.flags & Ri) !== (we.flags & Ri) && (me.mode & $o) !== Ln && xe("Internal React error: Expected static flag was missing. Please notify the React team."), lw = !1, St)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return tt;
    }
    function Dy() {
      var me = Sb !== 0;
      return Sb = 0, me;
    }
    function eT(me, we, Ie) {
      we.updateQueue = me.updateQueue, (we.mode & _u) !== Ln ? we.flags &= ~(xd | As | Oa | go) : we.flags &= ~(Oa | go), me.lanes = kf(me.lanes, Ie);
    }
    function tT() {
      if (pn.current = Ew, lw) {
        for (var me = aa.memoizedState; me !== null; ) {
          var we = me.queue;
          we !== null && (we.pending = null), me = me.next;
        }
        lw = !1;
      }
      Xh = Ir, aa = null, Ui = null, Vi = null, bl = null, Yf = -1, Rr = null, hT = !1, Eb = !1, Sb = 0;
    }
    function Kc() {
      var me = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Vi === null ? aa.memoizedState = Vi = me : Vi = Vi.next = me, Vi;
    }
    function gl() {
      var me;
      if (Ui === null) {
        var we = aa.alternate;
        we !== null ? me = we.memoizedState : me = null;
      } else
        me = Ui.next;
      var Ie;
      if (Vi === null ? Ie = aa.memoizedState : Ie = Vi.next, Ie !== null)
        Vi = Ie, Ie = Vi.next, Ui = me;
      else {
        if (me === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ui = me;
        var Ne = { memoizedState: Ui.memoizedState, baseState: Ui.baseState, baseQueue: Ui.baseQueue, queue: Ui.queue, next: null };
        Vi === null ? aa.memoizedState = Vi = Ne : Vi = Vi.next = Ne;
      }
      return Vi;
    }
    function rT() {
      return { lastEffect: null, stores: null };
    }
    function _x(me, we) {
      return typeof we == "function" ? we(me) : we;
    }
    function xx(me, we, Ie) {
      var Ne = Kc(), De;
      Ie !== void 0 ? De = Ie(we) : De = we, Ne.memoizedState = Ne.baseState = De;
      var Ze = { pending: null, interleaved: null, lanes: Ir, dispatch: null, lastRenderedReducer: me, lastRenderedState: De };
      Ne.queue = Ze;
      var tt = Ze.dispatch = UI.bind(null, aa, Ze);
      return [Ne.memoizedState, tt];
    }
    function Ex(me, we, Ie) {
      var Ne = gl(), De = Ne.queue;
      if (De === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      De.lastRenderedReducer = me;
      var Ze = Ui, tt = Ze.baseQueue, ht = De.pending;
      if (ht !== null) {
        if (tt !== null) {
          var St = tt.next, Nt = ht.next;
          tt.next = Nt, ht.next = St;
        }
        Ze.baseQueue !== tt && xe("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), Ze.baseQueue = tt = ht, De.pending = null;
      }
      if (tt !== null) {
        var Bt = tt.next, lr = Ze.baseState, nr = null, _r = null, Er = null, Cr = Bt;
        do {
          var rn = Cr.lane;
          if (Rd(Xh, rn)) {
            if (Er !== null) {
              var Cn = { lane: Uo, action: Cr.action, hasEagerState: Cr.hasEagerState, eagerState: Cr.eagerState, next: null };
              Er = Er.next = Cn;
            }
            if (Cr.hasEagerState)
              lr = Cr.eagerState;
            else {
              var Bn = Cr.action;
              lr = me(lr, Bn);
            }
          } else {
            var Ro = { lane: rn, action: Cr.action, hasEagerState: Cr.hasEagerState, eagerState: Cr.eagerState, next: null };
            Er === null ? (_r = Er = Ro, nr = lr) : Er = Er.next = Ro, aa.lanes = wo(aa.lanes, rn), Ub(rn);
          }
          Cr = Cr.next;
        } while (Cr !== null && Cr !== Bt);
        Er === null ? nr = lr : Er.next = _r, an(lr, Ne.memoizedState) || $b(), Ne.memoizedState = lr, Ne.baseState = nr, Ne.baseQueue = Er, De.lastRenderedState = lr;
      }
      var Co = De.interleaved;
      if (Co !== null) {
        var br = Co;
        do {
          var Ar = br.lane;
          aa.lanes = wo(aa.lanes, Ar), Ub(Ar), br = br.next;
        } while (br !== Co);
      } else
        tt === null && (De.lanes = Ir);
      var gr = De.dispatch;
      return [Ne.memoizedState, gr];
    }
    function Px(me, we, Ie) {
      var Ne = gl(), De = Ne.queue;
      if (De === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      De.lastRenderedReducer = me;
      var Ze = De.dispatch, tt = De.pending, ht = Ne.memoizedState;
      if (tt !== null) {
        De.pending = null;
        var St = tt.next, Nt = St;
        do {
          var Bt = Nt.action;
          ht = me(ht, Bt), Nt = Nt.next;
        } while (Nt !== St);
        an(ht, Ne.memoizedState) || $b(), Ne.memoizedState = ht, Ne.baseQueue === null && (Ne.baseState = ht), De.lastRenderedState = ht;
      }
      return [ht, Ze];
    }
    function Tx(me, we, Ie) {
      var Ne = aa, De = Kc(), Ze, tt = ls();
      if (tt) {
        if (Ie === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        Ze = Ie(), jy || Ze !== Ie() && (xe("The result of getServerSnapshot should be cached to avoid an infinite loop"), jy = !0);
      } else {
        if (Ze = we(), !jy) {
          var ht = we();
          an(Ze, ht) || (xe("The result of getSnapshot should be cached to avoid an infinite loop"), jy = !0);
        }
        var St = Uw();
        if (St === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Np(St, Xh) || nT(Ne, we, Ze);
      }
      De.memoizedState = Ze;
      var Nt = { value: Ze, getSnapshot: we };
      return De.queue = Nt, mw(aT.bind(null, Ne, Nt, me), [me]), Ne.flags |= Oa, Pb(Di | cs, oT.bind(null, Ne, Nt, Ze, we), void 0, null), Ze;
    }
    function cw(me, we, Ie) {
      var Ne = aa, De = gl(), Ze = we();
      if (!jy) {
        var tt = we();
        an(Ze, tt) || (xe("The result of getSnapshot should be cached to avoid an infinite loop"), jy = !0);
      }
      var ht = De.memoizedState, St = !an(ht, Ze);
      St && (De.memoizedState = Ze, $b());
      var Nt = De.queue;
      if (kb(aT.bind(null, Ne, Nt, me), [me]), Nt.getSnapshot !== we || St || Vi !== null && Vi.memoizedState.tag & Di) {
        Ne.flags |= Oa, Pb(Di | cs, oT.bind(null, Ne, Nt, Ze, we), void 0, null);
        var Bt = Uw();
        if (Bt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Np(Bt, Xh) || nT(Ne, we, Ze);
      }
      return Ze;
    }
    function nT(me, we, Ie) {
      me.flags |= Pp;
      var Ne = { getSnapshot: we, value: Ie }, De = aa.updateQueue;
      if (De === null)
        De = rT(), aa.updateQueue = De, De.stores = [Ne];
      else {
        var Ze = De.stores;
        Ze === null ? De.stores = [Ne] : Ze.push(Ne);
      }
    }
    function oT(me, we, Ie, Ne) {
      we.value = Ie, we.getSnapshot = Ne, iT(we) && sT(me);
    }
    function aT(me, we, Ie) {
      var Ne = function() {
        iT(we) && sT(me);
      };
      return Ie(Ne);
    }
    function iT(me) {
      var we = me.getSnapshot, Ie = me.value;
      try {
        var Ne = we();
        return !an(Ie, Ne);
      } catch {
        return !0;
      }
    }
    function sT(me) {
      var we = zu(me, Wn);
      we !== null && Gi(we, me, Wn, la);
    }
    function fw(me) {
      var we = Kc();
      typeof me == "function" && (me = me()), we.memoizedState = we.baseState = me;
      var Ie = { pending: null, interleaved: null, lanes: Ir, dispatch: null, lastRenderedReducer: _x, lastRenderedState: me };
      we.queue = Ie;
      var Ne = Ie.dispatch = VI.bind(null, aa, Ie);
      return [we.memoizedState, Ne];
    }
    function kx(me) {
      return Ex(_x);
    }
    function Ox(me) {
      return Px(_x);
    }
    function Pb(me, we, Ie, Ne) {
      var De = { tag: me, create: we, destroy: Ie, deps: Ne, next: null }, Ze = aa.updateQueue;
      if (Ze === null)
        Ze = rT(), aa.updateQueue = Ze, Ze.lastEffect = De.next = De;
      else {
        var tt = Ze.lastEffect;
        if (tt === null)
          Ze.lastEffect = De.next = De;
        else {
          var ht = tt.next;
          tt.next = De, De.next = ht, Ze.lastEffect = De;
        }
      }
      return De;
    }
    function Ax(me) {
      var we = Kc();
      {
        var Ie = { current: me };
        return we.memoizedState = Ie, Ie;
      }
    }
    function pw(me) {
      var we = gl();
      return we.memoizedState;
    }
    function Tb(me, we, Ie, Ne) {
      var De = Kc(), Ze = Ne === void 0 ? null : Ne;
      aa.flags |= me, De.memoizedState = Pb(Di | we, Ie, void 0, Ze);
    }
    function hw(me, we, Ie, Ne) {
      var De = gl(), Ze = Ne === void 0 ? null : Ne, tt = void 0;
      if (Ui !== null) {
        var ht = Ui.memoizedState;
        if (tt = ht.destroy, Ze !== null) {
          var St = ht.deps;
          if (wx(Ze, St)) {
            De.memoizedState = Pb(we, Ie, tt, Ze);
            return;
          }
        }
      }
      aa.flags |= me, De.memoizedState = Pb(Di | we, Ie, tt, Ze);
    }
    function mw(me, we) {
      return (aa.mode & _u) !== Ln ? Tb(xd | Oa | kc, cs, me, we) : Tb(Oa | kc, cs, me, we);
    }
    function kb(me, we) {
      return hw(Oa, cs, me, we);
    }
    function Cx(me, we) {
      return Tb(go, Qc, me, we);
    }
    function yw(me, we) {
      return hw(go, Qc, me, we);
    }
    function $x(me, we) {
      var Ie = go;
      return Ie |= Os, (aa.mode & _u) !== Ln && (Ie |= As), Tb(Ie, Bi, me, we);
    }
    function vw(me, we) {
      return hw(go, Bi, me, we);
    }
    function uT(me, we) {
      if (typeof we == "function") {
        var Ie = we, Ne = me();
        return Ie(Ne), function() {
          Ie(null);
        };
      } else if (we != null) {
        var De = we;
        De.hasOwnProperty("current") || xe("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(De).join(", ") + "}");
        var Ze = me();
        return De.current = Ze, function() {
          De.current = null;
        };
      }
    }
    function Ix(me, we, Ie) {
      typeof we != "function" && xe("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", we !== null ? typeof we : "null");
      var Ne = Ie != null ? Ie.concat([me]) : null, De = go;
      return De |= Os, (aa.mode & _u) !== Ln && (De |= As), Tb(De, Bi, uT.bind(null, we, me), Ne);
    }
    function bw(me, we, Ie) {
      typeof we != "function" && xe("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", we !== null ? typeof we : "null");
      var Ne = Ie != null ? Ie.concat([me]) : null;
      return hw(go, Bi, uT.bind(null, we, me), Ne);
    }
    function $I(me, we) {
    }
    var gw = $I;
    function Mx(me, we) {
      var Ie = Kc(), Ne = we === void 0 ? null : we;
      return Ie.memoizedState = [me, Ne], me;
    }
    function ww(me, we) {
      var Ie = gl(), Ne = we === void 0 ? null : we, De = Ie.memoizedState;
      if (De !== null && Ne !== null) {
        var Ze = De[1];
        if (wx(Ne, Ze))
          return De[0];
      }
      return Ie.memoizedState = [me, Ne], me;
    }
    function Rx(me, we) {
      var Ie = Kc(), Ne = we === void 0 ? null : we, De = me();
      return Ie.memoizedState = [De, Ne], De;
    }
    function _w(me, we) {
      var Ie = gl(), Ne = we === void 0 ? null : we, De = Ie.memoizedState;
      if (De !== null && Ne !== null) {
        var Ze = De[1];
        if (wx(Ne, Ze))
          return De[0];
      }
      var tt = me();
      return Ie.memoizedState = [tt, Ne], tt;
    }
    function Nx(me) {
      var we = Kc();
      return we.memoizedState = me, me;
    }
    function lT(me) {
      var we = gl(), Ie = Ui, Ne = Ie.memoizedState;
      return dT(we, Ne, me);
    }
    function cT(me) {
      var we = gl();
      if (Ui === null)
        return we.memoizedState = me, me;
      var Ie = Ui.memoizedState;
      return dT(we, Ie, me);
    }
    function dT(me, we, Ie) {
      var Ne = !x_(Xh);
      if (Ne) {
        if (!an(Ie, we)) {
          var De = Mv();
          aa.lanes = wo(aa.lanes, De), Ub(De), me.baseState = !0;
        }
        return we;
      } else
        return me.baseState && (me.baseState = !1, $b()), me.memoizedState = Ie, Ie;
    }
    function II(me, we, Ie) {
      var Ne = eu();
      fi(Lp(Ne, Pu)), me(!0);
      var De = xb.transition;
      xb.transition = {};
      var Ze = xb.transition;
      xb.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        me(!1), we();
      } finally {
        if (fi(Ne), xb.transition = De, De === null && Ze._updatedFibers) {
          var tt = Ze._updatedFibers.size;
          tt > 10 && _e("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ze._updatedFibers.clear();
        }
      }
    }
    function jx() {
      var me = fw(!1), we = me[0], Ie = me[1], Ne = II.bind(null, Ie), De = Kc();
      return De.memoizedState = Ne, [we, Ne];
    }
    function fT() {
      var me = kx(), we = me[0], Ie = gl(), Ne = Ie.memoizedState;
      return [we, Ne];
    }
    function pT() {
      var me = Ox(), we = me[0], Ie = gl(), Ne = Ie.memoizedState;
      return [we, Ne];
    }
    var hT = !1;
    function BI() {
      return hT;
    }
    function Fx() {
      var me = Kc(), we = Uw(), Ie = we.identifierPrefix, Ne;
      if (ls()) {
        var De = YC();
        Ne = ":" + Ie + "R" + De;
        var Ze = Sb++;
        Ze > 0 && (Ne += "H" + Ze.toString(32)), Ne += ":";
      } else {
        var tt = kI++;
        Ne = ":" + Ie + "r" + tt.toString(32) + ":";
      }
      return me.memoizedState = Ne, Ne;
    }
    function xw() {
      var me = gl(), we = me.memoizedState;
      return we;
    }
    function UI(me, we, Ie) {
      typeof arguments[3] == "function" && xe("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Ne = ep(me), De = { lane: Ne, action: Ie, hasEagerState: !1, eagerState: null, next: null };
      if (mT(me))
        yT(we, De);
      else {
        var Ze = IP(me, we, De, Ne);
        if (Ze !== null) {
          var tt = iu();
          Gi(Ze, me, Ne, tt), vT(Ze, we, Ne);
        }
      }
      bT(me, Ne);
    }
    function VI(me, we, Ie) {
      typeof arguments[3] == "function" && xe("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Ne = ep(me), De = { lane: Ne, action: Ie, hasEagerState: !1, eagerState: null, next: null };
      if (mT(me))
        yT(we, De);
      else {
        var Ze = me.alternate;
        if (me.lanes === Ir && (Ze === null || Ze.lanes === Ir)) {
          var tt = we.lastRenderedReducer;
          if (tt !== null) {
            var ht;
            ht = pn.current, pn.current = nc;
            try {
              var St = we.lastRenderedState, Nt = tt(St, Ie);
              if (De.hasEagerState = !0, De.eagerState = Nt, an(Nt, St)) {
                sI(me, we, De, Ne);
                return;
              }
            } catch {
            } finally {
              pn.current = ht;
            }
          }
        }
        var Bt = IP(me, we, De, Ne);
        if (Bt !== null) {
          var lr = iu();
          Gi(Bt, me, Ne, lr), vT(Bt, we, Ne);
        }
      }
      bT(me, Ne);
    }
    function mT(me) {
      var we = me.alternate;
      return me === aa || we !== null && we === aa;
    }
    function yT(me, we) {
      Eb = lw = !0;
      var Ie = me.pending;
      Ie === null ? we.next = we : (we.next = Ie.next, Ie.next = we), me.pending = we;
    }
    function vT(me, we, Ie) {
      if (Iv(Ie)) {
        var Ne = we.lanes;
        Ne = Rv(Ne, me.pendingLanes);
        var De = wo(Ne, Ie);
        we.lanes = De, jp(me, De);
      }
    }
    function bT(me, we, Ie) {
      jc(me, we);
    }
    var Ew = { readContext: Pi, useCallback: Ds, useContext: Ds, useEffect: Ds, useImperativeHandle: Ds, useInsertionEffect: Ds, useLayoutEffect: Ds, useMemo: Ds, useReducer: Ds, useRef: Ds, useState: Ds, useDebugValue: Ds, useDeferredValue: Ds, useTransition: Ds, useMutableSource: Ds, useSyncExternalStore: Ds, useId: Ds, unstable_isNewReconciler: Ft }, gT = null, wT = null, _T = null, xT = null, Xc = null, nc = null, Sw = null;
    {
      var Lx = function() {
        xe("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, lo = function() {
        xe("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      gT = { readContext: function(me) {
        return Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", ta(), Fy(we), Mx(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", ta(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", ta(), Fy(we), mw(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", ta(), Fy(Ie), Ix(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", ta(), Fy(we), Cx(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", ta(), Fy(we), $x(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", ta(), Fy(we);
        var Ie = pn.current;
        pn.current = Xc;
        try {
          return Rx(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", ta();
        var Ne = pn.current;
        pn.current = Xc;
        try {
          return xx(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", ta(), Ax(me);
      }, useState: function(me) {
        Rr = "useState", ta();
        var we = pn.current;
        pn.current = Xc;
        try {
          return fw(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", ta(), void 0;
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", ta(), Nx(me);
      }, useTransition: function() {
        return Rr = "useTransition", ta(), jx();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", ta(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", ta(), Tx(me, we, Ie);
      }, useId: function() {
        return Rr = "useId", ta(), Fx();
      }, unstable_isNewReconciler: Ft }, wT = { readContext: function(me) {
        return Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", Jr(), Mx(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", Jr(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", Jr(), mw(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", Jr(), Ix(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", Jr(), Cx(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", Jr(), $x(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", Jr();
        var Ie = pn.current;
        pn.current = Xc;
        try {
          return Rx(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", Jr();
        var Ne = pn.current;
        pn.current = Xc;
        try {
          return xx(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", Jr(), Ax(me);
      }, useState: function(me) {
        Rr = "useState", Jr();
        var we = pn.current;
        pn.current = Xc;
        try {
          return fw(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", Jr(), void 0;
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", Jr(), Nx(me);
      }, useTransition: function() {
        return Rr = "useTransition", Jr(), jx();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", Jr(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", Jr(), Tx(me, we, Ie);
      }, useId: function() {
        return Rr = "useId", Jr(), Fx();
      }, unstable_isNewReconciler: Ft }, _T = { readContext: function(me) {
        return Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", Jr(), ww(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", Jr(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", Jr(), kb(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", Jr(), bw(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", Jr(), yw(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", Jr(), vw(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", Jr();
        var Ie = pn.current;
        pn.current = nc;
        try {
          return _w(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", Jr();
        var Ne = pn.current;
        pn.current = nc;
        try {
          return Ex(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", Jr(), pw();
      }, useState: function(me) {
        Rr = "useState", Jr();
        var we = pn.current;
        pn.current = nc;
        try {
          return kx(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", Jr(), gw();
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", Jr(), lT(me);
      }, useTransition: function() {
        return Rr = "useTransition", Jr(), fT();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", Jr(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", Jr(), cw(me, we);
      }, useId: function() {
        return Rr = "useId", Jr(), xw();
      }, unstable_isNewReconciler: Ft }, xT = { readContext: function(me) {
        return Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", Jr(), ww(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", Jr(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", Jr(), kb(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", Jr(), bw(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", Jr(), yw(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", Jr(), vw(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", Jr();
        var Ie = pn.current;
        pn.current = Sw;
        try {
          return _w(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", Jr();
        var Ne = pn.current;
        pn.current = Sw;
        try {
          return Px(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", Jr(), pw();
      }, useState: function(me) {
        Rr = "useState", Jr();
        var we = pn.current;
        pn.current = Sw;
        try {
          return Ox(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", Jr(), gw();
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", Jr(), cT(me);
      }, useTransition: function() {
        return Rr = "useTransition", Jr(), pT();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", Jr(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", Jr(), cw(me, we);
      }, useId: function() {
        return Rr = "useId", Jr(), xw();
      }, unstable_isNewReconciler: Ft }, Xc = { readContext: function(me) {
        return Lx(), Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", lo(), ta(), Mx(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", lo(), ta(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", lo(), ta(), mw(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", lo(), ta(), Ix(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", lo(), ta(), Cx(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", lo(), ta(), $x(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", lo(), ta();
        var Ie = pn.current;
        pn.current = Xc;
        try {
          return Rx(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", lo(), ta();
        var Ne = pn.current;
        pn.current = Xc;
        try {
          return xx(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", lo(), ta(), Ax(me);
      }, useState: function(me) {
        Rr = "useState", lo(), ta();
        var we = pn.current;
        pn.current = Xc;
        try {
          return fw(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", lo(), ta(), void 0;
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", lo(), ta(), Nx(me);
      }, useTransition: function() {
        return Rr = "useTransition", lo(), ta(), jx();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", lo(), ta(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", lo(), ta(), Tx(me, we, Ie);
      }, useId: function() {
        return Rr = "useId", lo(), ta(), Fx();
      }, unstable_isNewReconciler: Ft }, nc = { readContext: function(me) {
        return Lx(), Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", lo(), Jr(), ww(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", lo(), Jr(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", lo(), Jr(), kb(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", lo(), Jr(), bw(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", lo(), Jr(), yw(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", lo(), Jr(), vw(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", lo(), Jr();
        var Ie = pn.current;
        pn.current = nc;
        try {
          return _w(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", lo(), Jr();
        var Ne = pn.current;
        pn.current = nc;
        try {
          return Ex(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", lo(), Jr(), pw();
      }, useState: function(me) {
        Rr = "useState", lo(), Jr();
        var we = pn.current;
        pn.current = nc;
        try {
          return kx(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", lo(), Jr(), gw();
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", lo(), Jr(), lT(me);
      }, useTransition: function() {
        return Rr = "useTransition", lo(), Jr(), fT();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", lo(), Jr(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", lo(), Jr(), cw(me, we);
      }, useId: function() {
        return Rr = "useId", lo(), Jr(), xw();
      }, unstable_isNewReconciler: Ft }, Sw = { readContext: function(me) {
        return Lx(), Pi(me);
      }, useCallback: function(me, we) {
        return Rr = "useCallback", lo(), Jr(), ww(me, we);
      }, useContext: function(me) {
        return Rr = "useContext", lo(), Jr(), Pi(me);
      }, useEffect: function(me, we) {
        return Rr = "useEffect", lo(), Jr(), kb(me, we);
      }, useImperativeHandle: function(me, we, Ie) {
        return Rr = "useImperativeHandle", lo(), Jr(), bw(me, we, Ie);
      }, useInsertionEffect: function(me, we) {
        return Rr = "useInsertionEffect", lo(), Jr(), yw(me, we);
      }, useLayoutEffect: function(me, we) {
        return Rr = "useLayoutEffect", lo(), Jr(), vw(me, we);
      }, useMemo: function(me, we) {
        Rr = "useMemo", lo(), Jr();
        var Ie = pn.current;
        pn.current = nc;
        try {
          return _w(me, we);
        } finally {
          pn.current = Ie;
        }
      }, useReducer: function(me, we, Ie) {
        Rr = "useReducer", lo(), Jr();
        var Ne = pn.current;
        pn.current = nc;
        try {
          return Px(me, we, Ie);
        } finally {
          pn.current = Ne;
        }
      }, useRef: function(me) {
        return Rr = "useRef", lo(), Jr(), pw();
      }, useState: function(me) {
        Rr = "useState", lo(), Jr();
        var we = pn.current;
        pn.current = nc;
        try {
          return Ox(me);
        } finally {
          pn.current = we;
        }
      }, useDebugValue: function(me, we) {
        return Rr = "useDebugValue", lo(), Jr(), gw();
      }, useDeferredValue: function(me) {
        return Rr = "useDeferredValue", lo(), Jr(), cT(me);
      }, useTransition: function() {
        return Rr = "useTransition", lo(), Jr(), pT();
      }, useMutableSource: function(me, we, Ie) {
        return Rr = "useMutableSource", lo(), Jr(), void 0;
      }, useSyncExternalStore: function(me, we, Ie) {
        return Rr = "useSyncExternalStore", lo(), Jr(), cw(me, we);
      }, useId: function() {
        return Rr = "useId", lo(), Jr(), xw();
      }, unstable_isNewReconciler: Ft };
    }
    var Qf = ae.unstable_now, ET = 0, Pw = -1, Ob = -1, Tw = -1, Dx = !1, kw = !1;
    function ST() {
      return Dx;
    }
    function WI() {
      kw = !0;
    }
    function GI() {
      Dx = !1, kw = !1;
    }
    function YI() {
      Dx = kw, kw = !1;
    }
    function PT() {
      return ET;
    }
    function TT() {
      ET = Qf();
    }
    function Bx(me) {
      Ob = Qf(), me.actualStartTime < 0 && (me.actualStartTime = Qf());
    }
    function kT(me) {
      Ob = -1;
    }
    function Ow(me, we) {
      if (Ob >= 0) {
        var Ie = Qf() - Ob;
        me.actualDuration += Ie, we && (me.selfBaseDuration = Ie), Ob = -1;
      }
    }
    function Jc(me) {
      if (Pw >= 0) {
        var we = Qf() - Pw;
        Pw = -1;
        for (var Ie = me.return; Ie !== null; ) {
          switch (Ie.tag) {
            case je:
              var Ne = Ie.stateNode;
              Ne.effectDuration += we;
              return;
            case Ct:
              var De = Ie.stateNode;
              De.effectDuration += we;
              return;
          }
          Ie = Ie.return;
        }
      }
    }
    function zx(me) {
      if (Tw >= 0) {
        var we = Qf() - Tw;
        Tw = -1;
        for (var Ie = me.return; Ie !== null; ) {
          switch (Ie.tag) {
            case je:
              var Ne = Ie.stateNode;
              Ne !== null && (Ne.passiveEffectDuration += we);
              return;
            case Ct:
              var De = Ie.stateNode;
              De !== null && (De.passiveEffectDuration += we);
              return;
          }
          Ie = Ie.return;
        }
      }
    }
    function ed() {
      Pw = Qf();
    }
    function Ux() {
      Tw = Qf();
    }
    function Vx(me) {
      for (var we = me.child; we; )
        me.actualDuration += we.actualDuration, we = we.sibling;
    }
    function Jh(me, we) {
      return { value: me, source: we, stack: is(we), digest: null };
    }
    function Hx(me, we, Ie) {
      return { value: me, source: null, stack: Ie ?? null, digest: we ?? null };
    }
    function QI(me, we) {
      return !0;
    }
    function qx(me, we) {
      try {
        var Ie = QI(me, we);
        if (Ie === !1)
          return;
        var Ne = we.value, De = we.source, Ze = we.stack, tt = Ze !== null ? Ze : "";
        if (Ne != null && Ne._suppressLogging) {
          if (me.tag === Me)
            return;
          console.error(Ne);
        }
        var ht = De ? Gn(De) : null, St = ht ? "The above error occurred in the <" + ht + "> component:" : "The above error occurred in one of your React components:", Nt;
        if (me.tag === je)
          Nt = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Bt = Gn(me) || "Anonymous";
          Nt = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Bt + ".");
        }
        var lr = St + `
` + tt + `

` + ("" + Nt);
        console.error(lr);
      } catch (nr) {
        setTimeout(function() {
          throw nr;
        });
      }
    }
    var KI = typeof WeakMap == "function" ? WeakMap : Map;
    function OT(me, we, Ie) {
      var Ne = Jd(la, Ie);
      Ne.tag = S1, Ne.payload = { element: null };
      var De = we.value;
      return Ne.callback = function() {
        qR(De), qx(me, we);
      }, Ne;
    }
    function Wx(me, we, Ie) {
      var Ne = Jd(la, Ie);
      Ne.tag = S1;
      var De = me.type.getDerivedStateFromError;
      if (typeof De == "function") {
        var Ze = we.value;
        Ne.payload = function() {
          return De(Ze);
        }, Ne.callback = function() {
          k2(me), qx(me, we);
        };
      }
      var tt = me.stateNode;
      return tt !== null && typeof tt.componentDidCatch == "function" && (Ne.callback = function() {
        k2(me), qx(me, we), typeof De != "function" && VR(this);
        var ht = we.value, St = we.stack;
        this.componentDidCatch(ht, { componentStack: St !== null ? St : "" }), typeof De != "function" && (Rs(me.lanes, Wn) || xe("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Gn(me) || "Unknown"));
      }), Ne;
    }
    function AT(me, we, Ie) {
      var Ne = me.pingCache, De;
      if (Ne === null ? (Ne = me.pingCache = new KI(), De = /* @__PURE__ */ new Set(), Ne.set(we, De)) : (De = Ne.get(we), De === void 0 && (De = /* @__PURE__ */ new Set(), Ne.set(we, De))), !De.has(Ie)) {
        De.add(Ie);
        var Ze = WR.bind(null, me, we, Ie);
        Ni && Vb(me, Ie), we.then(Ze, Ze);
      }
    }
    function XI(me, we, Ie, Ne) {
      var De = me.updateQueue;
      if (De === null) {
        var Ze = /* @__PURE__ */ new Set();
        Ze.add(Ie), me.updateQueue = Ze;
      } else
        De.add(Ie);
    }
    function eM(me, we) {
      var Ie = me.tag;
      if ((me.mode & $o) === Ln && (Ie === $e || Ie === yt || Ie === Ut)) {
        var Ne = me.alternate;
        Ne ? (me.updateQueue = Ne.updateQueue, me.memoizedState = Ne.memoizedState, me.lanes = Ne.lanes) : (me.updateQueue = null, me.memoizedState = null);
      }
    }
    function CT(me) {
      var we = me;
      do {
        if (we.tag === It && EI(we))
          return we;
        we = we.return;
      } while (we !== null);
      return null;
    }
    function $T(me, we, Ie, Ne, De) {
      if ((me.mode & $o) === Ln) {
        if (me === we)
          me.flags |= xi;
        else {
          if (me.flags |= Jn, Ie.flags |= Tp, Ie.flags &= ~(bm | Ys), Ie.tag === Me) {
            var Ze = Ie.alternate;
            if (Ze === null)
              Ie.tag = tr;
            else {
              var tt = Jd(la, Wn);
              tt.tag = K0, Wf(Ie, tt, Wn);
            }
          }
          Ie.lanes = wo(Ie.lanes, Wn);
        }
        return me;
      }
      return me.flags |= xi, me.lanes = De, me;
    }
    function tM(me, we, Ie, Ne, De) {
      if (Ie.flags |= Ys, Ni && Vb(me, De), Ne !== null && typeof Ne == "object" && typeof Ne.then == "function") {
        var Ze = Ne;
        eM(Ie), ls() && Ie.mode & $o && US();
        var tt = CT(we);
        if (tt !== null) {
          tt.flags &= ~Fa, $T(tt, we, Ie, me, De), tt.mode & $o && AT(me, Ze, De), XI(tt, me, Ze);
          return;
        } else {
          if (!Tf(De)) {
            AT(me, Ze, De), PE();
            return;
          }
          var ht = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          Ne = ht;
        }
      } else if (ls() && Ie.mode & $o) {
        US();
        var St = CT(we);
        if (St !== null) {
          (St.flags & xi) === Nn && (St.flags |= Fa), $T(St, we, Ie, me, De), v1(Jh(Ne, Ie));
          return;
        }
      }
      Ne = Jh(Ne, Ie), NR(Ne);
      var Nt = we;
      do {
        switch (Nt.tag) {
          case je: {
            var Bt = Ne;
            Nt.flags |= xi;
            var lr = di(De);
            Nt.lanes = wo(Nt.lanes, lr);
            var nr = OT(Nt, Bt, lr);
            k1(Nt, nr);
            return;
          }
          case Me:
            var _r = Ne, Er = Nt.type, Cr = Nt.stateNode;
            if ((Nt.flags & Jn) === Nn && (typeof Er.getDerivedStateFromError == "function" || Cr !== null && typeof Cr.componentDidCatch == "function" && !b2(Cr))) {
              Nt.flags |= xi;
              var rn = di(De);
              Nt.lanes = wo(Nt.lanes, rn);
              var Cn = Wx(Nt, _r, rn);
              k1(Nt, Cn);
              return;
            }
            break;
        }
        Nt = Nt.return;
      } while (Nt !== null);
    }
    function rM() {
      return null;
    }
    var Ab = fe.ReactCurrentOwner, ac = !1, Zx, Cb, Gx, Yx, Qx, em, Kx, Aw;
    Zx = {}, Cb = {}, Gx = {}, Yx = {}, Qx = {}, em = !1, Kx = {}, Aw = {};
    function ou(me, we, Ie, Ne) {
      me === null ? we.child = YP(we, null, Ie, Ne) : we.child = Iy(we, me.child, Ie, Ne);
    }
    function nM(me, we, Ie, Ne) {
      we.child = Iy(we, me.child, null, Ne), we.child = Iy(we, null, Ie, Ne);
    }
    function IT(me, we, Ie, Ne, De) {
      if (we.type !== we.elementType) {
        var Ze = Ie.propTypes;
        Ze && Xl(Ze, Ne, "prop", Fo(Ie));
      }
      var tt = Ie.render, ht = we.ref, St, Nt;
      $y(we, De), Nc(we);
      {
        if (Ab.current = we, Ii(!0), St = Ly(me, we, tt, Ne, ht, De), Nt = Dy(), we.mode & Ma) {
          ci(!0);
          try {
            St = Ly(me, we, tt, Ne, ht, De), Nt = Dy();
          } finally {
            ci(!1);
          }
        }
        Ii(!1);
      }
      return Ed(), me !== null && !ac ? (eT(me, we, De), ef(me, we, De)) : (ls() && Nt && d1(we), we.flags |= wc, ou(me, we, St, De), we.child);
    }
    function MT(me, we, Ie, Ne, De) {
      if (me === null) {
        var Ze = Ie.type;
        if (cN(Ze) && Ie.compare === null && Ie.defaultProps === void 0) {
          var tt = Ze;
          return tt = Zy(Ze), we.tag = Ut, we.type = tt, eE(we, Ze), RT(me, we, tt, Ne, De);
        }
        {
          var ht = Ze.propTypes;
          ht && Xl(ht, Ne, "prop", Fo(Ze));
        }
        var St = jE(Ie.type, null, Ne, we, we.mode, De);
        return St.ref = we.ref, St.return = we, we.child = St, St;
      }
      {
        var Nt = Ie.type, Bt = Nt.propTypes;
        Bt && Xl(Bt, Ne, "prop", Fo(Nt));
      }
      var lr = me.child, nr = iE(me, De);
      if (!nr) {
        var _r = lr.memoizedProps, Er = Ie.compare;
        if (Er = Er !== null ? Er : Mn, Er(_r, Ne) && me.ref === we.ref)
          return ef(me, we, De);
      }
      we.flags |= wc;
      var Cr = am(lr, Ne);
      return Cr.ref = we.ref, Cr.return = we, we.child = Cr, Cr;
    }
    function RT(me, we, Ie, Ne, De) {
      if (we.type !== we.elementType) {
        var Ze = we.elementType;
        if (Ze.$$typeof === xn) {
          var tt = Ze, ht = tt._payload, St = tt._init;
          try {
            Ze = St(ht);
          } catch {
            Ze = null;
          }
          var Nt = Ze && Ze.propTypes;
          Nt && Xl(Nt, Ne, "prop", Fo(Ze));
        }
      }
      if (me !== null) {
        var Bt = me.memoizedProps;
        if (Mn(Bt, Ne) && me.ref === we.ref && we.type === me.type)
          if (ac = !1, we.pendingProps = Ne = Bt, iE(me, De))
            (me.flags & Tp) !== Nn && (ac = !0);
          else
            return we.lanes = me.lanes, ef(me, we, De);
      }
      return Xx(me, we, Ie, Ne, De);
    }
    function NT(me, we, Ie) {
      var Ne = we.pendingProps, De = Ne.children, Ze = me !== null ? me.memoizedState : null;
      if (Ne.mode === "hidden" || ot)
        if ((we.mode & $o) === Ln) {
          var tt = { baseLanes: Ir, cachePool: null, transitions: null };
          we.memoizedState = tt, Vw(we, Ie);
        } else if (Rs(Ie, Ms)) {
          var ht = { baseLanes: Ir, cachePool: null, transitions: null };
          we.memoizedState = ht;
          var St = Ze !== null ? Ze.baseLanes : Ie;
          Vw(we, St);
        } else {
          var Nt = null, Bt;
          if (Ze !== null) {
            var lr = Ze.baseLanes;
            Bt = wo(lr, Ie);
          } else
            Bt = Ie;
          we.lanes = we.childLanes = Ms;
          var nr = { baseLanes: Bt, cachePool: Nt, transitions: null };
          return we.memoizedState = nr, we.updateQueue = null, Vw(we, Bt), null;
        }
      else {
        var _r;
        Ze !== null ? (_r = wo(Ze.baseLanes, Ie), we.memoizedState = null) : _r = Ie, Vw(we, _r);
      }
      return ou(me, we, De, Ie), we.child;
    }
    function oM(me, we, Ie) {
      var Ne = we.pendingProps;
      return ou(me, we, Ne, Ie), we.child;
    }
    function aM(me, we, Ie) {
      var Ne = we.pendingProps.children;
      return ou(me, we, Ne, Ie), we.child;
    }
    function iM(me, we, Ie) {
      {
        we.flags |= go;
        {
          var Ne = we.stateNode;
          Ne.effectDuration = 0, Ne.passiveEffectDuration = 0;
        }
      }
      var De = we.pendingProps, Ze = De.children;
      return ou(me, we, Ze, Ie), we.child;
    }
    function jT(me, we) {
      var Ie = we.ref;
      (me === null && Ie !== null || me !== null && me.ref !== Ie) && (we.flags |= ks, we.flags |= vv);
    }
    function Xx(me, we, Ie, Ne, De) {
      if (we.type !== we.elementType) {
        var Ze = Ie.propTypes;
        Ze && Xl(Ze, Ne, "prop", Fo(Ie));
      }
      var tt;
      {
        var ht = Py(we, Ie, !0);
        tt = Ty(we, ht);
      }
      var St, Nt;
      $y(we, De), Nc(we);
      {
        if (Ab.current = we, Ii(!0), St = Ly(me, we, Ie, Ne, tt, De), Nt = Dy(), we.mode & Ma) {
          ci(!0);
          try {
            St = Ly(me, we, Ie, Ne, tt, De), Nt = Dy();
          } finally {
            ci(!1);
          }
        }
        Ii(!1);
      }
      return Ed(), me !== null && !ac ? (eT(me, we, De), ef(me, we, De)) : (ls() && Nt && d1(we), we.flags |= wc, ou(me, we, St, De), we.child);
    }
    function FT(me, we, Ie, Ne, De) {
      {
        switch (PN(we)) {
          case !1: {
            var Ze = we.stateNode, tt = we.type, ht = new tt(we.memoizedProps, Ze.context), St = ht.state;
            Ze.updater.enqueueSetState(Ze, St, null);
            break;
          }
          case !0: {
            we.flags |= Jn, we.flags |= xi;
            var Nt = new Error("Simulated error coming from DevTools"), Bt = di(De);
            we.lanes = wo(we.lanes, Bt);
            var lr = Wx(we, Jh(Nt, we), Bt);
            k1(we, lr);
            break;
          }
        }
        if (we.type !== we.elementType) {
          var nr = Ie.propTypes;
          nr && Xl(nr, Ne, "prop", Fo(Ie));
        }
      }
      var _r;
      Yc(Ie) ? (_r = !0, I0(we)) : _r = !1, $y(we, De);
      var Er = we.stateNode, Cr;
      Er === null ? ($w(me, we), HP(we, Ie, Ne), D1(we, Ie, Ne, De), Cr = !0) : me === null ? Cr = yI(we, Ie, Ne, De) : Cr = vI(me, we, Ie, Ne, De);
      var rn = Jx(me, we, Ie, Cr, _r, De);
      {
        var Cn = we.stateNode;
        Cr && Cn.props !== Ne && (em || xe("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Gn(we) || "a component"), em = !0);
      }
      return rn;
    }
    function Jx(me, we, Ie, Ne, De, Ze) {
      jT(me, we);
      var tt = (we.flags & Jn) !== Nn;
      if (!Ne && !tt)
        return De && FS(we, Ie, !1), ef(me, we, Ze);
      var ht = we.stateNode;
      Ab.current = we;
      var St;
      if (tt && typeof Ie.getDerivedStateFromError != "function")
        St = null, kT();
      else {
        Nc(we);
        {
          if (Ii(!0), St = ht.render(), we.mode & Ma) {
            ci(!0);
            try {
              ht.render();
            } finally {
              ci(!1);
            }
          }
          Ii(!1);
        }
        Ed();
      }
      return we.flags |= wc, me !== null && tt ? nM(me, we, St, Ze) : ou(me, we, St, Ze), we.memoizedState = ht.state, De && FS(we, Ie, !0), we.child;
    }
    function LT(me) {
      var we = me.stateNode;
      we.pendingContext ? NS(me, we.pendingContext, we.pendingContext !== we.context) : we.context && NS(me, we.context, !1), q1(me, we.containerInfo);
    }
    function sM(me, we, Ie) {
      if (LT(we), me === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var Ne = we.pendingProps, De = we.memoizedState, Ze = De.element;
      jP(me, we), tw(we, Ne, null, Ie);
      var tt = we.memoizedState;
      we.stateNode;
      var ht = tt.element;
      if (De.isDehydrated) {
        var St = { element: ht, isDehydrated: !1, cache: tt.cache, pendingSuspenseBoundaries: tt.pendingSuspenseBoundaries, transitions: tt.transitions }, Nt = we.updateQueue;
        if (Nt.baseState = St, we.memoizedState = St, we.flags & Fa) {
          var Bt = Jh(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), we);
          return DT(me, we, ht, Ie, Bt);
        } else if (ht !== Ze) {
          var lr = Jh(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), we);
          return DT(me, we, ht, Ie, lr);
        } else {
          W$(we);
          var nr = YP(we, null, ht, Ie);
          we.child = nr;
          for (var _r = nr; _r; )
            _r.flags = _r.flags & ~xa | vu, _r = _r.sibling;
        }
      } else {
        if (Ay(), ht === Ze)
          return ef(me, we, Ie);
        ou(me, we, ht, Ie);
      }
      return we.child;
    }
    function DT(me, we, Ie, Ne, De) {
      return Ay(), v1(De), we.flags |= Fa, ou(me, we, Ie, Ne), we.child;
    }
    function uM(me, we, Ie) {
      KP(we), me === null && y1(we);
      var Ne = we.type, De = we.pendingProps, Ze = me !== null ? me.memoizedProps : null, tt = De.children, ht = K_(Ne, De);
      return ht ? tt = null : Ze !== null && K_(Ne, Ze) && (we.flags |= ea), jT(me, we), ou(me, we, tt, Ie), we.child;
    }
    function lM(me, we) {
      return me === null && y1(we), null;
    }
    function cM(me, we, Ie, Ne) {
      $w(me, we);
      var De = we.pendingProps, Ze = Ie, tt = Ze._payload, ht = Ze._init, St = ht(tt);
      we.type = St;
      var Nt = we.tag = dN(St), Bt = tc(St, De), lr;
      switch (Nt) {
        case $e:
          return eE(we, St), we.type = St = Zy(St), lr = Xx(null, we, St, Bt, Ne), lr;
        case Me:
          return we.type = St = CE(St), lr = FT(null, we, St, Bt, Ne), lr;
        case yt:
          return we.type = St = $E(St), lr = IT(null, we, St, Bt, Ne), lr;
        case Vt: {
          if (we.type !== we.elementType) {
            var nr = St.propTypes;
            nr && Xl(nr, Bt, "prop", Fo(St));
          }
          return lr = MT(null, we, St, tc(St.type, Bt), Ne), lr;
        }
      }
      var _r = "";
      throw St !== null && typeof St == "object" && St.$$typeof === xn && (_r = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + St + ". " + ("Lazy element type must resolve to a class or function." + _r));
    }
    function dM(me, we, Ie, Ne, De) {
      $w(me, we), we.tag = Me;
      var Ze;
      return Yc(Ie) ? (Ze = !0, I0(we)) : Ze = !1, $y(we, De), HP(we, Ie, Ne), D1(we, Ie, Ne, De), Jx(null, we, Ie, !0, Ze, De);
    }
    function fM(me, we, Ie, Ne) {
      $w(me, we);
      var De = we.pendingProps, Ze;
      {
        var tt = Py(we, Ie, !1);
        Ze = Ty(we, tt);
      }
      $y(we, Ne);
      var ht, St;
      Nc(we);
      {
        if (Ie.prototype && typeof Ie.prototype.render == "function") {
          var Nt = Fo(Ie) || "Unknown";
          Zx[Nt] || (xe("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Nt, Nt), Zx[Nt] = !0);
        }
        we.mode & Ma && ec.recordLegacyContextWarning(we, null), Ii(!0), Ab.current = we, ht = Ly(null, we, Ie, De, Ze, Ne), St = Dy(), Ii(!1);
      }
      if (Ed(), we.flags |= wc, typeof ht == "object" && ht !== null && typeof ht.render == "function" && ht.$$typeof === void 0) {
        var Bt = Fo(Ie) || "Unknown";
        Cb[Bt] || (xe("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Bt, Bt, Bt), Cb[Bt] = !0);
      }
      if (typeof ht == "object" && ht !== null && typeof ht.render == "function" && ht.$$typeof === void 0) {
        {
          var lr = Fo(Ie) || "Unknown";
          Cb[lr] || (xe("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", lr, lr, lr), Cb[lr] = !0);
        }
        we.tag = Me, we.memoizedState = null, we.updateQueue = null;
        var nr = !1;
        return Yc(Ie) ? (nr = !0, I0(we)) : nr = !1, we.memoizedState = ht.state !== null && ht.state !== void 0 ? ht.state : null, T1(we), VP(we, ht), D1(we, Ie, De, Ne), Jx(null, we, Ie, !0, nr, Ne);
      } else {
        if (we.tag = $e, we.mode & Ma) {
          ci(!0);
          try {
            ht = Ly(null, we, Ie, De, Ze, Ne), St = Dy();
          } finally {
            ci(!1);
          }
        }
        return ls() && St && d1(we), ou(null, we, ht, Ne), eE(we, Ie), we.child;
      }
    }
    function eE(me, we) {
      {
        if (we && we.childContextTypes && xe("%s(...): childContextTypes cannot be defined on a function component.", we.displayName || we.name || "Component"), me.ref !== null) {
          var Ie = "", Ne = Xa();
          Ne && (Ie += `

Check the render method of \`` + Ne + "`.");
          var De = Ne || "", Ze = me._debugSource;
          Ze && (De = Ze.fileName + ":" + Ze.lineNumber), Qx[De] || (Qx[De] = !0, xe("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", Ie));
        }
        if (typeof we.getDerivedStateFromProps == "function") {
          var tt = Fo(we) || "Unknown";
          Yx[tt] || (xe("%s: Function components do not support getDerivedStateFromProps.", tt), Yx[tt] = !0);
        }
        if (typeof we.contextType == "object" && we.contextType !== null) {
          var ht = Fo(we) || "Unknown";
          Gx[ht] || (xe("%s: Function components do not support contextType.", ht), Gx[ht] = !0);
        }
      }
    }
    var tE = { dehydrated: null, treeContext: null, retryLane: Uo };
    function rE(me) {
      return { baseLanes: me, cachePool: rM(), transitions: null };
    }
    function pM(me, we) {
      var Ie = null;
      return { baseLanes: wo(me.baseLanes, we), cachePool: Ie, transitions: me.transitions };
    }
    function hM(me, we, Ie, Ne) {
      if (we !== null) {
        var De = we.memoizedState;
        if (De === null)
          return !1;
      }
      return G1(me, _b);
    }
    function mM(me, we) {
      return kf(me.childLanes, we);
    }
    function BT(me, we, Ie) {
      var Ne = we.pendingProps;
      TN(we) && (we.flags |= Jn);
      var De = rc.current, Ze = !1, tt = (we.flags & Jn) !== Nn;
      if (tt || hM(De, me) ? (Ze = !0, we.flags &= ~Jn) : (me === null || me.memoizedState !== null) && (De = _I(De, JP)), De = Ry(De), Gf(we, De), me === null) {
        y1(we);
        var ht = we.memoizedState;
        if (ht !== null) {
          var St = ht.dehydrated;
          if (St !== null)
            return wM(we, St);
        }
        var Nt = Ne.children, Bt = Ne.fallback;
        if (Ze) {
          var lr = yM(we, Nt, Bt, Ie), nr = we.child;
          return nr.memoizedState = rE(Ie), we.memoizedState = tE, lr;
        } else
          return nE(we, Nt);
      } else {
        var _r = me.memoizedState;
        if (_r !== null) {
          var Er = _r.dehydrated;
          if (Er !== null)
            return _M(me, we, tt, Ne, Er, _r, Ie);
        }
        if (Ze) {
          var Cr = Ne.fallback, rn = Ne.children, Cn = bM(me, we, rn, Cr, Ie), Bn = we.child, Ro = me.child.memoizedState;
          return Bn.memoizedState = Ro === null ? rE(Ie) : pM(Ro, Ie), Bn.childLanes = mM(me, Ie), we.memoizedState = tE, Cn;
        } else {
          var Co = Ne.children, br = vM(me, we, Co, Ie);
          return we.memoizedState = null, br;
        }
      }
    }
    function nE(me, we, Ie) {
      var Ne = me.mode, De = { mode: "visible", children: we }, Ze = oE(De, Ne);
      return Ze.return = me, me.child = Ze, Ze;
    }
    function yM(me, we, Ie, Ne) {
      var De = me.mode, Ze = me.child, tt = { mode: "hidden", children: we }, ht, St;
      return (De & $o) === Ln && Ze !== null ? (ht = Ze, ht.childLanes = Ir, ht.pendingProps = tt, me.mode & qn && (ht.actualDuration = 0, ht.actualStartTime = -1, ht.selfBaseDuration = 0, ht.treeBaseDuration = 0), St = hp(Ie, De, Ne, null)) : (ht = oE(tt, De), St = hp(Ie, De, Ne, null)), ht.return = me, St.return = me, ht.sibling = St, me.child = ht, St;
    }
    function oE(me, we, Ie) {
      return O2(me, we, Ir, null);
    }
    function zT(me, we) {
      return am(me, we);
    }
    function vM(me, we, Ie, Ne) {
      var De = me.child, Ze = De.sibling, tt = zT(De, { mode: "visible", children: Ie });
      if ((we.mode & $o) === Ln && (tt.lanes = Ne), tt.return = we, tt.sibling = null, Ze !== null) {
        var ht = we.deletions;
        ht === null ? (we.deletions = [Ze], we.flags |= Xo) : ht.push(Ze);
      }
      return we.child = tt, tt;
    }
    function bM(me, we, Ie, Ne, De) {
      var Ze = we.mode, tt = me.child, ht = tt.sibling, St = { mode: "hidden", children: Ie }, Nt;
      if ((Ze & $o) === Ln && we.child !== tt) {
        var Bt = we.child;
        Nt = Bt, Nt.childLanes = Ir, Nt.pendingProps = St, we.mode & qn && (Nt.actualDuration = 0, Nt.actualStartTime = -1, Nt.selfBaseDuration = tt.selfBaseDuration, Nt.treeBaseDuration = tt.treeBaseDuration), we.deletions = null;
      } else
        Nt = zT(tt, St), Nt.subtreeFlags = tt.subtreeFlags & Ri;
      var lr;
      return ht !== null ? lr = am(ht, Ne) : (lr = hp(Ne, Ze, De, null), lr.flags |= xa), lr.return = we, Nt.return = we, Nt.sibling = lr, we.child = Nt, lr;
    }
    function Cw(me, we, Ie, Ne) {
      Ne !== null && v1(Ne), Iy(we, me.child, null, Ie);
      var De = we.pendingProps, Ze = De.children, tt = nE(we, Ze);
      return tt.flags |= xa, we.memoizedState = null, tt;
    }
    function gM(me, we, Ie, Ne, De) {
      var Ze = we.mode, tt = { mode: "visible", children: Ie }, ht = oE(tt, Ze), St = hp(Ne, Ze, De, null);
      return St.flags |= xa, ht.return = we, St.return = we, ht.sibling = St, we.child = ht, (we.mode & $o) !== Ln && Iy(we, me.child, null, De), St;
    }
    function wM(me, we, Ie) {
      return (me.mode & $o) === Ln ? (xe("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), me.lanes = Wn) : t1(we) ? me.lanes = Od : me.lanes = Ms, null;
    }
    function _M(me, we, Ie, Ne, De, Ze, tt) {
      if (Ie)
        if (we.flags & Fa) {
          we.flags &= ~Fa;
          var ht = Hx(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Cw(me, we, tt, ht);
        } else {
          if (we.memoizedState !== null)
            return we.child = me.child, we.flags |= Jn, null;
          var St = Ne.children, Nt = Ne.fallback, Bt = gM(me, we, St, Nt, tt), lr = we.child;
          return lr.memoizedState = rE(tt), we.memoizedState = tE, Bt;
        }
      else {
        if (JC(), (we.mode & $o) === Ln)
          return Cw(me, we, tt, null);
        if (t1(De)) {
          var nr, _r, Er;
          {
            var Cr = yC(De);
            nr = Cr.digest, _r = Cr.message, Er = Cr.stack;
          }
          var rn;
          _r ? rn = new Error(_r) : rn = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Cn = Hx(rn, nr, Er);
          return Cw(me, we, tt, Cn);
        }
        var Bn = Rs(tt, me.childLanes);
        if (ac || Bn) {
          var Ro = Uw();
          if (Ro !== null) {
            var Co = ey(Ro, tt);
            if (Co !== Uo && Co !== Ze.retryLane) {
              Ze.retryLane = Co;
              var br = la;
              zu(me, Co), Gi(Ro, me, Co, br);
            }
          }
          PE();
          var Ar = Hx(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Cw(me, we, tt, Ar);
        } else if (OS(De)) {
          we.flags |= Jn, we.child = me.child;
          var gr = ZR.bind(null, me);
          return vC(De, gr), null;
        } else {
          Z$(we, De, Ze.treeContext);
          var qr = Ne.children, hn = nE(we, qr);
          return hn.flags |= vu, hn;
        }
      }
    }
    function UT(me, we, Ie) {
      me.lanes = wo(me.lanes, we);
      var Ne = me.alternate;
      Ne !== null && (Ne.lanes = wo(Ne.lanes, we)), x1(me.return, we, Ie);
    }
    function xM(me, we, Ie) {
      for (var Ne = we; Ne !== null; ) {
        if (Ne.tag === It) {
          var De = Ne.memoizedState;
          De !== null && UT(Ne, Ie, me);
        } else if (Ne.tag === hr)
          UT(Ne, Ie, me);
        else if (Ne.child !== null) {
          Ne.child.return = Ne, Ne = Ne.child;
          continue;
        }
        if (Ne === me)
          return;
        for (; Ne.sibling === null; ) {
          if (Ne.return === null || Ne.return === me)
            return;
          Ne = Ne.return;
        }
        Ne.sibling.return = Ne.return, Ne = Ne.sibling;
      }
    }
    function EM(me) {
      for (var we = me, Ie = null; we !== null; ) {
        var Ne = we.alternate;
        Ne !== null && uw(Ne) === null && (Ie = we), we = we.sibling;
      }
      return Ie;
    }
    function SM(me) {
      if (me !== void 0 && me !== "forwards" && me !== "backwards" && me !== "together" && !Kx[me])
        if (Kx[me] = !0, typeof me == "string")
          switch (me.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              xe('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', me, me.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              xe('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', me, me.toLowerCase());
              break;
            }
            default:
              xe('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
              break;
          }
        else
          xe('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
    }
    function PM(me, we) {
      me !== void 0 && !Aw[me] && (me !== "collapsed" && me !== "hidden" ? (Aw[me] = !0, xe('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', me)) : we !== "forwards" && we !== "backwards" && (Aw[me] = !0, xe('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', me)));
    }
    function VT(me, we) {
      {
        var Ie = oa(me), Ne = !Ie && typeof si(me) == "function";
        if (Ie || Ne) {
          var De = Ie ? "array" : "iterable";
          return xe("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", De, we, De), !1;
        }
      }
      return !0;
    }
    function TM(me, we) {
      if ((we === "forwards" || we === "backwards") && me !== void 0 && me !== null && me !== !1)
        if (oa(me)) {
          for (var Ie = 0; Ie < me.length; Ie++)
            if (!VT(me[Ie], Ie))
              return;
        } else {
          var Ne = si(me);
          if (typeof Ne == "function") {
            var De = Ne.call(me);
            if (De)
              for (var Ze = De.next(), tt = 0; !Ze.done; Ze = De.next()) {
                if (!VT(Ze.value, tt))
                  return;
                tt++;
              }
          } else
            xe('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', we);
        }
    }
    function aE(me, we, Ie, Ne, De) {
      var Ze = me.memoizedState;
      Ze === null ? me.memoizedState = { isBackwards: we, rendering: null, renderingStartTime: 0, last: Ne, tail: Ie, tailMode: De } : (Ze.isBackwards = we, Ze.rendering = null, Ze.renderingStartTime = 0, Ze.last = Ne, Ze.tail = Ie, Ze.tailMode = De);
    }
    function HT(me, we, Ie) {
      var Ne = we.pendingProps, De = Ne.revealOrder, Ze = Ne.tail, tt = Ne.children;
      SM(De), PM(Ze, De), TM(tt, De), ou(me, we, tt, Ie);
      var ht = rc.current, St = G1(ht, _b);
      if (St)
        ht = Y1(ht, _b), we.flags |= Jn;
      else {
        var Nt = me !== null && (me.flags & Jn) !== Nn;
        Nt && xM(we, we.child, Ie), ht = Ry(ht);
      }
      if (Gf(we, ht), (we.mode & $o) === Ln)
        we.memoizedState = null;
      else
        switch (De) {
          case "forwards": {
            var Bt = EM(we.child), lr;
            Bt === null ? (lr = we.child, we.child = null) : (lr = Bt.sibling, Bt.sibling = null), aE(we, !1, lr, Bt, Ze);
            break;
          }
          case "backwards": {
            var nr = null, _r = we.child;
            for (we.child = null; _r !== null; ) {
              var Er = _r.alternate;
              if (Er !== null && uw(Er) === null) {
                we.child = _r;
                break;
              }
              var Cr = _r.sibling;
              _r.sibling = nr, nr = _r, _r = Cr;
            }
            aE(we, !0, nr, null, Ze);
            break;
          }
          case "together": {
            aE(we, !1, null, null, void 0);
            break;
          }
          default:
            we.memoizedState = null;
        }
      return we.child;
    }
    function kM(me, we, Ie) {
      q1(we, we.stateNode.containerInfo);
      var Ne = we.pendingProps;
      return me === null ? we.child = Iy(we, null, Ne, Ie) : ou(me, we, Ne, Ie), we.child;
    }
    var qT = !1;
    function OM(me, we, Ie) {
      var Ne = we.type, De = Ne._context, Ze = we.pendingProps, tt = we.memoizedProps, ht = Ze.value;
      {
        "value" in Ze || qT || (qT = !0, xe("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var St = we.type.propTypes;
        St && Xl(St, Ze, "prop", "Context.Provider");
      }
      if ($P(we, De, ht), tt !== null) {
        var Nt = tt.value;
        if (an(Nt, ht)) {
          if (tt.children === Ze.children && !C0())
            return ef(me, we, Ie);
        } else
          oI(we, De, Ie);
      }
      var Bt = Ze.children;
      return ou(me, we, Bt, Ie), we.child;
    }
    var WT = !1;
    function AM(me, we, Ie) {
      var Ne = we.type;
      Ne._context === void 0 ? Ne !== Ne.Consumer && (WT || (WT = !0, xe("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : Ne = Ne._context;
      var De = we.pendingProps, Ze = De.children;
      typeof Ze != "function" && xe("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), $y(we, Ie);
      var tt = Pi(Ne);
      Nc(we);
      var ht;
      return Ab.current = we, Ii(!0), ht = Ze(tt), Ii(!1), Ed(), we.flags |= wc, ou(me, we, ht, Ie), we.child;
    }
    function $b() {
      ac = !0;
    }
    function $w(me, we) {
      (we.mode & $o) === Ln && me !== null && (me.alternate = null, we.alternate = null, we.flags |= xa);
    }
    function ef(me, we, Ie) {
      return me !== null && (we.dependencies = me.dependencies), kT(), Ub(we.lanes), Rs(Ie, we.childLanes) ? (bI(me, we), we.child) : null;
    }
    function CM(me, we, Ie) {
      {
        var Ne = we.return;
        if (Ne === null)
          throw new Error("Cannot swap the root fiber.");
        if (me.alternate = null, we.alternate = null, Ie.index = we.index, Ie.sibling = we.sibling, Ie.return = we.return, Ie.ref = we.ref, we === Ne.child)
          Ne.child = Ie;
        else {
          var De = Ne.child;
          if (De === null)
            throw new Error("Expected parent to have a child.");
          for (; De.sibling !== we; )
            if (De = De.sibling, De === null)
              throw new Error("Expected to find the previous sibling.");
          De.sibling = Ie;
        }
        var Ze = Ne.deletions;
        return Ze === null ? (Ne.deletions = [me], Ne.flags |= Xo) : Ze.push(me), Ie.flags |= xa, Ie;
      }
    }
    function iE(me, we) {
      var Ie = me.lanes;
      return !!Rs(Ie, we);
    }
    function $M(me, we, Ie) {
      switch (we.tag) {
        case je:
          LT(we), we.stateNode, Ay();
          break;
        case ze:
          KP(we);
          break;
        case Me: {
          var Ne = we.type;
          Yc(Ne) && I0(we);
          break;
        }
        case Be:
          q1(we, we.stateNode.containerInfo);
          break;
        case dt: {
          var De = we.memoizedProps.value, Ze = we.type._context;
          $P(we, Ze, De);
          break;
        }
        case Ct:
          {
            var tt = Rs(Ie, we.childLanes);
            tt && (we.flags |= go);
            {
              var ht = we.stateNode;
              ht.effectDuration = 0, ht.passiveEffectDuration = 0;
            }
          }
          break;
        case It: {
          var St = we.memoizedState;
          if (St !== null) {
            if (St.dehydrated !== null)
              return Gf(we, Ry(rc.current)), we.flags |= Jn, null;
            var Nt = we.child, Bt = Nt.childLanes;
            if (Rs(Ie, Bt))
              return BT(me, we, Ie);
            Gf(we, Ry(rc.current));
            var lr = ef(me, we, Ie);
            return lr !== null ? lr.sibling : null;
          } else
            Gf(we, Ry(rc.current));
          break;
        }
        case hr: {
          var nr = (me.flags & Jn) !== Nn, _r = Rs(Ie, we.childLanes);
          if (nr) {
            if (_r)
              return HT(me, we, Ie);
            we.flags |= Jn;
          }
          var Er = we.memoizedState;
          if (Er !== null && (Er.rendering = null, Er.tail = null, Er.lastEffect = null), Gf(we, rc.current), _r)
            break;
          return null;
        }
        case Qe:
        case at:
          return we.lanes = Ir, NT(me, we, Ie);
      }
      return ef(me, we, Ie);
    }
    function ZT(me, we, Ie) {
      if (we._debugNeedsRemount && me !== null)
        return CM(me, we, jE(we.type, we.key, we.pendingProps, we._debugOwner || null, we.mode, we.lanes));
      if (me !== null) {
        var Ne = me.memoizedProps, De = we.pendingProps;
        if (Ne !== De || C0() || we.type !== me.type)
          ac = !0;
        else {
          var Ze = iE(me, Ie);
          if (!Ze && (we.flags & Jn) === Nn)
            return ac = !1, $M(me, we, Ie);
          (me.flags & Tp) !== Nn ? ac = !0 : ac = !1;
        }
      } else if (ac = !1, ls() && ZC(we)) {
        var tt = we.index, ht = GC();
        BS(we, ht, tt);
      }
      switch (we.lanes = Ir, we.tag) {
        case Re:
          return fM(me, we, we.type, Ie);
        case Zt: {
          var St = we.elementType;
          return cM(me, we, St, Ie);
        }
        case $e: {
          var Nt = we.type, Bt = we.pendingProps, lr = we.elementType === Nt ? Bt : tc(Nt, Bt);
          return Xx(me, we, Nt, lr, Ie);
        }
        case Me: {
          var nr = we.type, _r = we.pendingProps, Er = we.elementType === nr ? _r : tc(nr, _r);
          return FT(me, we, nr, Er, Ie);
        }
        case je:
          return sM(me, we, Ie);
        case ze:
          return uM(me, we, Ie);
        case He:
          return lM(me, we);
        case It:
          return BT(me, we, Ie);
        case Be:
          return kM(me, we, Ie);
        case yt: {
          var Cr = we.type, rn = we.pendingProps, Cn = we.elementType === Cr ? rn : tc(Cr, rn);
          return IT(me, we, Cr, Cn, Ie);
        }
        case qe:
          return oM(me, we, Ie);
        case Ye:
          return aM(me, we, Ie);
        case Ct:
          return iM(me, we, Ie);
        case dt:
          return OM(me, we, Ie);
        case pt:
          return AM(me, we, Ie);
        case Vt: {
          var Bn = we.type, Ro = we.pendingProps, Co = tc(Bn, Ro);
          if (we.type !== we.elementType) {
            var br = Bn.propTypes;
            br && Xl(br, Co, "prop", Fo(Bn));
          }
          return Co = tc(Bn.type, Co), MT(me, we, Bn, Co, Ie);
        }
        case Ut:
          return RT(me, we, we.type, we.pendingProps, Ie);
        case tr: {
          var Ar = we.type, gr = we.pendingProps, qr = we.elementType === Ar ? gr : tc(Ar, gr);
          return dM(me, we, Ar, qr, Ie);
        }
        case hr:
          return HT(me, we, Ie);
        case Ot:
          break;
        case Qe:
          return NT(me, we, Ie);
      }
      throw new Error("Unknown unit of work tag (" + we.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function By(me) {
      me.flags |= go;
    }
    function GT(me) {
      me.flags |= ks, me.flags |= vv;
    }
    var YT, sE, QT, KT;
    YT = function(me, we, Ie, Ne) {
      for (var De = we.child; De !== null; ) {
        if (De.tag === ze || De.tag === He)
          sA(me, De.stateNode);
        else if (De.tag !== Be && De.child !== null) {
          De.child.return = De, De = De.child;
          continue;
        }
        if (De === we)
          return;
        for (; De.sibling === null; ) {
          if (De.return === null || De.return === we)
            return;
          De = De.return;
        }
        De.sibling.return = De.return, De = De.sibling;
      }
    }, sE = function(me, we) {
    }, QT = function(me, we, Ie, Ne, De) {
      var Ze = me.memoizedProps;
      if (Ze !== Ne) {
        var tt = we.stateNode, ht = W1(), St = lA(tt, Ie, Ze, Ne, De, ht);
        we.updateQueue = St, St && By(we);
      }
    }, KT = function(me, we, Ie, Ne) {
      Ie !== Ne && By(we);
    };
    function Ib(me, we) {
      if (!ls())
        switch (me.tailMode) {
          case "hidden": {
            for (var Ie = me.tail, Ne = null; Ie !== null; )
              Ie.alternate !== null && (Ne = Ie), Ie = Ie.sibling;
            Ne === null ? me.tail = null : Ne.sibling = null;
            break;
          }
          case "collapsed": {
            for (var De = me.tail, Ze = null; De !== null; )
              De.alternate !== null && (Ze = De), De = De.sibling;
            Ze === null ? !we && me.tail !== null ? me.tail.sibling = null : me.tail = null : Ze.sibling = null;
            break;
          }
        }
    }
    function hs(me) {
      var we = me.alternate !== null && me.alternate.child === me.child, Ie = Ir, Ne = Nn;
      if (we) {
        if ((me.mode & qn) !== Ln) {
          for (var De = me.selfBaseDuration, Ze = me.child; Ze !== null; )
            Ie = wo(Ie, wo(Ze.lanes, Ze.childLanes)), Ne |= Ze.subtreeFlags & Ri, Ne |= Ze.flags & Ri, De += Ze.treeBaseDuration, Ze = Ze.sibling;
          me.treeBaseDuration = De;
        } else
          for (var tt = me.child; tt !== null; )
            Ie = wo(Ie, wo(tt.lanes, tt.childLanes)), Ne |= tt.subtreeFlags & Ri, Ne |= tt.flags & Ri, tt.return = me, tt = tt.sibling;
        me.subtreeFlags |= Ne;
      } else {
        if ((me.mode & qn) !== Ln) {
          for (var ht = me.actualDuration, St = me.selfBaseDuration, Nt = me.child; Nt !== null; )
            Ie = wo(Ie, wo(Nt.lanes, Nt.childLanes)), Ne |= Nt.subtreeFlags, Ne |= Nt.flags, ht += Nt.actualDuration, St += Nt.treeBaseDuration, Nt = Nt.sibling;
          me.actualDuration = ht, me.treeBaseDuration = St;
        } else
          for (var Bt = me.child; Bt !== null; )
            Ie = wo(Ie, wo(Bt.lanes, Bt.childLanes)), Ne |= Bt.subtreeFlags, Ne |= Bt.flags, Bt.return = me, Bt = Bt.sibling;
        me.subtreeFlags |= Ne;
      }
      return me.childLanes = Ie, we;
    }
    function IM(me, we, Ie) {
      if (X$() && (we.mode & $o) !== Ln && (we.flags & Jn) === Nn)
        return KS(we), Ay(), we.flags |= Fa | Ys | xi, !1;
      var Ne = H0(we);
      if (Ie !== null && Ie.dehydrated !== null)
        if (me === null) {
          if (!Ne)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (Q$(we), hs(we), (we.mode & qn) !== Ln) {
            var De = Ie !== null;
            if (De) {
              var Ze = we.child;
              Ze !== null && (we.treeBaseDuration -= Ze.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Ay(), (we.flags & Jn) === Nn && (we.memoizedState = null), we.flags |= go, hs(we), (we.mode & qn) !== Ln) {
            var tt = Ie !== null;
            if (tt) {
              var ht = we.child;
              ht !== null && (we.treeBaseDuration -= ht.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return XS(), !0;
    }
    function XT(me, we, Ie) {
      var Ne = we.pendingProps;
      switch (f1(we), we.tag) {
        case Re:
        case Zt:
        case Ut:
        case $e:
        case yt:
        case qe:
        case Ye:
        case Ct:
        case pt:
        case Vt:
          return hs(we), null;
        case Me: {
          var De = we.type;
          return Yc(De) && $0(we), hs(we), null;
        }
        case je: {
          var Ze = we.stateNode;
          if (My(we), u1(we), K1(), Ze.pendingContext && (Ze.context = Ze.pendingContext, Ze.pendingContext = null), me === null || me.child === null) {
            var tt = H0(we);
            if (tt)
              By(we);
            else if (me !== null) {
              var ht = me.memoizedState;
              (!ht.isDehydrated || (we.flags & Fa) !== Nn) && (we.flags |= yu, XS());
            }
          }
          return sE(me, we), hs(we), null;
        }
        case ze: {
          Z1(we);
          var St = QP(), Nt = we.type;
          if (me !== null && we.stateNode != null)
            QT(me, we, Nt, Ne, St), me.ref !== we.ref && GT(we);
          else {
            if (!Ne) {
              if (we.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return hs(we), null;
            }
            var Bt = W1(), lr = H0(we);
            if (lr)
              G$(we, St, Bt) && By(we);
            else {
              var nr = eA(Nt, Ne, St, Bt, we);
              YT(nr, we, !1, !1), we.stateNode = nr, uA(nr, Nt, Ne, St) && By(we);
            }
            we.ref !== null && GT(we);
          }
          return hs(we), null;
        }
        case He: {
          var _r = Ne;
          if (me && we.stateNode != null) {
            var Er = me.memoizedProps;
            KT(me, we, Er, _r);
          } else {
            if (typeof _r != "string" && we.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Cr = QP(), rn = W1(), Cn = H0(we);
            Cn ? Y$(we) && By(we) : we.stateNode = yA(_r, Cr, rn, we);
          }
          return hs(we), null;
        }
        case It: {
          Ny(we);
          var Bn = we.memoizedState;
          if (me === null || me.memoizedState !== null && me.memoizedState.dehydrated !== null) {
            var Ro = IM(me, we, Bn);
            if (!Ro)
              return we.flags & xi ? we : null;
          }
          if ((we.flags & Jn) !== Nn)
            return we.lanes = Ie, (we.mode & qn) !== Ln && Vx(we), we;
          var Co = Bn !== null, br = me !== null && me.memoizedState !== null;
          if (Co !== br && Co) {
            var Ar = we.child;
            if (Ar.flags |= Pc, (we.mode & $o) !== Ln) {
              var gr = me === null && (we.memoizedProps.unstable_avoidThisFallback !== !0 || !et);
              gr || G1(rc.current, JP) ? RR() : PE();
            }
          }
          var qr = we.updateQueue;
          if (qr !== null && (we.flags |= go), hs(we), (we.mode & qn) !== Ln && Co) {
            var hn = we.child;
            hn !== null && (we.treeBaseDuration -= hn.treeBaseDuration);
          }
          return null;
        }
        case Be:
          return My(we), sE(me, we), me === null && BC(we.stateNode.containerInfo), hs(we), null;
        case dt:
          var nn = we.type._context;
          return _1(nn, we), hs(we), null;
        case tr: {
          var Kn = we.type;
          return Yc(Kn) && $0(we), hs(we), null;
        }
        case hr: {
          Ny(we);
          var yo = we.memoizedState;
          if (yo === null)
            return hs(we), null;
          var sa = (we.flags & Jn) !== Nn, Yo = yo.rendering;
          if (Yo === null)
            if (sa)
              Ib(yo, !1);
            else {
              var mi = jR() && (me === null || (me.flags & Jn) === Nn);
              if (!mi)
                for (var Qo = we.child; Qo !== null; ) {
                  var ni = uw(Qo);
                  if (ni !== null) {
                    sa = !0, we.flags |= Jn, Ib(yo, !1);
                    var Bs = ni.updateQueue;
                    return Bs !== null && (we.updateQueue = Bs, we.flags |= go), we.subtreeFlags = Nn, gI(we, Ie), Gf(we, Y1(rc.current, _b)), we.child;
                  }
                  Qo = Qo.sibling;
                }
              yo.tail !== null && Ia() > a2() && (we.flags |= Jn, sa = !0, Ib(yo, !1), we.lanes = Cv);
            }
          else {
            if (!sa) {
              var ws = uw(Yo);
              if (ws !== null) {
                we.flags |= Jn, sa = !0;
                var tl = ws.updateQueue;
                if (tl !== null && (we.updateQueue = tl, we.flags |= go), Ib(yo, !0), yo.tail === null && yo.tailMode === "hidden" && !Yo.alternate && !ls())
                  return hs(we), null;
              } else
                Ia() * 2 - yo.renderingStartTime > a2() && Ie !== Ms && (we.flags |= Jn, sa = !0, Ib(yo, !1), we.lanes = Cv);
            }
            if (yo.isBackwards)
              Yo.sibling = we.child, we.child = Yo;
            else {
              var su = yo.last;
              su !== null ? su.sibling = Yo : we.child = Yo, yo.last = Yo;
            }
          }
          if (yo.tail !== null) {
            var uu = yo.tail;
            yo.rendering = uu, yo.tail = uu.sibling, yo.renderingStartTime = Ia(), uu.sibling = null;
            var zs = rc.current;
            return sa ? zs = Y1(zs, _b) : zs = Ry(zs), Gf(we, zs), uu;
          }
          return hs(we), null;
        }
        case Ot:
          break;
        case Qe:
        case at: {
          SE(we);
          var sf = we.memoizedState, Gy = sf !== null;
          if (me !== null) {
            var Zb = me.memoizedState, nd = Zb !== null;
            nd !== Gy && !ot && (we.flags |= Pc);
          }
          return !Gy || (we.mode & $o) === Ln ? hs(we) : Rs(rd, Ms) && (hs(we), we.subtreeFlags & (xa | go) && (we.flags |= Pc)), null;
        }
        case wt:
          return null;
        case bt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + we.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function MM(me, we, Ie) {
      switch (f1(we), we.tag) {
        case Me: {
          var Ne = we.type;
          Yc(Ne) && $0(we);
          var De = we.flags;
          return De & xi ? (we.flags = De & ~xi | Jn, (we.mode & qn) !== Ln && Vx(we), we) : null;
        }
        case je: {
          we.stateNode, My(we), u1(we), K1();
          var Ze = we.flags;
          return (Ze & xi) !== Nn && (Ze & Jn) === Nn ? (we.flags = Ze & ~xi | Jn, we) : null;
        }
        case ze:
          return Z1(we), null;
        case It: {
          Ny(we);
          var tt = we.memoizedState;
          if (tt !== null && tt.dehydrated !== null) {
            if (we.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Ay();
          }
          var ht = we.flags;
          return ht & xi ? (we.flags = ht & ~xi | Jn, (we.mode & qn) !== Ln && Vx(we), we) : null;
        }
        case hr:
          return Ny(we), null;
        case Be:
          return My(we), null;
        case dt:
          var St = we.type._context;
          return _1(St, we), null;
        case Qe:
        case at:
          return SE(we), null;
        case wt:
          return null;
        default:
          return null;
      }
    }
    function JT(me, we, Ie) {
      switch (f1(we), we.tag) {
        case Me: {
          var Ne = we.type.childContextTypes;
          Ne != null && $0(we);
          break;
        }
        case je: {
          we.stateNode, My(we), u1(we), K1();
          break;
        }
        case ze: {
          Z1(we);
          break;
        }
        case Be:
          My(we);
          break;
        case It:
          Ny(we);
          break;
        case hr:
          Ny(we);
          break;
        case dt:
          var De = we.type._context;
          _1(De, we);
          break;
        case Qe:
        case at:
          SE(we);
          break;
      }
    }
    var wk = null;
    wk = /* @__PURE__ */ new Set();
    var Iw = !1, ys = !1, RM = typeof WeakSet == "function" ? WeakSet : Set, wn = null, zy = null, Uy = null;
    function NM(me) {
      _d(null, function() {
        throw me;
      }), mv();
    }
    var jM = function(me, we) {
      if (we.props = me.memoizedProps, we.state = me.memoizedState, me.mode & qn)
        try {
          ed(), we.componentWillUnmount();
        } finally {
          Jc(me);
        }
      else
        we.componentWillUnmount();
    };
    function _k(me, we) {
      try {
        Kf(Bi, me);
      } catch (Ie) {
        Ta(me, we, Ie);
      }
    }
    function uE(me, we, Ie) {
      try {
        jM(me, Ie);
      } catch (Ne) {
        Ta(me, we, Ne);
      }
    }
    function FM(me, we, Ie) {
      try {
        Ie.componentDidMount();
      } catch (Ne) {
        Ta(me, we, Ne);
      }
    }
    function Ik(me, we) {
      try {
        Lk(me);
      } catch (Ie) {
        Ta(me, we, Ie);
      }
    }
    function Vy(me, we) {
      var Ie = me.ref;
      if (Ie !== null)
        if (typeof Ie == "function") {
          var Ne;
          try {
            if (Nr && Dr && me.mode & qn)
              try {
                ed(), Ne = Ie(null);
              } finally {
                Jc(me);
              }
            else
              Ne = Ie(null);
          } catch (De) {
            Ta(me, we, De);
          }
          typeof Ne == "function" && xe("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Gn(me));
        } else
          Ie.current = null;
    }
    function Mw(me, we, Ie) {
      try {
        Ie();
      } catch (Ne) {
        Ta(me, we, Ne);
      }
    }
    var jk = !1;
    function LM(me, we) {
      XO(me.containerInfo), wn = we, DM();
      var Ie = jk;
      return jk = !1, Ie;
    }
    function DM() {
      for (; wn !== null; ) {
        var me = wn, we = me.child;
        (me.subtreeFlags & gf) !== Nn && we !== null ? (we.return = me, wn = we) : BM();
      }
    }
    function BM() {
      for (; wn !== null; ) {
        var me = wn;
        Lo(me);
        try {
          zM(me);
        } catch (Ie) {
          Ta(me, me.return, Ie);
        }
        wa();
        var we = me.sibling;
        if (we !== null) {
          we.return = me.return, wn = we;
          return;
        }
        wn = me.return;
      }
    }
    function zM(me) {
      var we = me.alternate, Ie = me.flags;
      if ((Ie & yu) !== Nn) {
        switch (Lo(me), me.tag) {
          case $e:
          case yt:
          case Ut:
            break;
          case Me: {
            if (we !== null) {
              var Ne = we.memoizedProps, De = we.memoizedState, Ze = me.stateNode;
              me.type === me.elementType && !em && (Ze.props !== me.memoizedProps && xe("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gn(me) || "instance"), Ze.state !== me.memoizedState && xe("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gn(me) || "instance"));
              var tt = Ze.getSnapshotBeforeUpdate(me.elementType === me.type ? Ne : tc(me.type, Ne), De);
              {
                var ht = wk;
                tt === void 0 && !ht.has(me.type) && (ht.add(me.type), xe("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Gn(me)));
              }
              Ze.__reactInternalSnapshotBeforeUpdate = tt;
            }
            break;
          }
          case je: {
            {
              var St = me.stateNode;
              fC(St.containerInfo);
            }
            break;
          }
          case ze:
          case He:
          case Be:
          case tr:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        wa();
      }
    }
    function ic(me, we, Ie) {
      var Ne = we.updateQueue, De = Ne !== null ? Ne.lastEffect : null;
      if (De !== null) {
        var Ze = De.next, tt = Ze;
        do {
          if ((tt.tag & me) === me) {
            var ht = tt.destroy;
            tt.destroy = void 0, ht !== void 0 && ((me & cs) !== Uu ? Tm(we) : (me & Bi) !== Uu && km(we), (me & Qc) !== Uu && Hb(!0), Mw(we, Ie, ht), (me & Qc) !== Uu && Hb(!1), (me & cs) !== Uu ? Og() : (me & Bi) !== Uu && wf());
          }
          tt = tt.next;
        } while (tt !== Ze);
      }
    }
    function Kf(me, we) {
      var Ie = we.updateQueue, Ne = Ie !== null ? Ie.lastEffect : null;
      if (Ne !== null) {
        var De = Ne.next, Ze = De;
        do {
          if ((Ze.tag & me) === me) {
            (me & cs) !== Uu ? kg(we) : (me & Bi) !== Uu && Ag(we);
            var tt = Ze.create;
            (me & Qc) !== Uu && Hb(!0), Ze.destroy = tt(), (me & Qc) !== Uu && Hb(!1), (me & cs) !== Uu ? kv() : (me & Bi) !== Uu && Cg();
            {
              var ht = Ze.destroy;
              if (ht !== void 0 && typeof ht != "function") {
                var St = void 0;
                (Ze.tag & Bi) !== Nn ? St = "useLayoutEffect" : (Ze.tag & Qc) !== Nn ? St = "useInsertionEffect" : St = "useEffect";
                var Nt = void 0;
                ht === null ? Nt = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof ht.then == "function" ? Nt = `

It looks like you wrote ` + St + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + St + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Nt = " You returned: " + ht, xe("%s must not return anything besides a function, which is used for clean-up.%s", St, Nt);
              }
            }
          }
          Ze = Ze.next;
        } while (Ze !== De);
      }
    }
    function UM(me, we) {
      if ((we.flags & go) !== Nn)
        switch (we.tag) {
          case Ct: {
            var Ie = we.stateNode.passiveEffectDuration, Ne = we.memoizedProps, De = Ne.id, Ze = Ne.onPostCommit, tt = PT(), ht = we.alternate === null ? "mount" : "update";
            ST() && (ht = "nested-update"), typeof Ze == "function" && Ze(De, ht, Ie, tt);
            var St = we.return;
            e:
              for (; St !== null; ) {
                switch (St.tag) {
                  case je:
                    var Nt = St.stateNode;
                    Nt.passiveEffectDuration += Ie;
                    break e;
                  case Ct:
                    var Bt = St.stateNode;
                    Bt.passiveEffectDuration += Ie;
                    break e;
                }
                St = St.return;
              }
            break;
          }
        }
    }
    function VM(me, we, Ie, Ne) {
      if ((Ie.flags & rs) !== Nn)
        switch (Ie.tag) {
          case $e:
          case yt:
          case Ut: {
            if (!ys)
              if (Ie.mode & qn)
                try {
                  ed(), Kf(Bi | Di, Ie);
                } finally {
                  Jc(Ie);
                }
              else
                Kf(Bi | Di, Ie);
            break;
          }
          case Me: {
            var De = Ie.stateNode;
            if (Ie.flags & go && !ys)
              if (we === null)
                if (Ie.type === Ie.elementType && !em && (De.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gn(Ie) || "instance"), De.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gn(Ie) || "instance")), Ie.mode & qn)
                  try {
                    ed(), De.componentDidMount();
                  } finally {
                    Jc(Ie);
                  }
                else
                  De.componentDidMount();
              else {
                var Ze = Ie.elementType === Ie.type ? we.memoizedProps : tc(Ie.type, we.memoizedProps), tt = we.memoizedState;
                if (Ie.type === Ie.elementType && !em && (De.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gn(Ie) || "instance"), De.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gn(Ie) || "instance")), Ie.mode & qn)
                  try {
                    ed(), De.componentDidUpdate(Ze, tt, De.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Jc(Ie);
                  }
                else
                  De.componentDidUpdate(Ze, tt, De.__reactInternalSnapshotBeforeUpdate);
              }
            var ht = Ie.updateQueue;
            ht !== null && (Ie.type === Ie.elementType && !em && (De.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gn(Ie) || "instance"), De.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gn(Ie) || "instance")), LP(Ie, ht, De));
            break;
          }
          case je: {
            var St = Ie.updateQueue;
            if (St !== null) {
              var Nt = null;
              if (Ie.child !== null)
                switch (Ie.child.tag) {
                  case ze:
                    Nt = Ie.child.stateNode;
                    break;
                  case Me:
                    Nt = Ie.child.stateNode;
                    break;
                }
              LP(Ie, St, Nt);
            }
            break;
          }
          case ze: {
            var Bt = Ie.stateNode;
            if (we === null && Ie.flags & go) {
              var lr = Ie.type, nr = Ie.memoizedProps;
              BA(Bt, lr, nr);
            }
            break;
          }
          case He:
            break;
          case Be:
            break;
          case Ct: {
            {
              var _r = Ie.memoizedProps, Er = _r.onCommit, Cr = _r.onRender, rn = Ie.stateNode.effectDuration, Cn = PT(), Bn = we === null ? "mount" : "update";
              ST() && (Bn = "nested-update"), typeof Cr == "function" && Cr(Ie.memoizedProps.id, Bn, Ie.actualDuration, Ie.treeBaseDuration, Ie.actualStartTime, Cn);
              {
                typeof Er == "function" && Er(Ie.memoizedProps.id, Bn, rn, Cn), zR(Ie);
                var Ro = Ie.return;
                e:
                  for (; Ro !== null; ) {
                    switch (Ro.tag) {
                      case je:
                        var Co = Ro.stateNode;
                        Co.effectDuration += rn;
                        break e;
                      case Ct:
                        var br = Ro.stateNode;
                        br.effectDuration += rn;
                        break e;
                    }
                    Ro = Ro.return;
                  }
              }
            }
            break;
          }
          case It: {
            KM(me, Ie);
            break;
          }
          case hr:
          case tr:
          case Ot:
          case Qe:
          case at:
          case bt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ys || Ie.flags & ks && Lk(Ie);
    }
    function HM(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          if (me.mode & qn)
            try {
              ed(), _k(me, me.return);
            } finally {
              Jc(me);
            }
          else
            _k(me, me.return);
          break;
        }
        case Me: {
          var we = me.stateNode;
          typeof we.componentDidMount == "function" && FM(me, me.return, we), Ik(me, me.return);
          break;
        }
        case ze: {
          Ik(me, me.return);
          break;
        }
      }
    }
    function qM(me, we) {
      for (var Ie = null, Ne = me; ; ) {
        if (Ne.tag === ze) {
          if (Ie === null) {
            Ie = Ne;
            try {
              var De = Ne.stateNode;
              we ? uC(De) : cC(Ne.stateNode, Ne.memoizedProps);
            } catch (tt) {
              Ta(me, me.return, tt);
            }
          }
        } else if (Ne.tag === He) {
          if (Ie === null)
            try {
              var Ze = Ne.stateNode;
              we ? lC(Ze) : dC(Ze, Ne.memoizedProps);
            } catch (tt) {
              Ta(me, me.return, tt);
            }
        } else if (!((Ne.tag === Qe || Ne.tag === at) && Ne.memoizedState !== null && Ne !== me) && Ne.child !== null) {
          Ne.child.return = Ne, Ne = Ne.child;
          continue;
        }
        if (Ne === me)
          return;
        for (; Ne.sibling === null; ) {
          if (Ne.return === null || Ne.return === me)
            return;
          Ie === Ne && (Ie = null), Ne = Ne.return;
        }
        Ie === Ne && (Ie = null), Ne.sibling.return = Ne.return, Ne = Ne.sibling;
      }
    }
    function Lk(me) {
      var we = me.ref;
      if (we !== null) {
        var Ie = me.stateNode, Ne;
        switch (me.tag) {
          case ze:
            Ne = Ie;
            break;
          default:
            Ne = Ie;
        }
        if (typeof we == "function") {
          var De;
          if (me.mode & qn)
            try {
              ed(), De = we(Ne);
            } finally {
              Jc(me);
            }
          else
            De = we(Ne);
          typeof De == "function" && xe("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Gn(me));
        } else
          we.hasOwnProperty("current") || xe("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Gn(me)), we.current = Ne;
      }
    }
    function WM(me) {
      var we = me.alternate;
      we !== null && (we.return = null), me.return = null;
    }
    function Bk(me) {
      var we = me.alternate;
      we !== null && (me.alternate = null, Bk(we));
      {
        if (me.child = null, me.deletions = null, me.sibling = null, me.tag === ze) {
          var Ie = me.stateNode;
          Ie !== null && VC(Ie);
        }
        me.stateNode = null, me._debugOwner = null, me.return = null, me.dependencies = null, me.memoizedProps = null, me.memoizedState = null, me.pendingProps = null, me.stateNode = null, me.updateQueue = null;
      }
    }
    function ZM(me) {
      for (var we = me.return; we !== null; ) {
        if (zk(we))
          return we;
        we = we.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function zk(me) {
      return me.tag === ze || me.tag === je || me.tag === Be;
    }
    function Vk(me) {
      var we = me;
      e:
        for (; ; ) {
          for (; we.sibling === null; ) {
            if (we.return === null || zk(we.return))
              return null;
            we = we.return;
          }
          for (we.sibling.return = we.return, we = we.sibling; we.tag !== ze && we.tag !== He && we.tag !== er; ) {
            if (we.flags & xa || we.child === null || we.tag === Be)
              continue e;
            we.child.return = we, we = we.child;
          }
          if (!(we.flags & xa))
            return we.stateNode;
        }
    }
    function GM(me) {
      var we = ZM(me);
      switch (we.tag) {
        case ze: {
          var Ie = we.stateNode;
          we.flags & ea && (kS(Ie), we.flags &= ~ea);
          var Ne = Vk(me);
          cE(me, Ne, Ie);
          break;
        }
        case je:
        case Be: {
          var De = we.stateNode.containerInfo, Ze = Vk(me);
          lE(me, Ze, De);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function lE(me, we, Ie) {
      var Ne = me.tag, De = Ne === ze || Ne === He;
      if (De) {
        var Ze = me.stateNode;
        we ? oC(Ie, Ze, we) : rC(Ie, Ze);
      } else if (Ne !== Be) {
        var tt = me.child;
        if (tt !== null) {
          lE(tt, we, Ie);
          for (var ht = tt.sibling; ht !== null; )
            lE(ht, we, Ie), ht = ht.sibling;
        }
      }
    }
    function cE(me, we, Ie) {
      var Ne = me.tag, De = Ne === ze || Ne === He;
      if (De) {
        var Ze = me.stateNode;
        we ? nC(Ie, Ze, we) : tC(Ie, Ze);
      } else if (Ne !== Be) {
        var tt = me.child;
        if (tt !== null) {
          cE(tt, we, Ie);
          for (var ht = tt.sibling; ht !== null; )
            cE(ht, we, Ie), ht = ht.sibling;
        }
      }
    }
    var vs = null, dc = !1;
    function YM(me, we, Ie) {
      {
        var Ne = we;
        e:
          for (; Ne !== null; ) {
            switch (Ne.tag) {
              case ze: {
                vs = Ne.stateNode, dc = !1;
                break e;
              }
              case je: {
                vs = Ne.stateNode.containerInfo, dc = !0;
                break e;
              }
              case Be: {
                vs = Ne.stateNode.containerInfo, dc = !0;
                break e;
              }
            }
            Ne = Ne.return;
          }
        if (vs === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        Hk(me, we, Ie), vs = null, dc = !1;
      }
      WM(Ie);
    }
    function Xf(me, we, Ie) {
      for (var Ne = Ie.child; Ne !== null; )
        Hk(me, we, Ne), Ne = Ne.sibling;
    }
    function Hk(me, we, Ie) {
      switch (Pv(Ie), Ie.tag) {
        case ze:
          ys || Vy(Ie, we);
        case He: {
          {
            var Ne = vs, De = dc;
            vs = null, Xf(me, we, Ie), vs = Ne, dc = De, vs !== null && (dc ? iC(vs, Ie.stateNode) : aC(vs, Ie.stateNode));
          }
          return;
        }
        case er: {
          vs !== null && (dc ? sC(vs, Ie.stateNode) : e1(vs, Ie.stateNode));
          return;
        }
        case Be: {
          {
            var Ze = vs, tt = dc;
            vs = Ie.stateNode.containerInfo, dc = !0, Xf(me, we, Ie), vs = Ze, dc = tt;
          }
          return;
        }
        case $e:
        case yt:
        case Vt:
        case Ut: {
          if (!ys) {
            var ht = Ie.updateQueue;
            if (ht !== null) {
              var St = ht.lastEffect;
              if (St !== null) {
                var Nt = St.next, Bt = Nt;
                do {
                  var lr = Bt, nr = lr.destroy, _r = lr.tag;
                  nr !== void 0 && ((_r & Qc) !== Uu ? Mw(Ie, we, nr) : (_r & Bi) !== Uu && (km(Ie), Ie.mode & qn ? (ed(), Mw(Ie, we, nr), Jc(Ie)) : Mw(Ie, we, nr), wf())), Bt = Bt.next;
                } while (Bt !== Nt);
              }
            }
          }
          Xf(me, we, Ie);
          return;
        }
        case Me: {
          if (!ys) {
            Vy(Ie, we);
            var Er = Ie.stateNode;
            typeof Er.componentWillUnmount == "function" && uE(Ie, we, Er);
          }
          Xf(me, we, Ie);
          return;
        }
        case Ot: {
          Xf(me, we, Ie);
          return;
        }
        case Qe: {
          if (Ie.mode & $o) {
            var Cr = ys;
            ys = Cr || Ie.memoizedState !== null, Xf(me, we, Ie), ys = Cr;
          } else
            Xf(me, we, Ie);
          break;
        }
        default: {
          Xf(me, we, Ie);
          return;
        }
      }
    }
    function QM(me) {
      me.memoizedState;
    }
    function KM(me, we) {
      var Ie = we.memoizedState;
      if (Ie === null) {
        var Ne = we.alternate;
        if (Ne !== null) {
          var De = Ne.memoizedState;
          if (De !== null) {
            var Ze = De.dehydrated;
            Ze !== null && TC(Ze);
          }
        }
      }
    }
    function qk(me) {
      var we = me.updateQueue;
      if (we !== null) {
        me.updateQueue = null;
        var Ie = me.stateNode;
        Ie === null && (Ie = me.stateNode = new RM()), we.forEach(function(Ne) {
          var De = YR.bind(null, me, Ne);
          if (!Ie.has(Ne)) {
            if (Ie.add(Ne), Ni)
              if (zy !== null && Uy !== null)
                Vb(Uy, zy);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            Ne.then(De, De);
          }
        });
      }
    }
    function XM(me, we, Ie) {
      zy = Ie, Uy = me, Lo(we), Gk(we, me), Lo(we), zy = null, Uy = null;
    }
    function fc(me, we, Ie) {
      var Ne = we.deletions;
      if (Ne !== null)
        for (var De = 0; De < Ne.length; De++) {
          var Ze = Ne[De];
          try {
            YM(me, we, Ze);
          } catch (St) {
            Ta(Ze, we, St);
          }
        }
      var tt = Pl();
      if (we.subtreeFlags & Cs)
        for (var ht = we.child; ht !== null; )
          Lo(ht), Gk(ht, me), ht = ht.sibling;
      Lo(tt);
    }
    function Gk(me, we, Ie) {
      var Ne = me.alternate, De = me.flags;
      switch (me.tag) {
        case $e:
        case yt:
        case Vt:
        case Ut: {
          if (fc(we, me), td(me), De & go) {
            try {
              ic(Qc | Di, me, me.return), Kf(Qc | Di, me);
            } catch (Kn) {
              Ta(me, me.return, Kn);
            }
            if (me.mode & qn) {
              try {
                ed(), ic(Bi | Di, me, me.return);
              } catch (Kn) {
                Ta(me, me.return, Kn);
              }
              Jc(me);
            } else
              try {
                ic(Bi | Di, me, me.return);
              } catch (Kn) {
                Ta(me, me.return, Kn);
              }
          }
          return;
        }
        case Me: {
          fc(we, me), td(me), De & ks && Ne !== null && Vy(Ne, Ne.return);
          return;
        }
        case ze: {
          fc(we, me), td(me), De & ks && Ne !== null && Vy(Ne, Ne.return);
          {
            if (me.flags & ea) {
              var Ze = me.stateNode;
              try {
                kS(Ze);
              } catch (Kn) {
                Ta(me, me.return, Kn);
              }
            }
            if (De & go) {
              var tt = me.stateNode;
              if (tt != null) {
                var ht = me.memoizedProps, St = Ne !== null ? Ne.memoizedProps : ht, Nt = me.type, Bt = me.updateQueue;
                if (me.updateQueue = null, Bt !== null)
                  try {
                    qA(tt, Bt, Nt, St, ht, me);
                  } catch (Kn) {
                    Ta(me, me.return, Kn);
                  }
              }
            }
          }
          return;
        }
        case He: {
          if (fc(we, me), td(me), De & go) {
            if (me.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var lr = me.stateNode, nr = me.memoizedProps, _r = Ne !== null ? Ne.memoizedProps : nr;
            try {
              eC(lr, _r, nr);
            } catch (Kn) {
              Ta(me, me.return, Kn);
            }
          }
          return;
        }
        case je: {
          if (fc(we, me), td(me), De & go && Ne !== null) {
            var Er = Ne.memoizedState;
            if (Er.isDehydrated)
              try {
                PC(we.containerInfo);
              } catch (Kn) {
                Ta(me, me.return, Kn);
              }
          }
          return;
        }
        case Be: {
          fc(we, me), td(me);
          return;
        }
        case It: {
          fc(we, me), td(me);
          var Cr = me.child;
          if (Cr.flags & Pc) {
            var rn = Cr.stateNode, Cn = Cr.memoizedState, Bn = Cn !== null;
            if (rn.isHidden = Bn, Bn) {
              var Ro = Cr.alternate !== null && Cr.alternate.memoizedState !== null;
              Ro || MR();
            }
          }
          if (De & go) {
            try {
              QM(me);
            } catch (Kn) {
              Ta(me, me.return, Kn);
            }
            qk(me);
          }
          return;
        }
        case Qe: {
          var Co = Ne !== null && Ne.memoizedState !== null;
          if (me.mode & $o) {
            var br = ys;
            ys = br || Co, fc(we, me), ys = br;
          } else
            fc(we, me);
          if (td(me), De & Pc) {
            var Ar = me.stateNode, gr = me.memoizedState, qr = gr !== null, hn = me;
            if (Ar.isHidden = qr, qr && !Co && (hn.mode & $o) !== Ln) {
              wn = hn;
              for (var nn = hn.child; nn !== null; )
                wn = nn, eR(nn), nn = nn.sibling;
            }
            qM(hn, qr);
          }
          return;
        }
        case hr: {
          fc(we, me), td(me), De & go && qk(me);
          return;
        }
        case Ot:
          return;
        default: {
          fc(we, me), td(me);
          return;
        }
      }
    }
    function td(me) {
      var we = me.flags;
      if (we & xa) {
        try {
          GM(me);
        } catch (Ie) {
          Ta(me, me.return, Ie);
        }
        me.flags &= ~xa;
      }
      we & vu && (me.flags &= ~vu);
    }
    function JM(me, we, Ie) {
      zy = Ie, Uy = we, wn = me, Qk(me, we, Ie), zy = null, Uy = null;
    }
    function Qk(me, we, Ie) {
      for (var Ne = (me.mode & $o) !== Ln; wn !== null; ) {
        var De = wn, Ze = De.child;
        if (De.tag === Qe && Ne) {
          var tt = De.memoizedState !== null, ht = tt || Iw;
          if (ht) {
            dE(me, we, Ie);
            continue;
          } else {
            var St = De.alternate, Nt = St !== null && St.memoizedState !== null, Bt = Nt || ys, lr = Iw, nr = ys;
            Iw = ht, ys = Bt, ys && !nr && (wn = De, tR(De));
            for (var _r = Ze; _r !== null; )
              wn = _r, Qk(_r, we, Ie), _r = _r.sibling;
            wn = De, Iw = lr, ys = nr, dE(me, we, Ie);
            continue;
          }
        }
        (De.subtreeFlags & rs) !== Nn && Ze !== null ? (Ze.return = De, wn = Ze) : dE(me, we, Ie);
      }
    }
    function dE(me, we, Ie) {
      for (; wn !== null; ) {
        var Ne = wn;
        if ((Ne.flags & rs) !== Nn) {
          var De = Ne.alternate;
          Lo(Ne);
          try {
            VM(we, De, Ne, Ie);
          } catch (tt) {
            Ta(Ne, Ne.return, tt);
          }
          wa();
        }
        if (Ne === me) {
          wn = null;
          return;
        }
        var Ze = Ne.sibling;
        if (Ze !== null) {
          Ze.return = Ne.return, wn = Ze;
          return;
        }
        wn = Ne.return;
      }
    }
    function eR(me) {
      for (; wn !== null; ) {
        var we = wn, Ie = we.child;
        switch (we.tag) {
          case $e:
          case yt:
          case Vt:
          case Ut: {
            if (we.mode & qn)
              try {
                ed(), ic(Bi, we, we.return);
              } finally {
                Jc(we);
              }
            else
              ic(Bi, we, we.return);
            break;
          }
          case Me: {
            Vy(we, we.return);
            var Ne = we.stateNode;
            typeof Ne.componentWillUnmount == "function" && uE(we, we.return, Ne);
            break;
          }
          case ze: {
            Vy(we, we.return);
            break;
          }
          case Qe: {
            var De = we.memoizedState !== null;
            if (De) {
              Kk(me);
              continue;
            }
            break;
          }
        }
        Ie !== null ? (Ie.return = we, wn = Ie) : Kk(me);
      }
    }
    function Kk(me) {
      for (; wn !== null; ) {
        var we = wn;
        if (we === me) {
          wn = null;
          return;
        }
        var Ie = we.sibling;
        if (Ie !== null) {
          Ie.return = we.return, wn = Ie;
          return;
        }
        wn = we.return;
      }
    }
    function tR(me) {
      for (; wn !== null; ) {
        var we = wn, Ie = we.child;
        if (we.tag === Qe) {
          var Ne = we.memoizedState !== null;
          if (Ne) {
            Jk(me);
            continue;
          }
        }
        Ie !== null ? (Ie.return = we, wn = Ie) : Jk(me);
      }
    }
    function Jk(me) {
      for (; wn !== null; ) {
        var we = wn;
        Lo(we);
        try {
          HM(we);
        } catch (Ne) {
          Ta(we, we.return, Ne);
        }
        if (wa(), we === me) {
          wn = null;
          return;
        }
        var Ie = we.sibling;
        if (Ie !== null) {
          Ie.return = we.return, wn = Ie;
          return;
        }
        wn = we.return;
      }
    }
    function rR(me, we, Ie, Ne) {
      wn = we, nR(we, me, Ie, Ne);
    }
    function nR(me, we, Ie, Ne) {
      for (; wn !== null; ) {
        var De = wn, Ze = De.child;
        (De.subtreeFlags & bu) !== Nn && Ze !== null ? (Ze.return = De, wn = Ze) : oR(me, we, Ie, Ne);
      }
    }
    function oR(me, we, Ie, Ne) {
      for (; wn !== null; ) {
        var De = wn;
        if ((De.flags & Oa) !== Nn) {
          Lo(De);
          try {
            aR(we, De, Ie, Ne);
          } catch (tt) {
            Ta(De, De.return, tt);
          }
          wa();
        }
        if (De === me) {
          wn = null;
          return;
        }
        var Ze = De.sibling;
        if (Ze !== null) {
          Ze.return = De.return, wn = Ze;
          return;
        }
        wn = De.return;
      }
    }
    function aR(me, we, Ie, Ne) {
      switch (we.tag) {
        case $e:
        case yt:
        case Ut: {
          if (we.mode & qn) {
            Ux();
            try {
              Kf(cs | Di, we);
            } finally {
              zx(we);
            }
          } else
            Kf(cs | Di, we);
          break;
        }
      }
    }
    function iR(me) {
      wn = me, sR();
    }
    function sR() {
      for (; wn !== null; ) {
        var me = wn, we = me.child;
        if ((wn.flags & Xo) !== Nn) {
          var Ie = me.deletions;
          if (Ie !== null) {
            for (var Ne = 0; Ne < Ie.length; Ne++) {
              var De = Ie[Ne];
              wn = De, cR(De, me);
            }
            {
              var Ze = me.alternate;
              if (Ze !== null) {
                var tt = Ze.child;
                if (tt !== null) {
                  Ze.child = null;
                  do {
                    var ht = tt.sibling;
                    tt.sibling = null, tt = ht;
                  } while (tt !== null);
                }
              }
            }
            wn = me;
          }
        }
        (me.subtreeFlags & bu) !== Nn && we !== null ? (we.return = me, wn = we) : uR();
      }
    }
    function uR() {
      for (; wn !== null; ) {
        var me = wn;
        (me.flags & Oa) !== Nn && (Lo(me), lR(me), wa());
        var we = me.sibling;
        if (we !== null) {
          we.return = me.return, wn = we;
          return;
        }
        wn = me.return;
      }
    }
    function lR(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          me.mode & qn ? (Ux(), ic(cs | Di, me, me.return), zx(me)) : ic(cs | Di, me, me.return);
          break;
        }
      }
    }
    function cR(me, we) {
      for (; wn !== null; ) {
        var Ie = wn;
        Lo(Ie), fR(Ie, we), wa();
        var Ne = Ie.child;
        Ne !== null ? (Ne.return = Ie, wn = Ne) : dR(me);
      }
    }
    function dR(me) {
      for (; wn !== null; ) {
        var we = wn, Ie = we.sibling, Ne = we.return;
        if (Bk(we), we === me) {
          wn = null;
          return;
        }
        if (Ie !== null) {
          Ie.return = Ne, wn = Ie;
          return;
        }
        wn = Ne;
      }
    }
    function fR(me, we) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          me.mode & qn ? (Ux(), ic(cs, me, we), zx(me)) : ic(cs, me, we);
          break;
        }
      }
    }
    function pR(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          try {
            Kf(Bi | Di, me);
          } catch (Ie) {
            Ta(me, me.return, Ie);
          }
          break;
        }
        case Me: {
          var we = me.stateNode;
          try {
            we.componentDidMount();
          } catch (Ie) {
            Ta(me, me.return, Ie);
          }
          break;
        }
      }
    }
    function hR(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          try {
            Kf(cs | Di, me);
          } catch (we) {
            Ta(me, me.return, we);
          }
          break;
        }
      }
    }
    function mR(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut: {
          try {
            ic(Bi | Di, me, me.return);
          } catch (Ie) {
            Ta(me, me.return, Ie);
          }
          break;
        }
        case Me: {
          var we = me.stateNode;
          typeof we.componentWillUnmount == "function" && uE(me, me.return, we);
          break;
        }
      }
    }
    function yR(me) {
      switch (me.tag) {
        case $e:
        case yt:
        case Ut:
          try {
            ic(cs | Di, me, me.return);
          } catch (we) {
            Ta(me, me.return, we);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Mb = Symbol.for;
      Mb("selector.component"), Mb("selector.has_pseudo_class"), Mb("selector.role"), Mb("selector.test_id"), Mb("selector.text");
    }
    var vR = [];
    function bR() {
      vR.forEach(function(me) {
        return me();
      });
    }
    var gR = fe.ReactCurrentActQueue;
    function wR(me) {
      {
        var we = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, Ie = typeof jest < "u";
        return Ie && we !== !1;
      }
    }
    function e2() {
      {
        var me = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !me && gR.current !== null && xe("The current testing environment is not configured to support act(...)"), me;
      }
    }
    var _R = Math.ceil, fE = fe.ReactCurrentDispatcher, pE = fe.ReactCurrentOwner, bs = fe.ReactCurrentBatchConfig, pc = fe.ReactCurrentActQueue, Hi = 0, t2 = 1, gs = 2, wl = 4, tf = 0, Rb = 1, tm = 2, Rw = 3, Nb = 4, r2 = 5, hE = 6, Vo = Hi, au = null, Ha = null, qi = Ir, rd = Ir, mE = Uf(Ir), Wi = tf, jb = null, Nw = Ir, Fb = Ir, jw = Ir, Lb = null, Vu = null, yE = 0, n2 = 500, o2 = 1 / 0, xR = 500, rf = null;
    function Db() {
      o2 = Ia() + xR;
    }
    function a2() {
      return o2;
    }
    var Fw = !1, vE = null, Hy = null, rm = !1, Jf = null, Bb = Ir, bE = [], gE = null, ER = 50, zb = 0, wE = null, _E = !1, Lw = !1, SR = 50, qy = 0, Dw = null, Bw = la, zw = Ir, i2 = !1;
    function Uw() {
      return au;
    }
    function iu() {
      return (Vo & (gs | wl)) !== Hi ? Ia() : (Bw !== la || (Bw = Ia()), Bw);
    }
    function ep(me) {
      var we = me.mode;
      if ((we & $o) === Ln)
        return Wn;
      if ((Vo & gs) !== Hi && qi !== Ir)
        return di(qi);
      var Ie = rI() !== tI;
      if (Ie) {
        if (bs.transition !== null) {
          var Ne = bs.transition;
          Ne._updatedFibers || (Ne._updatedFibers = /* @__PURE__ */ new Set()), Ne._updatedFibers.add(me);
        }
        return zw === Uo && (zw = Mv()), zw;
      }
      var De = eu();
      if (De !== Uo)
        return De;
      var Ze = _A();
      return Ze;
    }
    function PR(me) {
      var we = me.mode;
      return (we & $o) === Ln ? Wn : E_();
    }
    function Gi(me, we, Ie, Ne) {
      KR(), i2 && xe("useInsertionEffect must not schedule updates."), _E && (Lw = !0), Of(me, Ie, Ne), (Vo & gs) !== Ir && me === au ? eN(we) : (Ni && Lg(me, we, Ie), tN(we), me === au && ((Vo & gs) === Hi && (Fb = wo(Fb, Ie)), Wi === Nb && tp(me, qi)), Hu(me, Ne), Ie === Wn && Vo === Hi && (we.mode & $o) === Ln && !pc.isBatchingLegacy && (Db(), DS()));
    }
    function TR(me, we, Ie) {
      var Ne = me.current;
      Ne.lanes = we, Of(me, we, Ie), Hu(me, Ie);
    }
    function kR(me) {
      return (Vo & gs) !== Hi;
    }
    function Hu(me, we) {
      var Ie = me.callbackNode;
      w_(me, we);
      var Ne = Mp(me, me === au ? qi : Ir);
      if (Ne === Ir) {
        Ie !== null && S2(Ie), me.callbackNode = null, me.callbackPriority = Uo;
        return;
      }
      var De = ti(Ne), Ze = me.callbackPriority;
      if (Ze === De && !(pc.current !== null && Ie !== OE)) {
        Ie == null && Ze !== Wn && xe("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      Ie != null && S2(Ie);
      var tt;
      if (De === Wn)
        me.tag === Vf ? (pc.isBatchingLegacy !== null && (pc.didScheduleLegacyUpdate = !0), WC(d2.bind(null, me))) : LS(d2.bind(null, me)), pc.current !== null ? pc.current.push(Hf) : $A(function() {
          (Vo & (gs | wl)) === Hi && Hf();
        }), tt = null;
      else {
        var ht;
        switch (Bg(Ne)) {
          case Ns:
            ht = Em;
            break;
          case Pu:
            ht = Xs;
            break;
          case ji:
            ht = dl;
            break;
          case ry:
            ht = Ac;
            break;
          default:
            ht = dl;
            break;
        }
        tt = AE(ht, u2.bind(null, me));
      }
      me.callbackPriority = De, me.callbackNode = tt;
    }
    function u2(me, we) {
      if (GI(), Bw = la, zw = Ir, (Vo & (gs | wl)) !== Hi)
        throw new Error("Should not already be working.");
      var Ie = me.callbackNode, Ne = af();
      if (Ne && me.callbackNode !== Ie)
        return null;
      var De = Mp(me, me === au ? qi : Ir);
      if (De === Ir)
        return null;
      var Ze = !Np(me, De) && !jg(me, De) && !we, tt = Ze ? LR(me, De) : Hw(me, De);
      if (tt !== tf) {
        if (tt === tm) {
          var ht = $v(me);
          ht !== Ir && (De = ht, tt = xE(me, ht));
        }
        if (tt === Rb) {
          var St = jb;
          throw nm(me, Ir), tp(me, De), Hu(me, Ia()), St;
        }
        if (tt === hE)
          tp(me, De);
        else {
          var Nt = !Np(me, De), Bt = me.current.alternate;
          if (Nt && !CR(Bt)) {
            if (tt = Hw(me, De), tt === tm) {
              var lr = $v(me);
              lr !== Ir && (De = lr, tt = xE(me, lr));
            }
            if (tt === Rb) {
              var nr = jb;
              throw nm(me, Ir), tp(me, De), Hu(me, Ia()), nr;
            }
          }
          me.finishedWork = Bt, me.finishedLanes = De, OR(me, tt, De);
        }
      }
      return Hu(me, Ia()), me.callbackNode === Ie ? u2.bind(null, me) : null;
    }
    function xE(me, we) {
      var Ie = Lb;
      if (Nd(me)) {
        var Ne = nm(me, we);
        Ne.flags |= Fa, DC(me.containerInfo);
      }
      var De = Hw(me, we);
      if (De !== tm) {
        var Ze = Vu;
        Vu = Ie, Ze !== null && c2(Ze);
      }
      return De;
    }
    function c2(me) {
      Vu === null ? Vu = me : Vu.push.apply(Vu, me);
    }
    function OR(me, we, Ie) {
      switch (we) {
        case tf:
        case Rb:
          throw new Error("Root did not complete. This is a bug in React.");
        case tm: {
          om(me, Vu, rf);
          break;
        }
        case Rw: {
          if (tp(me, Ie), Gm(Ie) && !P2()) {
            var Ne = yE + n2 - Ia();
            if (Ne > 10) {
              var De = Mp(me, Ir);
              if (De !== Ir)
                break;
              var Ze = me.suspendedLanes;
              if (!Rd(Ze, Ie)) {
                iu(), Km(me, Ze);
                break;
              }
              me.timeoutHandle = X_(om.bind(null, me, Vu, rf), Ne);
              break;
            }
          }
          om(me, Vu, rf);
          break;
        }
        case Nb: {
          if (tp(me, Ie), Ng(Ie))
            break;
          if (!P2()) {
            var tt = Rg(me, Ie), ht = tt, St = Ia() - ht, Nt = QR(St) - St;
            if (Nt > 10) {
              me.timeoutHandle = X_(om.bind(null, me, Vu, rf), Nt);
              break;
            }
          }
          om(me, Vu, rf);
          break;
        }
        case r2: {
          om(me, Vu, rf);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function CR(me) {
      for (var we = me; ; ) {
        if (we.flags & Pp) {
          var Ie = we.updateQueue;
          if (Ie !== null) {
            var Ne = Ie.stores;
            if (Ne !== null)
              for (var De = 0; De < Ne.length; De++) {
                var Ze = Ne[De], tt = Ze.getSnapshot, ht = Ze.value;
                try {
                  if (!an(tt(), ht))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var St = we.child;
        if (we.subtreeFlags & Pp && St !== null) {
          St.return = we, we = St;
          continue;
        }
        if (we === me)
          return !0;
        for (; we.sibling === null; ) {
          if (we.return === null || we.return === me)
            return !0;
          we = we.return;
        }
        we.sibling.return = we.return, we = we.sibling;
      }
      return !0;
    }
    function tp(me, we) {
      we = kf(we, jw), we = kf(we, Fb), jv(me, we);
    }
    function d2(me) {
      if (YI(), (Vo & (gs | wl)) !== Hi)
        throw new Error("Should not already be working.");
      af();
      var we = Mp(me, Ir);
      if (!Rs(we, Wn))
        return Hu(me, Ia()), null;
      var Ie = Hw(me, we);
      if (me.tag !== Vf && Ie === tm) {
        var Ne = $v(me);
        Ne !== Ir && (we = Ne, Ie = xE(me, Ne));
      }
      if (Ie === Rb) {
        var De = jb;
        throw nm(me, Ir), tp(me, we), Hu(me, Ia()), De;
      }
      if (Ie === hE)
        throw new Error("Root did not complete. This is a bug in React.");
      var Ze = me.current.alternate;
      return me.finishedWork = Ze, me.finishedLanes = we, om(me, Vu, rf), Hu(me, Ia()), null;
    }
    function $R(me, we) {
      we !== Ir && (jp(me, wo(we, Wn)), Hu(me, Ia()), (Vo & (gs | wl)) === Hi && (Db(), Hf()));
    }
    function EE(me, we) {
      var Ie = Vo;
      Vo |= t2;
      try {
        return me(we);
      } finally {
        Vo = Ie, Vo === Hi && !pc.isBatchingLegacy && (Db(), DS());
      }
    }
    function IR(me, we, Ie, Ne, De) {
      var Ze = eu(), tt = bs.transition;
      try {
        return bs.transition = null, fi(Ns), me(we, Ie, Ne, De);
      } finally {
        fi(Ze), bs.transition = tt, Vo === Hi && Db();
      }
    }
    function nf(me) {
      Jf !== null && Jf.tag === Vf && (Vo & (gs | wl)) === Hi && af();
      var we = Vo;
      Vo |= t2;
      var Ie = bs.transition, Ne = eu();
      try {
        return bs.transition = null, fi(Ns), me ? me() : void 0;
      } finally {
        fi(Ne), bs.transition = Ie, Vo = we, (Vo & (gs | wl)) === Hi && Hf();
      }
    }
    function f2() {
      return (Vo & (gs | wl)) !== Hi;
    }
    function Vw(me, we) {
      Ls(mE, rd, me), rd = wo(rd, we);
    }
    function SE(me) {
      rd = mE.current, Fs(mE, me);
    }
    function nm(me, we) {
      me.finishedWork = null, me.finishedLanes = Ir;
      var Ie = me.timeoutHandle;
      if (Ie !== J_ && (me.timeoutHandle = J_, OA(Ie)), Ha !== null)
        for (var Ne = Ha.return; Ne !== null; ) {
          var De = Ne.alternate;
          JT(De, Ne), Ne = Ne.return;
        }
      au = me;
      var Ze = am(me.current, null);
      return Ha = Ze, qi = rd = we, Wi = tf, jb = null, Nw = Ir, Fb = Ir, jw = Ir, Lb = null, Vu = null, iI(), ec.discardPendingWarnings(), Ze;
    }
    function p2(me, we) {
      do {
        var Ie = Ha;
        try {
          if (Y0(), tT(), wa(), pE.current = null, Ie === null || Ie.return === null) {
            Wi = Rb, jb = we, Ha = null;
            return;
          }
          if (Nr && Ie.mode & qn && Ow(Ie, !0), dr)
            if (Ed(), we !== null && typeof we == "object" && typeof we.then == "function") {
              var Ne = we;
              $g(Ie, Ne, qi);
            } else
              Om(Ie, we, qi);
          tM(me, Ie.return, Ie, we, qi), v2(Ie);
        } catch (De) {
          we = De, Ha === Ie && Ie !== null ? (Ie = Ie.return, Ha = Ie) : Ie = Ha;
          continue;
        }
        return;
      } while (!0);
    }
    function h2() {
      var me = fE.current;
      return fE.current = Ew, me === null ? Ew : me;
    }
    function m2(me) {
      fE.current = me;
    }
    function MR() {
      yE = Ia();
    }
    function Ub(me) {
      Nw = wo(me, Nw);
    }
    function RR() {
      Wi === tf && (Wi = Rw);
    }
    function PE() {
      (Wi === tf || Wi === Rw || Wi === tm) && (Wi = Nb), au !== null && (Rp(Nw) || Rp(Fb)) && tp(au, qi);
    }
    function NR(me) {
      Wi !== Nb && (Wi = tm), Lb === null ? Lb = [me] : Lb.push(me);
    }
    function jR() {
      return Wi === tf;
    }
    function Hw(me, we) {
      var Ie = Vo;
      Vo |= gs;
      var Ne = h2();
      if (au !== me || qi !== we) {
        if (Ni) {
          var De = me.memoizedUpdaters;
          De.size > 0 && (Vb(me, qi), De.clear()), Fv(me, we);
        }
        rf = ty(), nm(me, we);
      }
      Qu(we);
      do
        try {
          FR();
          break;
        } catch (Ze) {
          p2(me, Ze);
        }
      while (!0);
      if (Y0(), Vo = Ie, m2(Ne), Ha !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return xf(), au = null, qi = Ir, Wi;
    }
    function FR() {
      for (; Ha !== null; )
        y2(Ha);
    }
    function LR(me, we) {
      var Ie = Vo;
      Vo |= gs;
      var Ne = h2();
      if (au !== me || qi !== we) {
        if (Ni) {
          var De = me.memoizedUpdaters;
          De.size > 0 && (Vb(me, qi), De.clear()), Fv(me, we);
        }
        rf = ty(), Db(), nm(me, we);
      }
      Qu(we);
      do
        try {
          DR();
          break;
        } catch (Ze) {
          p2(me, Ze);
        }
      while (!0);
      return Y0(), m2(Ne), Vo = Ie, Ha !== null ? (Ap(), tf) : (xf(), au = null, qi = Ir, Wi);
    }
    function DR() {
      for (; Ha !== null && !xm(); )
        y2(Ha);
    }
    function y2(me) {
      var we = me.alternate;
      Lo(me);
      var Ie;
      (me.mode & qn) !== Ln ? (Bx(me), Ie = TE(we, me, rd), Ow(me, !0)) : Ie = TE(we, me, rd), wa(), me.memoizedProps = me.pendingProps, Ie === null ? v2(me) : Ha = Ie, pE.current = null;
    }
    function v2(me) {
      var we = me;
      do {
        var Ie = we.alternate, Ne = we.return;
        if ((we.flags & Ys) === Nn) {
          Lo(we);
          var De = void 0;
          if ((we.mode & qn) === Ln ? De = XT(Ie, we, rd) : (Bx(we), De = XT(Ie, we, rd), Ow(we, !1)), wa(), De !== null) {
            Ha = De;
            return;
          }
        } else {
          var Ze = MM(Ie, we);
          if (Ze !== null) {
            Ze.flags &= xg, Ha = Ze;
            return;
          }
          if ((we.mode & qn) !== Ln) {
            Ow(we, !1);
            for (var tt = we.actualDuration, ht = we.child; ht !== null; )
              tt += ht.actualDuration, ht = ht.sibling;
            we.actualDuration = tt;
          }
          if (Ne !== null)
            Ne.flags |= Ys, Ne.subtreeFlags = Nn, Ne.deletions = null;
          else {
            Wi = hE, Ha = null;
            return;
          }
        }
        var St = we.sibling;
        if (St !== null) {
          Ha = St;
          return;
        }
        we = Ne, Ha = we;
      } while (we !== null);
      Wi === tf && (Wi = r2);
    }
    function om(me, we, Ie) {
      var Ne = eu(), De = bs.transition;
      try {
        bs.transition = null, fi(Ns), BR(me, we, Ie, Ne);
      } finally {
        bs.transition = De, fi(Ne);
      }
      return null;
    }
    function BR(me, we, Ie, Ne) {
      do
        af();
      while (Jf !== null);
      if (XR(), (Vo & (gs | wl)) !== Hi)
        throw new Error("Should not already be working.");
      var De = me.finishedWork, Ze = me.finishedLanes;
      if (Pm(Ze), De === null)
        return Tv(), null;
      if (Ze === Ir && xe("root.finishedLanes should not be empty during a commit. This is a bug in React."), me.finishedWork = null, me.finishedLanes = Ir, De === me.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      me.callbackNode = null, me.callbackPriority = Uo;
      var tt = wo(De.lanes, De.childLanes);
      Fg(me, tt), me === au && (au = null, Ha = null, qi = Ir), ((De.subtreeFlags & bu) !== Nn || (De.flags & bu) !== Nn) && (rm || (rm = !0, gE = Ie, AE(dl, function() {
        return af(), null;
      })));
      var ht = (De.subtreeFlags & (gf | Cs | rs | bu)) !== Nn, St = (De.flags & (gf | Cs | rs | bu)) !== Nn;
      if (ht || St) {
        var Nt = bs.transition;
        bs.transition = null;
        var Bt = eu();
        fi(Ns);
        var lr = Vo;
        Vo |= wl, pE.current = null, LM(me, De), TT(), XM(me, De, Ze), JO(me.containerInfo), me.current = De, Ig(Ze), JM(De, me, Ze), _f(), Pg(), Vo = lr, fi(Bt), bs.transition = Nt;
      } else
        me.current = De, TT();
      var nr = rm;
      if (rm ? (rm = !1, Jf = me, Bb = Ze) : (qy = 0, Dw = null), tt = me.pendingLanes, tt === Ir && (Hy = null), nr || _2(me.current, !1), Vl(De.stateNode, Ne), Ni && me.memoizedUpdaters.clear(), bR(), Hu(me, Ia()), we !== null)
        for (var _r = me.onRecoverableError, Er = 0; Er < we.length; Er++) {
          var Cr = we[Er], rn = Cr.stack, Cn = Cr.digest;
          _r(Cr.value, { componentStack: rn, digest: Cn });
        }
      if (Fw) {
        Fw = !1;
        var Bn = vE;
        throw vE = null, Bn;
      }
      return Rs(Bb, Wn) && me.tag !== Vf && af(), tt = me.pendingLanes, Rs(tt, Wn) ? (WI(), me === wE ? zb++ : (zb = 0, wE = me)) : zb = 0, Hf(), Tv(), null;
    }
    function af() {
      if (Jf !== null) {
        var me = Bg(Bb), we = ns(ji, me), Ie = bs.transition, Ne = eu();
        try {
          return bs.transition = null, fi(we), UR();
        } finally {
          fi(Ne), bs.transition = Ie;
        }
      }
      return !1;
    }
    function zR(me) {
      bE.push(me), rm || (rm = !0, AE(dl, function() {
        return af(), null;
      }));
    }
    function UR() {
      if (Jf === null)
        return !1;
      var me = gE;
      gE = null;
      var we = Jf, Ie = Bb;
      if (Jf = null, Bb = Ir, (Vo & (gs | wl)) !== Hi)
        throw new Error("Cannot flush passive effects while already rendering.");
      _E = !0, Lw = !1, Mg(Ie);
      var Ne = Vo;
      Vo |= wl, iR(we.current), rR(we, we.current, Ie, me);
      {
        var De = bE;
        bE = [];
        for (var Ze = 0; Ze < De.length; Ze++) {
          var tt = De[Ze];
          UM(we, tt);
        }
      }
      kp(), _2(we.current, !0), Vo = Ne, Hf(), Lw ? we === Dw ? qy++ : (qy = 0, Dw = we) : qy = 0, _E = !1, Lw = !1, Ic(we);
      {
        var ht = we.current.stateNode;
        ht.effectDuration = 0, ht.passiveEffectDuration = 0;
      }
      return !0;
    }
    function b2(me) {
      return Hy !== null && Hy.has(me);
    }
    function VR(me) {
      Hy === null ? Hy = /* @__PURE__ */ new Set([me]) : Hy.add(me);
    }
    function HR(me) {
      Fw || (Fw = !0, vE = me);
    }
    var qR = HR;
    function g2(me, we, Ie) {
      var Ne = Jh(Ie, we), De = OT(me, Ne, Wn), Ze = Wf(me, De, Wn), tt = iu();
      Ze !== null && (Of(Ze, Wn, tt), Hu(Ze, tt));
    }
    function Ta(me, we, Ie) {
      if (NM(Ie), Hb(!1), me.tag === je) {
        g2(me, me, Ie);
        return;
      }
      var Ne = null;
      for (Ne = we; Ne !== null; ) {
        if (Ne.tag === je) {
          g2(Ne, me, Ie);
          return;
        } else if (Ne.tag === Me) {
          var De = Ne.type, Ze = Ne.stateNode;
          if (typeof De.getDerivedStateFromError == "function" || typeof Ze.componentDidCatch == "function" && !b2(Ze)) {
            var tt = Jh(Ie, me), ht = Wx(Ne, tt, Wn), St = Wf(Ne, ht, Wn), Nt = iu();
            St !== null && (Of(St, Wn, Nt), Hu(St, Nt));
            return;
          }
        }
        Ne = Ne.return;
      }
      xe(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, Ie);
    }
    function WR(me, we, Ie) {
      var Ne = me.pingCache;
      Ne !== null && Ne.delete(we);
      var De = iu();
      Km(me, Ie), rN(me), au === me && Rd(qi, Ie) && (Wi === Nb || Wi === Rw && Gm(qi) && Ia() - yE < n2 ? nm(me, Ir) : jw = wo(jw, Ie)), Hu(me, De);
    }
    function w2(me, we) {
      we === Uo && (we = PR(me));
      var Ie = iu(), Ne = zu(me, we);
      Ne !== null && (Of(Ne, we, Ie), Hu(Ne, Ie));
    }
    function ZR(me) {
      var we = me.memoizedState, Ie = Uo;
      we !== null && (Ie = we.retryLane), w2(me, Ie);
    }
    function YR(me, we) {
      var Ie = Uo, Ne;
      switch (me.tag) {
        case It:
          Ne = me.stateNode;
          var De = me.memoizedState;
          De !== null && (Ie = De.retryLane);
          break;
        case hr:
          Ne = me.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      Ne !== null && Ne.delete(we), w2(me, Ie);
    }
    function QR(me) {
      return me < 120 ? 120 : me < 480 ? 480 : me < 1080 ? 1080 : me < 1920 ? 1920 : me < 3e3 ? 3e3 : me < 4320 ? 4320 : _R(me / 1960) * 1960;
    }
    function KR() {
      if (zb > ER)
        throw zb = 0, wE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      qy > SR && (qy = 0, Dw = null, xe("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function XR() {
      ec.flushLegacyContextWarning(), ec.flushPendingUnsafeLifecycleWarnings();
    }
    function _2(me, we) {
      Lo(me), qw(me, As, mR), we && qw(me, xd, yR), qw(me, As, pR), we && qw(me, xd, hR), wa();
    }
    function qw(me, we, Ie) {
      for (var Ne = me, De = null; Ne !== null; ) {
        var Ze = Ne.subtreeFlags & we;
        Ne !== De && Ne.child !== null && Ze !== Nn ? Ne = Ne.child : ((Ne.flags & we) !== Nn && Ie(Ne), Ne.sibling !== null ? Ne = Ne.sibling : Ne = De = Ne.return);
      }
    }
    var Ww = null;
    function x2(me) {
      {
        if ((Vo & gs) !== Hi || !(me.mode & $o))
          return;
        var we = me.tag;
        if (we !== Re && we !== je && we !== Me && we !== $e && we !== yt && we !== Vt && we !== Ut)
          return;
        var Ie = Gn(me) || "ReactComponent";
        if (Ww !== null) {
          if (Ww.has(Ie))
            return;
          Ww.add(Ie);
        } else
          Ww = /* @__PURE__ */ new Set([Ie]);
        var Ne = fa;
        try {
          Lo(me), xe("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          Ne ? Lo(me) : wa();
        }
      }
    }
    var TE;
    {
      var JR = null;
      TE = function(me, we, Ie) {
        var Ne = A2(JR, we);
        try {
          return ZT(me, we, Ie);
        } catch (Ze) {
          if (x$() || Ze !== null && typeof Ze == "object" && typeof Ze.then == "function")
            throw Ze;
          if (Y0(), tT(), JT(me, we), A2(we, Ne), we.mode & qn && Bx(we), _d(null, ZT, null, me, we, Ie), b_()) {
            var De = mv();
            typeof De == "object" && De !== null && De._suppressLogging && typeof Ze == "object" && Ze !== null && !Ze._suppressLogging && (Ze._suppressLogging = !0);
          }
          throw Ze;
        }
      };
    }
    var E2 = !1, kE;
    kE = /* @__PURE__ */ new Set();
    function eN(me) {
      if (Ka && !BI())
        switch (me.tag) {
          case $e:
          case yt:
          case Ut: {
            var we = Ha && Gn(Ha) || "Unknown", Ie = we;
            if (!kE.has(Ie)) {
              kE.add(Ie);
              var Ne = Gn(me) || "Unknown";
              xe("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", Ne, we, we);
            }
            break;
          }
          case Me: {
            E2 || (xe("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), E2 = !0);
            break;
          }
        }
    }
    function Vb(me, we) {
      if (Ni) {
        var Ie = me.memoizedUpdaters;
        Ie.forEach(function(Ne) {
          Lg(me, Ne, we);
        });
      }
    }
    var OE = {};
    function AE(me, we) {
      {
        var Ie = pc.current;
        return Ie !== null ? (Ie.push(we), OE) : _m(me, we);
      }
    }
    function S2(me) {
      if (me !== OE)
        return Sg(me);
    }
    function P2() {
      return pc.current !== null;
    }
    function tN(me) {
      {
        if (me.mode & $o) {
          if (!e2())
            return;
        } else if (!wR() || Vo !== Hi || me.tag !== $e && me.tag !== yt && me.tag !== Ut)
          return;
        if (pc.current === null) {
          var we = fa;
          try {
            Lo(me), xe(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Gn(me));
          } finally {
            we ? Lo(me) : wa();
          }
        }
      }
    }
    function rN(me) {
      me.tag !== Vf && e2() && pc.current === null && xe(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Hb(me) {
      i2 = me;
    }
    var _l = null, Wy = null, nN = function(me) {
      _l = me;
    };
    function Zy(me) {
      {
        if (_l === null)
          return me;
        var we = _l(me);
        return we === void 0 ? me : we.current;
      }
    }
    function CE(me) {
      return Zy(me);
    }
    function $E(me) {
      {
        if (_l === null)
          return me;
        var we = _l(me);
        if (we === void 0) {
          if (me != null && typeof me.render == "function") {
            var Ie = Zy(me.render);
            if (me.render !== Ie) {
              var Ne = { $$typeof: vn, render: Ie };
              return me.displayName !== void 0 && (Ne.displayName = me.displayName), Ne;
            }
          }
          return me;
        }
        return we.current;
      }
    }
    function T2(me, we) {
      {
        if (_l === null)
          return !1;
        var Ie = me.elementType, Ne = we.type, De = !1, Ze = typeof Ne == "object" && Ne !== null ? Ne.$$typeof : null;
        switch (me.tag) {
          case Me: {
            typeof Ne == "function" && (De = !0);
            break;
          }
          case $e: {
            (typeof Ne == "function" || Ze === xn) && (De = !0);
            break;
          }
          case yt: {
            (Ze === vn || Ze === xn) && (De = !0);
            break;
          }
          case Vt:
          case Ut: {
            (Ze === Zn || Ze === xn) && (De = !0);
            break;
          }
          default:
            return !1;
        }
        if (De) {
          var tt = _l(Ie);
          if (tt !== void 0 && tt === _l(Ne))
            return !0;
        }
        return !1;
      }
    }
    function k2(me) {
      {
        if (_l === null || typeof WeakSet != "function")
          return;
        Wy === null && (Wy = /* @__PURE__ */ new WeakSet()), Wy.add(me);
      }
    }
    var oN = function(me, we) {
      {
        if (_l === null)
          return;
        var Ie = we.staleFamilies, Ne = we.updatedFamilies;
        af(), nf(function() {
          IE(me.current, Ne, Ie);
        });
      }
    }, aN = function(me, we) {
      {
        if (me.context !== Ju)
          return;
        af(), nf(function() {
          qb(we, me, null, null);
        });
      }
    };
    function IE(me, we, Ie) {
      {
        var Ne = me.alternate, De = me.child, Ze = me.sibling, tt = me.tag, ht = me.type, St = null;
        switch (tt) {
          case $e:
          case Ut:
          case Me:
            St = ht;
            break;
          case yt:
            St = ht.render;
            break;
        }
        if (_l === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Nt = !1, Bt = !1;
        if (St !== null) {
          var lr = _l(St);
          lr !== void 0 && (Ie.has(lr) ? Bt = !0 : we.has(lr) && (tt === Me ? Bt = !0 : Nt = !0));
        }
        if (Wy !== null && (Wy.has(me) || Ne !== null && Wy.has(Ne)) && (Bt = !0), Bt && (me._debugNeedsRemount = !0), Bt || Nt) {
          var nr = zu(me, Wn);
          nr !== null && Gi(nr, me, Wn, la);
        }
        De !== null && !Bt && IE(De, we, Ie), Ze !== null && IE(Ze, we, Ie);
      }
    }
    var iN = function(me, we) {
      {
        var Ie = /* @__PURE__ */ new Set(), Ne = new Set(we.map(function(De) {
          return De.current;
        }));
        return ME(me.current, Ne, Ie), Ie;
      }
    };
    function ME(me, we, Ie) {
      {
        var Ne = me.child, De = me.sibling, Ze = me.tag, tt = me.type, ht = null;
        switch (Ze) {
          case $e:
          case Ut:
          case Me:
            ht = tt;
            break;
          case yt:
            ht = tt.render;
            break;
        }
        var St = !1;
        ht !== null && we.has(ht) && (St = !0), St ? sN(me, Ie) : Ne !== null && ME(Ne, we, Ie), De !== null && ME(De, we, Ie);
      }
    }
    function sN(me, we) {
      {
        var Ie = uN(me, we);
        if (Ie)
          return;
        for (var Ne = me; ; ) {
          switch (Ne.tag) {
            case ze:
              we.add(Ne.stateNode);
              return;
            case Be:
              we.add(Ne.stateNode.containerInfo);
              return;
            case je:
              we.add(Ne.stateNode.containerInfo);
              return;
          }
          if (Ne.return === null)
            throw new Error("Expected to reach root first.");
          Ne = Ne.return;
        }
      }
    }
    function uN(me, we) {
      for (var Ie = me, Ne = !1; ; ) {
        if (Ie.tag === ze)
          Ne = !0, we.add(Ie.stateNode);
        else if (Ie.child !== null) {
          Ie.child.return = Ie, Ie = Ie.child;
          continue;
        }
        if (Ie === me)
          return Ne;
        for (; Ie.sibling === null; ) {
          if (Ie.return === null || Ie.return === me)
            return Ne;
          Ie = Ie.return;
        }
        Ie.sibling.return = Ie.return, Ie = Ie.sibling;
      }
      return !1;
    }
    var RE;
    {
      RE = !1;
      try {
        var JN = Object.preventExtensions({});
      } catch {
        RE = !0;
      }
    }
    function lN(me, we, Ie, Ne) {
      this.tag = me, this.key = Ie, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = we, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = Ne, this.flags = Nn, this.subtreeFlags = Nn, this.deletions = null, this.lanes = Ir, this.childLanes = Ir, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !RE && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var el = function(me, we, Ie, Ne) {
      return new lN(me, we, Ie, Ne);
    };
    function NE(me) {
      var we = me.prototype;
      return !!(we && we.isReactComponent);
    }
    function cN(me) {
      return typeof me == "function" && !NE(me) && me.defaultProps === void 0;
    }
    function dN(me) {
      if (typeof me == "function")
        return NE(me) ? Me : $e;
      if (me != null) {
        var we = me.$$typeof;
        if (we === vn)
          return yt;
        if (we === Zn)
          return Vt;
      }
      return Re;
    }
    function am(me, we) {
      var Ie = me.alternate;
      Ie === null ? (Ie = el(me.tag, we, me.key, me.mode), Ie.elementType = me.elementType, Ie.type = me.type, Ie.stateNode = me.stateNode, Ie._debugSource = me._debugSource, Ie._debugOwner = me._debugOwner, Ie._debugHookTypes = me._debugHookTypes, Ie.alternate = me, me.alternate = Ie) : (Ie.pendingProps = we, Ie.type = me.type, Ie.flags = Nn, Ie.subtreeFlags = Nn, Ie.deletions = null, Ie.actualDuration = 0, Ie.actualStartTime = -1), Ie.flags = me.flags & Ri, Ie.childLanes = me.childLanes, Ie.lanes = me.lanes, Ie.child = me.child, Ie.memoizedProps = me.memoizedProps, Ie.memoizedState = me.memoizedState, Ie.updateQueue = me.updateQueue;
      var Ne = me.dependencies;
      switch (Ie.dependencies = Ne === null ? null : { lanes: Ne.lanes, firstContext: Ne.firstContext }, Ie.sibling = me.sibling, Ie.index = me.index, Ie.ref = me.ref, Ie.selfBaseDuration = me.selfBaseDuration, Ie.treeBaseDuration = me.treeBaseDuration, Ie._debugNeedsRemount = me._debugNeedsRemount, Ie.tag) {
        case Re:
        case $e:
        case Ut:
          Ie.type = Zy(me.type);
          break;
        case Me:
          Ie.type = CE(me.type);
          break;
        case yt:
          Ie.type = $E(me.type);
          break;
      }
      return Ie;
    }
    function fN(me, we) {
      me.flags &= Ri | xa;
      var Ie = me.alternate;
      if (Ie === null)
        me.childLanes = Ir, me.lanes = we, me.child = null, me.subtreeFlags = Nn, me.memoizedProps = null, me.memoizedState = null, me.updateQueue = null, me.dependencies = null, me.stateNode = null, me.selfBaseDuration = 0, me.treeBaseDuration = 0;
      else {
        me.childLanes = Ie.childLanes, me.lanes = Ie.lanes, me.child = Ie.child, me.subtreeFlags = Nn, me.deletions = null, me.memoizedProps = Ie.memoizedProps, me.memoizedState = Ie.memoizedState, me.updateQueue = Ie.updateQueue, me.type = Ie.type;
        var Ne = Ie.dependencies;
        me.dependencies = Ne === null ? null : { lanes: Ne.lanes, firstContext: Ne.firstContext }, me.selfBaseDuration = Ie.selfBaseDuration, me.treeBaseDuration = Ie.treeBaseDuration;
      }
      return me;
    }
    function pN(me, we, Ie) {
      var Ne;
      return me === R0 ? (Ne = $o, we === !0 && (Ne |= Ma, Ne |= _u)) : Ne = Ln, Ni && (Ne |= qn), el(je, null, null, Ne);
    }
    function jE(me, we, Ie, Ne, De, Ze) {
      var tt = Re, ht = me;
      if (typeof me == "function")
        NE(me) ? (tt = Me, ht = CE(ht)) : ht = Zy(ht);
      else if (typeof me == "string")
        tt = ze;
      else
        e:
          switch (me) {
            case ho:
              return hp(Ie.children, De, Ze, we);
            case To:
              tt = Ye, De |= Ma, (De & $o) !== Ln && (De |= _u);
              break;
            case Qt:
              return hN(Ie, De, Ze, we);
            case mn:
              return mN(Ie, De, Ze, we);
            case En:
              return yN(Ie, De, Ze, we);
            case Zo:
              return O2(Ie, De, Ze, we);
            case va:
            case na:
            case yi:
            case _s:
            case Wo:
            default: {
              if (typeof me == "object" && me !== null)
                switch (me.$$typeof) {
                  case kr:
                    tt = dt;
                    break e;
                  case Tr:
                    tt = pt;
                    break e;
                  case vn:
                    tt = yt, ht = $E(ht);
                    break e;
                  case Zn:
                    tt = Vt;
                    break e;
                  case xn:
                    tt = Zt, ht = null;
                    break e;
                }
              var St = "";
              {
                (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (St += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Nt = Ne ? Gn(Ne) : null;
                Nt && (St += `

Check the render method of \`` + Nt + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (me == null ? me : typeof me) + "." + St));
            }
          }
      var Bt = el(tt, Ie, we, De);
      return Bt.elementType = me, Bt.type = ht, Bt.lanes = Ze, Bt._debugOwner = Ne, Bt;
    }
    function FE(me, we, Ie) {
      var Ne = null;
      Ne = me._owner;
      var De = me.type, Ze = me.key, tt = me.props, ht = jE(De, Ze, tt, Ne, we, Ie);
      return ht._debugSource = me._source, ht._debugOwner = me._owner, ht;
    }
    function hp(me, we, Ie, Ne) {
      var De = el(qe, me, Ne, we);
      return De.lanes = Ie, De;
    }
    function hN(me, we, Ie, Ne) {
      typeof me.id != "string" && xe('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof me.id);
      var De = el(Ct, me, Ne, we | qn);
      return De.elementType = Qt, De.lanes = Ie, De.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, De;
    }
    function mN(me, we, Ie, Ne) {
      var De = el(It, me, Ne, we);
      return De.elementType = mn, De.lanes = Ie, De;
    }
    function yN(me, we, Ie, Ne) {
      var De = el(hr, me, Ne, we);
      return De.elementType = En, De.lanes = Ie, De;
    }
    function O2(me, we, Ie, Ne) {
      var De = el(Qe, me, Ne, we);
      De.elementType = Zo, De.lanes = Ie;
      var Ze = { isHidden: !1 };
      return De.stateNode = Ze, De;
    }
    function LE(me, we, Ie) {
      var Ne = el(He, me, null, we);
      return Ne.lanes = Ie, Ne;
    }
    function vN() {
      var me = el(ze, null, null, Ln);
      return me.elementType = "DELETED", me;
    }
    function bN(me) {
      var we = el(er, null, null, Ln);
      return we.stateNode = me, we;
    }
    function DE(me, we, Ie) {
      var Ne = me.children !== null ? me.children : [], De = el(Be, Ne, me.key, we);
      return De.lanes = Ie, De.stateNode = { containerInfo: me.containerInfo, pendingChildren: null, implementation: me.implementation }, De;
    }
    function A2(me, we) {
      return me === null && (me = el(Re, null, null, Ln)), me.tag = we.tag, me.key = we.key, me.elementType = we.elementType, me.type = we.type, me.stateNode = we.stateNode, me.return = we.return, me.child = we.child, me.sibling = we.sibling, me.index = we.index, me.ref = we.ref, me.pendingProps = we.pendingProps, me.memoizedProps = we.memoizedProps, me.updateQueue = we.updateQueue, me.memoizedState = we.memoizedState, me.dependencies = we.dependencies, me.mode = we.mode, me.flags = we.flags, me.subtreeFlags = we.subtreeFlags, me.deletions = we.deletions, me.lanes = we.lanes, me.childLanes = we.childLanes, me.alternate = we.alternate, me.actualDuration = we.actualDuration, me.actualStartTime = we.actualStartTime, me.selfBaseDuration = we.selfBaseDuration, me.treeBaseDuration = we.treeBaseDuration, me._debugSource = we._debugSource, me._debugOwner = we._debugOwner, me._debugNeedsRemount = we._debugNeedsRemount, me._debugHookTypes = we._debugHookTypes, me;
    }
    function gN(me, we, Ie, Ne, De) {
      this.tag = we, this.containerInfo = me, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = J_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Uo, this.eventTimes = Qm(Ir), this.expirationTimes = Qm(la), this.pendingLanes = Ir, this.suspendedLanes = Ir, this.pingedLanes = Ir, this.expiredLanes = Ir, this.mutableReadLanes = Ir, this.finishedLanes = Ir, this.entangledLanes = Ir, this.entanglements = Qm(Ir), this.identifierPrefix = Ne, this.onRecoverableError = De, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var Ze = this.pendingUpdatersLaneMap = [], tt = 0; tt < Sa; tt++)
          Ze.push(/* @__PURE__ */ new Set());
      }
      switch (we) {
        case R0:
          this._debugRootType = Ie ? "hydrateRoot()" : "createRoot()";
          break;
        case Vf:
          this._debugRootType = Ie ? "hydrate()" : "render()";
          break;
      }
    }
    function C2(me, we, Ie, Ne, De, Ze, tt, ht, St, Nt) {
      var Bt = new gN(me, we, Ie, ht, St), lr = pN(we, Ze);
      Bt.current = lr, lr.stateNode = Bt;
      {
        var nr = { element: Ne, isDehydrated: Ie, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        lr.memoizedState = nr;
      }
      return T1(lr), Bt;
    }
    var BE = "18.2.0";
    function wN(me, we, Ie) {
      var Ne = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return jn(Ne), { $$typeof: Bo, key: Ne == null ? null : "" + Ne, children: me, containerInfo: we, implementation: Ie };
    }
    var zE, UE;
    zE = !1, UE = {};
    function $2(me) {
      if (!me)
        return Ju;
      var we = mu(me), Ie = qC(we);
      if (we.tag === Me) {
        var Ne = we.type;
        if (Yc(Ne))
          return jS(we, Ne, Ie);
      }
      return Ie;
    }
    function _N(me, we) {
      {
        var Ie = mu(me);
        if (Ie === void 0) {
          if (typeof me.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var Ne = Object.keys(me).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + Ne);
        }
        var De = gu(Ie);
        if (De === null)
          return null;
        if (De.mode & Ma) {
          var Ze = Gn(Ie) || "Component";
          if (!UE[Ze]) {
            UE[Ze] = !0;
            var tt = fa;
            try {
              Lo(De), Ie.mode & Ma ? xe("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", we, we, Ze) : xe("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", we, we, Ze);
            } finally {
              tt ? Lo(tt) : wa();
            }
          }
        }
        return De.stateNode;
      }
    }
    function I2(me, we, Ie, Ne, De, Ze, tt, ht) {
      var St = !1, Nt = null;
      return C2(me, we, St, Nt, Ie, Ne, De, Ze, tt);
    }
    function M2(me, we, Ie, Ne, De, Ze, tt, ht, St, Nt) {
      var Bt = !0, lr = C2(Ie, Ne, Bt, me, De, Ze, tt, ht, St);
      lr.context = $2(null);
      var nr = lr.current, _r = iu(), Er = ep(nr), Cr = Jd(_r, Er);
      return Cr.callback = we ?? null, Wf(nr, Cr, Er), TR(lr, Er, _r), lr;
    }
    function qb(me, we, Ie, Ne) {
      Tg(we, me);
      var De = we.current, Ze = iu(), tt = ep(De);
      Pd(tt);
      var ht = $2(Ie);
      we.context === null ? we.context = ht : we.pendingContext = ht, Ka && fa !== null && !zE && (zE = !0, xe(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Gn(fa) || "Unknown"));
      var St = Jd(Ze, tt);
      St.payload = { element: me }, Ne = Ne === void 0 ? null : Ne, Ne !== null && (typeof Ne != "function" && xe("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", Ne), St.callback = Ne);
      var Nt = Wf(De, St, tt);
      return Nt !== null && (Gi(Nt, De, tt, Ze), ew(Nt, De, tt)), tt;
    }
    function Yw(me) {
      var we = me.current;
      if (!we.child)
        return null;
      switch (we.child.tag) {
        case ze:
          return we.child.stateNode;
        default:
          return we.child.stateNode;
      }
    }
    function xN(me) {
      switch (me.tag) {
        case je: {
          var we = me.stateNode;
          if (Nd(we)) {
            var Ie = __(we);
            $R(we, Ie);
          }
          break;
        }
        case It: {
          nf(function() {
            var De = zu(me, Wn);
            if (De !== null) {
              var Ze = iu();
              Gi(De, me, Wn, Ze);
            }
          });
          var Ne = Wn;
          VE(me, Ne);
          break;
        }
      }
    }
    function R2(me, we) {
      var Ie = me.memoizedState;
      Ie !== null && Ie.dehydrated !== null && (Ie.retryLane = Nv(Ie.retryLane, we));
    }
    function VE(me, we) {
      R2(me, we);
      var Ie = me.alternate;
      Ie && R2(Ie, we);
    }
    function EN(me) {
      if (me.tag === It) {
        var we = Ef, Ie = zu(me, we);
        if (Ie !== null) {
          var Ne = iu();
          Gi(Ie, me, we, Ne);
        }
        VE(me, we);
      }
    }
    function SN(me) {
      if (me.tag === It) {
        var we = ep(me), Ie = zu(me, we);
        if (Ie !== null) {
          var Ne = iu();
          Gi(Ie, me, we, Ne);
        }
        VE(me, we);
      }
    }
    function N2(me) {
      var we = Eg(me);
      return we === null ? null : we.stateNode;
    }
    var j2 = function(me) {
      return null;
    };
    function PN(me) {
      return j2(me);
    }
    var F2 = function(me) {
      return !1;
    };
    function TN(me) {
      return F2(me);
    }
    var L2 = null, D2 = null, B2 = null, z2 = null, U2 = null, V2 = null, H2 = null, q2 = null, W2 = null;
    {
      var Z2 = function(me, we, Ie) {
        var Ne = we[Ie], De = oa(me) ? me.slice() : oo({}, me);
        return Ie + 1 === we.length ? (oa(De) ? De.splice(Ne, 1) : delete De[Ne], De) : (De[Ne] = Z2(me[Ne], we, Ie + 1), De);
      }, G2 = function(me, we) {
        return Z2(me, we, 0);
      }, Y2 = function(me, we, Ie, Ne) {
        var De = we[Ne], Ze = oa(me) ? me.slice() : oo({}, me);
        if (Ne + 1 === we.length) {
          var tt = Ie[Ne];
          Ze[tt] = Ze[De], oa(Ze) ? Ze.splice(De, 1) : delete Ze[De];
        } else
          Ze[De] = Y2(me[De], we, Ie, Ne + 1);
        return Ze;
      }, Q2 = function(me, we, Ie) {
        if (we.length !== Ie.length) {
          _e("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var Ne = 0; Ne < Ie.length - 1; Ne++)
            if (we[Ne] !== Ie[Ne]) {
              _e("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return Y2(me, we, Ie, 0);
      }, K2 = function(me, we, Ie, Ne) {
        if (Ie >= we.length)
          return Ne;
        var De = we[Ie], Ze = oa(me) ? me.slice() : oo({}, me);
        return Ze[De] = K2(me[De], we, Ie + 1, Ne), Ze;
      }, X2 = function(me, we, Ie) {
        return K2(me, we, 0, Ie);
      }, HE = function(me, we) {
        for (var Ie = me.memoizedState; Ie !== null && we > 0; )
          Ie = Ie.next, we--;
        return Ie;
      };
      L2 = function(me, we, Ie, Ne) {
        var De = HE(me, we);
        if (De !== null) {
          var Ze = X2(De.memoizedState, Ie, Ne);
          De.memoizedState = Ze, De.baseState = Ze, me.memoizedProps = oo({}, me.memoizedProps);
          var tt = zu(me, Wn);
          tt !== null && Gi(tt, me, Wn, la);
        }
      }, D2 = function(me, we, Ie) {
        var Ne = HE(me, we);
        if (Ne !== null) {
          var De = G2(Ne.memoizedState, Ie);
          Ne.memoizedState = De, Ne.baseState = De, me.memoizedProps = oo({}, me.memoizedProps);
          var Ze = zu(me, Wn);
          Ze !== null && Gi(Ze, me, Wn, la);
        }
      }, B2 = function(me, we, Ie, Ne) {
        var De = HE(me, we);
        if (De !== null) {
          var Ze = Q2(De.memoizedState, Ie, Ne);
          De.memoizedState = Ze, De.baseState = Ze, me.memoizedProps = oo({}, me.memoizedProps);
          var tt = zu(me, Wn);
          tt !== null && Gi(tt, me, Wn, la);
        }
      }, z2 = function(me, we, Ie) {
        me.pendingProps = X2(me.memoizedProps, we, Ie), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Ne = zu(me, Wn);
        Ne !== null && Gi(Ne, me, Wn, la);
      }, U2 = function(me, we) {
        me.pendingProps = G2(me.memoizedProps, we), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Ie = zu(me, Wn);
        Ie !== null && Gi(Ie, me, Wn, la);
      }, V2 = function(me, we, Ie) {
        me.pendingProps = Q2(me.memoizedProps, we, Ie), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Ne = zu(me, Wn);
        Ne !== null && Gi(Ne, me, Wn, la);
      }, H2 = function(me) {
        var we = zu(me, Wn);
        we !== null && Gi(we, me, Wn, la);
      }, q2 = function(me) {
        j2 = me;
      }, W2 = function(me) {
        F2 = me;
      };
    }
    function kN(me) {
      var we = gu(me);
      return we === null ? null : we.stateNode;
    }
    function ON(me) {
      return null;
    }
    function AN() {
      return fa;
    }
    function CN(me) {
      var we = me.findFiberByHostInstance, Ie = fe.ReactCurrentDispatcher;
      return Sv({ bundleType: me.bundleType, version: me.version, rendererPackageName: me.rendererPackageName, rendererConfig: me.rendererConfig, overrideHookState: L2, overrideHookStateDeletePath: D2, overrideHookStateRenamePath: B2, overrideProps: z2, overridePropsDeletePath: U2, overridePropsRenamePath: V2, setErrorHandler: q2, setSuspenseHandler: W2, scheduleUpdate: H2, currentDispatcherRef: Ie, findHostInstanceByFiber: kN, findFiberByHostInstance: we || ON, findHostInstancesForRefresh: iN, scheduleRefresh: oN, scheduleRoot: aN, setRefreshHandler: nN, getCurrentFiber: AN, reconcilerVersion: BE });
    }
    var J2 = typeof reportError == "function" ? reportError : function(me) {
      console.error(me);
    };
    function qE(me) {
      this._internalRoot = me;
    }
    e_.prototype.render = qE.prototype.render = function(me) {
      var we = this._internalRoot;
      if (we === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? xe("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : t_(arguments[1]) ? xe("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && xe("You passed a second argument to root.render(...) but it only accepts one argument.");
        var Ie = we.containerInfo;
        if (Ie.nodeType !== ei) {
          var Ne = N2(we.current);
          Ne && Ne.parentNode !== Ie && xe("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      qb(me, we, null, null);
    }, e_.prototype.unmount = qE.prototype.unmount = function() {
      typeof arguments[0] == "function" && xe("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var me = this._internalRoot;
      if (me !== null) {
        this._internalRoot = null;
        var we = me.containerInfo;
        f2() && xe("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), nf(function() {
          qb(null, me, null, null);
        }), $S(we);
      }
    };
    function $N(me, we) {
      if (!t_(me))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      eO(me);
      var Ie = !1, Ne = !1, De = "", Ze = J2;
      we != null && (we.hydrate ? _e("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof we == "object" && we !== null && we.$$typeof === $n && xe(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), we.unstable_strictMode === !0 && (Ie = !0), we.identifierPrefix !== void 0 && (De = we.identifierPrefix), we.onRecoverableError !== void 0 && (Ze = we.onRecoverableError), we.transitionCallbacks !== void 0 && we.transitionCallbacks);
      var tt = I2(me, R0, null, Ie, Ne, De, Ze);
      x0(tt.current, me);
      var ht = me.nodeType === ei ? me.parentNode : me;
      return eb(ht), new qE(tt);
    }
    function e_(me) {
      this._internalRoot = me;
    }
    function IN(me) {
      me && Wg(me);
    }
    e_.prototype.unstable_scheduleHydration = IN;
    function MN(me, we, Ie) {
      if (!t_(me))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      eO(me), we === void 0 && xe("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var Ne = Ie ?? null, De = Ie != null && Ie.hydratedSources || null, Ze = !1, tt = !1, ht = "", St = J2;
      Ie != null && (Ie.unstable_strictMode === !0 && (Ze = !0), Ie.identifierPrefix !== void 0 && (ht = Ie.identifierPrefix), Ie.onRecoverableError !== void 0 && (St = Ie.onRecoverableError));
      var Nt = M2(we, null, me, R0, Ne, Ze, tt, ht, St);
      if (x0(Nt.current, me), eb(me), De)
        for (var Bt = 0; Bt < De.length; Bt++) {
          var lr = De[Bt];
          PI(Nt, lr);
        }
      return new e_(Nt);
    }
    function t_(me) {
      return !!(me && (me.nodeType === Ts || me.nodeType === Zu || me.nodeType === id || !Rt));
    }
    function Wb(me) {
      return !!(me && (me.nodeType === Ts || me.nodeType === Zu || me.nodeType === id || me.nodeType === ei && me.nodeValue === " react-mount-point-unstable "));
    }
    function eO(me) {
      me.nodeType === Ts && me.tagName && me.tagName.toUpperCase() === "BODY" && xe("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), db(me) && (me._reactRootContainer ? xe("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : xe("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var RN = fe.ReactCurrentOwner, tO;
    tO = function(me) {
      if (me._reactRootContainer && me.nodeType !== ei) {
        var we = N2(me._reactRootContainer.current);
        we && we.parentNode !== me && xe("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var Ie = !!me._reactRootContainer, Ne = WE(me), De = !!(Ne && zf(Ne));
      De && !Ie && xe("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), me.nodeType === Ts && me.tagName && me.tagName.toUpperCase() === "BODY" && xe("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function WE(me) {
      return me ? me.nodeType === Zu ? me.documentElement : me.firstChild : null;
    }
    function rO() {
    }
    function NN(me, we, Ie, Ne, De) {
      if (De) {
        if (typeof Ne == "function") {
          var Ze = Ne;
          Ne = function() {
            var nr = Yw(tt);
            Ze.call(nr);
          };
        }
        var tt = M2(we, Ne, me, Vf, null, !1, !1, "", rO);
        me._reactRootContainer = tt, x0(tt.current, me);
        var ht = me.nodeType === ei ? me.parentNode : me;
        return eb(ht), nf(), tt;
      } else {
        for (var St; St = me.lastChild; )
          me.removeChild(St);
        if (typeof Ne == "function") {
          var Nt = Ne;
          Ne = function() {
            var nr = Yw(Bt);
            Nt.call(nr);
          };
        }
        var Bt = I2(me, Vf, null, !1, !1, "", rO);
        me._reactRootContainer = Bt, x0(Bt.current, me);
        var lr = me.nodeType === ei ? me.parentNode : me;
        return eb(lr), nf(function() {
          qb(we, Bt, Ie, Ne);
        }), Bt;
      }
    }
    function jN(me, we) {
      me !== null && typeof me != "function" && xe("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", we, me);
    }
    function r_(me, we, Ie, Ne, De) {
      tO(Ie), jN(De === void 0 ? null : De, "render");
      var Ze = Ie._reactRootContainer, tt;
      if (!Ze)
        tt = NN(Ie, we, me, De, Ne);
      else {
        if (tt = Ze, typeof De == "function") {
          var ht = De;
          De = function() {
            var St = Yw(tt);
            ht.call(St);
          };
        }
        qb(we, tt, me, De);
      }
      return Yw(tt);
    }
    function FN(me) {
      {
        var we = RN.current;
        if (we !== null && we.stateNode !== null) {
          var Ie = we.stateNode._warnedAboutRefsInRender;
          Ie || xe("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Fo(we.type) || "A component"), we.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return me == null ? null : me.nodeType === Ts ? me : _N(me, "findDOMNode");
    }
    function LN(me, we, Ie) {
      if (xe("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wb(we))
        throw new Error("Target container is not a DOM element.");
      {
        var Ne = db(we) && we._reactRootContainer === void 0;
        Ne && xe("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return r_(null, me, we, !0, Ie);
    }
    function DN(me, we, Ie) {
      if (xe("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wb(we))
        throw new Error("Target container is not a DOM element.");
      {
        var Ne = db(we) && we._reactRootContainer === void 0;
        Ne && xe("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return r_(null, me, we, !1, Ie);
    }
    function zN(me, we, Ie, Ne) {
      if (xe("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wb(Ie))
        throw new Error("Target container is not a DOM element.");
      if (me == null || !Sp(me))
        throw new Error("parentComponent must be a valid React Component");
      return r_(me, we, Ie, !1, Ne);
    }
    function UN(me) {
      if (!Wb(me))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var we = db(me) && me._reactRootContainer === void 0;
        we && xe("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (me._reactRootContainer) {
        {
          var Ie = WE(me), Ne = Ie && !zf(Ie);
          Ne && xe("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return nf(function() {
          r_(null, null, me, !1, function() {
            me._reactRootContainer = null, $S(me);
          });
        }), !0;
      } else {
        {
          var De = WE(me), Ze = !!(De && zf(De)), tt = me.nodeType === Ts && Wb(me.parentNode) && !!me.parentNode._reactRootContainer;
          Ze && xe("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", tt ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    S_(xN), zg(EN), P_(SN), ny(eu), Ug(Dg), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && xe("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), wg(VO), ym(EE, IR, nf);
    function VN(me, we) {
      var Ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!t_(we))
        throw new Error("Target container is not a DOM element.");
      return wN(me, we, null, Ie);
    }
    function HN(me, we, Ie, Ne) {
      return zN(me, we, Ie, Ne);
    }
    var ZE = { usingClientEntryPoint: !1, Events: [zf, Sy, E0, mm, _p, EE] };
    function qN(me, we) {
      return ZE.usingClientEntryPoint || xe('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), $N(me, we);
    }
    function WN(me, we, Ie) {
      return ZE.usingClientEntryPoint || xe('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), MN(me, we, Ie);
    }
    function ZN(me) {
      return f2() && xe("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), nf(me);
    }
    var GN = CN({ findFiberByHostInstance: Jp, bundleType: 1, version: BE, rendererPackageName: "react-dom" });
    if (!GN && kn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var nO = window.location.protocol;
      /^(https?|file):$/.test(nO) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (nO === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ZE, ne.createPortal = VN, ne.createRoot = qN, ne.findDOMNode = FN, ne.flushSync = ZN, ne.hydrate = LN, ne.hydrateRoot = WN, ne.render = DN, ne.unmountComponentAtNode = UN, ne.unstable_batchedUpdates = EE, ne.unstable_renderSubtreeIntoContainer = HN, ne.version = BE, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), gz = M((ne, oe) => {
  function ae() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ae);
      } catch (fe) {
        console.error(fe);
      }
    }
  }
  process.env.NODE_ENV === "production" ? (ae(), oe.exports = mz()) : oe.exports = hz();
}), bz = M((ne) => {
  var oe = gz();
  process.env.NODE_ENV === "production" ? (ne.createRoot = oe.createRoot, ne.hydrateRoot = oe.hydrateRoot) : (ae = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ne.createRoot = function(fe, ye) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.createRoot(fe, ye);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  }, ne.hydrateRoot = function(fe, ye, ve) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.hydrateRoot(fe, ye, ve);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  });
  var ae;
});
function Xm(ne, { insertAt: oe } = {}) {
  if (!ne || typeof document > "u")
    return;
  let ae = document.head || document.getElementsByTagName("head")[0], fe = document.createElement("style");
  fe.type = "text/css", oe === "top" && ae.firstChild ? ae.insertBefore(fe, ae.firstChild) : ae.appendChild(fe), fe.styleSheet ? fe.styleSheet.cssText = ne : fe.appendChild(document.createTextNode(ne));
}
var ek = Y(() => {
}), Sz = Y(() => {
  ek(), Xm(`#mud-dev-tools{all:initial}#mud-dev-tools *,#mud-dev-tools :before,#mud-dev-tools :after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}#mud-dev-tools :before,#mud-dev-tools :after{--tw-content: ""}#mud-dev-tools{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}#mud-dev-tools{margin:0;line-height:inherit}#mud-dev-tools hr{height:0;color:inherit;border-top-width:1px}#mud-dev-tools abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6{font-size:inherit;font-weight:inherit}#mud-dev-tools a{color:inherit;text-decoration:inherit}#mud-dev-tools b,#mud-dev-tools strong{font-weight:bolder}#mud-dev-tools code,#mud-dev-tools kbd,#mud-dev-tools samp,#mud-dev-tools pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}#mud-dev-tools small{font-size:80%}#mud-dev-tools sub,#mud-dev-tools sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#mud-dev-tools sub{bottom:-.25em}#mud-dev-tools sup{top:-.5em}#mud-dev-tools table{text-indent:0;border-color:inherit;border-collapse:collapse}#mud-dev-tools button,#mud-dev-tools input,#mud-dev-tools optgroup,#mud-dev-tools select,#mud-dev-tools textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}#mud-dev-tools button,#mud-dev-tools select{text-transform:none}#mud-dev-tools button,#mud-dev-tools [type=button],#mud-dev-tools [type=reset],#mud-dev-tools [type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}#mud-dev-tools :-moz-focusring{outline:auto}#mud-dev-tools :-moz-ui-invalid{box-shadow:none}#mud-dev-tools progress{vertical-align:baseline}#mud-dev-tools ::-webkit-inner-spin-button,#mud-dev-tools ::-webkit-outer-spin-button{height:auto}#mud-dev-tools [type=search]{-webkit-appearance:textfield;outline-offset:-2px}#mud-dev-tools ::-webkit-search-decoration{-webkit-appearance:none}#mud-dev-tools ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}#mud-dev-tools summary{display:list-item}#mud-dev-tools blockquote,#mud-dev-tools dl,#mud-dev-tools dd,#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6,#mud-dev-tools hr,#mud-dev-tools figure,#mud-dev-tools p,#mud-dev-tools pre{margin:0}#mud-dev-tools fieldset{margin:0;padding:0}#mud-dev-tools legend{padding:0}#mud-dev-tools ol,#mud-dev-tools ul,#mud-dev-tools menu{list-style:none;margin:0;padding:0}#mud-dev-tools textarea{resize:vertical}#mud-dev-tools input::-moz-placeholder,#mud-dev-tools textarea::-moz-placeholder{opacity:1;color:#9ca3af}#mud-dev-tools input::placeholder,#mud-dev-tools textarea::placeholder{opacity:1;color:#9ca3af}#mud-dev-tools button,#mud-dev-tools [role=button]{cursor:pointer}#mud-dev-tools :disabled{cursor:default}#mud-dev-tools img,#mud-dev-tools svg,#mud-dev-tools video,#mud-dev-tools canvas,#mud-dev-tools audio,#mud-dev-tools iframe,#mud-dev-tools embed,#mud-dev-tools object{display:block;vertical-align:middle}#mud-dev-tools img,#mud-dev-tools video{max-width:100%;height:auto}#mud-dev-tools [hidden]{display:none}
`);
}), _z = Y(() => {
  ek(), Xm(`*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }#mud-dev-tools :is(.pointer-events-none){pointer-events:none}#mud-dev-tools :is(.pointer-events-auto){pointer-events:auto}#mud-dev-tools :is(.fixed){position:fixed}#mud-dev-tools :is(.absolute){position:absolute}#mud-dev-tools :is(.relative){position:relative}#mud-dev-tools :is(.sticky){position:sticky}#mud-dev-tools :is(.inset-0){inset:0}#mud-dev-tools :is(.bottom-0){bottom:0}#mud-dev-tools :is(.left-0){left:0}#mud-dev-tools :is(.right-0){right:0}#mud-dev-tools :is(.right-full){right:100%}#mud-dev-tools :is(.top-0){top:0}#mud-dev-tools :is(.top-1){top:.25rem}#mud-dev-tools :is(.z-10){z-index:10}#mud-dev-tools :is(.z-20){z-index:20}#mud-dev-tools :is(.m-2){margin:.5rem}#mud-dev-tools :is(.-mx-1){margin-left:-.25rem;margin-right:-.25rem}#mud-dev-tools :is(.block){display:block}#mud-dev-tools :is(.flex){display:flex}#mud-dev-tools :is(.inline-flex){display:inline-flex}#mud-dev-tools :is(.\\!table){display:table!important}#mud-dev-tools :is(.table){display:table}#mud-dev-tools :is(.grid){display:grid}#mud-dev-tools :is(.hidden){display:none}#mud-dev-tools :is(.h-4){height:1rem}#mud-dev-tools :is(.h-\\[1em\\]){height:1em}#mud-dev-tools :is(.h-full){height:100%}#mud-dev-tools :is(.w-2\\/12){width:16.666667%}#mud-dev-tools :is(.w-3\\/12){width:25%}#mud-dev-tools :is(.w-4){width:1rem}#mud-dev-tools :is(.w-\\[1em\\]){width:1em}#mud-dev-tools :is(.w-full){width:100%}#mud-dev-tools :is(.min-w-max){min-width:max-content}#mud-dev-tools :is(.max-w-screen-sm){max-width:640px}#mud-dev-tools :is(.flex-1){flex:1 1 0%}#mud-dev-tools :is(.flex-none){flex:none}#mud-dev-tools :is(.flex-grow){flex-grow:1}#mud-dev-tools :is(.table-fixed){table-layout:fixed}#mud-dev-tools :is(.translate-x-0){--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}#mud-dev-tools :is(.translate-x-full){--tw-translate-x: 100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}#mud-dev-tools :is(.animate-spin){animation:spin 1s linear infinite}#mud-dev-tools :is(.cursor-default){cursor:default}#mud-dev-tools :is(.cursor-pointer){cursor:pointer}#mud-dev-tools :is(.select-none){-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.grid-cols-\\[max-content\\,1fr\\]){grid-template-columns:max-content 1fr}#mud-dev-tools :is(.flex-col){flex-direction:column}#mud-dev-tools :is(.flex-col-reverse){flex-direction:column-reverse}#mud-dev-tools :is(.items-start){align-items:flex-start}#mud-dev-tools :is(.items-end){align-items:flex-end}#mud-dev-tools :is(.items-center){align-items:center}#mud-dev-tools :is(.justify-center){justify-content:center}#mud-dev-tools :is(.gap-1){gap:.25rem}#mud-dev-tools :is(.gap-2){gap:.5rem}#mud-dev-tools :is(.gap-x-4){column-gap:1rem}#mud-dev-tools :is(.space-y-1 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-2 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-4 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-6 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-8 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(2rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(2rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.overflow-auto){overflow:auto}#mud-dev-tools :is(.overflow-hidden){overflow:hidden}#mud-dev-tools :is(.text-ellipsis){text-overflow:ellipsis}#mud-dev-tools :is(.whitespace-nowrap){white-space:nowrap}#mud-dev-tools :is(.whitespace-pre){white-space:pre}#mud-dev-tools :is(.rounded){border-radius:.25rem}#mud-dev-tools :is(.border-2){border-width:2px}#mud-dev-tools :is(.border-dashed){border-style:dashed}#mud-dev-tools :is(.border-transparent){border-color:transparent}#mud-dev-tools :is(.border-white\\/10){border-color:#ffffff1a}#mud-dev-tools :is(.border-white\\/20){border-color:#fff3}#mud-dev-tools :is(.bg-gray-500\\/10){background-color:#6b72801a}#mud-dev-tools :is(.bg-red-800){--tw-bg-opacity: 1;background-color:rgb(153 27 27 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-red-900\\/50){background-color:#7f1d1d80}#mud-dev-tools :is(.bg-slate-600){--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-700){--tw-bg-opacity: 1;background-color:rgb(51 65 85 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-800){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-900){--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-white\\/5){background-color:#ffffff0d}#mud-dev-tools :is(.p-1){padding:.25rem}#mud-dev-tools :is(.p-2){padding:.5rem}#mud-dev-tools :is(.p-4){padding:1rem}#mud-dev-tools :is(.p-6){padding:1.5rem}#mud-dev-tools :is(.px-1){padding-left:.25rem;padding-right:.25rem}#mud-dev-tools :is(.px-1\\.5){padding-left:.375rem;padding-right:.375rem}#mud-dev-tools :is(.px-2){padding-left:.5rem;padding-right:.5rem}#mud-dev-tools :is(.px-3){padding-left:.75rem;padding-right:.75rem}#mud-dev-tools :is(.py-0){padding-top:0;padding-bottom:0}#mud-dev-tools :is(.py-0\\.5){padding-top:.125rem;padding-bottom:.125rem}#mud-dev-tools :is(.py-1){padding-top:.25rem;padding-bottom:.25rem}#mud-dev-tools :is(.py-1\\.5){padding-top:.375rem;padding-bottom:.375rem}#mud-dev-tools :is(.py-2){padding-top:.5rem;padding-bottom:.5rem}#mud-dev-tools :is(.pb-0){padding-bottom:0}#mud-dev-tools :is(.pb-0\\.5){padding-bottom:.125rem}#mud-dev-tools :is(.pb-1){padding-bottom:.25rem}#mud-dev-tools :is(.pt-1){padding-top:.25rem}#mud-dev-tools :is(.pt-1\\.5){padding-top:.375rem}#mud-dev-tools :is(.text-left){text-align:left}#mud-dev-tools :is(.text-right){text-align:right}#mud-dev-tools :is(.font-mono){font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}#mud-dev-tools :is(.text-sm){font-size:.875rem;line-height:1.25rem}#mud-dev-tools :is(.text-xs){font-size:.75rem;line-height:1rem}#mud-dev-tools :is(.font-bold){font-weight:700}#mud-dev-tools :is(.font-medium){font-weight:500}#mud-dev-tools :is(.font-normal){font-weight:400}#mud-dev-tools :is(.font-semibold){font-weight:600}#mud-dev-tools :is(.uppercase){text-transform:uppercase}#mud-dev-tools :is(.leading-none){line-height:1}#mud-dev-tools :is(.tracking-\\[-1ch\\]){letter-spacing:-1ch}#mud-dev-tools :is(.text-amber-200\\/80){color:#fde68acc}#mud-dev-tools :is(.text-cyan-500){--tw-text-opacity: 1;color:rgb(6 182 212 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-gray-500){--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-green-500){--tw-text-opacity: 1;color:rgb(34 197 94 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-red-500){--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-transparent){color:transparent}#mud-dev-tools :is(.text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-white\\/20){color:#fff3}#mud-dev-tools :is(.text-white\\/40){color:#fff6}#mud-dev-tools :is(.text-white\\/60){color:#fff9}#mud-dev-tools :is(.text-white\\/80){color:#fffc}#mud-dev-tools :is(.underline){text-decoration-line:underline}#mud-dev-tools :is(.opacity-0){opacity:0}#mud-dev-tools :is(.opacity-100){opacity:1}#mud-dev-tools :is(.opacity-25){opacity:.25}#mud-dev-tools :is(.opacity-60){opacity:.6}#mud-dev-tools :is(.opacity-75){opacity:.75}#mud-dev-tools :is(.shadow-lg){--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}#mud-dev-tools :is(.filter){filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}#mud-dev-tools :is(.transition){transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}#mud-dev-tools :is(.duration-500){transition-duration:.5s}#mud-dev-tools :is(.after\\:select-none):after{content:var(--tw-content);-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.after\\:content-\\[\\'\\2026\\'\\]):after{--tw-content: "\\2026";content:var(--tw-content)}#mud-dev-tools :is(.hover\\:bg-blue-700:hover){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:bg-blue-800:hover){--tw-bg-opacity: 1;background-color:rgb(30 64 175 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:text-white:hover){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.hover\\:text-white\\/60:hover){color:#fff9}#mud-dev-tools :is(.hover\\:underline:hover){text-decoration-line:underline}#mud-dev-tools :is(.hover\\:opacity-100:hover){opacity:1}#mud-dev-tools :is(.group:hover .group-hover\\:border-blue-700){--tw-border-opacity: 1;border-color:rgb(29 78 216 / var(--tw-border-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:bg-blue-700){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.peer:hover ~ .peer-hover\\:opacity-60){opacity:.6}
`);
});
function wz() {
  for (var ne = 0, oe, ae, fe = ""; ne < arguments.length; )
    (oe = arguments[ne++]) && (ae = xz(oe)) && (fe && (fe += " "), fe += ae);
  return fe;
}
function xz(ne) {
  if (typeof ne == "string")
    return ne;
  for (var oe, ae = "", fe = 0; fe < ne.length; fe++)
    ne[fe] && (oe = xz(ne[fe])) && (ae && (ae += " "), ae += oe);
  return ae;
}
var Ez = Y(() => {
});
function Oz(ne) {
  var oe = BZ(ne), ae = ne.conflictingClassGroups, fe = ne.conflictingClassGroupModifiers, ye = fe === void 0 ? {} : fe;
  function ve(xe) {
    var Oe = xe.split(rk);
    return Oe[0] === "" && Oe.length !== 1 && Oe.shift(), Tz(Oe, oe) || IZ(xe);
  }
  function _e(xe, Oe) {
    var $e = ae[xe] || [];
    return Oe && ye[xe] ? [].concat($e, ye[xe]) : $e;
  }
  return { getClassGroupId: ve, getConflictingClassGroupIds: _e };
}
function Tz(ne, oe) {
  var _e;
  if (ne.length === 0)
    return oe.classGroupId;
  var ae = ne[0], fe = oe.nextPart.get(ae), ye = fe ? Tz(ne.slice(1), fe) : void 0;
  if (ye)
    return ye;
  if (oe.validators.length !== 0) {
    var ve = ne.join(rk);
    return (_e = oe.validators.find(function(xe) {
      var Oe = xe.validator;
      return Oe(ve);
    })) == null ? void 0 : _e.classGroupId;
  }
}
function IZ(ne) {
  if (Cz.test(ne)) {
    var oe = Cz.exec(ne)[1], ae = oe == null ? void 0 : oe.substring(0, oe.indexOf(":"));
    if (ae)
      return "arbitrary.." + ae;
  }
}
function BZ(ne) {
  var oe = ne.theme, ae = ne.prefix, fe = { nextPart: /* @__PURE__ */ new Map(), validators: [] }, ye = VZ(Object.entries(ne.classGroups), ae);
  return ye.forEach(function(ve) {
    var _e = ve[0], xe = ve[1];
    tk(xe, fe, _e, oe);
  }), fe;
}
function tk(ne, oe, ae, fe) {
  ne.forEach(function(ye) {
    if (typeof ye == "string") {
      var ve = ye === "" ? oe : Rz(oe, ye);
      ve.classGroupId = ae;
      return;
    }
    if (typeof ye == "function") {
      if (HZ(ye)) {
        tk(ye(fe), oe, ae, fe);
        return;
      }
      oe.validators.push({ validator: ye, classGroupId: ae });
      return;
    }
    Object.entries(ye).forEach(function(_e) {
      var xe = _e[0], Oe = _e[1];
      tk(Oe, Rz(oe, xe), ae, fe);
    });
  });
}
function Rz(ne, oe) {
  var ae = ne;
  return oe.split(rk).forEach(function(fe) {
    ae.nextPart.has(fe) || ae.nextPart.set(fe, { nextPart: /* @__PURE__ */ new Map(), validators: [] }), ae = ae.nextPart.get(fe);
  }), ae;
}
function HZ(ne) {
  return ne.isThemeGetter;
}
function VZ(ne, oe) {
  return oe ? ne.map(function(ae) {
    var fe = ae[0], ye = ae[1], ve = ye.map(function(_e) {
      return typeof _e == "string" ? oe + _e : typeof _e == "object" ? Object.fromEntries(Object.entries(_e).map(function(xe) {
        var Oe = xe[0], $e = xe[1];
        return [oe + Oe, $e];
      })) : _e;
    });
    return [fe, ve];
  }) : ne;
}
var rk, Cz, kz = Y(() => {
  rk = "-", Cz = /^\[(.+)\]$/;
});
function Az(ne) {
  if (ne < 1)
    return { get: function() {
    }, set: function() {
    } };
  var oe = 0, ae = /* @__PURE__ */ new Map(), fe = /* @__PURE__ */ new Map();
  function ye(ve, _e) {
    ae.set(ve, _e), oe++, oe > ne && (oe = 0, fe = ae, ae = /* @__PURE__ */ new Map());
  }
  return { get: function(ve) {
    var _e = ae.get(ve);
    if (_e !== void 0)
      return _e;
    if ((_e = fe.get(ve)) !== void 0)
      return ye(ve, _e), _e;
  }, set: function(ve, _e) {
    ae.has(ve) ? ae.set(ve, _e) : ye(ve, _e);
  } };
}
var Pz = Y(() => {
});
function Mz(ne) {
  var oe = ne.separator || ":", ae = oe.length === 1, fe = oe[0], ye = oe.length;
  return function(ve) {
    for (var _e = [], xe = 0, Oe = 0, $e, Me = 0; Me < ve.length; Me++) {
      var Re = ve[Me];
      if (xe === 0) {
        if (Re === fe && (ae || ve.slice(Me, Me + ye) === oe)) {
          _e.push(ve.slice(Oe, Me)), Oe = Me + ye;
          continue;
        }
        if (Re === "/") {
          $e = Me;
          continue;
        }
      }
      Re === "[" ? xe++ : Re === "]" && xe--;
    }
    var je = _e.length === 0 ? ve : ve.substring(Oe), Be = je.startsWith(nk), ze = Be ? je.substring(1) : je, He = $e && $e > Oe ? $e - Oe : void 0;
    return { modifiers: _e, hasImportantModifier: Be, baseClassName: ze, maybePostfixModifierPosition: He };
  };
}
function Dz(ne) {
  if (ne.length <= 1)
    return ne;
  var oe = [], ae = [];
  return ne.forEach(function(fe) {
    var ye = fe[0] === "[";
    ye ? (oe.push.apply(oe, ae.sort().concat([fe])), ae = []) : ae.push(fe);
  }), oe.push.apply(oe, ae.sort()), oe;
}
var nk, ik = Y(() => {
  nk = "!";
});
function Nz(ne) {
  return { cache: Az(ne.cacheSize), splitModifiers: Mz(ne), ...Oz(ne) };
}
var Lz = Y(() => {
  kz(), Pz(), ik();
});
function jz(ne, oe) {
  var ae = oe.splitModifiers, fe = oe.getClassGroupId, ye = oe.getConflictingClassGroupIds, ve = /* @__PURE__ */ new Set();
  return ne.trim().split($Z).map(function(_e) {
    var xe = ae(_e), Oe = xe.modifiers, $e = xe.hasImportantModifier, Me = xe.baseClassName, Re = xe.maybePostfixModifierPosition, je = fe(Re ? Me.substring(0, Re) : Me), Be = !!Re;
    if (!je) {
      if (!Re)
        return { isTailwindClass: !1, originalClassName: _e };
      if (je = fe(Me), !je)
        return { isTailwindClass: !1, originalClassName: _e };
      Be = !1;
    }
    var ze = Dz(Oe).join(":"), He = $e ? ze + nk : ze;
    return { isTailwindClass: !0, modifierId: He, classGroupId: je, originalClassName: _e, hasPostfixModifier: Be };
  }).reverse().filter(function(_e) {
    if (!_e.isTailwindClass)
      return !0;
    var xe = _e.modifierId, Oe = _e.classGroupId, $e = _e.hasPostfixModifier, Me = xe + Oe;
    return ve.has(Me) ? !1 : (ve.add(Me), ye(Oe, $e).forEach(function(Re) {
      return ve.add(xe + Re);
    }), !0);
  }).reverse().map(function(_e) {
    return _e.originalClassName;
  }).join(" ");
}
var $Z, Uz = Y(() => {
  ik(), $Z = /\s+/;
});
function Fz() {
  for (var ne = arguments.length, oe = new Array(ne), ae = 0; ae < ne; ae++)
    oe[ae] = arguments[ae];
  var fe, ye, ve, _e = xe;
  function xe($e) {
    var Me = oe[0], Re = oe.slice(1), je = Re.reduce(function(Be, ze) {
      return ze(Be);
    }, Me());
    return fe = Nz(je), ye = fe.cache.get, ve = fe.cache.set, _e = Oe, Oe($e);
  }
  function Oe($e) {
    var Me = ye($e);
    if (Me)
      return Me;
    var Re = jz($e, fe);
    return ve($e, Re), Re;
  }
  return function() {
    return _e(wz.apply(null, arguments));
  };
}
var zz = Y(() => {
  Lz(), Uz(), Ez();
});
function Wt(ne) {
  var oe = function(ae) {
    return ae[ne] || [];
  };
  return oe.isThemeGetter = !0, oe;
}
var qz = Y(() => {
});
function ma(ne) {
  return Ll(ne) || YZ.has(ne) || WZ.test(ne) || wu(ne);
}
function wu(ne) {
  return oc(ne, "length", XZ);
}
function Hz(ne) {
  return oc(ne, "size", Gz);
}
function Vz(ne) {
  return oc(ne, "position", Gz);
}
function $z(ne) {
  return oc(ne, "url", JZ);
}
function Jm(ne) {
  return oc(ne, "number", Ll);
}
function Ll(ne) {
  return !Number.isNaN(Number(ne));
}
function Wz(ne) {
  return ne.endsWith("%") && Ll(ne.slice(0, -1));
}
function sd(ne) {
  return Iz(ne) || oc(ne, "number", Iz);
}
function yr(ne) {
  return Bz.test(ne);
}
function cd() {
  return !0;
}
function xu(ne) {
  return GZ.test(ne);
}
function Yz(ne) {
  return oc(ne, "", ZZ);
}
function oc(ne, oe, ae) {
  var fe = Bz.exec(ne);
  return fe ? fe[1] ? fe[1] === oe : ae(fe[2]) : !1;
}
function XZ(ne) {
  return QZ.test(ne);
}
function Gz() {
  return !1;
}
function JZ(ne) {
  return ne.startsWith("url(");
}
function Iz(ne) {
  return Number.isInteger(Number(ne));
}
function ZZ(ne) {
  return KZ.test(ne);
}
var Bz, WZ, YZ, GZ, QZ, KZ, Qz = Y(() => {
  Bz = /^\[(?:([a-z-]+):)?(.+)\]$/i, WZ = /^\d+\/\d+$/, YZ = /* @__PURE__ */ new Set(["px", "full", "screen"]), GZ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, QZ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))/, KZ = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
});
function Kz() {
  var ne = Wt("colors"), oe = Wt("spacing"), ae = Wt("blur"), fe = Wt("brightness"), ye = Wt("borderColor"), ve = Wt("borderRadius"), _e = Wt("borderSpacing"), xe = Wt("borderWidth"), Oe = Wt("contrast"), $e = Wt("grayscale"), Me = Wt("hueRotate"), Re = Wt("invert"), je = Wt("gap"), Be = Wt("gradientColorStops"), ze = Wt("gradientColorStopPositions"), He = Wt("inset"), qe = Wt("margin"), Ye = Wt("opacity"), pt = Wt("padding"), dt = Wt("saturate"), yt = Wt("scale"), Ct = Wt("sepia"), It = Wt("skew"), Vt = Wt("space"), Ut = Wt("translate"), Zt = function() {
    return ["auto", "contain", "none"];
  }, tr = function() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  }, er = function() {
    return ["auto", oe];
  }, hr = function() {
    return ["", ma];
  }, Ot = function() {
    return ["auto", Ll, yr];
  }, Qe = function() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  }, at = function() {
    return ["solid", "dashed", "dotted", "double", "none"];
  }, wt = function() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  }, bt = function() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  }, At = function() {
    return ["", "0", yr];
  }, Ft = function() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  }, Gt = function() {
    return [Ll, Jm];
  }, ot = function() {
    return [Ll, yr];
  };
  return { cacheSize: 500, theme: { colors: [cd], spacing: [ma], blur: ["none", "", xu, wu], brightness: Gt(), borderColor: [ne], borderRadius: ["none", "", "full", xu, wu], borderSpacing: [oe], borderWidth: hr(), contrast: Gt(), grayscale: At(), hueRotate: ot(), invert: At(), gap: [oe], gradientColorStops: [ne], gradientColorStopPositions: [Wz, wu], inset: er(), margin: er(), opacity: Gt(), padding: [oe], saturate: Gt(), scale: Gt(), sepia: At(), skew: ot(), space: [oe], translate: [oe] }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", yr] }], container: ["container"], columns: [{ columns: [xu] }], "break-after": [{ "break-after": Ft() }], "break-before": [{ "break-before": Ft() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none"] }], clear: [{ clear: ["left", "right", "both", "none"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [].concat(Qe(), [yr]) }], overflow: [{ overflow: tr() }], "overflow-x": [{ "overflow-x": tr() }], "overflow-y": [{ "overflow-y": tr() }], overscroll: [{ overscroll: Zt() }], "overscroll-x": [{ "overscroll-x": Zt() }], "overscroll-y": [{ "overscroll-y": Zt() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [He] }], "inset-x": [{ "inset-x": [He] }], "inset-y": [{ "inset-y": [He] }], start: [{ start: [He] }], end: [{ end: [He] }], top: [{ top: [He] }], right: [{ right: [He] }], bottom: [{ bottom: [He] }], left: [{ left: [He] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", sd] }], basis: [{ basis: [oe] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", yr] }], grow: [{ grow: At() }], shrink: [{ shrink: At() }], order: [{ order: ["first", "last", "none", sd] }], "grid-cols": [{ "grid-cols": [cd] }], "col-start-end": [{ col: ["auto", { span: [sd] }, yr] }], "col-start": [{ "col-start": Ot() }], "col-end": [{ "col-end": Ot() }], "grid-rows": [{ "grid-rows": [cd] }], "row-start-end": [{ row: ["auto", { span: [sd] }, yr] }], "row-start": [{ "row-start": Ot() }], "row-end": [{ "row-end": Ot() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", yr] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", yr] }], gap: [{ gap: [je] }], "gap-x": [{ "gap-x": [je] }], "gap-y": [{ "gap-y": [je] }], "justify-content": [{ justify: ["normal"].concat(bt()) }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal"].concat(bt(), ["baseline"]) }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [].concat(bt(), ["baseline"]) }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [pt] }], px: [{ px: [pt] }], py: [{ py: [pt] }], ps: [{ ps: [pt] }], pe: [{ pe: [pt] }], pt: [{ pt: [pt] }], pr: [{ pr: [pt] }], pb: [{ pb: [pt] }], pl: [{ pl: [pt] }], m: [{ m: [qe] }], mx: [{ mx: [qe] }], my: [{ my: [qe] }], ms: [{ ms: [qe] }], me: [{ me: [qe] }], mt: [{ mt: [qe] }], mr: [{ mr: [qe] }], mb: [{ mb: [qe] }], ml: [{ ml: [qe] }], "space-x": [{ "space-x": [Vt] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [Vt] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", oe] }], "min-w": [{ "min-w": ["min", "max", "fit", ma] }], "max-w": [{ "max-w": ["0", "none", "full", "min", "max", "fit", "prose", { screen: [xu] }, xu, wu] }], h: [{ h: [oe, "auto", "min", "max", "fit"] }], "min-h": [{ "min-h": ["min", "max", "fit", ma] }], "max-h": [{ "max-h": [oe, "min", "max", "fit"] }], "font-size": [{ text: ["base", xu, wu] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Jm] }], "font-family": [{ font: [cd] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", wu] }], "line-clamp": [{ "line-clamp": ["none", Ll, Jm] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ma] }], "list-image": [{ "list-image": ["none", yr] }], "list-style-type": [{ list: ["none", "disc", "decimal", yr] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [ne] }], "placeholder-opacity": [{ "placeholder-opacity": [Ye] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [ne] }], "text-opacity": [{ "text-opacity": [Ye] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [].concat(at(), ["wavy"]) }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", ma] }], "underline-offset": [{ "underline-offset": ["auto", ma] }], "text-decoration-color": [{ decoration: [ne] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], indent: [{ indent: [oe] }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", wu] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", yr] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [Ye] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [].concat(Qe(), [Vz]) }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Hz] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, $z] }], "bg-color": [{ bg: [ne] }], "gradient-from-pos": [{ from: [ze] }], "gradient-via-pos": [{ via: [ze] }], "gradient-to-pos": [{ to: [ze] }], "gradient-from": [{ from: [Be] }], "gradient-via": [{ via: [Be] }], "gradient-to": [{ to: [Be] }], rounded: [{ rounded: [ve] }], "rounded-s": [{ "rounded-s": [ve] }], "rounded-e": [{ "rounded-e": [ve] }], "rounded-t": [{ "rounded-t": [ve] }], "rounded-r": [{ "rounded-r": [ve] }], "rounded-b": [{ "rounded-b": [ve] }], "rounded-l": [{ "rounded-l": [ve] }], "rounded-ss": [{ "rounded-ss": [ve] }], "rounded-se": [{ "rounded-se": [ve] }], "rounded-ee": [{ "rounded-ee": [ve] }], "rounded-es": [{ "rounded-es": [ve] }], "rounded-tl": [{ "rounded-tl": [ve] }], "rounded-tr": [{ "rounded-tr": [ve] }], "rounded-br": [{ "rounded-br": [ve] }], "rounded-bl": [{ "rounded-bl": [ve] }], "border-w": [{ border: [xe] }], "border-w-x": [{ "border-x": [xe] }], "border-w-y": [{ "border-y": [xe] }], "border-w-s": [{ "border-s": [xe] }], "border-w-e": [{ "border-e": [xe] }], "border-w-t": [{ "border-t": [xe] }], "border-w-r": [{ "border-r": [xe] }], "border-w-b": [{ "border-b": [xe] }], "border-w-l": [{ "border-l": [xe] }], "border-opacity": [{ "border-opacity": [Ye] }], "border-style": [{ border: [].concat(at(), ["hidden"]) }], "divide-x": [{ "divide-x": [xe] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [xe] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [Ye] }], "divide-style": [{ divide: at() }], "border-color": [{ border: [ye] }], "border-color-x": [{ "border-x": [ye] }], "border-color-y": [{ "border-y": [ye] }], "border-color-t": [{ "border-t": [ye] }], "border-color-r": [{ "border-r": [ye] }], "border-color-b": [{ "border-b": [ye] }], "border-color-l": [{ "border-l": [ye] }], "divide-color": [{ divide: [ye] }], "outline-style": [{ outline: [""].concat(at()) }], "outline-offset": [{ "outline-offset": [ma] }], "outline-w": [{ outline: [ma] }], "outline-color": [{ outline: [ne] }], "ring-w": [{ ring: hr() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [ne] }], "ring-opacity": [{ "ring-opacity": [Ye] }], "ring-offset-w": [{ "ring-offset": [ma] }], "ring-offset-color": [{ "ring-offset": [ne] }], shadow: [{ shadow: ["", "inner", "none", xu, Yz] }], "shadow-color": [{ shadow: [cd] }], opacity: [{ opacity: [Ye] }], "mix-blend": [{ "mix-blend": wt() }], "bg-blend": [{ "bg-blend": wt() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [ae] }], brightness: [{ brightness: [fe] }], contrast: [{ contrast: [Oe] }], "drop-shadow": [{ "drop-shadow": ["", "none", xu, yr] }], grayscale: [{ grayscale: [$e] }], "hue-rotate": [{ "hue-rotate": [Me] }], invert: [{ invert: [Re] }], saturate: [{ saturate: [dt] }], sepia: [{ sepia: [Ct] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [ae] }], "backdrop-brightness": [{ "backdrop-brightness": [fe] }], "backdrop-contrast": [{ "backdrop-contrast": [Oe] }], "backdrop-grayscale": [{ "backdrop-grayscale": [$e] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [Me] }], "backdrop-invert": [{ "backdrop-invert": [Re] }], "backdrop-opacity": [{ "backdrop-opacity": [Ye] }], "backdrop-saturate": [{ "backdrop-saturate": [dt] }], "backdrop-sepia": [{ "backdrop-sepia": [Ct] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [_e] }], "border-spacing-x": [{ "border-spacing-x": [_e] }], "border-spacing-y": [{ "border-spacing-y": [_e] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", yr] }], duration: [{ duration: ot() }], ease: [{ ease: ["linear", "in", "out", "in-out", yr] }], delay: [{ delay: ot() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", yr] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [yt] }], "scale-x": [{ "scale-x": [yt] }], "scale-y": [{ "scale-y": [yt] }], rotate: [{ rotate: [sd, yr] }], "translate-x": [{ "translate-x": [Ut] }], "translate-y": [{ "translate-y": [Ut] }], "skew-x": [{ "skew-x": [It] }], "skew-y": [{ "skew-y": [It] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", yr] }], accent: [{ accent: ["auto", ne] }], appearance: ["appearance-none"], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", yr] }], "caret-color": [{ caret: [ne] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": [oe] }], "scroll-mx": [{ "scroll-mx": [oe] }], "scroll-my": [{ "scroll-my": [oe] }], "scroll-ms": [{ "scroll-ms": [oe] }], "scroll-me": [{ "scroll-me": [oe] }], "scroll-mt": [{ "scroll-mt": [oe] }], "scroll-mr": [{ "scroll-mr": [oe] }], "scroll-mb": [{ "scroll-mb": [oe] }], "scroll-ml": [{ "scroll-ml": [oe] }], "scroll-p": [{ "scroll-p": [oe] }], "scroll-px": [{ "scroll-px": [oe] }], "scroll-py": [{ "scroll-py": [oe] }], "scroll-ps": [{ "scroll-ps": [oe] }], "scroll-pe": [{ "scroll-pe": [oe] }], "scroll-pt": [{ "scroll-pt": [oe] }], "scroll-pr": [{ "scroll-pr": [oe] }], "scroll-pb": [{ "scroll-pb": [oe] }], "scroll-pl": [{ "scroll-pl": [oe] }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "pinch-zoom", "manipulation", { pan: ["x", "left", "right", "y", "up", "down"] }] }], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", yr] }], fill: [{ fill: [ne, "none"] }], "stroke-w": [{ stroke: [ma, Jm] }], stroke: [{ stroke: [ne, "none"] }], sr: ["sr-only", "not-sr-only"] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } };
}
var Xz = Y(() => {
  qz(), Qz();
}), Pr, Jz = Y(() => {
  zz(), Xz(), Pr = Fz(Kz);
}), uc = Y(() => {
  Jz();
});
function Tt() {
  return Tt = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, Tt.apply(this, arguments);
}
function fq(ne) {
  ne === void 0 && (ne = {});
  let { initialEntries: oe = ["/"], initialIndex: ae, v5Compat: fe = !1 } = ne, ye;
  ye = oe.map((je, Be) => Me(je, typeof je == "string" ? null : je.state, Be === 0 ? "default" : void 0));
  let ve = Oe(ae ?? ye.length - 1), _e = pr.Pop, xe = null;
  function Oe(je) {
    return Math.min(Math.max(je, 0), ye.length - 1);
  }
  function $e() {
    return ye[ve];
  }
  function Me(je, Be, ze) {
    Be === void 0 && (Be = null);
    let He = uk(ye ? $e().pathname : "/", je, Be, ze);
    return ln(He.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(je)), He;
  }
  function Re(je) {
    return typeof je == "string" ? je : Mo(je);
  }
  return { get index() {
    return ve;
  }, get action() {
    return _e;
  }, get location() {
    return $e();
  }, createHref: Re, createURL(je) {
    return new URL(Re(je), "http://localhost");
  }, encodeLocation(je) {
    let Be = typeof je == "string" ? Qi(je) : je;
    return { pathname: Be.pathname || "", search: Be.search || "", hash: Be.hash || "" };
  }, push(je, Be) {
    _e = pr.Push;
    let ze = Me(je, Be);
    ve += 1, ye.splice(ve, ye.length, ze), fe && xe && xe({ action: _e, location: ze, delta: 1 });
  }, replace(je, Be) {
    _e = pr.Replace;
    let ze = Me(je, Be);
    ye[ve] = ze, fe && xe && xe({ action: _e, location: ze, delta: 0 });
  }, go(je) {
    _e = pr.Pop;
    let Be = Oe(ve + je), ze = ye[Be];
    ve = Be, xe && xe({ action: _e, location: ze, delta: je });
  }, listen(je) {
    return xe = je, () => {
      xe = null;
    };
  } };
}
function Te(ne, oe) {
  if (ne === !1 || ne === null || typeof ne > "u")
    throw new Error(oe);
}
function ln(ne, oe) {
  if (!ne) {
    typeof console < "u" && console.warn(oe);
    try {
      throw new Error(oe);
    } catch {
    }
  }
}
function eee() {
  return Math.random().toString(36).substr(2, 8);
}
function uk(ne, oe, ae, fe) {
  return ae === void 0 && (ae = null), Tt({ pathname: typeof ne == "string" ? ne : ne.pathname, search: "", hash: "" }, typeof oe == "string" ? Qi(oe) : oe, { state: ae, key: oe && oe.key || fe || eee() });
}
function Mo(ne) {
  let { pathname: oe = "/", search: ae = "", hash: fe = "" } = ne;
  return ae && ae !== "?" && (oe += ae.charAt(0) === "?" ? ae : "?" + ae), fe && fe !== "#" && (oe += fe.charAt(0) === "#" ? fe : "#" + fe), oe;
}
function Qi(ne) {
  let oe = {};
  if (ne) {
    let ae = ne.indexOf("#");
    ae >= 0 && (oe.hash = ne.substr(ae), ne = ne.substr(0, ae));
    let fe = ne.indexOf("?");
    fe >= 0 && (oe.search = ne.substr(fe), ne = ne.substr(0, fe)), ne && (oe.pathname = ne);
  }
  return oe;
}
function ree(ne) {
  return ne.index === !0;
}
function dq(ne, oe, ae, fe) {
  return ae === void 0 && (ae = []), fe === void 0 && (fe = {}), ne.map((ye, ve) => {
    let _e = [...ae, ve], xe = typeof ye.id == "string" ? ye.id : _e.join("-");
    if (Te(ye.index !== !0 || !ye.children, "Cannot specify children on an index route"), Te(!fe[xe], 'Found a route id collision on id "' + xe + `".  Route id's must be globally unique within Data Router usages`), ree(ye)) {
      let Oe = Tt({}, ye, oe(ye), { id: xe });
      return fe[xe] = Oe, Oe;
    } else {
      let Oe = Tt({}, ye, oe(ye), { id: xe, children: void 0 });
      return fe[xe] = Oe, ye.children && (Oe.children = dq(ye.children, oe, _e, fe)), Oe;
    }
  });
}
function Cu(ne, oe, ae) {
  ae === void 0 && (ae = "/");
  let fe = typeof oe == "string" ? Qi(oe) : oe, ye = Ru(fe.pathname || "/", ae);
  if (ye == null)
    return null;
  let ve = pq(ne);
  nee(ve);
  let _e = null;
  for (let xe = 0; _e == null && xe < ve.length; ++xe)
    _e = dee(ve[xe], vee(ye));
  return _e;
}
function pq(ne, oe, ae, fe) {
  oe === void 0 && (oe = []), ae === void 0 && (ae = []), fe === void 0 && (fe = "");
  let ye = (ve, _e, xe) => {
    let Oe = { relativePath: xe === void 0 ? ve.path || "" : xe, caseSensitive: ve.caseSensitive === !0, childrenIndex: _e, route: ve };
    Oe.relativePath.startsWith("/") && (Te(Oe.relativePath.startsWith(fe), 'Absolute route path "' + Oe.relativePath + '" nested under path ' + ('"' + fe + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), Oe.relativePath = Oe.relativePath.slice(fe.length));
    let $e = ha([fe, Oe.relativePath]), Me = ae.concat(Oe);
    ve.children && ve.children.length > 0 && (Te(ve.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + $e + '".')), pq(ve.children, oe, Me, $e)), !(ve.path == null && !ve.index) && oe.push({ path: $e, score: cee($e, ve.index), routesMeta: Me });
  };
  return ne.forEach((ve, _e) => {
    var xe;
    if (ve.path === "" || !((xe = ve.path) != null && xe.includes("?")))
      ye(ve, _e);
    else
      for (let Oe of vq(ve.path))
        ye(ve, _e, Oe);
  }), oe;
}
function vq(ne) {
  let oe = ne.split("/");
  if (oe.length === 0)
    return [];
  let [ae, ...fe] = oe, ye = ae.endsWith("?"), ve = ae.replace(/\?$/, "");
  if (fe.length === 0)
    return ye ? [ve, ""] : [ve];
  let _e = vq(fe.join("/")), xe = [];
  return xe.push(..._e.map((Oe) => Oe === "" ? ve : [ve, Oe].join("/"))), ye && xe.push(..._e), xe.map((Oe) => ne.startsWith("/") && Oe === "" ? "/" : Oe);
}
function nee(ne) {
  ne.sort((oe, ae) => oe.score !== ae.score ? ae.score - oe.score : fee(oe.routesMeta.map((fe) => fe.childrenIndex), ae.routesMeta.map((fe) => fe.childrenIndex)));
}
function cee(ne, oe) {
  let ae = ne.split("/"), fe = ae.length;
  return ae.some(Zz) && (fe += see), oe && (fe += oee), ae.filter((ye) => !Zz(ye)).reduce((ye, ve) => ye + (iee.test(ve) ? aee : ve === "" ? uee : lee), fe);
}
function fee(ne, oe) {
  return ne.length === oe.length && ne.slice(0, -1).every((ae, fe) => ae === oe[fe]) ? ne[ne.length - 1] - oe[oe.length - 1] : 0;
}
function dee(ne, oe) {
  let { routesMeta: ae } = ne, fe = {}, ye = "/", ve = [];
  for (let _e = 0; _e < ae.length; ++_e) {
    let xe = ae[_e], Oe = _e === ae.length - 1, $e = ye === "/" ? oe : oe.slice(ye.length) || "/", Me = T0({ path: xe.relativePath, caseSensitive: xe.caseSensitive, end: Oe }, $e);
    if (!Me)
      return null;
    Object.assign(fe, Me.params);
    let Re = xe.route;
    ve.push({ params: fe, pathname: ha([ye, Me.pathname]), pathnameBase: yee(ha([ye, Me.pathnameBase])), route: Re }), Me.pathnameBase !== "/" && (ye = ha([ye, Me.pathnameBase]));
  }
  return ve;
}
function T0(ne, oe) {
  typeof ne == "string" && (ne = { path: ne, caseSensitive: !1, end: !0 });
  let [ae, fe] = pee(ne.path, ne.caseSensitive, ne.end), ye = oe.match(ae);
  if (!ye)
    return null;
  let ve = ye[0], _e = ve.replace(/(.)\/+$/, "$1"), xe = ye.slice(1);
  return { params: fe.reduce((Oe, $e, Me) => {
    if ($e === "*") {
      let Re = xe[Me] || "";
      _e = ve.slice(0, ve.length - Re.length).replace(/(.)\/+$/, "$1");
    }
    return Oe[$e] = mee(xe[Me] || "", $e), Oe;
  }, {}), pathname: ve, pathnameBase: _e, pattern: ne };
}
function pee(ne, oe, ae) {
  oe === void 0 && (oe = !1), ae === void 0 && (ae = !0), ln(ne === "*" || !ne.endsWith("*") || ne.endsWith("/*"), 'Route path "' + ne + '" will be treated as if it were ' + ('"' + ne.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + ne.replace(/\*$/, "/*") + '".'));
  let fe = [], ye = "^" + ne.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (ve, _e) => (fe.push(_e), "/([^\\/]+)"));
  return ne.endsWith("*") ? (fe.push("*"), ye += ne === "*" || ne === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : ae ? ye += "\\/*$" : ne !== "" && ne !== "/" && (ye += "(?:(?=\\/|$))"), [new RegExp(ye, oe ? void 0 : "i"), fe];
}
function vee(ne) {
  try {
    return decodeURI(ne);
  } catch (oe) {
    return ln(!1, 'The URL path "' + ne + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + oe + ").")), ne;
  }
}
function mee(ne, oe) {
  try {
    return decodeURIComponent(ne);
  } catch (ae) {
    return ln(!1, 'The value for the URL param "' + oe + '" will not be decoded because' + (' the string "' + ne + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + ae + ").")), ne;
  }
}
function Ru(ne, oe) {
  if (oe === "/")
    return ne;
  if (!ne.toLowerCase().startsWith(oe.toLowerCase()))
    return null;
  let ae = oe.endsWith("/") ? oe.length - 1 : oe.length, fe = ne.charAt(ae);
  return fe && fe !== "/" ? null : ne.slice(ae) || "/";
}
function ck(ne, oe) {
  oe === void 0 && (oe = "/");
  let { pathname: ae, search: fe = "", hash: ye = "" } = typeof ne == "string" ? Qi(ne) : ne;
  return { pathname: ae ? ae.startsWith("/") ? ae : hee(ae, oe) : oe, search: gee(fe), hash: bee(ye) };
}
function hee(ne, oe) {
  let ae = oe.replace(/\/+$/, "").split("/");
  return ne.split("/").forEach((fe) => {
    fe === ".." ? ae.length > 1 && ae.pop() : fe !== "." && ae.push(fe);
  }), ae.length > 1 ? ae.join("/") : "/";
}
function ak(ne, oe, ae, fe) {
  return "Cannot include a '" + ne + "' character in a manually specified " + ("`to." + oe + "` field [" + JSON.stringify(fe) + "].  Please separate it out to the ") + ("`to." + ae + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function nh(ne) {
  return ne.filter((oe, ae) => ae === 0 || oe.route.path && oe.route.path.length > 0);
}
function k0(ne, oe, ae, fe) {
  fe === void 0 && (fe = !1);
  let ye;
  typeof ne == "string" ? ye = Qi(ne) : (ye = Tt({}, ne), Te(!ye.pathname || !ye.pathname.includes("?"), ak("?", "pathname", "search", ye)), Te(!ye.pathname || !ye.pathname.includes("#"), ak("#", "pathname", "hash", ye)), Te(!ye.search || !ye.search.includes("#"), ak("#", "search", "hash", ye)));
  let ve = ne === "" || ye.pathname === "", _e = ve ? "/" : ye.pathname, xe;
  if (fe || _e == null)
    xe = ae;
  else {
    let Re = oe.length - 1;
    if (_e.startsWith("..")) {
      let je = _e.split("/");
      for (; je[0] === ".."; )
        je.shift(), Re -= 1;
      ye.pathname = je.join("/");
    }
    xe = Re >= 0 ? oe[Re] : "/";
  }
  let Oe = ck(ye, xe), $e = _e && _e !== "/" && _e.endsWith("/"), Me = (ve || _e === ".") && ae.endsWith("/");
  return !Oe.pathname.endsWith("/") && ($e || Me) && (Oe.pathname += "/"), Oe;
}
function ih(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.internal == "boolean" && "data" in ne;
}
function fk(ne) {
  Te(ne.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let oe;
  if (ne.mapRouteProperties)
    oe = ne.mapRouteProperties;
  else if (ne.detectErrorBoundary) {
    let Jt = ne.detectErrorBoundary;
    oe = (or) => ({ hasErrorBoundary: Jt(or) });
  } else
    oe = Oee;
  let ae = {}, fe = dq(ne.routes, oe, void 0, ae), ye, ve = ne.basename || "/", _e = Tt({ v7_normalizeFormMethod: !1, v7_prependBasename: !1 }, ne.future), xe = null, Oe = /* @__PURE__ */ new Set(), $e = null, Me = null, Re = null, je = ne.hydrationData != null, Be = Cu(fe, ne.history.location, ve), ze = null;
  if (Be == null) {
    let Jt = Wa(404, { pathname: ne.history.location.pathname }), { matches: or, route: fr } = uq(fe);
    Be = or, ze = { [fr.id]: Jt };
  }
  let He = !Be.some((Jt) => Jt.route.lazy) && (!Be.some((Jt) => Jt.route.loader) || ne.hydrationData != null), qe, Ye = { historyAction: ne.history.action, location: ne.history.location, matches: Be, initialized: He, navigation: ok, restoreScrollPosition: ne.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: ne.hydrationData && ne.hydrationData.loaderData || {}, actionData: ne.hydrationData && ne.hydrationData.actionData || null, errors: ne.hydrationData && ne.hydrationData.errors || ze, fetchers: /* @__PURE__ */ new Map(), blockers: /* @__PURE__ */ new Map() }, pt = pr.Pop, dt = !1, yt, Ct = !1, It = !1, Vt = [], Ut = [], Zt = /* @__PURE__ */ new Map(), tr = 0, er = -1, hr = /* @__PURE__ */ new Map(), Ot = /* @__PURE__ */ new Set(), Qe = /* @__PURE__ */ new Map(), at = /* @__PURE__ */ new Map(), wt = /* @__PURE__ */ new Map(), bt = !1;
  function At() {
    return xe = ne.history.listen((Jt) => {
      let { action: or, location: fr, delta: Mr } = Jt;
      if (bt) {
        bt = !1;
        return;
      }
      ln(wt.size === 0 || Mr != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let Wr = Eo({ currentLocation: Ye.location, nextLocation: fr, historyAction: or });
      if (Wr && Mr != null) {
        bt = !0, ne.history.go(Mr * -1), vo(Wr, { state: "blocked", location: fr, proceed() {
          vo(Wr, { state: "proceeding", proceed: void 0, reset: void 0, location: fr }), ne.history.go(Mr);
        }, reset() {
          Ko(Wr), ot({ blockers: new Map(qe.state.blockers) });
        } });
        return;
      }
      return Xt(or, fr);
    }), Ye.initialized || Xt(pr.Pop, Ye.location), qe;
  }
  function Ft() {
    xe && xe(), Oe.clear(), yt && yt.abort(), Ye.fetchers.forEach((Jt, or) => Ho(or)), Ye.blockers.forEach((Jt, or) => Ko(or));
  }
  function Gt(Jt) {
    return Oe.add(Jt), () => Oe.delete(Jt);
  }
  function ot(Jt) {
    Ye = Tt({}, Ye, Jt), Oe.forEach((or) => or(Ye));
  }
  function et(Jt, or) {
    var fr, Mr;
    let Wr = Ye.actionData != null && Ye.navigation.formMethod != null && Eu(Ye.navigation.formMethod) && Ye.navigation.state === "loading" && ((fr = Jt.state) == null ? void 0 : fr._isRedirect) !== !0, Vr;
    or.actionData ? Object.keys(or.actionData).length > 0 ? Vr = or.actionData : Vr = null : Wr ? Vr = Ye.actionData : Vr = null;
    let Zr = or.loaderData ? oq(Ye.loaderData, or.loaderData, or.matches || [], or.errors) : Ye.loaderData;
    for (let [Lr] of wt)
      Ko(Lr);
    let on = dt === !0 || Ye.navigation.formMethod != null && Eu(Ye.navigation.formMethod) && ((Mr = Jt.state) == null ? void 0 : Mr._isRedirect) !== !0;
    ye && (fe = ye, ye = void 0), ot(Tt({}, or, { actionData: Vr, loaderData: Zr, historyAction: pt, location: Jt, initialized: !0, navigation: ok, revalidation: "idle", restoreScrollPosition: Jo(Jt, or.matches || Ye.matches), preventScrollReset: on, blockers: new Map(Ye.blockers) })), Ct || pt === pr.Pop || (pt === pr.Push ? ne.history.push(Jt, Jt.state) : pt === pr.Replace && ne.history.replace(Jt, Jt.state)), pt = pr.Pop, dt = !1, Ct = !1, It = !1, Vt = [], Ut = [];
  }
  async function Rt(Jt, or) {
    if (typeof Jt == "number") {
      ne.history.go(Jt);
      return;
    }
    let fr = lk(Ye.location, Ye.matches, ve, _e.v7_prependBasename, Jt, or == null ? void 0 : or.fromRouteId, or == null ? void 0 : or.relative), { path: Mr, submission: Wr, error: Vr } = tq(_e.v7_normalizeFormMethod, !1, fr, or), Zr = Ye.location, on = uk(Ye.location, Mr, or && or.state);
    on = Tt({}, on, ne.history.encodeLocation(on));
    let Lr = or && or.replace != null ? or.replace : void 0, tn = pr.Push;
    Lr === !0 ? tn = pr.Replace : Lr === !1 || Wr != null && Eu(Wr.formMethod) && Wr.formAction === Ye.location.pathname + Ye.location.search && (tn = pr.Replace);
    let Qn = or && "preventScrollReset" in or ? or.preventScrollReset === !0 : void 0, Fn = Eo({ currentLocation: Zr, nextLocation: on, historyAction: tn });
    if (Fn) {
      vo(Fn, { state: "blocked", location: on, proceed() {
        vo(Fn, { state: "proceeding", proceed: void 0, reset: void 0, location: on }), Rt(Jt, or);
      }, reset() {
        Ko(Fn), ot({ blockers: new Map(Ye.blockers) });
      } });
      return;
    }
    return await Xt(tn, on, { submission: Wr, pendingError: Vr, preventScrollReset: Qn, replace: or && or.replace });
  }
  function xr() {
    if (kn(), ot({ revalidation: "loading" }), Ye.navigation.state !== "submitting") {
      if (Ye.navigation.state === "idle") {
        Xt(Ye.historyAction, Ye.location, { startUninterruptedRevalidation: !0 });
        return;
      }
      Xt(pt || Ye.historyAction, Ye.navigation.location, { overrideNavigation: Ye.navigation });
    }
  }
  async function Xt(Jt, or, fr) {
    yt && yt.abort(), yt = null, pt = Jt, Ct = (fr && fr.startUninterruptedRevalidation) === !0, So(Ye.location, Ye.matches), dt = (fr && fr.preventScrollReset) === !0;
    let Mr = ye || fe, Wr = fr && fr.overrideNavigation, Vr = Cu(Mr, or, ve);
    if (!Vr) {
      let en = Wa(404, { pathname: or.pathname }), { matches: An, route: zn } = uq(Mr);
      ra(), et(or, { matches: An, loaderData: {}, errors: { [zn.id]: en } });
      return;
    }
    if (Mee(Ye.location, or) && !(fr && fr.submission && Eu(fr.submission.formMethod))) {
      et(or, { matches: Vr });
      return;
    }
    yt = new AbortController();
    let Zr = eh(ne.history, or, yt.signal, fr && fr.submission), on, Lr;
    if (fr && fr.pendingError)
      Lr = { [fd(Vr).route.id]: fr.pendingError };
    else if (fr && fr.submission && Eu(fr.submission.formMethod)) {
      let en = await dr(Zr, or, fr.submission, Vr, { replace: fr.replace });
      if (en.shortCircuited)
        return;
      on = en.pendingActionData, Lr = en.pendingActionError, Wr = Tt({ state: "loading", location: or }, fr.submission), Zr = new Request(Zr.url, { signal: Zr.signal });
    }
    let { shortCircuited: tn, loaderData: Qn, errors: Fn } = await Nr(Zr, or, Vr, Wr, fr && fr.submission, fr && fr.fetcherSubmission, fr && fr.replace, on, Lr);
    tn || (yt = null, et(or, Tt({ matches: Vr }, on ? { actionData: on } : {}, { loaderData: Qn, errors: Fn })));
  }
  async function dr(Jt, or, fr, Mr, Wr) {
    kn();
    let Vr = Tt({ state: "submitting", location: or }, fr);
    ot({ navigation: Vr });
    let Zr, on = sk(Mr, or);
    if (!on.route.action && !on.route.lazy)
      Zr = { type: Gr.error, error: Wa(405, { method: Jt.method, pathname: or.pathname, routeId: on.route.id }) };
    else if (Zr = await Zm("action", Jt, on, Mr, ae, oe, ve), Jt.signal.aborted)
      return { shortCircuited: !0 };
    if (dd(Zr)) {
      let Lr;
      return Wr && Wr.replace != null ? Lr = Wr.replace : Lr = Zr.location === Ye.location.pathname + Ye.location.search, await Pn(Ye, Zr, { submission: fr, replace: Lr }), { shortCircuited: !0 };
    }
    if (th(Zr)) {
      let Lr = fd(Mr, on.route.id);
      return (Wr && Wr.replace) !== !0 && (pt = pr.Push), { pendingActionData: {}, pendingActionError: { [Lr.route.id]: Zr.error } };
    }
    if (lc(Zr))
      throw Wa(400, { type: "defer-action" });
    return { pendingActionData: { [on.route.id]: Zr.data } };
  }
  async function Nr(Jt, or, fr, Mr, Wr, Vr, Zr, on, Lr) {
    let tn = Mr;
    tn || (tn = Tt({ state: "loading", location: or, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Wr));
    let Qn = Wr || Vr ? Wr || Vr : tn.formMethod && tn.formAction && tn.formData && tn.formEncType ? { formMethod: tn.formMethod, formAction: tn.formAction, formData: tn.formData, formEncType: tn.formEncType } : void 0, Fn = ye || fe, [en, An] = rq(ne.history, Ye, fr, Qn, or, It, Vt, Ut, Qe, Fn, ve, on, Lr);
    if (ra(($n) => !(fr && fr.some((Bo) => Bo.route.id === $n)) || en && en.some((Bo) => Bo.route.id === $n)), en.length === 0 && An.length === 0) {
      let $n = pa();
      return et(or, Tt({ matches: fr, loaderData: {}, errors: Lr || null }, on ? { actionData: on } : {}, $n ? { fetchers: new Map(Ye.fetchers) } : {})), { shortCircuited: !0 };
    }
    if (!Ct) {
      An.forEach((Bo) => {
        let ho = Ye.fetchers.get(Bo.key), To = { state: "loading", data: ho && ho.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        Ye.fetchers.set(Bo.key, To);
      });
      let $n = on || Ye.actionData;
      ot(Tt({ navigation: tn }, $n ? Object.keys($n).length === 0 ? { actionData: null } : { actionData: $n } : {}, An.length > 0 ? { fetchers: new Map(Ye.fetchers) } : {}));
    }
    er = ++tr, An.forEach(($n) => {
      $n.controller && Zt.set($n.key, $n.controller);
    });
    let zn = () => An.forEach(($n) => Rn($n.key));
    yt && yt.signal.addEventListener("abort", zn);
    let { results: Oo, loaderResults: ii, fetcherResults: No } = await co(Ye.matches, fr, en, An, Jt);
    if (Jt.signal.aborted)
      return { shortCircuited: !0 };
    yt && yt.signal.removeEventListener("abort", zn), An.forEach(($n) => Zt.delete($n.key));
    let Ao = lq(Oo);
    if (Ao)
      return await Pn(Ye, Ao, { replace: Zr }), { shortCircuited: !0 };
    let { loaderData: Da, errors: po } = aq(Ye, fr, en, ii, Lr, An, No, at);
    at.forEach(($n, Bo) => {
      $n.subscribe((ho) => {
        (ho || $n.done) && at.delete(Bo);
      });
    });
    let _o = pa(), Ba = jn(er), bo = _o || Ba || An.length > 0;
    return Tt({ loaderData: Da, errors: po }, bo ? { fetchers: new Map(Ye.fetchers) } : {});
  }
  function Dr(Jt) {
    return Ye.fetchers.get(Jt) || Cee;
  }
  function jr(Jt, or, fr, Mr) {
    if (Ree)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    Zt.has(Jt) && Rn(Jt);
    let Wr = ye || fe, Vr = lk(Ye.location, Ye.matches, ve, _e.v7_prependBasename, fr, or, Mr == null ? void 0 : Mr.relative), Zr = Cu(Wr, Vr, ve);
    if (!Zr) {
      Yn(Jt, or, Wa(404, { pathname: Vr }));
      return;
    }
    let { path: on, submission: Lr } = tq(_e.v7_normalizeFormMethod, !0, Vr, Mr), tn = sk(Zr, on);
    if (dt = (Mr && Mr.preventScrollReset) === !0, Lr && Eu(Lr.formMethod)) {
      un(Jt, or, on, tn, Zr, Lr);
      return;
    }
    Qe.set(Jt, { routeId: or, path: on }), so(Jt, or, on, tn, Zr, Lr);
  }
  async function un(Jt, or, fr, Mr, Wr, Vr) {
    if (kn(), Qe.delete(Jt), !Mr.route.action && !Mr.route.lazy) {
      let Qt = Wa(405, { method: Vr.formMethod, pathname: fr, routeId: or });
      Yn(Jt, or, Qt);
      return;
    }
    let Zr = Ye.fetchers.get(Jt), on = Tt({ state: "submitting" }, Vr, { data: Zr && Zr.data, " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Jt, on), ot({ fetchers: new Map(Ye.fetchers) });
    let Lr = new AbortController(), tn = eh(ne.history, fr, Lr.signal, Vr);
    Zt.set(Jt, Lr);
    let Qn = await Zm("action", tn, Mr, Wr, ae, oe, ve);
    if (tn.signal.aborted) {
      Zt.get(Jt) === Lr && Zt.delete(Jt);
      return;
    }
    if (dd(Qn)) {
      Zt.delete(Jt), Ot.add(Jt);
      let Qt = Tt({ state: "loading" }, Vr, { data: void 0, " _hasFetcherDoneAnything ": !0 });
      return Ye.fetchers.set(Jt, Qt), ot({ fetchers: new Map(Ye.fetchers) }), Pn(Ye, Qn, { submission: Vr, isFetchActionRedirect: !0 });
    }
    if (th(Qn)) {
      Yn(Jt, or, Qn.error);
      return;
    }
    if (lc(Qn))
      throw Wa(400, { type: "defer-action" });
    let Fn = Ye.navigation.location || Ye.location, en = eh(ne.history, Fn, Lr.signal), An = ye || fe, zn = Ye.navigation.state !== "idle" ? Cu(An, Ye.navigation.location, ve) : Ye.matches;
    Te(zn, "Didn't find any matches after fetcher action");
    let Oo = ++tr;
    hr.set(Jt, Oo);
    let ii = Tt({ state: "loading", data: Qn.data }, Vr, { " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Jt, ii);
    let [No, Ao] = rq(ne.history, Ye, zn, Vr, Fn, It, Vt, Ut, Qe, An, ve, { [Mr.route.id]: Qn.data }, void 0);
    Ao.filter((Qt) => Qt.key !== Jt).forEach((Qt) => {
      let kr = Qt.key, Tr = Ye.fetchers.get(kr), vn = { state: "loading", data: Tr && Tr.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      Ye.fetchers.set(kr, vn), Qt.controller && Zt.set(kr, Qt.controller);
    }), ot({ fetchers: new Map(Ye.fetchers) });
    let Da = () => Ao.forEach((Qt) => Rn(Qt.key));
    Lr.signal.addEventListener("abort", Da);
    let { results: po, loaderResults: _o, fetcherResults: Ba } = await co(Ye.matches, zn, No, Ao, en);
    if (Lr.signal.aborted)
      return;
    Lr.signal.removeEventListener("abort", Da), hr.delete(Jt), Zt.delete(Jt), Ao.forEach((Qt) => Zt.delete(Qt.key));
    let bo = lq(po);
    if (bo)
      return Pn(Ye, bo);
    let { loaderData: $n, errors: Bo } = aq(Ye, Ye.matches, No, _o, void 0, Ao, Ba, at), ho = { state: "idle", data: Qn.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    Ye.fetchers.set(Jt, ho);
    let To = jn(Oo);
    Ye.navigation.state === "loading" && Oo > er ? (Te(pt, "Expected pending action"), yt && yt.abort(), et(Ye.navigation.location, { matches: zn, loaderData: $n, errors: Bo, fetchers: new Map(Ye.fetchers) })) : (ot(Tt({ errors: Bo, loaderData: oq(Ye.loaderData, $n, zn, Bo) }, To ? { fetchers: new Map(Ye.fetchers) } : {})), It = !1);
  }
  async function so(Jt, or, fr, Mr, Wr, Vr) {
    let Zr = Ye.fetchers.get(Jt), on = Tt({ state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Vr, { data: Zr && Zr.data, " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Jt, on), ot({ fetchers: new Map(Ye.fetchers) });
    let Lr = new AbortController(), tn = eh(ne.history, fr, Lr.signal);
    Zt.set(Jt, Lr);
    let Qn = await Zm("loader", tn, Mr, Wr, ae, oe, ve);
    if (lc(Qn) && (Qn = await _q(Qn, tn.signal, !0) || Qn), Zt.get(Jt) === Lr && Zt.delete(Jt), tn.signal.aborted)
      return;
    if (dd(Qn)) {
      Ot.add(Jt), await Pn(Ye, Qn);
      return;
    }
    if (th(Qn)) {
      let en = fd(Ye.matches, or);
      Ye.fetchers.delete(Jt), ot({ fetchers: new Map(Ye.fetchers), errors: { [en.route.id]: Qn.error } });
      return;
    }
    Te(!lc(Qn), "Unhandled fetcher deferred data");
    let Fn = { state: "idle", data: Qn.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    Ye.fetchers.set(Jt, Fn), ot({ fetchers: new Map(Ye.fetchers) });
  }
  async function Pn(Jt, or, fr) {
    var Mr;
    let { submission: Wr, replace: Vr, isFetchActionRedirect: Zr } = fr === void 0 ? {} : fr;
    or.revalidate && (It = !0);
    let on = uk(Jt.location, or.location, Tt({ _isRedirect: !0 }, Zr ? { _isFetchActionRedirect: !0 } : {}));
    if (Te(on, "Expected a location on the redirect navigation"), hq.test(or.location) && yq && typeof ((Mr = window) == null ? void 0 : Mr.location) < "u") {
      let An = ne.history.createURL(or.location), zn = Ru(An.pathname, ve) == null;
      if (window.location.origin !== An.origin || zn) {
        Vr ? window.location.replace(or.location) : window.location.assign(or.location);
        return;
      }
    }
    yt = null;
    let Lr = Vr === !0 ? pr.Replace : pr.Push, { formMethod: tn, formAction: Qn, formEncType: Fn, formData: en } = Jt.navigation;
    !Wr && tn && Qn && en && Fn && (Wr = { formMethod: tn, formAction: Qn, formEncType: Fn, formData: en }), Eee.has(or.status) && Wr && Eu(Wr.formMethod) ? await Xt(Lr, on, { submission: Tt({}, Wr, { formAction: or.location }), preventScrollReset: dt }) : Zr ? await Xt(Lr, on, { overrideNavigation: { state: "loading", location: on, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, fetcherSubmission: Wr, preventScrollReset: dt }) : await Xt(Lr, on, { overrideNavigation: { state: "loading", location: on, formMethod: Wr ? Wr.formMethod : void 0, formAction: Wr ? Wr.formAction : void 0, formEncType: Wr ? Wr.formEncType : void 0, formData: Wr ? Wr.formData : void 0 }, preventScrollReset: dt });
  }
  async function co(Jt, or, fr, Mr, Wr) {
    let Vr = await Promise.all([...fr.map((Lr) => Zm("loader", Wr, Lr, or, ae, oe, ve)), ...Mr.map((Lr) => Lr.matches && Lr.match && Lr.controller ? Zm("loader", eh(ne.history, Lr.path, Lr.controller.signal), Lr.match, Lr.matches, ae, oe, ve) : { type: Gr.error, error: Wa(404, { pathname: Lr.path }) })]), Zr = Vr.slice(0, fr.length), on = Vr.slice(fr.length);
    return await Promise.all([sq(Jt, fr, Zr, Zr.map(() => Wr.signal), !1, Ye.loaderData), sq(Jt, Mr.map((Lr) => Lr.match), on, Mr.map((Lr) => Lr.controller ? Lr.controller.signal : null), !0)]), { results: Vr, loaderResults: Zr, fetcherResults: on };
  }
  function kn() {
    It = !0, Vt.push(...ra()), Qe.forEach((Jt, or) => {
      Zt.has(or) && (Ut.push(or), Rn(or));
    });
  }
  function Yn(Jt, or, fr) {
    let Mr = fd(Ye.matches, or);
    Ho(Jt), ot({ errors: { [Mr.route.id]: fr }, fetchers: new Map(Ye.fetchers) });
  }
  function Ho(Jt) {
    Zt.has(Jt) && Rn(Jt), Qe.delete(Jt), hr.delete(Jt), Ot.delete(Jt), Ye.fetchers.delete(Jt);
  }
  function Rn(Jt) {
    let or = Zt.get(Jt);
    Te(or, "Expected fetch controller: " + Jt), or.abort(), Zt.delete(Jt);
  }
  function fo(Jt) {
    for (let or of Jt) {
      let fr = { state: "idle", data: Dr(or).data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      Ye.fetchers.set(or, fr);
    }
  }
  function pa() {
    let Jt = [], or = !1;
    for (let fr of Ot) {
      let Mr = Ye.fetchers.get(fr);
      Te(Mr, "Expected fetcher: " + fr), Mr.state === "loading" && (Ot.delete(fr), Jt.push(fr), or = !0);
    }
    return fo(Jt), or;
  }
  function jn(Jt) {
    let or = [];
    for (let [fr, Mr] of hr)
      if (Mr < Jt) {
        let Wr = Ye.fetchers.get(fr);
        Te(Wr, "Expected fetcher: " + fr), Wr.state === "loading" && (Rn(fr), hr.delete(fr), or.push(fr));
      }
    return fo(or), or.length > 0;
  }
  function Xn(Jt, or) {
    let fr = Ye.blockers.get(Jt) || eq;
    return wt.get(Jt) !== or && wt.set(Jt, or), fr;
  }
  function Ko(Jt) {
    Ye.blockers.delete(Jt), wt.delete(Jt);
  }
  function vo(Jt, or) {
    let fr = Ye.blockers.get(Jt) || eq;
    Te(fr.state === "unblocked" && or.state === "blocked" || fr.state === "blocked" && or.state === "blocked" || fr.state === "blocked" && or.state === "proceeding" || fr.state === "blocked" && or.state === "unblocked" || fr.state === "proceeding" && or.state === "unblocked", "Invalid blocker state transition: " + fr.state + " -> " + or.state), Ye.blockers.set(Jt, or), ot({ blockers: new Map(Ye.blockers) });
  }
  function Eo(Jt) {
    let { currentLocation: or, nextLocation: fr, historyAction: Mr } = Jt;
    if (wt.size === 0)
      return;
    wt.size > 1 && ln(!1, "A router only supports one blocker at a time");
    let Wr = Array.from(wt.entries()), [Vr, Zr] = Wr[Wr.length - 1], on = Ye.blockers.get(Vr);
    if (!(on && on.state === "proceeding") && Zr({ currentLocation: or, nextLocation: fr, historyAction: Mr }))
      return Vr;
  }
  function ra(Jt) {
    let or = [];
    return at.forEach((fr, Mr) => {
      (!Jt || Jt(Mr)) && (fr.cancel(), or.push(Mr), at.delete(Mr));
    }), or;
  }
  function uo(Jt, or, fr) {
    if ($e = Jt, Re = or, Me = fr || ((Mr) => Mr.key), !je && Ye.navigation === ok) {
      je = !0;
      let Mr = Jo(Ye.location, Ye.matches);
      Mr != null && ot({ restoreScrollPosition: Mr });
    }
    return () => {
      $e = null, Re = null, Me = null;
    };
  }
  function So(Jt, or) {
    if ($e && Me && Re) {
      let fr = or.map((Wr) => cq(Wr, Ye.loaderData)), Mr = Me(Jt, fr) || Jt.key;
      $e[Mr] = Re();
    }
  }
  function Jo(Jt, or) {
    if ($e && Me && Re) {
      let fr = or.map((Vr) => cq(Vr, Ye.loaderData)), Mr = Me(Jt, fr) || Jt.key, Wr = $e[Mr];
      if (typeof Wr == "number")
        return Wr;
    }
    return null;
  }
  function Po(Jt) {
    ye = Jt;
  }
  return qe = { get basename() {
    return ve;
  }, get state() {
    return Ye;
  }, get routes() {
    return fe;
  }, initialize: At, subscribe: Gt, enableScrollRestoration: uo, navigate: Rt, fetch: jr, revalidate: xr, createHref: (Jt) => ne.history.createHref(Jt), encodeLocation: (Jt) => ne.history.encodeLocation(Jt), getFetcher: Dr, deleteFetcher: Ho, dispose: Ft, getBlocker: Xn, deleteBlocker: Ko, _internalFetchControllers: Zt, _internalActiveDeferreds: at, _internalSetRoutes: Po }, qe;
}
function Tee(ne) {
  return ne != null && "formData" in ne;
}
function lk(ne, oe, ae, fe, ye, ve, _e) {
  let xe, Oe;
  if (ve != null && _e !== "path") {
    xe = [];
    for (let Me of oe)
      if (xe.push(Me), Me.route.id === ve) {
        Oe = Me;
        break;
      }
  } else
    xe = oe, Oe = oe[oe.length - 1];
  let $e = k0(ye || ".", nh(xe).map((Me) => Me.pathnameBase), ne.pathname, _e === "path");
  return ye == null && ($e.search = ne.search, $e.hash = ne.hash), (ye == null || ye === "" || ye === ".") && Oe && Oe.route.index && !dk($e.search) && ($e.search = $e.search ? $e.search.replace(/^\?/, "?index&") : "?index"), fe && ae !== "/" && ($e.pathname = $e.pathname === "/" ? ae : ha([ae, $e.pathname])), Mo($e);
}
function tq(ne, oe, ae, fe) {
  if (!fe || !Tee(fe))
    return { path: ae };
  if (fe.formMethod && !Lee(fe.formMethod))
    return { path: ae, error: Wa(405, { method: fe.formMethod }) };
  let ye;
  if (fe.formData) {
    let xe = fe.formMethod || "get";
    if (ye = { formMethod: ne ? xe.toUpperCase() : xe.toLowerCase(), formAction: Sq(ae), formEncType: fe && fe.formEncType || "application/x-www-form-urlencoded", formData: fe.formData }, Eu(ye.formMethod))
      return { path: ae, submission: ye };
  }
  let ve = Qi(ae), _e = bq(fe.formData);
  return oe && ve.search && dk(ve.search) && _e.append("index", ""), ve.search = "?" + _e, { path: Mo(ve), submission: ye };
}
function kee(ne, oe) {
  let ae = ne;
  if (oe) {
    let fe = ne.findIndex((ye) => ye.route.id === oe);
    fe >= 0 && (ae = ne.slice(0, fe));
  }
  return ae;
}
function rq(ne, oe, ae, fe, ye, ve, _e, xe, Oe, $e, Me, Re, je) {
  let Be = je ? Object.values(je)[0] : Re ? Object.values(Re)[0] : void 0, ze = ne.createURL(oe.location), He = ne.createURL(ye), qe = je ? Object.keys(je)[0] : void 0, Ye = kee(ae, qe).filter((dt, yt) => {
    if (dt.route.lazy)
      return !0;
    if (dt.route.loader == null)
      return !1;
    if (Aee(oe.loaderData, oe.matches[yt], dt) || _e.some((Vt) => Vt === dt.route.id))
      return !0;
    let Ct = oe.matches[yt], It = dt;
    return nq(dt, Tt({ currentUrl: ze, currentParams: Ct.params, nextUrl: He, nextParams: It.params }, fe, { actionResult: Be, defaultShouldRevalidate: ve || ze.toString() === He.toString() || ze.search !== He.search || gq(Ct, It) }));
  }), pt = [];
  return Oe.forEach((dt, yt) => {
    if (!ae.some((Vt) => Vt.route.id === dt.routeId))
      return;
    let Ct = Cu($e, dt.path, Me);
    if (!Ct) {
      pt.push({ key: yt, routeId: dt.routeId, path: dt.path, matches: null, match: null, controller: null });
      return;
    }
    let It = sk(Ct, dt.path);
    if (xe.includes(yt)) {
      pt.push({ key: yt, routeId: dt.routeId, path: dt.path, matches: Ct, match: It, controller: new AbortController() });
      return;
    }
    nq(It, Tt({ currentUrl: ze, currentParams: oe.matches[oe.matches.length - 1].params, nextUrl: He, nextParams: ae[ae.length - 1].params }, fe, { actionResult: Be, defaultShouldRevalidate: ve })) && pt.push({ key: yt, routeId: dt.routeId, path: dt.path, matches: Ct, match: It, controller: new AbortController() });
  }), [Ye, pt];
}
function Aee(ne, oe, ae) {
  let fe = !oe || ae.route.id !== oe.route.id, ye = ne[ae.route.id] === void 0;
  return fe || ye;
}
function gq(ne, oe) {
  let ae = ne.route.path;
  return ne.pathname !== oe.pathname || ae != null && ae.endsWith("*") && ne.params["*"] !== oe.params["*"];
}
function nq(ne, oe) {
  if (ne.route.shouldRevalidate) {
    let ae = ne.route.shouldRevalidate(oe);
    if (typeof ae == "boolean")
      return ae;
  }
  return oe.defaultShouldRevalidate;
}
async function iq(ne, oe, ae) {
  if (!ne.lazy)
    return;
  let fe = await ne.lazy();
  if (!ne.lazy)
    return;
  let ye = ae[ne.id];
  Te(ye, "No route found in manifest");
  let ve = {};
  for (let _e in fe) {
    let xe = ye[_e] !== void 0 && _e !== "hasErrorBoundary";
    ln(!xe, 'Route "' + ye.id + '" has a static property "' + _e + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + _e + '" will be ignored.')), !xe && !tee.has(_e) && (ve[_e] = fe[_e]);
  }
  Object.assign(ye, ve), Object.assign(ye, Tt({}, oe(ye), { lazy: void 0 }));
}
async function Zm(ne, oe, ae, fe, ye, ve, _e, xe, Oe, $e) {
  xe === void 0 && (xe = !1), Oe === void 0 && (Oe = !1);
  let Me, Re, je, Be = (qe) => {
    let Ye, pt = new Promise((dt, yt) => Ye = yt);
    return je = () => Ye(), oe.signal.addEventListener("abort", je), Promise.race([qe({ request: oe, params: ae.params, context: $e }), pt]);
  };
  try {
    let qe = ae.route[ne];
    if (ae.route.lazy)
      if (qe)
        Re = (await Promise.all([Be(qe), iq(ae.route, ve, ye)]))[0];
      else if (await iq(ae.route, ve, ye), qe = ae.route[ne], qe)
        Re = await Be(qe);
      else if (ne === "action") {
        let Ye = new URL(oe.url), pt = Ye.pathname + Ye.search;
        throw Wa(405, { method: oe.method, pathname: pt, routeId: ae.route.id });
      } else
        return { type: Gr.data, data: void 0 };
    else if (qe)
      Re = await Be(qe);
    else {
      let Ye = new URL(oe.url), pt = Ye.pathname + Ye.search;
      throw Wa(404, { pathname: pt });
    }
    Te(Re !== void 0, "You defined " + (ne === "action" ? "an action" : "a loader") + " for route " + ('"' + ae.route.id + "\" but didn't return anything from your `" + ne + "` ") + "function. Please return a value or `null`.");
  } catch (qe) {
    Me = Gr.error, Re = qe;
  } finally {
    je && oe.signal.removeEventListener("abort", je);
  }
  if (Nee(Re)) {
    let qe = Re.status;
    if (xee.has(qe)) {
      let dt = Re.headers.get("Location");
      if (Te(dt, "Redirects returned/thrown from loaders/actions must have a Location header"), !hq.test(dt))
        dt = lk(new URL(oe.url), fe.slice(0, fe.indexOf(ae) + 1), _e, !0, dt);
      else if (!xe) {
        let yt = new URL(oe.url), Ct = dt.startsWith("//") ? new URL(yt.protocol + dt) : new URL(dt), It = Ru(Ct.pathname, _e) != null;
        Ct.origin === yt.origin && It && (dt = Ct.pathname + Ct.search + Ct.hash);
      }
      if (xe)
        throw Re.headers.set("Location", dt), Re;
      return { type: Gr.redirect, status: qe, location: dt, revalidate: Re.headers.get("X-Remix-Revalidate") !== null };
    }
    if (Oe)
      throw { type: Me || Gr.data, response: Re };
    let Ye, pt = Re.headers.get("Content-Type");
    return pt && /\bapplication\/json\b/.test(pt) ? Ye = await Re.json() : Ye = await Re.text(), Me === Gr.error ? { type: Me, error: new rh(qe, Re.statusText, Ye), headers: Re.headers } : { type: Gr.data, data: Ye, statusCode: Re.status, headers: Re.headers };
  }
  if (Me === Gr.error)
    return { type: Me, error: Re };
  if (Dee(Re)) {
    var ze, He;
    return { type: Gr.deferred, deferredData: Re, statusCode: (ze = Re.init) == null ? void 0 : ze.status, headers: ((He = Re.init) == null ? void 0 : He.headers) && new Headers(Re.init.headers) };
  }
  return { type: Gr.data, data: Re };
}
function eh(ne, oe, ae, fe) {
  let ye = ne.createURL(Sq(oe)).toString(), ve = { signal: ae };
  if (fe && Eu(fe.formMethod)) {
    let { formMethod: _e, formEncType: xe, formData: Oe } = fe;
    ve.method = _e.toUpperCase(), ve.body = xe === "application/x-www-form-urlencoded" ? bq(Oe) : Oe;
  }
  return new Request(ye, ve);
}
function bq(ne) {
  let oe = new URLSearchParams();
  for (let [ae, fe] of ne.entries())
    oe.append(ae, fe instanceof File ? fe.name : fe);
  return oe;
}
function Pee(ne, oe, ae, fe, ye) {
  let ve = {}, _e = null, xe, Oe = !1, $e = {};
  return ae.forEach((Me, Re) => {
    let je = oe[Re].route.id;
    if (Te(!dd(Me), "Cannot handle redirect results in processLoaderData"), th(Me)) {
      let Be = fd(ne, je), ze = Me.error;
      fe && (ze = Object.values(fe)[0], fe = void 0), _e = _e || {}, _e[Be.route.id] == null && (_e[Be.route.id] = ze), ve[je] = void 0, Oe || (Oe = !0, xe = ih(Me.error) ? Me.error.status : 500), Me.headers && ($e[je] = Me.headers);
    } else
      lc(Me) ? (ye.set(je, Me.deferredData), ve[je] = Me.deferredData.data) : ve[je] = Me.data, Me.statusCode != null && Me.statusCode !== 200 && !Oe && (xe = Me.statusCode), Me.headers && ($e[je] = Me.headers);
  }), fe && (_e = fe, ve[Object.keys(fe)[0]] = void 0), { loaderData: ve, errors: _e, statusCode: xe || 200, loaderHeaders: $e };
}
function aq(ne, oe, ae, fe, ye, ve, _e, xe) {
  let { loaderData: Oe, errors: $e } = Pee(oe, ae, fe, ye, xe);
  for (let Me = 0; Me < ve.length; Me++) {
    let { key: Re, match: je, controller: Be } = ve[Me];
    Te(_e !== void 0 && _e[Me] !== void 0, "Did not find corresponding fetcher result");
    let ze = _e[Me];
    if (!(Be && Be.signal.aborted))
      if (th(ze)) {
        let He = fd(ne.matches, je == null ? void 0 : je.route.id);
        $e && $e[He.route.id] || ($e = Tt({}, $e, { [He.route.id]: ze.error })), ne.fetchers.delete(Re);
      } else if (dd(ze))
        Te(!1, "Unhandled fetcher revalidation redirect");
      else if (lc(ze))
        Te(!1, "Unhandled fetcher deferred data");
      else {
        let He = { state: "idle", data: ze.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        ne.fetchers.set(Re, He);
      }
  }
  return { loaderData: Oe, errors: $e };
}
function oq(ne, oe, ae, fe) {
  let ye = Tt({}, oe);
  for (let ve of ae) {
    let _e = ve.route.id;
    if (oe.hasOwnProperty(_e) ? oe[_e] !== void 0 && (ye[_e] = oe[_e]) : ne[_e] !== void 0 && ve.route.loader && (ye[_e] = ne[_e]), fe && fe.hasOwnProperty(_e))
      break;
  }
  return ye;
}
function fd(ne, oe) {
  return (oe ? ne.slice(0, ne.findIndex((ae) => ae.route.id === oe) + 1) : [...ne]).reverse().find((ae) => ae.route.hasErrorBoundary === !0) || ne[0];
}
function uq(ne) {
  let oe = ne.find((ae) => ae.index || !ae.path || ae.path === "/") || { id: "__shim-error-route__" };
  return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: oe }], route: oe };
}
function Wa(ne, oe) {
  let { pathname: ae, routeId: fe, method: ye, type: ve } = oe === void 0 ? {} : oe, _e = "Unknown Server Error", xe = "Unknown @remix-run/router error";
  return ne === 400 ? (_e = "Bad Request", ye && ae && fe ? xe = "You made a " + ye + ' request to "' + ae + '" but ' + ('did not provide a `loader` for route "' + fe + '", ') + "so there is no way to handle the request." : ve === "defer-action" && (xe = "defer() is not supported in actions")) : ne === 403 ? (_e = "Forbidden", xe = 'Route "' + fe + '" does not match URL "' + ae + '"') : ne === 404 ? (_e = "Not Found", xe = 'No route matches URL "' + ae + '"') : ne === 405 && (_e = "Method Not Allowed", ye && ae && fe ? xe = "You made a " + ye.toUpperCase() + ' request to "' + ae + '" but ' + ('did not provide an `action` for route "' + fe + '", ') + "so there is no way to handle the request." : ye && (xe = 'Invalid request method "' + ye.toUpperCase() + '"')), new rh(ne || 500, _e, new Error(xe), !0);
}
function lq(ne) {
  for (let oe = ne.length - 1; oe >= 0; oe--) {
    let ae = ne[oe];
    if (dd(ae))
      return ae;
  }
}
function Sq(ne) {
  let oe = typeof ne == "string" ? Qi(ne) : ne;
  return Mo(Tt({}, oe, { hash: "" }));
}
function Mee(ne, oe) {
  return ne.pathname === oe.pathname && ne.search === oe.search && ne.hash !== oe.hash;
}
function lc(ne) {
  return ne.type === Gr.deferred;
}
function th(ne) {
  return ne.type === Gr.error;
}
function dd(ne) {
  return (ne && ne.type) === Gr.redirect;
}
function Dee(ne) {
  let oe = ne;
  return oe && typeof oe == "object" && typeof oe.data == "object" && typeof oe.subscribe == "function" && typeof oe.cancel == "function" && typeof oe.resolveData == "function";
}
function Nee(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.headers == "object" && typeof ne.body < "u";
}
function Lee(ne) {
  return wee.has(ne.toLowerCase());
}
function Eu(ne) {
  return See.has(ne.toLowerCase());
}
async function sq(ne, oe, ae, fe, ye, ve) {
  for (let _e = 0; _e < ae.length; _e++) {
    let xe = ae[_e], Oe = oe[_e];
    if (!Oe)
      continue;
    let $e = ne.find((Re) => Re.route.id === Oe.route.id), Me = $e != null && !gq($e, Oe) && (ve && ve[Oe.route.id]) !== void 0;
    if (lc(xe) && (ye || Me)) {
      let Re = fe[_e];
      Te(Re, "Expected an AbortSignal for revalidating fetcher deferred result"), await _q(xe, Re, ye).then((je) => {
        je && (ae[_e] = je || ae[_e]);
      });
    }
  }
}
async function _q(ne, oe, ae) {
  if (ae === void 0 && (ae = !1), !await ne.deferredData.resolveData(oe)) {
    if (ae)
      try {
        return { type: Gr.data, data: ne.deferredData.unwrappedData };
      } catch (fe) {
        return { type: Gr.error, error: fe };
      }
    return { type: Gr.data, data: ne.deferredData.data };
  }
}
function dk(ne) {
  return new URLSearchParams(ne).getAll("index").some((oe) => oe === "");
}
function cq(ne, oe) {
  let { route: ae, pathname: fe, params: ye } = ne;
  return { id: ae.id, pathname: fe, params: ye, data: oe[ae.id], handle: ae.handle };
}
function sk(ne, oe) {
  let ae = typeof oe == "string" ? Qi(oe).search : oe.search;
  if (ne[ne.length - 1].route.index && dk(ae || ""))
    return ne[ne.length - 1];
  let fe = nh(ne);
  return fe[fe.length - 1];
}
var pr, Gr, tee, iee, aee, oee, uee, lee, see, Zz, ha, yee, gee, bee, rh, mq, See, _ee, wee, xee, Eee, ok, Cee, eq, hq, yq, Ree, Oee, A0 = Y(() => {
  (function(ne) {
    ne.Pop = "POP", ne.Push = "PUSH", ne.Replace = "REPLACE";
  })(pr || (pr = {})), function(ne) {
    ne.data = "data", ne.deferred = "deferred", ne.redirect = "redirect", ne.error = "error";
  }(Gr || (Gr = {})), tee = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]), iee = /^:\w+$/, aee = 3, oee = 2, uee = 1, lee = 10, see = -2, Zz = (ne) => ne === "*", ha = (ne) => ne.join("/").replace(/\/\/+/g, "/"), yee = (ne) => ne.replace(/\/+$/, "").replace(/^\/*/, "/"), gee = (ne) => !ne || ne === "?" ? "" : ne.startsWith("?") ? ne : "?" + ne, bee = (ne) => !ne || ne === "#" ? "" : ne.startsWith("#") ? ne : "#" + ne, rh = class {
    constructor(ne, oe, ae, fe) {
      fe === void 0 && (fe = !1), this.status = ne, this.statusText = oe || "", this.internal = fe, ae instanceof Error ? (this.data = ae.toString(), this.error = ae) : this.data = ae;
    }
  }, mq = ["post", "put", "patch", "delete"], See = new Set(mq), _ee = ["get", ...mq], wee = new Set(_ee), xee = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Eee = /* @__PURE__ */ new Set([307, 308]), ok = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Cee = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, eq = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, hq = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, yq = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ree = !yq, Oee = (ne) => ({ hasErrorBoundary: !!ne.hasErrorBoundary });
});
function ah() {
  return ah = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, ah.apply(this, arguments);
}
function hk(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe;
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useHref() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: fe, navigator: ye } = se.useContext(ya), { hash: ve, pathname: _e, search: xe } = Fl(ne, { relative: ae }), Oe = _e;
  return fe !== "/" && (Oe = _e === "/" ? fe : ha([fe, _e])), ye.createHref({ pathname: Oe, search: xe, hash: ve });
}
function md() {
  return se.useContext(vd) != null;
}
function Ya() {
  return md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useLocation() may be used only in the context of a <Router> component.") : Te(!1)), se.useContext(vd).location;
}
function Rq(ne) {
  se.useContext(ya).static || se.useLayoutEffect(ne);
}
function Ou() {
  return se.useContext(Ul) != null ? Kee() : Iee();
}
function Iee() {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useNavigate() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: ne, navigator: oe } = se.useContext(ya), { matches: ae } = se.useContext(ga), { pathname: fe } = Ya(), ye = JSON.stringify(nh(ae).map((_e) => _e.pathnameBase)), ve = se.useRef(!1);
  return Rq(() => {
    ve.current = !0;
  }), se.useCallback(function(_e, xe) {
    if (xe === void 0 && (xe = {}), process.env.NODE_ENV !== "production" && ln(ve.current, Cq), !ve.current)
      return;
    if (typeof _e == "number") {
      oe.go(_e);
      return;
    }
    let Oe = k0(_e, JSON.parse(ye), fe, xe.relative === "path");
    ne !== "/" && (Oe.pathname = Oe.pathname === "/" ? ne : ha([ne, Oe.pathname])), (xe.replace ? oe.replace : oe.push)(Oe, xe.state, xe);
  }, [ne, oe, ye, fe]);
}
function Oq(ne) {
  let oe = se.useContext(ga).outlet;
  return oe && se.createElement(Bee.Provider, { value: ne }, oe);
}
function Tu() {
  let { matches: ne } = se.useContext(ga), oe = ne[ne.length - 1];
  return oe ? oe.params : {};
}
function Fl(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { matches: fe } = se.useContext(ga), { pathname: ye } = Ya(), ve = JSON.stringify(nh(fe).map((_e) => _e.pathnameBase));
  return se.useMemo(() => k0(ne, JSON.parse(ve), ye, ae === "path"), [ne, ve, ye, ae]);
}
function Hee(ne, oe, ae) {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useRoutes() may be used only in the context of a <Router> component.") : Te(!1));
  let { navigator: fe } = se.useContext(ya), { matches: ye } = se.useContext(ga), ve = ye[ye.length - 1], _e = ve ? ve.params : {}, xe = ve ? ve.pathname : "/", Oe = ve ? ve.pathnameBase : "/", $e = ve && ve.route;
  if (process.env.NODE_ENV !== "production") {
    let Ye = $e && $e.path || "";
    Xee(xe, !$e || Ye.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + xe + '" (under <Route path="' + Ye + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + Ye + '"> to <Route ') + ('path="' + (Ye === "/" ? "*" : Ye + "/*") + '">.'));
  }
  let Me = Ya(), Re;
  if (oe) {
    var je;
    let Ye = typeof oe == "string" ? Qi(oe) : oe;
    Oe === "/" || (je = Ye.pathname) != null && je.startsWith(Oe) || (process.env.NODE_ENV !== "production" ? Te(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + Oe + '" ') + ('but pathname "' + Ye.pathname + '" was given in the `location` prop.')) : Te(!1)), Re = Ye;
  } else
    Re = Me;
  let Be = Re.pathname || "/", ze = Oe === "/" ? Be : Be.slice(Oe.length) || "/", He = Cu(ne, { pathname: ze });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && ln($e || He != null, 'No routes matched location "' + Re.pathname + Re.search + Re.hash + '" '), process.env.NODE_ENV !== "production" && ln(He == null || He[He.length - 1].route.element !== void 0 || He[He.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + Re.pathname + Re.search + Re.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let qe = Yee(He && He.map((Ye) => Object.assign({}, Ye, { params: Object.assign({}, _e, Ye.params), pathname: ha([Oe, fe.encodeLocation ? fe.encodeLocation(Ye.pathname).pathname : Ye.pathname]), pathnameBase: Ye.pathnameBase === "/" ? Oe : ha([Oe, fe.encodeLocation ? fe.encodeLocation(Ye.pathnameBase).pathname : Ye.pathnameBase]) })), ye, ae);
  return oe && qe ? se.createElement(vd.Provider, { value: { location: ah({ pathname: "/", search: "", hash: "", state: null, key: "default" }, Re), navigationType: pr.Pop } }, qe) : qe;
}
function Vee() {
  let ne = P0(), oe = ih(ne) ? ne.status + " " + ne.statusText : ne instanceof Error ? ne.message : JSON.stringify(ne), ae = ne instanceof Error ? ne.stack : null, fe = "rgba(200,200,200, 0.5)", ye = { padding: "0.5rem", backgroundColor: fe }, ve = { padding: "2px 4px", backgroundColor: fe }, _e = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", ne), _e = se.createElement(se.Fragment, null, se.createElement("p", null, " Hey developer "), se.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", se.createElement("code", { style: ve }, "ErrorBoundary"), " or", " ", se.createElement("code", { style: ve }, "errorElement"), " prop on your route."))), se.createElement(se.Fragment, null, se.createElement("h2", null, "Unexpected Application Error!"), se.createElement("h3", { style: { fontStyle: "italic" } }, oe), ae ? se.createElement("pre", { style: ye }, ae) : null, _e);
}
function Wee(ne) {
  let { routeContext: oe, match: ae, children: fe } = ne, ye = se.useContext(Ul);
  return ye && ye.static && ye.staticContext && (ae.route.errorElement || ae.route.ErrorBoundary) && (ye.staticContext._deepestRenderedBoundaryId = ae.route.id), se.createElement(ga.Provider, { value: oe }, fe);
}
function Yee(ne, oe, ae) {
  var fe;
  if (oe === void 0 && (oe = []), ae === void 0 && (ae = null), ne == null) {
    var ye;
    if ((ye = ae) != null && ye.errors)
      ne = ae.matches;
    else
      return null;
  }
  let ve = ne, _e = (fe = ae) == null ? void 0 : fe.errors;
  if (_e != null) {
    let xe = ve.findIndex((Oe) => Oe.route.id && (_e == null ? void 0 : _e[Oe.route.id]));
    xe >= 0 || (process.env.NODE_ENV !== "production" ? Te(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(_e).join(",")) : Te(!1)), ve = ve.slice(0, Math.min(ve.length, xe + 1));
  }
  return ve.reduceRight((xe, Oe, $e) => {
    let Me = Oe.route.id ? _e == null ? void 0 : _e[Oe.route.id] : null, Re = null;
    ae && (Re = Oe.route.errorElement || $ee);
    let je = oe.concat(ve.slice(0, $e + 1)), Be = () => {
      let ze;
      return Me ? ze = Re : Oe.route.element ? ze = Oe.route.element : ze = xe, se.createElement(Wee, { match: Oe, routeContext: { outlet: xe, matches: je }, children: ze });
    };
    return ae && (Oe.route.ErrorBoundary || Oe.route.errorElement || $e === 0) ? se.createElement(pk, { location: ae.location, revalidation: ae.revalidation, component: Re, error: Me, children: Be(), routeContext: { outlet: null, matches: je } }) : Be();
  }, null);
}
function yk(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Gee(ne) {
  let oe = se.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function gk(ne) {
  let oe = se.useContext(sc);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function Qee(ne) {
  let oe = se.useContext(ga);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function bk(ne) {
  let oe = Qee(ne), ae = oe.matches[oe.matches.length - 1];
  return ae.route.id || (process.env.NODE_ENV !== "production" ? Te(!1, ne + ' can only be used on routes that contain a unique "id"') : Te(!1)), ae.route.id;
}
function Sk() {
  return bk(jl.UseRouteId);
}
function P0() {
  var ne;
  let oe = se.useContext(mk), ae = gk(jl.UseRouteError), fe = bk(jl.UseRouteError);
  return oe || ((ne = ae.errors) == null ? void 0 : ne[fe]);
}
function Kee() {
  let { router: ne } = Gee(vk.UseNavigateStable), oe = bk(jl.UseNavigateStable), ae = se.useRef(!1);
  return Rq(() => {
    ae.current = !0;
  }), se.useCallback(function(fe, ye) {
    ye === void 0 && (ye = {}), process.env.NODE_ENV !== "production" && ln(ae.current, Cq), ae.current && (typeof fe == "number" ? ne.navigate(fe) : ne.navigate(fe, ah({ fromRouteId: oe }, ye)));
  }, [ne, oe]);
}
function Xee(ne, oe, ae) {
  !oe && !wq[ne] && (wq[ne] = !0, process.env.NODE_ENV !== "production" && ln(!1, ae));
}
function xk(ne) {
  let { fallbackElement: oe, router: ae } = ne, [fe, ye] = se.useState(ae.state);
  se.useLayoutEffect(() => ae.subscribe(ye), [ae, ye]);
  let ve = se.useMemo(() => ({ createHref: ae.createHref, encodeLocation: ae.encodeLocation, go: (Oe) => ae.navigate(Oe), push: (Oe, $e, Me) => ae.navigate(Oe, { state: $e, preventScrollReset: Me == null ? void 0 : Me.preventScrollReset }), replace: (Oe, $e, Me) => ae.navigate(Oe, { replace: !0, state: $e, preventScrollReset: Me == null ? void 0 : Me.preventScrollReset }) }), [ae]), _e = ae.basename || "/", xe = se.useMemo(() => ({ router: ae, navigator: ve, static: !1, basename: _e }), [ae, ve, _e]);
  return se.createElement(se.Fragment, null, se.createElement(Ul.Provider, { value: xe }, se.createElement(sc.Provider, { value: fe }, se.createElement(M0, { basename: ae.basename, location: ae.state.location, navigationType: ae.state.historyAction, navigator: ve }, ae.state.initialized ? se.createElement(Jee, { routes: ae.routes, state: fe }) : oe))), null);
}
function Jee(ne) {
  let { routes: oe, state: ae } = ne;
  return Hee(oe, void 0, ae);
}
function cc(ne) {
  return Oq(ne.context);
}
function Ga(ne) {
  process.env.NODE_ENV !== "production" ? Te(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : Te(!1);
}
function M0(ne) {
  let { basename: oe = "/", children: ae = null, location: fe, navigationType: ye = pr.Pop, navigator: ve, static: _e = !1 } = ne;
  md() && (process.env.NODE_ENV !== "production" ? Te(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Te(!1));
  let xe = oe.replace(/^\/*/, "/"), Oe = se.useMemo(() => ({ basename: xe, navigator: ve, static: _e }), [xe, ve, _e]);
  typeof fe == "string" && (fe = Qi(fe));
  let { pathname: $e = "/", search: Me = "", hash: Re = "", state: je = null, key: Be = "default" } = fe, ze = se.useMemo(() => {
    let He = Ru($e, xe);
    return He == null ? null : { location: { pathname: He, search: Me, hash: Re, state: je, key: Be }, navigationType: ye };
  }, [xe, $e, Me, Re, je, Be, ye]);
  return process.env.NODE_ENV !== "production" && ln(ze != null, '<Router basename="' + xe + '"> is not able to match the URL ' + ('"' + $e + Me + Re + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), ze == null ? null : se.createElement(ya.Provider, { value: Oe }, se.createElement(vd.Provider, { children: ae, value: ze }));
}
function pd(ne, oe) {
  oe === void 0 && (oe = []);
  let ae = [];
  return se.Children.forEach(ne, (fe, ye) => {
    if (!se.isValidElement(fe))
      return;
    let ve = [...oe, ye];
    if (fe.type === se.Fragment) {
      ae.push.apply(ae, pd(fe.props.children, ve));
      return;
    }
    fe.type !== Ga && (process.env.NODE_ENV !== "production" ? Te(!1, "[" + (typeof fe.type == "string" ? fe.type : fe.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : Te(!1)), !fe.props.index || !fe.props.children || (process.env.NODE_ENV !== "production" ? Te(!1, "An index route cannot have child routes.") : Te(!1));
    let _e = { id: fe.props.id || ve.join("-"), caseSensitive: fe.props.caseSensitive, element: fe.props.element, Component: fe.props.Component, index: fe.props.index, path: fe.props.path, loader: fe.props.loader, action: fe.props.action, errorElement: fe.props.errorElement, ErrorBoundary: fe.props.ErrorBoundary, hasErrorBoundary: fe.props.ErrorBoundary != null || fe.props.errorElement != null, shouldRevalidate: fe.props.shouldRevalidate, handle: fe.props.handle, lazy: fe.props.lazy };
    fe.props.children && (_e.children = pd(fe.props.children, ve)), ae.push(_e);
  }), ae;
}
function Tq(ne) {
  let oe = { hasErrorBoundary: ne.ErrorBoundary != null || ne.errorElement != null };
  return ne.Component && (process.env.NODE_ENV !== "production" && ne.element && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(oe, { element: se.createElement(ne.Component), Component: void 0 })), ne.ErrorBoundary && (process.env.NODE_ENV !== "production" && ne.errorElement && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(oe, { errorElement: se.createElement(ne.ErrorBoundary), ErrorBoundary: void 0 })), oe;
}
function Ek(ne, oe) {
  return fk({ basename: oe == null ? void 0 : oe.basename, future: ah({}, oe == null ? void 0 : oe.future, { v7_prependBasename: !0 }), history: fq({ initialEntries: oe == null ? void 0 : oe.initialEntries, initialIndex: oe == null ? void 0 : oe.initialIndex }), hydrationData: oe == null ? void 0 : oe.hydrationData, routes: ne, mapRouteProperties: Tq }).initialize();
}
var se, Ul, sc, qee, ya, vd, ga, mk, Cq, Bee, $ee, pk, vk, jl, wq, xq, Ck = Y(() => {
  se = le(ir()), A0(), A0(), Ul = se.createContext(null), process.env.NODE_ENV !== "production" && (Ul.displayName = "DataRouter"), sc = se.createContext(null), process.env.NODE_ENV !== "production" && (sc.displayName = "DataRouterState"), qee = se.createContext(null), process.env.NODE_ENV !== "production" && (qee.displayName = "Await"), ya = se.createContext(null), process.env.NODE_ENV !== "production" && (ya.displayName = "Navigation"), vd = se.createContext(null), process.env.NODE_ENV !== "production" && (vd.displayName = "Location"), ga = se.createContext({ outlet: null, matches: [] }), process.env.NODE_ENV !== "production" && (ga.displayName = "Route"), mk = se.createContext(null), process.env.NODE_ENV !== "production" && (mk.displayName = "RouteError"), Cq = "You should call navigate() in a React.useEffect(), not when your component is first rendered.", Bee = se.createContext(null), $ee = se.createElement(Vee, null), pk = class extends se.Component {
    constructor(ne) {
      super(ne), this.state = { location: ne.location, revalidation: ne.revalidation, error: ne.error };
    }
    static getDerivedStateFromError(ne) {
      return { error: ne };
    }
    static getDerivedStateFromProps(ne, oe) {
      return oe.location !== ne.location || oe.revalidation !== "idle" && ne.revalidation === "idle" ? { error: ne.error, location: ne.location, revalidation: ne.revalidation } : { error: ne.error || oe.error, location: oe.location, revalidation: ne.revalidation || oe.revalidation };
    }
    componentDidCatch(ne, oe) {
      console.error("React Router caught the following error during render", ne, oe);
    }
    render() {
      return this.state.error ? se.createElement(ga.Provider, { value: this.props.routeContext }, se.createElement(mk.Provider, { value: this.state.error, children: this.props.component })) : this.props.children;
    }
  }, function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate";
  }(vk || (vk = {})), function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseLoaderData = "useLoaderData", ne.UseActionData = "useActionData", ne.UseRouteError = "useRouteError", ne.UseNavigation = "useNavigation", ne.UseRouteLoaderData = "useRouteLoaderData", ne.UseMatches = "useMatches", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate", ne.UseRouteId = "useRouteId";
  }(jl || (jl = {})), wq = {}, function(ne) {
    ne[ne.pending = 0] = "pending", ne[ne.success = 1] = "success", ne[ne.error = 2] = "error";
  }(xq || (xq = {})), new Promise(() => {
  });
});
function zl() {
  return zl = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, zl.apply(this, arguments);
}
function Tk(ne, oe) {
  if (ne == null)
    return {};
  var ae = {}, fe = Object.keys(ne), ye, ve;
  for (ve = 0; ve < fe.length; ve++)
    ye = fe[ve], !(oe.indexOf(ye) >= 0) && (ae[ye] = ne[ye]);
  return ae;
}
function j0(ne) {
  return ne != null && typeof ne.tagName == "string";
}
function ete(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "button";
}
function tte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "form";
}
function rte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "input";
}
function nte(ne) {
  return !!(ne.metaKey || ne.altKey || ne.ctrlKey || ne.shiftKey);
}
function ite(ne, oe) {
  return ne.button === 0 && (!oe || oe === "_self") && !nte(ne);
}
function ate(ne, oe, ae) {
  let fe, ye = null, ve, _e;
  if (tte(ne)) {
    let xe = oe.submissionTrigger;
    if (oe.action)
      ye = oe.action;
    else {
      let Oe = ne.getAttribute("action");
      ye = Oe ? Ru(Oe, ae) : null;
    }
    fe = oe.method || ne.getAttribute("method") || N0, ve = oe.encType || ne.getAttribute("enctype") || Rk, _e = new FormData(ne), xe && xe.name && _e.append(xe.name, xe.value);
  } else if (ete(ne) || rte(ne) && (ne.type === "submit" || ne.type === "image")) {
    let xe = ne.form;
    if (xe == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    if (oe.action)
      ye = oe.action;
    else {
      let Oe = ne.getAttribute("formaction") || xe.getAttribute("action");
      ye = Oe ? Ru(Oe, ae) : null;
    }
    fe = oe.method || ne.getAttribute("formmethod") || xe.getAttribute("method") || N0, ve = oe.encType || ne.getAttribute("formenctype") || xe.getAttribute("enctype") || Rk, _e = new FormData(xe), ne.name && _e.append(ne.name, ne.value);
  } else {
    if (j0(ne))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    if (fe = oe.method || N0, ye = oe.action || null, ve = oe.encType || Rk, ne instanceof FormData)
      _e = ne;
    else if (_e = new FormData(), ne instanceof URLSearchParams)
      for (let [xe, Oe] of ne)
        _e.append(xe, Oe);
    else if (ne != null)
      for (let xe of Object.keys(ne))
        _e.append(xe, ne[xe]);
  }
  return { action: ye, method: fe.toLowerCase(), encType: ve, formData: _e };
}
function Mq(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Dq(ne) {
  let oe = ft.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, Mq(ne)) : Te(!1)), oe;
}
function hte(ne, oe) {
  let { target: ae, replace: fe, state: ye, preventScrollReset: ve, relative: _e } = oe === void 0 ? {} : oe, xe = Ou(), Oe = Ya(), $e = Fl(ne, { relative: _e });
  return ft.useCallback((Me) => {
    if (ite(Me, ae)) {
      Me.preventDefault();
      let Re = fe !== void 0 ? fe : Mo(Oe) === Mo($e);
      xe(ne, { replace: Re, state: ye, preventScrollReset: ve, relative: _e });
    }
  }, [Oe, xe, $e, fe, ye, ae, ne, ve, _e]);
}
function yte(ne, oe) {
  let { router: ae } = Dq(L0.UseSubmitImpl), { basename: fe } = ft.useContext(ya), ye = Sk();
  return ft.useCallback(function(ve, _e) {
    if (_e === void 0 && (_e = {}), typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let { action: xe, method: Oe, encType: $e, formData: Me } = ate(ve, _e, fe), Re = { preventScrollReset: _e.preventScrollReset, formData: Me, formMethod: Oe, formEncType: $e };
    ne ? (oe == null && (process.env.NODE_ENV !== "production" ? Te(!1, "No routeId available for useFetcher()") : Te(!1)), ae.fetch(ne, oe, xe, Re)) : ae.navigate(xe, zl({}, Re, { replace: _e.replace, fromRouteId: ye }));
  }, [ae, fe, ne, oe, ye]);
}
function gte(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { basename: fe } = ft.useContext(ya), ye = ft.useContext(ga);
  ye || (process.env.NODE_ENV !== "production" ? Te(!1, "useFormAction must be used inside a RouteContext") : Te(!1));
  let [ve] = ye.matches.slice(-1), _e = zl({}, Fl(ne || ".", { relative: ae })), xe = Ya();
  if (ne == null && (_e.search = xe.search, _e.hash = xe.hash, ve.route.index)) {
    let Oe = new URLSearchParams(_e.search);
    Oe.delete("index"), _e.search = Oe.toString() ? "?" + Oe.toString() : "";
  }
  return (!ne || ne === ".") && ve.route.index && (_e.search = _e.search ? _e.search.replace(/^\?/, "?index&") : "?index"), fe !== "/" && (_e.pathname = _e.pathname === "/" ? fe : ha([fe, _e.pathname])), Mo(_e);
}
var ft, N0, Rk, ote, ute, lte, cte, fte, Aq, dte, pte, Pq, L0, Ok, Do = Y(() => {
  ft = le(ir()), Ck(), Ck(), A0(), N0 = "get", Rk = "application/x-www-form-urlencoded", ote = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], ute = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], lte = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"], process.env.NODE_ENV, cte = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", fte = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Aq = ft.forwardRef(function(ne, oe) {
    let { onClick: ae, relative: fe, reloadDocument: ye, replace: ve, state: _e, target: xe, to: Oe, preventScrollReset: $e } = ne, Me = Tk(ne, ote), { basename: Re } = ft.useContext(ya), je, Be = !1;
    if (typeof Oe == "string" && fte.test(Oe) && (je = Oe, cte))
      try {
        let Ye = new URL(window.location.href), pt = Oe.startsWith("//") ? new URL(Ye.protocol + Oe) : new URL(Oe), dt = Ru(pt.pathname, Re);
        pt.origin === Ye.origin && dt != null ? Oe = dt + pt.search + pt.hash : Be = !0;
      } catch {
        process.env.NODE_ENV !== "production" && ln(!1, '<Link to="' + Oe + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
      }
    let ze = hk(Oe, { relative: fe }), He = hte(Oe, { replace: ve, state: _e, target: xe, preventScrollReset: $e, relative: fe });
    function qe(Ye) {
      ae && ae(Ye), Ye.defaultPrevented || He(Ye);
    }
    return ft.createElement("a", zl({}, Me, { href: je || ze, onClick: Be || ye ? ae : qe, ref: oe, target: xe }));
  }), process.env.NODE_ENV !== "production" && (Aq.displayName = "Link"), dte = ft.forwardRef(function(ne, oe) {
    let { "aria-current": ae = "page", caseSensitive: fe = !1, className: ye = "", end: ve = !1, style: _e, to: xe, children: Oe } = ne, $e = Tk(ne, ute), Me = Fl(xe, { relative: $e.relative }), Re = Ya(), je = ft.useContext(sc), { navigator: Be } = ft.useContext(ya), ze = Be.encodeLocation ? Be.encodeLocation(Me).pathname : Me.pathname, He = Re.pathname, qe = je && je.navigation && je.navigation.location ? je.navigation.location.pathname : null;
    fe || (He = He.toLowerCase(), qe = qe ? qe.toLowerCase() : null, ze = ze.toLowerCase());
    let Ye = He === ze || !ve && He.startsWith(ze) && He.charAt(ze.length) === "/", pt = qe != null && (qe === ze || !ve && qe.startsWith(ze) && qe.charAt(ze.length) === "/"), dt = Ye ? ae : void 0, yt;
    typeof ye == "function" ? yt = ye({ isActive: Ye, isPending: pt }) : yt = [ye, Ye ? "active" : null, pt ? "pending" : null].filter(Boolean).join(" ");
    let Ct = typeof _e == "function" ? _e({ isActive: Ye, isPending: pt }) : _e;
    return ft.createElement(Aq, zl({}, $e, { "aria-current": dt, className: yt, ref: oe, style: Ct, to: xe }), typeof Oe == "function" ? Oe({ isActive: Ye, isPending: pt }) : Oe);
  }), process.env.NODE_ENV !== "production" && (dte.displayName = "NavLink"), pte = ft.forwardRef((ne, oe) => ft.createElement(Pq, zl({}, ne, { ref: oe }))), process.env.NODE_ENV !== "production" && (pte.displayName = "Form"), Pq = ft.forwardRef((ne, oe) => {
    let { reloadDocument: ae, replace: fe, method: ye = N0, action: ve, onSubmit: _e, fetcherKey: xe, routeId: Oe, relative: $e, preventScrollReset: Me } = ne, Re = Tk(ne, lte), je = yte(xe, Oe), Be = ye.toLowerCase() === "get" ? "get" : "post", ze = gte(ve, { relative: $e });
    return ft.createElement("form", zl({ ref: oe, method: Be, action: ze, onSubmit: ae ? _e : (He) => {
      if (_e && _e(He), He.defaultPrevented)
        return;
      He.preventDefault();
      let qe = He.nativeEvent.submitter, Ye = (qe == null ? void 0 : qe.getAttribute("formmethod")) || ye;
      je(qe || He.currentTarget, { method: Ye, replace: fe, relative: $e, preventScrollReset: Me });
    } }, Re));
  }), process.env.NODE_ENV !== "production" && (Pq.displayName = "FormImpl"), process.env.NODE_ENV, function(ne) {
    ne.UseScrollRestoration = "useScrollRestoration", ne.UseSubmitImpl = "useSubmitImpl", ne.UseFetcher = "useFetcher";
  }(L0 || (L0 = {})), function(ne) {
    ne.UseFetchers = "useFetchers", ne.UseScrollRestoration = "useScrollRestoration";
  }(Ok || (Ok = {}));
});
function sn({ to: ne, className: oe, type: ae, onClick: fe, ...ye }) {
  let ve = Ou(), _e = Fl(ne), xe = Ya(), Oe = _e.pathname, $e = xe.pathname, Me = $e === Oe || $e.startsWith(Oe) && $e.charAt(Oe.length) === "/";
  return (0, Nq.jsx)("button", { type: ae || "button", className: typeof oe == "function" ? oe({ isActive: Me }) : oe, onClick: (Re) => {
    ve(ne), fe == null || fe(Re);
  }, ...ye });
}
var Nq, ql = Y(() => {
  Do(), Nq = le(ke(), 1);
}), Lq = {};
Uj(Lq, { DevToolsProvider: () => _te, useDevToolsContext: () => zt });
var Qa, jq, kk, _te, zt, ai = Y(() => {
  Qa = le(ir(), 1), jq = le(ke(), 1), kk = (0, Qa.createContext)(null), _te = ({ children: ne, value: oe }) => {
    if ((0, Qa.useContext)(kk))
      throw new Error("DevToolsProvider can only be used once");
    let [ae, fe] = (0, Qa.useState)([]);
    (0, Qa.useEffect)(() => {
      let _e = oe.write$.subscribe((xe) => {
        fe((Oe) => [...Oe, xe]);
      });
      return () => _e.unsubscribe();
    }, [oe.write$]);
    let [ye, ve] = (0, Qa.useState)([]);
    return (0, Qa.useEffect)(() => {
      let _e = oe.storedBlockLogs$.subscribe(({ logs: xe }) => {
        ve((Oe) => [...Oe, ...xe]);
      });
      return () => _e.unsubscribe();
    }, [oe.storedBlockLogs$]), (0, jq.jsx)(kk.Provider, { value: { ...oe, writes: ae, storedLogs: ye }, children: ne });
  }, zt = () => {
    let ne = (0, Qa.useContext)(kk);
    if (!ne)
      throw new Error("Must be used within a DevToolsProvider");
    return ne;
  };
});
function Uq() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Ki.jsxs)(Ki.Fragment, { children: [(0, Ki.jsxs)("div", { className: "flex-none bg-slate-900 text-white/60 font-medium", children: [(0, Ki.jsx)(sn, { to: "/", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Summary" }), (0, Ki.jsx)(sn, { to: "/actions", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Actions" }), (0, Ki.jsx)(sn, { to: "/events", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Store log" }), oe ? (0, Ki.jsx)(sn, { to: "/tables", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Tables" }) : null, ne ? (0, Ki.jsx)(sn, { to: "/components", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Components" }) : null] }), (0, Ki.jsx)("div", { className: "flex-1 overflow-auto", children: (0, Ki.jsx)(cc, {}) })] });
}
var Ki, Fq = Y(() => {
  uc(), Do(), ql(), ai(), Ki = le(ke(), 1);
});
function U0({ error: ne }) {
  return (0, zq.jsx)("div", { className: "font-mono text-xs whitespace-pre overflow-auto bg-red-900/50 text-white p-4 rounded", children: ne instanceof Error ? ne.stack : String(ne) });
}
var zq, Ak = Y(() => {
  zq = le(ke(), 1);
});
function qq() {
  let ne = P0();
  return (0, hd.jsxs)("div", { className: "p-6 space-y-6", children: [(0, hd.jsxs)("p", { children: ["Whoops, something broke! Please", " ", (0, hd.jsx)("a", { href: `https://github.com/latticexyz/mud/issues/new?${new URLSearchParams({ body: `
**Steps to reproduce**

1. Go to 
2. Click on 
3. Scroll down to 
4. See error

**Expected behavior**

A clear and concise description of what you expected to happen.

**Error**
\`\`\`
${ne instanceof Error ? ne.stack : String(ne)}
\`\`\`
` })}`, target: "_blank", className: "text-white underline", children: "report the issue" }), " ", "so we can look into it."] }), (0, hd.jsx)(U0, { error: ne })] });
}
var hd, Iq = Y(() => {
  Do(), Ak(), hd = le(ke(), 1);
});
function Bq({ type: ne }) {
  switch (ne) {
    case "Store_SetRecord":
      return (0, F0.jsx)("span", { className: "text-green-500 font-bold", children: "=" });
    case "Store_SpliceStaticData":
    case "Store_SpliceDynamicData":
      return (0, F0.jsx)("span", { className: "text-cyan-500 font-bold", children: "+" });
    case "Store_DeleteRecord":
      return (0, F0.jsx)("span", { className: "text-red-500 font-bold", children: "-" });
    default:
      return u$4(ne, `Unexpected event type: ${ne}`);
  }
}
var F0, Hq = Y(() => {
  F0 = le(ke(), 1);
});
function z0({ logs: ne }) {
  return (0, cn.jsxs)("table", { className: "w-full table-fixed -mx-1", children: [(0, cn.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-amber-200/80 text-left", children: (0, cn.jsxs)("tr", { children: [(0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "block" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "table" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "key" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-[1em]" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs", children: "value" })] }) }), (0, cn.jsx)("tbody", { className: "font-mono text-xs", children: ne.map((oe) => {
    var ve;
    let ae = _$4(oe.args.tableId), { namespace: fe, name: ye } = ae;
    return (0, cn.jsxs)("tr", { className: "hover:bg-blue-800", children: [(0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis text-white/40", children: (ve = oe.blockNumber) == null ? void 0 : ve.toString() }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: i$6(ae) }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: oe.args.keyTuple.join(",") }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap", children: (0, cn.jsx)(Bq, { type: oe.eventName }) }), (0, cn.jsxs)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: [oe.eventName === "Store_SetRecord" ? JSON.stringify({ staticData: oe.args.staticData, encodedLengths: oe.args.encodedLengths, dynamicData: oe.args.dynamicData }) : null, oe.eventName === "Store_SpliceStaticData" ? JSON.stringify({ start: oe.args.start, data: oe.args.data }) : null, oe.eventName === "Store_SpliceDynamicData" ? JSON.stringify({ start: oe.args.start, deleteCount: oe.args.deleteCount, encodedLengths: oe.args.encodedLengths, data: oe.args.data }) : null] })] }, oe.blockHash != null && oe.logIndex != null ? `${oe.blockHash}:${oe.logIndex}` : `${fe}:${ye}:${oe.args.keyTuple.join(",")}`);
  }) })] });
}
var cn, Pk = Y(() => {
  Hq(), cn = le(ke(), 1);
});
function Vq() {
  let { storedLogs: ne } = zt(), oe = (0, yd.useRef)(null), ae = (0, yd.useRef)(!1), fe = (0, yd.useRef)("auto");
  return (0, yd.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, Mk.jsx)("div", { ref: oe, className: "px-2 pb-1", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: (0, Mk.jsx)(z0, { logs: ne }) });
}
var yd, Mk, $q = Y(() => {
  yd = le(ir(), 1), ai(), Pk(), Mk = le(ke(), 1);
}), Dk = M((ne, oe) => {
  oe.exports = function ae(fe, ye) {
    if (fe === ye)
      return !0;
    if (fe && ye && typeof fe == "object" && typeof ye == "object") {
      if (fe.constructor !== ye.constructor)
        return !1;
      var ve, _e, xe;
      if (Array.isArray(fe)) {
        if (ve = fe.length, ve != ye.length)
          return !1;
        for (_e = ve; _e-- !== 0; )
          if (!ae(fe[_e], ye[_e]))
            return !1;
        return !0;
      }
      if (fe.constructor === RegExp)
        return fe.source === ye.source && fe.flags === ye.flags;
      if (fe.valueOf !== Object.prototype.valueOf)
        return fe.valueOf() === ye.valueOf();
      if (fe.toString !== Object.prototype.toString)
        return fe.toString() === ye.toString();
      if (xe = Object.keys(fe), ve = xe.length, ve !== Object.keys(ye).length)
        return !1;
      for (_e = ve; _e-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(ye, xe[_e]))
          return !1;
      for (_e = ve; _e-- !== 0; ) {
        var Oe = xe[_e];
        if (!ae(fe[Oe], ye[Oe]))
          return !1;
      }
      return !0;
    }
    return fe !== fe && ye !== ye;
  };
}), Mt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isFunction = void 0;
  function oe(ae) {
    return typeof ae == "function";
  }
  ne.isFunction = oe;
}), Il = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createErrorClass = void 0;
  function oe(ae) {
    var fe = function(ve) {
      Error.call(ve), ve.stack = new Error().stack;
    }, ye = ae(fe);
    return ye.prototype = Object.create(Error.prototype), ye.prototype.constructor = ye, ye;
  }
  ne.createErrorClass = oe;
}), Nk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.UnsubscriptionError = void 0;
  var oe = Il();
  ne.UnsubscriptionError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.message = fe ? fe.length + ` errors occurred during unsubscription:
` + fe.map(function(ye, ve) {
        return ve + 1 + ") " + ye.toString();
      }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = fe;
    };
  });
}), ku = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.arrRemove = void 0;
  function oe(ae, fe) {
    if (ae) {
      var ye = ae.indexOf(fe);
      0 <= ye && ae.splice(ye, 1);
    }
  }
  ne.arrRemove = oe;
}), Oi = M((ne) => {
  var oe = ne && ne.__values || function(Me) {
    var Re = typeof Symbol == "function" && Symbol.iterator, je = Re && Me[Re], Be = 0;
    if (je)
      return je.call(Me);
    if (Me && typeof Me.length == "number")
      return { next: function() {
        return Me && Be >= Me.length && (Me = void 0), { value: Me && Me[Be++], done: !Me };
      } };
    throw new TypeError(Re ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }, ae = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, fe = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isSubscription = ne.EMPTY_SUBSCRIPTION = ne.Subscription = void 0;
  var ye = Mt(), ve = Nk(), _e = ku(), xe = function() {
    function Me(Re) {
      this.initialTeardown = Re, this.closed = !1, this._parentage = null, this._finalizers = null;
    }
    return Me.prototype.unsubscribe = function() {
      var Re, je, Be, ze, He;
      if (!this.closed) {
        this.closed = !0;
        var qe = this._parentage;
        if (qe)
          if (this._parentage = null, Array.isArray(qe))
            try {
              for (var Ye = oe(qe), pt = Ye.next(); !pt.done; pt = Ye.next()) {
                var dt = pt.value;
                dt.remove(this);
              }
            } catch (Zt) {
              Re = { error: Zt };
            } finally {
              try {
                pt && !pt.done && (je = Ye.return) && je.call(Ye);
              } finally {
                if (Re)
                  throw Re.error;
              }
            }
          else
            qe.remove(this);
        var yt = this.initialTeardown;
        if (ye.isFunction(yt))
          try {
            yt();
          } catch (Zt) {
            He = Zt instanceof ve.UnsubscriptionError ? Zt.errors : [Zt];
          }
        var Ct = this._finalizers;
        if (Ct) {
          this._finalizers = null;
          try {
            for (var It = oe(Ct), Vt = It.next(); !Vt.done; Vt = It.next()) {
              var Ut = Vt.value;
              try {
                $e(Ut);
              } catch (Zt) {
                He = He ?? [], Zt instanceof ve.UnsubscriptionError ? He = fe(fe([], ae(He)), ae(Zt.errors)) : He.push(Zt);
              }
            }
          } catch (Zt) {
            Be = { error: Zt };
          } finally {
            try {
              Vt && !Vt.done && (ze = It.return) && ze.call(It);
            } finally {
              if (Be)
                throw Be.error;
            }
          }
        }
        if (He)
          throw new ve.UnsubscriptionError(He);
      }
    }, Me.prototype.add = function(Re) {
      var je;
      if (Re && Re !== this)
        if (this.closed)
          $e(Re);
        else {
          if (Re instanceof Me) {
            if (Re.closed || Re._hasParent(this))
              return;
            Re._addParent(this);
          }
          (this._finalizers = (je = this._finalizers) !== null && je !== void 0 ? je : []).push(Re);
        }
    }, Me.prototype._hasParent = function(Re) {
      var je = this._parentage;
      return je === Re || Array.isArray(je) && je.includes(Re);
    }, Me.prototype._addParent = function(Re) {
      var je = this._parentage;
      this._parentage = Array.isArray(je) ? (je.push(Re), je) : je ? [je, Re] : Re;
    }, Me.prototype._removeParent = function(Re) {
      var je = this._parentage;
      je === Re ? this._parentage = null : Array.isArray(je) && _e.arrRemove(je, Re);
    }, Me.prototype.remove = function(Re) {
      var je = this._finalizers;
      je && _e.arrRemove(je, Re), Re instanceof Me && Re._removeParent(this);
    }, Me.EMPTY = function() {
      var Re = new Me();
      return Re.closed = !0, Re;
    }(), Me;
  }();
  ne.Subscription = xe, ne.EMPTY_SUBSCRIPTION = xe.EMPTY;
  function Oe(Me) {
    return Me instanceof xe || Me && "closed" in Me && ye.isFunction(Me.remove) && ye.isFunction(Me.add) && ye.isFunction(Me.unsubscribe);
  }
  ne.isSubscription = Oe;
  function $e(Me) {
    ye.isFunction(Me) ? Me() : Me.unsubscribe();
  }
}), gd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.config = void 0, ne.config = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 };
}), Uk = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var ve = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!ve)
      return fe;
    var _e = ve.call(fe), xe, Oe = [], $e;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(xe = _e.next()).done; )
        Oe.push(xe.value);
    } catch (Me) {
      $e = { error: Me };
    } finally {
      try {
        xe && !xe.done && (ve = _e.return) && ve.call(_e);
      } finally {
        if ($e)
          throw $e.error;
      }
    }
    return Oe;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var ve = 0, _e = ye.length, xe = fe.length; ve < _e; ve++, xe++)
      fe[xe] = ye[ve];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutProvider = void 0, ne.timeoutProvider = { setTimeout: function(fe, ye) {
    for (var ve = [], _e = 2; _e < arguments.length; _e++)
      ve[_e - 2] = arguments[_e];
    var xe = ne.timeoutProvider.delegate;
    return xe != null && xe.setTimeout ? xe.setTimeout.apply(xe, ae([fe, ye], oe(ve))) : setTimeout.apply(void 0, ae([fe, ye], oe(ve)));
  }, clearTimeout: function(fe) {
    var ye = ne.timeoutProvider.delegate;
    return ((ye == null ? void 0 : ye.clearTimeout) || clearTimeout)(fe);
  }, delegate: void 0 };
}), Fk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reportUnhandledError = void 0;
  var oe = gd(), ae = Uk();
  function fe(ye) {
    ae.timeoutProvider.setTimeout(function() {
      var ve = oe.config.onUnhandledError;
      if (ve)
        ve(ye);
      else
        throw ye;
    });
  }
  ne.reportUnhandledError = fe;
}), On = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.noop = void 0;
  function oe() {
  }
  ne.noop = oe;
}), eI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createNotification = ne.nextNotification = ne.errorNotification = ne.COMPLETE_NOTIFICATION = void 0, ne.COMPLETE_NOTIFICATION = function() {
    return fe("C", void 0, void 0);
  }();
  function oe(ye) {
    return fe("E", void 0, ye);
  }
  ne.errorNotification = oe;
  function ae(ye) {
    return fe("N", ye, void 0);
  }
  ne.nextNotification = ae;
  function fe(ye, ve, _e) {
    return { kind: ye, value: ve, error: _e };
  }
  ne.createNotification = fe;
}), G0 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.captureError = ne.errorContext = void 0;
  var oe = gd(), ae = null;
  function fe(ve) {
    if (oe.config.useDeprecatedSynchronousErrorHandling) {
      var _e = !ae;
      if (_e && (ae = { errorThrown: !1, error: null }), ve(), _e) {
        var xe = ae, Oe = xe.errorThrown, $e = xe.error;
        if (ae = null, Oe)
          throw $e;
      }
    } else
      ve();
  }
  ne.errorContext = fe;
  function ye(ve) {
    oe.config.useDeprecatedSynchronousErrorHandling && ae && (ae.errorThrown = !0, ae.error = ve);
  }
  ne.captureError = ye;
}), Sd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var pt = function(dt, yt) {
      return pt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ct, It) {
        Ct.__proto__ = It;
      } || function(Ct, It) {
        for (var Vt in It)
          Object.prototype.hasOwnProperty.call(It, Vt) && (Ct[Vt] = It[Vt]);
      }, pt(dt, yt);
    };
    return function(dt, yt) {
      if (typeof yt != "function" && yt !== null)
        throw new TypeError("Class extends value " + String(yt) + " is not a constructor or null");
      pt(dt, yt);
      function Ct() {
        this.constructor = dt;
      }
      dt.prototype = yt === null ? Object.create(yt) : (Ct.prototype = yt.prototype, new Ct());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EMPTY_OBSERVER = ne.SafeSubscriber = ne.Subscriber = void 0;
  var ae = Mt(), fe = Oi(), ye = gd(), ve = Fk(), _e = On(), xe = eI(), Oe = Uk(), $e = G0(), Me = function(pt) {
    oe(dt, pt);
    function dt(yt) {
      var Ct = pt.call(this) || this;
      return Ct.isStopped = !1, yt ? (Ct.destination = yt, fe.isSubscription(yt) && yt.add(Ct)) : Ct.destination = ne.EMPTY_OBSERVER, Ct;
    }
    return dt.create = function(yt, Ct, It) {
      return new ze(yt, Ct, It);
    }, dt.prototype.next = function(yt) {
      this.isStopped ? Ye(xe.nextNotification(yt), this) : this._next(yt);
    }, dt.prototype.error = function(yt) {
      this.isStopped ? Ye(xe.errorNotification(yt), this) : (this.isStopped = !0, this._error(yt));
    }, dt.prototype.complete = function() {
      this.isStopped ? Ye(xe.COMPLETE_NOTIFICATION, this) : (this.isStopped = !0, this._complete());
    }, dt.prototype.unsubscribe = function() {
      this.closed || (this.isStopped = !0, pt.prototype.unsubscribe.call(this), this.destination = null);
    }, dt.prototype._next = function(yt) {
      this.destination.next(yt);
    }, dt.prototype._error = function(yt) {
      try {
        this.destination.error(yt);
      } finally {
        this.unsubscribe();
      }
    }, dt.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    }, dt;
  }(fe.Subscription);
  ne.Subscriber = Me;
  var Re = Function.prototype.bind;
  function je(pt, dt) {
    return Re.call(pt, dt);
  }
  var Be = function() {
    function pt(dt) {
      this.partialObserver = dt;
    }
    return pt.prototype.next = function(dt) {
      var yt = this.partialObserver;
      if (yt.next)
        try {
          yt.next(dt);
        } catch (Ct) {
          He(Ct);
        }
    }, pt.prototype.error = function(dt) {
      var yt = this.partialObserver;
      if (yt.error)
        try {
          yt.error(dt);
        } catch (Ct) {
          He(Ct);
        }
      else
        He(dt);
    }, pt.prototype.complete = function() {
      var dt = this.partialObserver;
      if (dt.complete)
        try {
          dt.complete();
        } catch (yt) {
          He(yt);
        }
    }, pt;
  }(), ze = function(pt) {
    oe(dt, pt);
    function dt(yt, Ct, It) {
      var Vt = pt.call(this) || this, Ut;
      if (ae.isFunction(yt) || !yt)
        Ut = { next: yt ?? void 0, error: Ct ?? void 0, complete: It ?? void 0 };
      else {
        var Zt;
        Vt && ye.config.useDeprecatedNextContext ? (Zt = Object.create(yt), Zt.unsubscribe = function() {
          return Vt.unsubscribe();
        }, Ut = { next: yt.next && je(yt.next, Zt), error: yt.error && je(yt.error, Zt), complete: yt.complete && je(yt.complete, Zt) }) : Ut = yt;
      }
      return Vt.destination = new Be(Ut), Vt;
    }
    return dt;
  }(Me);
  ne.SafeSubscriber = ze;
  function He(pt) {
    ye.config.useDeprecatedSynchronousErrorHandling ? $e.captureError(pt) : ve.reportUnhandledError(pt);
  }
  function qe(pt) {
    throw pt;
  }
  function Ye(pt, dt) {
    var yt = ye.config.onStoppedNotification;
    yt && Oe.timeoutProvider.setTimeout(function() {
      return yt(pt, dt);
    });
  }
  ne.EMPTY_OBSERVER = { closed: !0, next: _e.noop, error: qe, complete: _e.noop };
}), uh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observable = void 0, ne.observable = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable";
  }();
}), Hn = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.identity = void 0;
  function oe(ae) {
    return ae;
  }
  ne.identity = oe;
}), lh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pipeFromArray = ne.pipe = void 0;
  var oe = Hn();
  function ae() {
    for (var ye = [], ve = 0; ve < arguments.length; ve++)
      ye[ve] = arguments[ve];
    return fe(ye);
  }
  ne.pipe = ae;
  function fe(ye) {
    return ye.length === 0 ? oe.identity : ye.length === 1 ? ye[0] : function(ve) {
      return ye.reduce(function(_e, xe) {
        return xe(_e);
      }, ve);
    };
  }
  ne.pipeFromArray = fe;
}), qt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Observable = void 0;
  var oe = Sd(), ae = Oi(), fe = uh(), ye = lh(), ve = gd(), _e = Mt(), xe = G0(), Oe = function() {
    function je(Be) {
      Be && (this._subscribe = Be);
    }
    return je.prototype.lift = function(Be) {
      var ze = new je();
      return ze.source = this, ze.operator = Be, ze;
    }, je.prototype.subscribe = function(Be, ze, He) {
      var qe = this, Ye = Re(Be) ? Be : new oe.SafeSubscriber(Be, ze, He);
      return xe.errorContext(function() {
        var pt = qe, dt = pt.operator, yt = pt.source;
        Ye.add(dt ? dt.call(Ye, yt) : yt ? qe._subscribe(Ye) : qe._trySubscribe(Ye));
      }), Ye;
    }, je.prototype._trySubscribe = function(Be) {
      try {
        return this._subscribe(Be);
      } catch (ze) {
        Be.error(ze);
      }
    }, je.prototype.forEach = function(Be, ze) {
      var He = this;
      return ze = $e(ze), new ze(function(qe, Ye) {
        var pt = new oe.SafeSubscriber({ next: function(dt) {
          try {
            Be(dt);
          } catch (yt) {
            Ye(yt), pt.unsubscribe();
          }
        }, error: Ye, complete: qe });
        He.subscribe(pt);
      });
    }, je.prototype._subscribe = function(Be) {
      var ze;
      return (ze = this.source) === null || ze === void 0 ? void 0 : ze.subscribe(Be);
    }, je.prototype[fe.observable] = function() {
      return this;
    }, je.prototype.pipe = function() {
      for (var Be = [], ze = 0; ze < arguments.length; ze++)
        Be[ze] = arguments[ze];
      return ye.pipeFromArray(Be)(this);
    }, je.prototype.toPromise = function(Be) {
      var ze = this;
      return Be = $e(Be), new Be(function(He, qe) {
        var Ye;
        ze.subscribe(function(pt) {
          return Ye = pt;
        }, function(pt) {
          return qe(pt);
        }, function() {
          return He(Ye);
        });
      });
    }, je.create = function(Be) {
      return new je(Be);
    }, je;
  }();
  ne.Observable = Oe;
  function $e(je) {
    var Be;
    return (Be = je ?? ve.config.Promise) !== null && Be !== void 0 ? Be : Promise;
  }
  function Me(je) {
    return je && _e.isFunction(je.next) && _e.isFunction(je.error) && _e.isFunction(je.complete);
  }
  function Re(je) {
    return je && je instanceof oe.Subscriber || Me(je) && ae.isSubscription(je);
  }
}), he = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.operate = ne.hasLift = void 0;
  var oe = Mt();
  function ae(ye) {
    return oe.isFunction(ye == null ? void 0 : ye.lift);
  }
  ne.hasLift = ae;
  function fe(ye) {
    return function(ve) {
      if (ae(ve))
        return ve.lift(function(_e) {
          try {
            return ye(_e, this);
          } catch (xe) {
            this.error(xe);
          }
        });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  ne.operate = fe;
}), Ae = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ve = function(_e, xe) {
      return ve = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Me in $e)
          Object.prototype.hasOwnProperty.call($e, Me) && (Oe[Me] = $e[Me]);
      }, ve(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      ve(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.OperatorSubscriber = ne.createOperatorSubscriber = void 0;
  var ae = Sd();
  function fe(ve, _e, xe, Oe, $e) {
    return new ye(ve, _e, xe, Oe, $e);
  }
  ne.createOperatorSubscriber = fe;
  var ye = function(ve) {
    oe(_e, ve);
    function _e(xe, Oe, $e, Me, Re, je) {
      var Be = ve.call(this, xe) || this;
      return Be.onFinalize = Re, Be.shouldUnsubscribe = je, Be._next = Oe ? function(ze) {
        try {
          Oe(ze);
        } catch (He) {
          xe.error(He);
        }
      } : ve.prototype._next, Be._error = Me ? function(ze) {
        try {
          Me(ze);
        } catch (He) {
          xe.error(He);
        } finally {
          this.unsubscribe();
        }
      } : ve.prototype._error, Be._complete = $e ? function() {
        try {
          $e();
        } catch (ze) {
          xe.error(ze);
        } finally {
          this.unsubscribe();
        }
      } : ve.prototype._complete, Be;
    }
    return _e.prototype.unsubscribe = function() {
      var xe;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var Oe = this.closed;
        ve.prototype.unsubscribe.call(this), !Oe && ((xe = this.onFinalize) === null || xe === void 0 || xe.call(this));
      }
    }, _e;
  }(ae.Subscriber);
  ne.OperatorSubscriber = ye;
}), $k = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.refCount = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ve) {
      var _e = null;
      ye._refCount++;
      var xe = ae.createOperatorSubscriber(ve, void 0, void 0, void 0, function() {
        if (!ye || ye._refCount <= 0 || 0 < --ye._refCount) {
          _e = null;
          return;
        }
        var Oe = ye._connection, $e = _e;
        _e = null, Oe && (!$e || Oe === $e) && Oe.unsubscribe(), ve.unsubscribe();
      });
      ye.subscribe(xe), xe.closed || (_e = ye.connect());
    });
  }
  ne.refCount = fe;
}), sh = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var Oe = function($e, Me) {
      return Oe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Re, je) {
        Re.__proto__ = je;
      } || function(Re, je) {
        for (var Be in je)
          Object.prototype.hasOwnProperty.call(je, Be) && (Re[Be] = je[Be]);
      }, Oe($e, Me);
    };
    return function($e, Me) {
      if (typeof Me != "function" && Me !== null)
        throw new TypeError("Class extends value " + String(Me) + " is not a constructor or null");
      Oe($e, Me);
      function Re() {
        this.constructor = $e;
      }
      $e.prototype = Me === null ? Object.create(Me) : (Re.prototype = Me.prototype, new Re());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ConnectableObservable = void 0;
  var ae = qt(), fe = Oi(), ye = $k(), ve = Ae(), _e = he(), xe = function(Oe) {
    oe($e, Oe);
    function $e(Me, Re) {
      var je = Oe.call(this) || this;
      return je.source = Me, je.subjectFactory = Re, je._subject = null, je._refCount = 0, je._connection = null, _e.hasLift(Me) && (je.lift = Me.lift), je;
    }
    return $e.prototype._subscribe = function(Me) {
      return this.getSubject().subscribe(Me);
    }, $e.prototype.getSubject = function() {
      var Me = this._subject;
      return (!Me || Me.isStopped) && (this._subject = this.subjectFactory()), this._subject;
    }, $e.prototype._teardown = function() {
      this._refCount = 0;
      var Me = this._connection;
      this._subject = this._connection = null, Me == null || Me.unsubscribe();
    }, $e.prototype.connect = function() {
      var Me = this, Re = this._connection;
      if (!Re) {
        Re = this._connection = new fe.Subscription();
        var je = this.getSubject();
        Re.add(this.source.subscribe(ve.createOperatorSubscriber(je, void 0, function() {
          Me._teardown(), je.complete();
        }, function(Be) {
          Me._teardown(), je.error(Be);
        }, function() {
          return Me._teardown();
        }))), Re.closed && (this._connection = null, Re = fe.Subscription.EMPTY);
      }
      return Re;
    }, $e.prototype.refCount = function() {
      return ye.refCount()(this);
    }, $e;
  }(ae.Observable);
  ne.ConnectableObservable = xe;
}), dI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.performanceTimestampProvider = void 0, ne.performanceTimestampProvider = { now: function() {
    return (ne.performanceTimestampProvider.delegate || performance).now();
  }, delegate: void 0 };
}), Wk = M((ne) => {
  var oe = ne && ne.__read || function(ye, ve) {
    var _e = typeof Symbol == "function" && ye[Symbol.iterator];
    if (!_e)
      return ye;
    var xe = _e.call(ye), Oe, $e = [], Me;
    try {
      for (; (ve === void 0 || ve-- > 0) && !(Oe = xe.next()).done; )
        $e.push(Oe.value);
    } catch (Re) {
      Me = { error: Re };
    } finally {
      try {
        Oe && !Oe.done && (_e = xe.return) && _e.call(xe);
      } finally {
        if (Me)
          throw Me.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ye, ve) {
    for (var _e = 0, xe = ve.length, Oe = ye.length; _e < xe; _e++, Oe++)
      ye[Oe] = ve[_e];
    return ye;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrameProvider = void 0;
  var fe = Oi();
  ne.animationFrameProvider = { schedule: function(ye) {
    var ve = requestAnimationFrame, _e = cancelAnimationFrame, xe = ne.animationFrameProvider.delegate;
    xe && (ve = xe.requestAnimationFrame, _e = xe.cancelAnimationFrame);
    var Oe = ve(function($e) {
      _e = void 0, ye($e);
    });
    return new fe.Subscription(function() {
      return _e == null ? void 0 : _e(Oe);
    });
  }, requestAnimationFrame: function() {
    for (var ye = [], ve = 0; ve < arguments.length; ve++)
      ye[ve] = arguments[ve];
    var _e = ne.animationFrameProvider.delegate;
    return ((_e == null ? void 0 : _e.requestAnimationFrame) || requestAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, cancelAnimationFrame: function() {
    for (var ye = [], ve = 0; ve < arguments.length; ve++)
      ye[ve] = arguments[ve];
    var _e = ne.animationFrameProvider.delegate;
    return ((_e == null ? void 0 : _e.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, delegate: void 0 };
}), hI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrames = void 0;
  var oe = qt(), ae = Oi(), fe = dI(), ye = Wk();
  function ve(Oe) {
    return Oe ? _e(Oe) : xe;
  }
  ne.animationFrames = ve;
  function _e(Oe) {
    var $e = ye.animationFrameProvider.schedule;
    return new oe.Observable(function(Me) {
      var Re = new ae.Subscription(), je = Oe || fe.performanceTimestampProvider, Be = je.now(), ze = function(He) {
        var qe = je.now();
        Me.next({ timestamp: Oe ? qe : He, elapsed: qe - Be }), Me.closed || Re.add($e(ze));
      };
      return Re.add($e(ze)), Re;
    });
  }
  var xe = _e();
}), Yk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ObjectUnsubscribedError = void 0;
  var oe = Il();
  ne.ObjectUnsubscribedError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
    };
  });
}), Tn = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var Me = function(Re, je) {
      return Me = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Be, ze) {
        Be.__proto__ = ze;
      } || function(Be, ze) {
        for (var He in ze)
          Object.prototype.hasOwnProperty.call(ze, He) && (Be[He] = ze[He]);
      }, Me(Re, je);
    };
    return function(Re, je) {
      if (typeof je != "function" && je !== null)
        throw new TypeError("Class extends value " + String(je) + " is not a constructor or null");
      Me(Re, je);
      function Be() {
        this.constructor = Re;
      }
      Re.prototype = je === null ? Object.create(je) : (Be.prototype = je.prototype, new Be());
    };
  }(), ae = ne && ne.__values || function(Me) {
    var Re = typeof Symbol == "function" && Symbol.iterator, je = Re && Me[Re], Be = 0;
    if (je)
      return je.call(Me);
    if (Me && typeof Me.length == "number")
      return { next: function() {
        return Me && Be >= Me.length && (Me = void 0), { value: Me && Me[Be++], done: !Me };
      } };
    throw new TypeError(Re ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnonymousSubject = ne.Subject = void 0;
  var fe = qt(), ye = Oi(), ve = Yk(), _e = ku(), xe = G0(), Oe = function(Me) {
    oe(Re, Me);
    function Re() {
      var je = Me.call(this) || this;
      return je.closed = !1, je.currentObservers = null, je.observers = [], je.isStopped = !1, je.hasError = !1, je.thrownError = null, je;
    }
    return Re.prototype.lift = function(je) {
      var Be = new $e(this, this);
      return Be.operator = je, Be;
    }, Re.prototype._throwIfClosed = function() {
      if (this.closed)
        throw new ve.ObjectUnsubscribedError();
    }, Re.prototype.next = function(je) {
      var Be = this;
      xe.errorContext(function() {
        var ze, He;
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.currentObservers || (Be.currentObservers = Array.from(Be.observers));
          try {
            for (var qe = ae(Be.currentObservers), Ye = qe.next(); !Ye.done; Ye = qe.next()) {
              var pt = Ye.value;
              pt.next(je);
            }
          } catch (dt) {
            ze = { error: dt };
          } finally {
            try {
              Ye && !Ye.done && (He = qe.return) && He.call(qe);
            } finally {
              if (ze)
                throw ze.error;
            }
          }
        }
      });
    }, Re.prototype.error = function(je) {
      var Be = this;
      xe.errorContext(function() {
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.hasError = Be.isStopped = !0, Be.thrownError = je;
          for (var ze = Be.observers; ze.length; )
            ze.shift().error(je);
        }
      });
    }, Re.prototype.complete = function() {
      var je = this;
      xe.errorContext(function() {
        if (je._throwIfClosed(), !je.isStopped) {
          je.isStopped = !0;
          for (var Be = je.observers; Be.length; )
            Be.shift().complete();
        }
      });
    }, Re.prototype.unsubscribe = function() {
      this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
    }, Object.defineProperty(Re.prototype, "observed", { get: function() {
      var je;
      return ((je = this.observers) === null || je === void 0 ? void 0 : je.length) > 0;
    }, enumerable: !1, configurable: !0 }), Re.prototype._trySubscribe = function(je) {
      return this._throwIfClosed(), Me.prototype._trySubscribe.call(this, je);
    }, Re.prototype._subscribe = function(je) {
      return this._throwIfClosed(), this._checkFinalizedStatuses(je), this._innerSubscribe(je);
    }, Re.prototype._innerSubscribe = function(je) {
      var Be = this, ze = this, He = ze.hasError, qe = ze.isStopped, Ye = ze.observers;
      return He || qe ? ye.EMPTY_SUBSCRIPTION : (this.currentObservers = null, Ye.push(je), new ye.Subscription(function() {
        Be.currentObservers = null, _e.arrRemove(Ye, je);
      }));
    }, Re.prototype._checkFinalizedStatuses = function(je) {
      var Be = this, ze = Be.hasError, He = Be.thrownError, qe = Be.isStopped;
      ze ? je.error(He) : qe && je.complete();
    }, Re.prototype.asObservable = function() {
      var je = new fe.Observable();
      return je.source = this, je;
    }, Re.create = function(je, Be) {
      return new $e(je, Be);
    }, Re;
  }(fe.Observable);
  ne.Subject = Oe;
  var $e = function(Me) {
    oe(Re, Me);
    function Re(je, Be) {
      var ze = Me.call(this) || this;
      return ze.destination = je, ze.source = Be, ze;
    }
    return Re.prototype.next = function(je) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.next) === null || ze === void 0 || ze.call(Be, je);
    }, Re.prototype.error = function(je) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.error) === null || ze === void 0 || ze.call(Be, je);
    }, Re.prototype.complete = function() {
      var je, Be;
      (Be = (je = this.destination) === null || je === void 0 ? void 0 : je.complete) === null || Be === void 0 || Be.call(je);
    }, Re.prototype._subscribe = function(je) {
      var Be, ze;
      return (ze = (Be = this.source) === null || Be === void 0 ? void 0 : Be.subscribe(je)) !== null && ze !== void 0 ? ze : ye.EMPTY_SUBSCRIPTION;
    }, Re;
  }(Oe);
  ne.AnonymousSubject = $e;
}), Xk = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.BehaviorSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(ve, ye);
    function ve(_e) {
      var xe = ye.call(this) || this;
      return xe._value = _e, xe;
    }
    return Object.defineProperty(ve.prototype, "value", { get: function() {
      return this.getValue();
    }, enumerable: !1, configurable: !0 }), ve.prototype._subscribe = function(_e) {
      var xe = ye.prototype._subscribe.call(this, _e);
      return !xe.closed && _e.next(this._value), xe;
    }, ve.prototype.getValue = function() {
      var _e = this, xe = _e.hasError, Oe = _e.thrownError, $e = _e._value;
      if (xe)
        throw Oe;
      return this._throwIfClosed(), $e;
    }, ve.prototype.next = function(_e) {
      ye.prototype.next.call(this, this._value = _e);
    }, ve;
  }(ae.Subject);
  ne.BehaviorSubject = fe;
}), rS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dateTimestampProvider = void 0, ne.dateTimestampProvider = { now: function() {
    return (ne.dateTimestampProvider.delegate || Date).now();
  }, delegate: void 0 };
}), nS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ve = function(_e, xe) {
      return ve = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Me in $e)
          Object.prototype.hasOwnProperty.call($e, Me) && (Oe[Me] = $e[Me]);
      }, ve(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      ve(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ReplaySubject = void 0;
  var ae = Tn(), fe = rS(), ye = function(ve) {
    oe(_e, ve);
    function _e(xe, Oe, $e) {
      xe === void 0 && (xe = 1 / 0), Oe === void 0 && (Oe = 1 / 0), $e === void 0 && ($e = fe.dateTimestampProvider);
      var Me = ve.call(this) || this;
      return Me._bufferSize = xe, Me._windowTime = Oe, Me._timestampProvider = $e, Me._buffer = [], Me._infiniteTimeWindow = !0, Me._infiniteTimeWindow = Oe === 1 / 0, Me._bufferSize = Math.max(1, xe), Me._windowTime = Math.max(1, Oe), Me;
    }
    return _e.prototype.next = function(xe) {
      var Oe = this, $e = Oe.isStopped, Me = Oe._buffer, Re = Oe._infiniteTimeWindow, je = Oe._timestampProvider, Be = Oe._windowTime;
      $e || (Me.push(xe), !Re && Me.push(je.now() + Be)), this._trimBuffer(), ve.prototype.next.call(this, xe);
    }, _e.prototype._subscribe = function(xe) {
      this._throwIfClosed(), this._trimBuffer();
      for (var Oe = this._innerSubscribe(xe), $e = this, Me = $e._infiniteTimeWindow, Re = $e._buffer, je = Re.slice(), Be = 0; Be < je.length && !xe.closed; Be += Me ? 1 : 2)
        xe.next(je[Be]);
      return this._checkFinalizedStatuses(xe), Oe;
    }, _e.prototype._trimBuffer = function() {
      var xe = this, Oe = xe._bufferSize, $e = xe._timestampProvider, Me = xe._buffer, Re = xe._infiniteTimeWindow, je = (Re ? 1 : 2) * Oe;
      if (Oe < 1 / 0 && je < Me.length && Me.splice(0, Me.length - je), !Re) {
        for (var Be = $e.now(), ze = 0, He = 1; He < Me.length && Me[He] <= Be; He += 2)
          ze = He;
        ze && Me.splice(0, ze + 1);
      }
    }, _e;
  }(ae.Subject);
  ne.ReplaySubject = ye;
}), iS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(ve, ye);
    function ve() {
      var _e = ye !== null && ye.apply(this, arguments) || this;
      return _e._value = null, _e._hasValue = !1, _e._isComplete = !1, _e;
    }
    return ve.prototype._checkFinalizedStatuses = function(_e) {
      var xe = this, Oe = xe.hasError, $e = xe._hasValue, Me = xe._value, Re = xe.thrownError, je = xe.isStopped, Be = xe._isComplete;
      Oe ? _e.error(Re) : (je || Be) && ($e && _e.next(Me), _e.complete());
    }, ve.prototype.next = function(_e) {
      this.isStopped || (this._value = _e, this._hasValue = !0);
    }, ve.prototype.complete = function() {
      var _e = this, xe = _e._hasValue, Oe = _e._value, $e = _e._isComplete;
      $e || (this._isComplete = !0, xe && ye.prototype.next.call(this, Oe), ye.prototype.complete.call(this));
    }, ve;
  }(ae.Subject);
  ne.AsyncSubject = fe;
}), SI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Action = void 0;
  var ae = Oi(), fe = function(ye) {
    oe(ve, ye);
    function ve(_e, xe) {
      return ye.call(this) || this;
    }
    return ve.prototype.schedule = function(_e, xe) {
      return this;
    }, ve;
  }(ae.Subscription);
  ne.Action = fe;
}), xI = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var ve = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!ve)
      return fe;
    var _e = ve.call(fe), xe, Oe = [], $e;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(xe = _e.next()).done; )
        Oe.push(xe.value);
    } catch (Me) {
      $e = { error: Me };
    } finally {
      try {
        xe && !xe.done && (ve = _e.return) && ve.call(_e);
      } finally {
        if ($e)
          throw $e.error;
      }
    }
    return Oe;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var ve = 0, _e = ye.length, xe = fe.length; ve < _e; ve++, xe++)
      fe[xe] = ye[ve];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.intervalProvider = void 0, ne.intervalProvider = { setInterval: function(fe, ye) {
    for (var ve = [], _e = 2; _e < arguments.length; _e++)
      ve[_e - 2] = arguments[_e];
    var xe = ne.intervalProvider.delegate;
    return xe != null && xe.setInterval ? xe.setInterval.apply(xe, ae([fe, ye], oe(ve))) : setInterval.apply(void 0, ae([fe, ye], oe(ve)));
  }, clearInterval: function(fe) {
    var ye = ne.intervalProvider.delegate;
    return ((ye == null ? void 0 : ye.clearInterval) || clearInterval)(fe);
  }, delegate: void 0 };
}), kd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var _e = function(xe, Oe) {
      return _e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function($e, Me) {
        $e.__proto__ = Me;
      } || function($e, Me) {
        for (var Re in Me)
          Object.prototype.hasOwnProperty.call(Me, Re) && ($e[Re] = Me[Re]);
      }, _e(xe, Oe);
    };
    return function(xe, Oe) {
      if (typeof Oe != "function" && Oe !== null)
        throw new TypeError("Class extends value " + String(Oe) + " is not a constructor or null");
      _e(xe, Oe);
      function $e() {
        this.constructor = xe;
      }
      xe.prototype = Oe === null ? Object.create(Oe) : ($e.prototype = Oe.prototype, new $e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncAction = void 0;
  var ae = SI(), fe = xI(), ye = ku(), ve = function(_e) {
    oe(xe, _e);
    function xe(Oe, $e) {
      var Me = _e.call(this, Oe, $e) || this;
      return Me.scheduler = Oe, Me.work = $e, Me.pending = !1, Me;
    }
    return xe.prototype.schedule = function(Oe, $e) {
      if ($e === void 0 && ($e = 0), this.closed)
        return this;
      this.state = Oe;
      var Me = this.id, Re = this.scheduler;
      return Me != null && (this.id = this.recycleAsyncId(Re, Me, $e)), this.pending = !0, this.delay = $e, this.id = this.id || this.requestAsyncId(Re, this.id, $e), this;
    }, xe.prototype.requestAsyncId = function(Oe, $e, Me) {
      return Me === void 0 && (Me = 0), fe.intervalProvider.setInterval(Oe.flush.bind(Oe, this), Me);
    }, xe.prototype.recycleAsyncId = function(Oe, $e, Me) {
      if (Me === void 0 && (Me = 0), Me != null && this.delay === Me && this.pending === !1)
        return $e;
      fe.intervalProvider.clearInterval($e);
    }, xe.prototype.execute = function(Oe, $e) {
      if (this.closed)
        return new Error("executing a cancelled action");
      this.pending = !1;
      var Me = this._execute(Oe, $e);
      if (Me)
        return Me;
      this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
    }, xe.prototype._execute = function(Oe, $e) {
      var Me = !1, Re;
      try {
        this.work(Oe);
      } catch (je) {
        Me = !0, Re = je || new Error("Scheduled action threw falsy error");
      }
      if (Me)
        return this.unsubscribe(), Re;
    }, xe.prototype.unsubscribe = function() {
      if (!this.closed) {
        var Oe = this, $e = Oe.id, Me = Oe.scheduler, Re = Me.actions;
        this.work = this.state = this.scheduler = null, this.pending = !1, ye.arrRemove(Re, this), $e != null && (this.id = this.recycleAsyncId(Me, $e, null)), this.delay = null, _e.prototype.unsubscribe.call(this);
      }
    }, xe;
  }(ae.Action);
  ne.AsyncAction = ve;
}), RI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TestTools = ne.Immediate = void 0;
  var oe = 1, ae, fe = {};
  function ye(ve) {
    return ve in fe ? (delete fe[ve], !0) : !1;
  }
  ne.Immediate = { setImmediate: function(ve) {
    var _e = oe++;
    return fe[_e] = !0, ae || (ae = Promise.resolve()), ae.then(function() {
      return ye(_e) && ve();
    }), _e;
  }, clearImmediate: function(ve) {
    ye(ve);
  } }, ne.TestTools = { pending: function() {
    return Object.keys(fe).length;
  } };
}), TI = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Me, Re = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Me = $e.next()).done; )
        Re.push(Me.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Me && !Me.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Me = _e.length; Oe < $e; Oe++, Me++)
      _e[Me] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.immediateProvider = void 0;
  var fe = RI(), ye = fe.Immediate.setImmediate, ve = fe.Immediate.clearImmediate;
  ne.immediateProvider = { setImmediate: function() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    var Oe = ne.immediateProvider.delegate;
    return ((Oe == null ? void 0 : Oe.setImmediate) || ye).apply(void 0, ae([], oe(_e)));
  }, clearImmediate: function(_e) {
    var xe = ne.immediateProvider.delegate;
    return ((xe == null ? void 0 : xe.clearImmediate) || ve)(_e);
  }, delegate: void 0 };
}), AI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ve = function(_e, xe) {
      return ve = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Me in $e)
          Object.prototype.hasOwnProperty.call($e, Me) && (Oe[Me] = $e[Me]);
      }, ve(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      ve(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapAction = void 0;
  var ae = kd(), fe = TI(), ye = function(ve) {
    oe(_e, ve);
    function _e(xe, Oe) {
      var $e = ve.call(this, xe, Oe) || this;
      return $e.scheduler = xe, $e.work = Oe, $e;
    }
    return _e.prototype.requestAsyncId = function(xe, Oe, $e) {
      return $e === void 0 && ($e = 0), $e !== null && $e > 0 ? ve.prototype.requestAsyncId.call(this, xe, Oe, $e) : (xe.actions.push(this), xe._scheduled || (xe._scheduled = fe.immediateProvider.setImmediate(xe.flush.bind(xe, void 0))));
    }, _e.prototype.recycleAsyncId = function(xe, Oe, $e) {
      if ($e === void 0 && ($e = 0), $e != null && $e > 0 || $e == null && this.delay > 0)
        return ve.prototype.recycleAsyncId.call(this, xe, Oe, $e);
      xe.actions.some(function(Me) {
        return Me.id === Oe;
      }) || (fe.immediateProvider.clearImmediate(Oe), xe._scheduled = void 0);
    }, _e;
  }(ae.AsyncAction);
  ne.AsapAction = ye;
}), Zk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Scheduler = void 0;
  var oe = rS(), ae = function() {
    function fe(ye, ve) {
      ve === void 0 && (ve = fe.now), this.schedulerActionCtor = ye, this.now = ve;
    }
    return fe.prototype.schedule = function(ye, ve, _e) {
      return ve === void 0 && (ve = 0), new this.schedulerActionCtor(this, ye).schedule(_e, ve);
    }, fe.now = oe.dateTimestampProvider.now, fe;
  }();
  ne.Scheduler = ae;
}), Dd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncScheduler = void 0;
  var ae = Zk(), fe = function(ye) {
    oe(ve, ye);
    function ve(_e, xe) {
      xe === void 0 && (xe = ae.Scheduler.now);
      var Oe = ye.call(this, _e, xe) || this;
      return Oe.actions = [], Oe._active = !1, Oe._scheduled = void 0, Oe;
    }
    return ve.prototype.flush = function(_e) {
      var xe = this.actions;
      if (this._active) {
        xe.push(_e);
        return;
      }
      var Oe;
      this._active = !0;
      do
        if (Oe = _e.execute(_e.state, _e.delay))
          break;
      while (_e = xe.shift());
      if (this._active = !1, Oe) {
        for (; _e = xe.shift(); )
          _e.unsubscribe();
        throw Oe;
      }
    }, ve;
  }(ae.Scheduler);
  ne.AsyncScheduler = fe;
}), MI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ve, ye);
    function ve() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ve.prototype.flush = function(_e) {
      this._active = !0;
      var xe = this._scheduled;
      this._scheduled = void 0;
      var Oe = this.actions, $e;
      _e = _e || Oe.shift();
      do
        if ($e = _e.execute(_e.state, _e.delay))
          break;
      while ((_e = Oe[0]) && _e.id === xe && Oe.shift());
      if (this._active = !1, $e) {
        for (; (_e = Oe[0]) && _e.id === xe && Oe.shift(); )
          _e.unsubscribe();
        throw $e;
      }
    }, ve;
  }(ae.AsyncScheduler);
  ne.AsapScheduler = fe;
}), DI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.asap = ne.asapScheduler = void 0;
  var oe = AI(), ae = MI();
  ne.asapScheduler = new ae.AsapScheduler(oe.AsapAction), ne.asap = ne.asapScheduler;
}), Ti = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.async = ne.asyncScheduler = void 0;
  var oe = kd(), ae = Dd();
  ne.asyncScheduler = new ae.AsyncScheduler(oe.AsyncAction), ne.async = ne.asyncScheduler;
}), NI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueAction = void 0;
  var ae = kd(), fe = function(ye) {
    oe(ve, ye);
    function ve(_e, xe) {
      var Oe = ye.call(this, _e, xe) || this;
      return Oe.scheduler = _e, Oe.work = xe, Oe;
    }
    return ve.prototype.schedule = function(_e, xe) {
      return xe === void 0 && (xe = 0), xe > 0 ? ye.prototype.schedule.call(this, _e, xe) : (this.delay = xe, this.state = _e, this.scheduler.flush(this), this);
    }, ve.prototype.execute = function(_e, xe) {
      return xe > 0 || this.closed ? ye.prototype.execute.call(this, _e, xe) : this._execute(_e, xe);
    }, ve.prototype.requestAsyncId = function(_e, xe, Oe) {
      return Oe === void 0 && (Oe = 0), Oe != null && Oe > 0 || Oe == null && this.delay > 0 ? ye.prototype.requestAsyncId.call(this, _e, xe, Oe) : _e.flush(this);
    }, ve;
  }(ae.AsyncAction);
  ne.QueueAction = fe;
}), LI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ve, ye);
    function ve() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ve;
  }(ae.AsyncScheduler);
  ne.QueueScheduler = fe;
}), jI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.queue = ne.queueScheduler = void 0;
  var oe = NI(), ae = LI();
  ne.queueScheduler = new ae.QueueScheduler(oe.QueueAction), ne.queue = ne.queueScheduler;
}), FI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ve = function(_e, xe) {
      return ve = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Me in $e)
          Object.prototype.hasOwnProperty.call($e, Me) && (Oe[Me] = $e[Me]);
      }, ve(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      ve(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameAction = void 0;
  var ae = kd(), fe = Wk(), ye = function(ve) {
    oe(_e, ve);
    function _e(xe, Oe) {
      var $e = ve.call(this, xe, Oe) || this;
      return $e.scheduler = xe, $e.work = Oe, $e;
    }
    return _e.prototype.requestAsyncId = function(xe, Oe, $e) {
      return $e === void 0 && ($e = 0), $e !== null && $e > 0 ? ve.prototype.requestAsyncId.call(this, xe, Oe, $e) : (xe.actions.push(this), xe._scheduled || (xe._scheduled = fe.animationFrameProvider.requestAnimationFrame(function() {
        return xe.flush(void 0);
      })));
    }, _e.prototype.recycleAsyncId = function(xe, Oe, $e) {
      if ($e === void 0 && ($e = 0), $e != null && $e > 0 || $e == null && this.delay > 0)
        return ve.prototype.recycleAsyncId.call(this, xe, Oe, $e);
      xe.actions.some(function(Me) {
        return Me.id === Oe;
      }) || (fe.animationFrameProvider.cancelAnimationFrame(Oe), xe._scheduled = void 0);
    }, _e;
  }(ae.AsyncAction);
  ne.AnimationFrameAction = ye;
}), zI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ve, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(ve, _e);
    };
    return function(ve, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(ve, _e);
      function xe() {
        this.constructor = ve;
      }
      ve.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ve, ye);
    function ve() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ve.prototype.flush = function(_e) {
      this._active = !0;
      var xe = this._scheduled;
      this._scheduled = void 0;
      var Oe = this.actions, $e;
      _e = _e || Oe.shift();
      do
        if ($e = _e.execute(_e.state, _e.delay))
          break;
      while ((_e = Oe[0]) && _e.id === xe && Oe.shift());
      if (this._active = !1, $e) {
        for (; (_e = Oe[0]) && _e.id === xe && Oe.shift(); )
          _e.unsubscribe();
        throw $e;
      }
    }, ve;
  }(ae.AsyncScheduler);
  ne.AnimationFrameScheduler = fe;
}), qI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrame = ne.animationFrameScheduler = void 0;
  var oe = FI(), ae = zI();
  ne.animationFrameScheduler = new ae.AnimationFrameScheduler(oe.AnimationFrameAction), ne.animationFrame = ne.animationFrameScheduler;
}), HI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var xe = function(Oe, $e) {
      return xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Me, Re) {
        Me.__proto__ = Re;
      } || function(Me, Re) {
        for (var je in Re)
          Object.prototype.hasOwnProperty.call(Re, je) && (Me[je] = Re[je]);
      }, xe(Oe, $e);
    };
    return function(Oe, $e) {
      if (typeof $e != "function" && $e !== null)
        throw new TypeError("Class extends value " + String($e) + " is not a constructor or null");
      xe(Oe, $e);
      function Me() {
        this.constructor = Oe;
      }
      Oe.prototype = $e === null ? Object.create($e) : (Me.prototype = $e.prototype, new Me());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.VirtualAction = ne.VirtualTimeScheduler = void 0;
  var ae = kd(), fe = Oi(), ye = Dd(), ve = function(xe) {
    oe(Oe, xe);
    function Oe($e, Me) {
      $e === void 0 && ($e = _e), Me === void 0 && (Me = 1 / 0);
      var Re = xe.call(this, $e, function() {
        return Re.frame;
      }) || this;
      return Re.maxFrames = Me, Re.frame = 0, Re.index = -1, Re;
    }
    return Oe.prototype.flush = function() {
      for (var $e = this, Me = $e.actions, Re = $e.maxFrames, je, Be; (Be = Me[0]) && Be.delay <= Re && (Me.shift(), this.frame = Be.delay, !(je = Be.execute(Be.state, Be.delay))); )
        ;
      if (je) {
        for (; Be = Me.shift(); )
          Be.unsubscribe();
        throw je;
      }
    }, Oe.frameTimeFactor = 10, Oe;
  }(ye.AsyncScheduler);
  ne.VirtualTimeScheduler = ve;
  var _e = function(xe) {
    oe(Oe, xe);
    function Oe($e, Me, Re) {
      Re === void 0 && (Re = $e.index += 1);
      var je = xe.call(this, $e, Me) || this;
      return je.scheduler = $e, je.work = Me, je.index = Re, je.active = !0, je.index = $e.index = Re, je;
    }
    return Oe.prototype.schedule = function($e, Me) {
      if (Me === void 0 && (Me = 0), Number.isFinite(Me)) {
        if (!this.id)
          return xe.prototype.schedule.call(this, $e, Me);
        this.active = !1;
        var Re = new Oe(this.scheduler, this.work);
        return this.add(Re), Re.schedule($e, Me);
      } else
        return fe.Subscription.EMPTY;
    }, Oe.prototype.requestAsyncId = function($e, Me, Re) {
      Re === void 0 && (Re = 0), this.delay = $e.frame + Re;
      var je = $e.actions;
      return je.push(this), je.sort(Oe.sortActions), !0;
    }, Oe.prototype.recycleAsyncId = function($e, Me, Re) {
    }, Oe.prototype._execute = function($e, Me) {
      if (this.active === !0)
        return xe.prototype._execute.call(this, $e, Me);
    }, Oe.sortActions = function($e, Me) {
      return $e.delay === Me.delay ? $e.index === Me.index ? 0 : $e.index > Me.index ? 1 : -1 : $e.delay > Me.delay ? 1 : -1;
    }, Oe;
  }(ae.AsyncAction);
  ne.VirtualAction = _e;
}), ba = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.empty = ne.EMPTY = void 0;
  var oe = qt();
  ne.EMPTY = new oe.Observable(function(ye) {
    return ye.complete();
  });
  function ae(ye) {
    return ye ? fe(ye) : ne.EMPTY;
  }
  ne.empty = ae;
  function fe(ye) {
    return new oe.Observable(function(ve) {
      return ye.schedule(function() {
        return ve.complete();
      });
    });
  }
}), dh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isScheduler = void 0;
  var oe = Mt();
  function ae(fe) {
    return fe && oe.isFunction(fe.schedule);
  }
  ne.isScheduler = ae;
}), ki = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.popNumber = ne.popScheduler = ne.popResultSelector = void 0;
  var oe = Mt(), ae = dh();
  function fe(xe) {
    return xe[xe.length - 1];
  }
  function ye(xe) {
    return oe.isFunction(fe(xe)) ? xe.pop() : void 0;
  }
  ne.popResultSelector = ye;
  function ve(xe) {
    return ae.isScheduler(fe(xe)) ? xe.pop() : void 0;
  }
  ne.popScheduler = ve;
  function _e(xe, Oe) {
    return typeof fe(xe) == "number" ? xe.pop() : Oe;
  }
  ne.popNumber = _e;
}), sS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isArrayLike = void 0, ne.isArrayLike = function(oe) {
    return oe && typeof oe.length == "number" && typeof oe != "function";
  };
}), tA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isPromise = void 0;
  var oe = Mt();
  function ae(fe) {
    return oe.isFunction(fe == null ? void 0 : fe.then);
  }
  ne.isPromise = ae;
}), rA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isInteropObservable = void 0;
  var oe = uh(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye[oe.observable]);
  }
  ne.isInteropObservable = fe;
}), nA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isAsyncIterable = void 0;
  var oe = Mt();
  function ae(fe) {
    return Symbol.asyncIterator && oe.isFunction(fe == null ? void 0 : fe[Symbol.asyncIterator]);
  }
  ne.isAsyncIterable = ae;
}), iA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createInvalidObservableTypeError = void 0;
  function oe(ae) {
    return new TypeError("You provided " + (ae !== null && typeof ae == "object" ? "an invalid object" : "'" + ae + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  ne.createInvalidObservableTypeError = oe;
}), aA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iterator = ne.getSymbolIterator = void 0;
  function oe() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
  }
  ne.getSymbolIterator = oe, ne.iterator = oe();
}), oA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isIterable = void 0;
  var oe = aA(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye == null ? void 0 : ye[oe.iterator]);
  }
  ne.isIterable = fe;
}), mS = M((ne) => {
  var oe = ne && ne.__generator || function(xe, Oe) {
    var $e = { label: 0, sent: function() {
      if (je[0] & 1)
        throw je[1];
      return je[1];
    }, trys: [], ops: [] }, Me, Re, je, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(qe) {
      return function(Ye) {
        return He([qe, Ye]);
      };
    }
    function He(qe) {
      if (Me)
        throw new TypeError("Generator is already executing.");
      for (; $e; )
        try {
          if (Me = 1, Re && (je = qe[0] & 2 ? Re.return : qe[0] ? Re.throw || ((je = Re.return) && je.call(Re), 0) : Re.next) && !(je = je.call(Re, qe[1])).done)
            return je;
          switch (Re = 0, je && (qe = [qe[0] & 2, je.value]), qe[0]) {
            case 0:
            case 1:
              je = qe;
              break;
            case 4:
              return $e.label++, { value: qe[1], done: !1 };
            case 5:
              $e.label++, Re = qe[1], qe = [0];
              continue;
            case 7:
              qe = $e.ops.pop(), $e.trys.pop();
              continue;
            default:
              if (je = $e.trys, !(je = je.length > 0 && je[je.length - 1]) && (qe[0] === 6 || qe[0] === 2)) {
                $e = 0;
                continue;
              }
              if (qe[0] === 3 && (!je || qe[1] > je[0] && qe[1] < je[3])) {
                $e.label = qe[1];
                break;
              }
              if (qe[0] === 6 && $e.label < je[1]) {
                $e.label = je[1], je = qe;
                break;
              }
              if (je && $e.label < je[2]) {
                $e.label = je[2], $e.ops.push(qe);
                break;
              }
              je[2] && $e.ops.pop(), $e.trys.pop();
              continue;
          }
          qe = Oe.call(xe, $e);
        } catch (Ye) {
          qe = [6, Ye], Re = 0;
        } finally {
          Me = je = 0;
        }
      if (qe[0] & 5)
        throw qe[1];
      return { value: qe[0] ? qe[1] : void 0, done: !0 };
    }
  }, ae = ne && ne.__await || function(xe) {
    return this instanceof ae ? (this.v = xe, this) : new ae(xe);
  }, fe = ne && ne.__asyncGenerator || function(xe, Oe, $e) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var Me = $e.apply(xe, Oe || []), Re, je = [];
    return Re = {}, Be("next"), Be("throw"), Be("return"), Re[Symbol.asyncIterator] = function() {
      return this;
    }, Re;
    function Be(dt) {
      Me[dt] && (Re[dt] = function(yt) {
        return new Promise(function(Ct, It) {
          je.push([dt, yt, Ct, It]) > 1 || ze(dt, yt);
        });
      });
    }
    function ze(dt, yt) {
      try {
        He(Me[dt](yt));
      } catch (Ct) {
        pt(je[0][3], Ct);
      }
    }
    function He(dt) {
      dt.value instanceof ae ? Promise.resolve(dt.value.v).then(qe, Ye) : pt(je[0][2], dt);
    }
    function qe(dt) {
      ze("next", dt);
    }
    function Ye(dt) {
      ze("throw", dt);
    }
    function pt(dt, yt) {
      dt(yt), je.shift(), je.length && ze(je[0][0], je[0][1]);
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isReadableStreamLike = ne.readableStreamLikeToAsyncGenerator = void 0;
  var ye = Mt();
  function ve(xe) {
    return fe(this, arguments, function() {
      var Oe, $e, Me, Re;
      return oe(this, function(je) {
        switch (je.label) {
          case 0:
            Oe = xe.getReader(), je.label = 1;
          case 1:
            je.trys.push([1, , 9, 10]), je.label = 2;
          case 2:
            return [4, ae(Oe.read())];
          case 3:
            return $e = je.sent(), Me = $e.value, Re = $e.done, Re ? [4, ae(void 0)] : [3, 5];
          case 4:
            return [2, je.sent()];
          case 5:
            return [4, ae(Me)];
          case 6:
            return [4, je.sent()];
          case 7:
            return je.sent(), [3, 2];
          case 8:
            return [3, 10];
          case 9:
            return Oe.releaseLock(), [7];
          case 10:
            return [2];
        }
      });
    });
  }
  ne.readableStreamLikeToAsyncGenerator = ve;
  function _e(xe) {
    return ye.isFunction(xe == null ? void 0 : xe.getReader);
  }
  ne.isReadableStreamLike = _e;
}), _t = M((ne) => {
  var oe = ne && ne.__awaiter || function(Ut, Zt, tr, er) {
    function hr(Ot) {
      return Ot instanceof tr ? Ot : new tr(function(Qe) {
        Qe(Ot);
      });
    }
    return new (tr || (tr = Promise))(function(Ot, Qe) {
      function at(At) {
        try {
          bt(er.next(At));
        } catch (Ft) {
          Qe(Ft);
        }
      }
      function wt(At) {
        try {
          bt(er.throw(At));
        } catch (Ft) {
          Qe(Ft);
        }
      }
      function bt(At) {
        At.done ? Ot(At.value) : hr(At.value).then(at, wt);
      }
      bt((er = er.apply(Ut, Zt || [])).next());
    });
  }, ae = ne && ne.__generator || function(Ut, Zt) {
    var tr = { label: 0, sent: function() {
      if (Ot[0] & 1)
        throw Ot[1];
      return Ot[1];
    }, trys: [], ops: [] }, er, hr, Ot, Qe;
    return Qe = { next: at(0), throw: at(1), return: at(2) }, typeof Symbol == "function" && (Qe[Symbol.iterator] = function() {
      return this;
    }), Qe;
    function at(bt) {
      return function(At) {
        return wt([bt, At]);
      };
    }
    function wt(bt) {
      if (er)
        throw new TypeError("Generator is already executing.");
      for (; tr; )
        try {
          if (er = 1, hr && (Ot = bt[0] & 2 ? hr.return : bt[0] ? hr.throw || ((Ot = hr.return) && Ot.call(hr), 0) : hr.next) && !(Ot = Ot.call(hr, bt[1])).done)
            return Ot;
          switch (hr = 0, Ot && (bt = [bt[0] & 2, Ot.value]), bt[0]) {
            case 0:
            case 1:
              Ot = bt;
              break;
            case 4:
              return tr.label++, { value: bt[1], done: !1 };
            case 5:
              tr.label++, hr = bt[1], bt = [0];
              continue;
            case 7:
              bt = tr.ops.pop(), tr.trys.pop();
              continue;
            default:
              if (Ot = tr.trys, !(Ot = Ot.length > 0 && Ot[Ot.length - 1]) && (bt[0] === 6 || bt[0] === 2)) {
                tr = 0;
                continue;
              }
              if (bt[0] === 3 && (!Ot || bt[1] > Ot[0] && bt[1] < Ot[3])) {
                tr.label = bt[1];
                break;
              }
              if (bt[0] === 6 && tr.label < Ot[1]) {
                tr.label = Ot[1], Ot = bt;
                break;
              }
              if (Ot && tr.label < Ot[2]) {
                tr.label = Ot[2], tr.ops.push(bt);
                break;
              }
              Ot[2] && tr.ops.pop(), tr.trys.pop();
              continue;
          }
          bt = Zt.call(Ut, tr);
        } catch (At) {
          bt = [6, At], hr = 0;
        } finally {
          er = Ot = 0;
        }
      if (bt[0] & 5)
        throw bt[1];
      return { value: bt[0] ? bt[1] : void 0, done: !0 };
    }
  }, fe = ne && ne.__asyncValues || function(Ut) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var Zt = Ut[Symbol.asyncIterator], tr;
    return Zt ? Zt.call(Ut) : (Ut = typeof ye == "function" ? ye(Ut) : Ut[Symbol.iterator](), tr = {}, er("next"), er("throw"), er("return"), tr[Symbol.asyncIterator] = function() {
      return this;
    }, tr);
    function er(Ot) {
      tr[Ot] = Ut[Ot] && function(Qe) {
        return new Promise(function(at, wt) {
          Qe = Ut[Ot](Qe), hr(at, wt, Qe.done, Qe.value);
        });
      };
    }
    function hr(Ot, Qe, at, wt) {
      Promise.resolve(wt).then(function(bt) {
        Ot({ value: bt, done: at });
      }, Qe);
    }
  }, ye = ne && ne.__values || function(Ut) {
    var Zt = typeof Symbol == "function" && Symbol.iterator, tr = Zt && Ut[Zt], er = 0;
    if (tr)
      return tr.call(Ut);
    if (Ut && typeof Ut.length == "number")
      return { next: function() {
        return Ut && er >= Ut.length && (Ut = void 0), { value: Ut && Ut[er++], done: !Ut };
      } };
    throw new TypeError(Zt ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromReadableStreamLike = ne.fromAsyncIterable = ne.fromIterable = ne.fromPromise = ne.fromArrayLike = ne.fromInteropObservable = ne.innerFrom = void 0;
  var ve = sS(), _e = tA(), xe = qt(), Oe = rA(), $e = nA(), Me = iA(), Re = oA(), je = mS(), Be = Mt(), ze = Fk(), He = uh();
  function qe(Ut) {
    if (Ut instanceof xe.Observable)
      return Ut;
    if (Ut != null) {
      if (Oe.isInteropObservable(Ut))
        return Ye(Ut);
      if (ve.isArrayLike(Ut))
        return pt(Ut);
      if (_e.isPromise(Ut))
        return dt(Ut);
      if ($e.isAsyncIterable(Ut))
        return Ct(Ut);
      if (Re.isIterable(Ut))
        return yt(Ut);
      if (je.isReadableStreamLike(Ut))
        return It(Ut);
    }
    throw Me.createInvalidObservableTypeError(Ut);
  }
  ne.innerFrom = qe;
  function Ye(Ut) {
    return new xe.Observable(function(Zt) {
      var tr = Ut[He.observable]();
      if (Be.isFunction(tr.subscribe))
        return tr.subscribe(Zt);
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  ne.fromInteropObservable = Ye;
  function pt(Ut) {
    return new xe.Observable(function(Zt) {
      for (var tr = 0; tr < Ut.length && !Zt.closed; tr++)
        Zt.next(Ut[tr]);
      Zt.complete();
    });
  }
  ne.fromArrayLike = pt;
  function dt(Ut) {
    return new xe.Observable(function(Zt) {
      Ut.then(function(tr) {
        Zt.closed || (Zt.next(tr), Zt.complete());
      }, function(tr) {
        return Zt.error(tr);
      }).then(null, ze.reportUnhandledError);
    });
  }
  ne.fromPromise = dt;
  function yt(Ut) {
    return new xe.Observable(function(Zt) {
      var tr, er;
      try {
        for (var hr = ye(Ut), Ot = hr.next(); !Ot.done; Ot = hr.next()) {
          var Qe = Ot.value;
          if (Zt.next(Qe), Zt.closed)
            return;
        }
      } catch (at) {
        tr = { error: at };
      } finally {
        try {
          Ot && !Ot.done && (er = hr.return) && er.call(hr);
        } finally {
          if (tr)
            throw tr.error;
        }
      }
      Zt.complete();
    });
  }
  ne.fromIterable = yt;
  function Ct(Ut) {
    return new xe.Observable(function(Zt) {
      Vt(Ut, Zt).catch(function(tr) {
        return Zt.error(tr);
      });
    });
  }
  ne.fromAsyncIterable = Ct;
  function It(Ut) {
    return Ct(je.readableStreamLikeToAsyncGenerator(Ut));
  }
  ne.fromReadableStreamLike = It;
  function Vt(Ut, Zt) {
    var tr, er, hr, Ot;
    return oe(this, void 0, void 0, function() {
      var Qe, at;
      return ae(this, function(wt) {
        switch (wt.label) {
          case 0:
            wt.trys.push([0, 5, 6, 11]), tr = fe(Ut), wt.label = 1;
          case 1:
            return [4, tr.next()];
          case 2:
            if (er = wt.sent(), !!er.done)
              return [3, 4];
            if (Qe = er.value, Zt.next(Qe), Zt.closed)
              return [2];
            wt.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return at = wt.sent(), hr = { error: at }, [3, 11];
          case 6:
            return wt.trys.push([6, , 9, 10]), er && !er.done && (Ot = tr.return) ? [4, Ot.call(tr)] : [3, 8];
          case 7:
            wt.sent(), wt.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (hr)
              throw hr.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return Zt.complete(), [2];
        }
      });
    });
  }
}), Au = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.executeSchedule = void 0;
  function oe(ae, fe, ye, ve, _e) {
    ve === void 0 && (ve = 0), _e === void 0 && (_e = !1);
    var xe = fe.schedule(function() {
      ye(), _e ? ae.add(this.schedule(null, ve)) : this.unsubscribe();
    }, ve);
    if (ae.add(xe), !_e)
      return xe;
  }
  ne.executeSchedule = oe;
}), ph = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeOn = void 0;
  var oe = Au(), ae = he(), fe = Ae();
  function ye(ve, _e) {
    return _e === void 0 && (_e = 0), ae.operate(function(xe, Oe) {
      xe.subscribe(fe.createOperatorSubscriber(Oe, function($e) {
        return oe.executeSchedule(Oe, ve, function() {
          return Oe.next($e);
        }, _e);
      }, function() {
        return oe.executeSchedule(Oe, ve, function() {
          return Oe.complete();
        }, _e);
      }, function($e) {
        return oe.executeSchedule(Oe, ve, function() {
          return Oe.error($e);
        }, _e);
      }));
    });
  }
  ne.observeOn = ye;
}), vh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.subscribeOn = void 0;
  var oe = he();
  function ae(fe, ye) {
    return ye === void 0 && (ye = 0), oe.operate(function(ve, _e) {
      _e.add(fe.schedule(function() {
        return ve.subscribe(_e);
      }, ye));
    });
  }
  ne.subscribeOn = ae;
}), JI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleObservable = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(ve, _e) {
    return oe.innerFrom(ve).pipe(fe.subscribeOn(_e), ae.observeOn(_e));
  }
  ne.scheduleObservable = ye;
}), ZI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.schedulePromise = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(ve, _e) {
    return oe.innerFrom(ve).pipe(fe.subscribeOn(_e), ae.observeOn(_e));
  }
  ne.schedulePromise = ye;
}), e3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleArray = void 0;
  var oe = qt();
  function ae(fe, ye) {
    return new oe.Observable(function(ve) {
      var _e = 0;
      return ye.schedule(function() {
        _e === fe.length ? ve.complete() : (ve.next(fe[_e++]), ve.closed || this.schedule());
      });
    });
  }
  ne.scheduleArray = ae;
}), cA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleIterable = void 0;
  var oe = qt(), ae = aA(), fe = Mt(), ye = Au();
  function ve(_e, xe) {
    return new oe.Observable(function(Oe) {
      var $e;
      return ye.executeSchedule(Oe, xe, function() {
        $e = _e[ae.iterator](), ye.executeSchedule(Oe, xe, function() {
          var Me, Re, je;
          try {
            Me = $e.next(), Re = Me.value, je = Me.done;
          } catch (Be) {
            Oe.error(Be);
            return;
          }
          je ? Oe.complete() : Oe.next(Re);
        }, 0, !0);
      }), function() {
        return fe.isFunction($e == null ? void 0 : $e.return) && $e.return();
      };
    });
  }
  ne.scheduleIterable = ve;
}), fA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleAsyncIterable = void 0;
  var oe = qt(), ae = Au();
  function fe(ye, ve) {
    if (!ye)
      throw new Error("Iterable cannot be null");
    return new oe.Observable(function(_e) {
      ae.executeSchedule(_e, ve, function() {
        var xe = ye[Symbol.asyncIterator]();
        ae.executeSchedule(_e, ve, function() {
          xe.next().then(function(Oe) {
            Oe.done ? _e.complete() : _e.next(Oe.value);
          });
        }, 0, !0);
      });
    });
  }
  ne.scheduleAsyncIterable = fe;
}), n3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleReadableStreamLike = void 0;
  var oe = fA(), ae = mS();
  function fe(ye, ve) {
    return oe.scheduleAsyncIterable(ae.readableStreamLikeToAsyncGenerator(ye), ve);
  }
  ne.scheduleReadableStreamLike = fe;
}), dA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduled = void 0;
  var oe = JI(), ae = ZI(), fe = e3(), ye = cA(), ve = fA(), _e = rA(), xe = tA(), Oe = sS(), $e = oA(), Me = nA(), Re = iA(), je = mS(), Be = n3();
  function ze(He, qe) {
    if (He != null) {
      if (_e.isInteropObservable(He))
        return oe.scheduleObservable(He, qe);
      if (Oe.isArrayLike(He))
        return fe.scheduleArray(He, qe);
      if (xe.isPromise(He))
        return ae.schedulePromise(He, qe);
      if (Me.isAsyncIterable(He))
        return ve.scheduleAsyncIterable(He, qe);
      if ($e.isIterable(He))
        return ye.scheduleIterable(He, qe);
      if (je.isReadableStreamLike(He))
        return Be.scheduleReadableStreamLike(He, qe);
    }
    throw Re.createInvalidObservableTypeError(He);
  }
  ne.scheduled = ze;
}), Ja = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.from = void 0;
  var oe = dA(), ae = _t();
  function fe(ye, ve) {
    return ve ? oe.scheduled(ye, ve) : ae.innerFrom(ye);
  }
  ne.from = fe;
}), TS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.of = void 0;
  var oe = ki(), ae = Ja();
  function fe() {
    for (var ye = [], ve = 0; ve < arguments.length; ve++)
      ye[ve] = arguments[ve];
    var _e = oe.popScheduler(ye);
    return ae.from(ye, _e);
  }
  ne.of = fe;
}), pA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwError = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye, ve) {
    var _e = ae.isFunction(ye) ? ye : function() {
      return ye;
    }, xe = function(Oe) {
      return Oe.error(_e());
    };
    return new oe.Observable(ve ? function(Oe) {
      return ve.schedule(xe, 0, Oe);
    } : xe);
  }
  ne.throwError = fe;
}), AS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeNotification = ne.Notification = ne.NotificationKind = void 0;
  var oe = ba(), ae = TS(), fe = pA(), ye = Mt();
  (function(xe) {
    xe.NEXT = "N", xe.ERROR = "E", xe.COMPLETE = "C";
  })(ne.NotificationKind || (ne.NotificationKind = {}));
  var ve = function() {
    function xe(Oe, $e, Me) {
      this.kind = Oe, this.value = $e, this.error = Me, this.hasValue = Oe === "N";
    }
    return xe.prototype.observe = function(Oe) {
      return _e(this, Oe);
    }, xe.prototype.do = function(Oe, $e, Me) {
      var Re = this, je = Re.kind, Be = Re.value, ze = Re.error;
      return je === "N" ? Oe == null ? void 0 : Oe(Be) : je === "E" ? $e == null ? void 0 : $e(ze) : Me == null ? void 0 : Me();
    }, xe.prototype.accept = function(Oe, $e, Me) {
      var Re;
      return ye.isFunction((Re = Oe) === null || Re === void 0 ? void 0 : Re.next) ? this.observe(Oe) : this.do(Oe, $e, Me);
    }, xe.prototype.toObservable = function() {
      var Oe = this, $e = Oe.kind, Me = Oe.value, Re = Oe.error, je = $e === "N" ? ae.of(Me) : $e === "E" ? fe.throwError(function() {
        return Re;
      }) : $e === "C" ? oe.EMPTY : 0;
      if (!je)
        throw new TypeError("Unexpected notification kind " + $e);
      return je;
    }, xe.createNext = function(Oe) {
      return new xe("N", Oe);
    }, xe.createError = function(Oe) {
      return new xe("E", void 0, Oe);
    }, xe.createComplete = function() {
      return xe.completeNotification;
    }, xe.completeNotification = new xe("C"), xe;
  }();
  ne.Notification = ve;
  function _e(xe, Oe) {
    var $e, Me, Re, je = xe, Be = je.kind, ze = je.value, He = je.error;
    if (typeof Be != "string")
      throw new TypeError('Invalid notification, missing "kind"');
    Be === "N" ? ($e = Oe.next) === null || $e === void 0 || $e.call(Oe, ze) : Be === "E" ? (Me = Oe.error) === null || Me === void 0 || Me.call(Oe, He) : (Re = Oe.complete) === null || Re === void 0 || Re.call(Oe);
  }
  ne.observeNotification = _e;
}), o3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isObservable = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye) {
    return !!ye && (ye instanceof oe.Observable || ae.isFunction(ye.lift) && ae.isFunction(ye.subscribe));
  }
  ne.isObservable = fe;
}), $l = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EmptyError = void 0;
  var oe = Il();
  ne.EmptyError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "EmptyError", this.message = "no elements in sequence";
    };
  });
}), u3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.lastValueFrom = void 0;
  var oe = $l();
  function ae(fe, ye) {
    var ve = typeof ye == "object";
    return new Promise(function(_e, xe) {
      var Oe = !1, $e;
      fe.subscribe({ next: function(Me) {
        $e = Me, Oe = !0;
      }, error: xe, complete: function() {
        Oe ? _e($e) : ve ? _e(ye.defaultValue) : xe(new oe.EmptyError());
      } });
    });
  }
  ne.lastValueFrom = ae;
}), l3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.firstValueFrom = void 0;
  var oe = $l(), ae = Sd();
  function fe(ye, ve) {
    var _e = typeof ve == "object";
    return new Promise(function(xe, Oe) {
      var $e = new ae.SafeSubscriber({ next: function(Me) {
        xe(Me), $e.unsubscribe();
      }, error: Oe, complete: function() {
        _e ? xe(ve.defaultValue) : Oe(new oe.EmptyError());
      } });
      ye.subscribe($e);
    });
  }
  ne.firstValueFrom = fe;
}), vA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ArgumentOutOfRangeError = void 0;
  var oe = Il();
  ne.ArgumentOutOfRangeError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ArgumentOutOfRangeError", this.message = "argument out of range";
    };
  });
}), mA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.NotFoundError = void 0;
  var oe = Il();
  ne.NotFoundError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "NotFoundError", this.message = fe;
    };
  });
}), hA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.SequenceError = void 0;
  var oe = Il();
  ne.SequenceError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "SequenceError", this.message = fe;
    };
  });
}), zS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isValidDate = void 0;
  function oe(ae) {
    return ae instanceof Date && !isNaN(ae);
  }
  ne.isValidDate = oe;
}), qS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeout = ne.TimeoutError = void 0;
  var oe = Ti(), ae = zS(), fe = he(), ye = _t(), ve = Il(), _e = Ae(), xe = Au();
  ne.TimeoutError = ve.createErrorClass(function(Me) {
    return function(Re) {
      Re === void 0 && (Re = null), Me(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = Re;
    };
  });
  function Oe(Me, Re) {
    var je = ae.isValidDate(Me) ? { first: Me } : typeof Me == "number" ? { each: Me } : Me, Be = je.first, ze = je.each, He = je.with, qe = He === void 0 ? $e : He, Ye = je.scheduler, pt = Ye === void 0 ? Re ?? oe.asyncScheduler : Ye, dt = je.meta, yt = dt === void 0 ? null : dt;
    if (Be == null && ze == null)
      throw new TypeError("No timeout provided.");
    return fe.operate(function(Ct, It) {
      var Vt, Ut, Zt = null, tr = 0, er = function(hr) {
        Ut = xe.executeSchedule(It, pt, function() {
          try {
            Vt.unsubscribe(), ye.innerFrom(qe({ meta: yt, lastValue: Zt, seen: tr })).subscribe(It);
          } catch (Ot) {
            It.error(Ot);
          }
        }, hr);
      };
      Vt = Ct.subscribe(_e.createOperatorSubscriber(It, function(hr) {
        Ut == null || Ut.unsubscribe(), tr++, It.next(Zt = hr), ze > 0 && er(ze);
      }, void 0, void 0, function() {
        Ut != null && Ut.closed || (Ut == null || Ut.unsubscribe()), Zt = null;
      })), !tr && er(Be != null ? typeof Be == "number" ? Be : +Be - pt.now() : ze);
    });
  }
  ne.timeout = Oe;
  function $e(Me) {
    throw new ne.TimeoutError(Me);
  }
}), Wl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.map = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ve) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        xe.next(ye.call(ve, $e, Oe++));
      }));
    });
  }
  ne.map = fe;
}), Gl = M((ne) => {
  var oe = ne && ne.__read || function(xe, Oe) {
    var $e = typeof Symbol == "function" && xe[Symbol.iterator];
    if (!$e)
      return xe;
    var Me = $e.call(xe), Re, je = [], Be;
    try {
      for (; (Oe === void 0 || Oe-- > 0) && !(Re = Me.next()).done; )
        je.push(Re.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Re && !Re.done && ($e = Me.return) && $e.call(Me);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return je;
  }, ae = ne && ne.__spreadArray || function(xe, Oe) {
    for (var $e = 0, Me = Oe.length, Re = xe.length; $e < Me; $e++, Re++)
      xe[Re] = Oe[$e];
    return xe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapOneOrManyArgs = void 0;
  var fe = Wl(), ye = Array.isArray;
  function ve(xe, Oe) {
    return ye(Oe) ? xe.apply(void 0, ae([], oe(Oe))) : xe(Oe);
  }
  function _e(xe) {
    return fe.map(function(Oe) {
      return ve(xe, Oe);
    });
  }
  ne.mapOneOrManyArgs = _e;
}), gA = M((ne) => {
  var oe = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallbackInternals = void 0;
  var fe = dh(), ye = qt(), ve = vh(), _e = Gl(), xe = ph(), Oe = iS();
  function $e(Me, Re, je, Be) {
    if (je)
      if (fe.isScheduler(je))
        Be = je;
      else
        return function() {
          for (var ze = [], He = 0; He < arguments.length; He++)
            ze[He] = arguments[He];
          return $e(Me, Re, Be).apply(this, ze).pipe(_e.mapOneOrManyArgs(je));
        };
    return Be ? function() {
      for (var ze = [], He = 0; He < arguments.length; He++)
        ze[He] = arguments[He];
      return $e(Me, Re).apply(this, ze).pipe(ve.subscribeOn(Be), xe.observeOn(Be));
    } : function() {
      for (var ze = this, He = [], qe = 0; qe < arguments.length; qe++)
        He[qe] = arguments[qe];
      var Ye = new Oe.AsyncSubject(), pt = !0;
      return new ye.Observable(function(dt) {
        var yt = Ye.subscribe(dt);
        if (pt) {
          pt = !1;
          var Ct = !1, It = !1;
          Re.apply(ze, ae(ae([], oe(He)), [function() {
            for (var Vt = [], Ut = 0; Ut < arguments.length; Ut++)
              Vt[Ut] = arguments[Ut];
            if (Me) {
              var Zt = Vt.shift();
              if (Zt != null) {
                Ye.error(Zt);
                return;
              }
            }
            Ye.next(1 < Vt.length ? Vt : Vt[0]), It = !0, Ct && Ye.complete();
          }])), It && Ye.complete(), Ct = !0;
        }
        return yt;
      });
    };
  }
  ne.bindCallbackInternals = $e;
}), c3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallback = void 0;
  var oe = gA();
  function ae(fe, ye, ve) {
    return oe.bindCallbackInternals(!1, fe, ye, ve);
  }
  ne.bindCallback = ae;
}), f3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindNodeCallback = void 0;
  var oe = gA();
  function ae(fe, ye, ve) {
    return oe.bindCallbackInternals(!0, fe, ye, ve);
  }
  ne.bindNodeCallback = ae;
}), bA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsArgArrayOrObject = void 0;
  var oe = Array.isArray, ae = Object.getPrototypeOf, fe = Object.prototype, ye = Object.keys;
  function ve(xe) {
    if (xe.length === 1) {
      var Oe = xe[0];
      if (oe(Oe))
        return { args: Oe, keys: null };
      if (_e(Oe)) {
        var $e = ye(Oe);
        return { args: $e.map(function(Me) {
          return Oe[Me];
        }), keys: $e };
      }
    }
    return { args: xe, keys: null };
  }
  ne.argsArgArrayOrObject = ve;
  function _e(xe) {
    return xe && typeof xe == "object" && ae(xe) === fe;
  }
}), SA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createObject = void 0;
  function oe(ae, fe) {
    return ae.reduce(function(ye, ve, _e) {
      return ye[ve] = fe[_e], ye;
    }, {});
  }
  ne.createObject = oe;
}), WS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestInit = ne.combineLatest = void 0;
  var oe = qt(), ae = bA(), fe = Ja(), ye = Hn(), ve = Gl(), _e = ki(), xe = SA(), Oe = Ae(), $e = Au();
  function Me() {
    for (var Be = [], ze = 0; ze < arguments.length; ze++)
      Be[ze] = arguments[ze];
    var He = _e.popScheduler(Be), qe = _e.popResultSelector(Be), Ye = ae.argsArgArrayOrObject(Be), pt = Ye.args, dt = Ye.keys;
    if (pt.length === 0)
      return fe.from([], He);
    var yt = new oe.Observable(Re(pt, He, dt ? function(Ct) {
      return xe.createObject(dt, Ct);
    } : ye.identity));
    return qe ? yt.pipe(ve.mapOneOrManyArgs(qe)) : yt;
  }
  ne.combineLatest = Me;
  function Re(Be, ze, He) {
    return He === void 0 && (He = ye.identity), function(qe) {
      je(ze, function() {
        for (var Ye = Be.length, pt = new Array(Ye), dt = Ye, yt = Ye, Ct = function(Vt) {
          je(ze, function() {
            var Ut = fe.from(Be[Vt], ze), Zt = !1;
            Ut.subscribe(Oe.createOperatorSubscriber(qe, function(tr) {
              pt[Vt] = tr, Zt || (Zt = !0, yt--), yt || qe.next(He(pt.slice()));
            }, function() {
              --dt || qe.complete();
            }));
          }, qe);
        }, It = 0; It < Ye; It++)
          Ct(It);
      }, qe);
    };
  }
  ne.combineLatestInit = Re;
  function je(Be, ze, He) {
    Be ? $e.executeSchedule(He, Be, ze) : ze();
  }
}), GS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeInternals = void 0;
  var oe = _t(), ae = Au(), fe = Ae();
  function ye(ve, _e, xe, Oe, $e, Me, Re, je) {
    var Be = [], ze = 0, He = 0, qe = !1, Ye = function() {
      qe && !Be.length && !ze && _e.complete();
    }, pt = function(yt) {
      return ze < Oe ? dt(yt) : Be.push(yt);
    }, dt = function(yt) {
      Me && _e.next(yt), ze++;
      var Ct = !1;
      oe.innerFrom(xe(yt, He++)).subscribe(fe.createOperatorSubscriber(_e, function(It) {
        $e == null || $e(It), Me ? pt(It) : _e.next(It);
      }, function() {
        Ct = !0;
      }, void 0, function() {
        if (Ct)
          try {
            ze--;
            for (var It = function() {
              var Vt = Be.shift();
              Re ? ae.executeSchedule(_e, Re, function() {
                return dt(Vt);
              }) : dt(Vt);
            }; Be.length && ze < Oe; )
              It();
            Ye();
          } catch (Vt) {
            _e.error(Vt);
          }
      }));
    };
    return ve.subscribe(fe.createOperatorSubscriber(_e, pt, function() {
      qe = !0, Ye();
    })), function() {
      je == null || je();
    };
  }
  ne.mergeInternals = ye;
}), Mu = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = GS(), ve = Mt();
  function _e(xe, Oe, $e) {
    return $e === void 0 && ($e = 1 / 0), ve.isFunction(Oe) ? _e(function(Me, Re) {
      return oe.map(function(je, Be) {
        return Oe(Me, je, Re, Be);
      })(ae.innerFrom(xe(Me, Re)));
    }, $e) : (typeof Oe == "number" && ($e = Oe), fe.operate(function(Me, Re) {
      return ye.mergeInternals(Me, Re, xe, $e);
    }));
  }
  ne.mergeMap = _e;
}), mh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeAll = void 0;
  var oe = Mu(), ae = Hn();
  function fe(ye) {
    return ye === void 0 && (ye = 1 / 0), oe.mergeMap(ae.identity, ye);
  }
  ne.mergeAll = fe;
}), JS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatAll = void 0;
  var oe = mh();
  function ae() {
    return oe.mergeAll(1);
  }
  ne.concatAll = ae;
}), hh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var oe = JS(), ae = ki(), fe = Ja();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return oe.concatAll()(fe.from(ve, ae.popScheduler(ve)));
  }
  ne.concat = ye;
}), yh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defer = void 0;
  var oe = qt(), ae = _t();
  function fe(ye) {
    return new oe.Observable(function(ve) {
      ae.innerFrom(ye()).subscribe(ve);
    });
  }
  ne.defer = fe;
}), b3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connectable = void 0;
  var oe = Tn(), ae = qt(), fe = yh(), ye = { connector: function() {
    return new oe.Subject();
  }, resetOnDisconnect: !0 };
  function ve(_e, xe) {
    xe === void 0 && (xe = ye);
    var Oe = null, $e = xe.connector, Me = xe.resetOnDisconnect, Re = Me === void 0 ? !0 : Me, je = $e(), Be = new ae.Observable(function(ze) {
      return je.subscribe(ze);
    });
    return Be.connect = function() {
      return (!Oe || Oe.closed) && (Oe = fe.defer(function() {
        return _e;
      }).subscribe(je), Re && Oe.add(function() {
        return je = $e();
      })), Oe;
    }, Be;
  }
  ne.connectable = ve;
}), S3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.forkJoin = void 0;
  var oe = qt(), ae = bA(), fe = _t(), ye = ki(), ve = Ae(), _e = Gl(), xe = SA();
  function Oe() {
    for (var $e = [], Me = 0; Me < arguments.length; Me++)
      $e[Me] = arguments[Me];
    var Re = ye.popResultSelector($e), je = ae.argsArgArrayOrObject($e), Be = je.args, ze = je.keys, He = new oe.Observable(function(qe) {
      var Ye = Be.length;
      if (!Ye) {
        qe.complete();
        return;
      }
      for (var pt = new Array(Ye), dt = Ye, yt = Ye, Ct = function(Vt) {
        var Ut = !1;
        fe.innerFrom(Be[Vt]).subscribe(ve.createOperatorSubscriber(qe, function(Zt) {
          Ut || (Ut = !0, yt--), pt[Vt] = Zt;
        }, function() {
          return dt--;
        }, void 0, function() {
          (!dt || !Ut) && (yt || qe.next(ze ? xe.createObject(ze, pt) : pt), qe.complete());
        }));
      }, It = 0; It < Ye; It++)
        Ct(It);
    });
    return Re ? He.pipe(_e.mapOneOrManyArgs(Re)) : He;
  }
  ne.forkJoin = Oe;
}), w3 = M((ne) => {
  var oe = ne && ne.__read || function(qe, Ye) {
    var pt = typeof Symbol == "function" && qe[Symbol.iterator];
    if (!pt)
      return qe;
    var dt = pt.call(qe), yt, Ct = [], It;
    try {
      for (; (Ye === void 0 || Ye-- > 0) && !(yt = dt.next()).done; )
        Ct.push(yt.value);
    } catch (Vt) {
      It = { error: Vt };
    } finally {
      try {
        yt && !yt.done && (pt = dt.return) && pt.call(dt);
      } finally {
        if (It)
          throw It.error;
      }
    }
    return Ct;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEvent = void 0;
  var ae = _t(), fe = qt(), ye = Mu(), ve = sS(), _e = Mt(), xe = Gl(), Oe = ["addListener", "removeListener"], $e = ["addEventListener", "removeEventListener"], Me = ["on", "off"];
  function Re(qe, Ye, pt, dt) {
    if (_e.isFunction(pt) && (dt = pt, pt = void 0), dt)
      return Re(qe, Ye, pt).pipe(xe.mapOneOrManyArgs(dt));
    var yt = oe(He(qe) ? $e.map(function(Vt) {
      return function(Ut) {
        return qe[Vt](Ye, Ut, pt);
      };
    }) : Be(qe) ? Oe.map(je(qe, Ye)) : ze(qe) ? Me.map(je(qe, Ye)) : [], 2), Ct = yt[0], It = yt[1];
    if (!Ct && ve.isArrayLike(qe))
      return ye.mergeMap(function(Vt) {
        return Re(Vt, Ye, pt);
      })(ae.innerFrom(qe));
    if (!Ct)
      throw new TypeError("Invalid event target");
    return new fe.Observable(function(Vt) {
      var Ut = function() {
        for (var Zt = [], tr = 0; tr < arguments.length; tr++)
          Zt[tr] = arguments[tr];
        return Vt.next(1 < Zt.length ? Zt : Zt[0]);
      };
      return Ct(Ut), function() {
        return It(Ut);
      };
    });
  }
  ne.fromEvent = Re;
  function je(qe, Ye) {
    return function(pt) {
      return function(dt) {
        return qe[pt](Ye, dt);
      };
    };
  }
  function Be(qe) {
    return _e.isFunction(qe.addListener) && _e.isFunction(qe.removeListener);
  }
  function ze(qe) {
    return _e.isFunction(qe.on) && _e.isFunction(qe.off);
  }
  function He(qe) {
    return _e.isFunction(qe.addEventListener) && _e.isFunction(qe.removeEventListener);
  }
}), E3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEventPattern = void 0;
  var oe = qt(), ae = Mt(), fe = Gl();
  function ye(ve, _e, xe) {
    return xe ? ye(ve, _e).pipe(fe.mapOneOrManyArgs(xe)) : new oe.Observable(function(Oe) {
      var $e = function() {
        for (var Re = [], je = 0; je < arguments.length; je++)
          Re[je] = arguments[je];
        return Oe.next(Re.length === 1 ? Re[0] : Re);
      }, Me = ve($e);
      return ae.isFunction(_e) ? function() {
        return _e($e, Me);
      } : void 0;
    });
  }
  ne.fromEventPattern = ye;
}), R3 = M((ne) => {
  var oe = ne && ne.__generator || function(xe, Oe) {
    var $e = { label: 0, sent: function() {
      if (je[0] & 1)
        throw je[1];
      return je[1];
    }, trys: [], ops: [] }, Me, Re, je, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(qe) {
      return function(Ye) {
        return He([qe, Ye]);
      };
    }
    function He(qe) {
      if (Me)
        throw new TypeError("Generator is already executing.");
      for (; $e; )
        try {
          if (Me = 1, Re && (je = qe[0] & 2 ? Re.return : qe[0] ? Re.throw || ((je = Re.return) && je.call(Re), 0) : Re.next) && !(je = je.call(Re, qe[1])).done)
            return je;
          switch (Re = 0, je && (qe = [qe[0] & 2, je.value]), qe[0]) {
            case 0:
            case 1:
              je = qe;
              break;
            case 4:
              return $e.label++, { value: qe[1], done: !1 };
            case 5:
              $e.label++, Re = qe[1], qe = [0];
              continue;
            case 7:
              qe = $e.ops.pop(), $e.trys.pop();
              continue;
            default:
              if (je = $e.trys, !(je = je.length > 0 && je[je.length - 1]) && (qe[0] === 6 || qe[0] === 2)) {
                $e = 0;
                continue;
              }
              if (qe[0] === 3 && (!je || qe[1] > je[0] && qe[1] < je[3])) {
                $e.label = qe[1];
                break;
              }
              if (qe[0] === 6 && $e.label < je[1]) {
                $e.label = je[1], je = qe;
                break;
              }
              if (je && $e.label < je[2]) {
                $e.label = je[2], $e.ops.push(qe);
                break;
              }
              je[2] && $e.ops.pop(), $e.trys.pop();
              continue;
          }
          qe = Oe.call(xe, $e);
        } catch (Ye) {
          qe = [6, Ye], Re = 0;
        } finally {
          Me = je = 0;
        }
      if (qe[0] & 5)
        throw qe[1];
      return { value: qe[0] ? qe[1] : void 0, done: !0 };
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.generate = void 0;
  var ae = Hn(), fe = dh(), ye = yh(), ve = cA();
  function _e(xe, Oe, $e, Me, Re) {
    var je, Be, ze, He;
    arguments.length === 1 ? (je = xe, He = je.initialState, Oe = je.condition, $e = je.iterate, Be = je.resultSelector, ze = Be === void 0 ? ae.identity : Be, Re = je.scheduler) : (He = xe, !Me || fe.isScheduler(Me) ? (ze = ae.identity, Re = Me) : ze = Me);
    function qe() {
      var Ye;
      return oe(this, function(pt) {
        switch (pt.label) {
          case 0:
            Ye = He, pt.label = 1;
          case 1:
            return !Oe || Oe(Ye) ? [4, ze(Ye)] : [3, 4];
          case 2:
            pt.sent(), pt.label = 3;
          case 3:
            return Ye = $e(Ye), [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return ye.defer(Re ? function() {
      return ve.scheduleIterable(qe(), Re);
    } : qe);
  }
  ne.generate = _e;
}), O3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iif = void 0;
  var oe = yh();
  function ae(fe, ye, ve) {
    return oe.defer(function() {
      return fe() ? ye : ve;
    });
  }
  ne.iif = ae;
}), Kl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timer = void 0;
  var oe = qt(), ae = Ti(), fe = dh(), ye = zS();
  function ve(_e, xe, Oe) {
    _e === void 0 && (_e = 0), Oe === void 0 && (Oe = ae.async);
    var $e = -1;
    return xe != null && (fe.isScheduler(xe) ? Oe = xe : $e = xe), new oe.Observable(function(Me) {
      var Re = ye.isValidDate(_e) ? +_e - Oe.now() : _e;
      Re < 0 && (Re = 0);
      var je = 0;
      return Oe.schedule(function() {
        Me.closed || (Me.next(je++), 0 <= $e ? this.schedule(void 0, $e) : Me.complete());
      }, Re);
    });
  }
  ne.timer = ve;
}), wA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = void 0;
  var oe = Ti(), ae = Kl();
  function fe(ye, ve) {
    return ye === void 0 && (ye = 0), ve === void 0 && (ve = oe.asyncScheduler), ye < 0 && (ye = 0), ae.timer(ye, ye, ve);
  }
  ne.interval = fe;
}), k3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var oe = mh(), ae = _t(), fe = ba(), ye = ki(), ve = Ja();
  function _e() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    var $e = ye.popScheduler(xe), Me = ye.popNumber(xe, 1 / 0), Re = xe;
    return Re.length ? Re.length === 1 ? ae.innerFrom(Re[0]) : oe.mergeAll(Me)(ve.from(Re, $e)) : fe.EMPTY;
  }
  ne.merge = _e;
}), xA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.never = ne.NEVER = void 0;
  var oe = qt(), ae = On();
  ne.NEVER = new oe.Observable(ae.noop);
  function fe() {
    return ne.NEVER;
  }
  ne.never = fe;
}), Sc = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsOrArgArray = void 0;
  var oe = Array.isArray;
  function ae(fe) {
    return fe.length === 1 && oe(fe[0]) ? fe[0] : fe;
  }
  ne.argsOrArgArray = ae;
}), P3 = M((ne) => {
  var oe = ne && ne.__read || function($e, Me) {
    var Re = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Re)
      return $e;
    var je = Re.call($e), Be, ze = [], He;
    try {
      for (; (Me === void 0 || Me-- > 0) && !(Be = je.next()).done; )
        ze.push(Be.value);
    } catch (qe) {
      He = { error: qe };
    } finally {
      try {
        Be && !Be.done && (Re = je.return) && Re.call(je);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function($e, Me) {
    for (var Re = 0, je = Me.length, Be = $e.length; Re < je; Re++, Be++)
      $e[Be] = Me[Re];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var fe = he(), ye = _t(), ve = Sc(), _e = Ae(), xe = On();
  function Oe() {
    for (var $e = [], Me = 0; Me < arguments.length; Me++)
      $e[Me] = arguments[Me];
    var Re = ve.argsOrArgArray($e);
    return fe.operate(function(je, Be) {
      var ze = ae([je], oe(Re)), He = function() {
        if (!Be.closed)
          if (ze.length > 0) {
            var qe = void 0;
            try {
              qe = ye.innerFrom(ze.shift());
            } catch {
              He();
              return;
            }
            var Ye = _e.createOperatorSubscriber(Be, void 0, xe.noop, xe.noop);
            qe.subscribe(Ye), Ye.add(He);
          } else
            Be.complete();
      };
      He();
    });
  }
  ne.onErrorResumeNext = Oe;
}), M3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var oe = ba(), ae = P3(), fe = Sc();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return ae.onErrorResumeNext(fe.argsOrArgArray(ve))(oe.EMPTY);
  }
  ne.onErrorResumeNext = ye;
}), D3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairs = void 0;
  var oe = Ja();
  function ae(fe, ye) {
    return oe.from(Object.entries(fe), ye);
  }
  ne.pairs = ae;
}), N3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.not = void 0;
  function oe(ae, fe) {
    return function(ye, ve) {
      return !ae.call(fe, ye, ve);
    };
  }
  ne.not = oe;
}), _c = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.filter = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ve) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        return ye.call(ve, $e, Oe++) && xe.next($e);
      }));
    });
  }
  ne.filter = fe;
}), U3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.partition = void 0;
  var oe = N3(), ae = _c(), fe = _t();
  function ye(ve, _e, xe) {
    return [ae.filter(_e, xe)(fe.innerFrom(ve)), ae.filter(oe.not(_e, xe))(fe.innerFrom(ve))];
  }
  ne.partition = ye;
}), EA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceInit = ne.race = void 0;
  var oe = qt(), ae = _t(), fe = Sc(), ye = Ae();
  function ve() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    return xe = fe.argsOrArgArray(xe), xe.length === 1 ? ae.innerFrom(xe[0]) : new oe.Observable(_e(xe));
  }
  ne.race = ve;
  function _e(xe) {
    return function(Oe) {
      for (var $e = [], Me = function(je) {
        $e.push(ae.innerFrom(xe[je]).subscribe(ye.createOperatorSubscriber(Oe, function(Be) {
          if ($e) {
            for (var ze = 0; ze < $e.length; ze++)
              ze !== je && $e[ze].unsubscribe();
            $e = null;
          }
          Oe.next(Be);
        })));
      }, Re = 0; $e && !Oe.closed && Re < xe.length; Re++)
        Me(Re);
    };
  }
  ne.raceInit = _e;
}), q3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.range = void 0;
  var oe = qt(), ae = ba();
  function fe(ye, ve, _e) {
    if (ve == null && (ve = ye, ye = 0), ve <= 0)
      return ae.EMPTY;
    var xe = ve + ye;
    return new oe.Observable(_e ? function(Oe) {
      var $e = ye;
      return _e.schedule(function() {
        $e < xe ? (Oe.next($e++), this.schedule()) : Oe.complete();
      });
    } : function(Oe) {
      for (var $e = ye; $e < xe && !Oe.closed; )
        Oe.next($e++);
      Oe.complete();
    });
  }
  ne.range = fe;
}), I3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.using = void 0;
  var oe = qt(), ae = _t(), fe = ba();
  function ye(ve, _e) {
    return new oe.Observable(function(xe) {
      var Oe = ve(), $e = _e(Oe), Me = $e ? ae.innerFrom($e) : fe.EMPTY;
      return Me.subscribe(xe), function() {
        Oe && Oe.unsubscribe();
      };
    });
  }
  ne.using = ye;
}), h_ = M((ne) => {
  var oe = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = qt(), ye = _t(), ve = Sc(), _e = ba(), xe = Ae(), Oe = ki();
  function $e() {
    for (var Me = [], Re = 0; Re < arguments.length; Re++)
      Me[Re] = arguments[Re];
    var je = Oe.popResultSelector(Me), Be = ve.argsOrArgArray(Me);
    return Be.length ? new fe.Observable(function(ze) {
      var He = Be.map(function() {
        return [];
      }), qe = Be.map(function() {
        return !1;
      });
      ze.add(function() {
        He = qe = null;
      });
      for (var Ye = function(dt) {
        ye.innerFrom(Be[dt]).subscribe(xe.createOperatorSubscriber(ze, function(yt) {
          if (He[dt].push(yt), He.every(function(It) {
            return It.length;
          })) {
            var Ct = He.map(function(It) {
              return It.shift();
            });
            ze.next(je ? je.apply(void 0, ae([], oe(Ct))) : Ct), He.some(function(It, Vt) {
              return !It.length && qe[Vt];
            }) && ze.complete();
          }
        }, function() {
          qe[dt] = !0, !He[dt].length && ze.complete();
        }));
      }, pt = 0; !ze.closed && pt < Be.length; pt++)
        Ye(pt);
      return function() {
        He = qe = null;
      };
    }) : _e.EMPTY;
  }
  ne.zip = $e;
}), H3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 });
}), CA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.audit = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye(ve) {
    return oe.operate(function(_e, xe) {
      var Oe = !1, $e = null, Me = null, Re = !1, je = function() {
        if (Me == null || Me.unsubscribe(), Me = null, Oe) {
          Oe = !1;
          var ze = $e;
          $e = null, xe.next(ze);
        }
        Re && xe.complete();
      }, Be = function() {
        Me = null, Re && xe.complete();
      };
      _e.subscribe(fe.createOperatorSubscriber(xe, function(ze) {
        Oe = !0, $e = ze, Me || ae.innerFrom(ve(ze)).subscribe(Me = fe.createOperatorSubscriber(xe, je, Be));
      }, function() {
        Re = !0, (!Oe || !Me || Me.closed) && xe.complete();
      }));
    });
  }
  ne.audit = ye;
}), $3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.auditTime = void 0;
  var oe = Ti(), ae = CA(), fe = Kl();
  function ye(ve, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.audit(function() {
      return fe.timer(ve, _e);
    });
  }
  ne.auditTime = ye;
}), Y3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.buffer = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(ve) {
    return oe.operate(function(_e, xe) {
      var Oe = [];
      return _e.subscribe(fe.createOperatorSubscriber(xe, function($e) {
        return Oe.push($e);
      }, function() {
        xe.next(Oe), xe.complete();
      })), ve.subscribe(fe.createOperatorSubscriber(xe, function() {
        var $e = Oe;
        Oe = [], xe.next($e);
      }, ae.noop)), function() {
        Oe = null;
      };
    });
  }
  ne.buffer = ye;
}), G3 = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferCount = void 0;
  var ae = he(), fe = Ae(), ye = ku();
  function ve(_e, xe) {
    return xe === void 0 && (xe = null), xe = xe ?? _e, ae.operate(function(Oe, $e) {
      var Me = [], Re = 0;
      Oe.subscribe(fe.createOperatorSubscriber($e, function(je) {
        var Be, ze, He, qe, Ye = null;
        Re++ % xe === 0 && Me.push([]);
        try {
          for (var pt = oe(Me), dt = pt.next(); !dt.done; dt = pt.next()) {
            var yt = dt.value;
            yt.push(je), _e <= yt.length && (Ye = Ye ?? [], Ye.push(yt));
          }
        } catch (Vt) {
          Be = { error: Vt };
        } finally {
          try {
            dt && !dt.done && (ze = pt.return) && ze.call(pt);
          } finally {
            if (Be)
              throw Be.error;
          }
        }
        if (Ye)
          try {
            for (var Ct = oe(Ye), It = Ct.next(); !It.done; It = Ct.next()) {
              var yt = It.value;
              ye.arrRemove(Me, yt), $e.next(yt);
            }
          } catch (Vt) {
            He = { error: Vt };
          } finally {
            try {
              It && !It.done && (qe = Ct.return) && qe.call(Ct);
            } finally {
              if (He)
                throw He.error;
            }
          }
      }, function() {
        var je, Be;
        try {
          for (var ze = oe(Me), He = ze.next(); !He.done; He = ze.next()) {
            var qe = He.value;
            $e.next(qe);
          }
        } catch (Ye) {
          je = { error: Ye };
        } finally {
          try {
            He && !He.done && (Be = ze.return) && Be.call(ze);
          } finally {
            if (je)
              throw je.error;
          }
        }
        $e.complete();
      }, void 0, function() {
        Me = null;
      }));
    });
  }
  ne.bufferCount = ve;
}), K3 = M((ne) => {
  var oe = ne && ne.__values || function(Me) {
    var Re = typeof Symbol == "function" && Symbol.iterator, je = Re && Me[Re], Be = 0;
    if (je)
      return je.call(Me);
    if (Me && typeof Me.length == "number")
      return { next: function() {
        return Me && Be >= Me.length && (Me = void 0), { value: Me && Me[Be++], done: !Me };
      } };
    throw new TypeError(Re ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferTime = void 0;
  var ae = Oi(), fe = he(), ye = Ae(), ve = ku(), _e = Ti(), xe = ki(), Oe = Au();
  function $e(Me) {
    for (var Re, je, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Re = xe.popScheduler(Be)) !== null && Re !== void 0 ? Re : _e.asyncScheduler, qe = (je = Be[0]) !== null && je !== void 0 ? je : null, Ye = Be[1] || 1 / 0;
    return fe.operate(function(pt, dt) {
      var yt = [], Ct = !1, It = function(Zt) {
        var tr = Zt.buffer, er = Zt.subs;
        er.unsubscribe(), ve.arrRemove(yt, Zt), dt.next(tr), Ct && Vt();
      }, Vt = function() {
        if (yt) {
          var Zt = new ae.Subscription();
          dt.add(Zt);
          var tr = [], er = { buffer: tr, subs: Zt };
          yt.push(er), Oe.executeSchedule(Zt, He, function() {
            return It(er);
          }, Me);
        }
      };
      qe !== null && qe >= 0 ? Oe.executeSchedule(dt, He, Vt, qe, !0) : Ct = !0, Vt();
      var Ut = ye.createOperatorSubscriber(dt, function(Zt) {
        var tr, er, hr = yt.slice();
        try {
          for (var Ot = oe(hr), Qe = Ot.next(); !Qe.done; Qe = Ot.next()) {
            var at = Qe.value, wt = at.buffer;
            wt.push(Zt), Ye <= wt.length && It(at);
          }
        } catch (bt) {
          tr = { error: bt };
        } finally {
          try {
            Qe && !Qe.done && (er = Ot.return) && er.call(Ot);
          } finally {
            if (tr)
              throw tr.error;
          }
        }
      }, function() {
        for (; yt != null && yt.length; )
          dt.next(yt.shift().buffer);
        Ut == null || Ut.unsubscribe(), dt.complete(), dt.unsubscribe();
      }, void 0, function() {
        return yt = null;
      });
      pt.subscribe(Ut);
    });
  }
  ne.bufferTime = $e;
}), Z3 = M((ne) => {
  var oe = ne && ne.__values || function($e) {
    var Me = typeof Symbol == "function" && Symbol.iterator, Re = Me && $e[Me], je = 0;
    if (Re)
      return Re.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && je >= $e.length && ($e = void 0), { value: $e && $e[je++], done: !$e };
      } };
    throw new TypeError(Me ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferToggle = void 0;
  var ae = Oi(), fe = he(), ye = _t(), ve = Ae(), _e = On(), xe = ku();
  function Oe($e, Me) {
    return fe.operate(function(Re, je) {
      var Be = [];
      ye.innerFrom($e).subscribe(ve.createOperatorSubscriber(je, function(ze) {
        var He = [];
        Be.push(He);
        var qe = new ae.Subscription(), Ye = function() {
          xe.arrRemove(Be, He), je.next(He), qe.unsubscribe();
        };
        qe.add(ye.innerFrom(Me(ze)).subscribe(ve.createOperatorSubscriber(je, Ye, _e.noop)));
      }, _e.noop)), Re.subscribe(ve.createOperatorSubscriber(je, function(ze) {
        var He, qe;
        try {
          for (var Ye = oe(Be), pt = Ye.next(); !pt.done; pt = Ye.next()) {
            var dt = pt.value;
            dt.push(ze);
          }
        } catch (yt) {
          He = { error: yt };
        } finally {
          try {
            pt && !pt.done && (qe = Ye.return) && qe.call(Ye);
          } finally {
            if (He)
              throw He.error;
          }
        }
      }, function() {
        for (; Be.length > 0; )
          je.next(Be.shift());
        je.complete();
      }));
    });
  }
  ne.bufferToggle = Oe;
}), tB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferWhen = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function ve(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = null, Me = null, Re = function() {
        Me == null || Me.unsubscribe();
        var je = $e;
        $e = [], je && Oe.next(je), ye.innerFrom(_e()).subscribe(Me = fe.createOperatorSubscriber(Oe, Re, ae.noop));
      };
      Re(), xe.subscribe(fe.createOperatorSubscriber(Oe, function(je) {
        return $e == null ? void 0 : $e.push(je);
      }, function() {
        $e && Oe.next($e), Oe.complete();
      }, void 0, function() {
        return $e = Me = null;
      }));
    });
  }
  ne.bufferWhen = ve;
}), nB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.catchError = void 0;
  var oe = _t(), ae = Ae(), fe = he();
  function ye(ve) {
    return fe.operate(function(_e, xe) {
      var Oe = null, $e = !1, Me;
      Oe = _e.subscribe(ae.createOperatorSubscriber(xe, void 0, void 0, function(Re) {
        Me = oe.innerFrom(ve(Re, ye(ve)(_e))), Oe ? (Oe.unsubscribe(), Oe = null, Me.subscribe(xe)) : $e = !0;
      })), $e && (Oe.unsubscribe(), Oe = null, Me.subscribe(xe));
    });
  }
  ne.catchError = ye;
}), TA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scanInternals = void 0;
  var oe = Ae();
  function ae(fe, ye, ve, _e, xe) {
    return function(Oe, $e) {
      var Me = ve, Re = ye, je = 0;
      Oe.subscribe(oe.createOperatorSubscriber($e, function(Be) {
        var ze = je++;
        Re = Me ? fe(Re, Be, ze) : (Me = !0, Be), _e && $e.next(Re);
      }, xe && function() {
        Me && $e.next(Re), $e.complete();
      }));
    };
  }
  ne.scanInternals = ae;
}), Qd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reduce = void 0;
  var oe = TA(), ae = he();
  function fe(ye, ve) {
    return ae.operate(oe.scanInternals(ye, ve, arguments.length >= 2, !1, !0));
  }
  ne.reduce = fe;
}), kA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.toArray = void 0;
  var oe = Qd(), ae = he(), fe = function(ve, _e) {
    return ve.push(_e), ve;
  };
  function ye() {
    return ae.operate(function(ve, _e) {
      oe.reduce(fe, [])(ve).subscribe(_e);
    });
  }
  ne.toArray = ye;
}), AA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.joinAllInternals = void 0;
  var oe = Hn(), ae = Gl(), fe = lh(), ye = Mu(), ve = kA();
  function _e(xe, Oe) {
    return fe.pipe(ve.toArray(), ye.mergeMap(function($e) {
      return xe($e);
    }), Oe ? ae.mapOneOrManyArgs(Oe) : oe.identity);
  }
  ne.joinAllInternals = _e;
}), PA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestAll = void 0;
  var oe = WS(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.combineLatest, ye);
  }
  ne.combineLatestAll = fe;
}), iB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineAll = void 0;
  var oe = PA();
  ne.combineAll = oe.combineLatestAll;
}), lB = M((ne) => {
  var oe = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatest = void 0;
  var fe = WS(), ye = he(), ve = Sc(), _e = Gl(), xe = lh(), Oe = ki();
  function $e() {
    for (var Me = [], Re = 0; Re < arguments.length; Re++)
      Me[Re] = arguments[Re];
    var je = Oe.popResultSelector(Me);
    return je ? xe.pipe($e.apply(void 0, ae([], oe(Me))), _e.mapOneOrManyArgs(je)) : ye.operate(function(Be, ze) {
      fe.combineLatestInit(ae([Be], oe(ve.argsOrArgArray(Me))))(ze);
    });
  }
  ne.combineLatest = $e;
}), sB = M((ne) => {
  var oe = ne && ne.__read || function(ve, _e) {
    var xe = typeof Symbol == "function" && ve[Symbol.iterator];
    if (!xe)
      return ve;
    var Oe = xe.call(ve), $e, Me = [], Re;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Me.push($e.value);
    } catch (je) {
      Re = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Re)
          throw Re.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(ve, _e) {
    for (var xe = 0, Oe = _e.length, $e = ve.length; xe < Oe; xe++, $e++)
      ve[$e] = _e[xe];
    return ve;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestWith = void 0;
  var fe = lB();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return fe.combineLatest.apply(void 0, ae([], oe(ve)));
  }
  ne.combineLatestWith = ye;
}), MA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMap = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, ve) {
    return ae.isFunction(ve) ? oe.mergeMap(ye, ve, 1) : oe.mergeMap(ye, 1);
  }
  ne.concatMap = fe;
}), dB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMapTo = void 0;
  var oe = MA(), ae = Mt();
  function fe(ye, ve) {
    return ae.isFunction(ve) ? oe.concatMap(function() {
      return ye;
    }, ve) : oe.concatMap(function() {
      return ye;
    });
  }
  ne.concatMapTo = fe;
}), pB = M((ne) => {
  var oe = ne && ne.__read || function(Oe, $e) {
    var Me = typeof Symbol == "function" && Oe[Symbol.iterator];
    if (!Me)
      return Oe;
    var Re = Me.call(Oe), je, Be = [], ze;
    try {
      for (; ($e === void 0 || $e-- > 0) && !(je = Re.next()).done; )
        Be.push(je.value);
    } catch (He) {
      ze = { error: He };
    } finally {
      try {
        je && !je.done && (Me = Re.return) && Me.call(Re);
      } finally {
        if (ze)
          throw ze.error;
      }
    }
    return Be;
  }, ae = ne && ne.__spreadArray || function(Oe, $e) {
    for (var Me = 0, Re = $e.length, je = Oe.length; Me < Re; Me++, je++)
      Oe[je] = $e[Me];
    return Oe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var fe = he(), ye = JS(), ve = ki(), _e = Ja();
  function xe() {
    for (var Oe = [], $e = 0; $e < arguments.length; $e++)
      Oe[$e] = arguments[$e];
    var Me = ve.popScheduler(Oe);
    return fe.operate(function(Re, je) {
      ye.concatAll()(_e.from(ae([Re], oe(Oe)), Me)).subscribe(je);
    });
  }
  ne.concat = xe;
}), vB = M((ne) => {
  var oe = ne && ne.__read || function(ve, _e) {
    var xe = typeof Symbol == "function" && ve[Symbol.iterator];
    if (!xe)
      return ve;
    var Oe = xe.call(ve), $e, Me = [], Re;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Me.push($e.value);
    } catch (je) {
      Re = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Re)
          throw Re.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(ve, _e) {
    for (var xe = 0, Oe = _e.length, $e = ve.length; xe < Oe; xe++, $e++)
      ve[$e] = _e[xe];
    return ve;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatWith = void 0;
  var fe = pB();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return fe.concat.apply(void 0, ae([], oe(ve)));
  }
  ne.concatWith = ye;
}), mB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromSubscribable = void 0;
  var oe = qt();
  function ae(fe) {
    return new oe.Observable(function(ye) {
      return fe.subscribe(ye);
    });
  }
  ne.fromSubscribable = ae;
}), M_ = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connect = void 0;
  var oe = Tn(), ae = Ja(), fe = he(), ye = mB(), ve = { connector: function() {
    return new oe.Subject();
  } };
  function _e(xe, Oe) {
    Oe === void 0 && (Oe = ve);
    var $e = Oe.connector;
    return fe.operate(function(Me, Re) {
      var je = $e();
      ae.from(xe(ye.fromSubscribable(je))).subscribe(Re), Re.add(Me.subscribe(je));
    });
  }
  ne.connect = _e;
}), hB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.count = void 0;
  var oe = Qd();
  function ae(fe) {
    return oe.reduce(function(ye, ve, _e) {
      return !fe || fe(ve, _e) ? ye + 1 : ye;
    }, 0);
  }
  ne.count = ae;
}), gB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounce = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function ve(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = !1, Me = null, Re = null, je = function() {
        if (Re == null || Re.unsubscribe(), Re = null, $e) {
          $e = !1;
          var Be = Me;
          Me = null, Oe.next(Be);
        }
      };
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        Re == null || Re.unsubscribe(), $e = !0, Me = Be, Re = fe.createOperatorSubscriber(Oe, je, ae.noop), ye.innerFrom(_e(Be)).subscribe(Re);
      }, function() {
        je(), Oe.complete();
      }, void 0, function() {
        Me = Re = null;
      }));
    });
  }
  ne.debounce = ve;
}), bB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounceTime = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(ve, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.operate(function(xe, Oe) {
      var $e = null, Me = null, Re = null, je = function() {
        if ($e) {
          $e.unsubscribe(), $e = null;
          var ze = Me;
          Me = null, Oe.next(ze);
        }
      };
      function Be() {
        var ze = Re + ve, He = _e.now();
        if (He < ze) {
          $e = this.schedule(void 0, ze - He), Oe.add($e);
          return;
        }
        je();
      }
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(ze) {
        Me = ze, Re = _e.now(), $e || ($e = _e.schedule(Be, ve), Oe.add($e));
      }, function() {
        je(), Oe.complete();
      }, void 0, function() {
        Me = $e = null;
      }));
    });
  }
  ne.debounceTime = ye;
}), gh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defaultIfEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(ve, _e) {
      var xe = !1;
      ve.subscribe(ae.createOperatorSubscriber(_e, function(Oe) {
        xe = !0, _e.next(Oe);
      }, function() {
        xe || _e.next(ye), _e.complete();
      }));
    });
  }
  ne.defaultIfEmpty = fe;
}), Kd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.take = void 0;
  var oe = ba(), ae = he(), fe = Ae();
  function ye(ve) {
    return ve <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(fe.createOperatorSubscriber(xe, function($e) {
        ++Oe <= ve && (xe.next($e), ve <= Oe && xe.complete());
      }));
    });
  }
  ne.take = ye;
}), DA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ignoreElements = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye() {
    return oe.operate(function(ve, _e) {
      ve.subscribe(ae.createOperatorSubscriber(_e, fe.noop));
    });
  }
  ne.ignoreElements = ye;
}), NA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapTo = void 0;
  var oe = Wl();
  function ae(fe) {
    return oe.map(function() {
      return fe;
    });
  }
  ne.mapTo = ae;
}), LA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delayWhen = void 0;
  var oe = hh(), ae = Kd(), fe = DA(), ye = NA(), ve = Mu();
  function _e(xe, Oe) {
    return Oe ? function($e) {
      return oe.concat(Oe.pipe(ae.take(1), fe.ignoreElements()), $e.pipe(_e(xe)));
    } : ve.mergeMap(function($e, Me) {
      return xe($e, Me).pipe(ae.take(1), ye.mapTo($e));
    });
  }
  ne.delayWhen = _e;
}), wB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delay = void 0;
  var oe = Ti(), ae = LA(), fe = Kl();
  function ye(ve, _e) {
    _e === void 0 && (_e = oe.asyncScheduler);
    var xe = fe.timer(ve, _e);
    return ae.delayWhen(function() {
      return xe;
    });
  }
  ne.delay = ye;
}), xB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dematerialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(ve, _e) {
      ve.subscribe(fe.createOperatorSubscriber(_e, function(xe) {
        return oe.observeNotification(xe, _e);
      }));
    });
  }
  ne.dematerialize = ye;
}), CB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinct = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye(ve, _e) {
    return oe.operate(function(xe, Oe) {
      var $e = /* @__PURE__ */ new Set();
      xe.subscribe(ae.createOperatorSubscriber(Oe, function(Me) {
        var Re = ve ? ve(Me) : Me;
        $e.has(Re) || ($e.add(Re), Oe.next(Me));
      })), _e == null || _e.subscribe(ae.createOperatorSubscriber(Oe, function() {
        return $e.clear();
      }, fe.noop));
    });
  }
  ne.distinct = ye;
}), jA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilChanged = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(_e, xe) {
    return xe === void 0 && (xe = oe.identity), _e = _e ?? ve, ae.operate(function(Oe, $e) {
      var Me, Re = !0;
      Oe.subscribe(fe.createOperatorSubscriber($e, function(je) {
        var Be = xe(je);
        (Re || !_e(Me, Be)) && (Re = !1, Me = Be, $e.next(je));
      }));
    });
  }
  ne.distinctUntilChanged = ye;
  function ve(_e, xe) {
    return _e === xe;
  }
}), RB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilKeyChanged = void 0;
  var oe = jA();
  function ae(fe, ye) {
    return oe.distinctUntilChanged(function(ve, _e) {
      return ye ? ye(ve[fe], _e[fe]) : ve[fe] === _e[fe];
    });
  }
  ne.distinctUntilKeyChanged = ae;
}), bh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwIfEmpty = void 0;
  var oe = $l(), ae = he(), fe = Ae();
  function ye(_e) {
    return _e === void 0 && (_e = ve), ae.operate(function(xe, Oe) {
      var $e = !1;
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Me) {
        $e = !0, Oe.next(Me);
      }, function() {
        return $e ? Oe.complete() : Oe.error(_e());
      }));
    });
  }
  ne.throwIfEmpty = ye;
  function ve() {
    return new oe.EmptyError();
  }
}), TB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.elementAt = void 0;
  var oe = vA(), ae = _c(), fe = bh(), ye = gh(), ve = Kd();
  function _e(xe, Oe) {
    if (xe < 0)
      throw new oe.ArgumentOutOfRangeError();
    var $e = arguments.length >= 2;
    return function(Me) {
      return Me.pipe(ae.filter(function(Re, je) {
        return je === xe;
      }), ve.take(1), $e ? ye.defaultIfEmpty(Oe) : fe.throwIfEmpty(function() {
        return new oe.ArgumentOutOfRangeError();
      }));
    };
  }
  ne.elementAt = _e;
}), kB = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Me, Re = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Me = $e.next()).done; )
        Re.push(Me.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Me && !Me.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Me = _e.length; Oe < $e; Oe++, Me++)
      _e[Me] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.endWith = void 0;
  var fe = hh(), ye = TS();
  function ve() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    return function(Oe) {
      return fe.concat(Oe, ye.of.apply(void 0, ae([], oe(_e))));
    };
  }
  ne.endWith = ve;
}), AB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.every = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ve) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        ye.call(ve, $e, Oe++, _e) || (xe.next(!1), xe.complete());
      }, function() {
        xe.next(!0), xe.complete();
      }));
    });
  }
  ne.every = fe;
}), UA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustAll = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye() {
    return oe.operate(function(ve, _e) {
      var xe = !1, Oe = null;
      ve.subscribe(fe.createOperatorSubscriber(_e, function($e) {
        Oe || (Oe = ae.innerFrom($e).subscribe(fe.createOperatorSubscriber(_e, void 0, function() {
          Oe = null, xe && _e.complete();
        })));
      }, function() {
        xe = !0, !Oe && _e.complete();
      }));
    });
  }
  ne.exhaustAll = ye;
}), MB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaust = void 0;
  var oe = UA();
  ne.exhaust = oe.exhaustAll;
}), jB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = Ae();
  function ve(_e, xe) {
    return xe ? function(Oe) {
      return Oe.pipe(ve(function($e, Me) {
        return ae.innerFrom(_e($e, Me)).pipe(oe.map(function(Re, je) {
          return xe($e, Re, Me, je);
        }));
      }));
    } : fe.operate(function(Oe, $e) {
      var Me = 0, Re = null, je = !1;
      Oe.subscribe(ye.createOperatorSubscriber($e, function(Be) {
        Re || (Re = ye.createOperatorSubscriber($e, void 0, function() {
          Re = null, je && $e.complete();
        }), ae.innerFrom(_e(Be, Me++)).subscribe(Re));
      }, function() {
        je = !0, !Re && $e.complete();
      }));
    });
  }
  ne.exhaustMap = ve;
}), UB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.expand = void 0;
  var oe = he(), ae = GS();
  function fe(ye, ve, _e) {
    return ve === void 0 && (ve = 1 / 0), ve = (ve || 0) < 1 ? 1 / 0 : ve, oe.operate(function(xe, Oe) {
      return ae.mergeInternals(xe, Oe, ye, ve, void 0, !0, _e);
    });
  }
  ne.expand = fe;
}), FB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.finalize = void 0;
  var oe = he();
  function ae(fe) {
    return oe.operate(function(ye, ve) {
      try {
        ye.subscribe(ve);
      } finally {
        ve.add(fe);
      }
    });
  }
  ne.finalize = ae;
}), FA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createFind = ne.find = void 0;
  var oe = he(), ae = Ae();
  function fe(ve, _e) {
    return oe.operate(ye(ve, _e, "value"));
  }
  ne.find = fe;
  function ye(ve, _e, xe) {
    var Oe = xe === "index";
    return function($e, Me) {
      var Re = 0;
      $e.subscribe(ae.createOperatorSubscriber(Me, function(je) {
        var Be = Re++;
        ve.call(_e, je, Be, $e) && (Me.next(Oe ? Be : je), Me.complete());
      }, function() {
        Me.next(Oe ? -1 : void 0), Me.complete();
      }));
    };
  }
  ne.createFind = ye;
}), qB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.findIndex = void 0;
  var oe = he(), ae = FA();
  function fe(ye, ve) {
    return oe.operate(ae.createFind(ye, ve, "index"));
  }
  ne.findIndex = fe;
}), IB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.first = void 0;
  var oe = $l(), ae = _c(), fe = Kd(), ye = gh(), ve = bh(), _e = Hn();
  function xe(Oe, $e) {
    var Me = arguments.length >= 2;
    return function(Re) {
      return Re.pipe(Oe ? ae.filter(function(je, Be) {
        return Oe(je, Be, Re);
      }) : _e.identity, fe.take(1), Me ? ye.defaultIfEmpty($e) : ve.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.first = xe;
}), HB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.groupBy = void 0;
  var oe = qt(), ae = _t(), fe = Tn(), ye = he(), ve = Ae();
  function _e(xe, Oe, $e, Me) {
    return ye.operate(function(Re, je) {
      var Be;
      !Oe || typeof Oe == "function" ? Be = Oe : ($e = Oe.duration, Be = Oe.element, Me = Oe.connector);
      var ze = /* @__PURE__ */ new Map(), He = function(Ct) {
        ze.forEach(Ct), Ct(je);
      }, qe = function(Ct) {
        return He(function(It) {
          return It.error(Ct);
        });
      }, Ye = 0, pt = !1, dt = new ve.OperatorSubscriber(je, function(Ct) {
        try {
          var It = xe(Ct), Vt = ze.get(It);
          if (!Vt) {
            ze.set(It, Vt = Me ? Me() : new fe.Subject());
            var Ut = yt(It, Vt);
            if (je.next(Ut), $e) {
              var Zt = ve.createOperatorSubscriber(Vt, function() {
                Vt.complete(), Zt == null || Zt.unsubscribe();
              }, void 0, void 0, function() {
                return ze.delete(It);
              });
              dt.add(ae.innerFrom($e(Ut)).subscribe(Zt));
            }
          }
          Vt.next(Be ? Be(Ct) : Ct);
        } catch (tr) {
          qe(tr);
        }
      }, function() {
        return He(function(Ct) {
          return Ct.complete();
        });
      }, qe, function() {
        return ze.clear();
      }, function() {
        return pt = !0, Ye === 0;
      });
      Re.subscribe(dt);
      function yt(Ct, It) {
        var Vt = new oe.Observable(function(Ut) {
          Ye++;
          var Zt = It.subscribe(Ut);
          return function() {
            Zt.unsubscribe(), --Ye === 0 && pt && dt.unsubscribe();
          };
        });
        return Vt.key = Ct, Vt;
      }
    });
  }
  ne.groupBy = _e;
}), VB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ve) {
      ye.subscribe(ae.createOperatorSubscriber(ve, function() {
        ve.next(!1), ve.complete();
      }, function() {
        ve.next(!0), ve.complete();
      }));
    });
  }
  ne.isEmpty = fe;
}), zA = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeLast = void 0;
  var ae = ba(), fe = he(), ye = Ae();
  function ve(_e) {
    return _e <= 0 ? function() {
      return ae.EMPTY;
    } : fe.operate(function(xe, Oe) {
      var $e = [];
      xe.subscribe(ye.createOperatorSubscriber(Oe, function(Me) {
        $e.push(Me), _e < $e.length && $e.shift();
      }, function() {
        var Me, Re;
        try {
          for (var je = oe($e), Be = je.next(); !Be.done; Be = je.next()) {
            var ze = Be.value;
            Oe.next(ze);
          }
        } catch (He) {
          Me = { error: He };
        } finally {
          try {
            Be && !Be.done && (Re = je.return) && Re.call(je);
          } finally {
            if (Me)
              throw Me.error;
          }
        }
        Oe.complete();
      }, void 0, function() {
        $e = null;
      }));
    });
  }
  ne.takeLast = ve;
}), $B = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.last = void 0;
  var oe = $l(), ae = _c(), fe = zA(), ye = bh(), ve = gh(), _e = Hn();
  function xe(Oe, $e) {
    var Me = arguments.length >= 2;
    return function(Re) {
      return Re.pipe(Oe ? ae.filter(function(je, Be) {
        return Oe(je, Be, Re);
      }) : _e.identity, fe.takeLast(1), Me ? ve.defaultIfEmpty($e) : ye.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.last = xe;
}), WB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.materialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(ve, _e) {
      ve.subscribe(fe.createOperatorSubscriber(_e, function(xe) {
        _e.next(oe.Notification.createNext(xe));
      }, function() {
        _e.next(oe.Notification.createComplete()), _e.complete();
      }, function(xe) {
        _e.next(oe.Notification.createError(xe)), _e.complete();
      }));
    });
  }
  ne.materialize = ye;
}), YB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.max = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(ve, _e) {
      return ye(ve, _e) > 0 ? ve : _e;
    } : function(ve, _e) {
      return ve > _e ? ve : _e;
    });
  }
  ne.max = fe;
}), GB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.flatMap = void 0;
  var oe = Mu();
  ne.flatMap = oe.mergeMap;
}), KB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMapTo = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, ve, _e) {
    return _e === void 0 && (_e = 1 / 0), ae.isFunction(ve) ? oe.mergeMap(function() {
      return ye;
    }, ve, _e) : (typeof ve == "number" && (_e = ve), oe.mergeMap(function() {
      return ye;
    }, _e));
  }
  ne.mergeMapTo = fe;
}), XB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeScan = void 0;
  var oe = he(), ae = GS();
  function fe(ye, ve, _e) {
    return _e === void 0 && (_e = 1 / 0), oe.operate(function(xe, Oe) {
      var $e = ve;
      return ae.mergeInternals(xe, Oe, function(Me, Re) {
        return ye($e, Me, Re);
      }, _e, function(Me) {
        $e = Me;
      }, !1, void 0, function() {
        return $e = null;
      });
    });
  }
  ne.mergeScan = fe;
}), ZB = M((ne) => {
  var oe = ne && ne.__read || function($e, Me) {
    var Re = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Re)
      return $e;
    var je = Re.call($e), Be, ze = [], He;
    try {
      for (; (Me === void 0 || Me-- > 0) && !(Be = je.next()).done; )
        ze.push(Be.value);
    } catch (qe) {
      He = { error: qe };
    } finally {
      try {
        Be && !Be.done && (Re = je.return) && Re.call(je);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function($e, Me) {
    for (var Re = 0, je = Me.length, Be = $e.length; Re < je; Re++, Be++)
      $e[Be] = Me[Re];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var fe = he(), ye = Sc(), ve = mh(), _e = ki(), xe = Ja();
  function Oe() {
    for (var $e = [], Me = 0; Me < arguments.length; Me++)
      $e[Me] = arguments[Me];
    var Re = _e.popScheduler($e), je = _e.popNumber($e, 1 / 0);
    return $e = ye.argsOrArgArray($e), fe.operate(function(Be, ze) {
      ve.mergeAll(je)(xe.from(ae([Be], oe($e)), Re)).subscribe(ze);
    });
  }
  ne.merge = Oe;
}), eH = M((ne) => {
  var oe = ne && ne.__read || function(ve, _e) {
    var xe = typeof Symbol == "function" && ve[Symbol.iterator];
    if (!xe)
      return ve;
    var Oe = xe.call(ve), $e, Me = [], Re;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Me.push($e.value);
    } catch (je) {
      Re = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Re)
          throw Re.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(ve, _e) {
    for (var xe = 0, Oe = _e.length, $e = ve.length; xe < Oe; xe++, $e++)
      ve[$e] = _e[xe];
    return ve;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeWith = void 0;
  var fe = ZB();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return fe.merge.apply(void 0, ae([], oe(ve)));
  }
  ne.mergeWith = ye;
}), tH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.min = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(ve, _e) {
      return ye(ve, _e) < 0 ? ve : _e;
    } : function(ve, _e) {
      return ve < _e ? ve : _e;
    });
  }
  ne.min = fe;
}), dw = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.multicast = void 0;
  var oe = sh(), ae = Mt(), fe = M_();
  function ye(ve, _e) {
    var xe = ae.isFunction(ve) ? ve : function() {
      return ve;
    };
    return ae.isFunction(_e) ? fe.connect(_e, { connector: xe }) : function(Oe) {
      return new oe.ConnectableObservable(Oe, xe);
    };
  }
  ne.multicast = ye;
}), nH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairwise = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ve) {
      var _e, xe = !1;
      ye.subscribe(ae.createOperatorSubscriber(ve, function(Oe) {
        var $e = _e;
        _e = Oe, xe && ve.next([$e, Oe]), xe = !0;
      }));
    });
  }
  ne.pairwise = fe;
}), iH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pluck = void 0;
  var oe = Wl();
  function ae() {
    for (var fe = [], ye = 0; ye < arguments.length; ye++)
      fe[ye] = arguments[ye];
    var ve = fe.length;
    if (ve === 0)
      throw new Error("list of properties cannot be empty.");
    return oe.map(function(_e) {
      for (var xe = _e, Oe = 0; Oe < ve; Oe++) {
        var $e = xe == null ? void 0 : xe[fe[Oe]];
        if (typeof $e < "u")
          xe = $e;
        else
          return;
      }
      return xe;
    });
  }
  ne.pluck = ae;
}), aH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publish = void 0;
  var oe = Tn(), ae = dw(), fe = M_();
  function ye(ve) {
    return ve ? function(_e) {
      return fe.connect(ve)(_e);
    } : function(_e) {
      return ae.multicast(new oe.Subject())(_e);
    };
  }
  ne.publish = ye;
}), oH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishBehavior = void 0;
  var oe = Xk(), ae = sh();
  function fe(ye) {
    return function(ve) {
      var _e = new oe.BehaviorSubject(ye);
      return new ae.ConnectableObservable(ve, function() {
        return _e;
      });
    };
  }
  ne.publishBehavior = fe;
}), uH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishLast = void 0;
  var oe = iS(), ae = sh();
  function fe() {
    return function(ye) {
      var ve = new oe.AsyncSubject();
      return new ae.ConnectableObservable(ye, function() {
        return ve;
      });
    };
  }
  ne.publishLast = fe;
}), sH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishReplay = void 0;
  var oe = nS(), ae = dw(), fe = Mt();
  function ye(ve, _e, xe, Oe) {
    xe && !fe.isFunction(xe) && (Oe = xe);
    var $e = fe.isFunction(xe) ? xe : void 0;
    return function(Me) {
      return ae.multicast(new oe.ReplaySubject(ve, _e, Oe), $e)(Me);
    };
  }
  ne.publishReplay = ye;
}), cH = M((ne) => {
  var oe = ne && ne.__read || function(xe, Oe) {
    var $e = typeof Symbol == "function" && xe[Symbol.iterator];
    if (!$e)
      return xe;
    var Me = $e.call(xe), Re, je = [], Be;
    try {
      for (; (Oe === void 0 || Oe-- > 0) && !(Re = Me.next()).done; )
        je.push(Re.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Re && !Re.done && ($e = Me.return) && $e.call(Me);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return je;
  }, ae = ne && ne.__spreadArray || function(xe, Oe) {
    for (var $e = 0, Me = Oe.length, Re = xe.length; $e < Me; $e++, Re++)
      xe[Re] = Oe[$e];
    return xe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceWith = void 0;
  var fe = EA(), ye = he(), ve = Hn();
  function _e() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    return xe.length ? ye.operate(function($e, Me) {
      fe.raceInit(ae([$e], oe(xe)))(Me);
    }) : ve.identity;
  }
  ne.raceWith = _e;
}), dH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeat = void 0;
  var oe = ba(), ae = he(), fe = Ae(), ye = _t(), ve = Kl();
  function _e(xe) {
    var Oe, $e = 1 / 0, Me;
    return xe != null && (typeof xe == "object" ? (Oe = xe.count, $e = Oe === void 0 ? 1 / 0 : Oe, Me = xe.delay) : $e = xe), $e <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(Re, je) {
      var Be = 0, ze, He = function() {
        if (ze == null || ze.unsubscribe(), ze = null, Me != null) {
          var Ye = typeof Me == "number" ? ve.timer(Me) : ye.innerFrom(Me(Be)), pt = fe.createOperatorSubscriber(je, function() {
            pt.unsubscribe(), qe();
          });
          Ye.subscribe(pt);
        } else
          qe();
      }, qe = function() {
        var Ye = !1;
        ze = Re.subscribe(fe.createOperatorSubscriber(je, void 0, function() {
          ++Be < $e ? ze ? He() : Ye = !0 : je.complete();
        })), Ye && He();
      };
      qe();
    });
  }
  ne.repeat = _e;
}), vH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeatWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(ve) {
    return ae.operate(function(_e, xe) {
      var Oe, $e = !1, Me, Re = !1, je = !1, Be = function() {
        return je && Re && (xe.complete(), !0);
      }, ze = function() {
        return Me || (Me = new oe.Subject(), ve(Me).subscribe(fe.createOperatorSubscriber(xe, function() {
          Oe ? He() : $e = !0;
        }, function() {
          Re = !0, Be();
        }))), Me;
      }, He = function() {
        je = !1, Oe = _e.subscribe(fe.createOperatorSubscriber(xe, void 0, function() {
          je = !0, !Be() && ze().next();
        })), $e && (Oe.unsubscribe(), Oe = null, $e = !1, He());
      };
      He();
    });
  }
  ne.repeatWhen = ye;
}), hH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retry = void 0;
  var oe = he(), ae = Ae(), fe = Hn(), ye = Kl(), ve = _t();
  function _e(xe) {
    xe === void 0 && (xe = 1 / 0);
    var Oe;
    xe && typeof xe == "object" ? Oe = xe : Oe = { count: xe };
    var $e = Oe.count, Me = $e === void 0 ? 1 / 0 : $e, Re = Oe.delay, je = Oe.resetOnSuccess, Be = je === void 0 ? !1 : je;
    return Me <= 0 ? fe.identity : oe.operate(function(ze, He) {
      var qe = 0, Ye, pt = function() {
        var dt = !1;
        Ye = ze.subscribe(ae.createOperatorSubscriber(He, function(yt) {
          Be && (qe = 0), He.next(yt);
        }, void 0, function(yt) {
          if (qe++ < Me) {
            var Ct = function() {
              Ye ? (Ye.unsubscribe(), Ye = null, pt()) : dt = !0;
            };
            if (Re != null) {
              var It = typeof Re == "number" ? ye.timer(Re) : ve.innerFrom(Re(yt, qe)), Vt = ae.createOperatorSubscriber(He, function() {
                Vt.unsubscribe(), Ct();
              }, function() {
                He.complete();
              });
              It.subscribe(Vt);
            } else
              Ct();
          } else
            He.error(yt);
        })), dt && (Ye.unsubscribe(), Ye = null, pt());
      };
      pt();
    });
  }
  ne.retry = _e;
}), gH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retryWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(ve) {
    return ae.operate(function(_e, xe) {
      var Oe, $e = !1, Me, Re = function() {
        Oe = _e.subscribe(fe.createOperatorSubscriber(xe, void 0, void 0, function(je) {
          Me || (Me = new oe.Subject(), ve(Me).subscribe(fe.createOperatorSubscriber(xe, function() {
            return Oe ? Re() : $e = !0;
          }))), Me && Me.next(je);
        })), $e && (Oe.unsubscribe(), Oe = null, $e = !1, Re());
      };
      Re();
    });
  }
  ne.retryWhen = ye;
}), IA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sample = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(ve) {
    return oe.operate(function(_e, xe) {
      var Oe = !1, $e = null;
      _e.subscribe(fe.createOperatorSubscriber(xe, function(Me) {
        Oe = !0, $e = Me;
      })), ve.subscribe(fe.createOperatorSubscriber(xe, function() {
        if (Oe) {
          Oe = !1;
          var Me = $e;
          $e = null, xe.next(Me);
        }
      }, ae.noop));
    });
  }
  ne.sample = ye;
}), SH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sampleTime = void 0;
  var oe = Ti(), ae = IA(), fe = wA();
  function ye(ve, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.sample(fe.interval(ve, _e));
  }
  ne.sampleTime = ye;
}), _H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scan = void 0;
  var oe = he(), ae = TA();
  function fe(ye, ve) {
    return oe.operate(ae.scanInternals(ye, ve, arguments.length >= 2, !0));
  }
  ne.scan = fe;
}), xH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sequenceEqual = void 0;
  var oe = he(), ae = Ae();
  function fe(ve, _e) {
    return _e === void 0 && (_e = function(xe, Oe) {
      return xe === Oe;
    }), oe.operate(function(xe, Oe) {
      var $e = ye(), Me = ye(), Re = function(Be) {
        Oe.next(Be), Oe.complete();
      }, je = function(Be, ze) {
        var He = ae.createOperatorSubscriber(Oe, function(qe) {
          var Ye = ze.buffer, pt = ze.complete;
          Ye.length === 0 ? pt ? Re(!1) : Be.buffer.push(qe) : !_e(qe, Ye.shift()) && Re(!1);
        }, function() {
          Be.complete = !0;
          var qe = ze.complete, Ye = ze.buffer;
          qe && Re(Ye.length === 0), He == null || He.unsubscribe();
        });
        return He;
      };
      xe.subscribe(je($e, Me)), ve.subscribe(je(Me, $e));
    });
  }
  ne.sequenceEqual = fe;
  function ye() {
    return { buffer: [], complete: !1 };
  }
}), HA = M((ne) => {
  var oe = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.share = void 0;
  var fe = Ja(), ye = Kd(), ve = Tn(), _e = Sd(), xe = he();
  function Oe(Me) {
    Me === void 0 && (Me = {});
    var Re = Me.connector, je = Re === void 0 ? function() {
      return new ve.Subject();
    } : Re, Be = Me.resetOnError, ze = Be === void 0 ? !0 : Be, He = Me.resetOnComplete, qe = He === void 0 ? !0 : He, Ye = Me.resetOnRefCountZero, pt = Ye === void 0 ? !0 : Ye;
    return function(dt) {
      var yt = null, Ct = null, It = null, Vt = 0, Ut = !1, Zt = !1, tr = function() {
        Ct == null || Ct.unsubscribe(), Ct = null;
      }, er = function() {
        tr(), yt = It = null, Ut = Zt = !1;
      }, hr = function() {
        var Ot = yt;
        er(), Ot == null || Ot.unsubscribe();
      };
      return xe.operate(function(Ot, Qe) {
        Vt++, !Zt && !Ut && tr();
        var at = It = It ?? je();
        Qe.add(function() {
          Vt--, Vt === 0 && !Zt && !Ut && (Ct = $e(hr, pt));
        }), at.subscribe(Qe), yt || (yt = new _e.SafeSubscriber({ next: function(wt) {
          return at.next(wt);
        }, error: function(wt) {
          Zt = !0, tr(), Ct = $e(er, ze, wt), at.error(wt);
        }, complete: function() {
          Ut = !0, tr(), Ct = $e(er, qe), at.complete();
        } }), fe.from(Ot).subscribe(yt));
      })(dt);
    };
  }
  ne.share = Oe;
  function $e(Me, Re) {
    for (var je = [], Be = 2; Be < arguments.length; Be++)
      je[Be - 2] = arguments[Be];
    return Re === !0 ? (Me(), null) : Re === !1 ? null : Re.apply(void 0, ae([], oe(je))).pipe(ye.take(1)).subscribe(function() {
      return Me();
    });
  }
}), EH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.shareReplay = void 0;
  var oe = nS(), ae = HA();
  function fe(ye, ve, _e) {
    var xe, Oe, $e, Me, Re = !1;
    return ye && typeof ye == "object" ? (xe = ye.bufferSize, Me = xe === void 0 ? 1 / 0 : xe, Oe = ye.windowTime, ve = Oe === void 0 ? 1 / 0 : Oe, $e = ye.refCount, Re = $e === void 0 ? !1 : $e, _e = ye.scheduler) : Me = ye ?? 1 / 0, ae.share({ connector: function() {
      return new oe.ReplaySubject(Me, ve, _e);
    }, resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: Re });
  }
  ne.shareReplay = fe;
}), CH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.single = void 0;
  var oe = $l(), ae = hA(), fe = mA(), ye = he(), ve = Ae();
  function _e(xe) {
    return ye.operate(function(Oe, $e) {
      var Me = !1, Re, je = !1, Be = 0;
      Oe.subscribe(ve.createOperatorSubscriber($e, function(ze) {
        je = !0, (!xe || xe(ze, Be++, Oe)) && (Me && $e.error(new ae.SequenceError("Too many matching values")), Me = !0, Re = ze);
      }, function() {
        Me ? ($e.next(Re), $e.complete()) : $e.error(je ? new fe.NotFoundError("No matching values") : new oe.EmptyError());
      }));
    });
  }
  ne.single = _e;
}), RH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skip = void 0;
  var oe = _c();
  function ae(fe) {
    return oe.filter(function(ye, ve) {
      return fe <= ve;
    });
  }
  ne.skip = ae;
}), OH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipLast = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(ve) {
    return ve <= 0 ? oe.identity : ae.operate(function(_e, xe) {
      var Oe = new Array(ve), $e = 0;
      return _e.subscribe(fe.createOperatorSubscriber(xe, function(Me) {
        var Re = $e++;
        if (Re < ve)
          Oe[Re] = Me;
        else {
          var je = Re % ve, Be = Oe[je];
          Oe[je] = Me, xe.next(Be);
        }
      })), function() {
        Oe = null;
      };
    });
  }
  ne.skipLast = ye;
}), kH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function ve(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = !1, Me = ae.createOperatorSubscriber(Oe, function() {
        Me == null || Me.unsubscribe(), $e = !0;
      }, ye.noop);
      fe.innerFrom(_e).subscribe(Me), xe.subscribe(ae.createOperatorSubscriber(Oe, function(Re) {
        return $e && Oe.next(Re);
      }));
    });
  }
  ne.skipUntil = ve;
}), AH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(ve, _e) {
      var xe = !1, Oe = 0;
      ve.subscribe(ae.createOperatorSubscriber(_e, function($e) {
        return (xe || (xe = !ye($e, Oe++))) && _e.next($e);
      }));
    });
  }
  ne.skipWhile = fe;
}), MH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.startWith = void 0;
  var oe = hh(), ae = ki(), fe = he();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    var xe = ae.popScheduler(ve);
    return fe.operate(function(Oe, $e) {
      (xe ? oe.concat(ve, Oe, xe) : oe.concat(ve, Oe)).subscribe($e);
    });
  }
  ne.startWith = ye;
}), Sh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMap = void 0;
  var oe = _t(), ae = he(), fe = Ae();
  function ye(ve, _e) {
    return ae.operate(function(xe, Oe) {
      var $e = null, Me = 0, Re = !1, je = function() {
        return Re && !$e && Oe.complete();
      };
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        $e == null || $e.unsubscribe();
        var ze = 0, He = Me++;
        oe.innerFrom(ve(Be, He)).subscribe($e = fe.createOperatorSubscriber(Oe, function(qe) {
          return Oe.next(_e ? _e(Be, qe, He, ze++) : qe);
        }, function() {
          $e = null, je();
        }));
      }, function() {
        Re = !0, je();
      }));
    });
  }
  ne.switchMap = ye;
}), NH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchAll = void 0;
  var oe = Sh(), ae = Hn();
  function fe() {
    return oe.switchMap(ae.identity);
  }
  ne.switchAll = fe;
}), jH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMapTo = void 0;
  var oe = Sh(), ae = Mt();
  function fe(ye, ve) {
    return ae.isFunction(ve) ? oe.switchMap(function() {
      return ye;
    }, ve) : oe.switchMap(function() {
      return ye;
    });
  }
  ne.switchMapTo = fe;
}), UH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchScan = void 0;
  var oe = Sh(), ae = he();
  function fe(ye, ve) {
    return ae.operate(function(_e, xe) {
      var Oe = ve;
      return oe.switchMap(function($e, Me) {
        return ye(Oe, $e, Me);
      }, function($e, Me) {
        return Oe = Me, Me;
      })(_e).subscribe(xe), function() {
        Oe = null;
      };
    });
  }
  ne.switchScan = fe;
}), FH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function ve(_e) {
    return oe.operate(function(xe, Oe) {
      fe.innerFrom(_e).subscribe(ae.createOperatorSubscriber(Oe, function() {
        return Oe.complete();
      }, ye.noop)), !Oe.closed && xe.subscribe(Oe);
    });
  }
  ne.takeUntil = ve;
}), zH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ve) {
    return ve === void 0 && (ve = !1), oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        var Me = ye($e, Oe++);
        (Me || ve) && xe.next($e), !Me && xe.complete();
      }));
    });
  }
  ne.takeWhile = fe;
}), qH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.tap = void 0;
  var oe = Mt(), ae = he(), fe = Ae(), ye = Hn();
  function ve(_e, xe, Oe) {
    var $e = oe.isFunction(_e) || xe || Oe ? { next: _e, error: xe, complete: Oe } : _e;
    return $e ? ae.operate(function(Me, Re) {
      var je;
      (je = $e.subscribe) === null || je === void 0 || je.call($e);
      var Be = !0;
      Me.subscribe(fe.createOperatorSubscriber(Re, function(ze) {
        var He;
        (He = $e.next) === null || He === void 0 || He.call($e, ze), Re.next(ze);
      }, function() {
        var ze;
        Be = !1, (ze = $e.complete) === null || ze === void 0 || ze.call($e), Re.complete();
      }, function(ze) {
        var He;
        Be = !1, (He = $e.error) === null || He === void 0 || He.call($e, ze), Re.error(ze);
      }, function() {
        var ze, He;
        Be && ((ze = $e.unsubscribe) === null || ze === void 0 || ze.call($e)), (He = $e.finalize) === null || He === void 0 || He.call($e);
      }));
    }) : ye.identity;
  }
  ne.tap = ve;
}), VA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttle = ne.defaultThrottleConfig = void 0;
  var oe = he(), ae = Ae(), fe = _t();
  ne.defaultThrottleConfig = { leading: !0, trailing: !1 };
  function ye(ve, _e) {
    return _e === void 0 && (_e = ne.defaultThrottleConfig), oe.operate(function(xe, Oe) {
      var $e = _e.leading, Me = _e.trailing, Re = !1, je = null, Be = null, ze = !1, He = function() {
        Be == null || Be.unsubscribe(), Be = null, Me && (pt(), ze && Oe.complete());
      }, qe = function() {
        Be = null, ze && Oe.complete();
      }, Ye = function(dt) {
        return Be = fe.innerFrom(ve(dt)).subscribe(ae.createOperatorSubscriber(Oe, He, qe));
      }, pt = function() {
        if (Re) {
          Re = !1;
          var dt = je;
          je = null, Oe.next(dt), !ze && Ye(dt);
        }
      };
      xe.subscribe(ae.createOperatorSubscriber(Oe, function(dt) {
        Re = !0, je = dt, !(Be && !Be.closed) && ($e ? pt() : Ye(dt));
      }, function() {
        ze = !0, !(Me && Re && Be && !Be.closed) && Oe.complete();
      }));
    });
  }
  ne.throttle = ye;
}), HH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttleTime = void 0;
  var oe = Ti(), ae = VA(), fe = Kl();
  function ye(ve, _e, xe) {
    _e === void 0 && (_e = oe.asyncScheduler), xe === void 0 && (xe = ae.defaultThrottleConfig);
    var Oe = fe.timer(ve, _e);
    return ae.throttle(function() {
      return Oe;
    }, xe);
  }
  ne.throttleTime = ye;
}), $H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TimeInterval = ne.timeInterval = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(_e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.operate(function(xe, Oe) {
      var $e = _e.now();
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Me) {
        var Re = _e.now(), je = Re - $e;
        $e = Re, Oe.next(new ve(Me, je));
      }));
    });
  }
  ne.timeInterval = ye;
  var ve = function() {
    function _e(xe, Oe) {
      this.value = xe, this.interval = Oe;
    }
    return _e;
  }();
  ne.TimeInterval = ve;
}), WH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutWith = void 0;
  var oe = Ti(), ae = zS(), fe = qS();
  function ye(ve, _e, xe) {
    var Oe, $e, Me;
    if (xe = xe ?? oe.async, ae.isValidDate(ve) ? Oe = ve : typeof ve == "number" && ($e = ve), _e)
      Me = function() {
        return _e;
      };
    else
      throw new TypeError("No observable provided to switch to");
    if (Oe == null && $e == null)
      throw new TypeError("No timeout provided.");
    return fe.timeout({ first: Oe, each: $e, scheduler: xe, with: Me });
  }
  ne.timeoutWith = ye;
}), YH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timestamp = void 0;
  var oe = rS(), ae = Wl();
  function fe(ye) {
    return ye === void 0 && (ye = oe.dateTimestampProvider), ae.map(function(ve) {
      return { value: ve, timestamp: ye.now() };
    });
  }
  ne.timestamp = fe;
}), KH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.window = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = On();
  function ve(_e) {
    return ae.operate(function(xe, Oe) {
      var $e = new oe.Subject();
      Oe.next($e.asObservable());
      var Me = function(Re) {
        $e.error(Re), Oe.error(Re);
      };
      return xe.subscribe(fe.createOperatorSubscriber(Oe, function(Re) {
        return $e == null ? void 0 : $e.next(Re);
      }, function() {
        $e.complete(), Oe.complete();
      }, Me)), _e.subscribe(fe.createOperatorSubscriber(Oe, function() {
        $e.complete(), Oe.next($e = new oe.Subject());
      }, ye.noop, Me)), function() {
        $e == null || $e.unsubscribe(), $e = null;
      };
    });
  }
  ne.window = ve;
}), JH = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowCount = void 0;
  var ae = Tn(), fe = he(), ye = Ae();
  function ve(_e, xe) {
    xe === void 0 && (xe = 0);
    var Oe = xe > 0 ? xe : _e;
    return fe.operate(function($e, Me) {
      var Re = [new ae.Subject()], je = 0;
      Me.next(Re[0].asObservable()), $e.subscribe(ye.createOperatorSubscriber(Me, function(Be) {
        var ze, He;
        try {
          for (var qe = oe(Re), Ye = qe.next(); !Ye.done; Ye = qe.next()) {
            var pt = Ye.value;
            pt.next(Be);
          }
        } catch (Ct) {
          ze = { error: Ct };
        } finally {
          try {
            Ye && !Ye.done && (He = qe.return) && He.call(qe);
          } finally {
            if (ze)
              throw ze.error;
          }
        }
        var dt = je - _e + 1;
        if (dt >= 0 && dt % Oe === 0 && Re.shift().complete(), ++je % Oe === 0) {
          var yt = new ae.Subject();
          Re.push(yt), Me.next(yt.asObservable());
        }
      }, function() {
        for (; Re.length > 0; )
          Re.shift().complete();
        Me.complete();
      }, function(Be) {
        for (; Re.length > 0; )
          Re.shift().error(Be);
        Me.error(Be);
      }, function() {
        Re = null;
      }));
    });
  }
  ne.windowCount = ve;
}), e4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowTime = void 0;
  var oe = Tn(), ae = Ti(), fe = Oi(), ye = he(), ve = Ae(), _e = ku(), xe = ki(), Oe = Au();
  function $e(Me) {
    for (var Re, je, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Re = xe.popScheduler(Be)) !== null && Re !== void 0 ? Re : ae.asyncScheduler, qe = (je = Be[0]) !== null && je !== void 0 ? je : null, Ye = Be[1] || 1 / 0;
    return ye.operate(function(pt, dt) {
      var yt = [], Ct = !1, It = function(tr) {
        var er = tr.window, hr = tr.subs;
        er.complete(), hr.unsubscribe(), _e.arrRemove(yt, tr), Ct && Vt();
      }, Vt = function() {
        if (yt) {
          var tr = new fe.Subscription();
          dt.add(tr);
          var er = new oe.Subject(), hr = { window: er, subs: tr, seen: 0 };
          yt.push(hr), dt.next(er.asObservable()), Oe.executeSchedule(tr, He, function() {
            return It(hr);
          }, Me);
        }
      };
      qe !== null && qe >= 0 ? Oe.executeSchedule(dt, He, Vt, qe, !0) : Ct = !0, Vt();
      var Ut = function(tr) {
        return yt.slice().forEach(tr);
      }, Zt = function(tr) {
        Ut(function(er) {
          var hr = er.window;
          return tr(hr);
        }), tr(dt), dt.unsubscribe();
      };
      return pt.subscribe(ve.createOperatorSubscriber(dt, function(tr) {
        Ut(function(er) {
          er.window.next(tr), Ye <= ++er.seen && It(er);
        });
      }, function() {
        return Zt(function(tr) {
          return tr.complete();
        });
      }, function(tr) {
        return Zt(function(er) {
          return er.error(tr);
        });
      })), function() {
        yt = null;
      };
    });
  }
  ne.windowTime = $e;
}), n4 = M((ne) => {
  var oe = ne && ne.__values || function(Me) {
    var Re = typeof Symbol == "function" && Symbol.iterator, je = Re && Me[Re], Be = 0;
    if (je)
      return je.call(Me);
    if (Me && typeof Me.length == "number")
      return { next: function() {
        return Me && Be >= Me.length && (Me = void 0), { value: Me && Me[Be++], done: !Me };
      } };
    throw new TypeError(Re ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowToggle = void 0;
  var ae = Tn(), fe = Oi(), ye = he(), ve = _t(), _e = Ae(), xe = On(), Oe = ku();
  function $e(Me, Re) {
    return ye.operate(function(je, Be) {
      var ze = [], He = function(qe) {
        for (; 0 < ze.length; )
          ze.shift().error(qe);
        Be.error(qe);
      };
      ve.innerFrom(Me).subscribe(_e.createOperatorSubscriber(Be, function(qe) {
        var Ye = new ae.Subject();
        ze.push(Ye);
        var pt = new fe.Subscription(), dt = function() {
          Oe.arrRemove(ze, Ye), Ye.complete(), pt.unsubscribe();
        }, yt;
        try {
          yt = ve.innerFrom(Re(qe));
        } catch (Ct) {
          He(Ct);
          return;
        }
        Be.next(Ye.asObservable()), pt.add(yt.subscribe(_e.createOperatorSubscriber(Be, dt, xe.noop, He)));
      }, xe.noop)), je.subscribe(_e.createOperatorSubscriber(Be, function(qe) {
        var Ye, pt, dt = ze.slice();
        try {
          for (var yt = oe(dt), Ct = yt.next(); !Ct.done; Ct = yt.next()) {
            var It = Ct.value;
            It.next(qe);
          }
        } catch (Vt) {
          Ye = { error: Vt };
        } finally {
          try {
            Ct && !Ct.done && (pt = yt.return) && pt.call(yt);
          } finally {
            if (Ye)
              throw Ye.error;
          }
        }
      }, function() {
        for (; 0 < ze.length; )
          ze.shift().complete();
        Be.complete();
      }, He, function() {
        for (; 0 < ze.length; )
          ze.shift().unsubscribe();
      }));
    });
  }
  ne.windowToggle = $e;
}), a4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = _t();
  function ve(_e) {
    return ae.operate(function(xe, Oe) {
      var $e, Me, Re = function(Be) {
        $e.error(Be), Oe.error(Be);
      }, je = function() {
        Me == null || Me.unsubscribe(), $e == null || $e.complete(), $e = new oe.Subject(), Oe.next($e.asObservable());
        var Be;
        try {
          Be = ye.innerFrom(_e());
        } catch (ze) {
          Re(ze);
          return;
        }
        Be.subscribe(Me = fe.createOperatorSubscriber(Oe, je, je, Re));
      };
      je(), xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        return $e.next(Be);
      }, function() {
        $e.complete(), Oe.complete();
      }, Re, function() {
        Me == null || Me.unsubscribe(), $e = null;
      }));
    });
  }
  ne.windowWhen = ve;
}), s4 = M((ne) => {
  var oe = ne && ne.__read || function(Me, Re) {
    var je = typeof Symbol == "function" && Me[Symbol.iterator];
    if (!je)
      return Me;
    var Be = je.call(Me), ze, He = [], qe;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Me, Re) {
    for (var je = 0, Be = Re.length, ze = Me.length; je < Be; je++, ze++)
      Me[ze] = Re[je];
    return Me;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.withLatestFrom = void 0;
  var fe = he(), ye = Ae(), ve = _t(), _e = Hn(), xe = On(), Oe = ki();
  function $e() {
    for (var Me = [], Re = 0; Re < arguments.length; Re++)
      Me[Re] = arguments[Re];
    var je = Oe.popResultSelector(Me);
    return fe.operate(function(Be, ze) {
      for (var He = Me.length, qe = new Array(He), Ye = Me.map(function() {
        return !1;
      }), pt = !1, dt = function(Ct) {
        ve.innerFrom(Me[Ct]).subscribe(ye.createOperatorSubscriber(ze, function(It) {
          qe[Ct] = It, !pt && !Ye[Ct] && (Ye[Ct] = !0, (pt = Ye.every(_e.identity)) && (Ye = null));
        }, xe.noop));
      }, yt = 0; yt < He; yt++)
        dt(yt);
      Be.subscribe(ye.createOperatorSubscriber(ze, function(Ct) {
        if (pt) {
          var It = ae([Ct], oe(qe));
          ze.next(je ? je.apply(void 0, ae([], oe(It))) : It);
        }
      }));
    });
  }
  ne.withLatestFrom = $e;
}), c4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipAll = void 0;
  var oe = h_(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.zip, ye);
  }
  ne.zipAll = fe;
}), f4 = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Me, Re = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Me = $e.next()).done; )
        Re.push(Me.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Me && !Me.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Me = _e.length; Oe < $e; Oe++, Me++)
      _e[Me] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = h_(), ye = he();
  function ve() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    return ye.operate(function(Oe, $e) {
      fe.zip.apply(void 0, ae([Oe], oe(_e))).subscribe($e);
    });
  }
  ne.zip = ve;
}), d4 = M((ne) => {
  var oe = ne && ne.__read || function(ve, _e) {
    var xe = typeof Symbol == "function" && ve[Symbol.iterator];
    if (!xe)
      return ve;
    var Oe = xe.call(ve), $e, Me = [], Re;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Me.push($e.value);
    } catch (je) {
      Re = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Re)
          throw Re.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(ve, _e) {
    for (var xe = 0, Oe = _e.length, $e = ve.length; xe < Oe; xe++, $e++)
      ve[$e] = _e[xe];
    return ve;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipWith = void 0;
  var fe = f4();
  function ye() {
    for (var ve = [], _e = 0; _e < arguments.length; _e++)
      ve[_e] = arguments[_e];
    return fe.zip.apply(void 0, ae([], oe(ve)));
  }
  ne.zipWith = ye;
}), WA = M((ne) => {
  var oe = ne && ne.__createBinding || (Object.create ? function(jt, Ht, sr, Fr) {
    Fr === void 0 && (Fr = sr), Object.defineProperty(jt, Fr, { enumerable: !0, get: function() {
      return Ht[sr];
    } });
  } : function(jt, Ht, sr, Fr) {
    Fr === void 0 && (Fr = sr), jt[Fr] = Ht[sr];
  }), ae = ne && ne.__exportStar || function(jt, Ht) {
    for (var sr in jt)
      sr !== "default" && !Object.prototype.hasOwnProperty.call(Ht, sr) && oe(Ht, jt, sr);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = ne.iif = ne.generate = ne.fromEventPattern = ne.fromEvent = ne.from = ne.forkJoin = ne.empty = ne.defer = ne.connectable = ne.concat = ne.combineLatest = ne.bindNodeCallback = ne.bindCallback = ne.UnsubscriptionError = ne.TimeoutError = ne.SequenceError = ne.ObjectUnsubscribedError = ne.NotFoundError = ne.EmptyError = ne.ArgumentOutOfRangeError = ne.firstValueFrom = ne.lastValueFrom = ne.isObservable = ne.identity = ne.noop = ne.pipe = ne.NotificationKind = ne.Notification = ne.Subscriber = ne.Subscription = ne.Scheduler = ne.VirtualAction = ne.VirtualTimeScheduler = ne.animationFrameScheduler = ne.animationFrame = ne.queueScheduler = ne.queue = ne.asyncScheduler = ne.async = ne.asapScheduler = ne.asap = ne.AsyncSubject = ne.ReplaySubject = ne.BehaviorSubject = ne.Subject = ne.animationFrames = ne.observable = ne.ConnectableObservable = ne.Observable = void 0, ne.filter = ne.expand = ne.exhaustMap = ne.exhaustAll = ne.exhaust = ne.every = ne.endWith = ne.elementAt = ne.distinctUntilKeyChanged = ne.distinctUntilChanged = ne.distinct = ne.dematerialize = ne.delayWhen = ne.delay = ne.defaultIfEmpty = ne.debounceTime = ne.debounce = ne.count = ne.connect = ne.concatWith = ne.concatMapTo = ne.concatMap = ne.concatAll = ne.combineLatestWith = ne.combineLatestAll = ne.combineAll = ne.catchError = ne.bufferWhen = ne.bufferToggle = ne.bufferTime = ne.bufferCount = ne.buffer = ne.auditTime = ne.audit = ne.config = ne.NEVER = ne.EMPTY = ne.scheduled = ne.zip = ne.using = ne.timer = ne.throwError = ne.range = ne.race = ne.partition = ne.pairs = ne.onErrorResumeNext = ne.of = ne.never = ne.merge = void 0, ne.switchMapTo = ne.switchMap = ne.switchAll = ne.subscribeOn = ne.startWith = ne.skipWhile = ne.skipUntil = ne.skipLast = ne.skip = ne.single = ne.shareReplay = ne.share = ne.sequenceEqual = ne.scan = ne.sampleTime = ne.sample = ne.refCount = ne.retryWhen = ne.retry = ne.repeatWhen = ne.repeat = ne.reduce = ne.raceWith = ne.publishReplay = ne.publishLast = ne.publishBehavior = ne.publish = ne.pluck = ne.pairwise = ne.observeOn = ne.multicast = ne.min = ne.mergeWith = ne.mergeScan = ne.mergeMapTo = ne.mergeMap = ne.flatMap = ne.mergeAll = ne.max = ne.materialize = ne.mapTo = ne.map = ne.last = ne.isEmpty = ne.ignoreElements = ne.groupBy = ne.first = ne.findIndex = ne.find = ne.finalize = void 0, ne.zipWith = ne.zipAll = ne.withLatestFrom = ne.windowWhen = ne.windowToggle = ne.windowTime = ne.windowCount = ne.window = ne.toArray = ne.timestamp = ne.timeoutWith = ne.timeout = ne.timeInterval = ne.throwIfEmpty = ne.throttleTime = ne.throttle = ne.tap = ne.takeWhile = ne.takeUntil = ne.takeLast = ne.take = ne.switchScan = void 0;
  var fe = qt();
  Object.defineProperty(ne, "Observable", { enumerable: !0, get: function() {
    return fe.Observable;
  } });
  var ye = sh();
  Object.defineProperty(ne, "ConnectableObservable", { enumerable: !0, get: function() {
    return ye.ConnectableObservable;
  } });
  var ve = uh();
  Object.defineProperty(ne, "observable", { enumerable: !0, get: function() {
    return ve.observable;
  } });
  var _e = hI();
  Object.defineProperty(ne, "animationFrames", { enumerable: !0, get: function() {
    return _e.animationFrames;
  } });
  var xe = Tn();
  Object.defineProperty(ne, "Subject", { enumerable: !0, get: function() {
    return xe.Subject;
  } });
  var Oe = Xk();
  Object.defineProperty(ne, "BehaviorSubject", { enumerable: !0, get: function() {
    return Oe.BehaviorSubject;
  } });
  var $e = nS();
  Object.defineProperty(ne, "ReplaySubject", { enumerable: !0, get: function() {
    return $e.ReplaySubject;
  } });
  var Me = iS();
  Object.defineProperty(ne, "AsyncSubject", { enumerable: !0, get: function() {
    return Me.AsyncSubject;
  } });
  var Re = DI();
  Object.defineProperty(ne, "asap", { enumerable: !0, get: function() {
    return Re.asap;
  } }), Object.defineProperty(ne, "asapScheduler", { enumerable: !0, get: function() {
    return Re.asapScheduler;
  } });
  var je = Ti();
  Object.defineProperty(ne, "async", { enumerable: !0, get: function() {
    return je.async;
  } }), Object.defineProperty(ne, "asyncScheduler", { enumerable: !0, get: function() {
    return je.asyncScheduler;
  } });
  var Be = jI();
  Object.defineProperty(ne, "queue", { enumerable: !0, get: function() {
    return Be.queue;
  } }), Object.defineProperty(ne, "queueScheduler", { enumerable: !0, get: function() {
    return Be.queueScheduler;
  } });
  var ze = qI();
  Object.defineProperty(ne, "animationFrame", { enumerable: !0, get: function() {
    return ze.animationFrame;
  } }), Object.defineProperty(ne, "animationFrameScheduler", { enumerable: !0, get: function() {
    return ze.animationFrameScheduler;
  } });
  var He = HI();
  Object.defineProperty(ne, "VirtualTimeScheduler", { enumerable: !0, get: function() {
    return He.VirtualTimeScheduler;
  } }), Object.defineProperty(ne, "VirtualAction", { enumerable: !0, get: function() {
    return He.VirtualAction;
  } });
  var qe = Zk();
  Object.defineProperty(ne, "Scheduler", { enumerable: !0, get: function() {
    return qe.Scheduler;
  } });
  var Ye = Oi();
  Object.defineProperty(ne, "Subscription", { enumerable: !0, get: function() {
    return Ye.Subscription;
  } });
  var pt = Sd();
  Object.defineProperty(ne, "Subscriber", { enumerable: !0, get: function() {
    return pt.Subscriber;
  } });
  var dt = AS();
  Object.defineProperty(ne, "Notification", { enumerable: !0, get: function() {
    return dt.Notification;
  } }), Object.defineProperty(ne, "NotificationKind", { enumerable: !0, get: function() {
    return dt.NotificationKind;
  } });
  var yt = lh();
  Object.defineProperty(ne, "pipe", { enumerable: !0, get: function() {
    return yt.pipe;
  } });
  var Ct = On();
  Object.defineProperty(ne, "noop", { enumerable: !0, get: function() {
    return Ct.noop;
  } });
  var It = Hn();
  Object.defineProperty(ne, "identity", { enumerable: !0, get: function() {
    return It.identity;
  } });
  var Vt = o3();
  Object.defineProperty(ne, "isObservable", { enumerable: !0, get: function() {
    return Vt.isObservable;
  } });
  var Ut = u3();
  Object.defineProperty(ne, "lastValueFrom", { enumerable: !0, get: function() {
    return Ut.lastValueFrom;
  } });
  var Zt = l3();
  Object.defineProperty(ne, "firstValueFrom", { enumerable: !0, get: function() {
    return Zt.firstValueFrom;
  } });
  var tr = vA();
  Object.defineProperty(ne, "ArgumentOutOfRangeError", { enumerable: !0, get: function() {
    return tr.ArgumentOutOfRangeError;
  } });
  var er = $l();
  Object.defineProperty(ne, "EmptyError", { enumerable: !0, get: function() {
    return er.EmptyError;
  } });
  var hr = mA();
  Object.defineProperty(ne, "NotFoundError", { enumerable: !0, get: function() {
    return hr.NotFoundError;
  } });
  var Ot = Yk();
  Object.defineProperty(ne, "ObjectUnsubscribedError", { enumerable: !0, get: function() {
    return Ot.ObjectUnsubscribedError;
  } });
  var Qe = hA();
  Object.defineProperty(ne, "SequenceError", { enumerable: !0, get: function() {
    return Qe.SequenceError;
  } });
  var at = qS();
  Object.defineProperty(ne, "TimeoutError", { enumerable: !0, get: function() {
    return at.TimeoutError;
  } });
  var wt = Nk();
  Object.defineProperty(ne, "UnsubscriptionError", { enumerable: !0, get: function() {
    return wt.UnsubscriptionError;
  } });
  var bt = c3();
  Object.defineProperty(ne, "bindCallback", { enumerable: !0, get: function() {
    return bt.bindCallback;
  } });
  var At = f3();
  Object.defineProperty(ne, "bindNodeCallback", { enumerable: !0, get: function() {
    return At.bindNodeCallback;
  } });
  var Ft = WS();
  Object.defineProperty(ne, "combineLatest", { enumerable: !0, get: function() {
    return Ft.combineLatest;
  } });
  var Gt = hh();
  Object.defineProperty(ne, "concat", { enumerable: !0, get: function() {
    return Gt.concat;
  } });
  var ot = b3();
  Object.defineProperty(ne, "connectable", { enumerable: !0, get: function() {
    return ot.connectable;
  } });
  var et = yh();
  Object.defineProperty(ne, "defer", { enumerable: !0, get: function() {
    return et.defer;
  } });
  var Rt = ba();
  Object.defineProperty(ne, "empty", { enumerable: !0, get: function() {
    return Rt.empty;
  } });
  var xr = S3();
  Object.defineProperty(ne, "forkJoin", { enumerable: !0, get: function() {
    return xr.forkJoin;
  } });
  var Xt = Ja();
  Object.defineProperty(ne, "from", { enumerable: !0, get: function() {
    return Xt.from;
  } });
  var dr = w3();
  Object.defineProperty(ne, "fromEvent", { enumerable: !0, get: function() {
    return dr.fromEvent;
  } });
  var Nr = E3();
  Object.defineProperty(ne, "fromEventPattern", { enumerable: !0, get: function() {
    return Nr.fromEventPattern;
  } });
  var Dr = R3();
  Object.defineProperty(ne, "generate", { enumerable: !0, get: function() {
    return Dr.generate;
  } });
  var jr = O3();
  Object.defineProperty(ne, "iif", { enumerable: !0, get: function() {
    return jr.iif;
  } });
  var un = wA();
  Object.defineProperty(ne, "interval", { enumerable: !0, get: function() {
    return un.interval;
  } });
  var so = k3();
  Object.defineProperty(ne, "merge", { enumerable: !0, get: function() {
    return so.merge;
  } });
  var Pn = xA();
  Object.defineProperty(ne, "never", { enumerable: !0, get: function() {
    return Pn.never;
  } });
  var co = TS();
  Object.defineProperty(ne, "of", { enumerable: !0, get: function() {
    return co.of;
  } });
  var kn = M3();
  Object.defineProperty(ne, "onErrorResumeNext", { enumerable: !0, get: function() {
    return kn.onErrorResumeNext;
  } });
  var Yn = D3();
  Object.defineProperty(ne, "pairs", { enumerable: !0, get: function() {
    return Yn.pairs;
  } });
  var Ho = U3();
  Object.defineProperty(ne, "partition", { enumerable: !0, get: function() {
    return Ho.partition;
  } });
  var Rn = EA();
  Object.defineProperty(ne, "race", { enumerable: !0, get: function() {
    return Rn.race;
  } });
  var fo = q3();
  Object.defineProperty(ne, "range", { enumerable: !0, get: function() {
    return fo.range;
  } });
  var pa = pA();
  Object.defineProperty(ne, "throwError", { enumerable: !0, get: function() {
    return pa.throwError;
  } });
  var jn = Kl();
  Object.defineProperty(ne, "timer", { enumerable: !0, get: function() {
    return jn.timer;
  } });
  var Xn = I3();
  Object.defineProperty(ne, "using", { enumerable: !0, get: function() {
    return Xn.using;
  } });
  var Ko = h_();
  Object.defineProperty(ne, "zip", { enumerable: !0, get: function() {
    return Ko.zip;
  } });
  var vo = dA();
  Object.defineProperty(ne, "scheduled", { enumerable: !0, get: function() {
    return vo.scheduled;
  } });
  var Eo = ba();
  Object.defineProperty(ne, "EMPTY", { enumerable: !0, get: function() {
    return Eo.EMPTY;
  } });
  var ra = xA();
  Object.defineProperty(ne, "NEVER", { enumerable: !0, get: function() {
    return ra.NEVER;
  } }), ae(H3(), ne);
  var uo = gd();
  Object.defineProperty(ne, "config", { enumerable: !0, get: function() {
    return uo.config;
  } });
  var So = CA();
  Object.defineProperty(ne, "audit", { enumerable: !0, get: function() {
    return So.audit;
  } });
  var Jo = $3();
  Object.defineProperty(ne, "auditTime", { enumerable: !0, get: function() {
    return Jo.auditTime;
  } });
  var Po = Y3();
  Object.defineProperty(ne, "buffer", { enumerable: !0, get: function() {
    return Po.buffer;
  } });
  var Jt = G3();
  Object.defineProperty(ne, "bufferCount", { enumerable: !0, get: function() {
    return Jt.bufferCount;
  } });
  var or = K3();
  Object.defineProperty(ne, "bufferTime", { enumerable: !0, get: function() {
    return or.bufferTime;
  } });
  var fr = Z3();
  Object.defineProperty(ne, "bufferToggle", { enumerable: !0, get: function() {
    return fr.bufferToggle;
  } });
  var Mr = tB();
  Object.defineProperty(ne, "bufferWhen", { enumerable: !0, get: function() {
    return Mr.bufferWhen;
  } });
  var Wr = nB();
  Object.defineProperty(ne, "catchError", { enumerable: !0, get: function() {
    return Wr.catchError;
  } });
  var Vr = iB();
  Object.defineProperty(ne, "combineAll", { enumerable: !0, get: function() {
    return Vr.combineAll;
  } });
  var Zr = PA();
  Object.defineProperty(ne, "combineLatestAll", { enumerable: !0, get: function() {
    return Zr.combineLatestAll;
  } });
  var on = sB();
  Object.defineProperty(ne, "combineLatestWith", { enumerable: !0, get: function() {
    return on.combineLatestWith;
  } });
  var Lr = JS();
  Object.defineProperty(ne, "concatAll", { enumerable: !0, get: function() {
    return Lr.concatAll;
  } });
  var tn = MA();
  Object.defineProperty(ne, "concatMap", { enumerable: !0, get: function() {
    return tn.concatMap;
  } });
  var Qn = dB();
  Object.defineProperty(ne, "concatMapTo", { enumerable: !0, get: function() {
    return Qn.concatMapTo;
  } });
  var Fn = vB();
  Object.defineProperty(ne, "concatWith", { enumerable: !0, get: function() {
    return Fn.concatWith;
  } });
  var en = M_();
  Object.defineProperty(ne, "connect", { enumerable: !0, get: function() {
    return en.connect;
  } });
  var An = hB();
  Object.defineProperty(ne, "count", { enumerable: !0, get: function() {
    return An.count;
  } });
  var zn = gB();
  Object.defineProperty(ne, "debounce", { enumerable: !0, get: function() {
    return zn.debounce;
  } });
  var Oo = bB();
  Object.defineProperty(ne, "debounceTime", { enumerable: !0, get: function() {
    return Oo.debounceTime;
  } });
  var ii = gh();
  Object.defineProperty(ne, "defaultIfEmpty", { enumerable: !0, get: function() {
    return ii.defaultIfEmpty;
  } });
  var No = wB();
  Object.defineProperty(ne, "delay", { enumerable: !0, get: function() {
    return No.delay;
  } });
  var Ao = LA();
  Object.defineProperty(ne, "delayWhen", { enumerable: !0, get: function() {
    return Ao.delayWhen;
  } });
  var Da = xB();
  Object.defineProperty(ne, "dematerialize", { enumerable: !0, get: function() {
    return Da.dematerialize;
  } });
  var po = CB();
  Object.defineProperty(ne, "distinct", { enumerable: !0, get: function() {
    return po.distinct;
  } });
  var _o = jA();
  Object.defineProperty(ne, "distinctUntilChanged", { enumerable: !0, get: function() {
    return _o.distinctUntilChanged;
  } });
  var Ba = RB();
  Object.defineProperty(ne, "distinctUntilKeyChanged", { enumerable: !0, get: function() {
    return Ba.distinctUntilKeyChanged;
  } });
  var bo = TB();
  Object.defineProperty(ne, "elementAt", { enumerable: !0, get: function() {
    return bo.elementAt;
  } });
  var $n = kB();
  Object.defineProperty(ne, "endWith", { enumerable: !0, get: function() {
    return $n.endWith;
  } });
  var Bo = AB();
  Object.defineProperty(ne, "every", { enumerable: !0, get: function() {
    return Bo.every;
  } });
  var ho = MB();
  Object.defineProperty(ne, "exhaust", { enumerable: !0, get: function() {
    return ho.exhaust;
  } });
  var To = UA();
  Object.defineProperty(ne, "exhaustAll", { enumerable: !0, get: function() {
    return To.exhaustAll;
  } });
  var Qt = jB();
  Object.defineProperty(ne, "exhaustMap", { enumerable: !0, get: function() {
    return Qt.exhaustMap;
  } });
  var kr = UB();
  Object.defineProperty(ne, "expand", { enumerable: !0, get: function() {
    return kr.expand;
  } });
  var Tr = _c();
  Object.defineProperty(ne, "filter", { enumerable: !0, get: function() {
    return Tr.filter;
  } });
  var vn = FB();
  Object.defineProperty(ne, "finalize", { enumerable: !0, get: function() {
    return vn.finalize;
  } });
  var mn = FA();
  Object.defineProperty(ne, "find", { enumerable: !0, get: function() {
    return mn.find;
  } });
  var En = qB();
  Object.defineProperty(ne, "findIndex", { enumerable: !0, get: function() {
    return En.findIndex;
  } });
  var Zn = IB();
  Object.defineProperty(ne, "first", { enumerable: !0, get: function() {
    return Zn.first;
  } });
  var xn = HB();
  Object.defineProperty(ne, "groupBy", { enumerable: !0, get: function() {
    return xn.groupBy;
  } });
  var na = DA();
  Object.defineProperty(ne, "ignoreElements", { enumerable: !0, get: function() {
    return na.ignoreElements;
  } });
  var Wo = VB();
  Object.defineProperty(ne, "isEmpty", { enumerable: !0, get: function() {
    return Wo.isEmpty;
  } });
  var Zo = $B();
  Object.defineProperty(ne, "last", { enumerable: !0, get: function() {
    return Zo.last;
  } });
  var va = Wl();
  Object.defineProperty(ne, "map", { enumerable: !0, get: function() {
    return va.map;
  } });
  var yi = NA();
  Object.defineProperty(ne, "mapTo", { enumerable: !0, get: function() {
    return yi.mapTo;
  } });
  var _s = WB();
  Object.defineProperty(ne, "materialize", { enumerable: !0, get: function() {
    return _s.materialize;
  } });
  var xo = YB();
  Object.defineProperty(ne, "max", { enumerable: !0, get: function() {
    return xo.max;
  } });
  var qu = mh();
  Object.defineProperty(ne, "mergeAll", { enumerable: !0, get: function() {
    return qu.mergeAll;
  } });
  var si = GB();
  Object.defineProperty(ne, "flatMap", { enumerable: !0, get: function() {
    return si.flatMap;
  } });
  var oo = Mu();
  Object.defineProperty(ne, "mergeMap", { enumerable: !0, get: function() {
    return oo.mergeMap;
  } });
  var da = KB();
  Object.defineProperty(ne, "mergeMapTo", { enumerable: !0, get: function() {
    return da.mergeMapTo;
  } });
  var xs = XB();
  Object.defineProperty(ne, "mergeScan", { enumerable: !0, get: function() {
    return xs.mergeScan;
  } });
  var as = eH();
  Object.defineProperty(ne, "mergeWith", { enumerable: !0, get: function() {
    return as.mergeWith;
  } });
  var Ci = tH();
  Object.defineProperty(ne, "min", { enumerable: !0, get: function() {
    return Ci.min;
  } });
  var Ca = dw();
  Object.defineProperty(ne, "multicast", { enumerable: !0, get: function() {
    return Ca.multicast;
  } });
  var Es = ph();
  Object.defineProperty(ne, "observeOn", { enumerable: !0, get: function() {
    return Es.observeOn;
  } });
  var ka = nH();
  Object.defineProperty(ne, "pairwise", { enumerable: !0, get: function() {
    return ka.pairwise;
  } });
  var rl = iH();
  Object.defineProperty(ne, "pluck", { enumerable: !0, get: function() {
    return rl.pluck;
  } });
  var nl = aH();
  Object.defineProperty(ne, "publish", { enumerable: !0, get: function() {
    return nl.publish;
  } });
  var od = oH();
  Object.defineProperty(ne, "publishBehavior", { enumerable: !0, get: function() {
    return od.publishBehavior;
  } });
  var ol = uH();
  Object.defineProperty(ne, "publishLast", { enumerable: !0, get: function() {
    return ol.publishLast;
  } });
  var Yi = sH();
  Object.defineProperty(ne, "publishReplay", { enumerable: !0, get: function() {
    return Yi.publishReplay;
  } });
  var $i = cH();
  Object.defineProperty(ne, "raceWith", { enumerable: !0, get: function() {
    return $i.raceWith;
  } });
  var $a = Qd();
  Object.defineProperty(ne, "reduce", { enumerable: !0, get: function() {
    return $a.reduce;
  } });
  var Us = dH();
  Object.defineProperty(ne, "repeat", { enumerable: !0, get: function() {
    return Us.repeat;
  } });
  var ts = vH();
  Object.defineProperty(ne, "repeatWhen", { enumerable: !0, get: function() {
    return ts.repeatWhen;
  } });
  var xl = hH();
  Object.defineProperty(ne, "retry", { enumerable: !0, get: function() {
    return xl.retry;
  } });
  var lu = gH();
  Object.defineProperty(ne, "retryWhen", { enumerable: !0, get: function() {
    return lu.retryWhen;
  } });
  var El = $k();
  Object.defineProperty(ne, "refCount", { enumerable: !0, get: function() {
    return El.refCount;
  } });
  var Vs = IA();
  Object.defineProperty(ne, "sample", { enumerable: !0, get: function() {
    return Vs.sample;
  } });
  var Hs = SH();
  Object.defineProperty(ne, "sampleTime", { enumerable: !0, get: function() {
    return Hs.sampleTime;
  } });
  var qs = _H();
  Object.defineProperty(ne, "scan", { enumerable: !0, get: function() {
    return qs.scan;
  } });
  var jo = xH();
  Object.defineProperty(ne, "sequenceEqual", { enumerable: !0, get: function() {
    return jo.sequenceEqual;
  } });
  var is = HA();
  Object.defineProperty(ne, "share", { enumerable: !0, get: function() {
    return is.share;
  } });
  var hc = EH();
  Object.defineProperty(ne, "shareReplay", { enumerable: !0, get: function() {
    return hc.shareReplay;
  } });
  var qa = CH();
  Object.defineProperty(ne, "single", { enumerable: !0, get: function() {
    return qa.single;
  } });
  var Fo = RH();
  Object.defineProperty(ne, "skip", { enumerable: !0, get: function() {
    return Fo.skip;
  } });
  var al = OH();
  Object.defineProperty(ne, "skipLast", { enumerable: !0, get: function() {
    return al.skipLast;
  } });
  var Sl = kH();
  Object.defineProperty(ne, "skipUntil", { enumerable: !0, get: function() {
    return Sl.skipUntil;
  } });
  var Gn = AH();
  Object.defineProperty(ne, "skipWhile", { enumerable: !0, get: function() {
    return Gn.skipWhile;
  } });
  var Ws = MH();
  Object.defineProperty(ne, "startWith", { enumerable: !0, get: function() {
    return Ws.startWith;
  } });
  var fa = vh();
  Object.defineProperty(ne, "subscribeOn", { enumerable: !0, get: function() {
    return fa.subscribeOn;
  } });
  var Ka = NH();
  Object.defineProperty(ne, "switchAll", { enumerable: !0, get: function() {
    return Ka.switchAll;
  } });
  var Xa = Sh();
  Object.defineProperty(ne, "switchMap", { enumerable: !0, get: function() {
    return Xa.switchMap;
  } });
  var Zs = jH();
  Object.defineProperty(ne, "switchMapTo", { enumerable: !0, get: function() {
    return Zs.switchMapTo;
  } });
  var wa = UH();
  Object.defineProperty(ne, "switchScan", { enumerable: !0, get: function() {
    return wa.switchScan;
  } });
  var Lo = Kd();
  Object.defineProperty(ne, "take", { enumerable: !0, get: function() {
    return Lo.take;
  } });
  var Pl = zA();
  Object.defineProperty(ne, "takeLast", { enumerable: !0, get: function() {
    return Pl.takeLast;
  } });
  var Ii = FH();
  Object.defineProperty(ne, "takeUntil", { enumerable: !0, get: function() {
    return Ii.takeUntil;
  } });
  var ja = zH();
  Object.defineProperty(ne, "takeWhile", { enumerable: !0, get: function() {
    return ja.takeWhile;
  } });
  var Ss = qH();
  Object.defineProperty(ne, "tap", { enumerable: !0, get: function() {
    return Ss.tap;
  } });
  var il = VA();
  Object.defineProperty(ne, "throttle", { enumerable: !0, get: function() {
    return il.throttle;
  } });
  var vi = HH();
  Object.defineProperty(ne, "throttleTime", { enumerable: !0, get: function() {
    return vi.throttleTime;
  } });
  var Tl = bh();
  Object.defineProperty(ne, "throwIfEmpty", { enumerable: !0, get: function() {
    return Tl.throwIfEmpty;
  } });
  var bi = $H();
  Object.defineProperty(ne, "timeInterval", { enumerable: !0, get: function() {
    return bi.timeInterval;
  } });
  var Gs = qS();
  Object.defineProperty(ne, "timeout", { enumerable: !0, get: function() {
    return Gs.timeout;
  } });
  var cu = WH();
  Object.defineProperty(ne, "timeoutWith", { enumerable: !0, get: function() {
    return cu.timeoutWith;
  } });
  var gi = YH();
  Object.defineProperty(ne, "timestamp", { enumerable: !0, get: function() {
    return gi.timestamp;
  } });
  var Mi = kA();
  Object.defineProperty(ne, "toArray", { enumerable: !0, get: function() {
    return Mi.toArray;
  } });
  var du = KH();
  Object.defineProperty(ne, "window", { enumerable: !0, get: function() {
    return du.window;
  } });
  var Ps = JH();
  Object.defineProperty(ne, "windowCount", { enumerable: !0, get: function() {
    return Ps.windowCount;
  } });
  var sl = e4();
  Object.defineProperty(ne, "windowTime", { enumerable: !0, get: function() {
    return sl.windowTime;
  } });
  var Wu = n4();
  Object.defineProperty(ne, "windowToggle", { enumerable: !0, get: function() {
    return Wu.windowToggle;
  } });
  var ul = a4();
  Object.defineProperty(ne, "windowWhen", { enumerable: !0, get: function() {
    return ul.windowWhen;
  } });
  var kl = s4();
  Object.defineProperty(ne, "withLatestFrom", { enumerable: !0, get: function() {
    return kl.withLatestFrom;
  } });
  var Ge = c4();
  Object.defineProperty(ne, "zipAll", { enumerable: !0, get: function() {
    return Ge.zipAll;
  } });
  var gt = d4();
  Object.defineProperty(ne, "zipWith", { enumerable: !0, get: function() {
    return gt.zipWith;
  } });
});
function Kw(ne, oe) {
  let ae = (oe == null ? void 0 : oe.updateOnValueChange) ?? !0, fe = Nge(ne), ye = (0, rp.useMemo)(() => f$2(fe, { runOnInit: !0 }), [fe]), [ve, _e] = (0, rp.useState)([...ye.matching]);
  return (0, rp.useEffect)(() => {
    _e([...ye.matching]);
    let xe = ye.update$.pipe((0, Qw.map)(() => [...ye.matching]));
    ae || (xe = xe.pipe((0, Qw.distinctUntilChanged)(($e, Me) => (0, _4.default)($e, Me))));
    let Oe = xe.subscribe(($e) => _e($e));
    return () => Oe.unsubscribe();
  }, [ye, ae]), ve;
}
function w4(ne, oe) {
  let [ae, fe] = (0, Xw.useState)(oe);
  return (0, Xw.useEffect)(() => {
    let ye = ne.subscribe(fe);
    return () => ye.unsubscribe();
  }, [ne]), ae;
}
function _h(ne) {
  let oe = (0, xc.useRef)(ne), [ae, fe] = (0, xc.useState)(ne == null ? { status: "idle" } : { status: "pending" });
  return (0, xc.useEffect)(() => {
    ne !== oe.current && (oe.current = ne, fe(ne == null ? { status: "idle" } : { status: "pending" }));
  }, [ne]), (0, xc.useEffect)(() => {
    ne != null && Promise.allSettled([ne]).then(([ye]) => {
      ne === oe.current && fe(ye);
    });
  }, [ne]), ae;
}
var rp, Gw, S4, _4, Qw, Xw, xc, Nge, wh = Y(() => {
  le(ir(), 1), rp = le(ir(), 1), Gw = le(ir(), 1), S4 = le(Dk(), 1), _4 = le(Dk(), 1), Qw = le(WA(), 1), Xw = le(ir(), 1), xc = le(ir(), 1), Nge = (ne) => {
    let [oe, ae] = (0, Gw.useState)(ne);
    return (0, Gw.useEffect)(() => {
      (0, S4.default)(ne, oe) || ae(ne);
    }, [ne]), oe;
  };
});
function E4() {
  var ye, ve;
  let { publicClient: ne, worldAddress: oe, latestBlock$: ae } = zt(), fe = w4(ae.pipe((0, x4.map)((_e) => _e.number)));
  return (0, Za.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Chain" }), (0, Za.jsxs)("dd", { className: "text-sm", children: [(ye = ne.chain) == null ? void 0 : ye.id, " (", (ve = ne.chain) == null ? void 0 : ve.name, ")"] }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Block number" }), (0, Za.jsx)("dd", { className: "text-sm", children: fe == null ? void 0 : fe.toString() }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "RPC" }), (0, Za.jsx)("dd", { className: "text-sm text-green-500", children: "Connected " }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "World" }), (0, Za.jsx)("dd", { className: "text-sm", children: oe })] });
}
var x4, Za, C4 = Y(() => {
  wh(), ai(), x4 = le(WA(), 1), Za = le(ke(), 1);
});
function R4(ne, oe) {
  var ae;
  return (ae = ne.exec(oe)) == null ? void 0 : ae.groups;
}
var O4 = Y(() => {
});
function Jw(ne) {
  let oe = ne.type;
  if (T4.test(ne.type) && "components" in ne) {
    oe = "(";
    let ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      let ve = ne.components[ye];
      oe += Jw(ve), ye < ae - 1 && (oe += ", ");
    }
    let fe = R4(T4, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, Jw({ ...ne, type: oe });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
var T4, k4 = Y(() => {
  O4(), T4 = /^tuple(?<array>(\[(\d*)\])*)$/;
});
function np(ne) {
  let oe = "", ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    let ye = ne[fe];
    oe += Jw(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
var A4 = Y(() => {
  k4();
});
function YA(ne) {
  return ne.type === "function" ? `function ${ne.name}(${np(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${np(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${np(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${np(ne.inputs)})` : ne.type === "constructor" ? `constructor(${np(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
var P4 = Y(() => {
  A4();
}), M4 = Y(() => {
  P4();
});
function ip(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new Eh(ne.type);
  return `${ne.name}(${xh(ne.inputs, { includeName: oe })})`;
}
function xh(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => Lge(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function Lge(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${xh(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
var Zw = Y(() => {
  ap();
});
function eo(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
var op = Y(() => {
});
function oi(ne) {
  return eo(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
var Ch = Y(() => {
  op();
}), D4, N4 = Y(() => {
  D4 = "2.9.20";
}), L4, j4 = Y(() => {
  N4(), L4 = () => `viem@${D4}`;
});
function U4(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? U4(ne.cause, oe) : oe ? null : ne;
}
var kt, Ec = Y(() => {
  j4(), kt = class extends Error {
    constructor(ne, oe = {}) {
      var ye;
      super(), Object.defineProperty(this, "details", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "docsPath", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "metaMessages", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shortMessage", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "ViemError" }), Object.defineProperty(this, "version", { enumerable: !0, configurable: !0, writable: !0, value: L4() });
      let ae = oe.cause instanceof kt ? oe.cause.details : (ye = oe.cause) != null && ye.message ? oe.cause.message : oe.details, fe = oe.cause instanceof kt && oe.cause.docsPath || oe.docsPath;
      this.message = [ne || "An error occurred.", "", ...oe.metaMessages ? [...oe.metaMessages, ""] : [], ...fe ? [`Docs: https://viem.sh${fe}${oe.docsSlug ? `#${oe.docsSlug}` : ""}`] : [], ...ae ? [`Details: ${ae}`] : [], `Version: ${this.version}`].join(`
`), oe.cause && (this.cause = oe.cause), this.details = ae, this.docsPath = fe, this.metaMessages = oe.metaMessages, this.shortMessage = ne;
    }
    walk(ne) {
      return U4(this, ne);
    }
  };
}), Cc, Rh, Oh, Rc, Th, up, kh, Ah, Eh, ap = Y(() => {
  Zw(), Ec(), Cc = class extends kt {
    constructor({ data: ne, params: oe, size: ae }) {
      super([`Data size of ${ae} bytes is too small for given parameters.`].join(`
`), { metaMessages: [`Params: (${xh(oe, { includeName: !0 })})`, `Data:   ${ne} (${ae} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingDataSizeTooSmallError" }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.data = ne, this.params = oe, this.size = ae;
    }
  }, Rh = class extends kt {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingZeroDataError" });
    }
  }, Oh = class extends kt {
    constructor({ docsPath: ne }) {
      super("Cannot extract event signature from empty topics.", { docsPath: ne }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureEmptyTopicsError" });
    }
  }, Rc = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded event signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureNotFoundError" });
    }
  }, Th = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded function signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiFunctionSignatureNotFoundError" });
    }
  }, up = class extends kt {
    constructor({ abiItem: ne, data: oe, params: ae, size: fe }) {
      super([`Data size of ${fe} bytes is too small for non-indexed event parameters.`].join(`
`), { metaMessages: [`Params: (${xh(ae, { includeName: !0 })})`, `Data:   ${oe} (${fe} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogDataMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne, this.data = oe, this.params = ae, this.size = fe;
    }
  }, kh = class extends kt {
    constructor({ abiItem: ne, param: oe }) {
      super([`Expected a topic for indexed event parameter${oe.name ? ` "${oe.name}"` : ""} on event "${ip(ne, { includeName: !0 })}".`].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne;
    }
  }, Ah = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Type "${ne}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidAbiDecodingType" });
    }
  }, Eh = class extends kt {
    constructor(ne) {
      super([`"${ne}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidDefinitionTypeError" });
    }
  };
}), Ph, Mh, GA = Y(() => {
  Ec(), Ph = class extends kt {
    constructor({ offset: ne, position: oe, size: ae }) {
      super(`Slice ${oe === "start" ? "starting" : "ending"} at offset "${ne}" is out-of-bounds (size: ${ae}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SliceOffsetOutOfBoundsError" });
    }
  }, Mh = class extends kt {
    constructor({ size: ne, targetSize: oe, type: ae }) {
      super(`${ae.charAt(0).toUpperCase()}${ae.slice(1).toLowerCase()} size (${ne}) exceeds padding size (${oe}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeExceedsPaddingSizeError" });
    }
  };
});
function fs(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? jge(ne, { dir: oe, size: ae }) : Uge(ne, { dir: oe, size: ae });
}
function jge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  let fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new Mh({ size: Math.ceil(fe.length / 2), targetSize: ae, type: "hex" });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function Uge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new Mh({ size: ne.length, targetSize: ae, type: "bytes" });
  let fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    let ve = oe === "right";
    fe[ve ? ye : ae - ye - 1] = ne[ve ? ye : ne.length - ye - 1];
  }
  return fe;
}
var QA = Y(() => {
  GA();
}), ex, tx, rx, nx = Y(() => {
  Ec(), ex = class extends kt {
    constructor({ max: ne, min: oe, signed: ae, size: fe, value: ye }) {
      super(`Number "${ye}" is not in safe ${fe ? `${fe * 8}-bit ${ae ? "signed" : "unsigned"} ` : ""}integer range ${ne ? `(${oe} to ${ne})` : `(above ${oe})`}`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "IntegerOutOfRangeError" });
    }
  }, tx = class extends kt {
    constructor(ne) {
      super(`Bytes value "${ne}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidBytesBooleanError" });
    }
  }, rx = class extends kt {
    constructor({ givenSize: ne, maxSize: oe }) {
      super(`Size cannot exceed ${oe} bytes. Given size: ${ne} bytes.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeOverflowError" });
    }
  };
});
function Dh(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
var KA = Y(() => {
});
function Xi(ne, { size: oe }) {
  if (oi(ne) > oe)
    throw new rx({ givenSize: oi(ne), maxSize: oe });
}
function XA(ne, oe = {}) {
  let { signed: ae } = oe;
  oe.size && Xi(ne, { size: oe.size });
  let fe = BigInt(ne);
  if (!ae)
    return fe;
  let ye = (ne.length - 2) / 2, ve = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= ve ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function Nh(ne, oe = {}) {
  return Number(XA(ne, oe));
}
var Lh = Y(() => {
  nx(), Ch();
});
function F4(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? xt(ne, oe) : typeof ne == "string" ? Ige(ne, oe) : typeof ne == "boolean" ? zge(ne, oe) : _a(ne, oe);
}
function zge(ne, oe = {}) {
  let ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function _a(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += Fge[ne[ye]];
  let fe = `0x${ae}`;
  return typeof oe.size == "number" ? (Xi(fe, { size: oe.size }), fs(fe, { dir: "right", size: oe.size })) : fe;
}
function xt(ne, oe = {}) {
  let { signed: ae, size: fe } = oe, ye = BigInt(ne), ve;
  fe ? ae ? ve = (1n << BigInt(fe) * 8n - 1n) - 1n : ve = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (ve = BigInt(Number.MAX_SAFE_INTEGER));
  let _e = typeof ve == "bigint" && ae ? -ve - 1n : 0;
  if (ve && ye > ve || ye < _e) {
    let Oe = typeof ne == "bigint" ? "n" : "";
    throw new ex({ max: ve ? `${ve}${Oe}` : void 0, min: `${_e}${Oe}`, signed: ae, size: fe, value: `${ne}${Oe}` });
  }
  let xe = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? fs(xe, { size: fe }) : xe;
}
function Ige(ne, oe = {}) {
  let ae = qge.encode(ne);
  return _a(ae, oe);
}
var Fge, qge, ui = Y(() => {
  nx(), QA(), Lh(), Fge = Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0")), qge = new TextEncoder();
});
function ix(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? Vge(ne, oe) : typeof ne == "boolean" ? Hge(ne, oe) : eo(ne) ? ax(ne, oe) : JA(ne, oe);
}
function Hge(ne, oe = {}) {
  let ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function z4(ne) {
  if (ne >= Du.zero && ne <= Du.nine)
    return ne - Du.zero;
  if (ne >= Du.A && ne <= Du.F)
    return ne - (Du.A - 10);
  if (ne >= Du.a && ne <= Du.f)
    return ne - (Du.a - 10);
}
function ax(ne, oe = {}) {
  let ae = ne;
  oe.size && (Xi(ae, { size: oe.size }), ae = fs(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  let ye = fe.length / 2, ve = new Uint8Array(ye);
  for (let _e = 0, xe = 0; _e < ye; _e++) {
    let Oe = z4(fe.charCodeAt(xe++)), $e = z4(fe.charCodeAt(xe++));
    if (Oe === void 0 || $e === void 0)
      throw new kt(`Invalid byte sequence ("${fe[xe - 2]}${fe[xe - 1]}" in "${fe}").`);
    ve[_e] = Oe * 16 + $e;
  }
  return ve;
}
function Vge(ne, oe) {
  let ae = xt(ne, oe);
  return ax(ae);
}
function JA(ne, oe = {}) {
  let ae = Bge.encode(ne);
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { dir: "right", size: oe.size })) : ae;
}
var Bge, Du, jh = Y(() => {
  Ec(), op(), QA(), Lh(), ui(), Bge = new TextEncoder(), Du = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
});
function ZA(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function eP(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function tP(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function q4(ne, oe) {
  eP(ne);
  let ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
var I4 = Y(() => {
});
function $ge(ne, oe = !1) {
  return oe ? { h: Number(ne & ox), l: Number(ne >> B4 & ox) } : { h: Number(ne >> B4 & ox) | 0, l: Number(ne & ox) | 0 };
}
function H4(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    let { h: ve, l: _e } = $ge(ne[ye], oe);
    [ae[ye], fe[ye]] = [ve, _e];
  }
  return [ae, fe];
}
var ox, B4, V4, $4, W4, Y4, G4 = Y(() => {
  ox = BigInt(4294967295), B4 = BigInt(32), V4 = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, $4 = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, W4 = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, Y4 = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae;
});
function Gge(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function lx(ne) {
  if (typeof ne == "string" && (ne = Gge(ne)), !Wge(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function K4(ne) {
  let oe = (fe) => ne().update(lx(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function X4(ne) {
  let oe = (fe, ye) => ne(ye).update(lx(fe)).digest(), ae = ne({});
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = (fe) => ne(fe), oe;
}
var Wge, Q4, Yge, ux, J4 = Y(() => {
  if (Wge = (ne) => ne instanceof Uint8Array, Q4 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), Yge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !Yge)
    throw new Error("Non little-endian hardware is not supported");
  ux = class {
    clone() {
      return this._cloneInto();
    }
  };
});
function rbe(ne, oe = 24) {
  let ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let _e = 0; _e < 10; _e++)
      ae[_e] = ne[_e] ^ ne[_e + 10] ^ ne[_e + 20] ^ ne[_e + 30] ^ ne[_e + 40];
    for (let _e = 0; _e < 10; _e += 2) {
      let xe = (_e + 8) % 10, Oe = (_e + 2) % 10, $e = ae[Oe], Me = ae[Oe + 1], Re = Z4($e, Me, 1) ^ ae[xe], je = eV($e, Me, 1) ^ ae[xe + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[_e + Be] ^= Re, ne[_e + Be + 1] ^= je;
    }
    let ye = ne[2], ve = ne[3];
    for (let _e = 0; _e < 24; _e++) {
      let xe = rV[_e], Oe = Z4(ye, ve, xe), $e = eV(ye, ve, xe), Me = tV[_e];
      ye = ne[Me], ve = ne[Me + 1], ne[Me] = Oe, ne[Me + 1] = $e;
    }
    for (let _e = 0; _e < 50; _e += 10) {
      for (let xe = 0; xe < 10; xe++)
        ae[xe] = ne[_e + xe];
      for (let xe = 0; xe < 10; xe++)
        ne[_e + xe] ^= ~ae[(xe + 2) % 10] & ae[(xe + 4) % 10];
    }
    ne[0] ^= ebe[fe], ne[1] ^= tbe[fe];
  }
  ae.fill(0);
}
var tV, rV, nV, Qge, Uh, Kge, Xge, Jge, Zge, ebe, tbe, Z4, eV, lp, ds, iV, aV, oV = Y(() => {
  I4(), G4(), J4(), [tV, rV, nV] = [[], [], []], Qge = BigInt(0), Uh = BigInt(1), Kge = BigInt(2), Xge = BigInt(7), Jge = BigInt(256), Zge = BigInt(113);
  for (let ne = 0, oe = Uh, ae = 1, fe = 0; ne < 24; ne++) {
    [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], tV.push(2 * (5 * fe + ae)), rV.push((ne + 1) * (ne + 2) / 2 % 64);
    let ye = Qge;
    for (let ve = 0; ve < 7; ve++)
      oe = (oe << Uh ^ (oe >> Xge) * Zge) % Jge, oe & Kge && (ye ^= Uh << (Uh << BigInt(ve)) - Uh);
    nV.push(ye);
  }
  [ebe, tbe] = H4(nV, !0), Z4 = (ne, oe, ae) => ae > 32 ? W4(ne, oe, ae) : V4(ne, oe, ae), eV = (ne, oe, ae) => ae > 32 ? Y4(ne, oe, ae) : $4(ne, oe, ae), lp = class extends ux {
    constructor(ne, oe, ae, fe = !1, ye = 24) {
      if (super(), this.blockLen = ne, this.suffix = oe, this.outputLen = ae, this.enableXOF = fe, this.rounds = ye, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ZA(ae), 0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = Q4(this.state);
    }
    keccak() {
      rbe(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
    }
    update(ne) {
      tP(this);
      let { blockLen: oe, state: ae } = this;
      ne = lx(ne);
      let fe = ne.length;
      for (let ye = 0; ye < fe; ) {
        let ve = Math.min(oe - this.pos, fe - ye);
        for (let _e = 0; _e < ve; _e++)
          ae[this.pos++] ^= ne[ye++];
        this.pos === oe && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = !0;
      let { state: ne, suffix: oe, pos: ae, blockLen: fe } = this;
      ne[ae] ^= oe, oe & 128 && ae === fe - 1 && this.keccak(), ne[fe - 1] ^= 128, this.keccak();
    }
    writeInto(ne) {
      tP(this, !1), eP(ne), this.finish();
      let oe = this.state, { blockLen: ae } = this;
      for (let fe = 0, ye = ne.length; fe < ye; ) {
        this.posOut >= ae && this.keccak();
        let ve = Math.min(ae - this.posOut, ye - fe);
        ne.set(oe.subarray(this.posOut, this.posOut + ve), fe), this.posOut += ve, fe += ve;
      }
      return ne;
    }
    xofInto(ne) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(ne);
    }
    xof(ne) {
      return ZA(ne), this.xofInto(new Uint8Array(ne));
    }
    digestInto(ne) {
      if (q4(ne, this), this.finished)
        throw new Error("digest() was already called");
      return this.writeInto(ne), this.destroy(), ne;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = !0, this.state.fill(0);
    }
    _cloneInto(ne) {
      let { blockLen: oe, suffix: ae, outputLen: fe, rounds: ye, enableXOF: ve } = this;
      return ne || (ne = new lp(oe, ae, fe, ve, ye)), ne.state32.set(this.state32), ne.pos = this.pos, ne.posOut = this.posOut, ne.finished = this.finished, ne.rounds = ye, ne.suffix = ae, ne.outputLen = fe, ne.enableXOF = ve, ne.destroyed = this.destroyed, ne;
    }
  }, ds = (ne, oe, ae) => K4(() => new lp(oe, ne, ae)), ds(6, 144, 224 / 8), ds(6, 136, 256 / 8), ds(6, 104, 384 / 8), ds(6, 72, 512 / 8), ds(1, 144, 224 / 8), iV = ds(1, 136, 256 / 8), ds(1, 104, 384 / 8), ds(1, 72, 512 / 8), aV = (ne, oe, ae) => X4((fe = {}) => new lp(oe, ne, fe.dkLen === void 0 ? ae : fe.dkLen, !0)), aV(31, 168, 128 / 8), aV(31, 136, 256 / 8);
});
function sx(ne, oe) {
  let ae = oe || "hex", fe = iV(eo(ne, { strict: !1 }) ? ix(ne) : ne);
  return ae === "bytes" ? fe : F4(fe);
}
var rP = Y(() => {
  oV(), op(), jh(), ui();
});
function uV(ne) {
  return nbe(ne);
}
var nbe, lV = Y(() => {
  jh(), rP(), nbe = (ne) => sx(ix(ne));
});
function sV(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", ve = !1;
  for (let _e = 0; _e < ne.length; _e++) {
    let xe = ne[_e];
    if (["(", ")", ","].includes(xe) && (oe = !0), xe === "(" && fe++, xe === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (xe === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += xe, xe === ")") {
          ve = !0;
          break;
        }
        continue;
      }
      if (xe === " ") {
        ne[_e - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += xe, ae += xe;
    }
  }
  if (!ve)
    throw new kt("Unable to normalize signature.");
  return ye;
}
var cV = Y(() => {
  Ec();
}), fV, dV = Y(() => {
  M4(), cV(), fV = (ne) => {
    let oe = (() => typeof ne == "string" ? ne : YA(ne))();
    return sV(oe);
  };
});
function cx(ne) {
  return uV(fV(ne));
}
var nP = Y(() => {
  lV(), dV();
}), pV, vV = Y(() => {
  nP(), pV = cx;
});
function mV(ne, oe) {
  let ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = sx(JA(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let ve = 0; ve < 40; ve += 2)
    fe[ve >> 1] >> 4 >= 8 && ye[ve] && (ye[ve] = ye[ve].toUpperCase()), (fe[ve >> 1] & 15) >= 8 && ye[ve + 1] && (ye[ve + 1] = ye[ve + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
var hV = Y(() => {
  jh(), rP();
});
function Fh(ne, oe, ae, { strict: fe } = {}) {
  return eo(ne, { strict: !1 }) ? ibe(ne, oe, ae, { strict: fe }) : iP(ne, oe, ae, { strict: fe });
}
function yV(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > oi(ne) - 1)
    throw new Ph({ offset: oe, position: "start", size: oi(ne) });
}
function gV(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && oi(ne) !== ae - oe)
    throw new Ph({ offset: ae, position: "end", size: oi(ne) });
}
function iP(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = ne.slice(oe, ae);
  return fe && gV(ye, oe, ae), ye;
}
function ibe(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && gV(ye, oe, ae), ye;
}
var fx = Y(() => {
  GA(), op(), Ch();
});
function aP(ne) {
  let oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? [oe[2] ? Number(oe[2]) : null, oe[1]] : void 0;
}
var bV = Y(() => {
}), SV, _V = Y(() => {
  fx(), nP(), SV = (ne) => Fh(cx(ne), 0, 4);
}), zh, sp, dx, oP = Y(() => {
  Ec(), zh = class extends kt {
    constructor({ offset: ne }) {
      super(`Offset \`${ne}\` cannot be negative.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "NegativeOffsetError" });
    }
  }, sp = class extends kt {
    constructor({ length: ne, position: oe }) {
      super(`Position \`${oe}\` is out of bounds (\`0 < position < ${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "PositionOutOfBoundsError" });
    }
  }, dx = class extends kt {
    constructor({ count: ne, limit: oe }) {
      super(`Recursive read limit of \`${oe}\` exceeded (recursive read count: \`${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "RecursiveReadLimitExceededError" });
    }
  };
});
function wV(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  let ae = Object.create(abe);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
var abe, xV = Y(() => {
  oP(), abe = { bytes: new Uint8Array(), dataView: new DataView(new ArrayBuffer(0)), position: 0, positionReadCount: /* @__PURE__ */ new Map(), recursiveReadCount: 0, recursiveReadLimit: 1 / 0, assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new dx({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit });
  }, assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new sp({ length: this.bytes.length, position: ne });
  }, decrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  }, getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  }, incrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  }, inspectByte(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectBytes(ne, oe) {
    let ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  }, inspectUint8(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectUint16(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  }, inspectUint24(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  }, inspectUint32(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  }, pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  }, pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  }, pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  }, pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  }, readByte() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectByte();
    return this.position++, ne;
  }, readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    let ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  }, readUint8() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint8();
    return this.position += 1, ne;
  }, readUint16() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint16();
    return this.position += 2, ne;
  }, readUint24() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint24();
    return this.position += 3, ne;
  }, readUint32() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint32();
    return this.position += 4, ne;
  }, get remaining() {
    return this.bytes.length - this.position;
  }, setPosition(ne) {
    let oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  }, _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    let ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  } };
});
function EV(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return XA(ae, oe);
}
function CV(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae)), ae.length > 1 || ae[0] > 1)
    throw new tx(ae);
  return !!ae[0];
}
function zo(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return Nh(ae, oe);
}
function RV(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
var OV = Y(() => {
  nx(), KA(), Lh(), ui();
});
function Ih(ne, oe) {
  let ae = typeof oe == "string" ? ax(oe) : oe, fe = wV(ae);
  if (oi(ae) === 0 && ne.length > 0)
    throw new Rh();
  if (oi(oe) && oi(oe) < 32)
    throw new Cc({ data: typeof oe == "string" ? oe : _a(oe), params: ne, size: oi(oe) });
  let ye = 0, ve = [];
  for (let _e = 0; _e < ne.length; ++_e) {
    let xe = ne[_e];
    fe.setPosition(ye);
    let [Oe, $e] = cp(fe, xe, { staticPosition: 0 });
    ye += $e, ve.push(Oe);
  }
  return ve;
}
function cp(ne, oe, { staticPosition: ae }) {
  let fe = aP(oe.type);
  if (fe) {
    let [ye, ve] = fe;
    return ube(ne, { ...oe, type: ve }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return fbe(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return obe(ne);
  if (oe.type === "bool")
    return lbe(ne);
  if (oe.type.startsWith("bytes"))
    return sbe(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return cbe(ne, oe);
  if (oe.type === "string")
    return dbe(ne, { staticPosition: ae });
  throw new Ah(oe.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
function obe(ne) {
  let oe = ne.readBytes(32);
  return [mV(_a(iP(oe, -20))), 32];
}
function ube(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    let _e = zo(ne.readBytes(uP)), xe = fe + _e, Oe = xe + TV;
    ne.setPosition(xe);
    let $e = zo(ne.readBytes(TV)), Me = qh(oe), Re = 0, je = [];
    for (let Be = 0; Be < $e; ++Be) {
      ne.setPosition(Oe + (Me ? Be * 32 : Re));
      let [ze, He] = cp(ne, oe, { staticPosition: Oe });
      Re += He, je.push(ze);
    }
    return ne.setPosition(fe + 32), [je, 32];
  }
  if (qh(oe)) {
    let _e = zo(ne.readBytes(uP)), xe = fe + _e, Oe = [];
    for (let $e = 0; $e < ae; ++$e) {
      ne.setPosition(xe + $e * 32);
      let [Me] = cp(ne, oe, { staticPosition: xe });
      Oe.push(Me);
    }
    return ne.setPosition(fe + 32), [Oe, 32];
  }
  let ye = 0, ve = [];
  for (let _e = 0; _e < ae; ++_e) {
    let [xe, Oe] = cp(ne, oe, { staticPosition: fe + ye });
    ye += Oe, ve.push(xe);
  }
  return [ve, ye];
}
function lbe(ne) {
  return [CV(ne.readBytes(32), { size: 32 }), 32];
}
function sbe(ne, oe, { staticPosition: ae }) {
  let [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    let ve = zo(ne.readBytes(32));
    ne.setPosition(ae + ve);
    let _e = zo(ne.readBytes(32));
    if (_e === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    let xe = ne.readBytes(_e);
    return ne.setPosition(ae + 32), [_a(xe), 32];
  }
  return [_a(ne.readBytes(parseInt(ye), 32)), 32];
}
function cbe(ne, oe) {
  let ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [fe > 48 ? EV(ye, { signed: ae }) : zo(ye, { signed: ae }), 32];
}
function fbe(ne, oe, { staticPosition: ae }) {
  let fe = oe.components.length === 0 || oe.components.some(({ name: _e }) => !_e), ye = fe ? [] : {}, ve = 0;
  if (qh(oe)) {
    let _e = zo(ne.readBytes(uP)), xe = ae + _e;
    for (let Oe = 0; Oe < oe.components.length; ++Oe) {
      let $e = oe.components[Oe];
      ne.setPosition(xe + ve);
      let [Me, Re] = cp(ne, $e, { staticPosition: xe });
      ve += Re, ye[fe ? Oe : $e == null ? void 0 : $e.name] = Me;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let _e = 0; _e < oe.components.length; ++_e) {
    let xe = oe.components[_e], [Oe, $e] = cp(ne, xe, { staticPosition: ae });
    ye[fe ? _e : xe == null ? void 0 : xe.name] = Oe, ve += $e;
  }
  return [ye, ve];
}
function dbe(ne, { staticPosition: oe }) {
  let ae = zo(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  let ye = zo(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  let ve = ne.readBytes(ye, 32), _e = RV(Dh(ve));
  return ne.setPosition(oe + 32), [_e, 32];
}
function qh(ne) {
  var fe;
  let { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(qh);
  let ae = aP(ne.type);
  return !!(ae && qh({ ...ne, type: ae[1] }));
}
var TV, uP, lP = Y(() => {
  ap(), hV(), xV(), Ch(), fx(), KA(), OV(), jh(), ui(), bV(), TV = 32, uP = 32;
}), kV, AV = Y(() => {
  kV = { gwei: 9, wei: 18 };
});
function sP(ne, oe) {
  let ae = ne.toString(), fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, ve] = [ae.slice(0, ae.length - oe), ae.slice(ae.length - oe)];
  return ve = ve.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${ve ? `.${ve}` : ""}`;
}
var PV = Y(() => {
});
function MV(ne, { format: oe }) {
  if (!oe)
    return {};
  let ae = {};
  function fe(ve) {
    let _e = Object.keys(ve);
    for (let xe of _e)
      xe in ne && (ae[xe] = ne[xe]), ve[xe] && typeof ve[xe] == "object" && !Array.isArray(ve[xe]) && fe(ve[xe]);
  }
  let ye = oe(ne || {});
  return fe(ye), ae;
}
var DV = Y(() => {
});
function NV(ne) {
  let oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => _a(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = xt(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = xt(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = xt(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = xt(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = xt(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = xt(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = pbe[ne.type]), typeof ne.value < "u" && (oe.value = xt(ne.value)), oe;
}
var pbe, LV = Y(() => {
  ui(), pbe = { legacy: "0x0", eip2930: "0x1", eip1559: "0x2", eip4844: "0x3" };
});
function cP(ne) {
  let { abi: oe, data: ae, strict: fe, topics: ye } = ne, ve = fe ?? !0, [_e, ...xe] = ye;
  if (!_e)
    throw new Oh({ docsPath: jV });
  let Oe = oe.find((He) => He.type === "event" && _e === pV(ip(He)));
  if (!(Oe && "name" in Oe) || Oe.type !== "event")
    throw new Rc(_e, { docsPath: jV });
  let { name: $e, inputs: Me } = Oe, Re = Me == null ? void 0 : Me.some((He) => !("name" in He && He.name)), je = Re ? [] : {}, Be = Me.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    let qe = Be[He], Ye = xe[He];
    if (!Ye)
      throw new kh({ abiItem: Oe, param: qe });
    je[Re ? He : qe.name || He] = vbe({ param: qe, value: Ye });
  }
  let ze = Me.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        let He = Ih(ze, ae);
        if (He)
          if (Re)
            je = [...je, ...He];
          else
            for (let qe = 0; qe < ze.length; qe++)
              je[ze[qe].name] = He[qe];
      } catch (He) {
        if (ve)
          throw He instanceof Cc || He instanceof sp ? new up({ abiItem: Oe, data: ae, params: ze, size: oi(ae) }) : He;
      }
    else if (ve)
      throw new up({ abiItem: Oe, data: "0x", params: ze, size: 0 });
  }
  return { eventName: $e, args: Object.values(je).length > 0 ? je : void 0 };
}
function vbe({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (Ih([ne], oe) || [])[0];
}
var jV, UV = Y(() => {
  ap(), Ch(), vV(), oP(), lP(), Zw(), jV = "/docs/contract/decodeEventLog";
});
function Bh(ne) {
  let { abi: oe, data: ae } = ne, fe = Fh(ae, 0, 4), ye = oe.find((ve) => ve.type === "function" && fe === SV(ip(ve)));
  if (!ye)
    throw new Th(fe, { docsPath: "/docs/contract/decodeFunctionData" });
  return { functionName: ye.name, args: "inputs" in ye && ye.inputs && ye.inputs.length > 0 ? Ih(ye.inputs, Fh(ae, 4)) : void 0 };
}
var FV = Y(() => {
  ap(), fx(), _V(), lP(), Zw();
});
function zV(ne, oe) {
  let [ae, fe = "0"] = ne.split("."), ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    let [ve, _e, xe] = [fe.slice(0, oe - 1), fe.slice(oe - 1, oe), fe.slice(oe)], Oe = Math.round(+`${_e}.${xe}`);
    Oe > 9 ? fe = `${BigInt(ve) + BigInt(1)}0`.padStart(ve.length + 1, "0") : fe = `${ve}${Oe}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
var qV = Y(() => {
});
function fP(ne, oe = "wei") {
  return zV(ne, kV[oe]);
}
var IV = Y(() => {
  AV(), qV();
});
async function BV(ne, { hash: oe }) {
  await ne.request({ method: `${ne.mode}_dropTransaction`, params: [oe] });
}
var HV = Y(() => {
});
async function VV(ne) {
  return ne.request({ method: `${ne.mode}_dumpState` });
}
var $V = Y(() => {
});
async function WV(ne) {
  return ne.mode === "ganache" ? await ne.request({ method: "eth_mining" }) : await ne.request({ method: `${ne.mode}_getAutomine` });
}
var YV = Y(() => {
});
async function GV(ne) {
  return await ne.request({ method: "txpool_content" });
}
var QV = Y(() => {
});
async function KV(ne) {
  let { pending: oe, queued: ae } = await ne.request({ method: "txpool_status" });
  return { pending: Nh(oe), queued: Nh(ae) };
}
var XV = Y(() => {
  Lh();
});
async function JV(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_impersonateAccount`, params: [oe] });
}
var ZV = Y(() => {
});
async function e5(ne, { seconds: oe }) {
  return await ne.request({ method: "evm_increaseTime", params: [xt(oe)] });
}
var t5 = Y(() => {
  ui();
});
async function r5(ne) {
  return await ne.request({ method: "txpool_inspect" });
}
var n5 = Y(() => {
});
async function i5(ne, { state: oe }) {
  await ne.request({ method: `${ne.mode}_loadState`, params: [oe] });
}
var a5 = Y(() => {
});
async function o5(ne, { blocks: oe, interval: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_mine", params: [{ blocks: xt(oe) }] }) : await ne.request({ method: `${ne.mode}_mine`, params: [xt(oe), xt(ae || 0)] });
}
var u5 = Y(() => {
  ui();
});
async function l5(ne) {
  await ne.request({ method: `${ne.mode}_removeBlockTimestampInterval` });
}
var s5 = Y(() => {
});
async function c5(ne, { blockNumber: oe, jsonRpcUrl: ae } = {}) {
  await ne.request({ method: `${ne.mode}_reset`, params: [{ forking: { blockNumber: Number(oe), jsonRpcUrl: ae } }] });
}
var f5 = Y(() => {
});
async function d5(ne, { id: oe }) {
  await ne.request({ method: "evm_revert", params: [oe] });
}
var p5 = Y(() => {
});
async function v5(ne, oe) {
  var He, qe, Ye;
  let { accessList: ae, data: fe, from: ye, gas: ve, gasPrice: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, nonce: $e, to: Me, value: Re, ...je } = oe, Be = (Ye = (qe = (He = ne.chain) == null ? void 0 : He.formatters) == null ? void 0 : qe.transactionRequest) == null ? void 0 : Ye.format, ze = (Be || NV)({ ...MV(je, { format: Be }), accessList: ae, data: fe, from: ye, gas: ve, gasPrice: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, nonce: $e, to: Me, value: Re });
  return await ne.request({ method: "eth_sendUnsignedTransaction", params: [ze] });
}
var m5 = Y(() => {
  DV(), LV();
});
async function h5(ne, oe) {
  ne.mode === "ganache" ? oe ? await ne.request({ method: "miner_start" }) : await ne.request({ method: "miner_stop" }) : await ne.request({ method: "evm_setAutomine", params: [oe] });
}
var y5 = Y(() => {
});
async function g5(ne, { address: oe, value: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_setAccountBalance", params: [oe, xt(ae)] }) : await ne.request({ method: `${ne.mode}_setBalance`, params: [oe, xt(ae)] });
}
var b5 = Y(() => {
  ui();
});
async function S5(ne, { gasLimit: oe }) {
  await ne.request({ method: "evm_setBlockGasLimit", params: [xt(oe)] });
}
var _5 = Y(() => {
  ui();
});
async function w5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: `${ne.mode}_setBlockTimestampInterval`, params: [ae] });
}
var x5 = Y(() => {
});
async function E5(ne, { address: oe, bytecode: ae }) {
  await ne.request({ method: `${ne.mode}_setCode`, params: [oe, ae] });
}
var C5 = Y(() => {
});
async function R5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_setCoinbase`, params: [oe] });
}
var O5 = Y(() => {
});
async function T5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: "evm_setIntervalMining", params: [ae] });
}
var k5 = Y(() => {
});
async function A5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setLoggingEnabled`, params: [oe] });
}
var P5 = Y(() => {
});
async function M5(ne, { gasPrice: oe }) {
  await ne.request({ method: `${ne.mode}_setMinGasPrice`, params: [xt(oe)] });
}
var D5 = Y(() => {
  ui();
});
async function N5(ne, { baseFeePerGas: oe }) {
  await ne.request({ method: `${ne.mode}_setNextBlockBaseFeePerGas`, params: [xt(oe)] });
}
var L5 = Y(() => {
  ui();
});
async function j5(ne, { timestamp: oe }) {
  await ne.request({ method: "evm_setNextBlockTimestamp", params: [xt(oe)] });
}
var U5 = Y(() => {
  ui();
});
async function F5(ne, { address: oe, nonce: ae }) {
  await ne.request({ method: `${ne.mode}_setNonce`, params: [oe, xt(ae)] });
}
var z5 = Y(() => {
  ui();
});
async function q5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setRpcUrl`, params: [oe] });
}
var I5 = Y(() => {
});
async function B5(ne, { address: oe, index: ae, value: fe }) {
  await ne.request({ method: `${ne.mode}_setStorageAt`, params: [oe, typeof ae == "number" ? xt(ae) : ae, fe] });
}
var H5 = Y(() => {
  ui();
});
async function V5(ne) {
  return await ne.request({ method: "evm_snapshot" });
}
var $5 = Y(() => {
});
async function W5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_stopImpersonatingAccount`, params: [oe] });
}
var Y5 = Y(() => {
});
function dP({ mode: ne }) {
  return (oe) => {
    let ae = oe.extend(() => ({ mode: ne }));
    return { dropTransaction: (fe) => BV(ae, fe), dumpState: () => VV(ae), getAutomine: () => WV(ae), getTxpoolContent: () => GV(ae), getTxpoolStatus: () => KV(ae), impersonateAccount: (fe) => JV(ae, fe), increaseTime: (fe) => e5(ae, fe), inspectTxpool: () => r5(ae), loadState: (fe) => i5(ae, fe), mine: (fe) => o5(ae, fe), removeBlockTimestampInterval: () => l5(ae), reset: (fe) => c5(ae, fe), revert: (fe) => d5(ae, fe), sendUnsignedTransaction: (fe) => v5(ae, fe), setAutomine: (fe) => h5(ae, fe), setBalance: (fe) => g5(ae, fe), setBlockGasLimit: (fe) => S5(ae, fe), setBlockTimestampInterval: (fe) => w5(ae, fe), setCode: (fe) => E5(ae, fe), setCoinbase: (fe) => R5(ae, fe), setIntervalMining: (fe) => T5(ae, fe), setLoggingEnabled: (fe) => A5(ae, fe), setMinGasPrice: (fe) => M5(ae, fe), setNextBlockBaseFeePerGas: (fe) => N5(ae, fe), setNextBlockTimestamp: (fe) => j5(ae, fe), setNonce: (fe) => F5(ae, fe), setRpcUrl: (fe) => q5(ae, fe), setStorageAt: (fe) => B5(ae, fe), snapshot: () => V5(ae), stopImpersonatingAccount: (fe) => W5(ae, fe) };
  };
}
var G5 = Y(() => {
  HV(), $V(), YV(), QV(), XV(), ZV(), t5(), n5(), a5(), u5(), s5(), f5(), p5(), m5(), y5(), b5(), _5(), x5(), C5(), O5(), k5(), P5(), D5(), L5(), U5(), z5(), I5(), H5(), $5(), Y5();
}), Hh = Y(() => {
  G5(), ap(), UV(), FV(), PV(), op(), IV();
});
function Q5() {
  var _e;
  let { publicClient: ne, walletClient: oe } = zt(), ae = (_e = oe == null ? void 0 : oe.account) == null ? void 0 : _e.address, fe = ne.chain.id === 31337 ? ne.extend(dP({ mode: "anvil" })) : null, [ye, ve] = (0, px.useState)(null);
  return (0, px.useEffect)(() => {
    if (!ne || !oe)
      return ve(null);
    let xe = oe.account;
    if (!xe)
      return ve(null);
    let Oe = async () => {
      let Me = await ne.getBalance({ address: xe.address });
      ve(Me);
    };
    Oe();
    let $e = setInterval(Oe, ne.pollingInterval);
    return () => clearInterval($e);
  }, [ne, oe]), (0, Nu.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Address" }), (0, Nu.jsx)("dd", { className: "text-sm", children: ae }), (0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Balance" }), (0, Nu.jsxs)("dd", { className: "text-sm flex items-center gap-2", title: ye ? ye.toString() : void 0, children: [ne && ye != null ? (0, Nu.jsxs)("span", { children: [sP(ye, ne.chain.nativeCurrency.decimals).replace(/(\.\d{4})\d+$/, "$1"), " ", ne.chain.nativeCurrency.symbol] }) : null, ae && fe ? (0, Nu.jsx)("button", { type: "button", className: "text-xs px-1.5 py-0.5 bg-slate-700 hover:bg-blue-700 hover:text-white rounded", onClick: () => fe.setBalance({ address: ae, value: fP("1") + (ye ?? 0n) }), children: "top up" }) : null] })] });
}
var px, Nu, K5 = Y(() => {
  px = le(ir(), 1), Hh(), ai(), Nu = le(ke(), 1);
});
function X5() {
  let { storedLogs: ne } = zt();
  return (0, Oc.jsxs)(Oc.Fragment, { children: [(0, Oc.jsx)(z0, { logs: ne.slice(-10) }), (0, Oc.jsx)(sn, { to: "/events", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] });
}
var Oc, J5 = Y(() => {
  ql(), ai(), Pk(), Oc = le(ke(), 1);
});
function pP({ className: ne }) {
  return (0, Vh.jsxs)("svg", { className: Pr("animate-spin w-[1em] h-[1em]", ne), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [(0, Vh.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), (0, Vh.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] });
}
var Vh, Z5 = Y(() => {
  uc(), Vh = le(ke(), 1);
});
function e$(ne) {
  return ne.replace(/^(0x[0-9A-F]{3})[0-9A-F]+([0-9A-F]{4})$/i, "$1$2");
}
var t$ = Y(() => {
});
function $h(ne) {
  return JSON.stringify(ne, (oe, ae) => typeof ae == "bigint" ? ae.toString() : ae);
}
var vP = Y(() => {
});
function vx(ne, oe) {
  return mP[oe.id] || (mP[oe.id] = oe.result.then((ae) => ne.getTransaction({ hash: ae }))), mP[oe.id];
}
var mP, hP = Y(() => {
  mP = {};
});
function mx(ne, oe) {
  return yP[oe.id] || (yP[oe.id] = oe.result.then((ae) => ne.waitForTransactionReceipt({ hash: ae }))), yP[oe.id];
}
var yP, gP = Y(() => {
  yP = {};
});
function r$(ne, oe, ae) {
  if (!bP[ae.id]) {
    let fe = vx(ne, ae), ye = mx(ne, ae);
    bP[ae.id] = Promise.all([fe, ye]).then(([ve, _e]) => {
      let { functionName: xe, args: Oe } = Bh({ abi: oe, data: ve.input });
      return ne.simulateContract({ account: ve.from, address: ve.to, abi: oe, functionName: xe, args: Oe, blockNumber: _e.blockNumber - 1n, value: ve.value });
    });
  }
  return bP[ae.id];
}
var bP, n$ = Y(() => {
  Hh(), hP(), gP(), bP = {};
});
function hx({ write: ne }) {
  var Ye, pt, dt;
  let { publicClient: oe, worldAbi: ae } = zt(), fe = (Ye = oe.chain.blockExplorers) == null ? void 0 : Ye.default.url, ye = _h(ne.result), ve = vx(oe, ne), _e = mx(oe, ne), xe = r$(oe, ae, ne), Oe = _h(ve), $e = _h(_e), Me = _h(xe), Re = ye.status === "pending" || $e.status === "pending", je = ye.status === "rejected" || $e.status === "fulfilled" && $e.value.status === "reverted", Be = Me.status === "fulfilled" ? Me.value.result : null, ze = ae && $e.status === "fulfilled" ? $e.value.logs.map((yt) => {
    try {
      return cP({ abi: ae, ...yt });
    } catch (Ct) {
      if (Ct instanceof Rc)
        return;
      throw Ct;
    }
  }).filter(b$7) : null, He = ne.request.functionName, qe = ne.request.args;
  if (He === "call" || He === "callFrom") {
    let yt = (dt = (pt = ne.request) == null ? void 0 : pt.args) != null && dt.length ? ne.request.args[ne.request.args.length - 1] : "0x", Ct = Bh({ abi: ae, data: yt });
    He = Ct.functionName, qe = Ct.args;
  }
  return (0, nt.jsxs)("details", { onToggle: (yt) => {
    yt.currentTarget.open && (console.log("transaction", Oe), console.log("transaction receipt", $e), console.log("transaction result", Me));
  }, children: [(0, nt.jsxs)("summary", { className: Pr("px-2 py-1 rounded flex items-center gap-2 border-2 border-transparent border-dashed cursor-pointer", Re ? "border-white/20 cursor-default" : je ? "bg-red-800" : "bg-slate-700"), children: [(0, nt.jsxs)("div", { className: "flex-1 font-mono text-white whitespace-nowrap overflow-hidden text-ellipsis", children: [He, "(", qe == null ? void 0 : qe.map((yt) => $h(yt)).join(", "), ")", " ", ne.request.functionName !== He ? (0, nt.jsxs)("span", { className: "text-xs text-white/40", children: ["via ", ne.request.functionName] }) : null] }), $e.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/block/${$e.value.blockNumber.toString()}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: $e.value.blockNumber.toString(), children: ["block ", $e.value.blockNumber.toString()] }) : null, ye.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/tx/${ye.value}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: ye.value, children: ["tx ", e$(ye.value)] }) : null, (0, nt.jsx)("div", { className: "flex-none inline-flex w-4 h-4 justify-center items-center font-bold", children: Re ? (0, nt.jsx)(pP, {}) : je ? (0, nt.jsx)(nt.Fragment, { children: "" }) : (0, nt.jsx)(nt.Fragment, { children: "" }) })] }), (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Result" }), Me.status === "fulfilled" ? (0, nt.jsx)("div", { className: "font-mono", children: $h(Be) }) : Me.status === "rejected" ? (0, nt.jsx)(U0, { error: Me.reason }) : (0, nt.jsx)(pP, {})] }), ze != null && ze.length ? (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Store events" }), (0, nt.jsxs)("table", { className: "w-full table-fixed", children: [(0, nt.jsx)("thead", { className: "bg-slate-800 text-amber-200/80 text-left", children: (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "table" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-[1em]" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "key" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs", children: "value" })] }) }), (0, nt.jsx)("tbody", { className: "font-mono text-xs", children: ze.map(({ eventName: yt, args: Ct }, It) => {
    let Vt = _$4(Ct.tableId);
    return (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: i$6(Vt) }), (0, nt.jsxs)("td", { className: "whitespace-nowrap", children: [yt === "Store_SetRecord" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "=" }) : null, yt === "Store_SpliceStaticData" || yt === "Store_SpliceDynamicData" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "+" }) : null, yt === "Store_DeleteRecord" ? (0, nt.jsx)("span", { className: "text-red-500 font-bold", children: "-" }) : null] }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: d$1(Ct.keyTuple) }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: Ct.data })] }, It);
  }) })] })] }) : null] });
}
var nt, SP = Y(() => {
  Hh(), uc(), Z5(), wh(), t$(), vP(), hP(), gP(), n$(), Ak(), ai(), nt = le(ke(), 1);
});
function i$() {
  let { writes: ne } = zt();
  return (0, to.jsx)(to.Fragment, { children: ne.length ? (0, to.jsxs)(to.Fragment, { children: [(0, to.jsx)("div", { className: "space-y-1", children: ne.slice(-5).map((oe) => (0, to.jsx)(hx, { write: oe }, oe.id)) }), (0, to.jsx)(sn, { to: "/actions", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] }) : (0, to.jsx)("div", { children: "Waiting for transactions" }) });
}
var to, a$ = Y(() => {
  ql(), ai(), SP(), to = le(ke(), 1);
});
function fp() {
  let { useStore: ne } = zt();
  if (!ne)
    throw new Error("Missing useStore");
  let [oe, ae] = (0, yx.useState)(ne.getState().tables);
  return (0, yx.useEffect)(() => ne.subscribe((fe) => {
    fe.tables !== oe && ae(fe.tables);
  }), [ne, oe]), Object.values(oe);
}
var yx, gx = Y(() => {
  ai(), yx = le(ir(), 1);
});
function o$() {
  let ne = fp();
  return (0, _P.jsx)("div", { className: "flex flex-col gap-1 items-start", children: ne.map((oe) => (0, _P.jsx)(sn, { to: `/tables/${oe.tableId}`, className: "font-mono text-xs hover:text-white", children: i$6(oe) }, oe.tableId)) });
}
var _P, u$ = Y(() => {
  ql(), gx(), _P = le(ke(), 1);
});
function Lu(ne) {
  var oe, ae;
  return String(((oe = ne.metadata) == null ? void 0 : oe.tableName) ?? ((ae = ne.metadata) == null ? void 0 : ae.componentName) ?? ne.id);
}
var wP = Y(() => {
});
function l$({ world: ne }) {
  let oe = [...ne.components].sort((ae, fe) => Lu(ae).localeCompare(Lu(fe)));
  return (0, ju.jsx)(ju.Fragment, { children: oe.length ? (0, ju.jsx)(ju.Fragment, { children: (0, ju.jsx)("div", { className: "flex flex-col gap-1 items-start", children: oe.map((ae) => (0, ju.jsx)(sn, { to: `/components/${ae.id}`, className: "font-mono text-xs hover:text-white", children: Lu(ae) }, ae.id)) }) }) : (0, ju.jsx)("div", { children: "Waiting for components" }) });
}
var ju, s$ = Y(() => {
  ql(), wP(), ju = le(ke(), 1);
}), xP, c$ = Y(() => {
  xP = { name: "@latticexyz/dev-tools", version: "2.1.0", description: "MUD developer tools", repository: { type: "git", url: "https://github.com/latticexyz/mud.git", directory: "packages/dev-tools" }, license: "MIT", type: "module", exports: { ".": "./dist/index.js" }, typesVersions: { "*": { index: ["./dist/index.d.ts"] } }, files: ["dist"], scripts: { build: "pnpm run build:js", "build:js": "tsup", clean: "pnpm run clean:js", "clean:js": "rimraf dist", dev: "tsup --watch", test: "tsc --noEmit", "test:ci": "pnpm run test" }, dependencies: { "@latticexyz/common": "workspace:*", "@latticexyz/react": "workspace:*", "@latticexyz/recs": "workspace:*", "@latticexyz/schema-type": "workspace:*", "@latticexyz/store": "workspace:*", "@latticexyz/store-sync": "workspace:*", "@latticexyz/utils": "workspace:*", "@latticexyz/world": "workspace:*", react: "^18.2.0", "react-dom": "^18.2.0", "react-router-dom": "^6.11.0", rxjs: "7.5.5", "tailwind-merge": "^1.12.0", "use-local-storage-state": "^18.3.2", viem: "2.9.20", zustand: "^4.3.7" }, devDependencies: { "@types/react": "18.2.22", "@types/react-dom": "18.2.7", "@types/ws": "^8.5.4", autoprefixer: "^10.4.14", postcss: "^8.4.23", tailwindcss: "^3.3.2", tsup: "^6.7.0", vitest: "0.34.6" }, peerDependencies: { "@latticexyz/common": "2.x", "@latticexyz/recs": "2.x", "@latticexyz/store": "2.x", "@latticexyz/store-sync": "2.x", "@latticexyz/utils": "2.x", "@latticexyz/world": "2.x" }, publishConfig: { access: "public" } };
});
function f$() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Dt.jsxs)("div", { className: "h-full flex flex-col", children: [(0, Dt.jsxs)("div", { className: "flex-grow p-6 space-y-8 relative", children: [(0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Network" }), (0, Dt.jsx)(E4, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Account" }), (0, Dt.jsx)(Q5, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent actions" }), (0, Dt.jsx)(i$, {})] }), (0, Dt.jsxs)("div", { className: "space-y-1", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent store events" }), (0, Dt.jsx)(X5, {})] }), oe ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Tables" }), (0, Dt.jsx)(o$, {})] }) : null, ne ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Components" }), (0, Dt.jsx)(l$, { world: ne })] }) : null] }), (0, Dt.jsxs)("div", { className: "p-2 text-right font-mono text-xs leading-none text-white/20", children: ["MUD ", _be ? (0, Dt.jsxs)(Dt.Fragment, { children: ["v", xP.version] }) : (0, Dt.jsx)(Dt.Fragment, { children: "linked" })] })] });
}
var Dt, _be, d$ = Y(() => {
  C4(), K5(), J5(), a$(), u$(), s$(), c$(), ai(), Dt = le(ke(), 1), _be = Object.entries(xP.dependencies).some(([ne, oe]) => ne.startsWith("@latticexyz/") && oe.startsWith("link:"));
});
function p$() {
  let { writes: ne } = zt(), oe = (0, dp.useRef)(null), ae = (0, dp.useRef)(!1), fe = (0, dp.useRef)("auto");
  return (0, dp.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, pp.jsx)("div", { ref: oe, className: "p-4 space-y-2", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: ne.length ? ne.map((ye) => (0, pp.jsx)(hx, { write: ye }, ye.id)) : (0, pp.jsx)(pp.Fragment, { children: "Waiting for transactions" }) });
}
var dp, pp, v$ = Y(() => {
  dp = le(ir(), 1), SP(), ai(), pp = le(ke(), 1);
});
function m$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let oe = [...ne.components].sort((_e, xe) => Lu(_e).localeCompare(Lu(xe))), { id: ae } = Tu(), fe = oe.find((_e) => _e.id === ae) ?? oe[0], ye = (0, Wh.useRef)(null), ve = Ou();
  return (0, Wh.useEffect)(() => {
    ae !== fe.id && ve(fe.id);
  }, [ae, fe.id]), (0, Wh.useEffect)(() => {
    let _e = (xe) => {
      ye.current && (xe.target instanceof Node && ye.current.contains(xe.target) || (ye.current.open = !1));
    };
    return window.addEventListener("click", _e), () => window.removeEventListener("click", _e);
  }), (0, fn.jsxs)("div", { className: "p-6 space-y-4", children: [oe.length ? (0, fn.jsxs)("div", { className: "space-y-2", children: [(0, fn.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Component" }), (0, fn.jsxs)("details", { ref: ye, className: "pointer-events-none select-none", children: [(0, fn.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, fn.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [fe ? (0, fn.jsx)("span", { className: "font-mono", children: Lu(fe) }) : (0, fn.jsx)("span", { children: "Pick a component" }), (0, fn.jsx)("span", { className: "text-white/40 text-xs", children: "" })] }) }), (0, fn.jsx)("div", { className: "relative", children: (0, fn.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: oe.map((_e) => (0, fn.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", _e === fe ? "bg-slate-600" : null), to: _e.id, onClick: () => {
    ye.current && (ye.current.open = !1);
  }, children: Lu(_e) }, _e.id)) }) })] })] }) : (0, fn.jsx)(fn.Fragment, { children: "Waiting for components" }), (0, fn.jsx)(cc, {})] });
}
var Wh, fn, h$ = Y(() => {
  Do(), ql(), Wh = le(ir(), 1), uc(), ai(), wP(), fn = le(ke(), 1);
});
function y$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, ro.jsxs)("table", { className: "w-full -mx-1", children: [(0, ro.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, ro.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [(0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: "entity" }), Object.keys(ne.schema).map((ae) => (0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, ro.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = de(ne, ae);
    return (0, ro.jsxs)("tr", { children: [(0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ae }), Object.keys(ne.schema).map((ye) => {
      let ve = fe[ye];
      return (0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ne.schema[ye] === P$3.T ? $h(ve) : Array.isArray(ve) ? ve.map(String).join(", ") : String(ve) }, ye);
    })] }, ae);
  }) })] });
}
var ro, g$ = Y(() => {
  wh(), vP(), ro = le(ke(), 1);
});
function b$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, no.jsxs)("table", { className: "w-full -mx-1", children: [(0, no.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, no.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [Object.keys(ne.metadata.keySchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae)), Object.keys(ne.metadata.valueSchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, no.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = vt(ne.metadata.keySchema, ae), ye = de(ne, ae);
    return (0, no.jsxs)("tr", { children: [Object.keys(ne.metadata.keySchema).map((ve) => (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: String(fe[ve]) }, ve)), Object.keys(ne.metadata.valueSchema).map((ve) => {
      let _e = ye[ve];
      return (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: Array.isArray(_e) ? _e.map(String).join(", ") : String(_e) }, ve);
    })] }, ae);
  }) })] });
}
var no, S$ = Y(() => {
  wh(), no = le(ke(), 1);
});
function _$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let { id: oe } = Tu(), ae = ne.components.find((fe) => fe.id === oe);
  return ae ? Pt(ae) ? (0, EP.jsx)(b$, { component: ae }, ae.id) : (0, EP.jsx)(y$, { component: ae }, ae.id) : null;
}
var EP, w$ = Y(() => {
  Do(), ai(), g$(), S$(), EP = le(ke(), 1);
});
function E$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((ve) => ve.tableId === oe) ?? ne[0], fe = (0, Yh.useRef)(null), ye = Ou();
  return (0, Yh.useEffect)(() => {
    oe !== ae.tableId && ye(ae.tableId);
  }, [oe, ae.tableId]), (0, Yh.useEffect)(() => {
    let ve = (_e) => {
      fe.current && (_e.target instanceof Node && fe.current.contains(_e.target) || (fe.current.open = !1));
    };
    return window.addEventListener("click", ve), () => window.removeEventListener("click", ve);
  }), (0, li.jsxs)("div", { className: "p-6 space-y-4", children: [(0, li.jsxs)("div", { className: "space-y-2", children: [(0, li.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Table" }), (0, li.jsxs)("details", { ref: fe, className: "pointer-events-none select-none", children: [(0, li.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, li.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [ae ? (0, li.jsx)("span", { className: "font-mono", children: i$6(ae) }) : (0, li.jsx)("span", { children: "Pick a table" }), (0, li.jsx)("span", { className: "text-white/40 text-xs", children: "" })] }) }), (0, li.jsx)("div", { className: "relative", children: (0, li.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: ne.map((ve) => (0, li.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", ve === ae ? "bg-slate-600" : null), to: ve.tableId, onClick: () => {
    fe.current && (fe.current.open = !1);
  }, children: i$6(ve) }, ve.tableId)) }) })] })] }), (0, li.jsx)(cc, {})] });
}
var Yh, li, C$ = Y(() => {
  Do(), ql(), Yh = le(ir(), 1), uc(), gx(), li = le(ke(), 1);
});
function R$(ne) {
  let { useStore: oe } = zt();
  if (!oe)
    throw new Error("Missing useStore");
  let [ae, fe] = (0, bx.useState)(oe.getState().getRecords(ne));
  return (0, bx.useEffect)(() => oe.subscribe(() => {
    let ye = oe.getState().getRecords(ne);
    ye !== ae && fe(ye);
  }), [oe, ae]), Object.values(ae);
}
var bx, O$ = Y(() => {
  ai(), bx = le(ir(), 1);
});
function T$({ hex: ne }) {
  return ne.length <= 10 ? (0, vp.jsx)("span", { children: ne }) : (0, vp.jsxs)("span", { children: [(0, vp.jsx)("span", { className: "after:content-[''] after:select-none", children: ne.slice(0, 6) }), (0, vp.jsx)("span", { className: "tracking-[-1ch] text-transparent", children: ne.slice(6, -4) }), ne.slice(-4)] });
}
var vp, k$ = Y(() => {
  vp = le(ke(), 1);
});
function CP({ value: ne }) {
  return Array.isArray(ne) ? ne.map((oe, ae) => (0, ps.jsxs)(A$.default.Fragment, { children: [ae > 0 ? ", " : null, (0, ps.jsx)(CP, { value: oe })] }, JSON.stringify({ i: ae, value: ne }))) : eo(ne) ? (0, ps.jsx)(T$, { hex: ne }) : (0, ps.jsx)(ps.Fragment, { children: String(ne) });
}
var A$, ps, P$ = Y(() => {
  A$ = le(ir(), 1), Hh(), k$(), ps = le(ke(), 1);
});
function M$({ table: ne }) {
  let oe = R$(ne);
  return (0, qo.jsxs)("table", { className: "w-full -mx-1", children: [(0, qo.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, qo.jsx)("tr", { className: "text-amber-200/80 font-mono", children: Object.keys(ne.schema).map((ae) => (0, qo.jsx)("th", { className: "px-1.5 pt-1.5 font-normal", children: ae }, ae)) }) }), (0, qo.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => (0, qo.jsx)("tr", { children: Object.keys(ne.schema).map((fe) => (0, qo.jsx)("td", { className: "px-1.5 whitespace-nowrap overflow-hidden text-ellipsis", children: (0, qo.jsx)(CP, { value: ae.fields[fe] }) }, fe)) }, ae.id)) })] });
}
var qo, D$ = Y(() => {
  O$(), P$(), qo = le(ke(), 1);
});
function N$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((fe) => fe.tableId === oe);
  return ae ? (0, L$.jsx)(M$, { table: ae }, ae.tableId) : null;
}
var L$, j$ = Y(() => {
  Do(), D$(), gx(), L$ = le(ke(), 1);
}), Qr, U$, F$ = Y(() => {
  Do(), Fq(), Iq(), $q(), d$(), v$(), h$(), w$(), C$(), j$(), Qr = le(ke(), 1), U$ = Ek(pd((0, Qr.jsxs)(Ga, { path: "/", element: (0, Qr.jsx)(Uq, {}), errorElement: (0, Qr.jsx)(qq, {}), children: [(0, Qr.jsx)(Ga, { index: !0, element: (0, Qr.jsx)(f$, {}) }), (0, Qr.jsx)(Ga, { path: "actions", element: (0, Qr.jsx)(p$, {}) }), (0, Qr.jsx)(Ga, { path: "events", element: (0, Qr.jsx)(Vq, {}) }), (0, Qr.jsx)(Ga, { path: "tables", element: (0, Qr.jsx)(E$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(N$, {}) }) }), (0, Qr.jsx)(Ga, { path: "components", element: (0, Qr.jsx)(m$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(_$, {}) }) })] })));
});
function TP(ne, oe) {
  if (Ai.useSyncExternalStore === void 0)
    throw new TypeError('You are using React 17 or below. Install with "npm install use-local-storage-state@17".');
  let [ae] = (0, Ai.useState)(oe == null ? void 0 : oe.defaultValue);
  if (typeof window > "u")
    return [ae, () => {
    }, { isPersistent: !0, removeItem: () => {
    } }];
  let fe = oe == null ? void 0 : oe.serializer;
  return kbe(ne, ae, oe == null ? void 0 : oe.storageSync, fe == null ? void 0 : fe.parse, fe == null ? void 0 : fe.stringify);
}
function kbe(ne, oe, ae = !0, fe = Abe, ye = JSON.stringify) {
  if (!Tc.has(ne) && oe !== void 0 && localStorage.getItem(ne) === null)
    try {
      localStorage.setItem(ne, ye(oe));
    } catch {
    }
  let ve = (0, Ai.useRef)({ item: null, parsed: oe }), _e = (0, Ai.useSyncExternalStore)((0, Ai.useCallback)((Oe) => {
    let $e = (Me) => {
      ne === Me && Oe();
    };
    return OP.add($e), () => {
      OP.delete($e);
    };
  }, [ne]), () => {
    let Oe = localStorage.getItem(ne);
    if (Tc.has(ne))
      ve.current = { item: Oe, parsed: Tc.get(ne) };
    else if (Oe !== ve.current.item) {
      let $e;
      try {
        $e = Oe === null ? oe : fe(Oe);
      } catch {
        $e = oe;
      }
      ve.current = { item: Oe, parsed: $e };
    }
    return ve.current.parsed;
  }, () => oe), xe = (0, Ai.useCallback)((Oe) => {
    let $e = Oe instanceof Function ? Oe(ve.current.parsed) : Oe;
    try {
      localStorage.setItem(ne, ye($e)), Tc.delete(ne);
    } catch {
      Tc.set(ne, $e);
    }
    RP(ne);
  }, [ne, ye]);
  return (0, Ai.useEffect)(() => {
    if (!ae)
      return;
    let Oe = ($e) => {
      $e.storageArea === localStorage && $e.key === ne && RP(ne);
    };
    return window.addEventListener("storage", Oe), () => window.removeEventListener("storage", Oe);
  }, [ne, ae]), (0, Ai.useMemo)(() => [_e, xe, { isPersistent: _e === oe || !Tc.has(ne), removeItem() {
    Tc.delete(ne), localStorage.removeItem(ne), RP(ne);
  } }], [ne, xe, _e, oe]);
}
function RP(ne) {
  for (let oe of [...OP])
    oe(ne);
}
function Abe(ne) {
  return ne === "undefined" ? void 0 : JSON.parse(ne);
}
var Ai, Tc, OP, z$ = Y(() => {
  Ai = le(ir()), Tc = /* @__PURE__ */ new Map(), OP = /* @__PURE__ */ new Set();
}), q$, I$ = Y(() => {
  z$(), q$ = TP;
}), H$ = {};
Uj(H$, { App: () => Pbe });
function Pbe() {
  let [ne, oe] = q$("mud-dev-tools-shown", { defaultValue: !0 });
  return (0, B$.useEffect)(() => {
    let ae = (fe) => {
      fe.key === "`" && oe(!ne);
    };
    return window.addEventListener("keypress", ae), () => window.removeEventListener("keypress", ae);
  }), (0, io.jsx)("div", { className: "fixed inset-0 pointer-events-none", children: (0, io.jsxs)("div", { className: Pr("pointer-events-auto w-full max-w-screen-sm h-full absolute right-0", "transition duration-500", ne ? "translate-x-0" : "translate-x-full"), children: [(0, io.jsxs)("div", { className: "absolute bottom-0 right-full min-w-max flex flex-col-reverse items-end justify-center m-2 text-gray-500", children: [(0, io.jsx)("button", { type: "button", className: "peer text-sm p-2 rounded leading-none transition opacity-60 hover:opacity-100", onClick: () => oe(!ne), children: (0, io.jsxs)("span", { className: "whitespace-nowrap font-medium", children: [ne ? "" : "", " MUD Dev Tools"] }) }), (0, io.jsxs)("span", { className: "transition opacity-0 peer-hover:opacity-60 px-2 text-xs flex items-center justify-center gap-2", children: ["Keyboard shortcut", (0, io.jsx)("code", { className: "bg-gray-500/10 p-1 rounded text-mono text-xs leading-none", children: "`" })] })] }), (0, io.jsx)("div", { className: Pr("w-full h-full bg-slate-800 text-white/80 text-sm flex flex-col", "transition duration-500", ne ? "opacity-100" : "opacity-0"), children: (0, io.jsx)(xk, { router: U$ }) })] }) });
}
var B$, io, V$ = Y(() => {
  Sz(), _z(), B$ = le(ir(), 1), uc(), F$(), Do(), I$(), io = le(ke(), 1);
}), Sx = le(ke(), 1), $$ = "mud-dev-tools";
async function Mbe(ne) {
  if (typeof window > "u") {
    console.warn("MUD dev-tools should only be used in browser bundles");
    return;
  }
  if (document.getElementById($$)) {
    console.warn("MUD dev-tools is already mounted");
    return;
  }
  try {
    let oe = await Promise.resolve().then(() => le(ir(), 1)), ae = await Promise.resolve().then(() => le(bz(), 1)), { App: fe } = await Promise.resolve().then(() => (V$(), H$)), { DevToolsProvider: ye } = await Promise.resolve().then(() => (ai(), Lq)), ve = document.createElement("div");
    ve.id = $$, ve.style.position = "relative", ve.style.zIndex = "999999";
    let _e = ae.createRoot(ve);
    return _e.render((0, Sx.jsx)(oe.StrictMode, { children: (0, Sx.jsx)(ye, { value: ne, children: (0, Sx.jsx)(fe, {}) }) })), document.body.appendChild(ve), () => {
      _e.unmount(), ve.remove();
    };
  } catch (oe) {
    console.error("Failed to mount MUD dev-tools", oe);
  }
}
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.6.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
var bn = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn.exports;
(function(ne) {
  (function(oe, ae) {
    function fe(Ot, Qe) {
      if (!Ot)
        throw new Error(Qe || "Assertion failed");
    }
    function ye(Ot, Qe) {
      Ot.super_ = Qe;
      var at = function() {
      };
      at.prototype = Qe.prototype, Ot.prototype = new at(), Ot.prototype.constructor = Ot;
    }
    function ve(Ot, Qe, at) {
      if (ve.isBN(Ot))
        return Ot;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ot !== null && ((Qe === "le" || Qe === "be") && (at = Qe, Qe = 10), this._init(Ot || 0, Qe || 10, at || "be"));
    }
    typeof oe == "object" ? oe.exports = ve : ae.BN = ve, ve.BN = ve, ve.wordSize = 26;
    var _e;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _e = window.Buffer : _e = require$$0.Buffer;
    } catch {
    }
    ve.isBN = function(Qe) {
      return Qe instanceof ve ? !0 : Qe !== null && typeof Qe == "object" && Qe.constructor.wordSize === ve.wordSize && Array.isArray(Qe.words);
    }, ve.max = function(Qe, at) {
      return Qe.cmp(at) > 0 ? Qe : at;
    }, ve.min = function(Qe, at) {
      return Qe.cmp(at) < 0 ? Qe : at;
    }, ve.prototype._init = function(Qe, at, wt) {
      if (typeof Qe == "number")
        return this._initNumber(Qe, at, wt);
      if (typeof Qe == "object")
        return this._initArray(Qe, at, wt);
      at === "hex" && (at = 16), fe(at === (at | 0) && at >= 2 && at <= 36), Qe = Qe.toString().replace(/\s+/g, "");
      var bt = 0;
      Qe[0] === "-" && (bt++, this.negative = 1), bt < Qe.length && (at === 16 ? this._parseHex(Qe, bt, wt) : (this._parseBase(Qe, at, bt), wt === "le" && this._initArray(this.toArray(), at, wt)));
    }, ve.prototype._initNumber = function(Qe, at, wt) {
      Qe < 0 && (this.negative = 1, Qe = -Qe), Qe < 67108864 ? (this.words = [Qe & 67108863], this.length = 1) : Qe < 4503599627370496 ? (this.words = [
        Qe & 67108863,
        Qe / 67108864 & 67108863
      ], this.length = 2) : (fe(Qe < 9007199254740992), this.words = [
        Qe & 67108863,
        Qe / 67108864 & 67108863,
        1
      ], this.length = 3), wt === "le" && this._initArray(this.toArray(), at, wt);
    }, ve.prototype._initArray = function(Qe, at, wt) {
      if (fe(typeof Qe.length == "number"), Qe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Qe.length / 3), this.words = new Array(this.length);
      for (var bt = 0; bt < this.length; bt++)
        this.words[bt] = 0;
      var At, Ft, Gt = 0;
      if (wt === "be")
        for (bt = Qe.length - 1, At = 0; bt >= 0; bt -= 3)
          Ft = Qe[bt] | Qe[bt - 1] << 8 | Qe[bt - 2] << 16, this.words[At] |= Ft << Gt & 67108863, this.words[At + 1] = Ft >>> 26 - Gt & 67108863, Gt += 24, Gt >= 26 && (Gt -= 26, At++);
      else if (wt === "le")
        for (bt = 0, At = 0; bt < Qe.length; bt += 3)
          Ft = Qe[bt] | Qe[bt + 1] << 8 | Qe[bt + 2] << 16, this.words[At] |= Ft << Gt & 67108863, this.words[At + 1] = Ft >>> 26 - Gt & 67108863, Gt += 24, Gt >= 26 && (Gt -= 26, At++);
      return this._strip();
    };
    function xe(Ot, Qe) {
      var at = Ot.charCodeAt(Qe);
      if (at >= 48 && at <= 57)
        return at - 48;
      if (at >= 65 && at <= 70)
        return at - 55;
      if (at >= 97 && at <= 102)
        return at - 87;
      fe(!1, "Invalid character in " + Ot);
    }
    function Oe(Ot, Qe, at) {
      var wt = xe(Ot, at);
      return at - 1 >= Qe && (wt |= xe(Ot, at - 1) << 4), wt;
    }
    ve.prototype._parseHex = function(Qe, at, wt) {
      this.length = Math.ceil((Qe.length - at) / 6), this.words = new Array(this.length);
      for (var bt = 0; bt < this.length; bt++)
        this.words[bt] = 0;
      var At = 0, Ft = 0, Gt;
      if (wt === "be")
        for (bt = Qe.length - 1; bt >= at; bt -= 2)
          Gt = Oe(Qe, at, bt) << At, this.words[Ft] |= Gt & 67108863, At >= 18 ? (At -= 18, Ft += 1, this.words[Ft] |= Gt >>> 26) : At += 8;
      else {
        var ot = Qe.length - at;
        for (bt = ot % 2 === 0 ? at + 1 : at; bt < Qe.length; bt += 2)
          Gt = Oe(Qe, at, bt) << At, this.words[Ft] |= Gt & 67108863, At >= 18 ? (At -= 18, Ft += 1, this.words[Ft] |= Gt >>> 26) : At += 8;
      }
      this._strip();
    };
    function $e(Ot, Qe, at, wt) {
      for (var bt = 0, At = 0, Ft = Math.min(Ot.length, at), Gt = Qe; Gt < Ft; Gt++) {
        var ot = Ot.charCodeAt(Gt) - 48;
        bt *= wt, ot >= 49 ? At = ot - 49 + 10 : ot >= 17 ? At = ot - 17 + 10 : At = ot, fe(ot >= 0 && At < wt, "Invalid character"), bt += At;
      }
      return bt;
    }
    ve.prototype._parseBase = function(Qe, at, wt) {
      this.words = [0], this.length = 1;
      for (var bt = 0, At = 1; At <= 67108863; At *= at)
        bt++;
      bt--, At = At / at | 0;
      for (var Ft = Qe.length - wt, Gt = Ft % bt, ot = Math.min(Ft, Ft - Gt) + wt, et = 0, Rt = wt; Rt < ot; Rt += bt)
        et = $e(Qe, Rt, Rt + bt, at), this.imuln(At), this.words[0] + et < 67108864 ? this.words[0] += et : this._iaddn(et);
      if (Gt !== 0) {
        var xr = 1;
        for (et = $e(Qe, Rt, Qe.length, at), Rt = 0; Rt < Gt; Rt++)
          xr *= at;
        this.imuln(xr), this.words[0] + et < 67108864 ? this.words[0] += et : this._iaddn(et);
      }
      this._strip();
    }, ve.prototype.copy = function(Qe) {
      Qe.words = new Array(this.length);
      for (var at = 0; at < this.length; at++)
        Qe.words[at] = this.words[at];
      Qe.length = this.length, Qe.negative = this.negative, Qe.red = this.red;
    };
    function Me(Ot, Qe) {
      Ot.words = Qe.words, Ot.length = Qe.length, Ot.negative = Qe.negative, Ot.red = Qe.red;
    }
    if (ve.prototype._move = function(Qe) {
      Me(Qe, this);
    }, ve.prototype.clone = function() {
      var Qe = new ve(null);
      return this.copy(Qe), Qe;
    }, ve.prototype._expand = function(Qe) {
      for (; this.length < Qe; )
        this.words[this.length++] = 0;
      return this;
    }, ve.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ve.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ve.prototype[Symbol.for("nodejs.util.inspect.custom")] = Re;
      } catch {
        ve.prototype.inspect = Re;
      }
    else
      ve.prototype.inspect = Re;
    function Re() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var je = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], ze = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ve.prototype.toString = function(Qe, at) {
      Qe = Qe || 10, at = at | 0 || 1;
      var wt;
      if (Qe === 16 || Qe === "hex") {
        wt = "";
        for (var bt = 0, At = 0, Ft = 0; Ft < this.length; Ft++) {
          var Gt = this.words[Ft], ot = ((Gt << bt | At) & 16777215).toString(16);
          At = Gt >>> 24 - bt & 16777215, bt += 2, bt >= 26 && (bt -= 26, Ft--), At !== 0 || Ft !== this.length - 1 ? wt = je[6 - ot.length] + ot + wt : wt = ot + wt;
        }
        for (At !== 0 && (wt = At.toString(16) + wt); wt.length % at !== 0; )
          wt = "0" + wt;
        return this.negative !== 0 && (wt = "-" + wt), wt;
      }
      if (Qe === (Qe | 0) && Qe >= 2 && Qe <= 36) {
        var et = Be[Qe], Rt = ze[Qe];
        wt = "";
        var xr = this.clone();
        for (xr.negative = 0; !xr.isZero(); ) {
          var Xt = xr.modrn(Rt).toString(Qe);
          xr = xr.idivn(Rt), xr.isZero() ? wt = Xt + wt : wt = je[et - Xt.length] + Xt + wt;
        }
        for (this.isZero() && (wt = "0" + wt); wt.length % at !== 0; )
          wt = "0" + wt;
        return this.negative !== 0 && (wt = "-" + wt), wt;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ve.prototype.toNumber = function() {
      var Qe = this.words[0];
      return this.length === 2 ? Qe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Qe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Qe : Qe;
    }, ve.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, _e && (ve.prototype.toBuffer = function(Qe, at) {
      return this.toArrayLike(_e, Qe, at);
    }), ve.prototype.toArray = function(Qe, at) {
      return this.toArrayLike(Array, Qe, at);
    };
    var He = function(Qe, at) {
      return Qe.allocUnsafe ? Qe.allocUnsafe(at) : new Qe(at);
    };
    ve.prototype.toArrayLike = function(Qe, at, wt) {
      this._strip();
      var bt = this.byteLength(), At = wt || Math.max(1, bt);
      fe(bt <= At, "byte array longer than desired length"), fe(At > 0, "Requested array length <= 0");
      var Ft = He(Qe, At), Gt = at === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Gt](Ft, bt), Ft;
    }, ve.prototype._toArrayLikeLE = function(Qe, at) {
      for (var wt = 0, bt = 0, At = 0, Ft = 0; At < this.length; At++) {
        var Gt = this.words[At] << Ft | bt;
        Qe[wt++] = Gt & 255, wt < Qe.length && (Qe[wt++] = Gt >> 8 & 255), wt < Qe.length && (Qe[wt++] = Gt >> 16 & 255), Ft === 6 ? (wt < Qe.length && (Qe[wt++] = Gt >> 24 & 255), bt = 0, Ft = 0) : (bt = Gt >>> 24, Ft += 2);
      }
      if (wt < Qe.length)
        for (Qe[wt++] = bt; wt < Qe.length; )
          Qe[wt++] = 0;
    }, ve.prototype._toArrayLikeBE = function(Qe, at) {
      for (var wt = Qe.length - 1, bt = 0, At = 0, Ft = 0; At < this.length; At++) {
        var Gt = this.words[At] << Ft | bt;
        Qe[wt--] = Gt & 255, wt >= 0 && (Qe[wt--] = Gt >> 8 & 255), wt >= 0 && (Qe[wt--] = Gt >> 16 & 255), Ft === 6 ? (wt >= 0 && (Qe[wt--] = Gt >> 24 & 255), bt = 0, Ft = 0) : (bt = Gt >>> 24, Ft += 2);
      }
      if (wt >= 0)
        for (Qe[wt--] = bt; wt >= 0; )
          Qe[wt--] = 0;
    }, Math.clz32 ? ve.prototype._countBits = function(Qe) {
      return 32 - Math.clz32(Qe);
    } : ve.prototype._countBits = function(Qe) {
      var at = Qe, wt = 0;
      return at >= 4096 && (wt += 13, at >>>= 13), at >= 64 && (wt += 7, at >>>= 7), at >= 8 && (wt += 4, at >>>= 4), at >= 2 && (wt += 2, at >>>= 2), wt + at;
    }, ve.prototype._zeroBits = function(Qe) {
      if (Qe === 0)
        return 26;
      var at = Qe, wt = 0;
      return at & 8191 || (wt += 13, at >>>= 13), at & 127 || (wt += 7, at >>>= 7), at & 15 || (wt += 4, at >>>= 4), at & 3 || (wt += 2, at >>>= 2), at & 1 || wt++, wt;
    }, ve.prototype.bitLength = function() {
      var Qe = this.words[this.length - 1], at = this._countBits(Qe);
      return (this.length - 1) * 26 + at;
    };
    function qe(Ot) {
      for (var Qe = new Array(Ot.bitLength()), at = 0; at < Qe.length; at++) {
        var wt = at / 26 | 0, bt = at % 26;
        Qe[at] = Ot.words[wt] >>> bt & 1;
      }
      return Qe;
    }
    ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var Qe = 0, at = 0; at < this.length; at++) {
        var wt = this._zeroBits(this.words[at]);
        if (Qe += wt, wt !== 26)
          break;
      }
      return Qe;
    }, ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ve.prototype.toTwos = function(Qe) {
      return this.negative !== 0 ? this.abs().inotn(Qe).iaddn(1) : this.clone();
    }, ve.prototype.fromTwos = function(Qe) {
      return this.testn(Qe - 1) ? this.notn(Qe).iaddn(1).ineg() : this.clone();
    }, ve.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ve.prototype.neg = function() {
      return this.clone().ineg();
    }, ve.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ve.prototype.iuor = function(Qe) {
      for (; this.length < Qe.length; )
        this.words[this.length++] = 0;
      for (var at = 0; at < Qe.length; at++)
        this.words[at] = this.words[at] | Qe.words[at];
      return this._strip();
    }, ve.prototype.ior = function(Qe) {
      return fe((this.negative | Qe.negative) === 0), this.iuor(Qe);
    }, ve.prototype.or = function(Qe) {
      return this.length > Qe.length ? this.clone().ior(Qe) : Qe.clone().ior(this);
    }, ve.prototype.uor = function(Qe) {
      return this.length > Qe.length ? this.clone().iuor(Qe) : Qe.clone().iuor(this);
    }, ve.prototype.iuand = function(Qe) {
      var at;
      this.length > Qe.length ? at = Qe : at = this;
      for (var wt = 0; wt < at.length; wt++)
        this.words[wt] = this.words[wt] & Qe.words[wt];
      return this.length = at.length, this._strip();
    }, ve.prototype.iand = function(Qe) {
      return fe((this.negative | Qe.negative) === 0), this.iuand(Qe);
    }, ve.prototype.and = function(Qe) {
      return this.length > Qe.length ? this.clone().iand(Qe) : Qe.clone().iand(this);
    }, ve.prototype.uand = function(Qe) {
      return this.length > Qe.length ? this.clone().iuand(Qe) : Qe.clone().iuand(this);
    }, ve.prototype.iuxor = function(Qe) {
      var at, wt;
      this.length > Qe.length ? (at = this, wt = Qe) : (at = Qe, wt = this);
      for (var bt = 0; bt < wt.length; bt++)
        this.words[bt] = at.words[bt] ^ wt.words[bt];
      if (this !== at)
        for (; bt < at.length; bt++)
          this.words[bt] = at.words[bt];
      return this.length = at.length, this._strip();
    }, ve.prototype.ixor = function(Qe) {
      return fe((this.negative | Qe.negative) === 0), this.iuxor(Qe);
    }, ve.prototype.xor = function(Qe) {
      return this.length > Qe.length ? this.clone().ixor(Qe) : Qe.clone().ixor(this);
    }, ve.prototype.uxor = function(Qe) {
      return this.length > Qe.length ? this.clone().iuxor(Qe) : Qe.clone().iuxor(this);
    }, ve.prototype.inotn = function(Qe) {
      fe(typeof Qe == "number" && Qe >= 0);
      var at = Math.ceil(Qe / 26) | 0, wt = Qe % 26;
      this._expand(at), wt > 0 && at--;
      for (var bt = 0; bt < at; bt++)
        this.words[bt] = ~this.words[bt] & 67108863;
      return wt > 0 && (this.words[bt] = ~this.words[bt] & 67108863 >> 26 - wt), this._strip();
    }, ve.prototype.notn = function(Qe) {
      return this.clone().inotn(Qe);
    }, ve.prototype.setn = function(Qe, at) {
      fe(typeof Qe == "number" && Qe >= 0);
      var wt = Qe / 26 | 0, bt = Qe % 26;
      return this._expand(wt + 1), at ? this.words[wt] = this.words[wt] | 1 << bt : this.words[wt] = this.words[wt] & ~(1 << bt), this._strip();
    }, ve.prototype.iadd = function(Qe) {
      var at;
      if (this.negative !== 0 && Qe.negative === 0)
        return this.negative = 0, at = this.isub(Qe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Qe.negative !== 0)
        return Qe.negative = 0, at = this.isub(Qe), Qe.negative = 1, at._normSign();
      var wt, bt;
      this.length > Qe.length ? (wt = this, bt = Qe) : (wt = Qe, bt = this);
      for (var At = 0, Ft = 0; Ft < bt.length; Ft++)
        at = (wt.words[Ft] | 0) + (bt.words[Ft] | 0) + At, this.words[Ft] = at & 67108863, At = at >>> 26;
      for (; At !== 0 && Ft < wt.length; Ft++)
        at = (wt.words[Ft] | 0) + At, this.words[Ft] = at & 67108863, At = at >>> 26;
      if (this.length = wt.length, At !== 0)
        this.words[this.length] = At, this.length++;
      else if (wt !== this)
        for (; Ft < wt.length; Ft++)
          this.words[Ft] = wt.words[Ft];
      return this;
    }, ve.prototype.add = function(Qe) {
      var at;
      return Qe.negative !== 0 && this.negative === 0 ? (Qe.negative = 0, at = this.sub(Qe), Qe.negative ^= 1, at) : Qe.negative === 0 && this.negative !== 0 ? (this.negative = 0, at = Qe.sub(this), this.negative = 1, at) : this.length > Qe.length ? this.clone().iadd(Qe) : Qe.clone().iadd(this);
    }, ve.prototype.isub = function(Qe) {
      if (Qe.negative !== 0) {
        Qe.negative = 0;
        var at = this.iadd(Qe);
        return Qe.negative = 1, at._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Qe), this.negative = 1, this._normSign();
      var wt = this.cmp(Qe);
      if (wt === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var bt, At;
      wt > 0 ? (bt = this, At = Qe) : (bt = Qe, At = this);
      for (var Ft = 0, Gt = 0; Gt < At.length; Gt++)
        at = (bt.words[Gt] | 0) - (At.words[Gt] | 0) + Ft, Ft = at >> 26, this.words[Gt] = at & 67108863;
      for (; Ft !== 0 && Gt < bt.length; Gt++)
        at = (bt.words[Gt] | 0) + Ft, Ft = at >> 26, this.words[Gt] = at & 67108863;
      if (Ft === 0 && Gt < bt.length && bt !== this)
        for (; Gt < bt.length; Gt++)
          this.words[Gt] = bt.words[Gt];
      return this.length = Math.max(this.length, Gt), bt !== this && (this.negative = 1), this._strip();
    }, ve.prototype.sub = function(Qe) {
      return this.clone().isub(Qe);
    };
    function Ye(Ot, Qe, at) {
      at.negative = Qe.negative ^ Ot.negative;
      var wt = Ot.length + Qe.length | 0;
      at.length = wt, wt = wt - 1 | 0;
      var bt = Ot.words[0] | 0, At = Qe.words[0] | 0, Ft = bt * At, Gt = Ft & 67108863, ot = Ft / 67108864 | 0;
      at.words[0] = Gt;
      for (var et = 1; et < wt; et++) {
        for (var Rt = ot >>> 26, xr = ot & 67108863, Xt = Math.min(et, Qe.length - 1), dr = Math.max(0, et - Ot.length + 1); dr <= Xt; dr++) {
          var Nr = et - dr | 0;
          bt = Ot.words[Nr] | 0, At = Qe.words[dr] | 0, Ft = bt * At + xr, Rt += Ft / 67108864 | 0, xr = Ft & 67108863;
        }
        at.words[et] = xr | 0, ot = Rt | 0;
      }
      return ot !== 0 ? at.words[et] = ot | 0 : at.length--, at._strip();
    }
    var pt = function(Qe, at, wt) {
      var bt = Qe.words, At = at.words, Ft = wt.words, Gt = 0, ot, et, Rt, xr = bt[0] | 0, Xt = xr & 8191, dr = xr >>> 13, Nr = bt[1] | 0, Dr = Nr & 8191, jr = Nr >>> 13, un = bt[2] | 0, so = un & 8191, Pn = un >>> 13, co = bt[3] | 0, kn = co & 8191, Yn = co >>> 13, Ho = bt[4] | 0, Rn = Ho & 8191, fo = Ho >>> 13, pa = bt[5] | 0, jn = pa & 8191, Xn = pa >>> 13, Ko = bt[6] | 0, vo = Ko & 8191, Eo = Ko >>> 13, ra = bt[7] | 0, uo = ra & 8191, So = ra >>> 13, Jo = bt[8] | 0, Po = Jo & 8191, Jt = Jo >>> 13, or = bt[9] | 0, fr = or & 8191, Mr = or >>> 13, Wr = At[0] | 0, Vr = Wr & 8191, Zr = Wr >>> 13, on = At[1] | 0, Lr = on & 8191, tn = on >>> 13, Qn = At[2] | 0, Fn = Qn & 8191, en = Qn >>> 13, An = At[3] | 0, zn = An & 8191, Oo = An >>> 13, ii = At[4] | 0, No = ii & 8191, Ao = ii >>> 13, Da = At[5] | 0, po = Da & 8191, _o = Da >>> 13, Ba = At[6] | 0, bo = Ba & 8191, $n = Ba >>> 13, Bo = At[7] | 0, ho = Bo & 8191, To = Bo >>> 13, Qt = At[8] | 0, kr = Qt & 8191, Tr = Qt >>> 13, vn = At[9] | 0, mn = vn & 8191, En = vn >>> 13;
      wt.negative = Qe.negative ^ at.negative, wt.length = 19, ot = Math.imul(Xt, Vr), et = Math.imul(Xt, Zr), et = et + Math.imul(dr, Vr) | 0, Rt = Math.imul(dr, Zr);
      var Zn = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Zn >>> 26) | 0, Zn &= 67108863, ot = Math.imul(Dr, Vr), et = Math.imul(Dr, Zr), et = et + Math.imul(jr, Vr) | 0, Rt = Math.imul(jr, Zr), ot = ot + Math.imul(Xt, Lr) | 0, et = et + Math.imul(Xt, tn) | 0, et = et + Math.imul(dr, Lr) | 0, Rt = Rt + Math.imul(dr, tn) | 0;
      var xn = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, ot = Math.imul(so, Vr), et = Math.imul(so, Zr), et = et + Math.imul(Pn, Vr) | 0, Rt = Math.imul(Pn, Zr), ot = ot + Math.imul(Dr, Lr) | 0, et = et + Math.imul(Dr, tn) | 0, et = et + Math.imul(jr, Lr) | 0, Rt = Rt + Math.imul(jr, tn) | 0, ot = ot + Math.imul(Xt, Fn) | 0, et = et + Math.imul(Xt, en) | 0, et = et + Math.imul(dr, Fn) | 0, Rt = Rt + Math.imul(dr, en) | 0;
      var na = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (na >>> 26) | 0, na &= 67108863, ot = Math.imul(kn, Vr), et = Math.imul(kn, Zr), et = et + Math.imul(Yn, Vr) | 0, Rt = Math.imul(Yn, Zr), ot = ot + Math.imul(so, Lr) | 0, et = et + Math.imul(so, tn) | 0, et = et + Math.imul(Pn, Lr) | 0, Rt = Rt + Math.imul(Pn, tn) | 0, ot = ot + Math.imul(Dr, Fn) | 0, et = et + Math.imul(Dr, en) | 0, et = et + Math.imul(jr, Fn) | 0, Rt = Rt + Math.imul(jr, en) | 0, ot = ot + Math.imul(Xt, zn) | 0, et = et + Math.imul(Xt, Oo) | 0, et = et + Math.imul(dr, zn) | 0, Rt = Rt + Math.imul(dr, Oo) | 0;
      var Wo = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Wo >>> 26) | 0, Wo &= 67108863, ot = Math.imul(Rn, Vr), et = Math.imul(Rn, Zr), et = et + Math.imul(fo, Vr) | 0, Rt = Math.imul(fo, Zr), ot = ot + Math.imul(kn, Lr) | 0, et = et + Math.imul(kn, tn) | 0, et = et + Math.imul(Yn, Lr) | 0, Rt = Rt + Math.imul(Yn, tn) | 0, ot = ot + Math.imul(so, Fn) | 0, et = et + Math.imul(so, en) | 0, et = et + Math.imul(Pn, Fn) | 0, Rt = Rt + Math.imul(Pn, en) | 0, ot = ot + Math.imul(Dr, zn) | 0, et = et + Math.imul(Dr, Oo) | 0, et = et + Math.imul(jr, zn) | 0, Rt = Rt + Math.imul(jr, Oo) | 0, ot = ot + Math.imul(Xt, No) | 0, et = et + Math.imul(Xt, Ao) | 0, et = et + Math.imul(dr, No) | 0, Rt = Rt + Math.imul(dr, Ao) | 0;
      var Zo = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, ot = Math.imul(jn, Vr), et = Math.imul(jn, Zr), et = et + Math.imul(Xn, Vr) | 0, Rt = Math.imul(Xn, Zr), ot = ot + Math.imul(Rn, Lr) | 0, et = et + Math.imul(Rn, tn) | 0, et = et + Math.imul(fo, Lr) | 0, Rt = Rt + Math.imul(fo, tn) | 0, ot = ot + Math.imul(kn, Fn) | 0, et = et + Math.imul(kn, en) | 0, et = et + Math.imul(Yn, Fn) | 0, Rt = Rt + Math.imul(Yn, en) | 0, ot = ot + Math.imul(so, zn) | 0, et = et + Math.imul(so, Oo) | 0, et = et + Math.imul(Pn, zn) | 0, Rt = Rt + Math.imul(Pn, Oo) | 0, ot = ot + Math.imul(Dr, No) | 0, et = et + Math.imul(Dr, Ao) | 0, et = et + Math.imul(jr, No) | 0, Rt = Rt + Math.imul(jr, Ao) | 0, ot = ot + Math.imul(Xt, po) | 0, et = et + Math.imul(Xt, _o) | 0, et = et + Math.imul(dr, po) | 0, Rt = Rt + Math.imul(dr, _o) | 0;
      var va = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, ot = Math.imul(vo, Vr), et = Math.imul(vo, Zr), et = et + Math.imul(Eo, Vr) | 0, Rt = Math.imul(Eo, Zr), ot = ot + Math.imul(jn, Lr) | 0, et = et + Math.imul(jn, tn) | 0, et = et + Math.imul(Xn, Lr) | 0, Rt = Rt + Math.imul(Xn, tn) | 0, ot = ot + Math.imul(Rn, Fn) | 0, et = et + Math.imul(Rn, en) | 0, et = et + Math.imul(fo, Fn) | 0, Rt = Rt + Math.imul(fo, en) | 0, ot = ot + Math.imul(kn, zn) | 0, et = et + Math.imul(kn, Oo) | 0, et = et + Math.imul(Yn, zn) | 0, Rt = Rt + Math.imul(Yn, Oo) | 0, ot = ot + Math.imul(so, No) | 0, et = et + Math.imul(so, Ao) | 0, et = et + Math.imul(Pn, No) | 0, Rt = Rt + Math.imul(Pn, Ao) | 0, ot = ot + Math.imul(Dr, po) | 0, et = et + Math.imul(Dr, _o) | 0, et = et + Math.imul(jr, po) | 0, Rt = Rt + Math.imul(jr, _o) | 0, ot = ot + Math.imul(Xt, bo) | 0, et = et + Math.imul(Xt, $n) | 0, et = et + Math.imul(dr, bo) | 0, Rt = Rt + Math.imul(dr, $n) | 0;
      var yi = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, ot = Math.imul(uo, Vr), et = Math.imul(uo, Zr), et = et + Math.imul(So, Vr) | 0, Rt = Math.imul(So, Zr), ot = ot + Math.imul(vo, Lr) | 0, et = et + Math.imul(vo, tn) | 0, et = et + Math.imul(Eo, Lr) | 0, Rt = Rt + Math.imul(Eo, tn) | 0, ot = ot + Math.imul(jn, Fn) | 0, et = et + Math.imul(jn, en) | 0, et = et + Math.imul(Xn, Fn) | 0, Rt = Rt + Math.imul(Xn, en) | 0, ot = ot + Math.imul(Rn, zn) | 0, et = et + Math.imul(Rn, Oo) | 0, et = et + Math.imul(fo, zn) | 0, Rt = Rt + Math.imul(fo, Oo) | 0, ot = ot + Math.imul(kn, No) | 0, et = et + Math.imul(kn, Ao) | 0, et = et + Math.imul(Yn, No) | 0, Rt = Rt + Math.imul(Yn, Ao) | 0, ot = ot + Math.imul(so, po) | 0, et = et + Math.imul(so, _o) | 0, et = et + Math.imul(Pn, po) | 0, Rt = Rt + Math.imul(Pn, _o) | 0, ot = ot + Math.imul(Dr, bo) | 0, et = et + Math.imul(Dr, $n) | 0, et = et + Math.imul(jr, bo) | 0, Rt = Rt + Math.imul(jr, $n) | 0, ot = ot + Math.imul(Xt, ho) | 0, et = et + Math.imul(Xt, To) | 0, et = et + Math.imul(dr, ho) | 0, Rt = Rt + Math.imul(dr, To) | 0;
      var _s = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (_s >>> 26) | 0, _s &= 67108863, ot = Math.imul(Po, Vr), et = Math.imul(Po, Zr), et = et + Math.imul(Jt, Vr) | 0, Rt = Math.imul(Jt, Zr), ot = ot + Math.imul(uo, Lr) | 0, et = et + Math.imul(uo, tn) | 0, et = et + Math.imul(So, Lr) | 0, Rt = Rt + Math.imul(So, tn) | 0, ot = ot + Math.imul(vo, Fn) | 0, et = et + Math.imul(vo, en) | 0, et = et + Math.imul(Eo, Fn) | 0, Rt = Rt + Math.imul(Eo, en) | 0, ot = ot + Math.imul(jn, zn) | 0, et = et + Math.imul(jn, Oo) | 0, et = et + Math.imul(Xn, zn) | 0, Rt = Rt + Math.imul(Xn, Oo) | 0, ot = ot + Math.imul(Rn, No) | 0, et = et + Math.imul(Rn, Ao) | 0, et = et + Math.imul(fo, No) | 0, Rt = Rt + Math.imul(fo, Ao) | 0, ot = ot + Math.imul(kn, po) | 0, et = et + Math.imul(kn, _o) | 0, et = et + Math.imul(Yn, po) | 0, Rt = Rt + Math.imul(Yn, _o) | 0, ot = ot + Math.imul(so, bo) | 0, et = et + Math.imul(so, $n) | 0, et = et + Math.imul(Pn, bo) | 0, Rt = Rt + Math.imul(Pn, $n) | 0, ot = ot + Math.imul(Dr, ho) | 0, et = et + Math.imul(Dr, To) | 0, et = et + Math.imul(jr, ho) | 0, Rt = Rt + Math.imul(jr, To) | 0, ot = ot + Math.imul(Xt, kr) | 0, et = et + Math.imul(Xt, Tr) | 0, et = et + Math.imul(dr, kr) | 0, Rt = Rt + Math.imul(dr, Tr) | 0;
      var xo = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, ot = Math.imul(fr, Vr), et = Math.imul(fr, Zr), et = et + Math.imul(Mr, Vr) | 0, Rt = Math.imul(Mr, Zr), ot = ot + Math.imul(Po, Lr) | 0, et = et + Math.imul(Po, tn) | 0, et = et + Math.imul(Jt, Lr) | 0, Rt = Rt + Math.imul(Jt, tn) | 0, ot = ot + Math.imul(uo, Fn) | 0, et = et + Math.imul(uo, en) | 0, et = et + Math.imul(So, Fn) | 0, Rt = Rt + Math.imul(So, en) | 0, ot = ot + Math.imul(vo, zn) | 0, et = et + Math.imul(vo, Oo) | 0, et = et + Math.imul(Eo, zn) | 0, Rt = Rt + Math.imul(Eo, Oo) | 0, ot = ot + Math.imul(jn, No) | 0, et = et + Math.imul(jn, Ao) | 0, et = et + Math.imul(Xn, No) | 0, Rt = Rt + Math.imul(Xn, Ao) | 0, ot = ot + Math.imul(Rn, po) | 0, et = et + Math.imul(Rn, _o) | 0, et = et + Math.imul(fo, po) | 0, Rt = Rt + Math.imul(fo, _o) | 0, ot = ot + Math.imul(kn, bo) | 0, et = et + Math.imul(kn, $n) | 0, et = et + Math.imul(Yn, bo) | 0, Rt = Rt + Math.imul(Yn, $n) | 0, ot = ot + Math.imul(so, ho) | 0, et = et + Math.imul(so, To) | 0, et = et + Math.imul(Pn, ho) | 0, Rt = Rt + Math.imul(Pn, To) | 0, ot = ot + Math.imul(Dr, kr) | 0, et = et + Math.imul(Dr, Tr) | 0, et = et + Math.imul(jr, kr) | 0, Rt = Rt + Math.imul(jr, Tr) | 0, ot = ot + Math.imul(Xt, mn) | 0, et = et + Math.imul(Xt, En) | 0, et = et + Math.imul(dr, mn) | 0, Rt = Rt + Math.imul(dr, En) | 0;
      var qu = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (qu >>> 26) | 0, qu &= 67108863, ot = Math.imul(fr, Lr), et = Math.imul(fr, tn), et = et + Math.imul(Mr, Lr) | 0, Rt = Math.imul(Mr, tn), ot = ot + Math.imul(Po, Fn) | 0, et = et + Math.imul(Po, en) | 0, et = et + Math.imul(Jt, Fn) | 0, Rt = Rt + Math.imul(Jt, en) | 0, ot = ot + Math.imul(uo, zn) | 0, et = et + Math.imul(uo, Oo) | 0, et = et + Math.imul(So, zn) | 0, Rt = Rt + Math.imul(So, Oo) | 0, ot = ot + Math.imul(vo, No) | 0, et = et + Math.imul(vo, Ao) | 0, et = et + Math.imul(Eo, No) | 0, Rt = Rt + Math.imul(Eo, Ao) | 0, ot = ot + Math.imul(jn, po) | 0, et = et + Math.imul(jn, _o) | 0, et = et + Math.imul(Xn, po) | 0, Rt = Rt + Math.imul(Xn, _o) | 0, ot = ot + Math.imul(Rn, bo) | 0, et = et + Math.imul(Rn, $n) | 0, et = et + Math.imul(fo, bo) | 0, Rt = Rt + Math.imul(fo, $n) | 0, ot = ot + Math.imul(kn, ho) | 0, et = et + Math.imul(kn, To) | 0, et = et + Math.imul(Yn, ho) | 0, Rt = Rt + Math.imul(Yn, To) | 0, ot = ot + Math.imul(so, kr) | 0, et = et + Math.imul(so, Tr) | 0, et = et + Math.imul(Pn, kr) | 0, Rt = Rt + Math.imul(Pn, Tr) | 0, ot = ot + Math.imul(Dr, mn) | 0, et = et + Math.imul(Dr, En) | 0, et = et + Math.imul(jr, mn) | 0, Rt = Rt + Math.imul(jr, En) | 0;
      var si = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (si >>> 26) | 0, si &= 67108863, ot = Math.imul(fr, Fn), et = Math.imul(fr, en), et = et + Math.imul(Mr, Fn) | 0, Rt = Math.imul(Mr, en), ot = ot + Math.imul(Po, zn) | 0, et = et + Math.imul(Po, Oo) | 0, et = et + Math.imul(Jt, zn) | 0, Rt = Rt + Math.imul(Jt, Oo) | 0, ot = ot + Math.imul(uo, No) | 0, et = et + Math.imul(uo, Ao) | 0, et = et + Math.imul(So, No) | 0, Rt = Rt + Math.imul(So, Ao) | 0, ot = ot + Math.imul(vo, po) | 0, et = et + Math.imul(vo, _o) | 0, et = et + Math.imul(Eo, po) | 0, Rt = Rt + Math.imul(Eo, _o) | 0, ot = ot + Math.imul(jn, bo) | 0, et = et + Math.imul(jn, $n) | 0, et = et + Math.imul(Xn, bo) | 0, Rt = Rt + Math.imul(Xn, $n) | 0, ot = ot + Math.imul(Rn, ho) | 0, et = et + Math.imul(Rn, To) | 0, et = et + Math.imul(fo, ho) | 0, Rt = Rt + Math.imul(fo, To) | 0, ot = ot + Math.imul(kn, kr) | 0, et = et + Math.imul(kn, Tr) | 0, et = et + Math.imul(Yn, kr) | 0, Rt = Rt + Math.imul(Yn, Tr) | 0, ot = ot + Math.imul(so, mn) | 0, et = et + Math.imul(so, En) | 0, et = et + Math.imul(Pn, mn) | 0, Rt = Rt + Math.imul(Pn, En) | 0;
      var oo = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (oo >>> 26) | 0, oo &= 67108863, ot = Math.imul(fr, zn), et = Math.imul(fr, Oo), et = et + Math.imul(Mr, zn) | 0, Rt = Math.imul(Mr, Oo), ot = ot + Math.imul(Po, No) | 0, et = et + Math.imul(Po, Ao) | 0, et = et + Math.imul(Jt, No) | 0, Rt = Rt + Math.imul(Jt, Ao) | 0, ot = ot + Math.imul(uo, po) | 0, et = et + Math.imul(uo, _o) | 0, et = et + Math.imul(So, po) | 0, Rt = Rt + Math.imul(So, _o) | 0, ot = ot + Math.imul(vo, bo) | 0, et = et + Math.imul(vo, $n) | 0, et = et + Math.imul(Eo, bo) | 0, Rt = Rt + Math.imul(Eo, $n) | 0, ot = ot + Math.imul(jn, ho) | 0, et = et + Math.imul(jn, To) | 0, et = et + Math.imul(Xn, ho) | 0, Rt = Rt + Math.imul(Xn, To) | 0, ot = ot + Math.imul(Rn, kr) | 0, et = et + Math.imul(Rn, Tr) | 0, et = et + Math.imul(fo, kr) | 0, Rt = Rt + Math.imul(fo, Tr) | 0, ot = ot + Math.imul(kn, mn) | 0, et = et + Math.imul(kn, En) | 0, et = et + Math.imul(Yn, mn) | 0, Rt = Rt + Math.imul(Yn, En) | 0;
      var da = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, ot = Math.imul(fr, No), et = Math.imul(fr, Ao), et = et + Math.imul(Mr, No) | 0, Rt = Math.imul(Mr, Ao), ot = ot + Math.imul(Po, po) | 0, et = et + Math.imul(Po, _o) | 0, et = et + Math.imul(Jt, po) | 0, Rt = Rt + Math.imul(Jt, _o) | 0, ot = ot + Math.imul(uo, bo) | 0, et = et + Math.imul(uo, $n) | 0, et = et + Math.imul(So, bo) | 0, Rt = Rt + Math.imul(So, $n) | 0, ot = ot + Math.imul(vo, ho) | 0, et = et + Math.imul(vo, To) | 0, et = et + Math.imul(Eo, ho) | 0, Rt = Rt + Math.imul(Eo, To) | 0, ot = ot + Math.imul(jn, kr) | 0, et = et + Math.imul(jn, Tr) | 0, et = et + Math.imul(Xn, kr) | 0, Rt = Rt + Math.imul(Xn, Tr) | 0, ot = ot + Math.imul(Rn, mn) | 0, et = et + Math.imul(Rn, En) | 0, et = et + Math.imul(fo, mn) | 0, Rt = Rt + Math.imul(fo, En) | 0;
      var xs = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (xs >>> 26) | 0, xs &= 67108863, ot = Math.imul(fr, po), et = Math.imul(fr, _o), et = et + Math.imul(Mr, po) | 0, Rt = Math.imul(Mr, _o), ot = ot + Math.imul(Po, bo) | 0, et = et + Math.imul(Po, $n) | 0, et = et + Math.imul(Jt, bo) | 0, Rt = Rt + Math.imul(Jt, $n) | 0, ot = ot + Math.imul(uo, ho) | 0, et = et + Math.imul(uo, To) | 0, et = et + Math.imul(So, ho) | 0, Rt = Rt + Math.imul(So, To) | 0, ot = ot + Math.imul(vo, kr) | 0, et = et + Math.imul(vo, Tr) | 0, et = et + Math.imul(Eo, kr) | 0, Rt = Rt + Math.imul(Eo, Tr) | 0, ot = ot + Math.imul(jn, mn) | 0, et = et + Math.imul(jn, En) | 0, et = et + Math.imul(Xn, mn) | 0, Rt = Rt + Math.imul(Xn, En) | 0;
      var as = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (as >>> 26) | 0, as &= 67108863, ot = Math.imul(fr, bo), et = Math.imul(fr, $n), et = et + Math.imul(Mr, bo) | 0, Rt = Math.imul(Mr, $n), ot = ot + Math.imul(Po, ho) | 0, et = et + Math.imul(Po, To) | 0, et = et + Math.imul(Jt, ho) | 0, Rt = Rt + Math.imul(Jt, To) | 0, ot = ot + Math.imul(uo, kr) | 0, et = et + Math.imul(uo, Tr) | 0, et = et + Math.imul(So, kr) | 0, Rt = Rt + Math.imul(So, Tr) | 0, ot = ot + Math.imul(vo, mn) | 0, et = et + Math.imul(vo, En) | 0, et = et + Math.imul(Eo, mn) | 0, Rt = Rt + Math.imul(Eo, En) | 0;
      var Ci = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Ci >>> 26) | 0, Ci &= 67108863, ot = Math.imul(fr, ho), et = Math.imul(fr, To), et = et + Math.imul(Mr, ho) | 0, Rt = Math.imul(Mr, To), ot = ot + Math.imul(Po, kr) | 0, et = et + Math.imul(Po, Tr) | 0, et = et + Math.imul(Jt, kr) | 0, Rt = Rt + Math.imul(Jt, Tr) | 0, ot = ot + Math.imul(uo, mn) | 0, et = et + Math.imul(uo, En) | 0, et = et + Math.imul(So, mn) | 0, Rt = Rt + Math.imul(So, En) | 0;
      var Ca = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, ot = Math.imul(fr, kr), et = Math.imul(fr, Tr), et = et + Math.imul(Mr, kr) | 0, Rt = Math.imul(Mr, Tr), ot = ot + Math.imul(Po, mn) | 0, et = et + Math.imul(Po, En) | 0, et = et + Math.imul(Jt, mn) | 0, Rt = Rt + Math.imul(Jt, En) | 0;
      var Es = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      Gt = (Rt + (et >>> 13) | 0) + (Es >>> 26) | 0, Es &= 67108863, ot = Math.imul(fr, mn), et = Math.imul(fr, En), et = et + Math.imul(Mr, mn) | 0, Rt = Math.imul(Mr, En);
      var ka = (Gt + ot | 0) + ((et & 8191) << 13) | 0;
      return Gt = (Rt + (et >>> 13) | 0) + (ka >>> 26) | 0, ka &= 67108863, Ft[0] = Zn, Ft[1] = xn, Ft[2] = na, Ft[3] = Wo, Ft[4] = Zo, Ft[5] = va, Ft[6] = yi, Ft[7] = _s, Ft[8] = xo, Ft[9] = qu, Ft[10] = si, Ft[11] = oo, Ft[12] = da, Ft[13] = xs, Ft[14] = as, Ft[15] = Ci, Ft[16] = Ca, Ft[17] = Es, Ft[18] = ka, Gt !== 0 && (Ft[19] = Gt, wt.length++), wt;
    };
    Math.imul || (pt = Ye);
    function dt(Ot, Qe, at) {
      at.negative = Qe.negative ^ Ot.negative, at.length = Ot.length + Qe.length;
      for (var wt = 0, bt = 0, At = 0; At < at.length - 1; At++) {
        var Ft = bt;
        bt = 0;
        for (var Gt = wt & 67108863, ot = Math.min(At, Qe.length - 1), et = Math.max(0, At - Ot.length + 1); et <= ot; et++) {
          var Rt = At - et, xr = Ot.words[Rt] | 0, Xt = Qe.words[et] | 0, dr = xr * Xt, Nr = dr & 67108863;
          Ft = Ft + (dr / 67108864 | 0) | 0, Nr = Nr + Gt | 0, Gt = Nr & 67108863, Ft = Ft + (Nr >>> 26) | 0, bt += Ft >>> 26, Ft &= 67108863;
        }
        at.words[At] = Gt, wt = Ft, Ft = bt;
      }
      return wt !== 0 ? at.words[At] = wt : at.length--, at._strip();
    }
    function yt(Ot, Qe, at) {
      return dt(Ot, Qe, at);
    }
    ve.prototype.mulTo = function(Qe, at) {
      var wt, bt = this.length + Qe.length;
      return this.length === 10 && Qe.length === 10 ? wt = pt(this, Qe, at) : bt < 63 ? wt = Ye(this, Qe, at) : bt < 1024 ? wt = dt(this, Qe, at) : wt = yt(this, Qe, at), wt;
    }, ve.prototype.mul = function(Qe) {
      var at = new ve(null);
      return at.words = new Array(this.length + Qe.length), this.mulTo(Qe, at);
    }, ve.prototype.mulf = function(Qe) {
      var at = new ve(null);
      return at.words = new Array(this.length + Qe.length), yt(this, Qe, at);
    }, ve.prototype.imul = function(Qe) {
      return this.clone().mulTo(Qe, this);
    }, ve.prototype.imuln = function(Qe) {
      var at = Qe < 0;
      at && (Qe = -Qe), fe(typeof Qe == "number"), fe(Qe < 67108864);
      for (var wt = 0, bt = 0; bt < this.length; bt++) {
        var At = (this.words[bt] | 0) * Qe, Ft = (At & 67108863) + (wt & 67108863);
        wt >>= 26, wt += At / 67108864 | 0, wt += Ft >>> 26, this.words[bt] = Ft & 67108863;
      }
      return wt !== 0 && (this.words[bt] = wt, this.length++), at ? this.ineg() : this;
    }, ve.prototype.muln = function(Qe) {
      return this.clone().imuln(Qe);
    }, ve.prototype.sqr = function() {
      return this.mul(this);
    }, ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ve.prototype.pow = function(Qe) {
      var at = qe(Qe);
      if (at.length === 0)
        return new ve(1);
      for (var wt = this, bt = 0; bt < at.length && at[bt] === 0; bt++, wt = wt.sqr())
        ;
      if (++bt < at.length)
        for (var At = wt.sqr(); bt < at.length; bt++, At = At.sqr())
          at[bt] !== 0 && (wt = wt.mul(At));
      return wt;
    }, ve.prototype.iushln = function(Qe) {
      fe(typeof Qe == "number" && Qe >= 0);
      var at = Qe % 26, wt = (Qe - at) / 26, bt = 67108863 >>> 26 - at << 26 - at, At;
      if (at !== 0) {
        var Ft = 0;
        for (At = 0; At < this.length; At++) {
          var Gt = this.words[At] & bt, ot = (this.words[At] | 0) - Gt << at;
          this.words[At] = ot | Ft, Ft = Gt >>> 26 - at;
        }
        Ft && (this.words[At] = Ft, this.length++);
      }
      if (wt !== 0) {
        for (At = this.length - 1; At >= 0; At--)
          this.words[At + wt] = this.words[At];
        for (At = 0; At < wt; At++)
          this.words[At] = 0;
        this.length += wt;
      }
      return this._strip();
    }, ve.prototype.ishln = function(Qe) {
      return fe(this.negative === 0), this.iushln(Qe);
    }, ve.prototype.iushrn = function(Qe, at, wt) {
      fe(typeof Qe == "number" && Qe >= 0);
      var bt;
      at ? bt = (at - at % 26) / 26 : bt = 0;
      var At = Qe % 26, Ft = Math.min((Qe - At) / 26, this.length), Gt = 67108863 ^ 67108863 >>> At << At, ot = wt;
      if (bt -= Ft, bt = Math.max(0, bt), ot) {
        for (var et = 0; et < Ft; et++)
          ot.words[et] = this.words[et];
        ot.length = Ft;
      }
      if (Ft !== 0)
        if (this.length > Ft)
          for (this.length -= Ft, et = 0; et < this.length; et++)
            this.words[et] = this.words[et + Ft];
        else
          this.words[0] = 0, this.length = 1;
      var Rt = 0;
      for (et = this.length - 1; et >= 0 && (Rt !== 0 || et >= bt); et--) {
        var xr = this.words[et] | 0;
        this.words[et] = Rt << 26 - At | xr >>> At, Rt = xr & Gt;
      }
      return ot && Rt !== 0 && (ot.words[ot.length++] = Rt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ve.prototype.ishrn = function(Qe, at, wt) {
      return fe(this.negative === 0), this.iushrn(Qe, at, wt);
    }, ve.prototype.shln = function(Qe) {
      return this.clone().ishln(Qe);
    }, ve.prototype.ushln = function(Qe) {
      return this.clone().iushln(Qe);
    }, ve.prototype.shrn = function(Qe) {
      return this.clone().ishrn(Qe);
    }, ve.prototype.ushrn = function(Qe) {
      return this.clone().iushrn(Qe);
    }, ve.prototype.testn = function(Qe) {
      fe(typeof Qe == "number" && Qe >= 0);
      var at = Qe % 26, wt = (Qe - at) / 26, bt = 1 << at;
      if (this.length <= wt)
        return !1;
      var At = this.words[wt];
      return !!(At & bt);
    }, ve.prototype.imaskn = function(Qe) {
      fe(typeof Qe == "number" && Qe >= 0);
      var at = Qe % 26, wt = (Qe - at) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= wt)
        return this;
      if (at !== 0 && wt++, this.length = Math.min(wt, this.length), at !== 0) {
        var bt = 67108863 ^ 67108863 >>> at << at;
        this.words[this.length - 1] &= bt;
      }
      return this._strip();
    }, ve.prototype.maskn = function(Qe) {
      return this.clone().imaskn(Qe);
    }, ve.prototype.iaddn = function(Qe) {
      return fe(typeof Qe == "number"), fe(Qe < 67108864), Qe < 0 ? this.isubn(-Qe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= Qe ? (this.words[0] = Qe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Qe), this.negative = 1, this) : this._iaddn(Qe);
    }, ve.prototype._iaddn = function(Qe) {
      this.words[0] += Qe;
      for (var at = 0; at < this.length && this.words[at] >= 67108864; at++)
        this.words[at] -= 67108864, at === this.length - 1 ? this.words[at + 1] = 1 : this.words[at + 1]++;
      return this.length = Math.max(this.length, at + 1), this;
    }, ve.prototype.isubn = function(Qe) {
      if (fe(typeof Qe == "number"), fe(Qe < 67108864), Qe < 0)
        return this.iaddn(-Qe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Qe), this.negative = 1, this;
      if (this.words[0] -= Qe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var at = 0; at < this.length && this.words[at] < 0; at++)
          this.words[at] += 67108864, this.words[at + 1] -= 1;
      return this._strip();
    }, ve.prototype.addn = function(Qe) {
      return this.clone().iaddn(Qe);
    }, ve.prototype.subn = function(Qe) {
      return this.clone().isubn(Qe);
    }, ve.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ve.prototype.abs = function() {
      return this.clone().iabs();
    }, ve.prototype._ishlnsubmul = function(Qe, at, wt) {
      var bt = Qe.length + wt, At;
      this._expand(bt);
      var Ft, Gt = 0;
      for (At = 0; At < Qe.length; At++) {
        Ft = (this.words[At + wt] | 0) + Gt;
        var ot = (Qe.words[At] | 0) * at;
        Ft -= ot & 67108863, Gt = (Ft >> 26) - (ot / 67108864 | 0), this.words[At + wt] = Ft & 67108863;
      }
      for (; At < this.length - wt; At++)
        Ft = (this.words[At + wt] | 0) + Gt, Gt = Ft >> 26, this.words[At + wt] = Ft & 67108863;
      if (Gt === 0)
        return this._strip();
      for (fe(Gt === -1), Gt = 0, At = 0; At < this.length; At++)
        Ft = -(this.words[At] | 0) + Gt, Gt = Ft >> 26, this.words[At] = Ft & 67108863;
      return this.negative = 1, this._strip();
    }, ve.prototype._wordDiv = function(Qe, at) {
      var wt = this.length - Qe.length, bt = this.clone(), At = Qe, Ft = At.words[At.length - 1] | 0, Gt = this._countBits(Ft);
      wt = 26 - Gt, wt !== 0 && (At = At.ushln(wt), bt.iushln(wt), Ft = At.words[At.length - 1] | 0);
      var ot = bt.length - At.length, et;
      if (at !== "mod") {
        et = new ve(null), et.length = ot + 1, et.words = new Array(et.length);
        for (var Rt = 0; Rt < et.length; Rt++)
          et.words[Rt] = 0;
      }
      var xr = bt.clone()._ishlnsubmul(At, 1, ot);
      xr.negative === 0 && (bt = xr, et && (et.words[ot] = 1));
      for (var Xt = ot - 1; Xt >= 0; Xt--) {
        var dr = (bt.words[At.length + Xt] | 0) * 67108864 + (bt.words[At.length + Xt - 1] | 0);
        for (dr = Math.min(dr / Ft | 0, 67108863), bt._ishlnsubmul(At, dr, Xt); bt.negative !== 0; )
          dr--, bt.negative = 0, bt._ishlnsubmul(At, 1, Xt), bt.isZero() || (bt.negative ^= 1);
        et && (et.words[Xt] = dr);
      }
      return et && et._strip(), bt._strip(), at !== "div" && wt !== 0 && bt.iushrn(wt), {
        div: et || null,
        mod: bt
      };
    }, ve.prototype.divmod = function(Qe, at, wt) {
      if (fe(!Qe.isZero()), this.isZero())
        return {
          div: new ve(0),
          mod: new ve(0)
        };
      var bt, At, Ft;
      return this.negative !== 0 && Qe.negative === 0 ? (Ft = this.neg().divmod(Qe, at), at !== "mod" && (bt = Ft.div.neg()), at !== "div" && (At = Ft.mod.neg(), wt && At.negative !== 0 && At.iadd(Qe)), {
        div: bt,
        mod: At
      }) : this.negative === 0 && Qe.negative !== 0 ? (Ft = this.divmod(Qe.neg(), at), at !== "mod" && (bt = Ft.div.neg()), {
        div: bt,
        mod: Ft.mod
      }) : this.negative & Qe.negative ? (Ft = this.neg().divmod(Qe.neg(), at), at !== "div" && (At = Ft.mod.neg(), wt && At.negative !== 0 && At.isub(Qe)), {
        div: Ft.div,
        mod: At
      }) : Qe.length > this.length || this.cmp(Qe) < 0 ? {
        div: new ve(0),
        mod: this
      } : Qe.length === 1 ? at === "div" ? {
        div: this.divn(Qe.words[0]),
        mod: null
      } : at === "mod" ? {
        div: null,
        mod: new ve(this.modrn(Qe.words[0]))
      } : {
        div: this.divn(Qe.words[0]),
        mod: new ve(this.modrn(Qe.words[0]))
      } : this._wordDiv(Qe, at);
    }, ve.prototype.div = function(Qe) {
      return this.divmod(Qe, "div", !1).div;
    }, ve.prototype.mod = function(Qe) {
      return this.divmod(Qe, "mod", !1).mod;
    }, ve.prototype.umod = function(Qe) {
      return this.divmod(Qe, "mod", !0).mod;
    }, ve.prototype.divRound = function(Qe) {
      var at = this.divmod(Qe);
      if (at.mod.isZero())
        return at.div;
      var wt = at.div.negative !== 0 ? at.mod.isub(Qe) : at.mod, bt = Qe.ushrn(1), At = Qe.andln(1), Ft = wt.cmp(bt);
      return Ft < 0 || At === 1 && Ft === 0 ? at.div : at.div.negative !== 0 ? at.div.isubn(1) : at.div.iaddn(1);
    }, ve.prototype.modrn = function(Qe) {
      var at = Qe < 0;
      at && (Qe = -Qe), fe(Qe <= 67108863);
      for (var wt = (1 << 26) % Qe, bt = 0, At = this.length - 1; At >= 0; At--)
        bt = (wt * bt + (this.words[At] | 0)) % Qe;
      return at ? -bt : bt;
    }, ve.prototype.modn = function(Qe) {
      return this.modrn(Qe);
    }, ve.prototype.idivn = function(Qe) {
      var at = Qe < 0;
      at && (Qe = -Qe), fe(Qe <= 67108863);
      for (var wt = 0, bt = this.length - 1; bt >= 0; bt--) {
        var At = (this.words[bt] | 0) + wt * 67108864;
        this.words[bt] = At / Qe | 0, wt = At % Qe;
      }
      return this._strip(), at ? this.ineg() : this;
    }, ve.prototype.divn = function(Qe) {
      return this.clone().idivn(Qe);
    }, ve.prototype.egcd = function(Qe) {
      fe(Qe.negative === 0), fe(!Qe.isZero());
      var at = this, wt = Qe.clone();
      at.negative !== 0 ? at = at.umod(Qe) : at = at.clone();
      for (var bt = new ve(1), At = new ve(0), Ft = new ve(0), Gt = new ve(1), ot = 0; at.isEven() && wt.isEven(); )
        at.iushrn(1), wt.iushrn(1), ++ot;
      for (var et = wt.clone(), Rt = at.clone(); !at.isZero(); ) {
        for (var xr = 0, Xt = 1; !(at.words[0] & Xt) && xr < 26; ++xr, Xt <<= 1)
          ;
        if (xr > 0)
          for (at.iushrn(xr); xr-- > 0; )
            (bt.isOdd() || At.isOdd()) && (bt.iadd(et), At.isub(Rt)), bt.iushrn(1), At.iushrn(1);
        for (var dr = 0, Nr = 1; !(wt.words[0] & Nr) && dr < 26; ++dr, Nr <<= 1)
          ;
        if (dr > 0)
          for (wt.iushrn(dr); dr-- > 0; )
            (Ft.isOdd() || Gt.isOdd()) && (Ft.iadd(et), Gt.isub(Rt)), Ft.iushrn(1), Gt.iushrn(1);
        at.cmp(wt) >= 0 ? (at.isub(wt), bt.isub(Ft), At.isub(Gt)) : (wt.isub(at), Ft.isub(bt), Gt.isub(At));
      }
      return {
        a: Ft,
        b: Gt,
        gcd: wt.iushln(ot)
      };
    }, ve.prototype._invmp = function(Qe) {
      fe(Qe.negative === 0), fe(!Qe.isZero());
      var at = this, wt = Qe.clone();
      at.negative !== 0 ? at = at.umod(Qe) : at = at.clone();
      for (var bt = new ve(1), At = new ve(0), Ft = wt.clone(); at.cmpn(1) > 0 && wt.cmpn(1) > 0; ) {
        for (var Gt = 0, ot = 1; !(at.words[0] & ot) && Gt < 26; ++Gt, ot <<= 1)
          ;
        if (Gt > 0)
          for (at.iushrn(Gt); Gt-- > 0; )
            bt.isOdd() && bt.iadd(Ft), bt.iushrn(1);
        for (var et = 0, Rt = 1; !(wt.words[0] & Rt) && et < 26; ++et, Rt <<= 1)
          ;
        if (et > 0)
          for (wt.iushrn(et); et-- > 0; )
            At.isOdd() && At.iadd(Ft), At.iushrn(1);
        at.cmp(wt) >= 0 ? (at.isub(wt), bt.isub(At)) : (wt.isub(at), At.isub(bt));
      }
      var xr;
      return at.cmpn(1) === 0 ? xr = bt : xr = At, xr.cmpn(0) < 0 && xr.iadd(Qe), xr;
    }, ve.prototype.gcd = function(Qe) {
      if (this.isZero())
        return Qe.abs();
      if (Qe.isZero())
        return this.abs();
      var at = this.clone(), wt = Qe.clone();
      at.negative = 0, wt.negative = 0;
      for (var bt = 0; at.isEven() && wt.isEven(); bt++)
        at.iushrn(1), wt.iushrn(1);
      do {
        for (; at.isEven(); )
          at.iushrn(1);
        for (; wt.isEven(); )
          wt.iushrn(1);
        var At = at.cmp(wt);
        if (At < 0) {
          var Ft = at;
          at = wt, wt = Ft;
        } else if (At === 0 || wt.cmpn(1) === 0)
          break;
        at.isub(wt);
      } while (!0);
      return wt.iushln(bt);
    }, ve.prototype.invm = function(Qe) {
      return this.egcd(Qe).a.umod(Qe);
    }, ve.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ve.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ve.prototype.andln = function(Qe) {
      return this.words[0] & Qe;
    }, ve.prototype.bincn = function(Qe) {
      fe(typeof Qe == "number");
      var at = Qe % 26, wt = (Qe - at) / 26, bt = 1 << at;
      if (this.length <= wt)
        return this._expand(wt + 1), this.words[wt] |= bt, this;
      for (var At = bt, Ft = wt; At !== 0 && Ft < this.length; Ft++) {
        var Gt = this.words[Ft] | 0;
        Gt += At, At = Gt >>> 26, Gt &= 67108863, this.words[Ft] = Gt;
      }
      return At !== 0 && (this.words[Ft] = At, this.length++), this;
    }, ve.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ve.prototype.cmpn = function(Qe) {
      var at = Qe < 0;
      if (this.negative !== 0 && !at)
        return -1;
      if (this.negative === 0 && at)
        return 1;
      this._strip();
      var wt;
      if (this.length > 1)
        wt = 1;
      else {
        at && (Qe = -Qe), fe(Qe <= 67108863, "Number is too big");
        var bt = this.words[0] | 0;
        wt = bt === Qe ? 0 : bt < Qe ? -1 : 1;
      }
      return this.negative !== 0 ? -wt | 0 : wt;
    }, ve.prototype.cmp = function(Qe) {
      if (this.negative !== 0 && Qe.negative === 0)
        return -1;
      if (this.negative === 0 && Qe.negative !== 0)
        return 1;
      var at = this.ucmp(Qe);
      return this.negative !== 0 ? -at | 0 : at;
    }, ve.prototype.ucmp = function(Qe) {
      if (this.length > Qe.length)
        return 1;
      if (this.length < Qe.length)
        return -1;
      for (var at = 0, wt = this.length - 1; wt >= 0; wt--) {
        var bt = this.words[wt] | 0, At = Qe.words[wt] | 0;
        if (bt !== At) {
          bt < At ? at = -1 : bt > At && (at = 1);
          break;
        }
      }
      return at;
    }, ve.prototype.gtn = function(Qe) {
      return this.cmpn(Qe) === 1;
    }, ve.prototype.gt = function(Qe) {
      return this.cmp(Qe) === 1;
    }, ve.prototype.gten = function(Qe) {
      return this.cmpn(Qe) >= 0;
    }, ve.prototype.gte = function(Qe) {
      return this.cmp(Qe) >= 0;
    }, ve.prototype.ltn = function(Qe) {
      return this.cmpn(Qe) === -1;
    }, ve.prototype.lt = function(Qe) {
      return this.cmp(Qe) === -1;
    }, ve.prototype.lten = function(Qe) {
      return this.cmpn(Qe) <= 0;
    }, ve.prototype.lte = function(Qe) {
      return this.cmp(Qe) <= 0;
    }, ve.prototype.eqn = function(Qe) {
      return this.cmpn(Qe) === 0;
    }, ve.prototype.eq = function(Qe) {
      return this.cmp(Qe) === 0;
    }, ve.red = function(Qe) {
      return new er(Qe);
    }, ve.prototype.toRed = function(Qe) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), Qe.convertTo(this)._forceRed(Qe);
    }, ve.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ve.prototype._forceRed = function(Qe) {
      return this.red = Qe, this;
    }, ve.prototype.forceRed = function(Qe) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(Qe);
    }, ve.prototype.redAdd = function(Qe) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, Qe);
    }, ve.prototype.redIAdd = function(Qe) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Qe);
    }, ve.prototype.redSub = function(Qe) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, Qe);
    }, ve.prototype.redISub = function(Qe) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, Qe);
    }, ve.prototype.redShl = function(Qe) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, Qe);
    }, ve.prototype.redMul = function(Qe) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, Qe), this.red.mul(this, Qe);
    }, ve.prototype.redIMul = function(Qe) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, Qe), this.red.imul(this, Qe);
    }, ve.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ve.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ve.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ve.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ve.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ve.prototype.redPow = function(Qe) {
      return fe(this.red && !Qe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Qe);
    };
    var Ct = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function It(Ot, Qe) {
      this.name = Ot, this.p = new ve(Qe, 16), this.n = this.p.bitLength(), this.k = new ve(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    It.prototype._tmp = function() {
      var Qe = new ve(null);
      return Qe.words = new Array(Math.ceil(this.n / 13)), Qe;
    }, It.prototype.ireduce = function(Qe) {
      var at = Qe, wt;
      do
        this.split(at, this.tmp), at = this.imulK(at), at = at.iadd(this.tmp), wt = at.bitLength();
      while (wt > this.n);
      var bt = wt < this.n ? -1 : at.ucmp(this.p);
      return bt === 0 ? (at.words[0] = 0, at.length = 1) : bt > 0 ? at.isub(this.p) : at.strip !== void 0 ? at.strip() : at._strip(), at;
    }, It.prototype.split = function(Qe, at) {
      Qe.iushrn(this.n, 0, at);
    }, It.prototype.imulK = function(Qe) {
      return Qe.imul(this.k);
    };
    function Vt() {
      It.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ye(Vt, It), Vt.prototype.split = function(Qe, at) {
      for (var wt = 4194303, bt = Math.min(Qe.length, 9), At = 0; At < bt; At++)
        at.words[At] = Qe.words[At];
      if (at.length = bt, Qe.length <= 9) {
        Qe.words[0] = 0, Qe.length = 1;
        return;
      }
      var Ft = Qe.words[9];
      for (at.words[at.length++] = Ft & wt, At = 10; At < Qe.length; At++) {
        var Gt = Qe.words[At] | 0;
        Qe.words[At - 10] = (Gt & wt) << 4 | Ft >>> 22, Ft = Gt;
      }
      Ft >>>= 22, Qe.words[At - 10] = Ft, Ft === 0 && Qe.length > 10 ? Qe.length -= 10 : Qe.length -= 9;
    }, Vt.prototype.imulK = function(Qe) {
      Qe.words[Qe.length] = 0, Qe.words[Qe.length + 1] = 0, Qe.length += 2;
      for (var at = 0, wt = 0; wt < Qe.length; wt++) {
        var bt = Qe.words[wt] | 0;
        at += bt * 977, Qe.words[wt] = at & 67108863, at = bt * 64 + (at / 67108864 | 0);
      }
      return Qe.words[Qe.length - 1] === 0 && (Qe.length--, Qe.words[Qe.length - 1] === 0 && Qe.length--), Qe;
    };
    function Ut() {
      It.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ye(Ut, It);
    function Zt() {
      It.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ye(Zt, It);
    function tr() {
      It.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ye(tr, It), tr.prototype.imulK = function(Qe) {
      for (var at = 0, wt = 0; wt < Qe.length; wt++) {
        var bt = (Qe.words[wt] | 0) * 19 + at, At = bt & 67108863;
        bt >>>= 26, Qe.words[wt] = At, at = bt;
      }
      return at !== 0 && (Qe.words[Qe.length++] = at), Qe;
    }, ve._prime = function(Qe) {
      if (Ct[Qe])
        return Ct[Qe];
      var at;
      if (Qe === "k256")
        at = new Vt();
      else if (Qe === "p224")
        at = new Ut();
      else if (Qe === "p192")
        at = new Zt();
      else if (Qe === "p25519")
        at = new tr();
      else
        throw new Error("Unknown prime " + Qe);
      return Ct[Qe] = at, at;
    };
    function er(Ot) {
      if (typeof Ot == "string") {
        var Qe = ve._prime(Ot);
        this.m = Qe.p, this.prime = Qe;
      } else
        fe(Ot.gtn(1), "modulus must be greater than 1"), this.m = Ot, this.prime = null;
    }
    er.prototype._verify1 = function(Qe) {
      fe(Qe.negative === 0, "red works only with positives"), fe(Qe.red, "red works only with red numbers");
    }, er.prototype._verify2 = function(Qe, at) {
      fe((Qe.negative | at.negative) === 0, "red works only with positives"), fe(
        Qe.red && Qe.red === at.red,
        "red works only with red numbers"
      );
    }, er.prototype.imod = function(Qe) {
      return this.prime ? this.prime.ireduce(Qe)._forceRed(this) : (Me(Qe, Qe.umod(this.m)._forceRed(this)), Qe);
    }, er.prototype.neg = function(Qe) {
      return Qe.isZero() ? Qe.clone() : this.m.sub(Qe)._forceRed(this);
    }, er.prototype.add = function(Qe, at) {
      this._verify2(Qe, at);
      var wt = Qe.add(at);
      return wt.cmp(this.m) >= 0 && wt.isub(this.m), wt._forceRed(this);
    }, er.prototype.iadd = function(Qe, at) {
      this._verify2(Qe, at);
      var wt = Qe.iadd(at);
      return wt.cmp(this.m) >= 0 && wt.isub(this.m), wt;
    }, er.prototype.sub = function(Qe, at) {
      this._verify2(Qe, at);
      var wt = Qe.sub(at);
      return wt.cmpn(0) < 0 && wt.iadd(this.m), wt._forceRed(this);
    }, er.prototype.isub = function(Qe, at) {
      this._verify2(Qe, at);
      var wt = Qe.isub(at);
      return wt.cmpn(0) < 0 && wt.iadd(this.m), wt;
    }, er.prototype.shl = function(Qe, at) {
      return this._verify1(Qe), this.imod(Qe.ushln(at));
    }, er.prototype.imul = function(Qe, at) {
      return this._verify2(Qe, at), this.imod(Qe.imul(at));
    }, er.prototype.mul = function(Qe, at) {
      return this._verify2(Qe, at), this.imod(Qe.mul(at));
    }, er.prototype.isqr = function(Qe) {
      return this.imul(Qe, Qe.clone());
    }, er.prototype.sqr = function(Qe) {
      return this.mul(Qe, Qe);
    }, er.prototype.sqrt = function(Qe) {
      if (Qe.isZero())
        return Qe.clone();
      var at = this.m.andln(3);
      if (fe(at % 2 === 1), at === 3) {
        var wt = this.m.add(new ve(1)).iushrn(2);
        return this.pow(Qe, wt);
      }
      for (var bt = this.m.subn(1), At = 0; !bt.isZero() && bt.andln(1) === 0; )
        At++, bt.iushrn(1);
      fe(!bt.isZero());
      var Ft = new ve(1).toRed(this), Gt = Ft.redNeg(), ot = this.m.subn(1).iushrn(1), et = this.m.bitLength();
      for (et = new ve(2 * et * et).toRed(this); this.pow(et, ot).cmp(Gt) !== 0; )
        et.redIAdd(Gt);
      for (var Rt = this.pow(et, bt), xr = this.pow(Qe, bt.addn(1).iushrn(1)), Xt = this.pow(Qe, bt), dr = At; Xt.cmp(Ft) !== 0; ) {
        for (var Nr = Xt, Dr = 0; Nr.cmp(Ft) !== 0; Dr++)
          Nr = Nr.redSqr();
        fe(Dr < dr);
        var jr = this.pow(Rt, new ve(1).iushln(dr - Dr - 1));
        xr = xr.redMul(jr), Rt = jr.redSqr(), Xt = Xt.redMul(Rt), dr = Dr;
      }
      return xr;
    }, er.prototype.invm = function(Qe) {
      var at = Qe._invmp(this.m);
      return at.negative !== 0 ? (at.negative = 0, this.imod(at).redNeg()) : this.imod(at);
    }, er.prototype.pow = function(Qe, at) {
      if (at.isZero())
        return new ve(1).toRed(this);
      if (at.cmpn(1) === 0)
        return Qe.clone();
      var wt = 4, bt = new Array(1 << wt);
      bt[0] = new ve(1).toRed(this), bt[1] = Qe;
      for (var At = 2; At < bt.length; At++)
        bt[At] = this.mul(bt[At - 1], Qe);
      var Ft = bt[0], Gt = 0, ot = 0, et = at.bitLength() % 26;
      for (et === 0 && (et = 26), At = at.length - 1; At >= 0; At--) {
        for (var Rt = at.words[At], xr = et - 1; xr >= 0; xr--) {
          var Xt = Rt >> xr & 1;
          if (Ft !== bt[0] && (Ft = this.sqr(Ft)), Xt === 0 && Gt === 0) {
            ot = 0;
            continue;
          }
          Gt <<= 1, Gt |= Xt, ot++, !(ot !== wt && (At !== 0 || xr !== 0)) && (Ft = this.mul(Ft, bt[Gt]), ot = 0, Gt = 0);
        }
        et = 26;
      }
      return Ft;
    }, er.prototype.convertTo = function(Qe) {
      var at = Qe.umod(this.m);
      return at === Qe ? at.clone() : at;
    }, er.prototype.convertFrom = function(Qe) {
      var at = Qe.clone();
      return at.red = null, at;
    }, ve.mont = function(Qe) {
      return new hr(Qe);
    };
    function hr(Ot) {
      er.call(this, Ot), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ve(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ye(hr, er), hr.prototype.convertTo = function(Qe) {
      return this.imod(Qe.ushln(this.shift));
    }, hr.prototype.convertFrom = function(Qe) {
      var at = this.imod(Qe.mul(this.rinv));
      return at.red = null, at;
    }, hr.prototype.imul = function(Qe, at) {
      if (Qe.isZero() || at.isZero())
        return Qe.words[0] = 0, Qe.length = 1, Qe;
      var wt = Qe.imul(at), bt = wt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), At = wt.isub(bt).iushrn(this.shift), Ft = At;
      return At.cmp(this.m) >= 0 ? Ft = At.isub(this.m) : At.cmpn(0) < 0 && (Ft = At.iadd(this.m)), Ft._forceRed(this);
    }, hr.prototype.mul = function(Qe, at) {
      if (Qe.isZero() || at.isZero())
        return new ve(0)._forceRed(this);
      var wt = Qe.mul(at), bt = wt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), At = wt.isub(bt).iushrn(this.shift), Ft = At;
      return At.cmp(this.m) >= 0 ? Ft = At.isub(this.m) : At.cmpn(0) < 0 && (Ft = At.iadd(this.m)), Ft._forceRed(this);
    }, hr.prototype.invm = function(Qe) {
      var at = this.imod(Qe._invmp(this.m).mul(this.r2));
      return at._forceRed(this);
    };
  })(ne, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports), version$2 = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const ne = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((oe) => {
      try {
        if ("test".normalize(oe) !== "test")
          throw new Error("bad normalize");
      } catch {
        ne.push(oe);
      }
    }), ne.length)
      throw new Error("missing " + ne.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (ne) {
    return ne.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(ne) {
  ne.DEBUG = "DEBUG", ne.INFO = "INFO", ne.WARNING = "WARNING", ne.ERROR = "ERROR", ne.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ne) {
  ne.UNKNOWN_ERROR = "UNKNOWN_ERROR", ne.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", ne.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", ne.NETWORK_ERROR = "NETWORK_ERROR", ne.SERVER_ERROR = "SERVER_ERROR", ne.TIMEOUT = "TIMEOUT", ne.BUFFER_OVERRUN = "BUFFER_OVERRUN", ne.NUMERIC_FAULT = "NUMERIC_FAULT", ne.MISSING_NEW = "MISSING_NEW", ne.INVALID_ARGUMENT = "INVALID_ARGUMENT", ne.MISSING_ARGUMENT = "MISSING_ARGUMENT", ne.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", ne.CALL_EXCEPTION = "CALL_EXCEPTION", ne.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", ne.NONCE_EXPIRED = "NONCE_EXPIRED", ne.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", ne.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", ne.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", ne.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(oe) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: oe,
      writable: !1
    });
  }
  _log(oe, ae) {
    const fe = oe.toLowerCase();
    LogLevels[fe] == null && this.throwArgumentError("invalid log level name", "logLevel", oe), !(_logLevel > LogLevels[fe]) && console.log.apply(console, ae);
  }
  debug(...oe) {
    this._log(Logger.levels.DEBUG, oe);
  }
  info(...oe) {
    this._log(Logger.levels.INFO, oe);
  }
  warn(...oe) {
    this._log(Logger.levels.WARNING, oe);
  }
  makeError(oe, ae, fe) {
    if (_censorErrors)
      return this.makeError("censored error", ae, {});
    ae || (ae = Logger.errors.UNKNOWN_ERROR), fe || (fe = {});
    const ye = [];
    Object.keys(fe).forEach((Oe) => {
      const $e = fe[Oe];
      try {
        if ($e instanceof Uint8Array) {
          let Me = "";
          for (let Re = 0; Re < $e.length; Re++)
            Me += HEX[$e[Re] >> 4], Me += HEX[$e[Re] & 15];
          ye.push(Oe + "=Uint8Array(0x" + Me + ")");
        } else
          ye.push(Oe + "=" + JSON.stringify($e));
      } catch {
        ye.push(Oe + "=" + JSON.stringify(fe[Oe].toString()));
      }
    }), ye.push(`code=${ae}`), ye.push(`version=${this.version}`);
    const ve = oe;
    let _e = "";
    switch (ae) {
      case ErrorCode.NUMERIC_FAULT: {
        _e = "NUMERIC_FAULT";
        const Oe = oe;
        switch (Oe) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            _e += "-" + Oe;
            break;
          case "negative-power":
          case "negative-width":
            _e += "-unsupported";
            break;
          case "unbound-bitwise-result":
            _e += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        _e = ae;
        break;
    }
    _e && (oe += " [ See: https://links.ethers.org/v5-errors-" + _e + " ]"), ye.length && (oe += " (" + ye.join(", ") + ")");
    const xe = new Error(oe);
    return xe.reason = ve, xe.code = ae, Object.keys(fe).forEach(function(Oe) {
      xe[Oe] = fe[Oe];
    }), xe;
  }
  throwError(oe, ae, fe) {
    throw this.makeError(oe, ae, fe);
  }
  throwArgumentError(oe, ae, fe) {
    return this.throwError(oe, Logger.errors.INVALID_ARGUMENT, {
      argument: ae,
      value: fe
    });
  }
  assert(oe, ae, fe, ye) {
    oe || this.throwError(ae, fe, ye);
  }
  assertArgument(oe, ae, fe, ye) {
    oe || this.throwArgumentError(ae, fe, ye);
  }
  checkNormalize(oe) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(oe, ae) {
    typeof oe == "number" && (ae == null && (ae = "value not safe"), (oe < 0 || oe >= 9007199254740991) && this.throwError(ae, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: oe
    }), oe % 1 && this.throwError(ae, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: oe
    }));
  }
  checkArgumentCount(oe, ae, fe) {
    fe ? fe = ": " + fe : fe = "", oe < ae && this.throwError("missing argument" + fe, Logger.errors.MISSING_ARGUMENT, {
      count: oe,
      expectedCount: ae
    }), oe > ae && this.throwError("too many arguments" + fe, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: oe,
      expectedCount: ae
    });
  }
  checkNew(oe, ae) {
    (oe === Object || oe == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: ae.name });
  }
  checkAbstract(oe, ae) {
    oe === ae ? this.throwError("cannot instantiate abstract class " + JSON.stringify(ae.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: oe.name, operation: "new" }) : (oe === Object || oe == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: ae.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$2)), _globalLogger;
  }
  static setCensorship(oe, ae) {
    if (!oe && ae && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!oe)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!oe, _permanentCensorErrors = !!ae;
  }
  static setLogLevel(oe) {
    const ae = LogLevels[oe.toLowerCase()];
    if (ae == null) {
      Logger.globalLogger().warn("invalid log level - " + oe);
      return;
    }
    _logLevel = ae;
  }
  static from(oe) {
    return new Logger(oe);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$1 = "bytes/5.7.0", logger$2 = new Logger(version$1);
function isHexable(ne) {
  return !!ne.toHexString;
}
function addSlice(ne) {
  return ne.slice || (ne.slice = function() {
    const oe = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(ne, oe)));
  }), ne;
}
function isInteger(ne) {
  return typeof ne == "number" && ne == ne && ne % 1 === 0;
}
function isBytes(ne) {
  if (ne == null)
    return !1;
  if (ne.constructor === Uint8Array)
    return !0;
  if (typeof ne == "string" || !isInteger(ne.length) || ne.length < 0)
    return !1;
  for (let oe = 0; oe < ne.length; oe++) {
    const ae = ne[oe];
    if (!isInteger(ae) || ae < 0 || ae >= 256)
      return !1;
  }
  return !0;
}
function arrayify(ne, oe) {
  if (oe || (oe = {}), typeof ne == "number") {
    logger$2.checkSafeUint53(ne, "invalid arrayify value");
    const ae = [];
    for (; ne; )
      ae.unshift(ne & 255), ne = parseInt(String(ne / 256));
    return ae.length === 0 && ae.push(0), addSlice(new Uint8Array(ae));
  }
  if (oe.allowMissingPrefix && typeof ne == "string" && ne.substring(0, 2) !== "0x" && (ne = "0x" + ne), isHexable(ne) && (ne = ne.toHexString()), isHexString(ne)) {
    let ae = ne.substring(2);
    ae.length % 2 && (oe.hexPad === "left" ? ae = "0" + ae : oe.hexPad === "right" ? ae += "0" : logger$2.throwArgumentError("hex data is odd-length", "value", ne));
    const fe = [];
    for (let ye = 0; ye < ae.length; ye += 2)
      fe.push(parseInt(ae.substring(ye, ye + 2), 16));
    return addSlice(new Uint8Array(fe));
  }
  return isBytes(ne) ? addSlice(new Uint8Array(ne)) : logger$2.throwArgumentError("invalid arrayify value", "value", ne);
}
function isHexString(ne, oe) {
  return !(typeof ne != "string" || !ne.match(/^0x[0-9A-Fa-f]*$/) || oe && ne.length !== 2 + 2 * oe);
}
const HexCharacters = "0123456789abcdef";
function hexlify(ne, oe) {
  if (oe || (oe = {}), typeof ne == "number") {
    logger$2.checkSafeUint53(ne, "invalid hexlify value");
    let ae = "";
    for (; ne; )
      ae = HexCharacters[ne & 15] + ae, ne = Math.floor(ne / 16);
    return ae.length ? (ae.length % 2 && (ae = "0" + ae), "0x" + ae) : "0x00";
  }
  if (typeof ne == "bigint")
    return ne = ne.toString(16), ne.length % 2 ? "0x0" + ne : "0x" + ne;
  if (oe.allowMissingPrefix && typeof ne == "string" && ne.substring(0, 2) !== "0x" && (ne = "0x" + ne), isHexable(ne))
    return ne.toHexString();
  if (isHexString(ne))
    return ne.length % 2 && (oe.hexPad === "left" ? ne = "0x0" + ne.substring(2) : oe.hexPad === "right" ? ne += "0" : logger$2.throwArgumentError("hex data is odd-length", "value", ne)), ne.toLowerCase();
  if (isBytes(ne)) {
    let ae = "0x";
    for (let fe = 0; fe < ne.length; fe++) {
      let ye = ne[fe];
      ae += HexCharacters[(ye & 240) >> 4] + HexCharacters[ye & 15];
    }
    return ae;
  }
  return logger$2.throwArgumentError("invalid hexlify value", "value", ne);
}
function hexZeroPad(ne, oe) {
  for (typeof ne != "string" ? ne = hexlify(ne) : isHexString(ne) || logger$2.throwArgumentError("invalid hex string", "value", ne), ne.length > 2 * oe + 2 && logger$2.throwArgumentError("value out of range", "value", arguments[1]); ne.length < 2 * oe + 2; )
    ne = "0x0" + ne.substring(2);
  return ne;
}
const version = "bignumber/5.7.0";
var BN = BN$1.BN;
const logger$1 = new Logger(version), _constructorGuard$1 = {}, MAX_SAFE = 9007199254740991;
function isBigNumberish(ne) {
  return ne != null && (BigNumber.isBigNumber(ne) || typeof ne == "number" && ne % 1 === 0 || typeof ne == "string" && !!ne.match(/^-?[0-9]+$/) || isHexString(ne) || typeof ne == "bigint" || isBytes(ne));
}
let _warnedToStringRadix = !1;
class BigNumber {
  constructor(oe, ae) {
    oe !== _constructorGuard$1 && logger$1.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = ae, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(oe) {
    return toBigNumber(toBN(this).fromTwos(oe));
  }
  toTwos(oe) {
    return toBigNumber(toBN(this).toTwos(oe));
  }
  abs() {
    return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this;
  }
  add(oe) {
    return toBigNumber(toBN(this).add(toBN(oe)));
  }
  sub(oe) {
    return toBigNumber(toBN(this).sub(toBN(oe)));
  }
  div(oe) {
    return BigNumber.from(oe).isZero() && throwFault$1("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(oe)));
  }
  mul(oe) {
    return toBigNumber(toBN(this).mul(toBN(oe)));
  }
  mod(oe) {
    const ae = toBN(oe);
    return ae.isNeg() && throwFault$1("division-by-zero", "mod"), toBigNumber(toBN(this).umod(ae));
  }
  pow(oe) {
    const ae = toBN(oe);
    return ae.isNeg() && throwFault$1("negative-power", "pow"), toBigNumber(toBN(this).pow(ae));
  }
  and(oe) {
    const ae = toBN(oe);
    return (this.isNegative() || ae.isNeg()) && throwFault$1("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(ae));
  }
  or(oe) {
    const ae = toBN(oe);
    return (this.isNegative() || ae.isNeg()) && throwFault$1("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(ae));
  }
  xor(oe) {
    const ae = toBN(oe);
    return (this.isNegative() || ae.isNeg()) && throwFault$1("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(ae));
  }
  mask(oe) {
    return (this.isNegative() || oe < 0) && throwFault$1("negative-width", "mask"), toBigNumber(toBN(this).maskn(oe));
  }
  shl(oe) {
    return (this.isNegative() || oe < 0) && throwFault$1("negative-width", "shl"), toBigNumber(toBN(this).shln(oe));
  }
  shr(oe) {
    return (this.isNegative() || oe < 0) && throwFault$1("negative-width", "shr"), toBigNumber(toBN(this).shrn(oe));
  }
  eq(oe) {
    return toBN(this).eq(toBN(oe));
  }
  lt(oe) {
    return toBN(this).lt(toBN(oe));
  }
  lte(oe) {
    return toBN(this).lte(toBN(oe));
  }
  gt(oe) {
    return toBN(this).gt(toBN(oe));
  }
  gte(oe) {
    return toBN(this).gte(toBN(oe));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return logger$1.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? _warnedToStringRadix || (_warnedToStringRadix = !0, logger$1.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? logger$1.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {}) : logger$1.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})), toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(oe) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(oe) {
    if (oe instanceof BigNumber)
      return oe;
    if (typeof oe == "string")
      return oe.match(/^-?0x[0-9a-f]+$/i) ? new BigNumber(_constructorGuard$1, toHex(oe)) : oe.match(/^-?[0-9]+$/) ? new BigNumber(_constructorGuard$1, toHex(new BN(oe))) : logger$1.throwArgumentError("invalid BigNumber string", "value", oe);
    if (typeof oe == "number")
      return oe % 1 && throwFault$1("underflow", "BigNumber.from", oe), (oe >= MAX_SAFE || oe <= -MAX_SAFE) && throwFault$1("overflow", "BigNumber.from", oe), BigNumber.from(String(oe));
    const ae = oe;
    if (typeof ae == "bigint")
      return BigNumber.from(ae.toString());
    if (isBytes(ae))
      return BigNumber.from(hexlify(ae));
    if (ae)
      if (ae.toHexString) {
        const fe = ae.toHexString();
        if (typeof fe == "string")
          return BigNumber.from(fe);
      } else {
        let fe = ae._hex;
        if (fe == null && ae.type === "BigNumber" && (fe = ae.hex), typeof fe == "string" && (isHexString(fe) || fe[0] === "-" && isHexString(fe.substring(1))))
          return BigNumber.from(fe);
      }
    return logger$1.throwArgumentError("invalid BigNumber value", "value", oe);
  }
  static isBigNumber(oe) {
    return !!(oe && oe._isBigNumber);
  }
}
function toHex(ne) {
  if (typeof ne != "string")
    return toHex(ne.toString(16));
  if (ne[0] === "-")
    return ne = ne.substring(1), ne[0] === "-" && logger$1.throwArgumentError("invalid hex", "value", ne), ne = toHex(ne), ne === "0x00" ? ne : "-" + ne;
  if (ne.substring(0, 2) !== "0x" && (ne = "0x" + ne), ne === "0x")
    return "0x00";
  for (ne.length % 2 && (ne = "0x0" + ne.substring(2)); ne.length > 4 && ne.substring(0, 4) === "0x00"; )
    ne = "0x" + ne.substring(4);
  return ne;
}
function toBigNumber(ne) {
  return BigNumber.from(toHex(ne));
}
function toBN(ne) {
  const oe = BigNumber.from(ne).toHexString();
  return oe[0] === "-" ? new BN("-" + oe.substring(3), 16) : new BN(oe.substring(2), 16);
}
function throwFault$1(ne, oe, ae) {
  const fe = { fault: ne, operation: oe };
  return ae != null && (fe.value = ae), logger$1.throwError(ne, Logger.errors.NUMERIC_FAULT, fe);
}
const logger = new Logger(version), _constructorGuard = {}, Zero = BigNumber.from(0), NegativeOne = BigNumber.from(-1);
function throwFault(ne, oe, ae, fe) {
  const ye = { fault: oe, operation: ae };
  return fe !== void 0 && (ye.value = fe), logger.throwError(ne, Logger.errors.NUMERIC_FAULT, ye);
}
let zeros = "0";
for (; zeros.length < 256; )
  zeros += zeros;
function getMultiplier(ne) {
  if (typeof ne != "number")
    try {
      ne = BigNumber.from(ne).toNumber();
    } catch {
    }
  return typeof ne == "number" && ne >= 0 && ne <= 256 && !(ne % 1) ? "1" + zeros.substring(0, ne) : logger.throwArgumentError("invalid decimal size", "decimals", ne);
}
function formatFixed(ne, oe) {
  oe == null && (oe = 0);
  const ae = getMultiplier(oe);
  ne = BigNumber.from(ne);
  const fe = ne.lt(Zero);
  fe && (ne = ne.mul(NegativeOne));
  let ye = ne.mod(ae).toString();
  for (; ye.length < ae.length - 1; )
    ye = "0" + ye;
  ye = ye.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const ve = ne.div(ae).toString();
  return ae.length === 1 ? ne = ve : ne = ve + "." + ye, fe && (ne = "-" + ne), ne;
}
function parseFixed(ne, oe) {
  oe == null && (oe = 0);
  const ae = getMultiplier(oe);
  (typeof ne != "string" || !ne.match(/^-?[0-9.]+$/)) && logger.throwArgumentError("invalid decimal value", "value", ne);
  const fe = ne.substring(0, 1) === "-";
  fe && (ne = ne.substring(1)), ne === "." && logger.throwArgumentError("missing value", "value", ne);
  const ye = ne.split(".");
  ye.length > 2 && logger.throwArgumentError("too many decimal points", "value", ne);
  let ve = ye[0], _e = ye[1];
  for (ve || (ve = "0"), _e || (_e = "0"); _e[_e.length - 1] === "0"; )
    _e = _e.substring(0, _e.length - 1);
  for (_e.length > ae.length - 1 && throwFault("fractional component exceeds decimals", "underflow", "parseFixed"), _e === "" && (_e = "0"); _e.length < ae.length - 1; )
    _e += "0";
  const xe = BigNumber.from(ve), Oe = BigNumber.from(_e);
  let $e = xe.mul(ae).add(Oe);
  return fe && ($e = $e.mul(NegativeOne)), $e;
}
class FixedFormat {
  constructor(oe, ae, fe, ye) {
    oe !== _constructorGuard && logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = ae, this.width = fe, this.decimals = ye, this.name = (ae ? "" : "u") + "fixed" + String(fe) + "x" + String(ye), this._multiplier = getMultiplier(ye), Object.freeze(this);
  }
  static from(oe) {
    if (oe instanceof FixedFormat)
      return oe;
    typeof oe == "number" && (oe = `fixed128x${oe}`);
    let ae = !0, fe = 128, ye = 18;
    if (typeof oe == "string") {
      if (oe !== "fixed")
        if (oe === "ufixed")
          ae = !1;
        else {
          const ve = oe.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          ve || logger.throwArgumentError("invalid fixed format", "format", oe), ae = ve[1] !== "u", fe = parseInt(ve[2]), ye = parseInt(ve[3]);
        }
    } else if (oe) {
      const ve = (_e, xe, Oe) => oe[_e] == null ? Oe : (typeof oe[_e] !== xe && logger.throwArgumentError("invalid fixed format (" + _e + " not " + xe + ")", "format." + _e, oe[_e]), oe[_e]);
      ae = ve("signed", "boolean", ae), fe = ve("width", "number", fe), ye = ve("decimals", "number", ye);
    }
    return fe % 8 && logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", fe), ye > 80 && logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", ye), new FixedFormat(_constructorGuard, ae, fe, ye);
  }
}
class FixedNumber {
  constructor(oe, ae, fe, ye) {
    oe !== _constructorGuard && logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = ye, this._hex = ae, this._value = fe, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(oe) {
    this.format.name !== oe.format.name && logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", oe);
  }
  addUnsafe(oe) {
    this._checkFormat(oe);
    const ae = parseFixed(this._value, this.format.decimals), fe = parseFixed(oe._value, oe.format.decimals);
    return FixedNumber.fromValue(ae.add(fe), this.format.decimals, this.format);
  }
  subUnsafe(oe) {
    this._checkFormat(oe);
    const ae = parseFixed(this._value, this.format.decimals), fe = parseFixed(oe._value, oe.format.decimals);
    return FixedNumber.fromValue(ae.sub(fe), this.format.decimals, this.format);
  }
  mulUnsafe(oe) {
    this._checkFormat(oe);
    const ae = parseFixed(this._value, this.format.decimals), fe = parseFixed(oe._value, oe.format.decimals);
    return FixedNumber.fromValue(ae.mul(fe).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(oe) {
    this._checkFormat(oe);
    const ae = parseFixed(this._value, this.format.decimals), fe = parseFixed(oe._value, oe.format.decimals);
    return FixedNumber.fromValue(ae.mul(this.format._multiplier).div(fe), this.format.decimals, this.format);
  }
  floor() {
    const oe = this.toString().split(".");
    oe.length === 1 && oe.push("0");
    let ae = FixedNumber.from(oe[0], this.format);
    const fe = !oe[1].match(/^(0*)$/);
    return this.isNegative() && fe && (ae = ae.subUnsafe(ONE.toFormat(ae.format))), ae;
  }
  ceiling() {
    const oe = this.toString().split(".");
    oe.length === 1 && oe.push("0");
    let ae = FixedNumber.from(oe[0], this.format);
    const fe = !oe[1].match(/^(0*)$/);
    return !this.isNegative() && fe && (ae = ae.addUnsafe(ONE.toFormat(ae.format))), ae;
  }
  // @TODO: Support other rounding algorithms
  round(oe) {
    oe == null && (oe = 0);
    const ae = this.toString().split(".");
    if (ae.length === 1 && ae.push("0"), (oe < 0 || oe > 80 || oe % 1) && logger.throwArgumentError("invalid decimal count", "decimals", oe), ae[1].length <= oe)
      return this;
    const fe = FixedNumber.from("1" + zeros.substring(0, oe), this.format), ye = BUMP.toFormat(this.format);
    return this.mulUnsafe(fe).addUnsafe(ye).floor().divUnsafe(fe);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(oe) {
    if (oe == null)
      return this._hex;
    oe % 8 && logger.throwArgumentError("invalid byte width", "width", oe);
    const ae = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(oe).toHexString();
    return hexZeroPad(ae, oe / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(oe) {
    return FixedNumber.fromString(this._value, oe);
  }
  static fromValue(oe, ae, fe) {
    return fe == null && ae != null && !isBigNumberish(ae) && (fe = ae, ae = null), ae == null && (ae = 0), fe == null && (fe = "fixed"), FixedNumber.fromString(formatFixed(oe, ae), FixedFormat.from(fe));
  }
  static fromString(oe, ae) {
    ae == null && (ae = "fixed");
    const fe = FixedFormat.from(ae), ye = parseFixed(oe, fe.decimals);
    !fe.signed && ye.lt(Zero) && throwFault("unsigned value cannot be negative", "overflow", "value", oe);
    let ve = null;
    fe.signed ? ve = ye.toTwos(fe.width).toHexString() : (ve = ye.toHexString(), ve = hexZeroPad(ve, fe.width / 8));
    const _e = formatFixed(ye, fe.decimals);
    return new FixedNumber(_constructorGuard, ve, _e, fe);
  }
  static fromBytes(oe, ae) {
    ae == null && (ae = "fixed");
    const fe = FixedFormat.from(ae);
    if (arrayify(oe).length > fe.width / 8)
      throw new Error("overflow");
    let ye = BigNumber.from(oe);
    fe.signed && (ye = ye.fromTwos(fe.width));
    const ve = ye.toTwos((fe.signed ? 0 : 1) + fe.width).toHexString(), _e = formatFixed(ye, fe.decimals);
    return new FixedNumber(_constructorGuard, ve, _e, fe);
  }
  static from(oe, ae) {
    if (typeof oe == "string")
      return FixedNumber.fromString(oe, ae);
    if (isBytes(oe))
      return FixedNumber.fromBytes(oe, ae);
    try {
      return FixedNumber.fromValue(oe, 0, ae);
    } catch (fe) {
      if (fe.code !== Logger.errors.INVALID_ARGUMENT)
        throw fe;
    }
    return logger.throwArgumentError("invalid FixedNumber value", "value", oe);
  }
  static isFixedNumber(oe) {
    return !!(oe && oe._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1), BUMP = FixedNumber.from("0.5"), names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(ne, oe) {
  if (typeof oe == "string") {
    const ae = names.indexOf(oe);
    ae !== -1 && (oe = 3 * ae);
  }
  return formatFixed(ne, oe ?? 18);
}
class MudLib {
  constructor() {
    Na(this, "spawnPlayer");
    Na(this, "spawnCapital");
    Na(this, "marchArmy");
    Na(this, "attack");
    Na(this, "buyInfantry");
    Na(this, "garrison");
    Na(this, "buyCavalryA");
    Na(this, "buyCavalryB");
    Na(this, "buyCavalryC");
    Na(this, "stakeTokenB");
    Na(this, "stakeTokenC");
    Na(this, "unStakeTokenB");
    Na(this, "unStakeTokenC");
    Na(this, "farming");
    Na(this, "network");
  }
  async setup() {
    const {
      components: oe,
      systemCalls: {
        spawnPlayer: ae,
        spawnCapital: fe,
        marchArmy: ye,
        attack: ve,
        garrison: _e,
        buyInfantry: xe,
        buyCavalryA: Oe,
        buyCavalryB: $e,
        buyCavalryC: Me,
        stakeTokenB: Re,
        stakeTokenC: je,
        unStakeTokenB: Be,
        unStakeTokenC: ze,
        farming: He,
        setMerkleRoot: qe,
        claim: Ye,
        swapA2B: pt,
        swapA2C: dt,
        withdrawToken: yt,
        transactionTokenA: Ct,
        transactionTokenB: It,
        transactionTokenC: Vt,
        approveTokenA: Ut
      },
      network: Zt
    } = await setup();
    async function tr(bt, At) {
      return await bt.read.balanceOf([At]);
    }
    const er = Zt.walletClient.account.address;
    let hr = -1, Ot = -1, Qe = -1;
    setInterval(async () => {
      const bt = (/* @__PURE__ */ new Date()).toISOString(), At = Number(formatUnits(await tr(Zt.tokenAContract, er), 18));
      At != hr && (hr = At, console.log(`${bt} - tokena updated`, hr), this.tokena_updated(hr));
      const Ft = Number(formatUnits(await tr(Zt.tokenBContract, er), 18));
      Ft != Ot && (Ot = Ft, console.log(`${bt} - tokenb updated`, Ot), this.tokenb_updated(Ot));
      const Gt = Number(formatUnits(await tr(Zt.tokenCContract, er), 18));
      Gt != Qe && (Qe = Gt, console.log(`${bt} - tokenc updated`, Qe), this.tokenc_updated(Qe));
    }, 3e3);
    const at = await Zt.publicClient.getBlockNumber();
    this.spawnPlayer = ae, this.spawnCapital = fe, this.marchArmy = ye, this.attack = ve, this.garrison = _e, this.buyInfantry = xe, this.buyCavalryA = Oe, this.buyCavalryB = $e, this.buyCavalryC = Me, this.stakeTokenB = Re, this.stakeTokenC = je, this.unStakeTokenB = Be, this.unStakeTokenC = ze, this.farming = He, this.setMerkleRoot = qe, this.claim = Ye, this.swapA2B = pt, this.swapA2C = dt, this.withdrawToken = yt, this.transactionTokenA = Ct, this.transactionTokenB = It, this.transactionTokenC = Vt, this.approveTokenA = Ut, Mbe({
      config: mudConfig,
      publicClient: Zt.publicClient,
      walletClient: Zt.walletClient,
      latestBlock$: Zt.latestBlock$,
      storedBlockLogs$: Zt.storedBlockLogs$,
      worldAddress: Zt.worldContract.address,
      worldAbi: Zt.worldContract.abi,
      write$: Zt.write$,
      // tables:mudConfig.tables
      useStore: Zt.useStore
    }), this.network = Zt, oe.Player.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -Player updated`, bt), this.player_updated({
        entity: bt.entity,
        value: bt.value
      });
    }), oe.PlayerDetail.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -PlayerDetails updated`, bt), this.player_detail_updated({
        entity: bt.entity,
        value: bt.value
      });
    }), oe.Land.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -Land updated`, bt), this.land_updated({
        entity: bt.entity,
        value: bt.value
      });
    }), oe.Capital.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -Capital updated`, bt), this.capital_updated({
        entity: bt.entity,
        value: bt.value
      });
    }), oe.Army.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -Army updated`, bt), this.army_updated({
        entity: bt.entity,
        value: bt.value
      });
    }), oe.BattleReport.update$.subscribe((bt) => {
      const At = (/* @__PURE__ */ new Date()).toISOString();
      console.log(`${At} -BattleReport updated`, bt), this.battle_report_updated({
        entity: bt.entity,
        value: bt.value
      });
    });
    let wt = !1;
    Zt.storedBlockLogs$.subscribe((bt) => {
      !wt && bt.blockNumber >= at && (wt = !0, setTimeout(() => {
        const At = (/* @__PURE__ */ new Date()).toISOString();
        console.log(`${At} -all catch up`, at, "=>", bt.blockNumber), this.all_catch_up({});
      }, 2e3));
    });
  }
  // To be overwritten by Godot callback
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  player_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  player_detail_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  land_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  capital_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  army_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  battle_report_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  stored_block_logs(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  setup_block(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  all_catch_up(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  tokena_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  tokenb_updated(oe) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  tokenc_updated(oe) {
  }
}
window.mud = new MudLib();
export {
  BaseError$1 as B,
  HttpRequestError as H,
  InvalidAddressError as I,
  concat$1 as a,
  isHex$1 as b,
  call as c,
  decodeErrorResult as d,
  encodeAbiParameters as e,
  getUrl$1 as g,
  isAddress as i,
  stringify as s
};
