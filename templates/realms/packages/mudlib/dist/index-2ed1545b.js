var YM = Object.defineProperty;
var QM = (ne, oe, ae) => oe in ne ? YM(ne, oe, { enumerable: !0, configurable: !0, writable: !0, value: ae }) : ne[oe] = ae;
var dc = (ne, oe, ae) => (QM(ne, typeof oe != "symbol" ? oe + "" : oe, ae), ae);
function createClientComponents({ components: ne }) {
  return {
    ...ne
    // add your client components or overrides here
  };
}
function createSystemCalls({ tables: ne, worldContract: oe, waitForTransaction: ae }) {
  return {
    spawnPlayer: async () => {
      const gt = await oe.write.spawnPlayer([]);
      await ae(gt);
    },
    marchArmy: async (gt, At, St, Nt, Ft, Vt) => {
      const on = await oe.write.march([gt, At, St, Nt, Ft, Vt]);
      await ae(on);
    },
    attack: async (gt) => {
      const At = await oe.write.attack([gt]);
      await ae(At);
    },
    garrison: async (gt, At, St, Nt, Ft) => {
      const Vt = await oe.write.garrison([gt, At, St, Nt, Ft]);
      await ae(Vt);
    },
    buyInfantry: async (gt) => {
      console.log("worldContract", oe);
      const At = await oe.write.buyInfantry([gt]);
      await ae(At);
    },
    buyCavalryA: async (gt) => {
      const At = await oe.write.buyCavalryA([gt]);
      await ae(At);
    },
    buyCavalryB: async (gt) => {
      const At = await oe.write.buyCavalryB([gt]);
      await ae(At);
    },
    buyCavalryC: async (gt) => {
      const At = await oe.write.buyCavalryC([gt]);
      await ae(At);
    },
    spawnCapital: async (gt) => {
      const At = await oe.write.spawnCapital([gt], {
        value: 5e14
        //ethers.utils.parseEther("0.5"),
      });
      await ae(At);
    },
    stakeTokenB: async (gt) => {
      const At = await oe.write.stakeTokenB([gt]);
      await ae(At);
    },
    stakeTokenC: async (gt) => {
      const At = await oe.write.stakeTokenC([gt]);
      await ae(At);
    },
    unStakeTokenB: async (gt, At) => {
      const St = await oe.write.unStakeTokenB([gt, At]);
      await ae(St);
    },
    unStakeTokenC: async (gt, At) => {
      const St = await oe.write.unStakeTokenC([gt, At]);
      await ae(St);
    },
    farming: async (gt) => {
      const At = await oe.write.farming([gt]);
      await ae(At);
    },
    setMerkleRoot: async (gt) => {
      const At = await oe.write.setMerkleRoot([gt]);
      await ae(At);
    },
    claim: async (gt, At) => {
      const St = await oe.write.claim([gt, At]);
      await ae(St);
    },
    swapA2B: async (gt) => {
      const At = await oe.write.swapA2B([gt]);
      await ae(At);
    },
    swapA2C: async (gt) => {
      const At = await oe.write.swapA2C([gt]);
      await ae(At);
    },
    withdrawToken: async (gt, At) => {
      const St = await oe.write.withdrawToken([gt, At]);
      await ae(St);
    }
  };
}
const version$2 = "1.0.0";
let BaseError$2 = class Zx extends Error {
  constructor(oe, ae = {}) {
    var _e;
    const fe = ae.cause instanceof Zx ? ae.cause.details : (_e = ae.cause) != null && _e.message ? ae.cause.message : ae.details, ye = ae.cause instanceof Zx && ae.cause.docsPath || ae.docsPath, we = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [`Docs: https://abitype.dev${ye}`] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: abitype@${version$2}`
    ].join(`
`);
    super(we), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
};
function execTyped(ne, oe) {
  const ae = ne.exec(oe);
  return ae == null ? void 0 : ae.groups;
}
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex$1 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, isTupleRegex = /^\(.+?\).*?$/, tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(ne) {
  let oe = ne.type;
  if (tupleRegex.test(ne.type) && "components" in ne) {
    oe = "(";
    const ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      const we = ne.components[ye];
      oe += formatAbiParameter(we), ye < ae - 1 && (oe += ", ");
    }
    const fe = execTyped(tupleRegex, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, formatAbiParameter({
      ...ne,
      type: oe
    });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
function formatAbiParameters(ne) {
  let oe = "";
  const ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    const ye = ne[fe];
    oe += formatAbiParameter(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
function formatAbiItem$1(ne) {
  return ne.type === "function" ? `function ${ne.name}(${formatAbiParameters(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${formatAbiParameters(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "constructor" ? `constructor(${formatAbiParameters(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(ne) {
  return errorSignatureRegex.test(ne);
}
function execErrorSignature(ne) {
  return execTyped(errorSignatureRegex, ne);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(ne) {
  return eventSignatureRegex.test(ne);
}
function execEventSignature(ne) {
  return execTyped(eventSignatureRegex, ne);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(ne) {
  return functionSignatureRegex.test(ne);
}
function execFunctionSignature(ne) {
  return execTyped(functionSignatureRegex, ne);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(ne) {
  return structSignatureRegex.test(ne);
}
function execStructSignature(ne) {
  return execTyped(structSignatureRegex, ne);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(ne) {
  return constructorSignatureRegex.test(ne);
}
function execConstructorSignature(ne) {
  return execTyped(constructorSignatureRegex, ne);
}
const fallbackSignatureRegex = /^fallback\(\)$/;
function isFallbackSignature(ne) {
  return fallbackSignatureRegex.test(ne);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(ne) {
  return receiveSignatureRegex.test(ne);
}
const modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]), eventModifiers = /* @__PURE__ */ new Set(["indexed"]), functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class UnknownTypeError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${oe}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [`Type "${oe}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidAbiParametersError extends BaseError$2 {
  constructor({ params: oe }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(oe, null, 2)})`,
      docsPath: "/api/human#parseabiparameters-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiParametersError"
    });
  }
}
class InvalidParameterError extends BaseError$2 {
  constructor({ param: oe }) {
    super("Invalid ABI parameter.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError$2 {
  constructor({ param: oe, name: ae }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `"${ae}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError$2 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError$2 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${fe}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError$2 {
  constructor({ abiParameter: oe }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(oe, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError$2 {
  constructor({ signature: oe, type: ae }) {
    super(`Invalid ${ae} signature.`, {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError$2 {
  constructor({ signature: oe }) {
    super("Unknown signature.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError$2 {
  constructor({ signature: oe }) {
    super("Invalid struct signature.", {
      details: oe,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError$2 {
  constructor({ type: oe }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${oe}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError$2 {
  constructor({ current: oe, depth: ae }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${oe.trim()}" has too many ${ae > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${ae}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(ne, oe) {
  return oe ? `${oe}:${ne}` : ne;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function parseSignature(ne, oe = {}) {
  if (isFunctionSignature(ne)) {
    const ae = execFunctionSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "function" });
    const fe = splitParameters(ae.parameters), ye = [], we = fe.length;
    for (let xe = 0; xe < we; xe++)
      ye.push(parseAbiParameter(fe[xe], {
        modifiers: functionModifiers,
        structs: oe,
        type: "function"
      }));
    const _e = [];
    if (ae.returns) {
      const xe = splitParameters(ae.returns), Oe = xe.length;
      for (let $e = 0; $e < Oe; $e++)
        _e.push(parseAbiParameter(xe[$e], {
          modifiers: functionModifiers,
          structs: oe,
          type: "function"
        }));
    }
    return {
      name: ae.name,
      type: "function",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye,
      outputs: _e
    };
  }
  if (isEventSignature(ne)) {
    const ae = execEventSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "event" });
    const fe = splitParameters(ae.parameters), ye = [], we = fe.length;
    for (let _e = 0; _e < we; _e++)
      ye.push(parseAbiParameter(fe[_e], {
        modifiers: eventModifiers,
        structs: oe,
        type: "event"
      }));
    return { name: ae.name, type: "event", inputs: ye };
  }
  if (isErrorSignature(ne)) {
    const ae = execErrorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "error" });
    const fe = splitParameters(ae.parameters), ye = [], we = fe.length;
    for (let _e = 0; _e < we; _e++)
      ye.push(parseAbiParameter(fe[_e], { structs: oe, type: "error" }));
    return { name: ae.name, type: "error", inputs: ye };
  }
  if (isConstructorSignature(ne)) {
    const ae = execConstructorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "constructor" });
    const fe = splitParameters(ae.parameters), ye = [], we = fe.length;
    for (let _e = 0; _e < we; _e++)
      ye.push(parseAbiParameter(fe[_e], { structs: oe, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye
    };
  }
  if (isFallbackSignature(ne))
    return { type: "fallback" };
  if (isReceiveSignature(ne))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: ne });
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(ne, oe) {
  var Ne, je;
  const ae = getParameterCacheKey(ne, oe == null ? void 0 : oe.type);
  if (parameterCache.has(ae))
    return parameterCache.get(ae);
  const fe = isTupleRegex.test(ne), ye = execTyped(fe ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, ne);
  if (!ye)
    throw new InvalidParameterError({ param: ne });
  if (ye.name && isSolidityKeyword(ye.name))
    throw new SolidityProtectedKeywordError({ param: ne, name: ye.name });
  const we = ye.name ? { name: ye.name } : {}, _e = ye.modifier === "indexed" ? { indexed: !0 } : {}, xe = (oe == null ? void 0 : oe.structs) ?? {};
  let Oe, $e = {};
  if (fe) {
    Oe = "tuple";
    const Be = splitParameters(ye.type), ze = [], He = Be.length;
    for (let qe = 0; qe < He; qe++)
      ze.push(parseAbiParameter(Be[qe], { structs: xe }));
    $e = { components: ze };
  } else if (ye.type in xe)
    Oe = "tuple", $e = { components: xe[ye.type] };
  else if (dynamicIntegerRegex.test(ye.type))
    Oe = `${ye.type}256`;
  else if (Oe = ye.type, (oe == null ? void 0 : oe.type) !== "struct" && !isSolidityType(Oe))
    throw new UnknownSolidityTypeError({ type: Oe });
  if (ye.modifier) {
    if (!((je = (Ne = oe == null ? void 0 : oe.modifiers) == null ? void 0 : Ne.has) != null && je.call(Ne, ye.modifier)))
      throw new InvalidModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
    if (functionModifiers.has(ye.modifier) && !isValidDataLocation(Oe, !!ye.array))
      throw new InvalidFunctionModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
  }
  const Re = {
    type: `${Oe}${ye.array ?? ""}`,
    ...we,
    ..._e,
    ...$e
  };
  return parameterCache.set(ae, Re), Re;
}
function splitParameters(ne, oe = [], ae = "", fe = 0) {
  const ye = ne.trim().length;
  for (let we = 0; we < ye; we++) {
    const _e = ne[we], xe = ne.slice(we + 1);
    switch (_e) {
      case ",":
        return fe === 0 ? splitParameters(xe, [...oe, ae.trim()]) : splitParameters(xe, oe, `${ae}${_e}`, fe);
      case "(":
        return splitParameters(xe, oe, `${ae}${_e}`, fe + 1);
      case ")":
        return splitParameters(xe, oe, `${ae}${_e}`, fe - 1);
      default:
        return splitParameters(xe, oe, `${ae}${_e}`, fe);
    }
  }
  if (ae === "")
    return oe;
  if (fe !== 0)
    throw new InvalidParenthesisError({ current: ae, depth: fe });
  return oe.push(ae.trim()), oe;
}
function isSolidityType(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || bytesRegex$1.test(ne) || integerRegex$1.test(ne);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || ne === "tuple" || bytesRegex$1.test(ne) || integerRegex$1.test(ne) || protectedKeywordsRegex.test(ne);
}
function isValidDataLocation(ne, oe) {
  return oe || ne === "bytes" || ne === "string" || ne === "tuple";
}
function parseStructs(ne) {
  const oe = {}, ae = ne.length;
  for (let _e = 0; _e < ae; _e++) {
    const xe = ne[_e];
    if (!isStructSignature(xe))
      continue;
    const Oe = execStructSignature(xe);
    if (!Oe)
      throw new InvalidSignatureError({ signature: xe, type: "struct" });
    const $e = Oe.properties.split(";"), Re = [], Ne = $e.length;
    for (let je = 0; je < Ne; je++) {
      const ze = $e[je].trim();
      if (!ze)
        continue;
      const He = parseAbiParameter(ze, {
        type: "struct"
      });
      Re.push(He);
    }
    if (!Re.length)
      throw new InvalidStructSignatureError({ signature: xe });
    oe[Oe.name] = Re;
  }
  const fe = {}, ye = Object.entries(oe), we = ye.length;
  for (let _e = 0; _e < we; _e++) {
    const [xe, Oe] = ye[_e];
    fe[xe] = resolveStructs(Oe, oe);
  }
  return fe;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(ne, oe, ae = /* @__PURE__ */ new Set()) {
  const fe = [], ye = ne.length;
  for (let we = 0; we < ye; we++) {
    const _e = ne[we];
    if (isTupleRegex.test(_e.type))
      fe.push(_e);
    else {
      const Oe = execTyped(typeWithoutTupleRegex, _e.type);
      if (!(Oe != null && Oe.type))
        throw new InvalidAbiTypeParameterError({ abiParameter: _e });
      const { array: $e, type: Re } = Oe;
      if (Re in oe) {
        if (ae.has(Re))
          throw new CircularReferenceError({ type: Re });
        fe.push({
          ..._e,
          type: `tuple${$e ?? ""}`,
          components: resolveStructs(oe[Re] ?? [], oe, /* @__PURE__ */ new Set([...ae, Re]))
        });
      } else if (isSolidityType(Re))
        fe.push(_e);
      else
        throw new UnknownTypeError({ type: Re });
    }
  }
  return fe;
}
function parseAbi(ne) {
  const oe = parseStructs(ne), ae = [], fe = ne.length;
  for (let ye = 0; ye < fe; ye++) {
    const we = ne[ye];
    isStructSignature(we) || ae.push(parseSignature(we, oe));
  }
  return ae;
}
function parseAbiParameters(ne) {
  const oe = [];
  if (typeof ne == "string") {
    const ae = splitParameters(ne), fe = ae.length;
    for (let ye = 0; ye < fe; ye++)
      oe.push(parseAbiParameter(ae[ye], { modifiers }));
  } else {
    const ae = parseStructs(ne), fe = ne.length;
    for (let ye = 0; ye < fe; ye++) {
      const we = ne[ye];
      if (isStructSignature(we))
        continue;
      const _e = splitParameters(we), xe = _e.length;
      for (let Oe = 0; Oe < xe; Oe++)
        oe.push(parseAbiParameter(_e[Oe], { modifiers, structs: ae }));
    }
  }
  if (oe.length === 0)
    throw new InvalidAbiParametersError({ params: ne });
  return oe;
}
function getAction(ne, oe, ae) {
  return (fe) => {
    var ye, we;
    return ((ye = ne[oe.name]) == null ? void 0 : ye.call(ne, fe)) ?? ((we = ne[ae]) == null ? void 0 : we.call(ne, fe)) ?? oe(ne, fe);
  };
}
function formatAbiItem(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new InvalidDefinitionTypeError(ne.type);
  return `${ne.name}(${formatAbiParams(ne.inputs, { includeName: oe })})`;
}
function formatAbiParams(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => formatAbiParam(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function formatAbiParam(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${formatAbiParams(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
function isHex$1(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
function size$2(ne) {
  return isHex$1(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
const version$1 = "2.9.20", getContractAddress = (ne) => ne, getUrl$1 = (ne) => ne, getVersion$1 = () => `viem@${version$1}`;
let BaseError$1 = class Gx extends Error {
  constructor(oe, ae = {}) {
    var we;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion$1()
    });
    const fe = ae.cause instanceof Gx ? ae.cause.details : (we = ae.cause) != null && we.message ? ae.cause.message : ae.details, ye = ae.cause instanceof Gx && ae.cause.docsPath || ae.docsPath;
    this.message = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [
        `Docs: https://viem.sh${ye}${ae.docsSlug ? `#${ae.docsSlug}` : ""}`
      ] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
  walk(oe) {
    return walk$1(this, oe);
  }
};
function walk$1(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? walk$1(ne.cause, oe) : oe ? null : ne;
}
class AbiConstructorNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$1 {
  constructor({ data: oe, params: ae, size: fe }) {
    super([`Data size of ${fe} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(ae, { includeName: !0 })})`,
        `Data:   ${oe} (${fe} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe, this.params = ae, this.size = fe;
  }
}
class AbiDecodingZeroDataError extends BaseError$1 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: oe, givenLength: ae, type: fe }) {
    super([
      `ABI encoding array length mismatch for type ${fe}.`,
      `Expected length: ${oe}`,
      `Given length: ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: oe, value: ae }) {
    super(`Size of bytes "${ae}" (bytes${size$2(ae)}) does not match expected size (bytes${oe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: oe, givenLength: ae }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${oe}`,
      `Given length (values): ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded error signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = oe;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$1 {
  constructor({ docsPath: oe }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded event signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Event ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Function ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Function "${oe}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$1 {
  constructor(oe, ae) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${oe.type}\` in \`${formatAbiItem(oe.abiItem)}\`, and`,
        `\`${ae.type}\` in \`${formatAbiItem(ae.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: oe, givenSize: ae }) {
    super(`Expected bytes${oe}, got bytes${ae}.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$1 {
  constructor({ abiItem: oe, data: ae, params: fe, size: ye }) {
    super([
      `Data size of ${ye} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(fe, { includeName: !0 })})`,
        `Data:   ${ae} (${ye} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe, this.data = ae, this.params = fe, this.size = ye;
  }
}
class DecodeLogTopicsMismatch extends BaseError$1 {
  constructor({ abiItem: oe, param: ae }) {
    super([
      `Expected a topic for indexed event parameter${ae.name ? ` "${ae.name}"` : ""} on event "${formatAbiItem(oe, { includeName: !0 })}".`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogTopicsMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$1 {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError$1 {
  constructor(oe) {
    super([`Value "${oe}" is not a valid array.`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$1 {
  constructor(oe) {
    super([
      `"${oe}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidDefinitionTypeError"
    });
  }
}
class UnsupportedPackedAbiType extends BaseError$1 {
  constructor(oe) {
    super(`Type "${oe}" is not supported for packed encoding.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedPackedAbiType"
    });
  }
}
class FilterTypeNotSupportedError extends BaseError$1 {
  constructor(oe) {
    super(`Filter type "${oe}" is not supported.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FilterTypeNotSupportedError"
    });
  }
}
class SliceOffsetOutOfBoundsError extends BaseError$1 {
  constructor({ offset: oe, position: ae, size: fe }) {
    super(`Slice ${ae === "start" ? "starting" : "ending"} at offset "${oe}" is out-of-bounds (size: ${fe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
let SizeExceedsPaddingSizeError$1 = class extends BaseError$1 {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} size (${oe}) exceeds padding size (${ae}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
};
class InvalidBytesLengthError extends BaseError$1 {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} is expected to be ${ae} ${fe} long, but is ${oe} ${fe} long.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesLengthError"
    });
  }
}
function pad$1(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? padHex$1(ne, { dir: oe, size: ae }) : padBytes$1(ne, { dir: oe, size: ae });
}
function padHex$1(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  const fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new SizeExceedsPaddingSizeError$1({
      size: Math.ceil(fe.length / 2),
      targetSize: ae,
      type: "hex"
    });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function padBytes$1(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new SizeExceedsPaddingSizeError$1({
      size: ne.length,
      targetSize: ae,
      type: "bytes"
    });
  const fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    const we = oe === "right";
    fe[we ? ye : ae - ye - 1] = ne[we ? ye : ne.length - ye - 1];
  }
  return fe;
}
class IntegerOutOfRangeError extends BaseError$1 {
  constructor({ max: oe, min: ae, signed: fe, size: ye, value: we }) {
    super(`Number "${we}" is not in safe ${ye ? `${ye * 8}-bit ${fe ? "signed" : "unsigned"} ` : ""}integer range ${oe ? `(${ae} to ${oe})` : `(above ${ae})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    });
  }
}
class InvalidBytesBooleanError extends BaseError$1 {
  constructor(oe) {
    super(`Bytes value "${oe}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError$1 {
  constructor(oe) {
    super(`Hex value "${oe}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidHexBooleanError"
    });
  }
}
let SizeOverflowError$1 = class extends BaseError$1 {
  constructor({ givenSize: oe, maxSize: ae }) {
    super(`Size cannot exceed ${ae} bytes. Given size: ${oe} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
};
function trim(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
function assertSize$1(ne, { size: oe }) {
  if (size$2(ne) > oe)
    throw new SizeOverflowError$1({
      givenSize: size$2(ne),
      maxSize: oe
    });
}
function hexToBigInt(ne, oe = {}) {
  const { signed: ae } = oe;
  oe.size && assertSize$1(ne, { size: oe.size });
  const fe = BigInt(ne);
  if (!ae)
    return fe;
  const ye = (ne.length - 2) / 2, we = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= we ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function hexToBool(ne, oe = {}) {
  let ae = ne;
  if (oe.size && (assertSize$1(ae, { size: oe.size }), ae = trim(ae)), trim(ae) === "0x00")
    return !1;
  if (trim(ae) === "0x01")
    return !0;
  throw new InvalidHexBooleanError(ae);
}
function hexToNumber$1(ne, oe = {}) {
  return Number(hexToBigInt(ne, oe));
}
function hexToString(ne, oe = {}) {
  let ae = hexToBytes$1(ne);
  return oe.size && (assertSize$1(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function toHex(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToHex(ne, oe) : typeof ne == "string" ? stringToHex$1(ne, oe) : typeof ne == "boolean" ? boolToHex(ne, oe) : bytesToHex$2(ne, oe);
}
function boolToHex(ne, oe = {}) {
  const ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { size: oe.size })) : ae;
}
function bytesToHex$2(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += hexes$2[ne[ye]];
  const fe = `0x${ae}`;
  return typeof oe.size == "number" ? (assertSize$1(fe, { size: oe.size }), pad$1(fe, { dir: "right", size: oe.size })) : fe;
}
function numberToHex(ne, oe = {}) {
  const { signed: ae, size: fe } = oe, ye = BigInt(ne);
  let we;
  fe ? ae ? we = (1n << BigInt(fe) * 8n - 1n) - 1n : we = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (we = BigInt(Number.MAX_SAFE_INTEGER));
  const _e = typeof we == "bigint" && ae ? -we - 1n : 0;
  if (we && ye > we || ye < _e) {
    const Oe = typeof ne == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: we ? `${we}${Oe}` : void 0,
      min: `${_e}${Oe}`,
      signed: ae,
      size: fe,
      value: `${ne}${Oe}`
    });
  }
  const xe = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? pad$1(xe, { size: fe }) : xe;
}
const encoder$2 = /* @__PURE__ */ new TextEncoder();
function stringToHex$1(ne, oe = {}) {
  const ae = encoder$2.encode(ne);
  return bytesToHex$2(ae, oe);
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$1(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToBytes(ne, oe) : typeof ne == "boolean" ? boolToBytes(ne, oe) : isHex$1(ne) ? hexToBytes$1(ne, oe) : stringToBytes(ne, oe);
}
function boolToBytes(ne, oe = {}) {
  const ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { size: oe.size })) : ae;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(ne) {
  if (ne >= charCodeMap.zero && ne <= charCodeMap.nine)
    return ne - charCodeMap.zero;
  if (ne >= charCodeMap.A && ne <= charCodeMap.F)
    return ne - (charCodeMap.A - 10);
  if (ne >= charCodeMap.a && ne <= charCodeMap.f)
    return ne - (charCodeMap.a - 10);
}
function hexToBytes$1(ne, oe = {}) {
  let ae = ne;
  oe.size && (assertSize$1(ae, { size: oe.size }), ae = pad$1(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  const ye = fe.length / 2, we = new Uint8Array(ye);
  for (let _e = 0, xe = 0; _e < ye; _e++) {
    const Oe = charCodeToBase16(fe.charCodeAt(xe++)), $e = charCodeToBase16(fe.charCodeAt(xe++));
    if (Oe === void 0 || $e === void 0)
      throw new BaseError$1(`Invalid byte sequence ("${fe[xe - 2]}${fe[xe - 1]}" in "${fe}").`);
    we[_e] = Oe * 16 + $e;
  }
  return we;
}
function numberToBytes(ne, oe) {
  const ae = numberToHex(ne, oe);
  return hexToBytes$1(ae);
}
function stringToBytes(ne, oe = {}) {
  const ae = encoder$1.encode(ne);
  return typeof oe.size == "number" ? (assertSize$1(ae, { size: oe.size }), pad$1(ae, { dir: "right", size: oe.size })) : ae;
}
function number(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function bytes(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function hash$1(ne) {
  if (typeof ne != "function" || typeof ne.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(ne.outputLen), number(ne.blockLen);
}
function exists(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(ne, oe) {
  bytes(ne);
  const ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(ne, oe = !1) {
  return oe ? { h: Number(ne & U32_MASK64), l: Number(ne >> _32n & U32_MASK64) } : { h: Number(ne >> _32n & U32_MASK64) | 0, l: Number(ne & U32_MASK64) | 0 };
}
function split(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    const { h: we, l: _e } = fromBig(ne[ye], oe);
    [ae[ye], fe[ye]] = [we, _e];
  }
  return [ae, fe];
}
const rotlSH = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, rotlSL = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, rotlBH = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, rotlBL = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae, crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (ne) => ne instanceof Uint8Array, u32 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), createView = (ne) => new DataView(ne.buffer, ne.byteOffset, ne.byteLength), rotr = (ne, oe) => ne << 32 - oe | ne >>> oe, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function toBytes(ne) {
  if (typeof ne == "string" && (ne = utf8ToBytes$1(ne)), !u8a$1(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function concatBytes$2(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a$1(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(ne) {
  const oe = (fe) => ne().update(toBytes(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function randomBytes(ne = 32) {
  if (crypto && typeof crypto.getRandomValues == "function")
    return crypto.getRandomValues(new Uint8Array(ne));
  throw new Error("crypto.getRandomValues must be defined");
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$4 = /* @__PURE__ */ BigInt(0), _1n$5 = /* @__PURE__ */ BigInt(1), _2n$3 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let ne = 0, oe = _1n$5, ae = 1, fe = 0; ne < 24; ne++) {
  [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], SHA3_PI.push(2 * (5 * fe + ae)), SHA3_ROTL.push((ne + 1) * (ne + 2) / 2 % 64);
  let ye = _0n$4;
  for (let we = 0; we < 7; we++)
    oe = (oe << _1n$5 ^ (oe >> _7n) * _0x71n) % _256n, oe & _2n$3 && (ye ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(we)) - _1n$5);
  _SHA3_IOTA.push(ye);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, !0), rotlH = (ne, oe, ae) => ae > 32 ? rotlBH(ne, oe, ae) : rotlSH(ne, oe, ae), rotlL = (ne, oe, ae) => ae > 32 ? rotlBL(ne, oe, ae) : rotlSL(ne, oe, ae);
function keccakP(ne, oe = 24) {
  const ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let _e = 0; _e < 10; _e++)
      ae[_e] = ne[_e] ^ ne[_e + 10] ^ ne[_e + 20] ^ ne[_e + 30] ^ ne[_e + 40];
    for (let _e = 0; _e < 10; _e += 2) {
      const xe = (_e + 8) % 10, Oe = (_e + 2) % 10, $e = ae[Oe], Re = ae[Oe + 1], Ne = rotlH($e, Re, 1) ^ ae[xe], je = rotlL($e, Re, 1) ^ ae[xe + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[_e + Be] ^= Ne, ne[_e + Be + 1] ^= je;
    }
    let ye = ne[2], we = ne[3];
    for (let _e = 0; _e < 24; _e++) {
      const xe = SHA3_ROTL[_e], Oe = rotlH(ye, we, xe), $e = rotlL(ye, we, xe), Re = SHA3_PI[_e];
      ye = ne[Re], we = ne[Re + 1], ne[Re] = Oe, ne[Re + 1] = $e;
    }
    for (let _e = 0; _e < 50; _e += 10) {
      for (let xe = 0; xe < 10; xe++)
        ae[xe] = ne[_e + xe];
      for (let xe = 0; xe < 10; xe++)
        ne[_e + xe] ^= ~ae[(xe + 2) % 10] & ae[(xe + 4) % 10];
    }
    ne[0] ^= SHA3_IOTA_H[fe], ne[1] ^= SHA3_IOTA_L[fe];
  }
  ae.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(oe, ae, fe, ye = !1, we = 24) {
    if (super(), this.blockLen = oe, this.suffix = ae, this.outputLen = fe, this.enableXOF = ye, this.rounds = we, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number(fe), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(oe) {
    exists(this);
    const { blockLen: ae, state: fe } = this;
    oe = toBytes(oe);
    const ye = oe.length;
    for (let we = 0; we < ye; ) {
      const _e = Math.min(ae - this.pos, ye - we);
      for (let xe = 0; xe < _e; xe++)
        fe[this.pos++] ^= oe[we++];
      this.pos === ae && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: oe, suffix: ae, pos: fe, blockLen: ye } = this;
    oe[fe] ^= ae, ae & 128 && fe === ye - 1 && this.keccak(), oe[ye - 1] ^= 128, this.keccak();
  }
  writeInto(oe) {
    exists(this, !1), bytes(oe), this.finish();
    const ae = this.state, { blockLen: fe } = this;
    for (let ye = 0, we = oe.length; ye < we; ) {
      this.posOut >= fe && this.keccak();
      const _e = Math.min(fe - this.posOut, we - ye);
      oe.set(ae.subarray(this.posOut, this.posOut + _e), ye), this.posOut += _e, ye += _e;
    }
    return oe;
  }
  xofInto(oe) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(oe);
  }
  xof(oe) {
    return number(oe), this.xofInto(new Uint8Array(oe));
  }
  digestInto(oe) {
    if (output(oe, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(oe), this.destroy(), oe;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(oe) {
    const { blockLen: ae, suffix: fe, outputLen: ye, rounds: we, enableXOF: _e } = this;
    return oe || (oe = new Keccak(ae, fe, ye, _e, we)), oe.state32.set(this.state32), oe.pos = this.pos, oe.posOut = this.posOut, oe.finished = this.finished, oe.rounds = we, oe.suffix = fe, oe.outputLen = ye, oe.enableXOF = _e, oe.destroyed = this.destroyed, oe;
  }
}
const gen = (ne, oe, ae) => wrapConstructor(() => new Keccak(oe, ne, ae)), keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256(ne, oe) {
  const ae = oe || "hex", fe = keccak_256(isHex$1(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex(fe);
}
const hash = (ne) => keccak256(toBytes$1(ne));
function hashSignature(ne) {
  return hash(ne);
}
function normalizeSignature(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", we = !1;
  for (let _e = 0; _e < ne.length; _e++) {
    const xe = ne[_e];
    if (["(", ")", ","].includes(xe) && (oe = !0), xe === "(" && fe++, xe === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (xe === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += xe, xe === ")") {
          we = !0;
          break;
        }
        continue;
      }
      if (xe === " ") {
        ne[_e - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += xe, ae += xe;
    }
  }
  if (!we)
    throw new BaseError$1("Unable to normalize signature.");
  return ye;
}
const toSignature = (ne) => {
  const oe = (() => typeof ne == "string" ? ne : formatAbiItem$1(ne))();
  return normalizeSignature(oe);
};
function toSignatureHash(ne) {
  return hashSignature(toSignature(ne));
}
const toEventSelector = toSignatureHash;
class InvalidAddressError extends BaseError$1 {
  constructor({ address: oe }) {
    super(`Address "${oe}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(oe) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = oe;
  }
  set(oe, ae) {
    return super.set(oe, ae), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
}
function checksumAddress(ne, oe) {
  const ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = keccak256(stringToBytes(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let we = 0; we < 40; we += 2)
    fe[we >> 1] >> 4 >= 8 && ye[we] && (ye[we] = ye[we].toUpperCase()), (fe[we >> 1] & 15) >= 8 && ye[we + 1] && (ye[we + 1] = ye[we + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
function getAddress(ne, oe) {
  if (!isAddress(ne, { strict: !1 }))
    throw new InvalidAddressError({ address: ne });
  return checksumAddress(ne, oe);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/, isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(ne, oe) {
  const { strict: ae = !0 } = oe ?? {};
  if (isAddressCache.has(ne))
    return isAddressCache.get(ne);
  const fe = (() => addressRegex.test(ne) ? ne.toLowerCase() === ne ? !0 : ae ? checksumAddress(ne) === ne : !0 : !1)();
  return isAddressCache.set(ne, fe), fe;
}
function concat$1(ne) {
  return typeof ne[0] == "string" ? concatHex$1(ne) : concatBytes$1(ne);
}
function concatBytes$1(ne) {
  let oe = 0;
  for (const ye of ne)
    oe += ye.length;
  const ae = new Uint8Array(oe);
  let fe = 0;
  for (const ye of ne)
    ae.set(ye, fe), fe += ye.length;
  return ae;
}
function concatHex$1(ne) {
  return `0x${ne.reduce((oe, ae) => oe + ae.replace("0x", ""), "")}`;
}
function slice(ne, oe, ae, { strict: fe } = {}) {
  return isHex$1(ne, { strict: !1 }) ? sliceHex(ne, oe, ae, {
    strict: fe
  }) : sliceBytes(ne, oe, ae, {
    strict: fe
  });
}
function assertStartOffset(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > size$2(ne) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: oe,
      position: "start",
      size: size$2(ne)
    });
}
function assertEndOffset(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && size$2(ne) !== ae - oe)
    throw new SliceOffsetOutOfBoundsError({
      offset: ae,
      position: "end",
      size: size$2(ne)
    });
}
function sliceBytes(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = ne.slice(oe, ae);
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function sliceHex(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function encodeAbiParameters(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = prepareParams({
    params: ne,
    values: oe
  }), fe = encodeParams(ae);
  return fe.length === 0 ? "0x" : fe;
}
function prepareParams({ params: ne, values: oe }) {
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++)
    ae.push(prepareParam({ param: ne[fe], value: oe[fe] }));
  return ae;
}
function prepareParam({ param: ne, value: oe }) {
  const ae = getArrayComponents(ne.type);
  if (ae) {
    const [fe, ye] = ae;
    return encodeArray(oe, { length: fe, param: { ...ne, type: ye } });
  }
  if (ne.type === "tuple")
    return encodeTuple(oe, {
      param: ne
    });
  if (ne.type === "address")
    return encodeAddress(oe);
  if (ne.type === "bool")
    return encodeBool(oe);
  if (ne.type.startsWith("uint") || ne.type.startsWith("int")) {
    const fe = ne.type.startsWith("int");
    return encodeNumber(oe, { signed: fe });
  }
  if (ne.type.startsWith("bytes"))
    return encodeBytes(oe, { param: ne });
  if (ne.type === "string")
    return encodeString(oe);
  throw new InvalidAbiEncodingTypeError(ne.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(ne) {
  let oe = 0;
  for (let we = 0; we < ne.length; we++) {
    const { dynamic: _e, encoded: xe } = ne[we];
    _e ? oe += 32 : oe += size$2(xe);
  }
  const ae = [], fe = [];
  let ye = 0;
  for (let we = 0; we < ne.length; we++) {
    const { dynamic: _e, encoded: xe } = ne[we];
    _e ? (ae.push(numberToHex(oe + ye, { size: 32 })), fe.push(xe), ye += size$2(xe)) : ae.push(xe);
  }
  return concat$1([...ae, ...fe]);
}
function encodeAddress(ne) {
  if (!isAddress(ne))
    throw new InvalidAddressError({ address: ne });
  return { dynamic: !1, encoded: padHex$1(ne.toLowerCase()) };
}
function encodeArray(ne, { length: oe, param: ae }) {
  const fe = oe === null;
  if (!Array.isArray(ne))
    throw new InvalidArrayError(ne);
  if (!fe && ne.length !== oe)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: oe,
      givenLength: ne.length,
      type: `${ae.type}[${oe}]`
    });
  let ye = !1;
  const we = [];
  for (let _e = 0; _e < ne.length; _e++) {
    const xe = prepareParam({ param: ae, value: ne[_e] });
    xe.dynamic && (ye = !0), we.push(xe);
  }
  if (fe || ye) {
    const _e = encodeParams(we);
    if (fe) {
      const xe = numberToHex(we.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: we.length > 0 ? concat$1([xe, _e]) : xe
      };
    }
    if (ye)
      return { dynamic: !0, encoded: _e };
  }
  return {
    dynamic: !1,
    encoded: concat$1(we.map(({ encoded: _e }) => _e))
  };
}
function encodeBytes(ne, { param: oe }) {
  const [, ae] = oe.type.split("bytes"), fe = size$2(ne);
  if (!ae) {
    let ye = ne;
    return fe % 32 !== 0 && (ye = padHex$1(ye, {
      dir: "right",
      size: Math.ceil((ne.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: concat$1([padHex$1(numberToHex(fe, { size: 32 })), ye])
    };
  }
  if (fe !== parseInt(ae))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(ae),
      value: ne
    });
  return { dynamic: !1, encoded: padHex$1(ne, { dir: "right" }) };
}
function encodeBool(ne) {
  if (typeof ne != "boolean")
    throw new BaseError$1(`Invalid boolean value: "${ne}" (type: ${typeof ne}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: padHex$1(boolToHex(ne)) };
}
function encodeNumber(ne, { signed: oe }) {
  return {
    dynamic: !1,
    encoded: numberToHex(ne, {
      size: 32,
      signed: oe
    })
  };
}
function encodeString(ne) {
  const oe = stringToHex$1(ne), ae = Math.ceil(size$2(oe) / 32), fe = [];
  for (let ye = 0; ye < ae; ye++)
    fe.push(padHex$1(slice(oe, ye * 32, (ye + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: concat$1([
      padHex$1(numberToHex(size$2(oe), { size: 32 })),
      ...fe
    ])
  };
}
function encodeTuple(ne, { param: oe }) {
  let ae = !1;
  const fe = [];
  for (let ye = 0; ye < oe.components.length; ye++) {
    const we = oe.components[ye], _e = Array.isArray(ne) ? ye : we.name, xe = prepareParam({
      param: we,
      value: ne[_e]
    });
    fe.push(xe), xe.dynamic && (ae = !0);
  }
  return {
    dynamic: ae,
    encoded: ae ? encodeParams(fe) : concat$1(fe.map(({ encoded: ye }) => ye))
  };
}
function getArrayComponents(ne) {
  const oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? (
    // Return `null` if the array is dynamic.
    [oe[2] ? Number(oe[2]) : null, oe[1]]
  ) : void 0;
}
const toFunctionSelector = (ne) => slice(toSignatureHash(ne), 0, 4);
function getAbiItem(ne) {
  const { abi: oe, args: ae = [], name: fe } = ne, ye = isHex$1(fe, { strict: !1 }), we = oe.filter((xe) => ye ? xe.type === "function" ? toFunctionSelector(xe) === fe : xe.type === "event" ? toEventSelector(xe) === fe : !1 : "name" in xe && xe.name === fe);
  if (we.length === 0)
    return;
  if (we.length === 1)
    return we[0];
  let _e;
  for (const xe of we) {
    if (!("inputs" in xe))
      continue;
    if (!ae || ae.length === 0) {
      if (!xe.inputs || xe.inputs.length === 0)
        return xe;
      continue;
    }
    if (!xe.inputs || xe.inputs.length === 0 || xe.inputs.length !== ae.length)
      continue;
    if (ae.every(($e, Re) => {
      const Ne = "inputs" in xe && xe.inputs[Re];
      return Ne ? isArgOfType($e, Ne) : !1;
    })) {
      if (_e && "inputs" in _e && _e.inputs) {
        const $e = getAmbiguousTypes(xe.inputs, _e.inputs, ae);
        if ($e)
          throw new AbiItemAmbiguityError({
            abiItem: xe,
            type: $e[0]
          }, {
            abiItem: _e,
            type: $e[1]
          });
      }
      _e = xe;
    }
  }
  return _e || we[0];
}
function isArgOfType(ne, oe) {
  const ae = typeof ne, fe = oe.type;
  switch (fe) {
    case "address":
      return isAddress(ne, { strict: !1 });
    case "bool":
      return ae === "boolean";
    case "function":
      return ae === "string";
    case "string":
      return ae === "string";
    default:
      return fe === "tuple" && "components" in oe ? Object.values(oe.components).every((ye, we) => isArgOfType(Object.values(ne)[we], ye)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(fe) ? ae === "number" || ae === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(fe) ? ae === "string" || ne instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(fe) ? Array.isArray(ne) && ne.every((ye) => isArgOfType(ye, {
        ...oe,
        // Pop off `[]` or `[M]` from end of type
        type: fe.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function getAmbiguousTypes(ne, oe, ae) {
  for (const fe in ne) {
    const ye = ne[fe], we = oe[fe];
    if (ye.type === "tuple" && we.type === "tuple" && "components" in ye && "components" in we)
      return getAmbiguousTypes(ye.components, we.components, ae[fe]);
    const _e = [ye.type, we.type];
    if ((() => _e.includes("address") && _e.includes("bytes20") ? !0 : _e.includes("address") && _e.includes("string") ? isAddress(ae[fe], { strict: !1 }) : _e.includes("address") && _e.includes("bytes") ? isAddress(ae[fe], { strict: !1 }) : !1)())
      return _e;
  }
}
const docsPath$4 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(ne) {
  var Oe;
  const { abi: oe, eventName: ae, args: fe } = ne;
  let ye = oe[0];
  if (ae) {
    const $e = getAbiItem({ abi: oe, name: ae });
    if (!$e)
      throw new AbiEventNotFoundError(ae, { docsPath: docsPath$4 });
    ye = $e;
  }
  if (ye.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$4 });
  const we = formatAbiItem(ye), _e = toEventSelector(we);
  let xe = [];
  if (fe && "inputs" in ye) {
    const $e = (Oe = ye.inputs) == null ? void 0 : Oe.filter((Ne) => "indexed" in Ne && Ne.indexed), Re = Array.isArray(fe) ? fe : Object.values(fe).length > 0 ? ($e == null ? void 0 : $e.map((Ne) => fe[Ne.name])) ?? [] : [];
    Re.length > 0 && (xe = ($e == null ? void 0 : $e.map((Ne, je) => Array.isArray(Re[je]) ? Re[je].map((Be, ze) => encodeArg({ param: Ne, value: Re[je][ze] })) : Re[je] ? encodeArg({ param: Ne, value: Re[je] }) : null)) ?? []);
  }
  return [_e, ...xe];
}
function encodeArg({ param: ne, value: oe }) {
  if (ne.type === "string" || ne.type === "bytes")
    return keccak256(toBytes$1(oe));
  if (ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(ne.type);
  return encodeAbiParameters([ne], [oe]);
}
function createFilterRequestScope(ne, { method: oe }) {
  var fe, ye;
  const ae = {};
  return ne.transport.type === "fallback" && ((ye = (fe = ne.transport).onResponse) == null || ye.call(fe, ({ method: we, response: _e, status: xe, transport: Oe }) => {
    xe === "success" && oe === we && (ae[_e] = Oe.request);
  })), (we) => ae[we] || ne.request;
}
async function createContractEventFilter(ne, oe) {
  const { address: ae, abi: fe, args: ye, eventName: we, fromBlock: _e, strict: xe, toBlock: Oe } = oe, $e = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  }), Re = we ? encodeEventTopics({
    abi: fe,
    args: ye,
    eventName: we
  }) : void 0, Ne = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: ae,
        fromBlock: typeof _e == "bigint" ? numberToHex(_e) : _e,
        toBlock: typeof Oe == "bigint" ? numberToHex(Oe) : Oe,
        topics: Re
      }
    ]
  });
  return {
    abi: fe,
    args: ye,
    eventName: we,
    id: Ne,
    request: $e(Ne),
    strict: !!xe,
    type: "event"
  };
}
function parseAccount(ne) {
  return typeof ne == "string" ? { address: ne, type: "json-rpc" } : ne;
}
const docsPath$3 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(ne) {
  const { abi: oe, args: ae, functionName: fe } = ne;
  let ye = oe[0];
  if (fe) {
    const we = getAbiItem({
      abi: oe,
      args: ae,
      name: fe
    });
    if (!we)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$3 });
    ye = we;
  }
  if (ye.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  return {
    abi: [ye],
    functionName: toFunctionSelector(formatAbiItem(ye))
  };
}
function encodeFunctionData(ne) {
  const { args: oe } = ne, { abi: ae, functionName: fe } = (() => {
    var xe;
    return ne.abi.length === 1 && ((xe = ne.functionName) != null && xe.startsWith("0x")) ? ne : prepareEncodeFunctionData(ne);
  })(), ye = ae[0], we = fe, _e = "inputs" in ye && ye.inputs ? encodeAbiParameters(ye.inputs, oe ?? []) : void 0;
  return concatHex$1([we, _e ?? "0x"]);
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class NegativeOffsetError extends BaseError$1 {
  constructor({ offset: oe }) {
    super(`Offset \`${oe}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$1 {
  constructor({ length: oe, position: ae }) {
    super(`Position \`${ae}\` is out of bounds (\`0 < position < ${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError$1 {
  constructor({ count: oe, limit: ae }) {
    super(`Recursive read limit of \`${ae}\` exceeded (recursive read count: \`${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: 1 / 0,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: ne
      });
  },
  decrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  },
  getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  },
  incrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  },
  inspectByte(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectBytes(ne, oe) {
    const ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  },
  inspectUint8(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectUint16(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  },
  inspectUint24(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  },
  inspectUint32(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  },
  pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  },
  pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  },
  pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  },
  pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectByte();
    return this.position++, ne;
  },
  readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    const ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint8();
    return this.position += 1, ne;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint16();
    return this.position += 2, ne;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint24();
    return this.position += 3, ne;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint32();
    return this.position += 4, ne;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(ne) {
    const oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  },
  _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    const ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  }
};
function createCursor(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  const ae = Object.create(staticCursor);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
function bytesToBigInt(ne, oe = {}) {
  typeof oe.size < "u" && assertSize$1(ne, { size: oe.size });
  const ae = bytesToHex$2(ne, oe);
  return hexToBigInt(ae, oe);
}
function bytesToBool(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (assertSize$1(ae, { size: oe.size }), ae = trim(ae)), ae.length > 1 || ae[0] > 1)
    throw new InvalidBytesBooleanError(ae);
  return !!ae[0];
}
function bytesToNumber(ne, oe = {}) {
  typeof oe.size < "u" && assertSize$1(ne, { size: oe.size });
  const ae = bytesToHex$2(ne, oe);
  return hexToNumber$1(ae, oe);
}
function bytesToString(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (assertSize$1(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
function decodeAbiParameters(ne, oe) {
  const ae = typeof oe == "string" ? hexToBytes$1(oe) : oe, fe = createCursor(ae);
  if (size$2(ae) === 0 && ne.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$2(oe) && size$2(oe) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof oe == "string" ? oe : bytesToHex$2(oe),
      params: ne,
      size: size$2(oe)
    });
  let ye = 0;
  const we = [];
  for (let _e = 0; _e < ne.length; ++_e) {
    const xe = ne[_e];
    fe.setPosition(ye);
    const [Oe, $e] = decodeParameter(fe, xe, {
      staticPosition: 0
    });
    ye += $e, we.push(Oe);
  }
  return we;
}
function decodeParameter(ne, oe, { staticPosition: ae }) {
  const fe = getArrayComponents(oe.type);
  if (fe) {
    const [ye, we] = fe;
    return decodeArray(ne, { ...oe, type: we }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return decodeTuple(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return decodeAddress(ne);
  if (oe.type === "bool")
    return decodeBool(ne);
  if (oe.type.startsWith("bytes"))
    return decodeBytes(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return decodeNumber(ne, oe);
  if (oe.type === "string")
    return decodeString(ne, { staticPosition: ae });
  throw new InvalidAbiDecodingTypeError(oe.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32, sizeOfOffset = 32;
function decodeAddress(ne) {
  const oe = ne.readBytes(32);
  return [checksumAddress(bytesToHex$2(sliceBytes(oe, -20))), 32];
}
function decodeArray(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = fe + _e, Oe = xe + sizeOfLength;
    ne.setPosition(xe);
    const $e = bytesToNumber(ne.readBytes(sizeOfLength)), Re = hasDynamicChild(oe);
    let Ne = 0;
    const je = [];
    for (let Be = 0; Be < $e; ++Be) {
      ne.setPosition(Oe + (Re ? Be * 32 : Ne));
      const [ze, He] = decodeParameter(ne, oe, {
        staticPosition: Oe
      });
      Ne += He, je.push(ze);
    }
    return ne.setPosition(fe + 32), [je, 32];
  }
  if (hasDynamicChild(oe)) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = fe + _e, Oe = [];
    for (let $e = 0; $e < ae; ++$e) {
      ne.setPosition(xe + $e * 32);
      const [Re] = decodeParameter(ne, oe, {
        staticPosition: xe
      });
      Oe.push(Re);
    }
    return ne.setPosition(fe + 32), [Oe, 32];
  }
  let ye = 0;
  const we = [];
  for (let _e = 0; _e < ae; ++_e) {
    const [xe, Oe] = decodeParameter(ne, oe, {
      staticPosition: fe + ye
    });
    ye += Oe, we.push(xe);
  }
  return [we, ye];
}
function decodeBool(ne) {
  return [bytesToBool(ne.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(ne, oe, { staticPosition: ae }) {
  const [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    const _e = bytesToNumber(ne.readBytes(32));
    ne.setPosition(ae + _e);
    const xe = bytesToNumber(ne.readBytes(32));
    if (xe === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    const Oe = ne.readBytes(xe);
    return ne.setPosition(ae + 32), [bytesToHex$2(Oe), 32];
  }
  return [bytesToHex$2(ne.readBytes(parseInt(ye), 32)), 32];
}
function decodeNumber(ne, oe) {
  const ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [
    fe > 48 ? bytesToBigInt(ye, { signed: ae }) : bytesToNumber(ye, { signed: ae }),
    32
  ];
}
function decodeTuple(ne, oe, { staticPosition: ae }) {
  const fe = oe.components.length === 0 || oe.components.some(({ name: _e }) => !_e), ye = fe ? [] : {};
  let we = 0;
  if (hasDynamicChild(oe)) {
    const _e = bytesToNumber(ne.readBytes(sizeOfOffset)), xe = ae + _e;
    for (let Oe = 0; Oe < oe.components.length; ++Oe) {
      const $e = oe.components[Oe];
      ne.setPosition(xe + we);
      const [Re, Ne] = decodeParameter(ne, $e, {
        staticPosition: xe
      });
      we += Ne, ye[fe ? Oe : $e == null ? void 0 : $e.name] = Re;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let _e = 0; _e < oe.components.length; ++_e) {
    const xe = oe.components[_e], [Oe, $e] = decodeParameter(ne, xe, {
      staticPosition: ae
    });
    ye[fe ? _e : xe == null ? void 0 : xe.name] = Oe, we += $e;
  }
  return [ye, we];
}
function decodeString(ne, { staticPosition: oe }) {
  const ae = bytesToNumber(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  const ye = bytesToNumber(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  const we = ne.readBytes(ye, 32), _e = bytesToString(trim(we));
  return ne.setPosition(oe + 32), [_e, 32];
}
function hasDynamicChild(ne) {
  var fe;
  const { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(hasDynamicChild);
  const ae = getArrayComponents(ne.type);
  return !!(ae && hasDynamicChild({ ...ne, type: ae[1] }));
}
function decodeErrorResult(ne) {
  const { abi: oe, data: ae } = ne, fe = slice(ae, 0, 4);
  if (fe === "0x")
    throw new AbiDecodingZeroDataError();
  const we = [...oe || [], solidityError, solidityPanic].find((_e) => _e.type === "error" && fe === toFunctionSelector(formatAbiItem(_e)));
  if (!we)
    throw new AbiErrorSignatureNotFoundError(fe, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: we,
    args: "inputs" in we && we.inputs && we.inputs.length > 0 ? decodeAbiParameters(we.inputs, slice(ae, 4)) : void 0,
    errorName: we.name
  };
}
const stringify = (ne, oe, ae) => JSON.stringify(ne, (fe, ye) => {
  const we = typeof ye == "bigint" ? ye.toString() : ye;
  return typeof oe == "function" ? oe(fe, we) : we;
}, ae);
function formatAbiItemWithArgs({ abiItem: ne, args: oe, includeFunctionName: ae = !0, includeName: fe = !1 }) {
  if ("name" in ne && "inputs" in ne && ne.inputs)
    return `${ae ? ne.name : ""}(${ne.inputs.map((ye, we) => `${fe && ye.name ? `${ye.name}: ` : ""}${typeof oe[we] == "object" ? stringify(oe[we]) : oe[we]}`).join(", ")})`;
}
const etherUnits = {
  gwei: 9,
  wei: 18
}, gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits(ne, oe) {
  let ae = ne.toString();
  const fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, we] = [
    ae.slice(0, ae.length - oe),
    ae.slice(ae.length - oe)
  ];
  return we = we.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${we ? `.${we}` : ""}`;
}
function formatEther(ne, oe = "wei") {
  return formatUnits(ne, etherUnits[oe]);
}
function formatGwei(ne, oe = "wei") {
  return formatUnits(ne, gweiUnits[oe]);
}
class AccountStateConflictError extends BaseError$1 {
  constructor({ address: oe }) {
    super(`State for account "${oe}" is set multiple times.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$1 {
  constructor() {
    super("state and stateDiff are set on the same account."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(ne) {
  return ne.reduce((oe, { slot: ae, value: fe }) => `${oe}        ${ae}: ${fe}
`, "");
}
function prettyStateOverride(ne) {
  return ne.reduce((oe, { address: ae, ...fe }) => {
    let ye = `${oe}    ${ae}:
`;
    return fe.nonce && (ye += `      nonce: ${fe.nonce}
`), fe.balance && (ye += `      balance: ${fe.balance}
`), fe.code && (ye += `      code: ${fe.code}
`), fe.state && (ye += `      state:
`, ye += prettyStateMapping(fe.state)), fe.stateDiff && (ye += `      stateDiff:
`, ye += prettyStateMapping(fe.stateDiff)), ye;
  }, `  State Override:
`).slice(0, -1);
}
function prettyPrint(ne) {
  const oe = Object.entries(ne).map(([fe, ye]) => ye === void 0 || ye === !1 ? null : [fe, ye]).filter(Boolean), ae = oe.reduce((fe, [ye]) => Math.max(fe, ye.length), 0);
  return oe.map(([fe, ye]) => `  ${`${fe}:`.padEnd(ae + 1)}  ${ye}`).join(`
`);
}
class FeeConflictError extends BaseError$1 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeConflictError"
    });
  }
}
class InvalidLegacyVError extends BaseError$1 {
  constructor({ v: oe }) {
    super(`Invalid \`v\` value "${oe}". Expected 27 or 28.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidLegacyVError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError$1 {
  constructor({ transaction: oe }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(oe),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class InvalidStorageKeySizeError extends BaseError$1 {
  constructor({ storageKey: oe }) {
    super(`Size for storage key "${oe}" is invalid. Expected 32 bytes. Got ${Math.floor((oe.length - 2) / 2)} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStorageKeySizeError"
    });
  }
}
class TransactionExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: we, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Re, to: Ne, value: je }) {
    var ze;
    const Be = prettyPrint({
      chain: ye && `${ye == null ? void 0 : ye.name} (id: ${ye == null ? void 0 : ye.id})`,
      from: ae == null ? void 0 : ae.address,
      to: Ne,
      value: typeof je < "u" && `${formatEther(je)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: we,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Re
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Request Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionExecutionError"
    }), this.cause = oe;
  }
}
class TransactionNotFoundError extends BaseError$1 {
  constructor({ blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: we }) {
    let _e = "Transaction";
    fe && we !== void 0 && (_e = `Transaction at block time "${fe}" at index "${we}"`), oe && we !== void 0 && (_e = `Transaction at block hash "${oe}" at index "${we}"`), ae && we !== void 0 && (_e = `Transaction at block number "${ae}" at index "${we}"`), ye && (_e = `Transaction with hash "${ye}"`), super(`${_e} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$1 {
  constructor({ hash: oe }) {
    super(`Transaction receipt with hash "${oe}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$1 {
  constructor({ hash: oe }) {
    super(`Timed out while waiting for transaction with hash "${oe}" to be confirmed.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
class CallExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: we, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Re, to: Ne, value: je, stateOverride: Be }) {
    var qe;
    const ze = ae ? parseAccount(ae) : void 0;
    let He = prettyPrint({
      from: ze == null ? void 0 : ze.address,
      to: Ne,
      value: typeof je < "u" && `${formatEther(je)} ${((qe = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : qe.symbol) || "ETH"}`,
      data: we,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Re
    });
    Be && (He += `
${prettyStateOverride(Be)}`), super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Raw Call Arguments:",
        He
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CallExecutionError"
    }), this.cause = oe;
  }
}
class ContractFunctionExecutionError extends BaseError$1 {
  constructor(oe, { abi: ae, args: fe, contractAddress: ye, docsPath: we, functionName: _e, sender: xe }) {
    const Oe = getAbiItem({ abi: ae, args: fe, name: _e }), $e = Oe ? formatAbiItemWithArgs({
      abiItem: Oe,
      args: fe,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, Re = Oe ? formatAbiItem(Oe, { includeName: !0 }) : void 0, Ne = prettyPrint({
      address: ye && getContractAddress(ye),
      function: Re,
      args: $e && $e !== "()" && `${[...Array((_e == null ? void 0 : _e.length) ?? 0).keys()].map(() => " ").join("")}${$e}`,
      sender: xe
    });
    super(oe.shortMessage || `An unknown error occurred while executing the contract function "${_e}".`, {
      cause: oe,
      docsPath: we,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Contract Call:",
        Ne
      ].filter(Boolean)
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionExecutionError"
    }), this.abi = ae, this.args = fe, this.cause = oe, this.contractAddress = ye, this.functionName = _e, this.sender = xe;
  }
}
class ContractFunctionRevertedError extends BaseError$1 {
  constructor({ abi: oe, data: ae, functionName: fe, message: ye }) {
    let we, _e, xe, Oe;
    if (ae && ae !== "0x")
      try {
        _e = decodeErrorResult({ abi: oe, data: ae });
        const { abiItem: Re, errorName: Ne, args: je } = _e;
        if (Ne === "Error")
          Oe = je[0];
        else if (Ne === "Panic") {
          const [Be] = je;
          Oe = panicReasons[Be];
        } else {
          const Be = Re ? formatAbiItem(Re, { includeName: !0 }) : void 0, ze = Re && je ? formatAbiItemWithArgs({
            abiItem: Re,
            args: je,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          xe = [
            Be ? `Error: ${Be}` : "",
            ze && ze !== "()" ? `       ${[...Array((Ne == null ? void 0 : Ne.length) ?? 0).keys()].map(() => " ").join("")}${ze}` : ""
          ];
        }
      } catch (Re) {
        we = Re;
      }
    else
      ye && (Oe = ye);
    let $e;
    we instanceof AbiErrorSignatureNotFoundError && ($e = we.signature, xe = [
      `Unable to decode signature "${$e}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${$e}.`
    ]), super(Oe && Oe !== "execution reverted" || $e ? [
      `The contract function "${fe}" reverted with the following ${$e ? "signature" : "reason"}:`,
      Oe || $e
    ].join(`
`) : `The contract function "${fe}" reverted.`, {
      cause: we,
      metaMessages: xe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = _e, this.reason = Oe, this.signature = $e;
  }
}
class ContractFunctionZeroDataError extends BaseError$1 {
  constructor({ functionName: oe }) {
    super(`The contract function "${oe}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${oe}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class RawContractError extends BaseError$1 {
  constructor({ data: oe, message: ae }) {
    super(ae || ""), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RawContractError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe;
  }
}
class HttpRequestError extends BaseError$1 {
  constructor({ body: oe, details: ae, headers: fe, status: ye, url: we }) {
    super("HTTP request failed.", {
      details: ae,
      metaMessages: [
        ye && `Status: ${ye}`,
        `URL: ${getUrl$1(we)}`,
        oe && `Request body: ${stringify(oe)}`
      ].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = oe, this.headers = fe, this.status = ye, this.url = we;
  }
}
class WebSocketRequestError extends BaseError$1 {
  constructor({ body: oe, details: ae, url: fe }) {
    super("WebSocket request failed.", {
      details: ae,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WebSocketRequestError"
    });
  }
}
class RpcRequestError extends BaseError$1 {
  constructor({ body: oe, error: ae, url: fe }) {
    super("RPC Request failed.", {
      cause: ae,
      details: ae.message,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = ae.code;
  }
}
let TimeoutError$1 = class extends BaseError$1 {
  constructor({ body: oe, url: ae }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl$1(ae)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TimeoutError"
    });
  }
};
const unknownErrorCode = -1;
class RpcError extends BaseError$1 {
  constructor(oe, { code: ae, docsPath: fe, metaMessages: ye, shortMessage: we }) {
    super(we, {
      cause: oe,
      docsPath: fe,
      metaMessages: ye || (oe == null ? void 0 : oe.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = oe.name, this.code = oe instanceof RpcRequestError ? oe.code : ae ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(oe, ae) {
    super(oe, ae), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = ae.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    });
  }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(ne, { abi: oe, address: ae, args: fe, docsPath: ye, functionName: we, sender: _e }) {
  const { code: xe, data: Oe, message: $e, shortMessage: Re } = ne instanceof RawContractError ? ne : ne instanceof BaseError$1 ? ne.walk((je) => "data" in je) || ne.walk() : {}, Ne = (() => ne instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({ functionName: we }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(xe) && (Oe || $e || Re) ? new ContractFunctionRevertedError({
    abi: oe,
    data: typeof Oe == "object" ? Oe.data : Oe,
    functionName: we,
    message: Re ?? $e
  }) : ne)();
  return new ContractFunctionExecutionError(Ne, {
    abi: oe,
    args: fe,
    contractAddress: ae,
    docsPath: ye,
    functionName: we,
    sender: _e
  });
}
class EstimateGasExecutionError extends BaseError$1 {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: we, gas: _e, gasPrice: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, nonce: Re, to: Ne, value: je }) {
    var ze;
    const Be = prettyPrint({
      from: ae == null ? void 0 : ae.address,
      to: Ne,
      value: typeof je < "u" && `${formatEther(je)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: we,
      gas: _e,
      gasPrice: typeof xe < "u" && `${formatGwei(xe)} gwei`,
      maxFeePerGas: typeof Oe < "u" && `${formatGwei(Oe)} gwei`,
      maxPriorityFeePerGas: typeof $e < "u" && `${formatGwei($e)} gwei`,
      nonce: Re
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EstimateGasExecutionError"
    }), this.cause = oe;
  }
}
class ExecutionRevertedError extends BaseError$1 {
  constructor({ cause: oe, message: ae } = {}) {
    var ye;
    const fe = (ye = ae == null ? void 0 : ae.replace("execution reverted: ", "")) == null ? void 0 : ye.replace("execution reverted", "");
    super(`Execution reverted ${fe ? `with reason: ${fe}` : "for an unknown reason"}.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$1 {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$1 {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is higher than the next one expected.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super([
      `Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$1 {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}exceeds the maximum allowed nonce.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$1 {
  constructor({ cause: oe } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: oe,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError$1 {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$1 {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction is too low.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$1 {
  constructor({ cause: oe }) {
    super("The transaction type is not supported for this chain.", {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$1 {
  constructor({ cause: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${fe ? ` = ${formatGwei(fe)} gwei` : ""}).`
    ].join(`
`), {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$1 {
  constructor({ cause: oe }) {
    super(`An error occurred while executing: ${oe == null ? void 0 : oe.shortMessage}`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownNodeError"
    });
  }
}
function getNodeError(ne, oe) {
  const ae = (ne.details || "").toLowerCase(), fe = ne instanceof BaseError$1 ? ne.walk((ye) => ye.code === ExecutionRevertedError.code) : ne;
  return fe instanceof BaseError$1 ? new ExecutionRevertedError({
    cause: ne,
    message: fe.details
  }) : ExecutionRevertedError.nodeMessage.test(ae) ? new ExecutionRevertedError({
    cause: ne,
    message: ne.details
  }) : FeeCapTooHighError.nodeMessage.test(ae) ? new FeeCapTooHighError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : FeeCapTooLowError.nodeMessage.test(ae) ? new FeeCapTooLowError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : NonceTooHighError.nodeMessage.test(ae) ? new NonceTooHighError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceTooLowError.nodeMessage.test(ae) ? new NonceTooLowError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceMaxValueError.nodeMessage.test(ae) ? new NonceMaxValueError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : InsufficientFundsError.nodeMessage.test(ae) ? new InsufficientFundsError({ cause: ne }) : IntrinsicGasTooHighError.nodeMessage.test(ae) ? new IntrinsicGasTooHighError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : IntrinsicGasTooLowError.nodeMessage.test(ae) ? new IntrinsicGasTooLowError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : TransactionTypeNotSupportedError.nodeMessage.test(ae) ? new TransactionTypeNotSupportedError({ cause: ne }) : TipAboveFeeCapError.nodeMessage.test(ae) ? new TipAboveFeeCapError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas,
    maxPriorityFeePerGas: oe == null ? void 0 : oe.maxPriorityFeePerGas
  }) : new UnknownNodeError({
    cause: ne
  });
}
function getEstimateGasError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new EstimateGasExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
function extract(ne, { format: oe }) {
  if (!oe)
    return {};
  const ae = {};
  function fe(we) {
    const _e = Object.keys(we);
    for (const xe of _e)
      xe in ne && (ae[xe] = ne[xe]), we[xe] && typeof we[xe] == "object" && !Array.isArray(we[xe]) && fe(we[xe]);
  }
  const ye = oe(ne || {});
  return fe(ye), ae;
}
function defineFormatter(ne, oe) {
  return ({ exclude: ae, format: fe }) => ({
    exclude: ae,
    format: (ye) => {
      const we = oe(ye);
      if (ae)
        for (const _e of ae)
          delete we[_e];
      return {
        ...we,
        ...fe(ye)
      };
    },
    type: ne
  });
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3"
};
function formatTransactionRequest(ne) {
  const oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => bytesToHex$2(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = numberToHex(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = numberToHex(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = numberToHex(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = numberToHex(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = numberToHex(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = numberToHex(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = rpcTransactionType[ne.type]), typeof ne.value < "u" && (oe.value = numberToHex(ne.value)), oe;
}
function assertRequest(ne) {
  const { account: oe, gasPrice: ae, maxFeePerGas: fe, maxPriorityFeePerGas: ye, to: we } = ne, _e = oe ? parseAccount(oe) : void 0;
  if (_e && !isAddress(_e.address))
    throw new InvalidAddressError({ address: _e.address });
  if (we && !isAddress(we))
    throw new InvalidAddressError({ address: we });
  if (typeof ae < "u" && (typeof fe < "u" || typeof ye < "u"))
    throw new FeeConflictError();
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ye && fe && ye > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ye });
}
class BaseFeeScalarError extends BaseError$1 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$1 {
  constructor() {
    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$1 {
  constructor({ maxPriorityFeePerGas: oe }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(oe)} gwei).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class BlockNotFoundError extends BaseError$1 {
  constructor({ blockHash: oe, blockNumber: ae }) {
    let fe = "Block";
    oe && (fe = `Block at hash "${oe}"`), ae && (fe = `Block at number "${ae}"`), super(`${fe} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlockNotFoundError"
    });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(ne) {
  const oe = {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    chainId: ne.chainId ? hexToNumber$1(ne.chainId) : void 0,
    gas: ne.gas ? BigInt(ne.gas) : void 0,
    gasPrice: ne.gasPrice ? BigInt(ne.gasPrice) : void 0,
    maxFeePerBlobGas: ne.maxFeePerBlobGas ? BigInt(ne.maxFeePerBlobGas) : void 0,
    maxFeePerGas: ne.maxFeePerGas ? BigInt(ne.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: ne.maxPriorityFeePerGas ? BigInt(ne.maxPriorityFeePerGas) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    type: ne.type ? transactionType[ne.type] : void 0,
    typeHex: ne.type ? ne.type : void 0,
    value: ne.value ? BigInt(ne.value) : void 0,
    v: ne.v ? BigInt(ne.v) : void 0
  };
  return oe.yParity = (() => {
    if (ne.yParity)
      return Number(ne.yParity);
    if (typeof oe.v == "bigint") {
      if (oe.v === 0n || oe.v === 27n)
        return 0;
      if (oe.v === 1n || oe.v === 28n)
        return 1;
      if (oe.v >= 35n)
        return oe.v % 2n === 0n ? 1 : 0;
    }
  })(), oe.type === "legacy" && (delete oe.accessList, delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas, delete oe.yParity), oe.type === "eip2930" && (delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas), oe.type === "eip1559" && delete oe.maxFeePerBlobGas, oe;
}
const defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatBlock(ne) {
  var ae;
  const oe = (ae = ne.transactions) == null ? void 0 : ae.map((fe) => typeof fe == "string" ? fe : formatTransaction(fe));
  return {
    ...ne,
    baseFeePerGas: ne.baseFeePerGas ? BigInt(ne.baseFeePerGas) : null,
    blobGasUsed: ne.blobGasUsed ? BigInt(ne.blobGasUsed) : void 0,
    difficulty: ne.difficulty ? BigInt(ne.difficulty) : void 0,
    excessBlobGas: ne.excessBlobGas ? BigInt(ne.excessBlobGas) : void 0,
    gasLimit: ne.gasLimit ? BigInt(ne.gasLimit) : void 0,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : void 0,
    hash: ne.hash ? ne.hash : null,
    logsBloom: ne.logsBloom ? ne.logsBloom : null,
    nonce: ne.nonce ? ne.nonce : null,
    number: ne.number ? BigInt(ne.number) : null,
    size: ne.size ? BigInt(ne.size) : void 0,
    timestamp: ne.timestamp ? BigInt(ne.timestamp) : void 0,
    transactions: oe,
    totalDifficulty: ne.totalDifficulty ? BigInt(ne.totalDifficulty) : null
  };
}
const defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);
async function getBlock(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, includeTransactions: ye } = {}) {
  var Re, Ne, je;
  const we = fe ?? "latest", _e = ye ?? !1, xe = ae !== void 0 ? numberToHex(ae) : void 0;
  let Oe = null;
  if (oe ? Oe = await ne.request({
    method: "eth_getBlockByHash",
    params: [oe, _e]
  }) : Oe = await ne.request({
    method: "eth_getBlockByNumber",
    params: [xe || we, _e]
  }), !Oe)
    throw new BlockNotFoundError({ blockHash: oe, blockNumber: ae });
  return (((je = (Ne = (Re = ne.chain) == null ? void 0 : Re.formatters) == null ? void 0 : Ne.block) == null ? void 0 : je.format) || formatBlock)(Oe);
}
async function getGasPrice(ne) {
  const oe = await ne.request({
    method: "eth_gasPrice"
  });
  return BigInt(oe);
}
async function estimateMaxPriorityFeePerGas(ne, oe) {
  return internal_estimateMaxPriorityFeePerGas(ne, oe);
}
async function internal_estimateMaxPriorityFeePerGas(ne, oe) {
  var we, _e, xe;
  const { block: ae, chain: fe = ne.chain, request: ye } = oe || {};
  if (typeof ((we = fe == null ? void 0 : fe.fees) == null ? void 0 : we.defaultPriorityFee) == "function") {
    const Oe = ae || await getAction(ne, getBlock, "getBlock")({});
    return fe.fees.defaultPriorityFee({
      block: Oe,
      client: ne,
      request: ye
    });
  }
  if (typeof ((_e = fe == null ? void 0 : fe.fees) == null ? void 0 : _e.defaultPriorityFee) < "u")
    return (xe = fe == null ? void 0 : fe.fees) == null ? void 0 : xe.defaultPriorityFee;
  try {
    const Oe = await ne.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(Oe);
  } catch {
    const [Oe, $e] = await Promise.all([
      ae ? Promise.resolve(ae) : getAction(ne, getBlock, "getBlock")({}),
      getAction(ne, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof Oe.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const Re = $e - Oe.baseFeePerGas;
    return Re < 0n ? 0n : Re;
  }
}
async function estimateFeesPerGas(ne, oe) {
  return internal_estimateFeesPerGas(ne, oe);
}
async function internal_estimateFeesPerGas(ne, oe) {
  var je, Be;
  const { block: ae, chain: fe = ne.chain, request: ye, type: we = "eip1559" } = oe || {}, _e = await (async () => {
    var ze, He;
    return typeof ((ze = fe == null ? void 0 : fe.fees) == null ? void 0 : ze.baseFeeMultiplier) == "function" ? fe.fees.baseFeeMultiplier({
      block: ae,
      client: ne,
      request: ye
    }) : ((He = fe == null ? void 0 : fe.fees) == null ? void 0 : He.baseFeeMultiplier) ?? 1.2;
  })();
  if (_e < 1)
    throw new BaseFeeScalarError();
  const Oe = 10 ** (((je = _e.toString().split(".")[1]) == null ? void 0 : je.length) ?? 0), $e = (ze) => ze * BigInt(Math.ceil(_e * Oe)) / BigInt(Oe), Re = ae || await getAction(ne, getBlock, "getBlock")({});
  if (typeof ((Be = fe == null ? void 0 : fe.fees) == null ? void 0 : Be.estimateFeesPerGas) == "function") {
    const ze = await fe.fees.estimateFeesPerGas({
      block: ae,
      client: ne,
      multiply: $e,
      request: ye,
      type: we
    });
    if (ze !== null)
      return ze;
  }
  if (we === "eip1559") {
    if (typeof Re.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const ze = typeof (ye == null ? void 0 : ye.maxPriorityFeePerGas) == "bigint" ? ye.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(ne, {
      block: Re,
      chain: fe,
      request: ye
    }), He = $e(Re.baseFeePerGas);
    return {
      maxFeePerGas: (ye == null ? void 0 : ye.maxFeePerGas) ?? He + ze,
      maxPriorityFeePerGas: ze
    };
  }
  return {
    gasPrice: (ye == null ? void 0 : ye.gasPrice) ?? $e(await getAction(ne, getGasPrice, "getGasPrice")({}))
  };
}
async function getTransactionCount(ne, { address: oe, blockTag: ae = "latest", blockNumber: fe }) {
  const ye = await ne.request({
    method: "eth_getTransactionCount",
    params: [oe, fe ? numberToHex(fe) : ae]
  });
  return hexToNumber$1(ye);
}
class AccountNotFoundError extends BaseError$1 {
  constructor({ docsPath: oe } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join(`
`), {
      docsPath: oe,
      docsSlug: "account"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountNotFoundError"
    });
  }
}
function blobsToCommitments(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((we) => hexToBytes$1(we)) : ne.blobs, ye = [];
  for (const we of fe)
    ye.push(Uint8Array.from(oe.blobToKzgCommitment(we)));
  return ae === "bytes" ? ye : ye.map((we) => bytesToHex$2(we));
}
function blobsToProofs(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((_e) => hexToBytes$1(_e)) : ne.blobs, ye = typeof ne.commitments[0] == "string" ? ne.commitments.map((_e) => hexToBytes$1(_e)) : ne.commitments, we = [];
  for (let _e = 0; _e < fe.length; _e++) {
    const xe = fe[_e], Oe = ye[_e];
    we.push(Uint8Array.from(oe.computeBlobKzgProof(xe, Oe)));
  }
  return ae === "bytes" ? we : we.map((_e) => bytesToHex$2(_e));
}
function setBigUint64(ne, oe, ae, fe) {
  if (typeof ne.setBigUint64 == "function")
    return ne.setBigUint64(oe, ae, fe);
  const ye = BigInt(32), we = BigInt(4294967295), _e = Number(ae >> ye & we), xe = Number(ae & we), Oe = fe ? 4 : 0, $e = fe ? 0 : 4;
  ne.setUint32(oe + Oe, _e, fe), ne.setUint32(oe + $e, xe, fe);
}
class SHA2 extends Hash {
  constructor(oe, ae, fe, ye) {
    super(), this.blockLen = oe, this.outputLen = ae, this.padOffset = fe, this.isLE = ye, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(oe), this.view = createView(this.buffer);
  }
  update(oe) {
    exists(this);
    const { view: ae, buffer: fe, blockLen: ye } = this;
    oe = toBytes(oe);
    const we = oe.length;
    for (let _e = 0; _e < we; ) {
      const xe = Math.min(ye - this.pos, we - _e);
      if (xe === ye) {
        const Oe = createView(oe);
        for (; ye <= we - _e; _e += ye)
          this.process(Oe, _e);
        continue;
      }
      fe.set(oe.subarray(_e, _e + xe), this.pos), this.pos += xe, _e += xe, this.pos === ye && (this.process(ae, 0), this.pos = 0);
    }
    return this.length += oe.length, this.roundClean(), this;
  }
  digestInto(oe) {
    exists(this), output(oe, this), this.finished = !0;
    const { buffer: ae, view: fe, blockLen: ye, isLE: we } = this;
    let { pos: _e } = this;
    ae[_e++] = 128, this.buffer.subarray(_e).fill(0), this.padOffset > ye - _e && (this.process(fe, 0), _e = 0);
    for (let Ne = _e; Ne < ye; Ne++)
      ae[Ne] = 0;
    setBigUint64(fe, ye - 8, BigInt(this.length * 8), we), this.process(fe, 0);
    const xe = createView(oe), Oe = this.outputLen;
    if (Oe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const $e = Oe / 4, Re = this.get();
    if ($e > Re.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ne = 0; Ne < $e; Ne++)
      xe.setUint32(4 * Ne, Re[Ne], we);
  }
  digest() {
    const { buffer: oe, outputLen: ae } = this;
    this.digestInto(oe);
    const fe = oe.slice(0, ae);
    return this.destroy(), fe;
  }
  _cloneInto(oe) {
    oe || (oe = new this.constructor()), oe.set(...this.get());
    const { blockLen: ae, buffer: fe, length: ye, finished: we, destroyed: _e, pos: xe } = this;
    return oe.length = ye, oe.pos = xe, oe.finished = we, oe.destroyed = _e, ye % ae && oe.buffer.set(fe), oe;
  }
}
const Chi = (ne, oe, ae) => ne & oe ^ ~ne & ae, Maj = (ne, oe, ae) => ne & oe ^ ne & ae ^ oe & ae, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: oe, B: ae, C: fe, D: ye, E: we, F: _e, G: xe, H: Oe } = this;
    return [oe, ae, fe, ye, we, _e, xe, Oe];
  }
  // prettier-ignore
  set(oe, ae, fe, ye, we, _e, xe, Oe) {
    this.A = oe | 0, this.B = ae | 0, this.C = fe | 0, this.D = ye | 0, this.E = we | 0, this.F = _e | 0, this.G = xe | 0, this.H = Oe | 0;
  }
  process(oe, ae) {
    for (let Ne = 0; Ne < 16; Ne++, ae += 4)
      SHA256_W[Ne] = oe.getUint32(ae, !1);
    for (let Ne = 16; Ne < 64; Ne++) {
      const je = SHA256_W[Ne - 15], Be = SHA256_W[Ne - 2], ze = rotr(je, 7) ^ rotr(je, 18) ^ je >>> 3, He = rotr(Be, 17) ^ rotr(Be, 19) ^ Be >>> 10;
      SHA256_W[Ne] = He + SHA256_W[Ne - 7] + ze + SHA256_W[Ne - 16] | 0;
    }
    let { A: fe, B: ye, C: we, D: _e, E: xe, F: Oe, G: $e, H: Re } = this;
    for (let Ne = 0; Ne < 64; Ne++) {
      const je = rotr(xe, 6) ^ rotr(xe, 11) ^ rotr(xe, 25), Be = Re + je + Chi(xe, Oe, $e) + SHA256_K[Ne] + SHA256_W[Ne] | 0, He = (rotr(fe, 2) ^ rotr(fe, 13) ^ rotr(fe, 22)) + Maj(fe, ye, we) | 0;
      Re = $e, $e = Oe, Oe = xe, xe = _e + Be | 0, _e = we, we = ye, ye = fe, fe = Be + He | 0;
    }
    fe = fe + this.A | 0, ye = ye + this.B | 0, we = we + this.C | 0, _e = _e + this.D | 0, xe = xe + this.E | 0, Oe = Oe + this.F | 0, $e = $e + this.G | 0, Re = Re + this.H | 0, this.set(fe, ye, we, _e, xe, Oe, $e, Re);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
function sha256(ne, oe) {
  const ae = oe || "hex", fe = sha256$1(isHex$1(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex(fe);
}
function commitmentToVersionedHash(ne) {
  const { commitment: oe, version: ae = 1 } = ne, fe = ne.to ?? (typeof oe == "string" ? "hex" : "bytes"), ye = sha256(oe, "bytes");
  return ye.set([ae], 0), fe === "bytes" ? ye : bytesToHex$2(ye);
}
function commitmentsToVersionedHashes(ne) {
  const { commitments: oe, version: ae } = ne, fe = ne.to ?? (typeof oe[0] == "string" ? "hex" : "bytes"), ye = [];
  for (const we of oe)
    ye.push(commitmentToVersionedHash({
      commitment: we,
      to: fe,
      version: ae
    }));
  return ye;
}
const blobsPerTransaction = 6, bytesPerFieldElement = 32, fieldElementsPerBlob = 4096, bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob, maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction, versionedHashVersionKzg = 1;
class BlobSizeTooLargeError extends BaseError$1 {
  constructor({ maxSize: oe, size: ae }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${oe} bytes`, `Given: ${ae} bytes`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$1 {
  constructor() {
    super("Blob data must not be empty."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EmptyBlobError"
    });
  }
}
class InvalidVersionedHashSizeError extends BaseError$1 {
  constructor({ hash: oe, size: ae }) {
    super(`Versioned hash "${oe}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${ae}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashSizeError"
    });
  }
}
class InvalidVersionedHashVersionError extends BaseError$1 {
  constructor({ hash: oe, version: ae }) {
    super(`Versioned hash "${oe}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${ae}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashVersionError"
    });
  }
}
function toBlobs(ne) {
  const oe = ne.to ?? (typeof ne.data == "string" ? "hex" : "bytes"), ae = typeof ne.data == "string" ? hexToBytes$1(ne.data) : ne.data, fe = size$2(ae);
  if (!fe)
    throw new EmptyBlobError();
  if (fe > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: fe
    });
  const ye = [];
  let we = !0, _e = 0;
  for (; we; ) {
    const xe = createCursor(new Uint8Array(bytesPerBlob));
    let Oe = 0;
    for (; Oe < fieldElementsPerBlob; ) {
      const $e = ae.slice(_e, _e + (bytesPerFieldElement - 1));
      if (xe.pushByte(0), xe.pushBytes($e), $e.length < 31) {
        xe.pushByte(128), we = !1;
        break;
      }
      Oe++, _e += 31;
    }
    ye.push(xe);
  }
  return oe === "bytes" ? ye.map((xe) => xe.bytes) : ye.map((xe) => bytesToHex$2(xe.bytes));
}
function toBlobSidecars(ne) {
  const { data: oe, kzg: ae, to: fe } = ne, ye = ne.blobs ?? toBlobs({ data: oe, to: fe }), we = ne.commitments ?? blobsToCommitments({ blobs: ye, kzg: ae, to: fe }), _e = ne.proofs ?? blobsToProofs({ blobs: ye, commitments: we, kzg: ae, to: fe }), xe = [];
  for (let Oe = 0; Oe < ye.length; Oe++)
    xe.push({
      blob: ye[Oe],
      commitment: we[Oe],
      proof: _e[Oe]
    });
  return xe;
}
function getTransactionType(ne) {
  if (ne.type)
    return ne.type;
  if (typeof ne.blobs < "u" || typeof ne.blobVersionedHashes < "u" || typeof ne.maxFeePerBlobGas < "u" || typeof ne.sidecars < "u")
    return "eip4844";
  if (typeof ne.maxFeePerGas < "u" || typeof ne.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof ne.gasPrice < "u")
    return typeof ne.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: ne });
}
async function getChainId(ne) {
  const oe = await ne.request({
    method: "eth_chainId"
  });
  return hexToNumber$1(oe);
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(ne, oe) {
  const { account: ae = ne.account, blobs: fe, chain: ye, chainId: we, gas: _e, kzg: xe, nonce: Oe, parameters: $e = defaultParameters, type: Re } = oe, Ne = ae ? parseAccount(ae) : void 0, je = { ...oe, ...Ne ? { from: Ne == null ? void 0 : Ne.address } : {} };
  let Be;
  async function ze() {
    return Be || (Be = await getAction(ne, getBlock, "getBlock")({ blockTag: "latest" }), Be);
  }
  if (($e.includes("blobVersionedHashes") || $e.includes("sidecars")) && fe && xe) {
    const He = blobsToCommitments({ blobs: fe, kzg: xe });
    if ($e.includes("blobVersionedHashes")) {
      const qe = commitmentsToVersionedHashes({
        commitments: He,
        to: "hex"
      });
      je.blobVersionedHashes = qe;
    }
    if ($e.includes("sidecars")) {
      const qe = blobsToProofs({ blobs: fe, commitments: He, kzg: xe }), Ye = toBlobSidecars({
        blobs: fe,
        commitments: He,
        proofs: qe,
        to: "hex"
      });
      je.sidecars = Ye;
    }
  }
  if ($e.includes("chainId") && (ye ? je.chainId = ye.id : typeof we < "u" ? je.chainId = we : je.chainId = await getAction(ne, getChainId, "getChainId")({})), $e.includes("nonce") && typeof Oe > "u" && Ne && (je.nonce = await getAction(ne, getTransactionCount, "getTransactionCount")({
    address: Ne.address,
    blockTag: "pending"
  })), ($e.includes("fees") || $e.includes("type")) && typeof Re > "u")
    try {
      je.type = getTransactionType(je);
    } catch {
      const He = await ze();
      je.type = typeof (He == null ? void 0 : He.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if ($e.includes("fees"))
    if (je.type === "eip1559" || je.type === "eip4844") {
      if (typeof je.maxFeePerGas > "u" || typeof je.maxPriorityFeePerGas > "u") {
        const He = await ze(), { maxFeePerGas: qe, maxPriorityFeePerGas: Ye } = await internal_estimateFeesPerGas(ne, {
          block: He,
          chain: ye,
          request: je
        });
        if (typeof oe.maxPriorityFeePerGas > "u" && oe.maxFeePerGas && oe.maxFeePerGas < Ye)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas: Ye
          });
        je.maxPriorityFeePerGas = Ye, je.maxFeePerGas = qe;
      }
    } else {
      if (typeof oe.maxFeePerGas < "u" || typeof oe.maxPriorityFeePerGas < "u")
        throw new Eip1559FeesNotSupportedError();
      const He = await ze(), { gasPrice: qe } = await internal_estimateFeesPerGas(ne, {
        block: He,
        chain: ye,
        request: je,
        type: "legacy"
      });
      je.gasPrice = qe;
    }
  return $e.includes("gas") && typeof _e > "u" && (je.gas = await getAction(ne, estimateGas, "estimateGas")({
    ...je,
    account: Ne ? { address: Ne.address, type: "json-rpc" } : void 0
  })), assertRequest(je), delete je.parameters, je;
}
async function estimateGas(ne, oe) {
  var ye, we, _e;
  const ae = oe.account ?? ne.account, fe = ae ? parseAccount(ae) : void 0;
  try {
    const { accessList: xe, blobs: Oe, blobVersionedHashes: $e, blockNumber: Re, blockTag: Ne, data: je, gas: Be, gasPrice: ze, maxFeePerBlobGas: He, maxFeePerGas: qe, maxPriorityFeePerGas: Ye, nonce: ot, to: tt, value: it, ...ht } = await prepareTransactionRequest(ne, {
      ...oe,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (fe == null ? void 0 : fe.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), At = (Re ? numberToHex(Re) : void 0) || Ne;
    assertRequest(oe);
    const St = (_e = (we = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : we.transactionRequest) == null ? void 0 : _e.format, Ft = (St || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(ht, { format: St }),
      from: fe == null ? void 0 : fe.address,
      accessList: xe,
      blobs: Oe,
      blobVersionedHashes: $e,
      data: je,
      gas: Be,
      gasPrice: ze,
      maxFeePerBlobGas: He,
      maxFeePerGas: qe,
      maxPriorityFeePerGas: Ye,
      nonce: ot,
      to: tt,
      value: it
    }), Vt = await ne.request({
      method: "eth_estimateGas",
      params: At ? [Ft, At] : [Ft]
    });
    return BigInt(Vt);
  } catch (xe) {
    throw getEstimateGasError(xe, {
      ...oe,
      account: fe,
      chain: ne.chain
    });
  }
}
async function estimateContractGas(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: we, ..._e } = oe, xe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: we
  });
  try {
    return await getAction(ne, estimateGas, "estimateGas")({
      data: xe,
      to: fe,
      ..._e
    });
  } catch (Oe) {
    const $e = _e.account ? parseAccount(_e.account) : void 0;
    throw getContractError(Oe, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: we,
      sender: $e == null ? void 0 : $e.address
    });
  }
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog(ne) {
  const { abi: oe, data: ae, strict: fe, topics: ye } = ne, we = fe ?? !0, [_e, ...xe] = ye;
  if (!_e)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath$2 });
  const Oe = oe.find((He) => He.type === "event" && _e === toEventSelector(formatAbiItem(He)));
  if (!(Oe && "name" in Oe) || Oe.type !== "event")
    throw new AbiEventSignatureNotFoundError(_e, { docsPath: docsPath$2 });
  const { name: $e, inputs: Re } = Oe, Ne = Re == null ? void 0 : Re.some((He) => !("name" in He && He.name));
  let je = Ne ? [] : {};
  const Be = Re.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    const qe = Be[He], Ye = xe[He];
    if (!Ye)
      throw new DecodeLogTopicsMismatch({
        abiItem: Oe,
        param: qe
      });
    je[Ne ? He : qe.name || He] = decodeTopic({ param: qe, value: Ye });
  }
  const ze = Re.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        const He = decodeAbiParameters(ze, ae);
        if (He)
          if (Ne)
            je = [...je, ...He];
          else
            for (let qe = 0; qe < ze.length; qe++)
              je[ze[qe].name] = He[qe];
      } catch (He) {
        if (we)
          throw He instanceof AbiDecodingDataSizeTooSmallError || He instanceof PositionOutOfBoundsError ? new DecodeLogDataMismatch({
            abiItem: Oe,
            data: ae,
            params: ze,
            size: size$2(ae)
          }) : He;
      }
    else if (we)
      throw new DecodeLogDataMismatch({
        abiItem: Oe,
        data: "0x",
        params: ze,
        size: 0
      });
  }
  return {
    eventName: $e,
    args: Object.values(je).length > 0 ? je : void 0
  };
}
function decodeTopic({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (decodeAbiParameters([ne], oe) || [])[0];
}
function parseEventLogs({ abi: ne, eventName: oe, logs: ae, strict: fe = !0 }) {
  return ae.map((ye) => {
    var we;
    try {
      const _e = decodeEventLog({
        ...ye,
        abi: ne,
        strict: fe
      });
      return oe && !oe.includes(_e.eventName) ? null : { ..._e, ...ye };
    } catch (_e) {
      let xe, Oe;
      if (_e instanceof AbiEventSignatureNotFoundError)
        return null;
      if (_e instanceof DecodeLogDataMismatch || _e instanceof DecodeLogTopicsMismatch) {
        if (fe)
          return null;
        xe = _e.abiItem.name, Oe = (we = _e.abiItem.inputs) == null ? void 0 : we.some(($e) => !("name" in $e && $e.name));
      }
      return { ...ye, args: Oe ? [] : {}, eventName: xe };
    }
  }).filter(Boolean);
}
function formatLog(ne, { args: oe, eventName: ae } = {}) {
  return {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    logIndex: ne.logIndex ? Number(ne.logIndex) : null,
    transactionHash: ne.transactionHash ? ne.transactionHash : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    ...ae ? { args: oe, eventName: ae } : {}
  };
}
async function getLogs(ne, { address: oe, blockHash: ae, fromBlock: fe, toBlock: ye, event: we, events: _e, args: xe, strict: Oe } = {}) {
  const $e = Oe ?? !1, Re = _e ?? (we ? [we] : void 0);
  let Ne = [];
  Re && (Ne = [
    Re.flatMap((ze) => encodeEventTopics({
      abi: [ze],
      eventName: ze.name,
      args: xe
    }))
  ], we && (Ne = Ne[0]));
  let je;
  ae ? je = await ne.request({
    method: "eth_getLogs",
    params: [{ address: oe, topics: Ne, blockHash: ae }]
  }) : je = await ne.request({
    method: "eth_getLogs",
    params: [
      {
        address: oe,
        topics: Ne,
        fromBlock: typeof fe == "bigint" ? numberToHex(fe) : fe,
        toBlock: typeof ye == "bigint" ? numberToHex(ye) : ye
      }
    ]
  });
  const Be = je.map((ze) => formatLog(ze));
  return Re ? parseEventLogs({
    abi: Re,
    logs: Be,
    strict: $e
  }) : Be;
}
async function getContractEvents(ne, oe) {
  const { abi: ae, address: fe, args: ye, blockHash: we, eventName: _e, fromBlock: xe, toBlock: Oe, strict: $e } = oe, Re = _e ? getAbiItem({ abi: ae, name: _e }) : void 0, Ne = Re ? void 0 : ae.filter((je) => je.type === "event");
  return getAction(ne, getLogs, "getLogs")({
    address: fe,
    args: ye,
    blockHash: we,
    event: Re,
    events: Ne,
    fromBlock: xe,
    toBlock: Oe,
    strict: $e
  });
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(ne) {
  const { abi: oe, args: ae, functionName: fe, data: ye } = ne;
  let we = oe[0];
  if (fe) {
    const xe = getAbiItem({ abi: oe, args: ae, name: fe });
    if (!xe)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$1 });
    we = xe;
  }
  if (we.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!we.outputs)
    throw new AbiFunctionOutputsNotFoundError(we.name, { docsPath: docsPath$1 });
  const _e = decodeAbiParameters(we.outputs, ye);
  if (_e && _e.length > 1)
    return _e;
  if (_e && _e.length === 1)
    return _e[0];
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
], aggregate3Signature = "0x82ad56cb";
class ChainDoesNotSupportContract extends BaseError$1 {
  constructor({ blockNumber: oe, chain: ae, contract: fe }) {
    super(`Chain "${ae.name}" does not support contract "${fe.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...oe && fe.blockCreated && fe.blockCreated > oe ? [
          `- The contract "${fe.name}" was not deployed until block ${fe.blockCreated} (current block ${oe}).`
        ] : [
          `- The chain does not have the contract "${fe.name}" configured.`
        ]
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$1 {
  constructor({ chain: oe, currentChainId: ae }) {
    super(`The current chain of the wallet (id: ${ae}) does not match the target chain for the transaction (id: ${oe.id}  ${oe.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${ae}`,
        `Expected Chain ID: ${oe.id}  ${oe.name}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError$1 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ClientChainNotConfiguredError"
    });
  }
}
class InvalidChainIdError extends BaseError$1 {
  constructor({ chainId: oe }) {
    super(typeof oe == "number" ? `Chain ID "${oe}" is invalid.` : "Chain ID is invalid."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidChainIdError"
    });
  }
}
function getChainContractAddress({ blockNumber: ne, chain: oe, contract: ae }) {
  var ye;
  const fe = (ye = oe == null ? void 0 : oe.contracts) == null ? void 0 : ye[ae];
  if (!fe)
    throw new ChainDoesNotSupportContract({
      chain: oe,
      contract: { name: ae }
    });
  if (ne && fe.blockCreated && fe.blockCreated > ne)
    throw new ChainDoesNotSupportContract({
      blockNumber: ne,
      chain: oe,
      contract: {
        name: ae,
        blockCreated: fe.blockCreated
      }
    });
  return fe.address;
}
function getCallError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new CallExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: ne, id: oe, shouldSplitBatch: ae, wait: fe = 0, sort: ye }) {
  const we = async () => {
    const Re = Oe();
    _e();
    const Ne = Re.map(({ args: je }) => je);
    Ne.length !== 0 && ne(Ne).then((je) => {
      var Be;
      ye && Array.isArray(je) && je.sort(ye);
      for (let ze = 0; ze < Re.length; ze++) {
        const { pendingPromise: He } = Re[ze];
        (Be = He.resolve) == null || Be.call(He, [je[ze], je]);
      }
    }).catch((je) => {
      var Be;
      for (let ze = 0; ze < Re.length; ze++) {
        const { pendingPromise: He } = Re[ze];
        (Be = He.reject) == null || Be.call(He, je);
      }
    });
  }, _e = () => schedulerCache.delete(oe), xe = () => Oe().map(({ args: Re }) => Re), Oe = () => schedulerCache.get(oe) || [], $e = (Re) => schedulerCache.set(oe, [...Oe(), Re]);
  return {
    flush: _e,
    async schedule(Re) {
      const Ne = {}, je = new Promise((He, qe) => {
        Ne.resolve = He, Ne.reject = qe;
      });
      return (ae == null ? void 0 : ae([...xe(), Re])) && we(), Oe().length > 0 ? ($e({ args: Re, pendingPromise: Ne }), je) : ($e({ args: Re, pendingPromise: Ne }), setTimeout(we, fe), je);
    }
  };
}
async function call(ne, oe) {
  var it, ht, gt, At;
  const { account: ae = ne.account, batch: fe = !!((it = ne.batch) != null && it.multicall), blockNumber: ye, blockTag: we = "latest", accessList: _e, blobs: xe, data: Oe, gas: $e, gasPrice: Re, maxFeePerBlobGas: Ne, maxFeePerGas: je, maxPriorityFeePerGas: Be, nonce: ze, to: He, value: qe, stateOverride: Ye, ...ot } = oe, tt = ae ? parseAccount(ae) : void 0;
  try {
    assertRequest(oe);
    const Nt = (ye ? numberToHex(ye) : void 0) || we, Ft = parseStateOverride(Ye), Vt = (At = (gt = (ht = ne.chain) == null ? void 0 : ht.formatters) == null ? void 0 : gt.transactionRequest) == null ? void 0 : At.format, tn = (Vt || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(ot, { format: Vt }),
      from: tt == null ? void 0 : tt.address,
      accessList: _e,
      blobs: xe,
      data: Oe,
      gas: $e,
      gasPrice: Re,
      maxFeePerBlobGas: Ne,
      maxFeePerGas: je,
      maxPriorityFeePerGas: Be,
      nonce: ze,
      to: He,
      value: qe
    });
    if (fe && shouldPerformMulticall({ request: tn }) && !Ft)
      try {
        return await scheduleMulticall(ne, {
          ...tn,
          blockNumber: ye,
          blockTag: we
        });
      } catch (en) {
        if (!(en instanceof ClientChainNotConfiguredError) && !(en instanceof ChainDoesNotSupportContract))
          throw en;
      }
    const _n = await ne.request({
      method: "eth_call",
      params: Ft ? [
        tn,
        Nt,
        Ft
      ] : [tn, Nt]
    });
    return _n === "0x" ? { data: void 0 } : { data: _n };
  } catch (St) {
    const Nt = getRevertErrorData(St), { offchainLookup: Ft, offchainLookupSignature: Vt } = await import("./ccip-6f208825.js");
    if (ne.ccipRead !== !1 && (Nt == null ? void 0 : Nt.slice(0, 10)) === Vt && He)
      return { data: await Ft(ne, { data: Nt, to: He }) };
    throw getCallError(St, {
      ...oe,
      account: tt,
      chain: ne.chain
    });
  }
}
function shouldPerformMulticall({ request: ne }) {
  const { data: oe, to: ae, ...fe } = ne;
  return !(!oe || oe.startsWith(aggregate3Signature) || !ae || Object.values(fe).filter((ye) => typeof ye < "u").length > 0);
}
async function scheduleMulticall(ne, oe) {
  var He;
  const { batchSize: ae = 1024, wait: fe = 0 } = typeof ((He = ne.batch) == null ? void 0 : He.multicall) == "object" ? ne.batch.multicall : {}, { blockNumber: ye, blockTag: we = "latest", data: _e, multicallAddress: xe, to: Oe } = oe;
  let $e = xe;
  if (!$e) {
    if (!ne.chain)
      throw new ClientChainNotConfiguredError();
    $e = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Ne = (ye ? numberToHex(ye) : void 0) || we, { schedule: je } = createBatchScheduler({
    id: `${ne.uid}.${Ne}`,
    wait: fe,
    shouldSplitBatch(qe) {
      return qe.reduce((ot, { data: tt }) => ot + (tt.length - 2), 0) > ae * 2;
    },
    fn: async (qe) => {
      const Ye = qe.map((it) => ({
        allowFailure: !0,
        callData: it.data,
        target: it.to
      })), ot = encodeFunctionData({
        abi: multicall3Abi,
        args: [Ye],
        functionName: "aggregate3"
      }), tt = await ne.request({
        method: "eth_call",
        params: [
          {
            data: ot,
            to: $e
          },
          Ne
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [Ye],
        functionName: "aggregate3",
        data: tt || "0x"
      });
    }
  }), [{ returnData: Be, success: ze }] = await je({ data: _e, to: Oe });
  if (!ze)
    throw new RawContractError({ data: Be });
  return Be === "0x" ? { data: void 0 } : { data: Be };
}
function getRevertErrorData(ne) {
  var ae;
  if (!(ne instanceof BaseError$1))
    return;
  const oe = ne.walk();
  return typeof (oe == null ? void 0 : oe.data) == "object" ? (ae = oe.data) == null ? void 0 : ae.data : oe.data;
}
function parseStateMapping(ne) {
  if (!(!ne || ne.length === 0))
    return ne.reduce((oe, { slot: ae, value: fe }) => {
      if (ae.length !== 66)
        throw new InvalidBytesLengthError({
          size: ae.length,
          targetSize: 66,
          type: "hex"
        });
      if (fe.length !== 66)
        throw new InvalidBytesLengthError({
          size: fe.length,
          targetSize: 66,
          type: "hex"
        });
      return oe[ae] = fe, oe;
    }, {});
}
function parseAccountStateOverride(ne) {
  const { balance: oe, nonce: ae, state: fe, stateDiff: ye, code: we } = ne, _e = {};
  if (we !== void 0 && (_e.code = we), oe !== void 0 && (_e.balance = numberToHex(oe)), ae !== void 0 && (_e.nonce = numberToHex(ae)), fe !== void 0 && (_e.state = parseStateMapping(fe)), ye !== void 0) {
    if (_e.state)
      throw new StateAssignmentConflictError();
    _e.stateDiff = parseStateMapping(ye);
  }
  return _e;
}
function parseStateOverride(ne) {
  if (!ne)
    return;
  const oe = {};
  for (const { address: ae, ...fe } of ne) {
    if (!isAddress(ae, { strict: !1 }))
      throw new InvalidAddressError({ address: ae });
    if (oe[ae])
      throw new AccountStateConflictError({ address: ae });
    oe[ae] = parseAccountStateOverride(fe);
  }
  return oe;
}
async function readContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: we, ..._e } = oe, xe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: we
  });
  try {
    const { data: Oe } = await getAction(ne, call, "call")({
      ..._e,
      data: xe,
      to: fe
    });
    return decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: we,
      data: Oe || "0x"
    });
  } catch (Oe) {
    throw getContractError(Oe, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/readContract",
      functionName: we
    });
  }
}
async function simulateContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: we, functionName: _e, ...xe } = oe, Oe = xe.account ? parseAccount(xe.account) : ne.account, $e = encodeFunctionData({ abi: ae, args: ye, functionName: _e });
  try {
    const { data: Re } = await getAction(ne, call, "call")({
      batch: !1,
      data: `${$e}${we ? we.replace("0x", "") : ""}`,
      to: fe,
      ...xe,
      account: Oe
    }), Ne = decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: _e,
      data: Re || "0x"
    }), je = ae.filter((Be) => "name" in Be && Be.name === oe.functionName);
    return {
      result: Ne,
      request: {
        abi: je,
        address: fe,
        args: ye,
        dataSuffix: we,
        functionName: _e,
        ...xe,
        account: Oe
      }
    };
  } catch (Re) {
    throw getContractError(Re, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/simulateContract",
      functionName: _e,
      sender: Oe == null ? void 0 : Oe.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map(), cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(ne, oe, ae) {
  const fe = ++callbackCount, ye = () => listenersCache.get(ne) || [], we = () => {
    const Re = ye();
    listenersCache.set(ne, Re.filter((Ne) => Ne.id !== fe));
  }, _e = () => {
    const Re = cleanupCache.get(ne);
    ye().length === 1 && Re && Re(), we();
  }, xe = ye();
  if (listenersCache.set(ne, [
    ...xe,
    { id: fe, fns: oe }
  ]), xe && xe.length > 0)
    return _e;
  const Oe = {};
  for (const Re in oe)
    Oe[Re] = (...Ne) => {
      var Be, ze;
      const je = ye();
      if (je.length !== 0)
        for (const He of je)
          (ze = (Be = He.fns)[Re]) == null || ze.call(Be, ...Ne);
    };
  const $e = ae(Oe);
  return typeof $e == "function" && cleanupCache.set(ne, $e), _e;
}
async function wait(ne) {
  return new Promise((oe) => setTimeout(oe, ne));
}
function poll(ne, { emitOnBegin: oe, initialWaitTime: ae, interval: fe }) {
  let ye = !0;
  const we = () => ye = !1;
  return (async () => {
    let xe;
    oe && (xe = await ne({ unpoll: we }));
    const Oe = await (ae == null ? void 0 : ae(xe)) ?? fe;
    await wait(Oe);
    const $e = async () => {
      ye && (await ne({ unpoll: we }), await wait(fe), $e());
    };
    $e();
  })(), we;
}
const promiseCache = /* @__PURE__ */ new Map(), responseCache = /* @__PURE__ */ new Map();
function getCache(ne) {
  const oe = (ye, we) => ({
    clear: () => we.delete(ye),
    get: () => we.get(ye),
    set: (_e) => we.set(ye, _e)
  }), ae = oe(ne, promiseCache), fe = oe(ne, responseCache);
  return {
    clear: () => {
      ae.clear(), fe.clear();
    },
    promise: ae,
    response: fe
  };
}
async function withCache(ne, { cacheKey: oe, cacheTime: ae = 1 / 0 }) {
  const fe = getCache(oe), ye = fe.response.get();
  if (ye && ae > 0 && (/* @__PURE__ */ new Date()).getTime() - ye.created.getTime() < ae)
    return ye.data;
  let we = fe.promise.get();
  we || (we = ne(), fe.promise.set(we));
  try {
    const _e = await we;
    return fe.response.set({ created: /* @__PURE__ */ new Date(), data: _e }), _e;
  } finally {
    fe.promise.clear();
  }
}
const cacheKey = (ne) => `blockNumber.${ne}`;
async function getBlockNumber(ne, { cacheTime: oe = ne.cacheTime } = {}) {
  const ae = await withCache(() => ne.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(ne.uid), cacheTime: oe });
  return BigInt(ae);
}
async function getFilterChanges(ne, { filter: oe }) {
  const ae = "strict" in oe && oe.strict, fe = await oe.request({
    method: "eth_getFilterChanges",
    params: [oe.id]
  });
  if (typeof fe[0] == "string")
    return fe;
  const ye = fe.map((we) => formatLog(we));
  return !("abi" in oe) || !oe.abi ? ye : parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  });
}
async function uninstallFilter(ne, { filter: oe }) {
  return oe.request({
    method: "eth_uninstallFilter",
    params: [oe.id]
  });
}
function watchContractEvent(ne, oe) {
  const { abi: ae, address: fe, args: ye, batch: we = !0, eventName: _e, fromBlock: xe, onError: Oe, onLogs: $e, poll: Re, pollingInterval: Ne = ne.pollingInterval, strict: je } = oe;
  return (typeof Re < "u" ? Re : ne.transport.type !== "webSocket" || typeof xe == "number") ? (() => {
    const qe = je ?? !1, Ye = stringify([
      "watchContractEvent",
      fe,
      ye,
      we,
      ne.uid,
      _e,
      Ne,
      qe,
      xe
    ]);
    return observe(Ye, { onLogs: $e, onError: Oe }, (ot) => {
      let tt;
      xe !== void 0 && (tt = xe - 1n);
      let it, ht = !1;
      const gt = poll(async () => {
        var At;
        if (!ht) {
          try {
            it = await getAction(ne, createContractEventFilter, "createContractEventFilter")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: _e,
              strict: qe,
              fromBlock: xe
            });
          } catch {
          }
          ht = !0;
          return;
        }
        try {
          let St;
          if (it)
            St = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: it });
          else {
            const Nt = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            tt && tt !== Nt ? St = await getAction(ne, getContractEvents, "getContractEvents")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: _e,
              fromBlock: tt + 1n,
              toBlock: Nt,
              strict: qe
            }) : St = [], tt = Nt;
          }
          if (St.length === 0)
            return;
          if (we)
            ot.onLogs(St);
          else
            for (const Nt of St)
              ot.onLogs([Nt]);
        } catch (St) {
          it && St instanceof InvalidInputRpcError && (ht = !1), (At = ot.onError) == null || At.call(ot, St);
        }
      }, {
        emitOnBegin: !0,
        interval: Ne
      });
      return async () => {
        it && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: it }), gt();
      };
    });
  })() : (() => {
    const qe = je ?? !1, Ye = stringify([
      "watchContractEvent",
      fe,
      ye,
      we,
      ne.uid,
      _e,
      Ne,
      qe
    ]);
    let ot = !0, tt = () => ot = !1;
    return observe(Ye, { onLogs: $e, onError: Oe }, (it) => ((async () => {
      try {
        const ht = _e ? encodeEventTopics({
          abi: ae,
          eventName: _e,
          args: ye
        }) : [], { unsubscribe: gt } = await ne.transport.subscribe({
          params: ["logs", { address: fe, topics: ht }],
          onData(At) {
            var Nt;
            if (!ot)
              return;
            const St = At.result;
            try {
              const { eventName: Ft, args: Vt } = decodeEventLog({
                abi: ae,
                data: St.data,
                topics: St.topics,
                strict: je
              }), on = formatLog(St, {
                args: Vt,
                eventName: Ft
              });
              it.onLogs([on]);
            } catch (Ft) {
              let Vt, on;
              if (Ft instanceof DecodeLogDataMismatch || Ft instanceof DecodeLogTopicsMismatch) {
                if (je)
                  return;
                Vt = Ft.abiItem.name, on = (Nt = Ft.abiItem.inputs) == null ? void 0 : Nt.some((_n) => !("name" in _n && _n.name));
              }
              const tn = formatLog(St, {
                args: on ? [] : {},
                eventName: Vt
              });
              it.onLogs([tn]);
            }
          },
          onError(At) {
            var St;
            (St = it.onError) == null || St.call(it, At);
          }
        });
        tt = gt, ot || tt();
      } catch (ht) {
        Oe == null || Oe(ht);
      }
    })(), () => tt()));
  })();
}
function assertCurrentChain({ chain: ne, currentChainId: oe }) {
  if (!ne)
    throw new ChainNotFoundError();
  if (oe !== ne.id)
    throw new ChainMismatchError({ chain: ne, currentChainId: oe });
}
function getTransactionError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new TransactionExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
async function sendRawTransaction(ne, { serializedTransaction: oe }) {
  return ne.request({
    method: "eth_sendRawTransaction",
    params: [oe]
  }, { retryCount: 0 });
}
async function sendTransaction(ne, oe) {
  var Ye, ot, tt, it;
  const { account: ae = ne.account, chain: fe = ne.chain, accessList: ye, blobs: we, data: _e, gas: xe, gasPrice: Oe, maxFeePerBlobGas: $e, maxFeePerGas: Re, maxPriorityFeePerGas: Ne, nonce: je, to: Be, value: ze, ...He } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const qe = parseAccount(ae);
  try {
    assertRequest(oe);
    let ht;
    if (fe !== null && (ht = await getAction(ne, getChainId, "getChainId")({}), assertCurrentChain({
      currentChainId: ht,
      chain: fe
    })), qe.type === "local") {
      const Nt = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({
        account: qe,
        accessList: ye,
        blobs: we,
        chain: fe,
        chainId: ht,
        data: _e,
        gas: xe,
        gasPrice: Oe,
        maxFeePerBlobGas: $e,
        maxFeePerGas: Re,
        maxPriorityFeePerGas: Ne,
        nonce: je,
        parameters: [...defaultParameters, "sidecars"],
        to: Be,
        value: ze,
        ...He
      }), Ft = (Ye = fe == null ? void 0 : fe.serializers) == null ? void 0 : Ye.transaction, Vt = await qe.signTransaction(Nt, {
        serializer: Ft
      });
      return await getAction(ne, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction: Vt
      });
    }
    const gt = (it = (tt = (ot = ne.chain) == null ? void 0 : ot.formatters) == null ? void 0 : tt.transactionRequest) == null ? void 0 : it.format, St = (gt || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(He, { format: gt }),
      accessList: ye,
      blobs: we,
      data: _e,
      from: qe.address,
      gas: xe,
      gasPrice: Oe,
      maxFeePerBlobGas: $e,
      maxFeePerGas: Re,
      maxPriorityFeePerGas: Ne,
      nonce: je,
      to: Be,
      value: ze
    });
    return await ne.request({
      method: "eth_sendTransaction",
      params: [St]
    }, { retryCount: 0 });
  } catch (ht) {
    throw getTransactionError(ht, {
      ...oe,
      account: qe,
      chain: oe.chain || void 0
    });
  }
}
async function writeContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: we, functionName: _e, ...xe } = oe, Oe = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: _e
  });
  return getAction(ne, sendTransaction, "sendTransaction")({
    data: `${Oe}${we ? we.replace("0x", "") : ""}`,
    to: fe,
    ...xe
  });
}
function getContract({ abi: ne, address: oe, client: ae }) {
  const fe = ae, [ye, we] = (() => fe ? "public" in fe && "wallet" in fe ? [fe.public, fe.wallet] : "public" in fe ? [fe.public, void 0] : "wallet" in fe ? [void 0, fe.wallet] : [fe, fe] : [void 0, void 0])(), _e = ye != null, xe = we != null, Oe = {};
  let $e = !1, Re = !1, Ne = !1;
  for (const je of ne)
    if (je.type === "function" ? je.stateMutability === "view" || je.stateMutability === "pure" ? $e = !0 : Re = !0 : je.type === "event" && (Ne = !0), $e && Re && Ne)
      break;
  return _e && ($e && (Oe.read = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye, readContract, "readContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), Re && (Oe.simulate = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye, simulateContract, "simulateContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), Ne && (Oe.createEventFilter = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((ot) => ot.type === "event" && ot.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, createContractEventFilter, "createContractEventFilter")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }), Oe.getEvents = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((ot) => ot.type === "event" && ot.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, getContractEvents, "getContractEvents")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }), Oe.watchEvent = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const He = ne.find((ot) => ot.type === "event" && ot.name === Be), { args: qe, options: Ye } = getEventParameters(ze, He);
        return getAction(ye, watchContractEvent, "watchContractEvent")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: qe,
          ...Ye
        });
      };
    }
  }))), xe && Re && (Oe.write = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(we, writeContract, "writeContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe
        });
      };
    }
  })), (_e || xe) && Re && (Oe.estimateGas = new Proxy({}, {
    get(je, Be) {
      return (...ze) => {
        const { args: He, options: qe } = getFunctionParameters(ze);
        return getAction(ye ?? we, estimateContractGas, "estimateContractGas")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...qe,
          account: qe.account ?? we.account
        });
      };
    }
  })), Oe.address = oe, Oe.abi = ne, Oe;
}
function getFunctionParameters(ne) {
  const oe = ne.length && Array.isArray(ne[0]), ae = oe ? ne[0] : [], fe = (oe ? ne[1] : ne[0]) ?? {};
  return { args: ae, options: fe };
}
function getEventParameters(ne, oe) {
  let ae = !1;
  Array.isArray(ne[0]) ? ae = !0 : ne.length === 1 ? ae = oe.inputs.some((we) => we.indexed) : ne.length === 2 && (ae = !0);
  const fe = ae ? ne[0] : void 0, ye = (ae ? ne[1] : ne[0]) ?? {};
  return { args: fe, options: ye };
}
async function addChain(ne, { chain: oe }) {
  const { id: ae, name: fe, nativeCurrency: ye, rpcUrls: we, blockExplorers: _e } = oe;
  await ne.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(ae),
        chainName: fe,
        nativeCurrency: ye,
        rpcUrls: we.default.http,
        blockExplorerUrls: _e ? Object.values(_e).map(({ url: xe }) => xe) : void 0
      }
    ]
  }, { retryCount: 0 });
}
function publicKeyToAddress(ne) {
  const oe = keccak256(`0x${ne.substring(4)}`).substring(26);
  return checksumAddress(`0x${oe}`);
}
const size$1 = 256;
let index = size$1, buffer;
function uid(ne = 11) {
  if (!buffer || index + ne > size$1 * 2) {
    buffer = "", index = 0;
    for (let oe = 0; oe < size$1; oe++)
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer.substring(index, index++ + ne);
}
function createClient$1(ne) {
  const { batch: oe, cacheTime: ae = ne.pollingInterval ?? 4e3, ccipRead: fe, key: ye = "base", name: we = "Base Client", pollingInterval: _e = 4e3, type: xe = "base" } = ne, Oe = ne.chain, $e = ne.account ? parseAccount(ne.account) : void 0, { config: Re, request: Ne, value: je } = ne.transport({
    chain: Oe,
    pollingInterval: _e
  }), Be = { ...Re, ...je }, ze = {
    account: $e,
    batch: oe,
    cacheTime: ae,
    ccipRead: fe,
    chain: Oe,
    key: ye,
    name: we,
    pollingInterval: _e,
    request: Ne,
    transport: Be,
    type: xe,
    uid: uid()
  };
  function He(qe) {
    return (Ye) => {
      const ot = Ye(qe);
      for (const it in ze)
        delete ot[it];
      const tt = { ...qe, ...ot };
      return Object.assign(tt, { extend: He(tt) });
    };
  }
  return Object.assign(ze, { extend: He(ze) });
}
function withRetry(ne, { delay: oe = 100, retryCount: ae = 2, shouldRetry: fe = () => !0 } = {}) {
  return new Promise((ye, we) => {
    const _e = async ({ count: xe = 0 } = {}) => {
      const Oe = async ({ error: $e }) => {
        const Re = typeof oe == "function" ? oe({ count: xe, error: $e }) : oe;
        Re && await wait(Re), _e({ count: xe + 1 });
      };
      try {
        const $e = await ne();
        ye($e);
      } catch ($e) {
        if (xe < ae && await fe({ count: xe, error: $e }))
          return Oe({ error: $e });
        we($e);
      }
    };
    _e();
  });
}
function buildRequest(ne, oe = {}) {
  return async (ae, fe = {}) => {
    const { retryDelay: ye = 150, retryCount: we = 3 } = {
      ...oe,
      ...fe
    };
    return withRetry(async () => {
      try {
        return await ne(ae);
      } catch (_e) {
        const xe = _e;
        switch (xe.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(xe);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(xe);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(xe);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(xe);
          case InternalRpcError.code:
            throw new InternalRpcError(xe);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(xe);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(xe);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(xe);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(xe);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(xe);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(xe);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(xe);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(xe);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(xe);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(xe);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(xe);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(xe);
          case SwitchChainError.code:
            throw new SwitchChainError(xe);
          case 5e3:
            throw new UserRejectedRequestError(xe);
          default:
            throw _e instanceof BaseError$1 ? _e : new UnknownRpcError(xe);
        }
      }
    }, {
      delay: ({ count: _e, error: xe }) => {
        var Oe;
        if (xe && xe instanceof HttpRequestError) {
          const $e = (Oe = xe == null ? void 0 : xe.headers) == null ? void 0 : Oe.get("Retry-After");
          if ($e != null && $e.match(/\d/))
            return parseInt($e) * 1e3;
        }
        return ~~(1 << _e) * ye;
      },
      retryCount: we,
      shouldRetry: ({ error: _e }) => shouldRetry(_e)
    });
  };
}
function shouldRetry(ne) {
  return "code" in ne && typeof ne.code == "number" ? ne.code === -1 || ne.code === LimitExceededRpcError.code || ne.code === InternalRpcError.code : ne instanceof HttpRequestError && ne.status ? ne.status === 403 || ne.status === 408 || ne.status === 413 || ne.status === 429 || ne.status === 500 || ne.status === 502 || ne.status === 503 || ne.status === 504 : !0;
}
function createTransport({ key: ne, name: oe, request: ae, retryCount: fe = 3, retryDelay: ye = 150, timeout: we, type: _e }, xe) {
  return {
    config: { key: ne, name: oe, request: ae, retryCount: fe, retryDelay: ye, timeout: we, type: _e },
    request: buildRequest(ae, { retryCount: fe, retryDelay: ye }),
    value: xe
  };
}
function fallback(ne, oe = {}) {
  const { key: ae = "fallback", name: fe = "Fallback", rank: ye = !1, retryCount: we, retryDelay: _e } = oe;
  return ({ chain: xe, pollingInterval: Oe = 4e3, timeout: $e, ...Re }) => {
    let Ne = ne, je = () => {
    };
    const Be = createTransport({
      key: ae,
      name: fe,
      async request({ method: ze, params: He }) {
        const qe = async (Ye = 0) => {
          const ot = Ne[Ye]({
            ...Re,
            chain: xe,
            retryCount: 0,
            timeout: $e
          });
          try {
            const tt = await ot.request({
              method: ze,
              params: He
            });
            return je({
              method: ze,
              params: He,
              response: tt,
              transport: ot,
              status: "success"
            }), tt;
          } catch (tt) {
            if (je({
              error: tt,
              method: ze,
              params: He,
              transport: ot,
              status: "error"
            }), shouldThrow(tt) || Ye === Ne.length - 1)
              throw tt;
            return qe(Ye + 1);
          }
        };
        return qe();
      },
      retryCount: we,
      retryDelay: _e,
      type: "fallback"
    }, {
      onResponse: (ze) => je = ze,
      transports: Ne.map((ze) => ze({ chain: xe, retryCount: 0 }))
    });
    if (ye) {
      const ze = typeof ye == "object" ? ye : {};
      rankTransports({
        chain: xe,
        interval: ze.interval ?? Oe,
        onTransports: (He) => Ne = He,
        sampleCount: ze.sampleCount,
        timeout: ze.timeout,
        transports: Ne,
        weights: ze.weights
      });
    }
    return Be;
  };
}
function shouldThrow(ne) {
  return "code" in ne && typeof ne.code == "number" && (ne.code === TransactionRejectedRpcError.code || ne.code === UserRejectedRequestError.code || ne.code === 5e3);
}
function rankTransports({ chain: ne, interval: oe = 4e3, onTransports: ae, sampleCount: fe = 10, timeout: ye = 1e3, transports: we, weights: _e = {} }) {
  const { stability: xe = 0.7, latency: Oe = 0.3 } = _e, $e = [], Re = async () => {
    const Ne = await Promise.all(we.map(async (ze) => {
      const He = ze({ chain: ne, retryCount: 0, timeout: ye }), qe = Date.now();
      let Ye, ot;
      try {
        await He.request({ method: "net_listening" }), ot = 1;
      } catch {
        ot = 0;
      } finally {
        Ye = Date.now();
      }
      return { latency: Ye - qe, success: ot };
    }));
    $e.push(Ne), $e.length > fe && $e.shift();
    const je = Math.max(...$e.map((ze) => Math.max(...ze.map(({ latency: He }) => He)))), Be = we.map((ze, He) => {
      const qe = $e.map((ht) => ht[He].latency), ot = 1 - qe.reduce((ht, gt) => ht + gt, 0) / qe.length / je, tt = $e.map((ht) => ht[He].success), it = tt.reduce((ht, gt) => ht + gt, 0) / tt.length;
      return it === 0 ? [0, He] : [
        Oe * ot + xe * it,
        He
      ];
    }).sort((ze, He) => He[0] - ze[0]);
    ae(Be.map(([, ze]) => we[ze])), await wait(oe), Re();
  };
  Re();
}
class UrlRequiredError extends BaseError$1 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function withTimeout(ne, { errorInstance: oe = new Error("timed out"), timeout: ae, signal: fe }) {
  return new Promise((ye, we) => {
    (async () => {
      let _e;
      try {
        const xe = new AbortController();
        ae > 0 && (_e = setTimeout(() => {
          fe ? xe.abort() : we(oe);
        }, ae)), ye(await ne({ signal: (xe == null ? void 0 : xe.signal) || null }));
      } catch (xe) {
        xe.name === "AbortError" && we(oe), we(xe);
      } finally {
        clearTimeout(_e);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(ne, oe = {}) {
  return {
    async request(ae) {
      var Ne;
      const { body: fe, fetchOptions: ye = {}, onRequest: we = oe.onRequest, onResponse: _e = oe.onResponse, timeout: xe = oe.timeout ?? 1e4 } = ae, { headers: Oe, method: $e, signal: Re } = { ...oe.fetchOptions, ...ye };
      try {
        const je = await withTimeout(async ({ signal: ze }) => {
          const He = {
            ...ye,
            body: Array.isArray(fe) ? stringify(fe.map((ot) => ({
              jsonrpc: "2.0",
              id: ot.id ?? idCache.take(),
              ...ot
            }))) : stringify({
              jsonrpc: "2.0",
              id: fe.id ?? idCache.take(),
              ...fe
            }),
            headers: {
              ...Oe,
              "Content-Type": "application/json"
            },
            method: $e || "POST",
            signal: Re || (xe > 0 ? ze : null)
          }, qe = new Request(ne, He);
          return we && await we(qe), await fetch(ne, He);
        }, {
          errorInstance: new TimeoutError$1({ body: fe, url: ne }),
          timeout: xe,
          signal: !0
        });
        _e && await _e(je);
        let Be;
        if ((Ne = je.headers.get("Content-Type")) != null && Ne.startsWith("application/json") ? Be = await je.json() : Be = await je.text(), !je.ok)
          throw new HttpRequestError({
            body: fe,
            details: stringify(Be.error) || je.statusText,
            headers: je.headers,
            status: je.status,
            url: ne
          });
        return Be;
      } catch (je) {
        throw je instanceof HttpRequestError || je instanceof TimeoutError$1 ? je : new HttpRequestError({
          body: fe,
          details: je.message,
          url: ne
        });
      }
    }
  };
}
function http(ne, oe = {}) {
  const { batch: ae, fetchOptions: fe, key: ye = "http", name: we = "HTTP JSON-RPC", onFetchRequest: _e, onFetchResponse: xe, retryDelay: Oe } = oe;
  return ({ chain: $e, retryCount: Re, timeout: Ne }) => {
    const { batchSize: je = 1e3, wait: Be = 0 } = typeof ae == "object" ? ae : {}, ze = oe.retryCount ?? Re, He = Ne ?? oe.timeout ?? 1e4, qe = ne || ($e == null ? void 0 : $e.rpcUrls.default.http[0]);
    if (!qe)
      throw new UrlRequiredError();
    const Ye = getHttpRpcClient(qe, {
      fetchOptions: fe,
      onRequest: _e,
      onResponse: xe,
      timeout: He
    });
    return createTransport({
      key: ye,
      name: we,
      async request({ method: ot, params: tt }) {
        const it = { method: ot, params: tt }, { schedule: ht } = createBatchScheduler({
          id: `${ne}`,
          wait: Be,
          shouldSplitBatch(Nt) {
            return Nt.length > je;
          },
          fn: (Nt) => Ye.request({
            body: Nt
          }),
          sort: (Nt, Ft) => Nt.id - Ft.id
        }), gt = async (Nt) => ae ? ht(Nt) : [
          await Ye.request({
            body: Nt
          })
        ], [{ error: At, result: St }] = await gt(it);
        if (At)
          throw new RpcRequestError({
            body: it,
            error: At,
            url: qe
          });
        return St;
      },
      retryCount: ze,
      retryDelay: Oe,
      timeout: He,
      type: "http"
    }, {
      fetchOptions: fe,
      url: qe
    });
  };
}
function isNullUniversalResolverError(ne, oe) {
  var fe, ye, we, _e, xe, Oe;
  if (!(ne instanceof BaseError$1))
    return !1;
  const ae = ne.walk(($e) => $e instanceof ContractFunctionRevertedError);
  return ae instanceof ContractFunctionRevertedError ? !!(((fe = ae.data) == null ? void 0 : fe.errorName) === "ResolverNotFound" || ((ye = ae.data) == null ? void 0 : ye.errorName) === "ResolverWildcardNotSupported" || ((we = ae.data) == null ? void 0 : we.errorName) === "ResolverNotContract" || ((_e = ae.data) == null ? void 0 : _e.errorName) === "ResolverError" || ((xe = ae.data) == null ? void 0 : xe.errorName) === "HttpError" || (Oe = ae.reason) != null && Oe.includes("Wildcard on non-extended resolvers is not supported") || oe === "reverse" && ae.reason === panicReasons[50]) : !1;
}
function encodedLabelToLabelhash(ne) {
  if (ne.length !== 66 || ne.indexOf("[") !== 0 || ne.indexOf("]") !== 65)
    return null;
  const oe = `0x${ne.slice(1, 65)}`;
  return isHex$1(oe) ? oe : null;
}
function namehash(ne) {
  let oe = new Uint8Array(32).fill(0);
  if (!ne)
    return bytesToHex$2(oe);
  const ae = ne.split(".");
  for (let fe = ae.length - 1; fe >= 0; fe -= 1) {
    const ye = encodedLabelToLabelhash(ae[fe]), we = ye ? toBytes$1(ye) : keccak256(stringToBytes(ae[fe]), "bytes");
    oe = keccak256(concat$1([oe, we]), "bytes");
  }
  return bytesToHex$2(oe);
}
function encodeLabelhash(ne) {
  return `[${ne.slice(2)}]`;
}
function labelhash(ne) {
  const oe = new Uint8Array(32).fill(0);
  return ne ? encodedLabelToLabelhash(ne) || keccak256(stringToBytes(ne)) : bytesToHex$2(oe);
}
function packetToBytes(ne) {
  const oe = ne.replace(/^\.|\.$/gm, "");
  if (oe.length === 0)
    return new Uint8Array(1);
  const ae = new Uint8Array(stringToBytes(oe).byteLength + 2);
  let fe = 0;
  const ye = oe.split(".");
  for (let we = 0; we < ye.length; we++) {
    let _e = stringToBytes(ye[we]);
    _e.byteLength > 255 && (_e = stringToBytes(encodeLabelhash(labelhash(ye[we])))), ae[fe] = _e.length, ae.set(_e, fe + 1), fe += _e.length + 1;
  }
  return ae.byteLength !== fe + 1 ? ae.slice(0, fe + 1) : ae;
}
async function getEnsAddress(ne, { blockNumber: oe, blockTag: ae, coinType: fe, name: ye, gatewayUrls: we, strict: _e, universalResolverAddress: xe }) {
  let Oe = xe;
  if (!Oe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Oe = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const $e = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...fe != null ? { args: [namehash(ye), BigInt(fe)] } : { args: [namehash(ye)] }
    }), Re = {
      address: Oe,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(ye)), $e],
      blockNumber: oe,
      blockTag: ae
    }, Ne = getAction(ne, readContract, "readContract"), je = we ? await Ne({
      ...Re,
      args: [...Re.args, we]
    }) : await Ne(Re);
    if (je[0] === "0x")
      return null;
    const Be = decodeFunctionResult({
      abi: addressResolverAbi,
      args: fe != null ? [namehash(ye), BigInt(fe)] : void 0,
      functionName: "addr",
      data: je[0]
    });
    return Be === "0x" || trim(Be) === "0x00" ? null : Be;
  } catch ($e) {
    if (_e)
      throw $e;
    if (isNullUniversalResolverError($e, "resolve"))
      return null;
    throw $e;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$1 {
  constructor({ data: oe }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(oe)}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$1 {
  constructor({ reason: oe }) {
    super(`ENS NFT avatar URI is invalid. ${oe}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$1 {
  constructor({ uri: oe }) {
    super(`Unable to resolve ENS avatar URI "${oe}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$1 {
  constructor({ namespace: oe }) {
    super(`ENS NFT avatar namespace "${oe}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, base64Regex$1 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(ne) {
  try {
    const oe = await fetch(ne, { method: "HEAD" });
    if (oe.status === 200) {
      const ae = oe.headers.get("content-type");
      return ae == null ? void 0 : ae.startsWith("image/");
    }
    return !1;
  } catch (oe) {
    return typeof oe == "object" && typeof oe.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((ae) => {
      const fe = new Image();
      fe.onload = () => {
        ae(!0);
      }, fe.onerror = () => {
        ae(!1);
      }, fe.src = ne;
    });
  }
}
function getGateway(ne, oe) {
  return ne ? ne.endsWith("/") ? ne.slice(0, -1) : ne : oe;
}
function resolveAvatarUri({ uri: ne, gatewayUrls: oe }) {
  const ae = base64Regex$1.test(ne);
  if (ae)
    return { uri: ne, isOnChain: !0, isEncoded: ae };
  const fe = getGateway(oe == null ? void 0 : oe.ipfs, "https://ipfs.io"), ye = getGateway(oe == null ? void 0 : oe.arweave, "https://arweave.net"), we = ne.match(networkRegex), { protocol: _e, subpath: xe, target: Oe, subtarget: $e = "" } = (we == null ? void 0 : we.groups) || {}, Re = _e === "ipns:/" || xe === "ipns/", Ne = _e === "ipfs:/" || xe === "ipfs/" || ipfsHashRegex.test(ne);
  if (ne.startsWith("http") && !Re && !Ne) {
    let Be = ne;
    return oe != null && oe.arweave && (Be = ne.replace(/https:\/\/arweave.net/g, oe == null ? void 0 : oe.arweave)), { uri: Be, isOnChain: !1, isEncoded: !1 };
  }
  if ((Re || Ne) && Oe)
    return {
      uri: `${fe}/${Re ? "ipns" : "ipfs"}/${Oe}${$e}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (_e === "ar:/" && Oe)
    return {
      uri: `${ye}/${Oe}${$e || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let je = ne.replace(dataURIRegex, "");
  if (je.startsWith("<svg") && (je = `data:image/svg+xml;base64,${btoa(je)}`), je.startsWith("data:") || je.startsWith("{"))
    return {
      uri: je,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new EnsAvatarUriResolutionError({ uri: ne });
}
function getJsonImage(ne) {
  if (typeof ne != "object" || !("image" in ne) && !("image_url" in ne) && !("image_data" in ne))
    throw new EnsAvatarInvalidMetadataError({ data: ne });
  return ne.image || ne.image_url || ne.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls: ne, uri: oe }) {
  try {
    const ae = await fetch(oe).then((ye) => ye.json());
    return await parseAvatarUri({
      gatewayUrls: ne,
      uri: getJsonImage(ae)
    });
  } catch {
    throw new EnsAvatarUriResolutionError({ uri: oe });
  }
}
async function parseAvatarUri({ gatewayUrls: ne, uri: oe }) {
  const { uri: ae, isOnChain: fe } = resolveAvatarUri({ uri: oe, gatewayUrls: ne });
  if (fe || await isImageUri(ae))
    return ae;
  throw new EnsAvatarUriResolutionError({ uri: oe });
}
function parseNftUri(ne) {
  let oe = ne;
  oe.startsWith("did:nft:") && (oe = oe.replace("did:nft:", "").replace(/_/g, "/"));
  const [ae, fe, ye] = oe.split("/"), [we, _e] = ae.split(":"), [xe, Oe] = fe.split(":");
  if (!we || we.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!_e)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!Oe)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!ye)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!xe)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(_e),
    namespace: xe.toLowerCase(),
    contractAddress: Oe,
    tokenID: ye
  };
}
async function getNftTokenUri(ne, { nft: oe }) {
  if (oe.namespace === "erc721")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(oe.tokenID)]
    });
  if (oe.namespace === "erc1155")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(oe.tokenID)]
    });
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: oe.namespace });
}
async function parseAvatarRecord(ne, { gatewayUrls: oe, record: ae }) {
  return /eip155:/i.test(ae) ? parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) : parseAvatarUri({ uri: ae, gatewayUrls: oe });
}
async function parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) {
  const fe = parseNftUri(ae), ye = await getNftTokenUri(ne, { nft: fe }), { uri: we, isOnChain: _e, isEncoded: xe } = resolveAvatarUri({ uri: ye, gatewayUrls: oe });
  if (_e && (we.includes("data:application/json;base64,") || we.startsWith("{"))) {
    const $e = xe ? (
      // if it is encoded, decode it
      atob(we.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      we
    ), Re = JSON.parse($e);
    return parseAvatarUri({ uri: getJsonImage(Re), gatewayUrls: oe });
  }
  let Oe = fe.tokenID;
  return fe.namespace === "erc1155" && (Oe = Oe.replace("0x", "").padStart(64, "0")), getMetadataAvatarUri({
    gatewayUrls: oe,
    uri: we.replace(/(?:0x)?{id}/, Oe)
  });
}
async function getEnsText(ne, { blockNumber: oe, blockTag: ae, name: fe, key: ye, gatewayUrls: we, strict: _e, universalResolverAddress: xe }) {
  let Oe = xe;
  if (!Oe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Oe = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const $e = {
      address: Oe,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(fe)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(fe), ye]
        })
      ],
      blockNumber: oe,
      blockTag: ae
    }, Re = getAction(ne, readContract, "readContract"), Ne = we ? await Re({
      ...$e,
      args: [...$e.args, we]
    }) : await Re($e);
    if (Ne[0] === "0x")
      return null;
    const je = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: Ne[0]
    });
    return je === "" ? null : je;
  } catch ($e) {
    if (_e)
      throw $e;
    if (isNullUniversalResolverError($e, "resolve"))
      return null;
    throw $e;
  }
}
async function getEnsAvatar(ne, { blockNumber: oe, blockTag: ae, assetGatewayUrls: fe, name: ye, gatewayUrls: we, strict: _e, universalResolverAddress: xe }) {
  const Oe = await getAction(ne, getEnsText, "getEnsText")({
    blockNumber: oe,
    blockTag: ae,
    key: "avatar",
    name: ye,
    universalResolverAddress: xe,
    gatewayUrls: we,
    strict: _e
  });
  if (!Oe)
    return null;
  try {
    return await parseAvatarRecord(ne, {
      record: Oe,
      gatewayUrls: fe
    });
  } catch {
    return null;
  }
}
async function getEnsName(ne, { address: oe, blockNumber: ae, blockTag: fe, gatewayUrls: ye, strict: we, universalResolverAddress: _e }) {
  let xe = _e;
  if (!xe) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    xe = getChainContractAddress({
      blockNumber: ae,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const Oe = `${oe.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const $e = {
      address: xe,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(Oe))],
      blockNumber: ae,
      blockTag: fe
    }, Re = getAction(ne, readContract, "readContract"), [Ne, je] = ye ? await Re({
      ...$e,
      args: [...$e.args, ye]
    }) : await Re($e);
    return oe.toLowerCase() !== je.toLowerCase() ? null : Ne;
  } catch ($e) {
    if (we)
      throw $e;
    if (isNullUniversalResolverError($e, "reverse"))
      return null;
    throw $e;
  }
}
async function getEnsResolver(ne, { blockNumber: oe, blockTag: ae, name: fe, universalResolverAddress: ye }) {
  let we = ye;
  if (!we) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    we = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [_e] = await getAction(ne, readContract, "readContract")({
    address: we,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(fe))],
    blockNumber: oe,
    blockTag: ae
  });
  return _e;
}
async function createBlockFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newBlockFilter"
  }), ae = await ne.request({
    method: "eth_newBlockFilter"
  });
  return { id: ae, request: oe(ae), type: "block" };
}
async function createEventFilter(ne, { address: oe, args: ae, event: fe, events: ye, fromBlock: we, strict: _e, toBlock: xe } = {}) {
  const Oe = ye ?? (fe ? [fe] : void 0), $e = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  });
  let Re = [];
  Oe && (Re = [
    Oe.flatMap((je) => encodeEventTopics({
      abi: [je],
      eventName: je.name,
      args: ae
    }))
  ], fe && (Re = Re[0]));
  const Ne = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: oe,
        fromBlock: typeof we == "bigint" ? numberToHex(we) : we,
        toBlock: typeof xe == "bigint" ? numberToHex(xe) : xe,
        ...Re.length ? { topics: Re } : {}
      }
    ]
  });
  return {
    abi: Oe,
    args: ae,
    eventName: fe ? fe.name : void 0,
    fromBlock: we,
    id: Ne,
    request: $e(Ne),
    strict: !!_e,
    toBlock: xe,
    type: "event"
  };
}
async function createPendingTransactionFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newPendingTransactionFilter"
  }), ae = await ne.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: ae, request: oe(ae), type: "transaction" };
}
async function getBalance(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae ? numberToHex(ae) : void 0, we = await ne.request({
    method: "eth_getBalance",
    params: [oe, ye || fe]
  });
  return BigInt(we);
}
async function getBlobBaseFee(ne) {
  const oe = await ne.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(oe);
}
async function getBlockTransactionCount(ne, { blockHash: oe, blockNumber: ae, blockTag: fe = "latest" } = {}) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0;
  let we;
  return oe ? we = await ne.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [oe]
  }) : we = await ne.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [ye || fe]
  }), hexToNumber$1(we);
}
async function getBytecode(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0, we = await ne.request({
    method: "eth_getCode",
    params: [oe, ye || fe]
  });
  if (we !== "0x")
    return we;
}
function formatFeeHistory(ne) {
  var oe;
  return {
    baseFeePerGas: ne.baseFeePerGas.map((ae) => BigInt(ae)),
    gasUsedRatio: ne.gasUsedRatio,
    oldestBlock: BigInt(ne.oldestBlock),
    reward: (oe = ne.reward) == null ? void 0 : oe.map((ae) => ae.map((fe) => BigInt(fe)))
  };
}
async function getFeeHistory(ne, { blockCount: oe, blockNumber: ae, blockTag: fe = "latest", rewardPercentiles: ye }) {
  const we = ae ? numberToHex(ae) : void 0, _e = await ne.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(oe),
      we || fe,
      ye
    ]
  });
  return formatFeeHistory(_e);
}
async function getFilterLogs(ne, { filter: oe }) {
  const ae = oe.strict ?? !1, ye = (await oe.request({
    method: "eth_getFilterLogs",
    params: [oe.id]
  })).map((we) => formatLog(we));
  return oe.abi ? parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  }) : ye;
}
function defineChain(ne) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...ne
  };
}
const arrayRegex = /^(.*)\[([0-9]*)\]$/, bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, socketClientCache = /* @__PURE__ */ new Map();
async function getSocketRpcClient(ne) {
  const { getSocket: oe, reconnect: ae = !0, url: fe } = ne, { attempts: ye = 5, delay: we = 2e3 } = typeof ae == "object" ? ae : {};
  let _e = socketClientCache.get(fe);
  if (_e)
    return _e;
  let xe = 0;
  const { schedule: Oe } = createBatchScheduler({
    id: fe,
    fn: async () => {
      const Ne = /* @__PURE__ */ new Map(), je = /* @__PURE__ */ new Map();
      let Be, ze;
      async function He() {
        return oe({
          onError(qe) {
            var Ye, ot;
            Be = qe;
            for (const tt of Ne.values())
              (Ye = tt.onError) == null || Ye.call(tt, Be);
            for (const tt of je.values())
              (ot = tt.onError) == null || ot.call(tt, Be);
            Ne.clear(), je.clear(), ae && xe < ye && setTimeout(async () => {
              xe++, ze = await He().catch(console.error);
            }, we);
          },
          onOpen() {
            Be = void 0, xe = 0;
          },
          onResponse(qe) {
            const Ye = qe.method === "eth_subscription", ot = Ye ? qe.params.subscription : qe.id, tt = Ye ? je : Ne, it = tt.get(ot);
            it && it.onResponse(qe), Ye || tt.delete(ot);
          }
        });
      }
      return ze = await He(), Be = void 0, _e = {
        close() {
          ze.close(), socketClientCache.delete(fe);
        },
        socket: ze,
        request({ body: qe, onError: Ye, onResponse: ot }) {
          Be && Ye && Ye(Be);
          const tt = qe.id ?? idCache.take(), it = (ht) => {
            var gt;
            typeof ht.id == "number" && tt !== ht.id || (qe.method === "eth_subscribe" && typeof ht.result == "string" && je.set(ht.result, {
              onResponse: it,
              onError: Ye
            }), qe.method === "eth_unsubscribe" && je.delete((gt = qe.params) == null ? void 0 : gt[0]), ot(ht));
          };
          Ne.set(tt, { onResponse: it, onError: Ye });
          try {
            ze.request({
              body: {
                jsonrpc: "2.0",
                id: tt,
                ...qe
              }
            });
          } catch (ht) {
            Ye == null || Ye(ht);
          }
        },
        requestAsync({ body: qe, timeout: Ye = 1e4 }) {
          return withTimeout(() => new Promise((ot, tt) => this.request({
            body: qe,
            onError: tt,
            onResponse: ot
          })), {
            errorInstance: new TimeoutError$1({ body: qe, url: fe }),
            timeout: Ye
          });
        },
        requests: Ne,
        subscriptions: je,
        url: fe
      }, socketClientCache.set(fe, _e), [_e];
    }
  }), [$e, [Re]] = await Oe();
  return Re;
}
async function getWebSocketRpcClient(ne, oe = {}) {
  const { reconnect: ae } = oe;
  return getSocketRpcClient({
    async getSocket({ onError: fe, onOpen: ye, onResponse: we }) {
      const _e = await import("./native-15074a2a.js").then((Ne) => Ne.WebSocket), xe = new _e(ne);
      function Oe() {
        xe.removeEventListener("close", Oe), xe.removeEventListener("message", $e), xe.removeEventListener("error", fe), xe.removeEventListener("open", ye);
      }
      function $e({ data: Ne }) {
        we(JSON.parse(Ne));
      }
      xe.addEventListener("close", Oe), xe.addEventListener("message", $e), xe.addEventListener("error", fe), xe.addEventListener("open", ye), xe.readyState === _e.CONNECTING && await new Promise((Ne, je) => {
        xe && (xe.onopen = Ne, xe.onerror = je);
      });
      const { close: Re } = xe;
      return Object.assign(xe, {
        close() {
          Re.bind(xe)(), Oe();
        },
        request({ body: Ne }) {
          if (xe.readyState === xe.CLOSED || xe.readyState === xe.CLOSING)
            throw new WebSocketRequestError({
              body: Ne,
              url: xe.url,
              details: "Socket is closed."
            });
          return xe.send(JSON.stringify(Ne));
        }
      });
    },
    reconnect: ae,
    url: ne
  });
}
async function getSocket(ne) {
  const oe = await getWebSocketRpcClient(ne);
  return Object.assign(oe.socket, {
    requests: oe.requests,
    subscriptions: oe.subscriptions
  });
}
function hashTypedData(ne) {
  const { domain: oe = {}, message: ae, primaryType: fe } = ne, ye = {
    EIP712Domain: getTypesForEIP712Domain({ domain: oe }),
    ...ne.types
  };
  validateTypedData({
    domain: oe,
    message: ae,
    primaryType: fe,
    types: ye
  });
  const we = ["0x1901"];
  return oe && we.push(hashDomain({
    domain: oe,
    types: ye
  })), fe !== "EIP712Domain" && we.push(hashStruct({
    data: ae,
    primaryType: fe,
    types: ye
  })), keccak256(concat$1(we));
}
function hashDomain({ domain: ne, types: oe }) {
  return hashStruct({
    data: ne,
    primaryType: "EIP712Domain",
    types: oe
  });
}
function hashStruct({ data: ne, primaryType: oe, types: ae }) {
  const fe = encodeData({
    data: ne,
    primaryType: oe,
    types: ae
  });
  return keccak256(fe);
}
function encodeData({ data: ne, primaryType: oe, types: ae }) {
  const fe = [{ type: "bytes32" }], ye = [hashType({ primaryType: oe, types: ae })];
  for (const we of ae[oe]) {
    const [_e, xe] = encodeField({
      types: ae,
      name: we.name,
      type: we.type,
      value: ne[we.name]
    });
    fe.push(_e), ye.push(xe);
  }
  return encodeAbiParameters(fe, ye);
}
function hashType({ primaryType: ne, types: oe }) {
  const ae = toHex(encodeType({ primaryType: ne, types: oe }));
  return keccak256(ae);
}
function encodeType({ primaryType: ne, types: oe }) {
  let ae = "";
  const fe = findTypeDependencies({ primaryType: ne, types: oe });
  fe.delete(ne);
  const ye = [ne, ...Array.from(fe).sort()];
  for (const we of ye)
    ae += `${we}(${oe[we].map(({ name: _e, type: xe }) => `${xe} ${_e}`).join(",")})`;
  return ae;
}
function findTypeDependencies({ primaryType: ne, types: oe }, ae = /* @__PURE__ */ new Set()) {
  const fe = ne.match(/^\w*/u), ye = fe == null ? void 0 : fe[0];
  if (ae.has(ye) || oe[ye] === void 0)
    return ae;
  ae.add(ye);
  for (const we of oe[ye])
    findTypeDependencies({ primaryType: we.type, types: oe }, ae);
  return ae;
}
function encodeField({ types: ne, name: oe, type: ae, value: fe }) {
  if (ne[ae] !== void 0)
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: fe, primaryType: ae, types: ne }))
    ];
  if (ae === "bytes")
    return fe = `0x${(fe.length % 2 ? "0" : "") + fe.slice(2)}`, [{ type: "bytes32" }, keccak256(fe)];
  if (ae === "string")
    return [{ type: "bytes32" }, keccak256(toHex(fe))];
  if (ae.lastIndexOf("]") === ae.length - 1) {
    const ye = ae.slice(0, ae.lastIndexOf("[")), we = fe.map((_e) => encodeField({
      name: oe,
      type: ye,
      types: ne,
      value: _e
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(we.map(([_e]) => _e), we.map(([, _e]) => _e)))
    ];
  }
  return [{ type: ae }, fe];
}
function validateTypedData(ne) {
  const { domain: oe, message: ae, primaryType: fe, types: ye } = ne, we = (_e, xe) => {
    for (const Oe of _e) {
      const { name: $e, type: Re } = Oe, Ne = xe[$e], je = Re.match(integerRegex);
      if (je && (typeof Ne == "number" || typeof Ne == "bigint")) {
        const [He, qe, Ye] = je;
        numberToHex(Ne, {
          signed: qe === "int",
          size: parseInt(Ye) / 8
        });
      }
      if (Re === "address" && typeof Ne == "string" && !isAddress(Ne))
        throw new InvalidAddressError({ address: Ne });
      const Be = Re.match(bytesRegex);
      if (Be) {
        const [He, qe] = Be;
        if (qe && size$2(Ne) !== parseInt(qe))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(qe),
            givenSize: size$2(Ne)
          });
      }
      const ze = ye[Re];
      ze && we(ze, Ne);
    }
  };
  if (ye.EIP712Domain && oe && we(ye.EIP712Domain, oe), fe !== "EIP712Domain") {
    const _e = ye[fe];
    we(_e, ae);
  }
}
function getTypesForEIP712Domain({ domain: ne }) {
  return [
    typeof (ne == null ? void 0 : ne.name) == "string" && { name: "name", type: "string" },
    (ne == null ? void 0 : ne.version) && { name: "version", type: "string" },
    typeof (ne == null ? void 0 : ne.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (ne == null ? void 0 : ne.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (ne == null ? void 0 : ne.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData(ne) {
  const { abi: oe, args: ae, bytecode: fe } = ne;
  if (!ae || ae.length === 0)
    return fe;
  const ye = oe.find((_e) => "type" in _e && _e.type === "constructor");
  if (!ye)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in ye))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!ye.inputs || ye.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const we = encodeAbiParameters(ye.inputs, ae);
  return concatHex$1([fe, we]);
}
function encodePacked(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++) {
    const ye = ne[fe], we = oe[fe];
    ae.push(encode(ye, we));
  }
  return concatHex$1(ae);
}
function encode(ne, oe, ae = !1) {
  if (ne === "address") {
    const _e = oe;
    if (!isAddress(_e))
      throw new InvalidAddressError({ address: _e });
    return pad$1(_e.toLowerCase(), {
      size: ae ? 32 : null
    });
  }
  if (ne === "string")
    return stringToHex$1(oe);
  if (ne === "bytes")
    return oe;
  if (ne === "bool")
    return pad$1(boolToHex(oe), { size: ae ? 32 : 1 });
  const fe = ne.match(integerRegex);
  if (fe) {
    const [_e, xe, Oe = "256"] = fe, $e = parseInt(Oe) / 8;
    return numberToHex(oe, {
      size: ae ? 32 : $e,
      signed: xe === "int"
    });
  }
  const ye = ne.match(bytesRegex);
  if (ye) {
    const [_e, xe] = ye;
    if (parseInt(xe) !== (oe.length - 2) / 2)
      throw new BytesSizeMismatchError({
        expectedSize: parseInt(xe),
        givenSize: (oe.length - 2) / 2
      });
    return pad$1(oe, { dir: "right", size: ae ? 32 : null });
  }
  const we = ne.match(arrayRegex);
  if (we && Array.isArray(oe)) {
    const [_e, xe] = we, Oe = [];
    for (let $e = 0; $e < oe.length; $e++)
      Oe.push(encode(xe, oe[$e], !0));
    return Oe.length === 0 ? "0x" : concatHex$1(Oe);
  }
  throw new UnsupportedPackedAbiType(ne);
}
function toRlp(ne, oe = "hex") {
  const ae = getEncodable(ne), fe = createCursor(new Uint8Array(ae.length));
  return ae.encode(fe), oe === "hex" ? bytesToHex$2(fe.bytes) : fe.bytes;
}
function getEncodable(ne) {
  return Array.isArray(ne) ? getEncodableList(ne.map((oe) => getEncodable(oe))) : getEncodableBytes(ne);
}
function getEncodableList(ne) {
  const oe = ne.reduce((ye, we) => ye + we.length, 0), ae = getSizeOfLength(oe);
  return {
    length: (() => oe <= 55 ? 1 + oe : 1 + ae + oe)(),
    encode(ye) {
      oe <= 55 ? ye.pushByte(192 + oe) : (ye.pushByte(192 + 55 + ae), ae === 1 ? ye.pushUint8(oe) : ae === 2 ? ye.pushUint16(oe) : ae === 3 ? ye.pushUint24(oe) : ye.pushUint32(oe));
      for (const { encode: we } of ne)
        we(ye);
    }
  };
}
function getEncodableBytes(ne) {
  const oe = typeof ne == "string" ? hexToBytes$1(ne) : ne, ae = getSizeOfLength(oe.length);
  return {
    length: (() => oe.length === 1 && oe[0] < 128 ? 1 : oe.length <= 55 ? 1 + oe.length : 1 + ae + oe.length)(),
    encode(ye) {
      oe.length === 1 && oe[0] < 128 ? ye.pushBytes(oe) : oe.length <= 55 ? (ye.pushByte(128 + oe.length), ye.pushBytes(oe)) : (ye.pushByte(128 + 55 + ae), ae === 1 ? ye.pushUint8(oe.length) : ae === 2 ? ye.pushUint16(oe.length) : ae === 3 ? ye.pushUint24(oe.length) : ye.pushUint32(oe.length), ye.pushBytes(oe));
    }
  };
}
function getSizeOfLength(ne) {
  if (ne < 2 ** 8)
    return 1;
  if (ne < 2 ** 16)
    return 2;
  if (ne < 2 ** 24)
    return 3;
  if (ne < 2 ** 32)
    return 4;
  throw new BaseError$1("Length is too large.");
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(ne) {
  const oe = {
    ...ne,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    contractAddress: ne.contractAddress ? ne.contractAddress : null,
    cumulativeGasUsed: ne.cumulativeGasUsed ? BigInt(ne.cumulativeGasUsed) : null,
    effectiveGasPrice: ne.effectiveGasPrice ? BigInt(ne.effectiveGasPrice) : null,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : null,
    logs: ne.logs ? ne.logs.map((ae) => formatLog(ae)) : null,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? hexToNumber$1(ne.transactionIndex) : null,
    status: ne.status ? receiptStatuses[ne.status] : null,
    type: ne.type ? transactionType[ne.type] || ne.type : null
  };
  return ne.blobGasPrice && (oe.blobGasPrice = BigInt(ne.blobGasPrice)), ne.blobGasUsed && (oe.blobGasUsed = BigInt(ne.blobGasUsed)), oe;
}
const defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt), presignMessagePrefix = `Ethereum Signed Message:
`;
function hashMessage(ne, oe) {
  const ae = (() => typeof ne == "string" ? stringToBytes(ne) : ne.raw instanceof Uint8Array ? ne.raw : toBytes$1(ne.raw))(), fe = stringToBytes(`${presignMessagePrefix}${ae.length}`);
  return keccak256(concat$1([fe, ae]), oe);
}
function assertTransactionEIP4844(ne) {
  const { blobVersionedHashes: oe } = ne;
  if (oe) {
    if (oe.length === 0)
      throw new EmptyBlobError();
    for (const ae of oe) {
      const fe = size$2(ae), ye = hexToNumber$1(slice(ae, 0, 1));
      if (fe !== 32)
        throw new InvalidVersionedHashSizeError({ hash: ae, size: fe });
      if (ye !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash: ae,
          version: ye
        });
    }
  }
  assertTransactionEIP1559(ne);
}
function assertTransactionEIP1559(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe, to: ye } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ye && !isAddress(ye))
    throw new InvalidAddressError({ address: ye });
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ae && fe && ae > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ae });
}
function assertTransactionEIP2930(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: we } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (we && !isAddress(we))
    throw new InvalidAddressError({ address: we });
  if (ae || ye)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
}
function assertTransactionLegacy(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: we, accessList: _e } = ne;
  if (we && !isAddress(we))
    throw new InvalidAddressError({ address: we });
  if (typeof oe < "u" && oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ae || ye)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (_e)
    throw new BaseError$1("`accessList` is not a valid Legacy Transaction attribute.");
}
function serializeAccessList(ne) {
  if (!ne || ne.length === 0)
    return [];
  const oe = [];
  for (let ae = 0; ae < ne.length; ae++) {
    const { address: fe, storageKeys: ye } = ne[ae];
    for (let we = 0; we < ye.length; we++)
      if (ye[we].length - 2 !== 64)
        throw new InvalidStorageKeySizeError({ storageKey: ye[we] });
    if (!isAddress(fe, { strict: !1 }))
      throw new InvalidAddressError({ address: fe });
    oe.push([fe, ye]);
  }
  return oe;
}
function serializeTransaction$1(ne, oe) {
  const ae = getTransactionType(ne);
  return ae === "eip1559" ? serializeTransactionEIP1559(ne, oe) : ae === "eip2930" ? serializeTransactionEIP2930(ne, oe) : ae === "eip4844" ? serializeTransactionEIP4844(ne, oe) : serializeTransactionLegacy(ne, oe);
}
function serializeTransactionEIP4844(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: we, value: _e, maxFeePerBlobGas: xe, maxFeePerGas: Oe, maxPriorityFeePerGas: $e, accessList: Re, data: Ne } = ne;
  assertTransactionEIP4844(ne);
  let je = ne.blobVersionedHashes, Be = ne.sidecars;
  if (ne.blobs && (typeof je > "u" || typeof Be > "u")) {
    const tt = typeof ne.blobs[0] == "string" ? ne.blobs : ne.blobs.map((gt) => bytesToHex$2(gt)), it = ne.kzg, ht = blobsToCommitments({
      blobs: tt,
      kzg: it
    });
    if (typeof je > "u" && (je = commitmentsToVersionedHashes({
      commitments: ht
    })), typeof Be > "u") {
      const gt = blobsToProofs({ blobs: tt, commitments: ht, kzg: it });
      Be = toBlobSidecars({ blobs: tt, commitments: ht, proofs: gt });
    }
  }
  const ze = serializeAccessList(Re), He = [
    toHex(ae),
    ye ? toHex(ye) : "0x",
    $e ? toHex($e) : "0x",
    Oe ? toHex(Oe) : "0x",
    fe ? toHex(fe) : "0x",
    we ?? "0x",
    _e ? toHex(_e) : "0x",
    Ne ?? "0x",
    ze,
    xe ? toHex(xe) : "0x",
    je ?? [],
    ...toYParitySignatureArray(ne, oe)
  ], qe = [], Ye = [], ot = [];
  if (Be)
    for (let tt = 0; tt < Be.length; tt++) {
      const { blob: it, commitment: ht, proof: gt } = Be[tt];
      qe.push(it), Ye.push(ht), ot.push(gt);
    }
  return concatHex$1([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    toRlp(Be ? [He, qe, Ye, ot] : He)
  ]);
}
function serializeTransactionEIP1559(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: we, value: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, accessList: $e, data: Re } = ne;
  assertTransactionEIP1559(ne);
  const Ne = serializeAccessList($e), je = [
    toHex(ae),
    ye ? toHex(ye) : "0x",
    Oe ? toHex(Oe) : "0x",
    xe ? toHex(xe) : "0x",
    fe ? toHex(fe) : "0x",
    we ?? "0x",
    _e ? toHex(_e) : "0x",
    Re ?? "0x",
    Ne,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex$1([
    "0x02",
    toRlp(je)
  ]);
}
function serializeTransactionEIP2930(ne, oe) {
  const { chainId: ae, gas: fe, data: ye, nonce: we, to: _e, value: xe, accessList: Oe, gasPrice: $e } = ne;
  assertTransactionEIP2930(ne);
  const Re = serializeAccessList(Oe), Ne = [
    toHex(ae),
    we ? toHex(we) : "0x",
    $e ? toHex($e) : "0x",
    fe ? toHex(fe) : "0x",
    _e ?? "0x",
    xe ? toHex(xe) : "0x",
    ye ?? "0x",
    Re,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex$1([
    "0x01",
    toRlp(Ne)
  ]);
}
function serializeTransactionLegacy(ne, oe) {
  const { chainId: ae = 0, gas: fe, data: ye, nonce: we, to: _e, value: xe, gasPrice: Oe } = ne;
  assertTransactionLegacy(ne);
  let $e = [
    we ? toHex(we) : "0x",
    Oe ? toHex(Oe) : "0x",
    fe ? toHex(fe) : "0x",
    _e ?? "0x",
    xe ? toHex(xe) : "0x",
    ye ?? "0x"
  ];
  if (oe) {
    const Re = (() => {
      if (oe.v >= 35n)
        return (oe.v - 35n) / 2n > 0 ? oe.v : 27n + (oe.v === 35n ? 0n : 1n);
      if (ae > 0)
        return BigInt(ae * 2) + BigInt(35n + oe.v - 27n);
      const Ne = 27n + (oe.v === 27n ? 0n : 1n);
      if (oe.v !== Ne)
        throw new InvalidLegacyVError({ v: oe.v });
      return Ne;
    })();
    $e = [
      ...$e,
      toHex(Re),
      oe.r,
      oe.s
    ];
  } else
    ae > 0 && ($e = [
      ...$e,
      toHex(ae),
      "0x",
      "0x"
    ]);
  return toRlp($e);
}
function toYParitySignatureArray(ne, oe) {
  const { r: ae, s: fe, v: ye, yParity: we } = oe ?? ne;
  return typeof ae > "u" ? [] : typeof fe > "u" ? [] : typeof ye > "u" && typeof we > "u" ? [] : [(() => typeof we == "number" ? we ? toHex(1) : "0x" : ye === 0n ? "0x" : ye === 1n ? toHex(1) : ye === 27n ? "0x" : toHex(1))(), trim(ae), trim(fe)];
}
function parseUnits(ne, oe) {
  let [ae, fe = "0"] = ne.split(".");
  const ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    const [we, _e, xe] = [
      fe.slice(0, oe - 1),
      fe.slice(oe - 1, oe),
      fe.slice(oe)
    ], Oe = Math.round(+`${_e}.${xe}`);
    Oe > 9 ? fe = `${BigInt(we) + BigInt(1)}0`.padStart(we.length + 1, "0") : fe = `${we}${Oe}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
function parseEther(ne, oe = "wei") {
  return parseUnits(ne, etherUnits[oe]);
}
function formatStorageProof(ne) {
  return ne.map((oe) => ({
    ...oe,
    value: BigInt(oe.value)
  }));
}
function formatProof(ne) {
  return {
    ...ne,
    balance: ne.balance ? BigInt(ne.balance) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    storageProof: ne.storageProof ? formatStorageProof(ne.storageProof) : void 0
  };
}
async function getProof(ne, { address: oe, blockNumber: ae, blockTag: fe, storageKeys: ye }) {
  const we = fe ?? "latest", _e = ae !== void 0 ? numberToHex(ae) : void 0, xe = await ne.request({
    method: "eth_getProof",
    params: [oe, ye, _e || we]
  });
  return formatProof(xe);
}
async function getStorageAt(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest", slot: ye }) {
  const we = ae !== void 0 ? numberToHex(ae) : void 0;
  return await ne.request({
    method: "eth_getStorageAt",
    params: [oe, ye, we || fe]
  });
}
async function getTransaction(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: we }) {
  var Re, Ne, je;
  const _e = fe || "latest", xe = ae !== void 0 ? numberToHex(ae) : void 0;
  let Oe = null;
  if (ye ? Oe = await ne.request({
    method: "eth_getTransactionByHash",
    params: [ye]
  }) : oe ? Oe = await ne.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [oe, numberToHex(we)]
  }) : (xe || _e) && (Oe = await ne.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [xe || _e, numberToHex(we)]
  })), !Oe)
    throw new TransactionNotFoundError({
      blockHash: oe,
      blockNumber: ae,
      blockTag: _e,
      hash: ye,
      index: we
    });
  return (((je = (Ne = (Re = ne.chain) == null ? void 0 : Re.formatters) == null ? void 0 : Ne.transaction) == null ? void 0 : je.format) || formatTransaction)(Oe);
}
async function getTransactionConfirmations(ne, { hash: oe, transactionReceipt: ae }) {
  const [fe, ye] = await Promise.all([
    getAction(ne, getBlockNumber, "getBlockNumber")({}),
    oe ? getAction(ne, getTransaction, "getBlockNumber")({ hash: oe }) : void 0
  ]), we = (ae == null ? void 0 : ae.blockNumber) || (ye == null ? void 0 : ye.blockNumber);
  return we ? fe - we + 1n : 0n;
}
async function getTransactionReceipt(ne, { hash: oe }) {
  var ye, we, _e;
  const ae = await ne.request({
    method: "eth_getTransactionReceipt",
    params: [oe]
  });
  if (!ae)
    throw new TransactionReceiptNotFoundError({ hash: oe });
  return (((_e = (we = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : we.transactionReceipt) == null ? void 0 : _e.format) || formatTransactionReceipt)(ae);
}
async function multicall(ne, oe) {
  var qe;
  const { allowFailure: ae = !0, batchSize: fe, blockNumber: ye, blockTag: we, multicallAddress: _e, stateOverride: xe } = oe, Oe = oe.contracts, $e = fe ?? (typeof ((qe = ne.batch) == null ? void 0 : qe.multicall) == "object" && ne.batch.multicall.batchSize || 1024);
  let Re = _e;
  if (!Re) {
    if (!ne.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    Re = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Ne = [[]];
  let je = 0, Be = 0;
  for (let Ye = 0; Ye < Oe.length; Ye++) {
    const { abi: ot, address: tt, args: it, functionName: ht } = Oe[Ye];
    try {
      const gt = encodeFunctionData({ abi: ot, args: it, functionName: ht });
      Be += (gt.length - 2) / 2, // Check if batching is enabled.
      $e > 0 && // Check if the current size of the batch exceeds the size limit.
      Be > $e && // Check if the current chunk is not already empty.
      Ne[je].length > 0 && (je++, Be = (gt.length - 2) / 2, Ne[je] = []), Ne[je] = [
        ...Ne[je],
        {
          allowFailure: !0,
          callData: gt,
          target: tt
        }
      ];
    } catch (gt) {
      const At = getContractError(gt, {
        abi: ot,
        address: tt,
        args: it,
        docsPath: "/docs/contract/multicall",
        functionName: ht
      });
      if (!ae)
        throw At;
      Ne[je] = [
        ...Ne[je],
        {
          allowFailure: !0,
          callData: "0x",
          target: tt
        }
      ];
    }
  }
  const ze = await Promise.allSettled(Ne.map((Ye) => getAction(ne, readContract, "readContract")({
    abi: multicall3Abi,
    address: Re,
    args: [Ye],
    blockNumber: ye,
    blockTag: we,
    functionName: "aggregate3",
    stateOverride: xe
  }))), He = [];
  for (let Ye = 0; Ye < ze.length; Ye++) {
    const ot = ze[Ye];
    if (ot.status === "rejected") {
      if (!ae)
        throw ot.reason;
      for (let it = 0; it < Ne[Ye].length; it++)
        He.push({
          status: "failure",
          error: ot.reason,
          result: void 0
        });
      continue;
    }
    const tt = ot.value;
    for (let it = 0; it < tt.length; it++) {
      const { returnData: ht, success: gt } = tt[it], { callData: At } = Ne[Ye][it], { abi: St, address: Nt, functionName: Ft, args: Vt } = Oe[He.length];
      try {
        if (At === "0x")
          throw new AbiDecodingZeroDataError();
        if (!gt)
          throw new RawContractError({ data: ht });
        const on = decodeFunctionResult({
          abi: St,
          args: Vt,
          data: ht,
          functionName: Ft
        });
        He.push(ae ? { result: on, status: "success" } : on);
      } catch (on) {
        const tn = getContractError(on, {
          abi: St,
          address: Nt,
          args: Vt,
          docsPath: "/docs/contract/multicall",
          functionName: Ft
        });
        if (!ae)
          throw tn;
        He.push({ error: tn, result: void 0, status: "failure" });
      }
    }
  }
  if (He.length !== Oe.length)
    throw new BaseError$1("multicall results mismatch");
  return He;
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a = (ne) => ne instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function bytesToHex$1(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  let oe = "";
  for (let ae = 0; ae < ne.length; ae++)
    oe += hexes$1[ne[ae]];
  return oe;
}
function numberToHexUnpadded(ne) {
  const oe = ne.toString(16);
  return oe.length & 1 ? `0${oe}` : oe;
}
function hexToNumber(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  return BigInt(ne === "" ? "0" : `0x${ne}`);
}
function hexToBytes(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  const oe = ne.length;
  if (oe % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + oe);
  const ae = new Uint8Array(oe / 2);
  for (let fe = 0; fe < ae.length; fe++) {
    const ye = fe * 2, we = ne.slice(ye, ye + 2), _e = Number.parseInt(we, 16);
    if (Number.isNaN(_e) || _e < 0)
      throw new Error("Invalid byte sequence");
    ae[fe] = _e;
  }
  return ae;
}
function bytesToNumberBE(ne) {
  return hexToNumber(bytesToHex$1(ne));
}
function bytesToNumberLE(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(ne).reverse()));
}
function numberToBytesBE(ne, oe) {
  return hexToBytes(ne.toString(16).padStart(oe * 2, "0"));
}
function numberToBytesLE(ne, oe) {
  return numberToBytesBE(ne, oe).reverse();
}
function numberToVarBytesBE(ne) {
  return hexToBytes(numberToHexUnpadded(ne));
}
function ensureBytes(ne, oe, ae) {
  let fe;
  if (typeof oe == "string")
    try {
      fe = hexToBytes(oe);
    } catch (we) {
      throw new Error(`${ne} must be valid hex string, got "${oe}". Cause: ${we}`);
    }
  else if (u8a(oe))
    fe = Uint8Array.from(oe);
  else
    throw new Error(`${ne} must be hex string or Uint8Array`);
  const ye = fe.length;
  if (typeof ae == "number" && ye !== ae)
    throw new Error(`${ne} expected ${ae} bytes, got ${ye}`);
  return fe;
}
function concatBytes(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
function equalBytes(ne, oe) {
  if (ne.length !== oe.length)
    return !1;
  for (let ae = 0; ae < ne.length; ae++)
    if (ne[ae] !== oe[ae])
      return !1;
  return !0;
}
function utf8ToBytes(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function bitLen(ne) {
  let oe;
  for (oe = 0; ne > _0n$3; ne >>= _1n$4, oe += 1)
    ;
  return oe;
}
function bitGet(ne, oe) {
  return ne >> BigInt(oe) & _1n$4;
}
const bitSet = (ne, oe, ae) => ne | (ae ? _1n$4 : _0n$3) << BigInt(oe), bitMask = (ne) => (_2n$2 << BigInt(ne - 1)) - _1n$4, u8n = (ne) => new Uint8Array(ne), u8fr = (ne) => Uint8Array.from(ne);
function createHmacDrbg(ne, oe, ae) {
  if (typeof ne != "number" || ne < 2)
    throw new Error("hashLen must be a number");
  if (typeof oe != "number" || oe < 2)
    throw new Error("qByteLen must be a number");
  if (typeof ae != "function")
    throw new Error("hmacFn must be a function");
  let fe = u8n(ne), ye = u8n(ne), we = 0;
  const _e = () => {
    fe.fill(1), ye.fill(0), we = 0;
  }, xe = (...Ne) => ae(ye, fe, ...Ne), Oe = (Ne = u8n()) => {
    ye = xe(u8fr([0]), Ne), fe = xe(), Ne.length !== 0 && (ye = xe(u8fr([1]), Ne), fe = xe());
  }, $e = () => {
    if (we++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let Ne = 0;
    const je = [];
    for (; Ne < oe; ) {
      fe = xe();
      const Be = fe.slice();
      je.push(Be), Ne += fe.length;
    }
    return concatBytes(...je);
  };
  return (Ne, je) => {
    _e(), Oe(Ne);
    let Be;
    for (; !(Be = je($e())); )
      Oe();
    return _e(), Be;
  };
}
const validatorFns = {
  bigint: (ne) => typeof ne == "bigint",
  function: (ne) => typeof ne == "function",
  boolean: (ne) => typeof ne == "boolean",
  string: (ne) => typeof ne == "string",
  stringOrUint8Array: (ne) => typeof ne == "string" || ne instanceof Uint8Array,
  isSafeInteger: (ne) => Number.isSafeInteger(ne),
  array: (ne) => Array.isArray(ne),
  field: (ne, oe) => oe.Fp.isValid(ne),
  hash: (ne) => typeof ne == "function" && Number.isSafeInteger(ne.outputLen)
};
function validateObject(ne, oe, ae = {}) {
  const fe = (ye, we, _e) => {
    const xe = validatorFns[we];
    if (typeof xe != "function")
      throw new Error(`Invalid validator "${we}", expected function`);
    const Oe = ne[ye];
    if (!(_e && Oe === void 0) && !xe(Oe, ne))
      throw new Error(`Invalid param ${String(ye)}=${Oe} (${typeof Oe}), expected ${we}`);
  };
  for (const [ye, we] of Object.entries(oe))
    fe(ye, we, !1);
  for (const [ye, we] of Object.entries(ae))
    fe(ye, we, !0);
  return ne;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual(ne, oe) {
  const ae = isHex$1(ne) ? toBytes$1(ne) : ne, fe = isHex$1(oe) ? toBytes$1(oe) : oe;
  return equalBytes(ae, fe);
}
async function verifyHash(ne, { address: oe, hash: ae, signature: fe, ...ye }) {
  const we = isHex$1(fe) ? fe : toHex(fe);
  try {
    const { data: _e } = await getAction(ne, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [oe, ae, we],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...ye
    });
    return isBytesEqual(_e ?? "0x0", "0x1");
  } catch (_e) {
    if (_e instanceof CallExecutionError)
      return !1;
    throw _e;
  }
}
async function verifyMessage(ne, { address: oe, message: ae, signature: fe, ...ye }) {
  const we = hashMessage(ae);
  return verifyHash(ne, {
    address: oe,
    hash: we,
    signature: fe,
    ...ye
  });
}
async function verifyTypedData(ne, oe) {
  const { address: ae, signature: fe, message: ye, primaryType: we, types: _e, domain: xe, ...Oe } = oe, $e = hashTypedData({ message: ye, primaryType: we, types: _e, domain: xe });
  return verifyHash(ne, {
    address: ae,
    hash: $e,
    signature: fe,
    ...Oe
  });
}
function watchBlockNumber(ne, { emitOnBegin: oe = !1, emitMissed: ae = !1, onBlockNumber: fe, onError: ye, poll: we, pollingInterval: _e = ne.pollingInterval }) {
  const xe = typeof we < "u" ? we : ne.transport.type !== "webSocket";
  let Oe;
  return xe ? (() => {
    const Ne = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae,
      _e
    ]);
    return observe(Ne, { onBlockNumber: fe, onError: ye }, (je) => poll(async () => {
      var Be;
      try {
        const ze = await getAction(ne, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (Oe) {
          if (ze === Oe)
            return;
          if (ze - Oe > 1 && ae)
            for (let He = Oe + 1n; He < ze; He++)
              je.onBlockNumber(He, Oe), Oe = He;
        }
        (!Oe || ze > Oe) && (je.onBlockNumber(ze, Oe), Oe = ze);
      } catch (ze) {
        (Be = je.onError) == null || Be.call(je, ze);
      }
    }, {
      emitOnBegin: oe,
      interval: _e
    }));
  })() : (() => {
    const Ne = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae
    ]);
    return observe(Ne, { onBlockNumber: fe, onError: ye }, (je) => {
      let Be = !0, ze = () => Be = !1;
      return (async () => {
        try {
          const { unsubscribe: He } = await ne.transport.subscribe({
            params: ["newHeads"],
            onData(qe) {
              var ot;
              if (!Be)
                return;
              const Ye = hexToBigInt((ot = qe.result) == null ? void 0 : ot.number);
              je.onBlockNumber(Ye, Oe), Oe = Ye;
            },
            onError(qe) {
              var Ye;
              (Ye = je.onError) == null || Ye.call(je, qe);
            }
          });
          ze = He, Be || ze();
        } catch (He) {
          ye == null || ye(He);
        }
      })(), () => ze();
    });
  })();
}
async function waitForTransactionReceipt(ne, {
  confirmations: oe = 1,
  hash: ae,
  onReplaced: fe,
  pollingInterval: ye = ne.pollingInterval,
  retryCount: we = 6,
  retryDelay: _e = ({ count: Oe }) => ~~(1 << Oe) * 200,
  // exponential backoff
  timeout: xe
}) {
  const Oe = stringify(["waitForTransactionReceipt", ne.uid, ae]);
  let $e, Re, Ne, je = !1;
  return new Promise((Be, ze) => {
    xe && setTimeout(() => ze(new WaitForTransactionReceiptTimeoutError({ hash: ae })), xe);
    const He = observe(Oe, { onReplaced: fe, resolve: Be, reject: ze }, (qe) => {
      const Ye = getAction(ne, watchBlockNumber, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: ye,
        async onBlockNumber(ot) {
          if (je)
            return;
          let tt = ot;
          const it = (ht) => {
            Ye(), ht(), He();
          };
          try {
            if (Ne) {
              if (oe > 1 && (!Ne.blockNumber || tt - Ne.blockNumber + 1n < oe))
                return;
              it(() => qe.resolve(Ne));
              return;
            }
            if ($e || (je = !0, await withRetry(async () => {
              $e = await getAction(ne, getTransaction, "getTransaction")({ hash: ae }), $e.blockNumber && (tt = $e.blockNumber);
            }, {
              delay: _e,
              retryCount: we
            }), je = !1), Ne = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({ hash: ae }), oe > 1 && (!Ne.blockNumber || tt - Ne.blockNumber + 1n < oe))
              return;
            it(() => qe.resolve(Ne));
          } catch (ht) {
            if (ht instanceof TransactionNotFoundError || ht instanceof TransactionReceiptNotFoundError) {
              if (!$e) {
                je = !1;
                return;
              }
              try {
                Re = $e, je = !0;
                const gt = await withRetry(() => getAction(ne, getBlock, "getBlock")({
                  blockNumber: tt,
                  includeTransactions: !0
                }), {
                  delay: _e,
                  retryCount: we,
                  shouldRetry: ({ error: Nt }) => Nt instanceof BlockNotFoundError
                });
                je = !1;
                const At = gt.transactions.find(({ from: Nt, nonce: Ft }) => Nt === Re.from && Ft === Re.nonce);
                if (!At || (Ne = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({
                  hash: At.hash
                }), oe > 1 && (!Ne.blockNumber || tt - Ne.blockNumber + 1n < oe)))
                  return;
                let St = "replaced";
                At.to === Re.to && At.value === Re.value ? St = "repriced" : At.from === At.to && At.value === 0n && (St = "cancelled"), it(() => {
                  var Nt;
                  (Nt = qe.onReplaced) == null || Nt.call(qe, {
                    reason: St,
                    replacedTransaction: Re,
                    transaction: At,
                    transactionReceipt: Ne
                  }), qe.resolve(Ne);
                });
              } catch (gt) {
                it(() => qe.reject(gt));
              }
            } else
              it(() => qe.reject(ht));
          }
        }
      });
    });
  });
}
function watchBlocks(ne, { blockTag: oe = "latest", emitMissed: ae = !1, emitOnBegin: fe = !1, onBlock: ye, onError: we, includeTransactions: _e, poll: xe, pollingInterval: Oe = ne.pollingInterval }) {
  const $e = typeof xe < "u" ? xe : ne.transport.type !== "webSocket", Re = _e ?? !1;
  let Ne;
  return $e ? (() => {
    const ze = stringify([
      "watchBlocks",
      ne.uid,
      oe,
      ae,
      fe,
      Re,
      Oe
    ]);
    return observe(ze, { onBlock: ye, onError: we }, (He) => poll(async () => {
      var qe;
      try {
        const Ye = await getAction(ne, getBlock, "getBlock")({
          blockTag: oe,
          includeTransactions: Re
        });
        if (Ye.number && (Ne != null && Ne.number)) {
          if (Ye.number === Ne.number)
            return;
          if (Ye.number - Ne.number > 1 && ae)
            for (let ot = (Ne == null ? void 0 : Ne.number) + 1n; ot < Ye.number; ot++) {
              const tt = await getAction(ne, getBlock, "getBlock")({
                blockNumber: ot,
                includeTransactions: Re
              });
              He.onBlock(tt, Ne), Ne = tt;
            }
        }
        // If no previous block exists, emit.
        (!(Ne != null && Ne.number) || // If the block tag is "pending" with no block number, emit.
        oe === "pending" && !(Ye != null && Ye.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        Ye.number && Ye.number > Ne.number) && (He.onBlock(Ye, Ne), Ne = Ye);
      } catch (Ye) {
        (qe = He.onError) == null || qe.call(He, Ye);
      }
    }, {
      emitOnBegin: fe,
      interval: Oe
    }));
  })() : (() => {
    let ze = !0, He = () => ze = !1;
    return (async () => {
      try {
        const { unsubscribe: qe } = await ne.transport.subscribe({
          params: ["newHeads"],
          onData(Ye) {
            var it, ht, gt;
            if (!ze)
              return;
            const tt = (((gt = (ht = (it = ne.chain) == null ? void 0 : it.formatters) == null ? void 0 : ht.block) == null ? void 0 : gt.format) || formatBlock)(Ye.result);
            ye(tt, Ne), Ne = tt;
          },
          onError(Ye) {
            we == null || we(Ye);
          }
        });
        He = qe, ze || He();
      } catch (qe) {
        we == null || we(qe);
      }
    })(), () => He();
  })();
}
function watchEvent(ne, { address: oe, args: ae, batch: fe = !0, event: ye, events: we, fromBlock: _e, onError: xe, onLogs: Oe, poll: $e, pollingInterval: Re = ne.pollingInterval, strict: Ne }) {
  const je = typeof $e < "u" ? $e : ne.transport.type !== "webSocket" || typeof _e == "bigint", Be = Ne ?? !1;
  return je ? (() => {
    const qe = stringify([
      "watchEvent",
      oe,
      ae,
      fe,
      ne.uid,
      ye,
      Re,
      _e
    ]);
    return observe(qe, { onLogs: Oe, onError: xe }, (Ye) => {
      let ot;
      _e !== void 0 && (ot = _e - 1n);
      let tt, it = !1;
      const ht = poll(async () => {
        var gt;
        if (!it) {
          try {
            tt = await getAction(ne, createEventFilter, "createEventFilter")({
              address: oe,
              args: ae,
              event: ye,
              events: we,
              strict: Be,
              fromBlock: _e
            });
          } catch {
          }
          it = !0;
          return;
        }
        try {
          let At;
          if (tt)
            At = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: tt });
          else {
            const St = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            ot && ot !== St ? At = await getAction(ne, getLogs, "getLogs")({
              address: oe,
              args: ae,
              event: ye,
              events: we,
              fromBlock: ot + 1n,
              toBlock: St
            }) : At = [], ot = St;
          }
          if (At.length === 0)
            return;
          if (fe)
            Ye.onLogs(At);
          else
            for (const St of At)
              Ye.onLogs([St]);
        } catch (At) {
          tt && At instanceof InvalidInputRpcError && (it = !1), (gt = Ye.onError) == null || gt.call(Ye, At);
        }
      }, {
        emitOnBegin: !0,
        interval: Re
      });
      return async () => {
        tt && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: tt }), ht();
      };
    });
  })() : (() => {
    let qe = !0, Ye = () => qe = !1;
    return (async () => {
      try {
        const ot = we ?? (ye ? [ye] : void 0);
        let tt = [];
        ot && (tt = [
          ot.flatMap((ht) => encodeEventTopics({
            abi: [ht],
            eventName: ht.name,
            args: ae
          }))
        ], ye && (tt = tt[0]));
        const { unsubscribe: it } = await ne.transport.subscribe({
          params: ["logs", { address: oe, topics: tt }],
          onData(ht) {
            var At;
            if (!qe)
              return;
            const gt = ht.result;
            try {
              const { eventName: St, args: Nt } = decodeEventLog({
                abi: ot ?? [],
                data: gt.data,
                topics: gt.topics,
                strict: Be
              }), Ft = formatLog(gt, { args: Nt, eventName: St });
              Oe([Ft]);
            } catch (St) {
              let Nt, Ft;
              if (St instanceof DecodeLogDataMismatch || St instanceof DecodeLogTopicsMismatch) {
                if (Ne)
                  return;
                Nt = St.abiItem.name, Ft = (At = St.abiItem.inputs) == null ? void 0 : At.some((on) => !("name" in on && on.name));
              }
              const Vt = formatLog(gt, {
                args: Ft ? [] : {},
                eventName: Nt
              });
              Oe([Vt]);
            }
          },
          onError(ht) {
            xe == null || xe(ht);
          }
        });
        Ye = it, qe || Ye();
      } catch (ot) {
        xe == null || xe(ot);
      }
    })(), () => Ye();
  })();
}
function watchPendingTransactions(ne, { batch: oe = !0, onError: ae, onTransactions: fe, poll: ye, pollingInterval: we = ne.pollingInterval }) {
  return (typeof ye < "u" ? ye : ne.transport.type !== "webSocket") ? (() => {
    const $e = stringify([
      "watchPendingTransactions",
      ne.uid,
      oe,
      we
    ]);
    return observe($e, { onTransactions: fe, onError: ae }, (Re) => {
      let Ne;
      const je = poll(async () => {
        var Be;
        try {
          if (!Ne)
            try {
              Ne = await getAction(ne, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (He) {
              throw je(), He;
            }
          const ze = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: Ne });
          if (ze.length === 0)
            return;
          if (oe)
            Re.onTransactions(ze);
          else
            for (const He of ze)
              Re.onTransactions([He]);
        } catch (ze) {
          (Be = Re.onError) == null || Be.call(Re, ze);
        }
      }, {
        emitOnBegin: !0,
        interval: we
      });
      return async () => {
        Ne && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: Ne }), je();
      };
    });
  })() : (() => {
    let $e = !0, Re = () => $e = !1;
    return (async () => {
      try {
        const { unsubscribe: Ne } = await ne.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(je) {
            if (!$e)
              return;
            const Be = je.result;
            fe([Be]);
          },
          onError(je) {
            ae == null || ae(je);
          }
        });
        Re = Ne, $e || Re();
      } catch (Ne) {
        ae == null || ae(Ne);
      }
    })(), () => Re();
  })();
}
function publicActions(ne) {
  return {
    call: (oe) => call(ne, oe),
    createBlockFilter: () => createBlockFilter(ne),
    createContractEventFilter: (oe) => createContractEventFilter(ne, oe),
    createEventFilter: (oe) => createEventFilter(ne, oe),
    createPendingTransactionFilter: () => createPendingTransactionFilter(ne),
    estimateContractGas: (oe) => estimateContractGas(ne, oe),
    estimateGas: (oe) => estimateGas(ne, oe),
    getBalance: (oe) => getBalance(ne, oe),
    getBlobBaseFee: () => getBlobBaseFee(ne),
    getBlock: (oe) => getBlock(ne, oe),
    getBlockNumber: (oe) => getBlockNumber(ne, oe),
    getBlockTransactionCount: (oe) => getBlockTransactionCount(ne, oe),
    getBytecode: (oe) => getBytecode(ne, oe),
    getChainId: () => getChainId(ne),
    getContractEvents: (oe) => getContractEvents(ne, oe),
    getEnsAddress: (oe) => getEnsAddress(ne, oe),
    getEnsAvatar: (oe) => getEnsAvatar(ne, oe),
    getEnsName: (oe) => getEnsName(ne, oe),
    getEnsResolver: (oe) => getEnsResolver(ne, oe),
    getEnsText: (oe) => getEnsText(ne, oe),
    getFeeHistory: (oe) => getFeeHistory(ne, oe),
    estimateFeesPerGas: (oe) => estimateFeesPerGas(ne, oe),
    getFilterChanges: (oe) => getFilterChanges(ne, oe),
    getFilterLogs: (oe) => getFilterLogs(ne, oe),
    getGasPrice: () => getGasPrice(ne),
    getLogs: (oe) => getLogs(ne, oe),
    getProof: (oe) => getProof(ne, oe),
    estimateMaxPriorityFeePerGas: (oe) => estimateMaxPriorityFeePerGas(ne, oe),
    getStorageAt: (oe) => getStorageAt(ne, oe),
    getTransaction: (oe) => getTransaction(ne, oe),
    getTransactionConfirmations: (oe) => getTransactionConfirmations(ne, oe),
    getTransactionCount: (oe) => getTransactionCount(ne, oe),
    getTransactionReceipt: (oe) => getTransactionReceipt(ne, oe),
    multicall: (oe) => multicall(ne, oe),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    readContract: (oe) => readContract(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    simulateContract: (oe) => simulateContract(ne, oe),
    verifyMessage: (oe) => verifyMessage(ne, oe),
    verifyTypedData: (oe) => verifyTypedData(ne, oe),
    uninstallFilter: (oe) => uninstallFilter(ne, oe),
    waitForTransactionReceipt: (oe) => waitForTransactionReceipt(ne, oe),
    watchBlocks: (oe) => watchBlocks(ne, oe),
    watchBlockNumber: (oe) => watchBlockNumber(ne, oe),
    watchContractEvent: (oe) => watchContractEvent(ne, oe),
    watchEvent: (oe) => watchEvent(ne, oe),
    watchPendingTransactions: (oe) => watchPendingTransactions(ne, oe)
  };
}
function createPublicClient(ne) {
  const { key: oe = "public", name: ae = "Public Client" } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    type: "publicClient"
  }).extend(publicActions);
}
function deployContract(ne, oe) {
  const { abi: ae, args: fe, bytecode: ye, ...we } = oe, _e = encodeDeployData({ abi: ae, args: fe, bytecode: ye });
  return sendTransaction(ne, {
    ...we,
    data: _e
  });
}
async function getAddresses(ne) {
  var ae;
  return ((ae = ne.account) == null ? void 0 : ae.type) === "local" ? [ne.account.address] : (await ne.request({ method: "eth_accounts" })).map((fe) => checksumAddress(fe));
}
async function getPermissions(ne) {
  return await ne.request({ method: "wallet_getPermissions" });
}
async function requestAddresses(ne) {
  return (await ne.request({ method: "eth_requestAccounts" }, { retryCount: 0 })).map((ae) => getAddress(ae));
}
async function requestPermissions(ne, oe) {
  return ne.request({
    method: "wallet_requestPermissions",
    params: [oe]
  }, { retryCount: 0 });
}
async function signMessage$1(ne, { account: oe = ne.account, message: ae }) {
  if (!oe)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const fe = parseAccount(oe);
  if (fe.type === "local")
    return fe.signMessage({ message: ae });
  const ye = (() => typeof ae == "string" ? stringToHex$1(ae) : ae.raw instanceof Uint8Array ? toHex(ae.raw) : ae.raw)();
  return ne.request({
    method: "personal_sign",
    params: [ye, fe.address]
  }, { retryCount: 0 });
}
async function signTransaction$1(ne, oe) {
  var $e, Re, Ne, je;
  const { account: ae = ne.account, chain: fe = ne.chain, ...ye } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const we = parseAccount(ae);
  assertRequest({
    account: we,
    ...oe
  });
  const _e = await getAction(ne, getChainId, "getChainId")({});
  fe !== null && assertCurrentChain({
    currentChainId: _e,
    chain: fe
  });
  const xe = (fe == null ? void 0 : fe.formatters) || (($e = ne.chain) == null ? void 0 : $e.formatters), Oe = ((Re = xe == null ? void 0 : xe.transactionRequest) == null ? void 0 : Re.format) || formatTransactionRequest;
  return we.type === "local" ? we.signTransaction({
    ...ye,
    chainId: _e
  }, { serializer: (je = (Ne = ne.chain) == null ? void 0 : Ne.serializers) == null ? void 0 : je.transaction }) : await ne.request({
    method: "eth_signTransaction",
    params: [
      {
        ...Oe(ye),
        chainId: numberToHex(_e),
        from: we.address
      }
    ]
  }, { retryCount: 0 });
}
async function signTypedData$1(ne, oe) {
  const { account: ae = ne.account, domain: fe, message: ye, primaryType: we } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const _e = parseAccount(ae), xe = {
    EIP712Domain: getTypesForEIP712Domain({ domain: fe }),
    ...oe.types
  };
  if (validateTypedData({ domain: fe, message: ye, primaryType: we, types: xe }), _e.type === "local")
    return _e.signTypedData({ domain: fe, message: ye, primaryType: we, types: xe });
  const Oe = stringify({ domain: fe ?? {}, message: ye, primaryType: we, types: xe }, ($e, Re) => isHex$1(Re) ? Re.toLowerCase() : Re);
  return ne.request({
    method: "eth_signTypedData_v4",
    params: [_e.address, Oe]
  }, { retryCount: 0 });
}
async function switchChain(ne, { id: oe }) {
  await ne.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(oe)
      }
    ]
  }, { retryCount: 0 });
}
async function watchAsset(ne, oe) {
  return await ne.request({
    method: "wallet_watchAsset",
    params: oe
  }, { retryCount: 0 });
}
function walletActions(ne) {
  return {
    addChain: (oe) => addChain(ne, oe),
    deployContract: (oe) => deployContract(ne, oe),
    getAddresses: () => getAddresses(ne),
    getChainId: () => getChainId(ne),
    getPermissions: () => getPermissions(ne),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    requestAddresses: () => requestAddresses(ne),
    requestPermissions: (oe) => requestPermissions(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    sendTransaction: (oe) => sendTransaction(ne, oe),
    signMessage: (oe) => signMessage$1(ne, oe),
    signTransaction: (oe) => signTransaction$1(ne, oe),
    signTypedData: (oe) => signTypedData$1(ne, oe),
    switchChain: (oe) => switchChain(ne, oe),
    watchAsset: (oe) => watchAsset(ne, oe),
    writeContract: (oe) => writeContract(ne, oe)
  };
}
function createWalletClient(ne) {
  const { key: oe = "wallet", name: ae = "Wallet Client", transport: fe } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    transport: fe,
    type: "walletClient"
  }).extend(walletActions);
}
function webSocket(ne, oe = {}) {
  const { key: ae = "webSocket", name: fe = "WebSocket JSON-RPC", reconnect: ye, retryDelay: we } = oe;
  return ({ chain: _e, retryCount: xe, timeout: Oe }) => {
    var je;
    const $e = oe.retryCount ?? xe, Re = Oe ?? oe.timeout ?? 1e4, Ne = ne || ((je = _e == null ? void 0 : _e.rpcUrls.default.webSocket) == null ? void 0 : je[0]);
    if (!Ne)
      throw new UrlRequiredError();
    return createTransport({
      key: ae,
      name: fe,
      async request({ method: Be, params: ze }) {
        const He = { method: Be, params: ze }, qe = await getWebSocketRpcClient(Ne, { reconnect: ye }), { error: Ye, result: ot } = await qe.requestAsync({
          body: He,
          timeout: Re
        });
        if (Ye)
          throw new RpcRequestError({
            body: He,
            error: Ye,
            url: Ne
          });
        return ot;
      },
      retryCount: $e,
      retryDelay: we,
      timeout: Re,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(Ne);
      },
      getRpcClient() {
        return getWebSocketRpcClient(Ne);
      },
      async subscribe({ params: Be, onData: ze, onError: He }) {
        const qe = await getWebSocketRpcClient(Ne), { result: Ye } = await new Promise((ot, tt) => qe.request({
          body: {
            method: "eth_subscribe",
            params: Be
          },
          onResponse(it) {
            if (it.error) {
              tt(it.error), He == null || He(it.error);
              return;
            }
            if (typeof it.id == "number") {
              ot(it);
              return;
            }
            it.method === "eth_subscription" && ze(it.params);
          }
        }));
        return {
          subscriptionId: Ye,
          async unsubscribe() {
            return new Promise((ot) => qe.request({
              body: {
                method: "eth_unsubscribe",
                params: [Ye]
              },
              onResponse: ot
            }));
          }
        };
      }
    });
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(ne, oe) {
  const ae = ne % oe;
  return ae >= _0n$2 ? ae : oe + ae;
}
function pow(ne, oe, ae) {
  if (ae <= _0n$2 || oe < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (ae === _1n$3)
    return _0n$2;
  let fe = _1n$3;
  for (; oe > _0n$2; )
    oe & _1n$3 && (fe = fe * ne % ae), ne = ne * ne % ae, oe >>= _1n$3;
  return fe;
}
function pow2(ne, oe, ae) {
  let fe = ne;
  for (; oe-- > _0n$2; )
    fe *= fe, fe %= ae;
  return fe;
}
function invert$1(ne, oe) {
  if (ne === _0n$2 || oe <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${ne} mod=${oe}`);
  let ae = mod(ne, oe), fe = oe, ye = _0n$2, we = _1n$3;
  for (; ae !== _0n$2; ) {
    const xe = fe / ae, Oe = fe % ae, $e = ye - we * xe;
    fe = ae, ae = Oe, ye = we, we = $e;
  }
  if (fe !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(ye, oe);
}
function tonelliShanks(ne) {
  const oe = (ne - _1n$3) / _2n$1;
  let ae, fe, ye;
  for (ae = ne - _1n$3, fe = 0; ae % _2n$1 === _0n$2; ae /= _2n$1, fe++)
    ;
  for (ye = _2n$1; ye < ne && pow(ye, oe, ne) !== ne - _1n$3; ye++)
    ;
  if (fe === 1) {
    const _e = (ne + _1n$3) / _4n;
    return function(Oe, $e) {
      const Re = Oe.pow($e, _e);
      if (!Oe.eql(Oe.sqr(Re), $e))
        throw new Error("Cannot find square root");
      return Re;
    };
  }
  const we = (ae + _1n$3) / _2n$1;
  return function(xe, Oe) {
    if (xe.pow(Oe, oe) === xe.neg(xe.ONE))
      throw new Error("Cannot find square root");
    let $e = fe, Re = xe.pow(xe.mul(xe.ONE, ye), ae), Ne = xe.pow(Oe, we), je = xe.pow(Oe, ae);
    for (; !xe.eql(je, xe.ONE); ) {
      if (xe.eql(je, xe.ZERO))
        return xe.ZERO;
      let Be = 1;
      for (let He = xe.sqr(je); Be < $e && !xe.eql(He, xe.ONE); Be++)
        He = xe.sqr(He);
      const ze = xe.pow(Re, _1n$3 << BigInt($e - Be - 1));
      Re = xe.sqr(ze), Ne = xe.mul(Ne, ze), je = xe.mul(je, Re), $e = Be;
    }
    return Ne;
  };
}
function FpSqrt(ne) {
  if (ne % _4n === _3n$1) {
    const oe = (ne + _1n$3) / _4n;
    return function(fe, ye) {
      const we = fe.pow(ye, oe);
      if (!fe.eql(fe.sqr(we), ye))
        throw new Error("Cannot find square root");
      return we;
    };
  }
  if (ne % _8n === _5n) {
    const oe = (ne - _5n) / _8n;
    return function(fe, ye) {
      const we = fe.mul(ye, _2n$1), _e = fe.pow(we, oe), xe = fe.mul(ye, _e), Oe = fe.mul(fe.mul(xe, _2n$1), _e), $e = fe.mul(xe, fe.sub(Oe, fe.ONE));
      if (!fe.eql(fe.sqr($e), ye))
        throw new Error("Cannot find square root");
      return $e;
    };
  }
  return tonelliShanks(ne);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(ne) {
  const oe = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, ae = FIELD_FIELDS.reduce((fe, ye) => (fe[ye] = "function", fe), oe);
  return validateObject(ne, ae);
}
function FpPow(ne, oe, ae) {
  if (ae < _0n$2)
    throw new Error("Expected power > 0");
  if (ae === _0n$2)
    return ne.ONE;
  if (ae === _1n$3)
    return oe;
  let fe = ne.ONE, ye = oe;
  for (; ae > _0n$2; )
    ae & _1n$3 && (fe = ne.mul(fe, ye)), ye = ne.sqr(ye), ae >>= _1n$3;
  return fe;
}
function FpInvertBatch(ne, oe) {
  const ae = new Array(oe.length), fe = oe.reduce((we, _e, xe) => ne.is0(_e) ? we : (ae[xe] = we, ne.mul(we, _e)), ne.ONE), ye = ne.inv(fe);
  return oe.reduceRight((we, _e, xe) => ne.is0(_e) ? we : (ae[xe] = ne.mul(we, ae[xe]), ne.mul(we, _e)), ye), ae;
}
function nLength(ne, oe) {
  const ae = oe !== void 0 ? oe : ne.toString(2).length, fe = Math.ceil(ae / 8);
  return { nBitLength: ae, nByteLength: fe };
}
function Field(ne, oe, ae = !1, fe = {}) {
  if (ne <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ne}`);
  const { nBitLength: ye, nByteLength: we } = nLength(ne, oe);
  if (we > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const _e = FpSqrt(ne), xe = Object.freeze({
    ORDER: ne,
    BITS: ye,
    BYTES: we,
    MASK: bitMask(ye),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (Oe) => mod(Oe, ne),
    isValid: (Oe) => {
      if (typeof Oe != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof Oe}`);
      return _0n$2 <= Oe && Oe < ne;
    },
    is0: (Oe) => Oe === _0n$2,
    isOdd: (Oe) => (Oe & _1n$3) === _1n$3,
    neg: (Oe) => mod(-Oe, ne),
    eql: (Oe, $e) => Oe === $e,
    sqr: (Oe) => mod(Oe * Oe, ne),
    add: (Oe, $e) => mod(Oe + $e, ne),
    sub: (Oe, $e) => mod(Oe - $e, ne),
    mul: (Oe, $e) => mod(Oe * $e, ne),
    pow: (Oe, $e) => FpPow(xe, Oe, $e),
    div: (Oe, $e) => mod(Oe * invert$1($e, ne), ne),
    // Same as above, but doesn't normalize
    sqrN: (Oe) => Oe * Oe,
    addN: (Oe, $e) => Oe + $e,
    subN: (Oe, $e) => Oe - $e,
    mulN: (Oe, $e) => Oe * $e,
    inv: (Oe) => invert$1(Oe, ne),
    sqrt: fe.sqrt || ((Oe) => _e(xe, Oe)),
    invertBatch: (Oe) => FpInvertBatch(xe, Oe),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (Oe, $e, Re) => Re ? $e : Oe,
    toBytes: (Oe) => ae ? numberToBytesLE(Oe, we) : numberToBytesBE(Oe, we),
    fromBytes: (Oe) => {
      if (Oe.length !== we)
        throw new Error(`Fp.fromBytes: expected ${we}, got ${Oe.length}`);
      return ae ? bytesToNumberLE(Oe) : bytesToNumberBE(Oe);
    }
  });
  return Object.freeze(xe);
}
function getFieldBytesLength(ne) {
  if (typeof ne != "bigint")
    throw new Error("field order must be bigint");
  const oe = ne.toString(2).length;
  return Math.ceil(oe / 8);
}
function getMinHashLength(ne) {
  const oe = getFieldBytesLength(ne);
  return oe + Math.ceil(oe / 2);
}
function mapHashToField(ne, oe, ae = !1) {
  const fe = ne.length, ye = getFieldBytesLength(oe), we = getMinHashLength(oe);
  if (fe < 16 || fe < we || fe > 1024)
    throw new Error(`expected ${we}-1024 bytes of input, got ${fe}`);
  const _e = ae ? bytesToNumberBE(ne) : bytesToNumberLE(ne), xe = mod(_e, oe - _1n$3) + _1n$3;
  return ae ? numberToBytesLE(xe, ye) : numberToBytesBE(xe, ye);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(ne, oe) {
  const ae = (ye, we) => {
    const _e = we.negate();
    return ye ? _e : we;
  }, fe = (ye) => {
    const we = Math.ceil(oe / ye) + 1, _e = 2 ** (ye - 1);
    return { windows: we, windowSize: _e };
  };
  return {
    constTimeNegate: ae,
    // non-const time multiplication ladder
    unsafeLadder(ye, we) {
      let _e = ne.ZERO, xe = ye;
      for (; we > _0n$1; )
        we & _1n$2 && (_e = _e.add(xe)), xe = xe.double(), we >>= _1n$2;
      return _e;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ye, we) {
      const { windows: _e, windowSize: xe } = fe(we), Oe = [];
      let $e = ye, Re = $e;
      for (let Ne = 0; Ne < _e; Ne++) {
        Re = $e, Oe.push(Re);
        for (let je = 1; je < xe; je++)
          Re = Re.add($e), Oe.push(Re);
        $e = Re.double();
      }
      return Oe;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ye, we, _e) {
      const { windows: xe, windowSize: Oe } = fe(ye);
      let $e = ne.ZERO, Re = ne.BASE;
      const Ne = BigInt(2 ** ye - 1), je = 2 ** ye, Be = BigInt(ye);
      for (let ze = 0; ze < xe; ze++) {
        const He = ze * Oe;
        let qe = Number(_e & Ne);
        _e >>= Be, qe > Oe && (qe -= je, _e += _1n$2);
        const Ye = He, ot = He + Math.abs(qe) - 1, tt = ze % 2 !== 0, it = qe < 0;
        qe === 0 ? Re = Re.add(ae(tt, we[Ye])) : $e = $e.add(ae(it, we[ot]));
      }
      return { p: $e, f: Re };
    },
    wNAFCached(ye, we, _e, xe) {
      const Oe = ye._WINDOW_SIZE || 1;
      let $e = we.get(ye);
      return $e || ($e = this.precomputeWindow(ye, Oe), Oe !== 1 && we.set(ye, xe($e))), this.wNAF(Oe, $e, _e);
    }
  };
}
function validateBasic(ne) {
  return validateField(ne.Fp), validateObject(ne, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(ne.n, ne.nBitLength),
    ...ne,
    p: ne.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(ne) {
  const oe = validateBasic(ne);
  validateObject(oe, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: ae, Fp: fe, a: ye } = oe;
  if (ae) {
    if (!fe.eql(ye, fe.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof ae != "object" || typeof ae.beta != "bigint" || typeof ae.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...oe });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(oe = "") {
      super(oe);
    }
  },
  _parseInt(ne) {
    const { Err: oe } = DER;
    if (ne.length < 2 || ne[0] !== 2)
      throw new oe("Invalid signature integer tag");
    const ae = ne[1], fe = ne.subarray(2, ae + 2);
    if (!ae || fe.length !== ae)
      throw new oe("Invalid signature integer: wrong length");
    if (fe[0] & 128)
      throw new oe("Invalid signature integer: negative");
    if (fe[0] === 0 && !(fe[1] & 128))
      throw new oe("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(fe), l: ne.subarray(ae + 2) };
  },
  toSig(ne) {
    const { Err: oe } = DER, ae = typeof ne == "string" ? h2b(ne) : ne;
    if (!(ae instanceof Uint8Array))
      throw new Error("ui8a expected");
    let fe = ae.length;
    if (fe < 2 || ae[0] != 48)
      throw new oe("Invalid signature tag");
    if (ae[1] !== fe - 2)
      throw new oe("Invalid signature: incorrect length");
    const { d: ye, l: we } = DER._parseInt(ae.subarray(2)), { d: _e, l: xe } = DER._parseInt(we);
    if (xe.length)
      throw new oe("Invalid signature: left bytes after parsing");
    return { r: ye, s: _e };
  },
  hexFromSig(ne) {
    const oe = ($e) => Number.parseInt($e[0], 16) & 8 ? "00" + $e : $e, ae = ($e) => {
      const Re = $e.toString(16);
      return Re.length & 1 ? `0${Re}` : Re;
    }, fe = oe(ae(ne.s)), ye = oe(ae(ne.r)), we = fe.length / 2, _e = ye.length / 2, xe = ae(we), Oe = ae(_e);
    return `30${ae(_e + we + 4)}02${Oe}${ye}02${xe}${fe}`;
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(ne) {
  const oe = validatePointOpts(ne), { Fp: ae } = oe, fe = oe.toBytes || ((ze, He, qe) => {
    const Ye = He.toAffine();
    return concatBytes(Uint8Array.from([4]), ae.toBytes(Ye.x), ae.toBytes(Ye.y));
  }), ye = oe.fromBytes || ((ze) => {
    const He = ze.subarray(1), qe = ae.fromBytes(He.subarray(0, ae.BYTES)), Ye = ae.fromBytes(He.subarray(ae.BYTES, 2 * ae.BYTES));
    return { x: qe, y: Ye };
  });
  function we(ze) {
    const { a: He, b: qe } = oe, Ye = ae.sqr(ze), ot = ae.mul(Ye, ze);
    return ae.add(ae.add(ot, ae.mul(ze, He)), qe);
  }
  if (!ae.eql(ae.sqr(oe.Gy), we(oe.Gx)))
    throw new Error("bad generator point: equation left != right");
  function _e(ze) {
    return typeof ze == "bigint" && _0n < ze && ze < oe.n;
  }
  function xe(ze) {
    if (!_e(ze))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function Oe(ze) {
    const { allowedPrivateKeyLengths: He, nByteLength: qe, wrapPrivateKey: Ye, n: ot } = oe;
    if (He && typeof ze != "bigint") {
      if (ze instanceof Uint8Array && (ze = bytesToHex$1(ze)), typeof ze != "string" || !He.includes(ze.length))
        throw new Error("Invalid key");
      ze = ze.padStart(qe * 2, "0");
    }
    let tt;
    try {
      tt = typeof ze == "bigint" ? ze : bytesToNumberBE(ensureBytes("private key", ze, qe));
    } catch {
      throw new Error(`private key must be ${qe} bytes, hex or bigint, not ${typeof ze}`);
    }
    return Ye && (tt = mod(tt, ot)), xe(tt), tt;
  }
  const $e = /* @__PURE__ */ new Map();
  function Re(ze) {
    if (!(ze instanceof Ne))
      throw new Error("ProjectivePoint expected");
  }
  class Ne {
    constructor(He, qe, Ye) {
      if (this.px = He, this.py = qe, this.pz = Ye, He == null || !ae.isValid(He))
        throw new Error("x required");
      if (qe == null || !ae.isValid(qe))
        throw new Error("y required");
      if (Ye == null || !ae.isValid(Ye))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(He) {
      const { x: qe, y: Ye } = He || {};
      if (!He || !ae.isValid(qe) || !ae.isValid(Ye))
        throw new Error("invalid affine point");
      if (He instanceof Ne)
        throw new Error("projective point not allowed");
      const ot = (tt) => ae.eql(tt, ae.ZERO);
      return ot(qe) && ot(Ye) ? Ne.ZERO : new Ne(qe, Ye, ae.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(He) {
      const qe = ae.invertBatch(He.map((Ye) => Ye.pz));
      return He.map((Ye, ot) => Ye.toAffine(qe[ot])).map(Ne.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(He) {
      const qe = Ne.fromAffine(ye(ensureBytes("pointHex", He)));
      return qe.assertValidity(), qe;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(He) {
      return Ne.BASE.multiply(Oe(He));
    }
    // "Private method", don't use it directly
    _setWindowSize(He) {
      this._WINDOW_SIZE = He, $e.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (oe.allowInfinityPoint && !ae.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: He, y: qe } = this.toAffine();
      if (!ae.isValid(He) || !ae.isValid(qe))
        throw new Error("bad point: x or y not FE");
      const Ye = ae.sqr(qe), ot = we(He);
      if (!ae.eql(Ye, ot))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: He } = this.toAffine();
      if (ae.isOdd)
        return !ae.isOdd(He);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(He) {
      Re(He);
      const { px: qe, py: Ye, pz: ot } = this, { px: tt, py: it, pz: ht } = He, gt = ae.eql(ae.mul(qe, ht), ae.mul(tt, ot)), At = ae.eql(ae.mul(Ye, ht), ae.mul(it, ot));
      return gt && At;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Ne(this.px, ae.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: He, b: qe } = oe, Ye = ae.mul(qe, _3n), { px: ot, py: tt, pz: it } = this;
      let ht = ae.ZERO, gt = ae.ZERO, At = ae.ZERO, St = ae.mul(ot, ot), Nt = ae.mul(tt, tt), Ft = ae.mul(it, it), Vt = ae.mul(ot, tt);
      return Vt = ae.add(Vt, Vt), At = ae.mul(ot, it), At = ae.add(At, At), ht = ae.mul(He, At), gt = ae.mul(Ye, Ft), gt = ae.add(ht, gt), ht = ae.sub(Nt, gt), gt = ae.add(Nt, gt), gt = ae.mul(ht, gt), ht = ae.mul(Vt, ht), At = ae.mul(Ye, At), Ft = ae.mul(He, Ft), Vt = ae.sub(St, Ft), Vt = ae.mul(He, Vt), Vt = ae.add(Vt, At), At = ae.add(St, St), St = ae.add(At, St), St = ae.add(St, Ft), St = ae.mul(St, Vt), gt = ae.add(gt, St), Ft = ae.mul(tt, it), Ft = ae.add(Ft, Ft), St = ae.mul(Ft, Vt), ht = ae.sub(ht, St), At = ae.mul(Ft, Nt), At = ae.add(At, At), At = ae.add(At, At), new Ne(ht, gt, At);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(He) {
      Re(He);
      const { px: qe, py: Ye, pz: ot } = this, { px: tt, py: it, pz: ht } = He;
      let gt = ae.ZERO, At = ae.ZERO, St = ae.ZERO;
      const Nt = oe.a, Ft = ae.mul(oe.b, _3n);
      let Vt = ae.mul(qe, tt), on = ae.mul(Ye, it), tn = ae.mul(ot, ht), _n = ae.add(qe, Ye), en = ae.add(tt, it);
      _n = ae.mul(_n, en), en = ae.add(Vt, on), _n = ae.sub(_n, en), en = ae.add(qe, ot);
      let dn = ae.add(tt, ht);
      return en = ae.mul(en, dn), dn = ae.add(Vt, tn), en = ae.sub(en, dn), dn = ae.add(Ye, ot), gt = ae.add(it, ht), dn = ae.mul(dn, gt), gt = ae.add(on, tn), dn = ae.sub(dn, gt), St = ae.mul(Nt, en), gt = ae.mul(Ft, tn), St = ae.add(gt, St), gt = ae.sub(on, St), St = ae.add(on, St), At = ae.mul(gt, St), on = ae.add(Vt, Vt), on = ae.add(on, Vt), tn = ae.mul(Nt, tn), en = ae.mul(Ft, en), on = ae.add(on, tn), tn = ae.sub(Vt, tn), tn = ae.mul(Nt, tn), en = ae.add(en, tn), Vt = ae.mul(on, en), At = ae.add(At, Vt), Vt = ae.mul(dn, en), gt = ae.mul(_n, gt), gt = ae.sub(gt, Vt), Vt = ae.mul(_n, on), St = ae.mul(dn, St), St = ae.add(St, Vt), new Ne(gt, At, St);
    }
    subtract(He) {
      return this.add(He.negate());
    }
    is0() {
      return this.equals(Ne.ZERO);
    }
    wNAF(He) {
      return Be.wNAFCached(this, $e, He, (qe) => {
        const Ye = ae.invertBatch(qe.map((ot) => ot.pz));
        return qe.map((ot, tt) => ot.toAffine(Ye[tt])).map(Ne.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(He) {
      const qe = Ne.ZERO;
      if (He === _0n)
        return qe;
      if (xe(He), He === _1n$1)
        return this;
      const { endo: Ye } = oe;
      if (!Ye)
        return Be.unsafeLadder(this, He);
      let { k1neg: ot, k1: tt, k2neg: it, k2: ht } = Ye.splitScalar(He), gt = qe, At = qe, St = this;
      for (; tt > _0n || ht > _0n; )
        tt & _1n$1 && (gt = gt.add(St)), ht & _1n$1 && (At = At.add(St)), St = St.double(), tt >>= _1n$1, ht >>= _1n$1;
      return ot && (gt = gt.negate()), it && (At = At.negate()), At = new Ne(ae.mul(At.px, Ye.beta), At.py, At.pz), gt.add(At);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(He) {
      xe(He);
      let qe = He, Ye, ot;
      const { endo: tt } = oe;
      if (tt) {
        const { k1neg: it, k1: ht, k2neg: gt, k2: At } = tt.splitScalar(qe);
        let { p: St, f: Nt } = this.wNAF(ht), { p: Ft, f: Vt } = this.wNAF(At);
        St = Be.constTimeNegate(it, St), Ft = Be.constTimeNegate(gt, Ft), Ft = new Ne(ae.mul(Ft.px, tt.beta), Ft.py, Ft.pz), Ye = St.add(Ft), ot = Nt.add(Vt);
      } else {
        const { p: it, f: ht } = this.wNAF(qe);
        Ye = it, ot = ht;
      }
      return Ne.normalizeZ([Ye, ot])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(He, qe, Ye) {
      const ot = Ne.BASE, tt = (ht, gt) => gt === _0n || gt === _1n$1 || !ht.equals(ot) ? ht.multiplyUnsafe(gt) : ht.multiply(gt), it = tt(this, qe).add(tt(He, Ye));
      return it.is0() ? void 0 : it;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(He) {
      const { px: qe, py: Ye, pz: ot } = this, tt = this.is0();
      He == null && (He = tt ? ae.ONE : ae.inv(ot));
      const it = ae.mul(qe, He), ht = ae.mul(Ye, He), gt = ae.mul(ot, He);
      if (tt)
        return { x: ae.ZERO, y: ae.ZERO };
      if (!ae.eql(gt, ae.ONE))
        throw new Error("invZ was invalid");
      return { x: it, y: ht };
    }
    isTorsionFree() {
      const { h: He, isTorsionFree: qe } = oe;
      if (He === _1n$1)
        return !0;
      if (qe)
        return qe(Ne, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: He, clearCofactor: qe } = oe;
      return He === _1n$1 ? this : qe ? qe(Ne, this) : this.multiplyUnsafe(oe.h);
    }
    toRawBytes(He = !0) {
      return this.assertValidity(), fe(Ne, this, He);
    }
    toHex(He = !0) {
      return bytesToHex$1(this.toRawBytes(He));
    }
  }
  Ne.BASE = new Ne(oe.Gx, oe.Gy, ae.ONE), Ne.ZERO = new Ne(ae.ZERO, ae.ONE, ae.ZERO);
  const je = oe.nBitLength, Be = wNAF(Ne, oe.endo ? Math.ceil(je / 2) : je);
  return {
    CURVE: oe,
    ProjectivePoint: Ne,
    normPrivateKeyToScalar: Oe,
    weierstrassEquation: we,
    isWithinCurveOrder: _e
  };
}
function validateOpts(ne) {
  const oe = validateBasic(ne);
  return validateObject(oe, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...oe });
}
function weierstrass(ne) {
  const oe = validateOpts(ne), { Fp: ae, n: fe } = oe, ye = ae.BYTES + 1, we = 2 * ae.BYTES + 1;
  function _e(en) {
    return _0n < en && en < ae.ORDER;
  }
  function xe(en) {
    return mod(en, fe);
  }
  function Oe(en) {
    return invert$1(en, fe);
  }
  const { ProjectivePoint: $e, normPrivateKeyToScalar: Re, weierstrassEquation: Ne, isWithinCurveOrder: je } = weierstrassPoints({
    ...oe,
    toBytes(en, dn, Ht) {
      const hn = dn.toAffine(), kn = ae.toBytes(hn.x), Dn = concatBytes;
      return Ht ? Dn(Uint8Array.from([dn.hasEvenY() ? 2 : 3]), kn) : Dn(Uint8Array.from([4]), kn, ae.toBytes(hn.y));
    },
    fromBytes(en) {
      const dn = en.length, Ht = en[0], hn = en.subarray(1);
      if (dn === ye && (Ht === 2 || Ht === 3)) {
        const kn = bytesToNumberBE(hn);
        if (!_e(kn))
          throw new Error("Point is not on curve");
        const Dn = Ne(kn);
        let yt = ae.sqrt(Dn);
        const jt = (yt & _1n$1) === _1n$1;
        return (Ht & 1) === 1 !== jt && (yt = ae.neg(yt)), { x: kn, y: yt };
      } else if (dn === we && Ht === 4) {
        const kn = ae.fromBytes(hn.subarray(0, ae.BYTES)), Dn = ae.fromBytes(hn.subarray(ae.BYTES, 2 * ae.BYTES));
        return { x: kn, y: Dn };
      } else
        throw new Error(`Point of length ${dn} was invalid. Expected ${ye} compressed bytes or ${we} uncompressed bytes`);
    }
  }), Be = (en) => bytesToHex$1(numberToBytesBE(en, oe.nByteLength));
  function ze(en) {
    const dn = fe >> _1n$1;
    return en > dn;
  }
  function He(en) {
    return ze(en) ? xe(-en) : en;
  }
  const qe = (en, dn, Ht) => bytesToNumberBE(en.slice(dn, Ht));
  class Ye {
    constructor(dn, Ht, hn) {
      this.r = dn, this.s = Ht, this.recovery = hn, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(dn) {
      const Ht = oe.nByteLength;
      return dn = ensureBytes("compactSignature", dn, Ht * 2), new Ye(qe(dn, 0, Ht), qe(dn, Ht, 2 * Ht));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(dn) {
      const { r: Ht, s: hn } = DER.toSig(ensureBytes("DER", dn));
      return new Ye(Ht, hn);
    }
    assertValidity() {
      if (!je(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!je(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(dn) {
      return new Ye(this.r, this.s, dn);
    }
    recoverPublicKey(dn) {
      const { r: Ht, s: hn, recovery: kn } = this, Dn = At(ensureBytes("msgHash", dn));
      if (kn == null || ![0, 1, 2, 3].includes(kn))
        throw new Error("recovery id invalid");
      const yt = kn === 2 || kn === 3 ? Ht + oe.n : Ht;
      if (yt >= ae.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const jt = kn & 1 ? "03" : "02", Mn = $e.fromHex(jt + Be(yt)), $n = Oe(yt), Zt = xe(-Dn * $n), vn = xe(hn * $n), Fn = $e.BASE.multiplyAndAddUnsafe(Mn, Zt, vn);
      if (!Fn)
        throw new Error("point at infinify");
      return Fn.assertValidity(), Fn;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return ze(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ye(this.r, xe(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return Be(this.r) + Be(this.s);
    }
  }
  const ot = {
    isValidPrivateKey(en) {
      try {
        return Re(en), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: Re,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const en = getMinHashLength(oe.n);
      return mapHashToField(oe.randomBytes(en), oe.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(en = 8, dn = $e.BASE) {
      return dn._setWindowSize(en), dn.multiply(BigInt(3)), dn;
    }
  };
  function tt(en, dn = !0) {
    return $e.fromPrivateKey(en).toRawBytes(dn);
  }
  function it(en) {
    const dn = en instanceof Uint8Array, Ht = typeof en == "string", hn = (dn || Ht) && en.length;
    return dn ? hn === ye || hn === we : Ht ? hn === 2 * ye || hn === 2 * we : en instanceof $e;
  }
  function ht(en, dn, Ht = !0) {
    if (it(en))
      throw new Error("first arg must be private key");
    if (!it(dn))
      throw new Error("second arg must be public key");
    return $e.fromHex(dn).multiply(Re(en)).toRawBytes(Ht);
  }
  const gt = oe.bits2int || function(en) {
    const dn = bytesToNumberBE(en), Ht = en.length * 8 - oe.nBitLength;
    return Ht > 0 ? dn >> BigInt(Ht) : dn;
  }, At = oe.bits2int_modN || function(en) {
    return xe(gt(en));
  }, St = bitMask(oe.nBitLength);
  function Nt(en) {
    if (typeof en != "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= en && en < St))
      throw new Error(`bigint expected < 2^${oe.nBitLength}`);
    return numberToBytesBE(en, oe.nByteLength);
  }
  function Ft(en, dn, Ht = Vt) {
    if (["recovered", "canonical"].some((Un) => Un in Ht))
      throw new Error("sign() legacy options not supported");
    const { hash: hn, randomBytes: kn } = oe;
    let { lowS: Dn, prehash: yt, extraEntropy: jt } = Ht;
    Dn == null && (Dn = !0), en = ensureBytes("msgHash", en), yt && (en = ensureBytes("prehashed msgHash", hn(en)));
    const Mn = At(en), $n = Re(dn), Zt = [Nt($n), Nt(Mn)];
    if (jt != null) {
      const Un = jt === !0 ? kn(ae.BYTES) : jt;
      Zt.push(ensureBytes("extraEntropy", Un));
    }
    const vn = concatBytes(...Zt), Fn = Mn;
    function Qn(Un) {
      const ar = gt(Un);
      if (!je(ar))
        return;
      const Zo = Oe(ar), ao = $e.BASE.multiply(ar).toAffine(), Yr = xe(ao.x);
      if (Yr === _0n)
        return;
      const so = xe(Zo * xe(Fn + Yr * $n));
      if (so === _0n)
        return;
      let Io = (ao.x === Yr ? 0 : 2) | Number(ao.y & _1n$1), Po = so;
      return Dn && ze(so) && (Po = He(so), Io ^= 1), new Ye(Yr, Po, Io);
    }
    return { seed: vn, k2sig: Qn };
  }
  const Vt = { lowS: oe.lowS, prehash: !1 }, on = { lowS: oe.lowS, prehash: !1 };
  function tn(en, dn, Ht = Vt) {
    const { seed: hn, k2sig: kn } = Ft(en, dn, Ht), Dn = oe;
    return createHmacDrbg(Dn.hash.outputLen, Dn.nByteLength, Dn.hmac)(hn, kn);
  }
  $e.BASE._setWindowSize(8);
  function _n(en, dn, Ht, hn = on) {
    var ao;
    const kn = en;
    if (dn = ensureBytes("msgHash", dn), Ht = ensureBytes("publicKey", Ht), "strict" in hn)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Dn, prehash: yt } = hn;
    let jt, Mn;
    try {
      if (typeof kn == "string" || kn instanceof Uint8Array)
        try {
          jt = Ye.fromDER(kn);
        } catch (Yr) {
          if (!(Yr instanceof DER.Err))
            throw Yr;
          jt = Ye.fromCompact(kn);
        }
      else if (typeof kn == "object" && typeof kn.r == "bigint" && typeof kn.s == "bigint") {
        const { r: Yr, s: so } = kn;
        jt = new Ye(Yr, so);
      } else
        throw new Error("PARSE");
      Mn = $e.fromHex(Ht);
    } catch (Yr) {
      if (Yr.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Dn && jt.hasHighS())
      return !1;
    yt && (dn = oe.hash(dn));
    const { r: $n, s: Zt } = jt, vn = At(dn), Fn = Oe(Zt), Qn = xe(vn * Fn), Un = xe($n * Fn), ar = (ao = $e.BASE.multiplyAndAddUnsafe(Mn, Qn, Un)) == null ? void 0 : ao.toAffine();
    return ar ? xe(ar.x) === $n : !1;
  }
  return {
    CURVE: oe,
    getPublicKey: tt,
    getSharedSecret: ht,
    sign: tn,
    verify: _n,
    ProjectivePoint: $e,
    Signature: Ye,
    utils: ot
  };
}
class HMAC extends Hash {
  constructor(oe, ae) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(oe);
    const fe = toBytes(ae);
    if (this.iHash = oe.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const ye = this.blockLen, we = new Uint8Array(ye);
    we.set(fe.length > ye ? oe.create().update(fe).digest() : fe);
    for (let _e = 0; _e < we.length; _e++)
      we[_e] ^= 54;
    this.iHash.update(we), this.oHash = oe.create();
    for (let _e = 0; _e < we.length; _e++)
      we[_e] ^= 106;
    this.oHash.update(we), we.fill(0);
  }
  update(oe) {
    return exists(this), this.iHash.update(oe), this;
  }
  digestInto(oe) {
    exists(this), bytes(oe, this.outputLen), this.finished = !0, this.iHash.digestInto(oe), this.oHash.update(oe), this.oHash.digestInto(oe), this.destroy();
  }
  digest() {
    const oe = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(oe), oe;
  }
  _cloneInto(oe) {
    oe || (oe = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: ae, iHash: fe, finished: ye, destroyed: we, blockLen: _e, outputLen: xe } = this;
    return oe = oe, oe.finished = ye, oe.destroyed = we, oe.blockLen = _e, oe.outputLen = xe, oe.oHash = ae._cloneInto(oe.oHash), oe.iHash = fe._cloneInto(oe.iHash), oe;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (ne, oe, ae) => new HMAC(ne, oe).update(ae).digest();
hmac.create = (ne, oe) => new HMAC(ne, oe);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(ne) {
  return {
    hash: ne,
    hmac: (oe, ...ae) => hmac(ne, oe, concatBytes$2(...ae)),
    randomBytes
  };
}
function createCurve(ne, oe) {
  const ae = (fe) => weierstrass({ ...ne, ...getHash(fe) });
  return Object.freeze({ ...ae(oe), create: ae });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (ne, oe) => (ne + oe / _2n) / oe;
function sqrtMod(ne) {
  const oe = secp256k1P, ae = BigInt(3), fe = BigInt(6), ye = BigInt(11), we = BigInt(22), _e = BigInt(23), xe = BigInt(44), Oe = BigInt(88), $e = ne * ne * ne % oe, Re = $e * $e * ne % oe, Ne = pow2(Re, ae, oe) * Re % oe, je = pow2(Ne, ae, oe) * Re % oe, Be = pow2(je, _2n, oe) * $e % oe, ze = pow2(Be, ye, oe) * Be % oe, He = pow2(ze, we, oe) * ze % oe, qe = pow2(He, xe, oe) * He % oe, Ye = pow2(qe, Oe, oe) * qe % oe, ot = pow2(Ye, xe, oe) * He % oe, tt = pow2(ot, ae, oe) * Re % oe, it = pow2(tt, _e, oe) * ze % oe, ht = pow2(it, fe, oe) * $e % oe, gt = pow2(ht, _2n, oe);
  if (!Fp.eql(Fp.sqr(gt), ne))
    throw new Error("Cannot find square root");
  return gt;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (ne) => {
      const oe = secp256k1N, ae = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), fe = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ye = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), we = ae, _e = BigInt("0x100000000000000000000000000000000"), xe = divNearest(we * ne, oe), Oe = divNearest(-fe * ne, oe);
      let $e = mod(ne - xe * ae - Oe * ye, oe), Re = mod(-xe * fe - Oe * we, oe);
      const Ne = $e > _e, je = Re > _e;
      if (Ne && ($e = oe - $e), je && (Re = oe - Re), $e > _e || Re > _e)
        throw new Error("splitScalar: Endomorphism failed, k=" + ne);
      return { k1neg: Ne, k1: $e, k2neg: je, k2: Re };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
function signatureToHex({ r: ne, s: oe, v: ae, yParity: fe }) {
  const ye = (() => {
    if (ae === 27n || fe === 0)
      return "1b";
    if (ae === 28n || fe === 1)
      return "1c";
    throw new Error("Invalid v value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(ne), hexToBigInt(oe)).toCompactHex()}${ye}`;
}
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Long(ne, oe, ae) {
  this.low = ne | 0, this.high = oe | 0, this.unsigned = !!ae;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: !0 });
function isLong(ne) {
  return (ne && ne.__isLong__) === !0;
}
function ctz32(ne) {
  var oe = Math.clz32(ne & -ne);
  return ne ? 31 - oe : oe;
}
Long.isLong = isLong;
var INT_CACHE = {}, UINT_CACHE = {};
function fromInt(ne, oe) {
  var ae, fe, ye;
  return oe ? (ne >>>= 0, (ye = 0 <= ne && ne < 256) && (fe = UINT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, 0, !0), ye && (UINT_CACHE[ne] = ae), ae)) : (ne |= 0, (ye = -128 <= ne && ne < 128) && (fe = INT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, ne < 0 ? -1 : 0, !1), ye && (INT_CACHE[ne] = ae), ae));
}
Long.fromInt = fromInt;
function fromNumber(ne, oe) {
  if (isNaN(ne))
    return oe ? UZERO : ZERO;
  if (oe) {
    if (ne < 0)
      return UZERO;
    if (ne >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (ne <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (ne + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  return ne < 0 ? fromNumber(-ne, oe).neg() : fromBits(ne % TWO_PWR_32_DBL | 0, ne / TWO_PWR_32_DBL | 0, oe);
}
Long.fromNumber = fromNumber;
function fromBits(ne, oe, ae) {
  return new Long(ne, oe, ae);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(ne, oe, ae) {
  if (ne.length === 0)
    throw Error("empty string");
  if (typeof oe == "number" ? (ae = oe, oe = !1) : oe = !!oe, ne === "NaN" || ne === "Infinity" || ne === "+Infinity" || ne === "-Infinity")
    return oe ? UZERO : ZERO;
  if (ae = ae || 10, ae < 2 || 36 < ae)
    throw RangeError("radix");
  var fe;
  if ((fe = ne.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (fe === 0)
    return fromString(ne.substring(1), oe, ae).neg();
  for (var ye = fromNumber(pow_dbl(ae, 8)), we = ZERO, _e = 0; _e < ne.length; _e += 8) {
    var xe = Math.min(8, ne.length - _e), Oe = parseInt(ne.substring(_e, _e + xe), ae);
    if (xe < 8) {
      var $e = fromNumber(pow_dbl(ae, xe));
      we = we.mul($e).add(fromNumber(Oe));
    } else
      we = we.mul(ye), we = we.add(fromNumber(Oe));
  }
  return we.unsigned = oe, we;
}
Long.fromString = fromString;
function fromValue(ne, oe) {
  return typeof ne == "number" ? fromNumber(ne, oe) : typeof ne == "string" ? fromString(ne, oe) : fromBits(ne.low, ne.high, typeof oe == "boolean" ? oe : ne.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536, TWO_PWR_24_DBL = 1 << 24, TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = fromInt(TWO_PWR_24_DBL), ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function(oe) {
  if (oe = oe || 10, oe < 2 || 36 < oe)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(MIN_VALUE)) {
      var ae = fromNumber(oe), fe = this.div(ae), ye = fe.mul(ae).sub(this);
      return fe.toString(oe) + ye.toInt().toString(oe);
    } else
      return "-" + this.neg().toString(oe);
  for (var we = fromNumber(pow_dbl(oe, 6), this.unsigned), _e = this, xe = ""; ; ) {
    var Oe = _e.div(we), $e = _e.sub(Oe.mul(we)).toInt() >>> 0, Re = $e.toString(oe);
    if (_e = Oe, _e.isZero())
      return Re + xe;
    for (; Re.length < 6; )
      Re = "0" + Re;
    xe = "" + Re + xe;
  }
};
LongPrototype.getHighBits = function() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (var oe = this.high != 0 ? this.high : this.low, ae = 31; ae > 0 && !(oe & 1 << ae); ae--)
    ;
  return this.high != 0 ? ae + 33 : ae + 1;
};
LongPrototype.isZero = function() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.unsigned !== oe.unsigned && this.high >>> 31 === 1 && oe.high >>> 31 === 1 ? !1 : this.high === oe.high && this.low === oe.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function(oe) {
  return !this.eq(
    /* validates */
    oe
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), this.eq(oe))
    return 0;
  var ae = this.isNegative(), fe = oe.isNegative();
  return ae && !fe ? -1 : !ae && fe ? 1 : this.unsigned ? oe.high >>> 0 > this.high >>> 0 || oe.high === this.high && oe.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(oe).isNegative() ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function() {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function(oe) {
  isLong(oe) || (oe = fromValue(oe));
  var ae = this.high >>> 16, fe = this.high & 65535, ye = this.low >>> 16, we = this.low & 65535, _e = oe.high >>> 16, xe = oe.high & 65535, Oe = oe.low >>> 16, $e = oe.low & 65535, Re = 0, Ne = 0, je = 0, Be = 0;
  return Be += we + $e, je += Be >>> 16, Be &= 65535, je += ye + Oe, Ne += je >>> 16, je &= 65535, Ne += fe + xe, Re += Ne >>> 16, Ne &= 65535, Re += ae + _e, Re &= 65535, fromBits(je << 16 | Be, Re << 16 | Ne, this.unsigned);
};
LongPrototype.subtract = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.add(oe.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function(oe) {
  if (this.isZero())
    return this;
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = wasm.mul(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (oe.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return oe.isOdd() ? MIN_VALUE : ZERO;
  if (oe.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return oe.isNegative() ? this.neg().mul(oe.neg()) : this.neg().mul(oe).neg();
  if (oe.isNegative())
    return this.mul(oe.neg()).neg();
  if (this.lt(TWO_PWR_24) && oe.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * oe.toNumber(), this.unsigned);
  var fe = this.high >>> 16, ye = this.high & 65535, we = this.low >>> 16, _e = this.low & 65535, xe = oe.high >>> 16, Oe = oe.high & 65535, $e = oe.low >>> 16, Re = oe.low & 65535, Ne = 0, je = 0, Be = 0, ze = 0;
  return ze += _e * Re, Be += ze >>> 16, ze &= 65535, Be += we * Re, je += Be >>> 16, Be &= 65535, Be += _e * $e, je += Be >>> 16, Be &= 65535, je += ye * Re, Ne += je >>> 16, je &= 65535, je += we * $e, Ne += je >>> 16, je &= 65535, je += _e * Oe, Ne += je >>> 16, je &= 65535, Ne += fe * Re + ye * $e + we * Oe + _e * xe, Ne &= 65535, fromBits(Be << 16 | ze, Ne << 16 | je, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), oe.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && oe.low === -1 && oe.high === -1)
      return this;
    var ae = (this.unsigned ? wasm.div_u : wasm.div_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var fe, ye, we;
  if (this.unsigned) {
    if (oe.unsigned || (oe = oe.toUnsigned()), oe.gt(this))
      return UZERO;
    if (oe.gt(this.shru(1)))
      return UONE;
    we = UZERO;
  } else {
    if (this.eq(MIN_VALUE)) {
      if (oe.eq(ONE) || oe.eq(NEG_ONE))
        return MIN_VALUE;
      if (oe.eq(MIN_VALUE))
        return ONE;
      var _e = this.shr(1);
      return fe = _e.div(oe).shl(1), fe.eq(ZERO) ? oe.isNegative() ? ONE : NEG_ONE : (ye = this.sub(oe.mul(fe)), we = fe.add(ye.div(oe)), we);
    } else if (oe.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return oe.isNegative() ? this.neg().div(oe.neg()) : this.neg().div(oe).neg();
    if (oe.isNegative())
      return this.div(oe.neg()).neg();
    we = ZERO;
  }
  for (ye = this; ye.gte(oe); ) {
    fe = Math.max(1, Math.floor(ye.toNumber() / oe.toNumber()));
    for (var xe = Math.ceil(Math.log(fe) / Math.LN2), Oe = xe <= 48 ? 1 : pow_dbl(2, xe - 48), $e = fromNumber(fe), Re = $e.mul(oe); Re.isNegative() || Re.gt(ye); )
      fe -= Oe, $e = fromNumber(fe, this.unsigned), Re = $e.mul(oe);
    $e.isZero() && ($e = ONE), we = we.add($e), ye = ye.sub(Re);
  }
  return we;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(oe).mul(oe));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low & oe.low, this.high & oe.high, this.unsigned);
};
LongPrototype.or = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low | oe.low, this.high | oe.high, this.unsigned);
};
LongPrototype.xor = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low ^ oe.low, this.high ^ oe.high, this.unsigned);
};
LongPrototype.shiftLeft = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low << oe, this.high << oe | this.low >>> 32 - oe, this.unsigned) : fromBits(0, this.low << oe - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >> oe, this.unsigned) : fromBits(this.high >> oe - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >>> oe, this.unsigned) : oe === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> oe - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.low << oe | this.high >>> ae, this.high << oe | this.low >>> ae, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.high << oe | this.low >>> ae, this.low << oe | this.high >>> ae, this.unsigned));
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.high << ae | this.low >>> oe, this.low << ae | this.high >>> oe, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.low << ae | this.high >>> oe, this.high << ae | this.low >>> oe, this.unsigned));
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function() {
  return this.unsigned ? fromBits(this.low, this.high, !1) : this;
};
LongPrototype.toUnsigned = function() {
  return this.unsigned ? this : fromBits(this.low, this.high, !0);
};
LongPrototype.toBytes = function(oe) {
  return oe ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function() {
  var oe = this.high, ae = this.low;
  return [
    ae & 255,
    ae >>> 8 & 255,
    ae >>> 16 & 255,
    ae >>> 24,
    oe & 255,
    oe >>> 8 & 255,
    oe >>> 16 & 255,
    oe >>> 24
  ];
};
LongPrototype.toBytesBE = function() {
  var oe = this.high, ae = this.low;
  return [
    oe >>> 24,
    oe >>> 16 & 255,
    oe >>> 8 & 255,
    oe & 255,
    ae >>> 24,
    ae >>> 16 & 255,
    ae >>> 8 & 255,
    ae & 255
  ];
};
Long.fromBytes = function(oe, ae, fe) {
  return fe ? Long.fromBytesLE(oe, ae) : Long.fromBytesBE(oe, ae);
};
Long.fromBytesLE = function(oe, ae) {
  return new Long(
    oe[0] | oe[1] << 8 | oe[2] << 16 | oe[3] << 24,
    oe[4] | oe[5] << 8 | oe[6] << 16 | oe[7] << 24,
    ae
  );
};
Long.fromBytesBE = function(oe, ae) {
  return new Long(
    oe[4] << 24 | oe[5] << 16 | oe[6] << 8 | oe[7],
    oe[0] << 24 | oe[1] << 16 | oe[2] << 8 | oe[3],
    ae
  );
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(ne) {
  return ne && ne.__esModule && Object.prototype.hasOwnProperty.call(ne, "default") ? ne.default : ne;
}
function getAugmentedNamespace(ne) {
  if (ne.__esModule)
    return ne;
  var oe = ne.default;
  if (typeof oe == "function") {
    var ae = function fe() {
      return this instanceof fe ? Reflect.construct(oe, arguments, this.constructor) : oe.apply(this, arguments);
    };
    ae.prototype = oe.prototype;
  } else
    ae = {};
  return Object.defineProperty(ae, "__esModule", { value: !0 }), Object.keys(ne).forEach(function(fe) {
    var ye = Object.getOwnPropertyDescriptor(ne, fe);
    Object.defineProperty(ae, fe, ye.get ? ye : {
      enumerable: !0,
      get: function() {
        return ne[fe];
      }
    });
  }), ae;
}
var indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(ne, oe) {
  for (var ae = new Array(arguments.length - 1), fe = 0, ye = 2, we = !0; ye < arguments.length; )
    ae[fe++] = arguments[ye++];
  return new Promise(function(xe, Oe) {
    ae[fe] = function(Re) {
      if (we)
        if (we = !1, Re)
          Oe(Re);
        else {
          for (var Ne = new Array(arguments.length - 1), je = 0; je < Ne.length; )
            Ne[je++] = arguments[je];
          xe.apply(null, Ne);
        }
    };
    try {
      ne.apply(oe || null, ae);
    } catch ($e) {
      we && (we = !1, Oe($e));
    }
  });
}
var base64$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(xe) {
    var Oe = xe.length;
    if (!Oe)
      return 0;
    for (var $e = 0; --Oe % 4 > 1 && xe.charAt(Oe) === "="; )
      ++$e;
    return Math.ceil(xe.length * 3) / 4 - $e;
  };
  for (var ae = new Array(64), fe = new Array(123), ye = 0; ye < 64; )
    fe[ae[ye] = ye < 26 ? ye + 65 : ye < 52 ? ye + 71 : ye < 62 ? ye - 4 : ye - 59 | 43] = ye++;
  oe.encode = function(xe, Oe, $e) {
    for (var Re = null, Ne = [], je = 0, Be = 0, ze; Oe < $e; ) {
      var He = xe[Oe++];
      switch (Be) {
        case 0:
          Ne[je++] = ae[He >> 2], ze = (He & 3) << 4, Be = 1;
          break;
        case 1:
          Ne[je++] = ae[ze | He >> 4], ze = (He & 15) << 2, Be = 2;
          break;
        case 2:
          Ne[je++] = ae[ze | He >> 6], Ne[je++] = ae[He & 63], Be = 0;
          break;
      }
      je > 8191 && ((Re || (Re = [])).push(String.fromCharCode.apply(String, Ne)), je = 0);
    }
    return Be && (Ne[je++] = ae[ze], Ne[je++] = 61, Be === 1 && (Ne[je++] = 61)), Re ? (je && Re.push(String.fromCharCode.apply(String, Ne.slice(0, je))), Re.join("")) : String.fromCharCode.apply(String, Ne.slice(0, je));
  };
  var we = "invalid encoding";
  oe.decode = function(xe, Oe, $e) {
    for (var Re = $e, Ne = 0, je, Be = 0; Be < xe.length; ) {
      var ze = xe.charCodeAt(Be++);
      if (ze === 61 && Ne > 1)
        break;
      if ((ze = fe[ze]) === void 0)
        throw Error(we);
      switch (Ne) {
        case 0:
          je = ze, Ne = 1;
          break;
        case 1:
          Oe[$e++] = je << 2 | (ze & 48) >> 4, je = ze, Ne = 2;
          break;
        case 2:
          Oe[$e++] = (je & 15) << 4 | (ze & 60) >> 2, je = ze, Ne = 3;
          break;
        case 3:
          Oe[$e++] = (je & 3) << 6 | ze, Ne = 0;
          break;
      }
    }
    if (Ne === 1)
      throw Error(we);
    return $e - Re;
  }, oe.test = function(xe) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(xe);
  };
})(base64$2);
var eventemitter = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function(oe, ae, fe) {
  return (this._listeners[oe] || (this._listeners[oe] = [])).push({
    fn: ae,
    ctx: fe || this
  }), this;
};
EventEmitter$1.prototype.off = function(oe, ae) {
  if (oe === void 0)
    this._listeners = {};
  else if (ae === void 0)
    this._listeners[oe] = [];
  else
    for (var fe = this._listeners[oe], ye = 0; ye < fe.length; )
      fe[ye].fn === ae ? fe.splice(ye, 1) : ++ye;
  return this;
};
EventEmitter$1.prototype.emit = function(oe) {
  var ae = this._listeners[oe];
  if (ae) {
    for (var fe = [], ye = 1; ye < arguments.length; )
      fe.push(arguments[ye++]);
    for (ye = 0; ye < ae.length; )
      ae[ye].fn.apply(ae[ye++].ctx, fe);
  }
  return this;
};
var float = factory(factory);
function factory(ne) {
  return typeof Float32Array < "u" ? function() {
    var oe = new Float32Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[3] === 128;
    function ye(Oe, $e, Re) {
      oe[0] = Oe, $e[Re] = ae[0], $e[Re + 1] = ae[1], $e[Re + 2] = ae[2], $e[Re + 3] = ae[3];
    }
    function we(Oe, $e, Re) {
      oe[0] = Oe, $e[Re] = ae[3], $e[Re + 1] = ae[2], $e[Re + 2] = ae[1], $e[Re + 3] = ae[0];
    }
    ne.writeFloatLE = fe ? ye : we, ne.writeFloatBE = fe ? we : ye;
    function _e(Oe, $e) {
      return ae[0] = Oe[$e], ae[1] = Oe[$e + 1], ae[2] = Oe[$e + 2], ae[3] = Oe[$e + 3], oe[0];
    }
    function xe(Oe, $e) {
      return ae[3] = Oe[$e], ae[2] = Oe[$e + 1], ae[1] = Oe[$e + 2], ae[0] = Oe[$e + 3], oe[0];
    }
    ne.readFloatLE = fe ? _e : xe, ne.readFloatBE = fe ? xe : _e;
  }() : function() {
    function oe(fe, ye, we, _e) {
      var xe = ye < 0 ? 1 : 0;
      if (xe && (ye = -ye), ye === 0)
        fe(1 / ye > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), we, _e);
      else if (isNaN(ye))
        fe(2143289344, we, _e);
      else if (ye > 34028234663852886e22)
        fe((xe << 31 | 2139095040) >>> 0, we, _e);
      else if (ye < 11754943508222875e-54)
        fe((xe << 31 | Math.round(ye / 1401298464324817e-60)) >>> 0, we, _e);
      else {
        var Oe = Math.floor(Math.log(ye) / Math.LN2), $e = Math.round(ye * Math.pow(2, -Oe) * 8388608) & 8388607;
        fe((xe << 31 | Oe + 127 << 23 | $e) >>> 0, we, _e);
      }
    }
    ne.writeFloatLE = oe.bind(null, writeUintLE), ne.writeFloatBE = oe.bind(null, writeUintBE);
    function ae(fe, ye, we) {
      var _e = fe(ye, we), xe = (_e >> 31) * 2 + 1, Oe = _e >>> 23 & 255, $e = _e & 8388607;
      return Oe === 255 ? $e ? NaN : xe * (1 / 0) : Oe === 0 ? xe * 1401298464324817e-60 * $e : xe * Math.pow(2, Oe - 150) * ($e + 8388608);
    }
    ne.readFloatLE = ae.bind(null, readUintLE), ne.readFloatBE = ae.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var oe = new Float64Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[7] === 128;
    function ye(Oe, $e, Re) {
      oe[0] = Oe, $e[Re] = ae[0], $e[Re + 1] = ae[1], $e[Re + 2] = ae[2], $e[Re + 3] = ae[3], $e[Re + 4] = ae[4], $e[Re + 5] = ae[5], $e[Re + 6] = ae[6], $e[Re + 7] = ae[7];
    }
    function we(Oe, $e, Re) {
      oe[0] = Oe, $e[Re] = ae[7], $e[Re + 1] = ae[6], $e[Re + 2] = ae[5], $e[Re + 3] = ae[4], $e[Re + 4] = ae[3], $e[Re + 5] = ae[2], $e[Re + 6] = ae[1], $e[Re + 7] = ae[0];
    }
    ne.writeDoubleLE = fe ? ye : we, ne.writeDoubleBE = fe ? we : ye;
    function _e(Oe, $e) {
      return ae[0] = Oe[$e], ae[1] = Oe[$e + 1], ae[2] = Oe[$e + 2], ae[3] = Oe[$e + 3], ae[4] = Oe[$e + 4], ae[5] = Oe[$e + 5], ae[6] = Oe[$e + 6], ae[7] = Oe[$e + 7], oe[0];
    }
    function xe(Oe, $e) {
      return ae[7] = Oe[$e], ae[6] = Oe[$e + 1], ae[5] = Oe[$e + 2], ae[4] = Oe[$e + 3], ae[3] = Oe[$e + 4], ae[2] = Oe[$e + 5], ae[1] = Oe[$e + 6], ae[0] = Oe[$e + 7], oe[0];
    }
    ne.readDoubleLE = fe ? _e : xe, ne.readDoubleBE = fe ? xe : _e;
  }() : function() {
    function oe(fe, ye, we, _e, xe, Oe) {
      var $e = _e < 0 ? 1 : 0;
      if ($e && (_e = -_e), _e === 0)
        fe(0, xe, Oe + ye), fe(1 / _e > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), xe, Oe + we);
      else if (isNaN(_e))
        fe(0, xe, Oe + ye), fe(2146959360, xe, Oe + we);
      else if (_e > 17976931348623157e292)
        fe(0, xe, Oe + ye), fe(($e << 31 | 2146435072) >>> 0, xe, Oe + we);
      else {
        var Re;
        if (_e < 22250738585072014e-324)
          Re = _e / 5e-324, fe(Re >>> 0, xe, Oe + ye), fe(($e << 31 | Re / 4294967296) >>> 0, xe, Oe + we);
        else {
          var Ne = Math.floor(Math.log(_e) / Math.LN2);
          Ne === 1024 && (Ne = 1023), Re = _e * Math.pow(2, -Ne), fe(Re * 4503599627370496 >>> 0, xe, Oe + ye), fe(($e << 31 | Ne + 1023 << 20 | Re * 1048576 & 1048575) >>> 0, xe, Oe + we);
        }
      }
    }
    ne.writeDoubleLE = oe.bind(null, writeUintLE, 0, 4), ne.writeDoubleBE = oe.bind(null, writeUintBE, 4, 0);
    function ae(fe, ye, we, _e, xe) {
      var Oe = fe(_e, xe + ye), $e = fe(_e, xe + we), Re = ($e >> 31) * 2 + 1, Ne = $e >>> 20 & 2047, je = 4294967296 * ($e & 1048575) + Oe;
      return Ne === 2047 ? je ? NaN : Re * (1 / 0) : Ne === 0 ? Re * 5e-324 * je : Re * Math.pow(2, Ne - 1075) * (je + 4503599627370496);
    }
    ne.readDoubleLE = ae.bind(null, readUintLE, 0, 4), ne.readDoubleBE = ae.bind(null, readUintBE, 4, 0);
  }(), ne;
}
function writeUintLE(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
function writeUintBE(ne, oe, ae) {
  oe[ae] = ne >>> 24, oe[ae + 1] = ne >>> 16 & 255, oe[ae + 2] = ne >>> 8 & 255, oe[ae + 3] = ne & 255;
}
function readUintLE(ne, oe) {
  return (ne[oe] | ne[oe + 1] << 8 | ne[oe + 2] << 16 | ne[oe + 3] << 24) >>> 0;
}
function readUintBE(ne, oe) {
  return (ne[oe] << 24 | ne[oe + 1] << 16 | ne[oe + 2] << 8 | ne[oe + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (ne) {
  }
  return null;
}
var utf8$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(fe) {
    for (var ye = 0, we = 0, _e = 0; _e < fe.length; ++_e)
      we = fe.charCodeAt(_e), we < 128 ? ye += 1 : we < 2048 ? ye += 2 : (we & 64512) === 55296 && (fe.charCodeAt(_e + 1) & 64512) === 56320 ? (++_e, ye += 4) : ye += 3;
    return ye;
  }, oe.read = function(fe, ye, we) {
    var _e = we - ye;
    if (_e < 1)
      return "";
    for (var xe = null, Oe = [], $e = 0, Re; ye < we; )
      Re = fe[ye++], Re < 128 ? Oe[$e++] = Re : Re > 191 && Re < 224 ? Oe[$e++] = (Re & 31) << 6 | fe[ye++] & 63 : Re > 239 && Re < 365 ? (Re = ((Re & 7) << 18 | (fe[ye++] & 63) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63) - 65536, Oe[$e++] = 55296 + (Re >> 10), Oe[$e++] = 56320 + (Re & 1023)) : Oe[$e++] = (Re & 15) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63, $e > 8191 && ((xe || (xe = [])).push(String.fromCharCode.apply(String, Oe)), $e = 0);
    return xe ? ($e && xe.push(String.fromCharCode.apply(String, Oe.slice(0, $e))), xe.join("")) : String.fromCharCode.apply(String, Oe.slice(0, $e));
  }, oe.write = function(fe, ye, we) {
    for (var _e = we, xe, Oe, $e = 0; $e < fe.length; ++$e)
      xe = fe.charCodeAt($e), xe < 128 ? ye[we++] = xe : xe < 2048 ? (ye[we++] = xe >> 6 | 192, ye[we++] = xe & 63 | 128) : (xe & 64512) === 55296 && ((Oe = fe.charCodeAt($e + 1)) & 64512) === 56320 ? (xe = 65536 + ((xe & 1023) << 10) + (Oe & 1023), ++$e, ye[we++] = xe >> 18 | 240, ye[we++] = xe >> 12 & 63 | 128, ye[we++] = xe >> 6 & 63 | 128, ye[we++] = xe & 63 | 128) : (ye[we++] = xe >> 12 | 224, ye[we++] = xe >> 6 & 63 | 128, ye[we++] = xe & 63 | 128);
    return we - _e;
  };
})(utf8$2);
var pool_1 = pool;
function pool(ne, oe, ae) {
  var fe = ae || 8192, ye = fe >>> 1, we = null, _e = fe;
  return function(Oe) {
    if (Oe < 1 || Oe > ye)
      return ne(Oe);
    _e + Oe > fe && (we = ne(fe), _e = 0);
    var $e = oe.call(we, _e, _e += Oe);
    return _e & 7 && (_e = (_e | 7) + 1), $e;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = oe;
  var ne = requireMinimal();
  function oe(we, _e) {
    this.lo = we >>> 0, this.hi = _e >>> 0;
  }
  var ae = oe.zero = new oe(0, 0);
  ae.toNumber = function() {
    return 0;
  }, ae.zzEncode = ae.zzDecode = function() {
    return this;
  }, ae.length = function() {
    return 1;
  };
  var fe = oe.zeroHash = "\0\0\0\0\0\0\0\0";
  oe.fromNumber = function(_e) {
    if (_e === 0)
      return ae;
    var xe = _e < 0;
    xe && (_e = -_e);
    var Oe = _e >>> 0, $e = (_e - Oe) / 4294967296 >>> 0;
    return xe && ($e = ~$e >>> 0, Oe = ~Oe >>> 0, ++Oe > 4294967295 && (Oe = 0, ++$e > 4294967295 && ($e = 0))), new oe(Oe, $e);
  }, oe.from = function(_e) {
    if (typeof _e == "number")
      return oe.fromNumber(_e);
    if (ne.isString(_e))
      if (ne.Long)
        _e = ne.Long.fromString(_e);
      else
        return oe.fromNumber(parseInt(_e, 10));
    return _e.low || _e.high ? new oe(_e.low >>> 0, _e.high >>> 0) : ae;
  }, oe.prototype.toNumber = function(_e) {
    if (!_e && this.hi >>> 31) {
      var xe = ~this.lo + 1 >>> 0, Oe = ~this.hi >>> 0;
      return xe || (Oe = Oe + 1 >>> 0), -(xe + Oe * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, oe.prototype.toLong = function(_e) {
    return ne.Long ? new ne.Long(this.lo | 0, this.hi | 0, !!_e) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_e };
  };
  var ye = String.prototype.charCodeAt;
  return oe.fromHash = function(_e) {
    return _e === fe ? ae : new oe(
      (ye.call(_e, 0) | ye.call(_e, 1) << 8 | ye.call(_e, 2) << 16 | ye.call(_e, 3) << 24) >>> 0,
      (ye.call(_e, 4) | ye.call(_e, 5) << 8 | ye.call(_e, 6) << 16 | ye.call(_e, 7) << 24) >>> 0
    );
  }, oe.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, oe.prototype.zzEncode = function() {
    var _e = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _e) >>> 0, this.lo = (this.lo << 1 ^ _e) >>> 0, this;
  }, oe.prototype.zzDecode = function() {
    var _e = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _e) >>> 0, this.hi = (this.hi >>> 1 ^ _e) >>> 0, this;
  }, oe.prototype.length = function() {
    var _e = this.lo, xe = (this.lo >>> 28 | this.hi << 4) >>> 0, Oe = this.hi >>> 24;
    return Oe === 0 ? xe === 0 ? _e < 16384 ? _e < 128 ? 1 : 2 : _e < 2097152 ? 3 : 4 : xe < 16384 ? xe < 128 ? 5 : 6 : xe < 2097152 ? 7 : 8 : Oe < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(ne) {
    var oe = ne;
    oe.asPromise = aspromise, oe.base64 = base64$2, oe.EventEmitter = eventemitter, oe.float = float, oe.inquire = inquire_1, oe.utf8 = utf8$2, oe.pool = pool_1, oe.LongBits = requireLongbits(), oe.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), oe.global = oe.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, oe.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), oe.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), oe.isInteger = Number.isInteger || /* istanbul ignore next */
    function(we) {
      return typeof we == "number" && isFinite(we) && Math.floor(we) === we;
    }, oe.isString = function(we) {
      return typeof we == "string" || we instanceof String;
    }, oe.isObject = function(we) {
      return we && typeof we == "object";
    }, oe.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    oe.isSet = function(we, _e) {
      var xe = we[_e];
      return xe != null && we.hasOwnProperty(_e) ? typeof xe != "object" || (Array.isArray(xe) ? xe.length : Object.keys(xe).length) > 0 : !1;
    }, oe.Buffer = function() {
      try {
        var ye = oe.inquire("buffer").Buffer;
        return ye.prototype.utf8Write ? ye : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), oe._Buffer_from = null, oe._Buffer_allocUnsafe = null, oe.newBuffer = function(we) {
      return typeof we == "number" ? oe.Buffer ? oe._Buffer_allocUnsafe(we) : new oe.Array(we) : oe.Buffer ? oe._Buffer_from(we) : typeof Uint8Array > "u" ? we : new Uint8Array(we);
    }, oe.Array = typeof Uint8Array < "u" ? Uint8Array : Array, oe.Long = /* istanbul ignore next */
    oe.global.dcodeIO && /* istanbul ignore next */
    oe.global.dcodeIO.Long || /* istanbul ignore next */
    oe.global.Long || oe.inquire("long"), oe.key2Re = /^true|false|0|1$/, oe.key32Re = /^-?(?:0|[1-9][0-9]*)$/, oe.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, oe.longToHash = function(we) {
      return we ? oe.LongBits.from(we).toHash() : oe.LongBits.zeroHash;
    }, oe.longFromHash = function(we, _e) {
      var xe = oe.LongBits.fromHash(we);
      return oe.Long ? oe.Long.fromBits(xe.lo, xe.hi, _e) : xe.toNumber(!!_e);
    };
    function ae(ye, we, _e) {
      for (var xe = Object.keys(we), Oe = 0; Oe < xe.length; ++Oe)
        (ye[xe[Oe]] === void 0 || !_e) && (ye[xe[Oe]] = we[xe[Oe]]);
      return ye;
    }
    oe.merge = ae, oe.lcFirst = function(we) {
      return we.charAt(0).toLowerCase() + we.substring(1);
    };
    function fe(ye) {
      function we(_e, xe) {
        if (!(this instanceof we))
          return new we(_e, xe);
        Object.defineProperty(this, "message", { get: function() {
          return _e;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, we) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), xe && ae(this, xe);
      }
      return we.prototype = Object.create(Error.prototype, {
        constructor: {
          value: we,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return ye;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), we;
    }
    oe.newError = fe, oe.ProtocolError = fe("ProtocolError"), oe.oneOfGetter = function(we) {
      for (var _e = {}, xe = 0; xe < we.length; ++xe)
        _e[we[xe]] = 1;
      return function() {
        for (var Oe = Object.keys(this), $e = Oe.length - 1; $e > -1; --$e)
          if (_e[Oe[$e]] === 1 && this[Oe[$e]] !== void 0 && this[Oe[$e]] !== null)
            return Oe[$e];
      };
    }, oe.oneOfSetter = function(we) {
      return function(_e) {
        for (var xe = 0; xe < we.length; ++xe)
          we[xe] !== _e && delete this[we[xe]];
      };
    }, oe.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, oe._configure = function() {
      var ye = oe.Buffer;
      if (!ye) {
        oe._Buffer_from = oe._Buffer_allocUnsafe = null;
        return;
      }
      oe._Buffer_from = ye.from !== Uint8Array.from && ye.from || /* istanbul ignore next */
      function(_e, xe) {
        return new ye(_e, xe);
      }, oe._Buffer_allocUnsafe = ye.allocUnsafe || /* istanbul ignore next */
      function(_e) {
        return new ye(_e);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1, util$5 = requireMinimal(), BufferWriter$1, LongBits$1 = util$5.LongBits, base64$1 = util$5.base64, utf8$1 = util$5.utf8;
function Op(ne, oe, ae) {
  this.fn = ne, this.len = oe, this.next = void 0, this.val = ae;
}
function noop$3() {
}
function State(ne) {
  this.head = ne.head, this.tail = ne.tail, this.len = ne.len, this.next = ne.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$3, 0, 0), this.tail = this.head, this.states = null;
}
var create$2 = function ne() {
  return util$5.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$2();
Writer$1.alloc = function ne(oe) {
  return new util$5.Array(oe);
};
util$5.Array !== Array && (Writer$1.alloc = util$5.pool(Writer$1.alloc, util$5.Array.prototype.subarray));
Writer$1.prototype._push = function ne(oe, ae, fe) {
  return this.tail = this.tail.next = new Op(oe, ae, fe), this.len += ae, this;
};
function writeByte(ne, oe, ae) {
  oe[ae] = ne & 255;
}
function writeVarint32(ne, oe, ae) {
  for (; ne > 127; )
    oe[ae++] = ne & 127 | 128, ne >>>= 7;
  oe[ae] = ne;
}
function VarintOp(ne, oe) {
  this.len = ne, this.next = void 0, this.val = oe;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function ne(oe) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (oe = oe >>> 0) < 128 ? 1 : oe < 16384 ? 2 : oe < 2097152 ? 3 : oe < 268435456 ? 4 : 5,
    oe
  )).len, this;
};
Writer$1.prototype.int32 = function ne(oe) {
  return oe < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(oe)) : this.uint32(oe);
};
Writer$1.prototype.sint32 = function ne(oe) {
  return this.uint32((oe << 1 ^ oe >> 31) >>> 0);
};
function writeVarint64(ne, oe, ae) {
  for (; ne.hi; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = (ne.lo >>> 7 | ne.hi << 25) >>> 0, ne.hi >>>= 7;
  for (; ne.lo > 127; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = ne.lo >>> 7;
  oe[ae++] = ne.lo;
}
Writer$1.prototype.uint64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function ne(oe) {
  var ae = LongBits$1.from(oe).zzEncode();
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.bool = function ne(oe) {
  return this._push(writeByte, 1, oe ? 1 : 0);
};
function writeFixed32(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
Writer$1.prototype.fixed32 = function ne(oe) {
  return this._push(writeFixed32, 4, oe >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeFixed32, 4, ae.lo)._push(writeFixed32, 4, ae.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function ne(oe) {
  return this._push(util$5.float.writeFloatLE, 4, oe);
};
Writer$1.prototype.double = function ne(oe) {
  return this._push(util$5.float.writeDoubleLE, 8, oe);
};
var writeBytes = util$5.Array.prototype.set ? function ne(oe, ae, fe) {
  ae.set(oe, fe);
} : function ne(oe, ae, fe) {
  for (var ye = 0; ye < oe.length; ++ye)
    ae[fe + ye] = oe[ye];
};
Writer$1.prototype.bytes = function ne(oe) {
  var ae = oe.length >>> 0;
  if (!ae)
    return this._push(writeByte, 1, 0);
  if (util$5.isString(oe)) {
    var fe = Writer$1.alloc(ae = base64$1.length(oe));
    base64$1.decode(oe, fe, 0), oe = fe;
  }
  return this.uint32(ae)._push(writeBytes, ae, oe);
};
Writer$1.prototype.string = function ne(oe) {
  var ae = utf8$1.length(oe);
  return ae ? this.uint32(ae)._push(utf8$1.write, ae, oe) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function ne() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function ne() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function ne() {
  var oe = this.head, ae = this.tail, fe = this.len;
  return this.reset().uint32(fe), fe && (this.tail.next = oe.next, this.tail = ae, this.len += fe), this;
};
Writer$1.prototype.finish = function ne() {
  for (var oe = this.head.next, ae = this.constructor.alloc(this.len), fe = 0; oe; )
    oe.fn(oe.val, ae, fe), fe += oe.len, oe = oe.next;
  return ae;
};
Writer$1._configure = function(ne) {
  BufferWriter$1 = ne, Writer$1.create = create$2(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$4 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$4._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$4.Buffer && util$4.Buffer.prototype instanceof Uint8Array && util$4.Buffer.prototype.set.name === "set" ? function(oe, ae, fe) {
    ae.set(oe, fe);
  } : function(oe, ae, fe) {
    if (oe.copy)
      oe.copy(ae, fe, 0, oe.length);
    else
      for (var ye = 0; ye < oe.length; )
        ae[fe++] = oe[ye++];
  };
};
BufferWriter.prototype.bytes = function ne(oe) {
  util$4.isString(oe) && (oe = util$4._Buffer_from(oe, "base64"));
  var ae = oe.length >>> 0;
  return this.uint32(ae), ae && this._push(BufferWriter.writeBytesBuffer, ae, oe), this;
};
function writeStringBuffer(ne, oe, ae) {
  ne.length < 40 ? util$4.utf8.write(ne, oe, ae) : oe.utf8Write ? oe.utf8Write(ne, ae) : oe.write(ne, ae);
}
BufferWriter.prototype.string = function ne(oe) {
  var ae = util$4.Buffer.byteLength(oe);
  return this.uint32(ae), ae && this._push(writeStringBuffer, ae, oe), this;
};
BufferWriter._configure();
var reader = Reader$1, util$3 = requireMinimal(), BufferReader$1, LongBits = util$3.LongBits, utf8 = util$3.utf8;
function indexOutOfRange(ne, oe) {
  return RangeError("index out of range: " + ne.pos + " + " + (oe || 1) + " > " + ne.len);
}
function Reader$1(ne) {
  this.buf = ne, this.pos = 0, this.len = ne.length;
}
var create_array = typeof Uint8Array < "u" ? function ne(oe) {
  if (oe instanceof Uint8Array || Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
} : function ne(oe) {
  if (Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
}, create$1 = function ne() {
  return util$3.Buffer ? function(ae) {
    return (Reader$1.create = function(ye) {
      return util$3.Buffer.isBuffer(ye) ? new BufferReader$1(ye) : create_array(ye);
    })(ae);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$3.Array.prototype.subarray || /* istanbul ignore next */
util$3.Array.prototype.slice;
Reader$1.prototype.uint32 = function ne() {
  var oe = 4294967295;
  return function() {
    if (oe = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (oe = (oe | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return oe;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return oe;
  };
}();
Reader$1.prototype.int32 = function ne() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function ne() {
  var oe = this.uint32();
  return oe >>> 1 ^ -(oe & 1) | 0;
};
function readLongVarint() {
  var ne = new LongBits(0, 0), oe = 0;
  if (this.len - this.pos > 4) {
    for (; oe < 4; ++oe)
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << 28) >>> 0, ne.hi = (ne.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return ne;
    oe = 0;
  } else {
    for (; oe < 3; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
    return ne.lo = (ne.lo | (this.buf[this.pos++] & 127) << oe * 7) >>> 0, ne;
  }
  if (this.len - this.pos > 4) {
    for (; oe < 5; ++oe)
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
  } else
    for (; oe < 5; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function ne() {
  return this.uint32() !== 0;
};
function readFixed32_end(ne, oe) {
  return (ne[oe - 4] | ne[oe - 3] << 8 | ne[oe - 2] << 16 | ne[oe - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, oe;
};
Reader$1.prototype.double = function ne() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, oe;
};
Reader$1.prototype.bytes = function ne() {
  var oe = this.uint32(), ae = this.pos, fe = this.pos + oe;
  if (fe > this.len)
    throw indexOutOfRange(this, oe);
  if (this.pos += oe, Array.isArray(this.buf))
    return this.buf.slice(ae, fe);
  if (ae === fe) {
    var ye = util$3.Buffer;
    return ye ? ye.alloc(0) : new this.buf.constructor(0);
  }
  return this._slice.call(this.buf, ae, fe);
};
Reader$1.prototype.string = function ne() {
  var oe = this.bytes();
  return utf8.read(oe, 0, oe.length);
};
Reader$1.prototype.skip = function ne(oe) {
  if (typeof oe == "number") {
    if (this.pos + oe > this.len)
      throw indexOutOfRange(this, oe);
    this.pos += oe;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(ne) {
  switch (ne) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (ne = this.uint32() & 7) !== 4; )
        this.skipType(ne);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + ne + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(ne) {
  BufferReader$1 = ne, Reader$1.create = create$1(), BufferReader$1._configure();
  var oe = util$3.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$3.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[oe](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[oe](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[oe](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[oe](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[oe](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$2 = requireMinimal();
function BufferReader(ne) {
  Reader.call(this, ne);
}
BufferReader._configure = function() {
  util$2.Buffer && (BufferReader.prototype._slice = util$2.Buffer.prototype.slice);
};
BufferReader.prototype.string = function ne() {
  var oe = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + oe, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + oe, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$1 = requireMinimal();
(Service.prototype = Object.create(util$1.EventEmitter.prototype)).constructor = Service;
function Service(ne, oe, ae) {
  if (typeof ne != "function")
    throw TypeError("rpcImpl must be a function");
  util$1.EventEmitter.call(this), this.rpcImpl = ne, this.requestDelimited = !!oe, this.responseDelimited = !!ae;
}
Service.prototype.rpcCall = function ne(oe, ae, fe, ye, we) {
  if (!ye)
    throw TypeError("request must be specified");
  var _e = this;
  if (!we)
    return util$1.asPromise(ne, _e, oe, ae, fe, ye);
  if (!_e.rpcImpl) {
    setTimeout(function() {
      we(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _e.rpcImpl(
      oe,
      ae[_e.requestDelimited ? "encodeDelimited" : "encode"](ye).finish(),
      function(Oe, $e) {
        if (Oe)
          return _e.emit("error", Oe, oe), we(Oe);
        if ($e === null) {
          _e.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!($e instanceof fe))
          try {
            $e = fe[_e.responseDelimited ? "decodeDelimited" : "decode"]($e);
          } catch (Re) {
            return _e.emit("error", Re, oe), we(Re);
          }
        return _e.emit("data", $e, oe), we(null, $e);
      }
    );
  } catch (xe) {
    _e.emit("error", xe, oe), setTimeout(function() {
      we(xe);
    }, 0);
    return;
  }
};
Service.prototype.end = function ne(oe) {
  return this.rpcImpl && (oe || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(ne) {
  var oe = ne;
  oe.Service = service;
})(rpc);
var roots = {};
(function(ne) {
  var oe = ne;
  oe.build = "minimal", oe.Writer = writer, oe.BufferWriter = writer_buffer, oe.Reader = reader, oe.BufferReader = reader_buffer, oe.util = requireMinimal(), oe.rpc = rpc, oe.roots = roots, oe.configure = ae;
  function ae() {
    oe.util._configure(), oe.Writer._configure(oe.BufferWriter), oe.Reader._configure(oe.BufferReader);
  }
  ae();
})(indexMinimal);
var minimal = indexMinimal;
const _m0 = /* @__PURE__ */ getDefaultExportFromCjs(minimal);
var lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function ne(oe) {
  const ae = /* @__PURE__ */ new Map(), fe = {
    set(ye, we) {
      if (ye = normalizeKey(ye), Array.isArray(we))
        if (we.length === 0)
          ae.delete(ye);
        else {
          for (const _e of we)
            validate(ye, _e);
          ae.set(ye, ye.endsWith("-bin") ? we : [we.join(", ")]);
        }
      else
        validate(ye, we), ae.set(ye, [we]);
      return fe;
    },
    append(ye, we) {
      ye = normalizeKey(ye), validate(ye, we);
      let _e = ae.get(ye);
      return _e == null && (_e = [], ae.set(ye, _e)), _e.push(we), ye.endsWith("-bin") || ae.set(ye, [_e.join(", ")]), fe;
    },
    delete(ye) {
      ye = normalizeKey(ye), ae.delete(ye);
    },
    get(ye) {
      var we;
      return ye = normalizeKey(ye), (we = ae.get(ye)) === null || we === void 0 ? void 0 : we[0];
    },
    getAll(ye) {
      var we;
      return ye = normalizeKey(ye), (we = ae.get(ye)) !== null && we !== void 0 ? we : [];
    },
    has(ye) {
      return ye = normalizeKey(ye), ae.has(ye);
    },
    [Symbol.iterator]() {
      return ae[Symbol.iterator]();
    }
  };
  if (oe != null) {
    const ye = isIterable$1(oe) ? oe : Object.entries(oe);
    for (const [we, _e] of ye)
      fe.set(we, _e);
  }
  return fe;
};
function normalizeKey(ne) {
  return ne.toLowerCase();
}
function validate(ne, oe) {
  if (!/^[0-9a-z_.-]+$/.test(ne))
    throw new Error(`Metadata key '${ne}' contains illegal characters`);
  if (ne.endsWith("-bin")) {
    if (!(oe instanceof Uint8Array))
      throw new Error(`Metadata key '${ne}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof oe != "string")
      throw new Error(`Metadata key '${ne}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(oe))
      throw new Error(`Metadata value '${oe}' of key '${ne}' contains illegal characters`);
  }
}
function isIterable$1(ne) {
  return Symbol.iterator in ne;
}
var Status = {};
(function(ne) {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = void 0, function(oe) {
    oe[oe.OK = 0] = "OK", oe[oe.CANCELLED = 1] = "CANCELLED", oe[oe.UNKNOWN = 2] = "UNKNOWN", oe[oe.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", oe[oe.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", oe[oe.NOT_FOUND = 5] = "NOT_FOUND", oe[oe.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", oe[oe.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", oe[oe.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", oe[oe.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", oe[oe.ABORTED = 10] = "ABORTED", oe[oe.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", oe[oe.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", oe[oe.INTERNAL = 13] = "INTERNAL", oe[oe.UNAVAILABLE = 14] = "UNAVAILABLE", oe[oe.DATA_LOSS = 15] = "DATA_LOSS", oe[oe.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(ne.Status || (ne.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(ne, oe) {
  return (ae, fe) => oe(Object.assign(Object.assign({}, ae), { next: (ye, we) => ne(Object.assign(Object.assign({}, ae), { request: ye }), we) }), fe);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function ne(oe, ae) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(oe, ae) : oe.__proto__ = ae;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function ne(oe) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(oe) : oe.__proto__ || oe.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function ne(oe, ae, fe) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(oe, ae, fe);
    } catch {
      ie8ObjectDefinePropertyBug = !0, ne(oe, ae, fe);
    }
  else
    oe[ae] = fe.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty = function ne(oe, ae) {
  return objectHasOwnPropertyIsDefined ? oe.hasOwnProperty(oe, ae) : oe[ae] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty;
var objectCreate = function ne(oe, ae) {
  if (objectCreateIsDefined)
    return Object.create(oe, ae);
  var fe = function() {
  };
  fe.prototype = oe;
  var ye = new fe();
  if (typeof ae > "u")
    return ye;
  if (typeof ae == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof ae == "object")
    for (var we in ae)
      hasOwnProperty(ae, we) && (ye[we] = ae[we].value);
  return ye;
};
helpers.objectCreate = objectCreate;
(function(ne) {
  ne.__esModule = void 0, ne.__esModule = !0;
  var oe = helpers, ae = oe.setPrototypeOf, fe = oe.getPrototypeOf, ye = oe.defineProperty, we = oe.objectCreate, _e = new Error().toString() === "[object Error]", xe = "";
  function Oe($e) {
    var Re = this.constructor, Ne = Re.name || function() {
      var qe = Re.toString().match(/^function\s*([^\s(]+)/);
      return qe === null ? xe || "Error" : qe[1];
    }(), je = Ne === "Error", Be = je ? xe : Ne, ze = Error.apply(this, arguments);
    if (ae(ze, fe(this)), !(ze instanceof Re) || !(ze instanceof Oe)) {
      var ze = this;
      Error.apply(this, arguments), ye(ze, "message", {
        configurable: !0,
        enumerable: !1,
        value: $e,
        writable: !0
      });
    }
    if (ye(ze, "name", {
      configurable: !0,
      enumerable: !1,
      value: Be,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      ze,
      je ? Oe : Re
    ), ze.stack === void 0) {
      var He = new Error($e);
      He.name = ze.name, ze.stack = He.stack;
    }
    return _e && ye(ze, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), ze;
  }
  xe = Oe.name || "ExtendableError", Oe.prototype = we(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), ne.ExtendableError = Oe, ne.default = ne.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(oe, ae, fe) {
    super(`${oe} ${Status_1$1.Status[ae]}: ${fe}`), this.path = oe, this.code = ae, this.details = fe, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ClientError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ClientError || oe["@@nice-grpc:ClientError"] === !0 || oe.name === "ClientError" && oe["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(ne, oe) {
  return (ae, fe) => ne(Object.assign(Object.assign({}, ae), { next: (ye, we) => oe(Object.assign(Object.assign({}, ae), { request: ye }), we) }), fe);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(oe, ae) {
    super(`${Status_1.Status[oe]}: ${ae}`), this.code = oe, this.details = ae, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ServerError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ServerError || oe["@@nice-grpc:ServerError"] === !0 || oe.name === "ServerError" && oe["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ye, we, _e) {
    _e === void 0 && (_e = we);
    var xe = Object.getOwnPropertyDescriptor(ye, we);
    (!xe || ("get" in xe ? !ye.__esModule : xe.writable || xe.configurable)) && (xe = { enumerable: !0, get: function() {
      return ye[we];
    } }), Object.defineProperty(fe, _e, xe);
  } : function(fe, ye, we, _e) {
    _e === void 0 && (_e = we), fe[_e] = ye[we];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ye) {
    for (var we in fe)
      we !== "default" && !Object.prototype.hasOwnProperty.call(ye, we) && oe(ye, fe, we);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ae(Metadata, ne), ae(Status, ne), ae(MethodDescriptor, ne), ae(CallOptions, ne), ae(ClientMiddleware, ne), ae(composeClientMiddleware$1, ne), ae(ClientError$1, ne), ae(CallContext, ne), ae(ServerMiddleware, ne), ae(composeServerMiddleware$1, ne), ae(ServerError$1, ne);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne)) {
    if (ae === "serviceName")
      continue;
    const ye = fe;
    oe[uncapitalize(ae)] = {
      path: `/${ne.serviceName}/${ae}`,
      requestStream: ye.requestStream,
      responseStream: ye.responseStream,
      requestDeserialize: ye.requestType.deserializeBinary,
      requestSerialize: (we) => we.serializeBinary(),
      responseDeserialize: ye.responseType.deserializeBinary,
      responseSerialize: (we) => we.serializeBinary(),
      options: {}
    };
  }
  return oe;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(ne) {
  return "prototype" in ne;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(ne) {
  return ne.length === 0 ? ne : ne[0].toLowerCase() + ne.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne.methods)) {
    const ye = fe.requestType.encode, we = fe.requestType.fromPartial, _e = fe.responseType.encode, xe = fe.responseType.fromPartial;
    oe[ae] = {
      path: `/${ne.fullName}/${fe.name}`,
      requestStream: fe.requestStream,
      responseStream: fe.responseStream,
      requestDeserialize: fe.requestType.decode,
      requestSerialize: we != null ? (Oe) => ye(we(Oe)).finish() : (Oe) => ye(Oe).finish(),
      responseDeserialize: fe.responseType.decode,
      responseSerialize: xe != null ? (Oe) => _e(xe(Oe)).finish() : (Oe) => _e(Oe).finish(),
      options: fe.options
    };
  }
  return oe;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(ne) {
  return "name" in ne && "fullName" in ne && "methods" in ne;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(ne) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(ne) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(ne) : (0, ts_proto_1.isTsProtoServiceDefinition)(ne) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(ne) : ne;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(ne) {
  const [, oe, ae] = ne.path.split("/");
  return {
    service: {
      serviceName: oe
    },
    methodName: ae,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.requestDeserialize(fe);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.responseDeserialize(fe);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(ne, oe) {
  return { address: ne, transport: oe };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(commonjsGlobal, function() {
    return ae = { 418: function(ye, we) {
      (function(_e, xe) {
        for (var Oe in xe)
          _e[Oe] = xe[Oe];
      })(we, function(_e) {
        var xe = {};
        function Oe($e) {
          if (xe[$e])
            return xe[$e].exports;
          var Re = xe[$e] = { i: $e, l: !1, exports: {} };
          return _e[$e].call(Re.exports, Re, Re.exports, Oe), Re.l = !0, Re.exports;
        }
        return Oe.m = _e, Oe.c = xe, Oe.i = function($e) {
          return $e;
        }, Oe.d = function($e, Re, Ne) {
          Oe.o($e, Re) || Object.defineProperty($e, Re, { configurable: !1, enumerable: !0, get: Ne });
        }, Oe.n = function($e) {
          var Re = $e && $e.__esModule ? function() {
            return $e.default;
          } : function() {
            return $e;
          };
          return Oe.d(Re, "a", Re), Re;
        }, Oe.o = function($e, Re) {
          return Object.prototype.hasOwnProperty.call($e, Re);
        }, Oe.p = "", Oe(Oe.s = 1);
      }([function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(3), Re = function() {
          function Ne(je, Be) {
            je === void 0 && (je = {}), Be === void 0 && (Be = { splitValues: !1 });
            var ze, He = this;
            this.headersMap = {}, je && (typeof Headers < "u" && je instanceof Headers ? $e.getHeaderKeys(je).forEach(function(qe) {
              $e.getHeaderValues(je, qe).forEach(function(Ye) {
                Be.splitValues ? He.append(qe, $e.splitHeaderValue(Ye)) : He.append(qe, Ye);
              });
            }) : typeof (ze = je) == "object" && typeof ze.headersMap == "object" && typeof ze.forEach == "function" ? je.forEach(function(qe, Ye) {
              He.append(qe, Ye);
            }) : typeof Map < "u" && je instanceof Map ? je.forEach(function(qe, Ye) {
              He.append(Ye, qe);
            }) : typeof je == "string" ? this.appendFromString(je) : typeof je == "object" && Object.getOwnPropertyNames(je).forEach(function(qe) {
              var Ye = je[qe];
              Array.isArray(Ye) ? Ye.forEach(function(ot) {
                He.append(qe, ot);
              }) : He.append(qe, Ye);
            }));
          }
          return Ne.prototype.appendFromString = function(je) {
            for (var Be = je.split(`\r
`), ze = 0; ze < Be.length; ze++) {
              var He = Be[ze], qe = He.indexOf(":");
              if (qe > 0) {
                var Ye = He.substring(0, qe).trim(), ot = He.substring(qe + 1).trim();
                this.append(Ye, ot);
              }
            }
          }, Ne.prototype.delete = function(je, Be) {
            var ze = $e.normalizeName(je);
            if (Be === void 0)
              delete this.headersMap[ze];
            else {
              var He = this.headersMap[ze];
              if (He) {
                var qe = He.indexOf(Be);
                qe >= 0 && He.splice(qe, 1), He.length === 0 && delete this.headersMap[ze];
              }
            }
          }, Ne.prototype.append = function(je, Be) {
            var ze = this, He = $e.normalizeName(je);
            Array.isArray(this.headersMap[He]) || (this.headersMap[He] = []), Array.isArray(Be) ? Be.forEach(function(qe) {
              ze.headersMap[He].push($e.normalizeValue(qe));
            }) : this.headersMap[He].push($e.normalizeValue(Be));
          }, Ne.prototype.set = function(je, Be) {
            var ze = $e.normalizeName(je);
            if (Array.isArray(Be)) {
              var He = [];
              Be.forEach(function(qe) {
                He.push($e.normalizeValue(qe));
              }), this.headersMap[ze] = He;
            } else
              this.headersMap[ze] = [$e.normalizeValue(Be)];
          }, Ne.prototype.has = function(je, Be) {
            var ze = this.headersMap[$e.normalizeName(je)];
            if (!Array.isArray(ze))
              return !1;
            if (Be !== void 0) {
              var He = $e.normalizeValue(Be);
              return ze.indexOf(He) >= 0;
            }
            return !0;
          }, Ne.prototype.get = function(je) {
            var Be = this.headersMap[$e.normalizeName(je)];
            return Be !== void 0 ? Be.concat() : [];
          }, Ne.prototype.forEach = function(je) {
            var Be = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(ze) {
              je(ze, Be.headersMap[ze]);
            }, this);
          }, Ne.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var je = new Headers();
              return this.forEach(function(Be, ze) {
                ze.forEach(function(He) {
                  je.append(Be, He);
                });
              }), je;
            }
            throw new Error("Headers class is not defined");
          }, Ne;
        }();
        xe.BrowserHeaders = Re;
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(0);
        xe.BrowserHeaders = $e.BrowserHeaders;
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 }), xe.iterateHeaders = function($e, Re) {
          for (var Ne = $e[Symbol.iterator](), je = Ne.next(); !je.done; )
            Re(je.value[0]), je = Ne.next();
        }, xe.iterateHeadersKeys = function($e, Re) {
          for (var Ne = $e.keys(), je = Ne.next(); !je.done; )
            Re(je.value), je = Ne.next();
        };
      }, function(_e, xe, Oe) {
        Object.defineProperty(xe, "__esModule", { value: !0 });
        var $e = Oe(2);
        xe.normalizeName = function(Re) {
          if (typeof Re != "string" && (Re = String(Re)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(Re))
            throw new TypeError("Invalid character in header field name");
          return Re.toLowerCase();
        }, xe.normalizeValue = function(Re) {
          return typeof Re != "string" && (Re = String(Re)), Re;
        }, xe.getHeaderValues = function(Re, Ne) {
          var je = Re;
          if (je instanceof Headers && je.getAll)
            return je.getAll(Ne);
          var Be = je.get(Ne);
          return Be && typeof Be == "string" ? [Be] : Be;
        }, xe.getHeaderKeys = function(Re) {
          var Ne = Re, je = {}, Be = [];
          return Ne.keys ? $e.iterateHeadersKeys(Ne, function(ze) {
            je[ze] || (je[ze] = !0, Be.push(ze));
          }) : Ne.forEach ? Ne.forEach(function(ze, He) {
            je[He] || (je[He] = !0, Be.push(He));
          }) : $e.iterateHeaders(Ne, function(ze) {
            var He = ze[0];
            je[He] || (je[He] = !0, Be.push(He));
          }), Be;
        }, xe.splitHeaderValue = function(Re) {
          var Ne = [];
          return Re.split(", ").forEach(function(je) {
            je.split(",").forEach(function(Be) {
              Ne.push(Be);
            });
          }), Ne;
        };
      }]));
    }, 617: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.ChunkParser = we.ChunkType = we.encodeASCII = we.decodeASCII = void 0;
      var xe, Oe = _e(65);
      function $e(qe) {
        return (Ye = qe) === 9 || Ye === 10 || Ye === 13 || qe >= 32 && qe <= 126;
        var Ye;
      }
      function Re(qe) {
        for (var Ye = 0; Ye !== qe.length; ++Ye)
          if (!$e(qe[Ye]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(qe));
      }
      function Ne(qe) {
        return (128 & qe.getUint8(0)) == 128;
      }
      function je(qe) {
        return qe.getUint32(1, !1);
      }
      function Be(qe, Ye, ot) {
        return qe.byteLength - Ye >= ot;
      }
      function ze(qe, Ye, ot) {
        if (qe.slice)
          return qe.slice(Ye, ot);
        var tt = qe.length;
        ot !== void 0 && (tt = ot);
        for (var it = new Uint8Array(tt - Ye), ht = 0, gt = Ye; gt < tt; gt++)
          it[ht++] = qe[gt];
        return it;
      }
      we.decodeASCII = Re, we.encodeASCII = function(qe) {
        for (var Ye = new Uint8Array(qe.length), ot = 0; ot !== qe.length; ++ot) {
          var tt = qe.charCodeAt(ot);
          if (!$e(tt))
            throw new Error("Metadata contains invalid ASCII");
          Ye[ot] = tt;
        }
        return Ye;
      }, function(qe) {
        qe[qe.MESSAGE = 1] = "MESSAGE", qe[qe.TRAILERS = 2] = "TRAILERS";
      }(xe = we.ChunkType || (we.ChunkType = {}));
      var He = function() {
        function qe() {
          this.buffer = null, this.position = 0;
        }
        return qe.prototype.parse = function(Ye, ot) {
          if (Ye.length === 0 && ot)
            return [];
          var tt, it = [];
          if (this.buffer == null)
            this.buffer = Ye, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = Ye, this.position = 0;
          else {
            var ht = this.buffer.byteLength - this.position, gt = new Uint8Array(ht + Ye.byteLength), At = ze(this.buffer, this.position);
            gt.set(At, 0);
            var St = new Uint8Array(Ye);
            gt.set(St, ht), this.buffer = gt, this.position = 0;
          }
          for (; ; ) {
            if (!Be(this.buffer, this.position, 5))
              return it;
            var Nt = ze(this.buffer, this.position, this.position + 5), Ft = new DataView(Nt.buffer, Nt.byteOffset, Nt.byteLength), Vt = je(Ft);
            if (!Be(this.buffer, this.position, 5 + Vt))
              return it;
            var on = ze(this.buffer, this.position + 5, this.position + 5 + Vt);
            if (this.position += 5 + Vt, Ne(Ft))
              return it.push({ chunkType: xe.TRAILERS, trailers: (tt = on, new Oe.Metadata(Re(tt))) }), it;
            it.push({ chunkType: xe.MESSAGE, data: on });
          }
        }, qe;
      }();
      we.ChunkParser = He;
    }, 8: function(ye, we) {
      var _e;
      Object.defineProperty(we, "__esModule", { value: !0 }), we.httpStatusToCode = we.Code = void 0, function(xe) {
        xe[xe.OK = 0] = "OK", xe[xe.Canceled = 1] = "Canceled", xe[xe.Unknown = 2] = "Unknown", xe[xe.InvalidArgument = 3] = "InvalidArgument", xe[xe.DeadlineExceeded = 4] = "DeadlineExceeded", xe[xe.NotFound = 5] = "NotFound", xe[xe.AlreadyExists = 6] = "AlreadyExists", xe[xe.PermissionDenied = 7] = "PermissionDenied", xe[xe.ResourceExhausted = 8] = "ResourceExhausted", xe[xe.FailedPrecondition = 9] = "FailedPrecondition", xe[xe.Aborted = 10] = "Aborted", xe[xe.OutOfRange = 11] = "OutOfRange", xe[xe.Unimplemented = 12] = "Unimplemented", xe[xe.Internal = 13] = "Internal", xe[xe.Unavailable = 14] = "Unavailable", xe[xe.DataLoss = 15] = "DataLoss", xe[xe.Unauthenticated = 16] = "Unauthenticated";
      }(_e = we.Code || (we.Code = {})), we.httpStatusToCode = function(xe) {
        switch (xe) {
          case 0:
            return _e.Internal;
          case 200:
            return _e.OK;
          case 400:
            return _e.InvalidArgument;
          case 401:
            return _e.Unauthenticated;
          case 403:
            return _e.PermissionDenied;
          case 404:
            return _e.NotFound;
          case 409:
            return _e.Aborted;
          case 412:
            return _e.FailedPrecondition;
          case 429:
            return _e.ResourceExhausted;
          case 499:
            return _e.Canceled;
          case 500:
            return _e.Unknown;
          case 501:
            return _e.Unimplemented;
          case 503:
            return _e.Unavailable;
          case 504:
            return _e.DeadlineExceeded;
          default:
            return _e.Unknown;
        }
      };
    }, 934: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.client = void 0;
      var xe = _e(65), Oe = _e(617), $e = _e(8), Re = _e(346), Ne = _e(57), je = _e(882);
      we.client = function(He, qe) {
        return new Be(He, qe);
      };
      var Be = function() {
        function He(qe, Ye) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new Oe.ChunkParser(), this.methodDefinition = qe, this.props = Ye, this.createTransport();
        }
        return He.prototype.createTransport = function() {
          var qe = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, Ye = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: qe, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(Ye) : this.transport = Ne.makeDefaultTransport(Ye);
        }, He.prototype.onTransportHeaders = function(qe, Ye) {
          if (this.props.debug && Re.debug("onHeaders", qe, Ye), this.closed)
            this.props.debug && Re.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (Ye !== 0) {
            this.responseHeaders = qe, this.props.debug && Re.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var ot = ze(qe);
            this.props.debug && Re.debug("onHeaders.gRPCStatus", ot);
            var tt = ot && ot >= 0 ? ot : $e.httpStatusToCode(Ye);
            this.props.debug && Re.debug("onHeaders.code", tt);
            var it = qe.get("grpc-message") || [];
            if (this.props.debug && Re.debug("onHeaders.gRPCMessage", it), this.rawOnHeaders(qe), tt !== $e.Code.OK) {
              var ht = this.decodeGRPCStatus(it[0]);
              this.rawOnError(tt, ht, qe);
            }
          }
        }, He.prototype.onTransportChunk = function(qe) {
          var Ye = this;
          if (this.closed)
            this.props.debug && Re.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var ot = [];
            try {
              ot = this.parser.parse(qe);
            } catch (tt) {
              return this.props.debug && Re.debug("onChunk.parsing error", tt, tt.message), void this.rawOnError($e.Code.Internal, "parsing error: " + tt.message);
            }
            ot.forEach(function(tt) {
              if (tt.chunkType === Oe.ChunkType.MESSAGE) {
                var it = Ye.methodDefinition.responseType.deserializeBinary(tt.data);
                Ye.rawOnMessage(it);
              } else
                tt.chunkType === Oe.ChunkType.TRAILERS && (Ye.responseHeaders ? (Ye.responseTrailers = new xe.Metadata(tt.trailers), Ye.props.debug && Re.debug("onChunk.trailers", Ye.responseTrailers)) : (Ye.responseHeaders = new xe.Metadata(tt.trailers), Ye.rawOnHeaders(Ye.responseHeaders)));
            });
          }
        }, He.prototype.onTransportEnd = function() {
          if (this.props.debug && Re.debug("grpc.onEnd"), this.closed)
            this.props.debug && Re.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var qe = ze(this.responseTrailers);
            if (qe !== null) {
              var Ye = this.responseTrailers.get("grpc-message"), ot = this.decodeGRPCStatus(Ye[0]);
              this.rawOnEnd(qe, ot, this.responseTrailers);
            } else
              this.rawOnError($e.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError($e.Code.Unknown, "Response closed without headers");
            var tt = ze(this.responseHeaders), it = this.responseHeaders.get("grpc-message");
            if (this.props.debug && Re.debug("grpc.headers only response ", tt, it), tt === null)
              return void this.rawOnEnd($e.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var ht = this.decodeGRPCStatus(it[0]);
            this.rawOnEnd(tt, ht, this.responseHeaders);
          }
        }, He.prototype.decodeGRPCStatus = function(qe) {
          if (!qe)
            return "";
          try {
            return decodeURIComponent(qe);
          } catch {
            return qe;
          }
        }, He.prototype.rawOnEnd = function(qe, Ye, ot) {
          var tt = this;
          this.props.debug && Re.debug("rawOnEnd", qe, Ye, ot), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(it) {
            if (!tt.closed)
              try {
                it(qe, Ye, ot);
              } catch (ht) {
                setTimeout(function() {
                  throw ht;
                }, 0);
              }
          }));
        }, He.prototype.rawOnHeaders = function(qe) {
          this.props.debug && Re.debug("rawOnHeaders", qe), this.completed || this.onHeadersCallbacks.forEach(function(Ye) {
            try {
              Ye(qe);
            } catch (ot) {
              setTimeout(function() {
                throw ot;
              }, 0);
            }
          });
        }, He.prototype.rawOnError = function(qe, Ye, ot) {
          var tt = this;
          ot === void 0 && (ot = new xe.Metadata()), this.props.debug && Re.debug("rawOnError", qe, Ye), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(it) {
            if (!tt.closed)
              try {
                it(qe, Ye, ot);
              } catch (ht) {
                setTimeout(function() {
                  throw ht;
                }, 0);
              }
          }));
        }, He.prototype.rawOnMessage = function(qe) {
          var Ye = this;
          this.props.debug && Re.debug("rawOnMessage", qe.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(ot) {
            if (!Ye.closed)
              try {
                ot(qe);
              } catch (tt) {
                setTimeout(function() {
                  throw tt;
                }, 0);
              }
          });
        }, He.prototype.onHeaders = function(qe) {
          this.onHeadersCallbacks.push(qe);
        }, He.prototype.onMessage = function(qe) {
          this.onMessageCallbacks.push(qe);
        }, He.prototype.onEnd = function(qe) {
          this.onEndCallbacks.push(qe);
        }, He.prototype.start = function(qe) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var Ye = new xe.Metadata(qe || {});
          Ye.set("content-type", "application/grpc-web+proto"), Ye.set("x-grpc-web", "1"), this.transport.start(Ye);
        }, He.prototype.send = function(qe) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var Ye = je.frameRequest(qe);
          this.transport.sendMessage(Ye);
        }, He.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, He.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && Re.debug("request.abort aborting request"), this.transport.cancel();
        }, He;
      }();
      function ze(He) {
        var qe = He.get("grpc-status") || [];
        if (qe.length > 0)
          try {
            var Ye = qe[0];
            return parseInt(Ye, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(ye, we) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.debug = void 0, we.debug = function() {
        for (var _e = [], xe = 0; xe < arguments.length; xe++)
          _e[xe] = arguments[xe];
        console.debug ? console.debug.apply(null, _e) : console.log.apply(null, _e);
      };
    }, 607: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.grpc = void 0;
      var xe, Oe = _e(418), $e = _e(57), Re = _e(229), Ne = _e(540), je = _e(210), Be = _e(859), ze = _e(8), He = _e(938), qe = _e(35), Ye = _e(934);
      (xe = we.grpc || (we.grpc = {})).setDefaultTransport = $e.setDefaultTransportFactory, xe.CrossBrowserHttpTransport = Be.CrossBrowserHttpTransport, xe.FetchReadableStreamTransport = Re.FetchReadableStreamTransport, xe.XhrTransport = je.XhrTransport, xe.WebsocketTransport = Ne.WebsocketTransport, xe.Code = ze.Code, xe.Metadata = Oe.BrowserHeaders, xe.client = function(ot, tt) {
        return Ye.client(ot, tt);
      }, xe.invoke = He.invoke, xe.unary = qe.unary;
    }, 938: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.invoke = void 0;
      var xe = _e(934);
      we.invoke = function(Oe, $e) {
        if (Oe.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var Re = xe.client(Oe, { host: $e.host, transport: $e.transport, debug: $e.debug });
        return $e.onHeaders && Re.onHeaders($e.onHeaders), $e.onMessage && Re.onMessage($e.onMessage), $e.onEnd && Re.onEnd($e.onEnd), Re.start($e.metadata), Re.send($e.request), Re.finishSend(), { close: function() {
          Re.close();
        } };
      };
    }, 65: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.Metadata = void 0;
      var xe = _e(418);
      Object.defineProperty(we, "Metadata", { enumerable: !0, get: function() {
        return xe.BrowserHeaders;
      } });
    }, 57: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.makeDefaultTransport = we.setDefaultTransportFactory = void 0;
      var xe = _e(859), Oe = function($e) {
        return xe.CrossBrowserHttpTransport({ withCredentials: !1 })($e);
      };
      we.setDefaultTransportFactory = function($e) {
        Oe = $e;
      }, we.makeDefaultTransport = function($e) {
        return Oe($e);
      };
    }, 229: function(ye, we, _e) {
      var xe = this && this.__assign || function() {
        return (xe = Object.assign || function(Ne) {
          for (var je, Be = 1, ze = arguments.length; Be < ze; Be++)
            for (var He in je = arguments[Be])
              Object.prototype.hasOwnProperty.call(je, He) && (Ne[He] = je[He]);
          return Ne;
        }).apply(this, arguments);
      };
      Object.defineProperty(we, "__esModule", { value: !0 }), we.detectFetchSupport = we.FetchReadableStreamTransport = void 0;
      var Oe = _e(65), $e = _e(346);
      we.FetchReadableStreamTransport = function(Ne) {
        return function(je) {
          return function(Be, ze) {
            return Be.debug && $e.debug("fetchRequest", Be), new Re(Be, ze);
          }(je, Ne);
        };
      };
      var Re = function() {
        function Ne(je, Be) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = je, this.init = Be;
        }
        return Ne.prototype.pump = function(je, Be) {
          var ze = this;
          if (this.reader = je, this.cancelled)
            return this.options.debug && $e.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(He) {
              ze.options.debug && $e.debug("Fetch.pump.reader.cancel exception", He);
            });
          this.reader.read().then(function(He) {
            if (He.done)
              return ze.options.onEnd(), Be;
            ze.options.onChunk(He.value), ze.pump(ze.reader, Be);
          }).catch(function(He) {
            ze.cancelled ? ze.options.debug && $e.debug("Fetch.catch - request cancelled") : (ze.cancelled = !0, ze.options.debug && $e.debug("Fetch.catch", He.message), ze.options.onEnd(He));
          });
        }, Ne.prototype.send = function(je) {
          var Be = this;
          fetch(this.options.url, xe(xe({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: je, signal: this.controller && this.controller.signal })).then(function(ze) {
            if (Be.options.debug && $e.debug("Fetch.response", ze), Be.options.onHeaders(new Oe.Metadata(ze.headers), ze.status), !ze.body)
              return ze;
            Be.pump(ze.body.getReader(), ze);
          }).catch(function(ze) {
            Be.cancelled ? Be.options.debug && $e.debug("Fetch.catch - request cancelled") : (Be.cancelled = !0, Be.options.debug && $e.debug("Fetch.catch", ze.message), Be.options.onEnd(ze));
          });
        }, Ne.prototype.sendMessage = function(je) {
          this.send(je);
        }, Ne.prototype.finishSend = function() {
        }, Ne.prototype.start = function(je) {
          this.metadata = je;
        }, Ne.prototype.cancel = function() {
          var je = this;
          this.cancelled ? this.options.debug && $e.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && $e.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && $e.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && $e.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(Be) {
            je.options.debug && $e.debug("Fetch.cancel.reader.cancel exception", Be);
          })) : this.options.debug && $e.debug("Fetch.cancel before reader"));
        }, Ne;
      }();
      we.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.CrossBrowserHttpTransport = void 0;
      var xe = _e(229), Oe = _e(210);
      we.CrossBrowserHttpTransport = function($e) {
        if (xe.detectFetchSupport()) {
          var Re = { credentials: $e.withCredentials ? "include" : "same-origin" };
          return xe.FetchReadableStreamTransport(Re);
        }
        return Oe.XhrTransport({ withCredentials: $e.withCredentials });
      };
    }, 210: function(ye, we, _e) {
      var xe, Oe = this && this.__extends || (xe = function(qe, Ye) {
        return (xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ot, tt) {
          ot.__proto__ = tt;
        } || function(ot, tt) {
          for (var it in tt)
            Object.prototype.hasOwnProperty.call(tt, it) && (ot[it] = tt[it]);
        })(qe, Ye);
      }, function(qe, Ye) {
        function ot() {
          this.constructor = qe;
        }
        xe(qe, Ye), qe.prototype = Ye === null ? Object.create(Ye) : (ot.prototype = Ye.prototype, new ot());
      });
      Object.defineProperty(we, "__esModule", { value: !0 }), we.stringToArrayBuffer = we.MozChunkedArrayBufferXHR = we.XHR = we.XhrTransport = void 0;
      var $e = _e(65), Re = _e(346), Ne = _e(849);
      we.XhrTransport = function(qe) {
        return function(Ye) {
          if (Ne.detectMozXHRSupport())
            return new Be(Ye, qe);
          if (Ne.detectXHROverrideMimeTypeSupport())
            return new je(Ye, qe);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var je = function() {
        function qe(Ye, ot) {
          this.options = Ye, this.init = ot;
        }
        return qe.prototype.onProgressEvent = function() {
          this.options.debug && Re.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var Ye = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var ot = He(Ye);
          this.options.onChunk(ot);
        }, qe.prototype.onLoadEvent = function() {
          this.options.debug && Re.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, qe.prototype.onStateChange = function() {
          this.options.debug && Re.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new $e.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, qe.prototype.sendMessage = function(Ye) {
          this.xhr.send(Ye);
        }, qe.prototype.finishSend = function() {
        }, qe.prototype.start = function(Ye) {
          var ot = this;
          this.metadata = Ye;
          var tt = new XMLHttpRequest();
          this.xhr = tt, tt.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(it, ht) {
            tt.setRequestHeader(it, ht.join(", "));
          }), tt.withCredentials = !!this.init.withCredentials, tt.addEventListener("readystatechange", this.onStateChange.bind(this)), tt.addEventListener("progress", this.onProgressEvent.bind(this)), tt.addEventListener("loadend", this.onLoadEvent.bind(this)), tt.addEventListener("error", function(it) {
            ot.options.debug && Re.debug("XHR.error", it), ot.options.onEnd(it.error);
          });
        }, qe.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, qe.prototype.cancel = function() {
          this.options.debug && Re.debug("XHR.abort"), this.xhr.abort();
        }, qe;
      }();
      we.XHR = je;
      var Be = function(qe) {
        function Ye() {
          return qe !== null && qe.apply(this, arguments) || this;
        }
        return Oe(Ye, qe), Ye.prototype.configureXhr = function() {
          this.options.debug && Re.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, Ye.prototype.onProgressEvent = function() {
          var ot = this.xhr.response;
          this.options.debug && Re.debug("MozXHR.onProgressEvent: ", new Uint8Array(ot)), this.options.onChunk(new Uint8Array(ot));
        }, Ye;
      }(je);
      function ze(qe, Ye) {
        var ot = qe.charCodeAt(Ye);
        if (ot >= 55296 && ot <= 56319) {
          var tt = qe.charCodeAt(Ye + 1);
          tt >= 56320 && tt <= 57343 && (ot = 65536 + (ot - 55296 << 10) + (tt - 56320));
        }
        return ot;
      }
      function He(qe) {
        for (var Ye = new Uint8Array(qe.length), ot = 0, tt = 0; tt < qe.length; tt++) {
          var it = String.prototype.codePointAt ? qe.codePointAt(tt) : ze(qe, tt);
          Ye[ot++] = 255 & it;
        }
        return Ye;
      }
      we.MozChunkedArrayBufferXHR = Be, we.stringToArrayBuffer = He;
    }, 849: function(ye, we) {
      var _e;
      function xe() {
        if (_e !== void 0)
          return _e;
        if (XMLHttpRequest) {
          _e = new XMLHttpRequest();
          try {
            _e.open("GET", "https://localhost");
          } catch {
          }
        }
        return _e;
      }
      function Oe($e) {
        var Re = xe();
        if (!Re)
          return !1;
        try {
          return Re.responseType = $e, Re.responseType === $e;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(we, "__esModule", { value: !0 }), we.detectXHROverrideMimeTypeSupport = we.detectMozXHRSupport = we.xhrSupportsResponseType = void 0, we.xhrSupportsResponseType = Oe, we.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && Oe("moz-chunked-arraybuffer");
      }, we.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.WebsocketTransport = void 0;
      var xe, Oe = _e(346), $e = _e(617);
      (function(Ne) {
        Ne[Ne.FINISH_SEND = 1] = "FINISH_SEND";
      })(xe || (xe = {}));
      var Re = new Uint8Array([1]);
      we.WebsocketTransport = function() {
        return function(Ne) {
          return function(je) {
            je.debug && Oe.debug("websocketRequest", je);
            var Be, ze = function(Ye) {
              if (Ye.substr(0, 8) === "https://")
                return "wss://" + Ye.substr(8);
              if (Ye.substr(0, 7) === "http://")
                return "ws://" + Ye.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(je.url), He = [];
            function qe(Ye) {
              if (Ye === xe.FINISH_SEND)
                Be.send(Re);
              else {
                var ot = Ye, tt = new Int8Array(ot.byteLength + 1);
                tt.set(new Uint8Array([0])), tt.set(ot, 1), Be.send(tt);
              }
            }
            return { sendMessage: function(Ye) {
              Be && Be.readyState !== Be.CONNECTING ? qe(Ye) : He.push(Ye);
            }, finishSend: function() {
              Be && Be.readyState !== Be.CONNECTING ? qe(xe.FINISH_SEND) : He.push(xe.FINISH_SEND);
            }, start: function(Ye) {
              (Be = new WebSocket(ze, ["grpc-websockets"])).binaryType = "arraybuffer", Be.onopen = function() {
                var ot;
                je.debug && Oe.debug("websocketRequest.onopen"), Be.send((ot = "", Ye.forEach(function(tt, it) {
                  ot += tt + ": " + it.join(", ") + `\r
`;
                }), $e.encodeASCII(ot))), He.forEach(function(tt) {
                  qe(tt);
                });
              }, Be.onclose = function(ot) {
                je.debug && Oe.debug("websocketRequest.onclose", ot), je.onEnd();
              }, Be.onerror = function(ot) {
                je.debug && Oe.debug("websocketRequest.onerror", ot);
              }, Be.onmessage = function(ot) {
                je.onChunk(new Uint8Array(ot.data));
              };
            }, cancel: function() {
              je.debug && Oe.debug("websocket.abort"), Be.close();
            } };
          }(Ne);
        };
      };
    }, 35: function(ye, we, _e) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.unary = void 0;
      var xe = _e(65), Oe = _e(934);
      we.unary = function($e, Re) {
        if ($e.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if ($e.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var Ne = null, je = null, Be = Oe.client($e, { host: Re.host, transport: Re.transport, debug: Re.debug });
        return Be.onHeaders(function(ze) {
          Ne = ze;
        }), Be.onMessage(function(ze) {
          je = ze;
        }), Be.onEnd(function(ze, He, qe) {
          Re.onEnd({ status: ze, statusMessage: He, headers: Ne || new xe.Metadata(), message: je, trailers: qe });
        }), Be.start(Re.metadata), Be.send(Re.request), Be.finishSend(), { close: function() {
          Be.close();
        } };
      };
    }, 882: function(ye, we) {
      Object.defineProperty(we, "__esModule", { value: !0 }), we.frameRequest = void 0, we.frameRequest = function(_e) {
        var xe = _e.serializeBinary(), Oe = new ArrayBuffer(xe.byteLength + 5);
        return new DataView(Oe, 1, 4).setUint32(0, xe.length, !1), new Uint8Array(Oe, 5).set(xe), new Uint8Array(Oe);
      };
    } }, fe = {}, function ye(we) {
      if (fe[we])
        return fe[we].exports;
      var _e = fe[we] = { exports: {} };
      return ae[we].call(_e.exports, _e, _e.exports, ye), _e.exports;
    }(607);
    var ae, fe;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
let AbortError$3 = class extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
};
function isAbortError(ne) {
  return typeof ne == "object" && ne !== null && ne.name === "AbortError";
}
function throwIfAborted(ne) {
  if (ne.aborted)
    throw new AbortError$3();
}
function rethrowAbortError(ne) {
  if (isAbortError(ne))
    throw ne;
}
function catchAbortError(ne) {
  if (!isAbortError(ne))
    throw ne;
}
function execute(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    let ye, we = !1;
    function _e() {
      we || (we = !0, ye != null && ye());
    }
    const xe = oe((Oe) => {
      ae(Oe), _e();
    }, (Oe) => {
      fe(Oe), _e();
    });
    if (!we) {
      const Oe = () => {
        const $e = xe();
        $e == null ? fe(new AbortError$3()) : $e.then(() => {
          fe(new AbortError$3());
        }, (Re) => {
          fe(Re);
        }), _e();
      };
      ne.addEventListener("abort", Oe), ye = () => {
        ne.removeEventListener("abort", Oe);
      };
    }
  });
}
function abortable(ne, oe) {
  if (ne.aborted) {
    const ae = () => {
    };
    oe.then(ae, ae);
  }
  return execute(ne, (ae, fe) => (oe.then(ae, fe), () => {
  }));
}
function delay(ne, oe) {
  return execute(ne, (ae) => {
    const fe = typeof oe == "number" ? oe : oe.getTime() - Date.now(), ye = setTimeout(ae, fe);
    return () => {
      clearTimeout(ye);
    };
  });
}
function forever(ne) {
  return execute(ne, () => () => {
  });
}
function waitForEvent(ne, oe, ae, fe) {
  return execute(ne, (ye) => {
    let we, _e = !1;
    return we = listen(oe, ae, (...Oe) => {
      ye(Oe.length > 1 ? Oe : Oe[0]), _e = !0, we != null && we();
    }, fe), _e && we(), () => {
      _e = !0, we != null && we();
    };
  });
}
function listen(ne, oe, ae, fe) {
  if (isEventTarget(ne))
    return ne.addEventListener(oe, ae, fe), () => ne.removeEventListener(oe, ae, fe);
  if (isJQueryStyleEventEmitter(ne))
    return ne.on(oe, ae), () => ne.off(oe, ae);
  if (isNodeStyleEventEmitter(ne))
    return ne.addListener(oe, ae), () => ne.removeListener(oe, ae);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(ne) {
  return isFunction$3(ne.addListener) && isFunction$3(ne.removeListener);
}
function isJQueryStyleEventEmitter(ne) {
  return isFunction$3(ne.on) && isFunction$3(ne.off);
}
function isEventTarget(ne) {
  return isFunction$3(ne.addEventListener) && isFunction$3(ne.removeEventListener);
}
const isFunction$3 = (ne) => typeof ne == "function";
function all(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), we = oe(ye.signal);
    if (we.length === 0) {
      ae([]);
      return;
    }
    const _e = () => {
      ye.abort();
    };
    ne.addEventListener("abort", _e);
    let xe;
    const Oe = new Array(we.length);
    let $e = 0;
    function Re() {
      $e += 1, $e === we.length && (ne.removeEventListener("abort", _e), xe != null ? fe(xe.reason) : ae(Oe));
    }
    for (const [Ne, je] of we.entries())
      je.then((Be) => {
        Oe[Ne] = Be, Re();
      }, (Be) => {
        ye.abort(), (xe == null || !isAbortError(Be) && isAbortError(xe.reason)) && (xe = { reason: Be }), Re();
      });
  });
}
function race(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), we = oe(ye.signal), _e = () => {
      ye.abort();
    };
    ne.addEventListener("abort", _e);
    let xe = 0;
    function Oe(Re) {
      ye.abort(), xe += 1, xe === we.length && (ne.removeEventListener("abort", _e), Re.status === "fulfilled" ? ae(Re.value) : fe(Re.reason));
    }
    let $e;
    for (const Re of we)
      Re.then((Ne) => {
        $e == null && ($e = { status: "fulfilled", value: Ne }), Oe($e);
      }, (Ne) => {
        ($e == null || !isAbortError(Ne) && ($e.status === "fulfilled" || isAbortError($e.reason))) && ($e = { status: "rejected", reason: Ne }), Oe($e);
      });
  });
}
async function retry$4(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, maxDelayMs: ye = 3e4, onError: we, maxAttempts: _e = 1 / 0 } = ae;
  let xe = 0;
  const Oe = () => {
    xe = -1;
  };
  for (; ; )
    try {
      return await oe(ne, xe, Oe);
    } catch ($e) {
      if (rethrowAbortError($e), xe >= _e)
        throw $e;
      let Re;
      if (xe === -1)
        Re = 0;
      else {
        const Ne = Math.min(ye, Math.pow(2, xe) * fe);
        Re = Math.round(Ne * (1 + Math.random()) / 2);
      }
      we && we($e, xe, Re), Re !== 0 && await delay(ne, Re), xe += 1;
    }
}
function spawn(ne, oe) {
  if (ne.aborted)
    return Promise.reject(new AbortError$3());
  const ae = [], fe = new AbortController(), ye = fe.signal, we = () => {
    fe.abort();
  };
  ne.addEventListener("abort", we);
  const _e = () => {
    ne.removeEventListener("abort", we);
  }, xe = /* @__PURE__ */ new Set(), Oe = () => {
    for (const Ne of xe)
      Ne.abort();
  };
  ye.addEventListener("abort", Oe);
  const $e = () => {
    ye.removeEventListener("abort", Oe);
  };
  let Re = new Promise((Ne, je) => {
    let Be, ze;
    He((qe) => oe(qe, {
      defer(Ye) {
        ae.push(Ye);
      },
      fork: He
    })).join().then((qe) => {
      fe.abort(), Be = { value: qe };
    }, (qe) => {
      fe.abort(), (!isAbortError(qe) || ze == null) && (ze = { error: qe });
    });
    function He(qe) {
      if (ye.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError$3();
          }
        };
      const Ye = new AbortController(), ot = Ye.signal, tt = qe(ot), it = {
        abort() {
          Ye.abort();
        },
        join: () => tt
      };
      return xe.add(it), tt.catch(catchAbortError).catch((ht) => {
        ze = { error: ht }, fe.abort();
      }).finally(() => {
        xe.delete(it), xe.size === 0 && (ze != null ? je(ze.error) : Ne(Be.value));
      }), it;
    }
  });
  return Re = Re.finally(() => {
    _e(), $e();
    let Ne = Promise.resolve();
    for (let je = ae.length - 1; je >= 0; je--)
      Ne = Ne.finally(ae[je]);
    return Ne;
  }), Re;
}
function run$1(ne) {
  const oe = new AbortController(), ae = ne(oe.signal).catch(catchAbortError);
  return () => (oe.abort(), ae);
}
function proactiveRetry(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, onError: ye, maxAttempts: we = 1 / 0 } = ae;
  return execute(ne, (_e, xe) => {
    const Oe = new AbortController();
    let $e = !1;
    const Re = /* @__PURE__ */ new Map();
    function Ne(ze) {
      Oe.abort(), Re.clear(), _e(ze);
    }
    function je(ze, He) {
      if (Re.delete(He), $e && Re.size === 0) {
        xe(ze);
        return;
      }
      if (!isAbortError(ze) && ye)
        try {
          ye(ze, He);
        } catch (qe) {
          Oe.abort(), Re.clear(), xe(qe);
        }
    }
    async function Be(ze) {
      for (let He = 0; ; He++) {
        const qe = oe(ze, He);
        if (Re.set(He, qe), qe.then(Ne, (tt) => je(tt, He)), He + 1 >= we)
          break;
        const Ye = Math.pow(2, He) * fe, ot = Math.round(Ye * (1 + Math.random()) / 2);
        await delay(ze, ot);
      }
      $e = !0;
    }
    return Be(Oe.signal).catch(catchAbortError), () => {
      Oe.abort();
    };
  });
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError: AbortError$3,
  abortable,
  all,
  catchAbortError,
  delay,
  execute,
  forever,
  isAbortError,
  proactiveRetry,
  race,
  rethrowAbortError,
  retry: retry$4,
  run: run$1,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(oe) {
    this._push({ type: ARRAY_VALUE, value: oe });
  }
  error(oe) {
    this._push({ type: ARRAY_ERROR, error: oe });
  }
  _push(oe) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: ae, reject: fe } = this._resolvers.shift();
      oe.type === ARRAY_ERROR ? fe(oe.error) : ae({ done: !1, value: oe.value });
    } else
      this._values.push(oe);
  }
  next() {
    if (this._values.length > 0) {
      const { type: oe, value: ae, error: fe } = this._values.shift();
      return oe === ARRAY_ERROR ? Promise.reject(fe) : Promise.resolve({ done: !1, value: ae });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((oe, ae) => {
      this._resolvers.push({ resolve: oe, reject: ae });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$2 = {};
Object.defineProperty(isAsyncIterable$2, "__esModule", { value: !0 });
isAsyncIterable$2.isAsyncIterable = void 0;
function isAsyncIterable$1(ne) {
  return ne != null && Symbol.asyncIterator in ne;
}
isAsyncIterable$2.isAsyncIterable = isAsyncIterable$1;
var convertMetadata = {}, base64 = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal, function() {
    var ae = "3.7.7", fe = ae, ye = typeof Buffer == "function", we = typeof TextDecoder == "function" ? new TextDecoder() : void 0, _e = typeof TextEncoder == "function" ? new TextEncoder() : void 0, xe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Oe = Array.prototype.slice.call(xe), $e = function(Zt) {
      var vn = {};
      return Zt.forEach(function(Fn, Qn) {
        return vn[Fn] = Qn;
      }), vn;
    }(Oe), Re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, Ne = String.fromCharCode.bind(String), je = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(Zt) {
      return new Uint8Array(Array.prototype.slice.call(Zt, 0));
    }, Be = function(Zt) {
      return Zt.replace(/=/g, "").replace(/[+\/]/g, function(vn) {
        return vn == "+" ? "-" : "_";
      });
    }, ze = function(Zt) {
      return Zt.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, He = function(Zt) {
      for (var vn, Fn, Qn, Un, ar = "", Zo = Zt.length % 3, ao = 0; ao < Zt.length; ) {
        if ((Fn = Zt.charCodeAt(ao++)) > 255 || (Qn = Zt.charCodeAt(ao++)) > 255 || (Un = Zt.charCodeAt(ao++)) > 255)
          throw new TypeError("invalid character found");
        vn = Fn << 16 | Qn << 8 | Un, ar += Oe[vn >> 18 & 63] + Oe[vn >> 12 & 63] + Oe[vn >> 6 & 63] + Oe[vn & 63];
      }
      return Zo ? ar.slice(0, Zo - 3) + "===".substring(Zo) : ar;
    }, qe = typeof btoa == "function" ? function(Zt) {
      return btoa(Zt);
    } : ye ? function(Zt) {
      return Buffer.from(Zt, "binary").toString("base64");
    } : He, Ye = ye ? function(Zt) {
      return Buffer.from(Zt).toString("base64");
    } : function(Zt) {
      for (var vn = 4096, Fn = [], Qn = 0, Un = Zt.length; Qn < Un; Qn += vn)
        Fn.push(Ne.apply(null, Zt.subarray(Qn, Qn + vn)));
      return qe(Fn.join(""));
    }, ot = function(Zt, vn) {
      return vn === void 0 && (vn = !1), vn ? Be(Ye(Zt)) : Ye(Zt);
    }, tt = function(Zt) {
      if (Zt.length < 2) {
        var vn = Zt.charCodeAt(0);
        return vn < 128 ? Zt : vn < 2048 ? Ne(192 | vn >>> 6) + Ne(128 | vn & 63) : Ne(224 | vn >>> 12 & 15) + Ne(128 | vn >>> 6 & 63) + Ne(128 | vn & 63);
      } else {
        var vn = 65536 + (Zt.charCodeAt(0) - 55296) * 1024 + (Zt.charCodeAt(1) - 56320);
        return Ne(240 | vn >>> 18 & 7) + Ne(128 | vn >>> 12 & 63) + Ne(128 | vn >>> 6 & 63) + Ne(128 | vn & 63);
      }
    }, it = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, ht = function(Zt) {
      return Zt.replace(it, tt);
    }, gt = ye ? function(Zt) {
      return Buffer.from(Zt, "utf8").toString("base64");
    } : _e ? function(Zt) {
      return Ye(_e.encode(Zt));
    } : function(Zt) {
      return qe(ht(Zt));
    }, At = function(Zt, vn) {
      return vn === void 0 && (vn = !1), vn ? Be(gt(Zt)) : gt(Zt);
    }, St = function(Zt) {
      return At(Zt, !0);
    }, Nt = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, Ft = function(Zt) {
      switch (Zt.length) {
        case 4:
          var vn = (7 & Zt.charCodeAt(0)) << 18 | (63 & Zt.charCodeAt(1)) << 12 | (63 & Zt.charCodeAt(2)) << 6 | 63 & Zt.charCodeAt(3), Fn = vn - 65536;
          return Ne((Fn >>> 10) + 55296) + Ne((Fn & 1023) + 56320);
        case 3:
          return Ne((15 & Zt.charCodeAt(0)) << 12 | (63 & Zt.charCodeAt(1)) << 6 | 63 & Zt.charCodeAt(2));
        default:
          return Ne((31 & Zt.charCodeAt(0)) << 6 | 63 & Zt.charCodeAt(1));
      }
    }, Vt = function(Zt) {
      return Zt.replace(Nt, Ft);
    }, on = function(Zt) {
      if (Zt = Zt.replace(/\s+/g, ""), !Re.test(Zt))
        throw new TypeError("malformed base64.");
      Zt += "==".slice(2 - (Zt.length & 3));
      for (var vn, Fn = "", Qn, Un, ar = 0; ar < Zt.length; )
        vn = $e[Zt.charAt(ar++)] << 18 | $e[Zt.charAt(ar++)] << 12 | (Qn = $e[Zt.charAt(ar++)]) << 6 | (Un = $e[Zt.charAt(ar++)]), Fn += Qn === 64 ? Ne(vn >> 16 & 255) : Un === 64 ? Ne(vn >> 16 & 255, vn >> 8 & 255) : Ne(vn >> 16 & 255, vn >> 8 & 255, vn & 255);
      return Fn;
    }, tn = typeof atob == "function" ? function(Zt) {
      return atob(ze(Zt));
    } : ye ? function(Zt) {
      return Buffer.from(Zt, "base64").toString("binary");
    } : on, _n = ye ? function(Zt) {
      return je(Buffer.from(Zt, "base64"));
    } : function(Zt) {
      return je(tn(Zt).split("").map(function(vn) {
        return vn.charCodeAt(0);
      }));
    }, en = function(Zt) {
      return _n(Ht(Zt));
    }, dn = ye ? function(Zt) {
      return Buffer.from(Zt, "base64").toString("utf8");
    } : we ? function(Zt) {
      return we.decode(_n(Zt));
    } : function(Zt) {
      return Vt(tn(Zt));
    }, Ht = function(Zt) {
      return ze(Zt.replace(/[-_]/g, function(vn) {
        return vn == "-" ? "+" : "/";
      }));
    }, hn = function(Zt) {
      return dn(Ht(Zt));
    }, kn = function(Zt) {
      if (typeof Zt != "string")
        return !1;
      var vn = Zt.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(vn) || !/[^\s0-9a-zA-Z\-_]/.test(vn);
    }, Dn = function(Zt) {
      return {
        value: Zt,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, yt = function() {
      var Zt = function(vn, Fn) {
        return Object.defineProperty(String.prototype, vn, Dn(Fn));
      };
      Zt("fromBase64", function() {
        return hn(this);
      }), Zt("toBase64", function(vn) {
        return At(this, vn);
      }), Zt("toBase64URI", function() {
        return At(this, !0);
      }), Zt("toBase64URL", function() {
        return At(this, !0);
      }), Zt("toUint8Array", function() {
        return en(this);
      });
    }, jt = function() {
      var Zt = function(vn, Fn) {
        return Object.defineProperty(Uint8Array.prototype, vn, Dn(Fn));
      };
      Zt("toBase64", function(vn) {
        return ot(this, vn);
      }), Zt("toBase64URI", function() {
        return ot(this, !0);
      }), Zt("toBase64URL", function() {
        return ot(this, !0);
      });
    }, Mn = function() {
      yt(), jt();
    }, $n = {
      version: ae,
      VERSION: fe,
      atob: tn,
      atobPolyfill: on,
      btoa: qe,
      btoaPolyfill: He,
      fromBase64: hn,
      toBase64: At,
      encode: At,
      encodeURI: St,
      encodeURL: St,
      utob: ht,
      btou: Vt,
      decode: hn,
      isValid: kn,
      fromUint8Array: ot,
      toUint8Array: en,
      extendString: yt,
      extendUint8Array: jt,
      extendBuiltins: Mn
    };
    return $n.Base64 = {}, Object.keys($n).forEach(function(Zt) {
      return $n.Base64[Zt] = $n[Zt];
    }), $n;
  });
})(base64);
var base64Exports = base64.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(ne) {
  const oe = new grpc_web_1$4.grpc.Metadata();
  for (const [ae, fe] of ne)
    for (const ye of fe)
      oe.append(ae, typeof ye == "string" ? ye : js_base64_1.Base64.fromUint8Array(ye));
  return oe;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(ne) {
  const oe = (0, nice_grpc_common_1$5.Metadata)();
  for (const [ae, fe] of Object.entries(ne.headersMap))
    if (ae.endsWith("-bin"))
      for (const ye of fe)
        for (const we of ye.split(/,\s?/))
          oe.append(ae, js_base64_1.Base64.toUint8Array(we));
    else
      oe.set(ae, fe);
  return oe;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$2, AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$2, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(ne), we = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: Re = (0, nice_grpc_common_1$4.Metadata)(), signal: Ne = new AbortController().signal, onHeader: je, onTrailer: Be } = $e, ze = new AbortController(), He = new AsyncSink_1$1.AsyncSink(), qe = grpc_web_1$3.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    qe.onHeaders((tt) => {
      je == null || je((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(tt));
    }), qe.onMessage((tt) => {
      He.write(tt);
    }), qe.onEnd((tt, it, ht) => {
      Be == null || Be((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(ht)), tt === grpc_web_1$3.grpc.Code.OK ? He.end() : He.error(new nice_grpc_common_1$4.ClientError(ne.path, +tt, it));
    }), qe.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(Re));
    let Ye;
    pipeRequest$1(ze.signal, Oe, qe, ne).then(() => {
      qe.finishSend();
    }, (tt) => {
      (0, abort_controller_x_1$3.isAbortError)(tt) || (Ye = tt, qe.close(), He.end());
    });
    const ot = () => {
      He.error(new abort_controller_x_1$3.AbortError()), ze.abort(), qe.close();
    };
    Ne.addEventListener("abort", ot);
    try {
      yield* He;
    } finally {
      if (ze.abort(), Ne.removeEventListener("abort", ot), (0, abort_controller_x_1$3.throwIfAborted)(Ne), Ye)
        throw Ye;
    }
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: we,
    requestStream: !0,
    request: Oe,
    responseStream: !0,
    next: _e
  }, $e);
  return (Oe, $e) => {
    const Ne = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const je = await Ne.next();
            return je.done && je.value != null ? await Ne.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : je;
          },
          return() {
            return Ne.return();
          },
          throw(je) {
            return Ne.throw(je);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$3.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createClientStreamingMethod$1 = {};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$2, service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$2, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(ne), we = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: Re = (0, nice_grpc_common_1$3.Metadata)(), signal: Ne = new AbortController().signal, onHeader: je, onTrailer: Be } = $e;
    return await (0, abort_controller_x_1$2.execute)(Ne, (ze, He) => {
      const qe = new AbortController();
      let Ye;
      const ot = grpc_web_1$2.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return ot.onHeaders((tt) => {
        je == null || je((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(tt));
      }), ot.onMessage((tt) => {
        Ye = tt;
      }), ot.onEnd((tt, it, ht) => {
        Be == null || Be((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(ht)), qe.abort(), tt === grpc_web_1$2.grpc.Code.OK ? ze(Ye) : He(new nice_grpc_common_1$3.ClientError(ne.path, +tt, it));
      }), ot.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(Re)), pipeRequest(qe.signal, Oe, ot, ne).then(() => {
        ot.finishSend();
      }, (tt) => {
        (0, abort_controller_x_1$2.isAbortError)(tt) || (He(tt), ot.close());
      }), () => {
        qe.abort(), ot.close();
      };
    });
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: we,
    requestStream: !0,
    request: Oe,
    responseStream: !1,
    next: _e
  }, $e);
  return async (Oe, $e) => {
    const Ne = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    let je = await Ne.next();
    for (; ; ) {
      if (!je.done) {
        je = await Ne.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (je.value == null) {
        je = await Ne.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return je.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$2.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createServerStreamingMethod$1 = {};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$2, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$2;
function createServerStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(ne), we = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: Re = (0, nice_grpc_common_1$2.Metadata)(), signal: Ne = new AbortController().signal, onHeader: je, onTrailer: Be } = $e, ze = new AsyncSink_1.AsyncSink(), He = grpc_web_1$1.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    He.onHeaders((Ye) => {
      je == null || je((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(Ye));
    }), He.onMessage((Ye) => {
      ze.write(Ye);
    }), He.onEnd((Ye, ot, tt) => {
      Be == null || Be((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(tt)), Ye === grpc_web_1$1.grpc.Code.OK ? ze.end() : ze.error(new nice_grpc_common_1$2.ClientError(ne.path, +Ye, ot));
    }), He.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(Re)), He.send({
      serializeBinary: () => ne.requestSerialize(Oe)
    }), He.finishSend();
    const qe = () => {
      ze.error(new abort_controller_x_1$1.AbortError()), He.close();
    };
    Ne.addEventListener("abort", qe);
    try {
      yield* ze;
    } finally {
      Ne.removeEventListener("abort", qe), (0, abort_controller_x_1$1.throwIfAborted)(Ne);
    }
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: we,
    requestStream: !1,
    request: Oe,
    responseStream: !0,
    next: _e
  }, $e);
  return (Oe, $e) => {
    const Ne = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const je = await Ne.next();
            return je.done && je.value != null ? await Ne.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : je;
          },
          return() {
            return Ne.return();
          },
          throw(je) {
            return Ne.throw(je);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1 = require$$2, service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$2, convertMetadata_1 = convertMetadata;
function createUnaryMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(ne), we = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* _e(Oe, $e) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(Oe))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: Re = (0, nice_grpc_common_1$1.Metadata)(), signal: Ne = new AbortController().signal, onHeader: je, onTrailer: Be } = $e;
    return await (0, abort_controller_x_1.execute)(Ne, (ze, He) => {
      let qe;
      const Ye = grpc_web_1.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return Ye.onHeaders((ot) => {
        je == null || je((0, convertMetadata_1.convertMetadataFromGrpcWeb)(ot));
      }), Ye.onMessage((ot) => {
        qe = ot;
      }), Ye.onEnd((ot, tt, it) => {
        Be == null || Be((0, convertMetadata_1.convertMetadataFromGrpcWeb)(it)), ot === grpc_web_1.grpc.Code.OK ? ze(qe) : He(new nice_grpc_common_1$1.ClientError(ne.path, +ot, tt));
      }), Ye.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(Re)), Ye.send({
        serializeBinary: () => ne.requestSerialize(Oe)
      }), Ye.finishSend(), () => {
        Ye.close();
      };
    });
  }
  const xe = ae == null ? _e : (Oe, $e) => ae({
    method: we,
    requestStream: !1,
    request: Oe,
    responseStream: !1,
    next: _e
  }, $e);
  return async (Oe, $e) => {
    const Ne = xe(Oe, {
      ...fe,
      ...$e
    })[Symbol.asyncIterator]();
    let je = await Ne.next();
    for (; ; ) {
      if (!je.done) {
        je = await Ne.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (je.value == null) {
        je = await Ne.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return je.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(ne, oe, ae) {
  return createClientFactory().create(ne, oe, ae);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(ne) {
  return {
    use(oe) {
      return createClientFactoryWithMiddleware(ne == null ? oe : (0, nice_grpc_common_1.composeClientMiddleware)(ne, oe));
    },
    create(oe, ae, fe = {}) {
      const ye = {}, we = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(oe));
      for (const [_e, xe] of we) {
        const Oe = {
          ...fe["*"],
          ...fe[_e]
        };
        xe.requestStream ? xe.responseStream ? ye[_e] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(xe, ae, ne, Oe) : ye[_e] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(xe, ae, ne, Oe) : xe.responseStream ? ye[_e] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(xe, ae, ne, Oe) : ye[_e] = (0, createUnaryMethod_1.createUnaryMethod)(xe, ae, ne, Oe);
      }
      return ye;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ye, we, _e, xe) {
    xe === void 0 && (xe = _e);
    var Oe = Object.getOwnPropertyDescriptor(we, _e);
    (!Oe || ("get" in Oe ? !we.__esModule : Oe.writable || Oe.configurable)) && (Oe = { enumerable: !0, get: function() {
      return we[_e];
    } }), Object.defineProperty(ye, xe, Oe);
  } : function(ye, we, _e, xe) {
    xe === void 0 && (xe = _e), ye[xe] = we[_e];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(ye, we) {
    for (var _e in ye)
      _e !== "default" && !Object.prototype.hasOwnProperty.call(we, _e) && oe(we, ye, _e);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = ne.Metadata = ne.composeClientMiddleware = ne.ClientError = void 0;
  var fe = lib;
  Object.defineProperty(ne, "ClientError", { enumerable: !0, get: function() {
    return fe.ClientError;
  } }), Object.defineProperty(ne, "composeClientMiddleware", { enumerable: !0, get: function() {
    return fe.composeClientMiddleware;
  } }), Object.defineProperty(ne, "Metadata", { enumerable: !0, get: function() {
    return fe.Metadata;
  } }), Object.defineProperty(ne, "Status", { enumerable: !0, get: function() {
    return fe.Status;
  } }), ae(serviceDefinitions, ne), ae(channel, ne), ae(ClientFactory, ne), ae(Client, ne);
})(lib$1);
function createBaseLinkedTwitterPair() {
  return { username: "", address: "" };
}
var LinkedTwitterPair = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterPair();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (we != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterPair.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterPair();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripRequest() {
  return { username: "", address: "" };
}
var DripRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (we != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return DripRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripRequest();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripDevRequest() {
  return { address: "" };
}
var DripDevRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripDevRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return DripDevRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripDevRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripResponse() {
  return { dripTxHash: "", ecsTxHash: "" };
}
var DripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.dripTxHash !== "" && oe.uint32(10).string(ne.dripTxHash), ne.ecsTxHash !== "" && oe.uint32(18).string(ne.ecsTxHash), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.dripTxHash = ae.string();
          continue;
        case 2:
          if (we != 18)
            break;
          ye.ecsTxHash = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return DripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripResponse();
    return oe.dripTxHash = ne.dripTxHash ?? "", oe.ecsTxHash = ne.ecsTxHash ?? "", oe;
  }
};
function createBaseTimeUntilDripResponse() {
  return { timeUntilDripMinutes: 0, timeUntilDripSeconds: 0 };
}
var TimeUntilDripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.timeUntilDripMinutes !== 0 && oe.uint32(9).double(ne.timeUntilDripMinutes), ne.timeUntilDripSeconds !== 0 && oe.uint32(17).double(ne.timeUntilDripSeconds), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseTimeUntilDripResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 9)
            break;
          ye.timeUntilDripMinutes = ae.double();
          continue;
        case 2:
          if (we != 17)
            break;
          ye.timeUntilDripSeconds = ae.double();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return TimeUntilDripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseTimeUntilDripResponse();
    return oe.timeUntilDripMinutes = ne.timeUntilDripMinutes ?? 0, oe.timeUntilDripSeconds = ne.timeUntilDripSeconds ?? 0, oe;
  }
};
function createBaseGetLinkedTwittersRequest() {
  return {};
}
var GetLinkedTwittersRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseGetLinkedTwittersRequest();
  }
};
function createBaseGetLinkedTwittersResponse() {
  return { linkedTwitters: [] };
}
var GetLinkedTwittersResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    for (const ae of ne.linkedTwitters)
      LinkedTwitterPair.encode(ae, oe.uint32(10).fork()).ldelim();
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.linkedTwitters.push(LinkedTwitterPair.decode(ae, ae.uint32()));
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    var ae;
    const oe = createBaseGetLinkedTwittersResponse();
    return oe.linkedTwitters = ((ae = ne.linkedTwitters) == null ? void 0 : ae.map((fe) => LinkedTwitterPair.fromPartial(fe))) || [], oe;
  }
};
function createBaseLinkedTwitterForAddressRequest() {
  return { address: "" };
}
var LinkedTwitterForAddressRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseLinkedTwitterForAddressResponse() {
  return { username: "" };
}
var LinkedTwitterForAddressResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressResponse();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterRequest() {
  return { username: "" };
}
var LinkedAddressForTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterRequest();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterResponse() {
  return { address: "" };
}
var LinkedAddressForTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterResponse();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseSetLinkedTwitterRequest() {
  return { address: "", username: "", signature: "" };
}
var SetLinkedTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), ne.username !== "" && oe.uint32(18).string(ne.username), ne.signature !== "" && oe.uint32(26).string(ne.signature), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterRequest();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      switch (we >>> 3) {
        case 1:
          if (we != 10)
            break;
          ye.address = ae.string();
          continue;
        case 2:
          if (we != 18)
            break;
          ye.username = ae.string();
          continue;
        case 3:
          if (we != 26)
            break;
          ye.signature = ae.string();
          continue;
      }
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseSetLinkedTwitterRequest();
    return oe.address = ne.address ?? "", oe.username = ne.username ?? "", oe.signature = ne.signature ?? "", oe;
  }
};
function createBaseSetLinkedTwitterResponse() {
  return {};
}
var SetLinkedTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterResponse();
    for (; ae.pos < fe; ) {
      const we = ae.uint32();
      if ((we & 7) == 4 || we == 0)
        break;
      ae.skipType(we & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseSetLinkedTwitterResponse();
  }
}, FaucetServiceDefinition = {
  name: "FaucetService",
  fullName: "faucet.FaucetService",
  methods: {
    drip: {
      name: "Drip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripDev: {
      name: "DripDev",
      requestType: DripDevRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripVerifyTweet: {
      name: "DripVerifyTweet",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    timeUntilDrip: {
      name: "TimeUntilDrip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: TimeUntilDripResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitters: {
      name: "GetLinkedTwitters",
      requestType: GetLinkedTwittersRequest,
      requestStream: !1,
      responseType: GetLinkedTwittersResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitterForAddress: {
      name: "GetLinkedTwitterForAddress",
      requestType: LinkedTwitterForAddressRequest,
      requestStream: !1,
      responseType: LinkedTwitterForAddressResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedAddressForTwitter: {
      name: "GetLinkedAddressForTwitter",
      requestType: LinkedAddressForTwitterRequest,
      requestStream: !1,
      responseType: LinkedAddressForTwitterResponse,
      responseStream: !1,
      options: {}
    },
    /** Admin utility endpoints for modifying state. Requires a signature with faucet private key. */
    setLinkedTwitter: {
      name: "SetLinkedTwitter",
      requestType: SetLinkedTwitterRequest,
      requestStream: !1,
      responseType: SetLinkedTwitterResponse,
      responseStream: !1,
      options: {}
    }
  }
};
(() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && (_m0.util.Long = Long, _m0.configure());
function createFaucetService(ne) {
  return lib$1.createClient(FaucetServiceDefinition, lib$1.createChannel(ne));
}
var util;
(function(ne) {
  ne.assertEqual = (ye) => ye;
  function oe(ye) {
  }
  ne.assertIs = oe;
  function ae(ye) {
    throw new Error();
  }
  ne.assertNever = ae, ne.arrayToEnum = (ye) => {
    const we = {};
    for (const _e of ye)
      we[_e] = _e;
    return we;
  }, ne.getValidEnumValues = (ye) => {
    const we = ne.objectKeys(ye).filter((xe) => typeof ye[ye[xe]] != "number"), _e = {};
    for (const xe of we)
      _e[xe] = ye[xe];
    return ne.objectValues(_e);
  }, ne.objectValues = (ye) => ne.objectKeys(ye).map(function(we) {
    return ye[we];
  }), ne.objectKeys = typeof Object.keys == "function" ? (ye) => Object.keys(ye) : (ye) => {
    const we = [];
    for (const _e in ye)
      Object.prototype.hasOwnProperty.call(ye, _e) && we.push(_e);
    return we;
  }, ne.find = (ye, we) => {
    for (const _e of ye)
      if (we(_e))
        return _e;
  }, ne.isInteger = typeof Number.isInteger == "function" ? (ye) => Number.isInteger(ye) : (ye) => typeof ye == "number" && isFinite(ye) && Math.floor(ye) === ye;
  function fe(ye, we = " | ") {
    return ye.map((_e) => typeof _e == "string" ? `'${_e}'` : _e).join(we);
  }
  ne.joinValues = fe, ne.jsonStringifyReplacer = (ye, we) => typeof we == "bigint" ? we.toString() : we;
})(util || (util = {}));
var objectUtil;
(function(ne) {
  ne.mergeShapes = (oe, ae) => ({
    ...oe,
    ...ae
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (ne) => {
  switch (typeof ne) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(ne) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(ne) ? ZodParsedType.array : ne === null ? ZodParsedType.null : ne.then && typeof ne.then == "function" && ne.catch && typeof ne.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && ne instanceof Map ? ZodParsedType.map : typeof Set < "u" && ne instanceof Set ? ZodParsedType.set : typeof Date < "u" && ne instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson = (ne) => JSON.stringify(ne, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
  constructor(oe) {
    super(), this.issues = [], this.addIssue = (fe) => {
      this.issues = [...this.issues, fe];
    }, this.addIssues = (fe = []) => {
      this.issues = [...this.issues, ...fe];
    };
    const ae = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, ae) : this.__proto__ = ae, this.name = "ZodError", this.issues = oe;
  }
  get errors() {
    return this.issues;
  }
  format(oe) {
    const ae = oe || function(we) {
      return we.message;
    }, fe = { _errors: [] }, ye = (we) => {
      for (const _e of we.issues)
        if (_e.code === "invalid_union")
          _e.unionErrors.map(ye);
        else if (_e.code === "invalid_return_type")
          ye(_e.returnTypeError);
        else if (_e.code === "invalid_arguments")
          ye(_e.argumentsError);
        else if (_e.path.length === 0)
          fe._errors.push(ae(_e));
        else {
          let xe = fe, Oe = 0;
          for (; Oe < _e.path.length; ) {
            const $e = _e.path[Oe];
            Oe === _e.path.length - 1 ? (xe[$e] = xe[$e] || { _errors: [] }, xe[$e]._errors.push(ae(_e))) : xe[$e] = xe[$e] || { _errors: [] }, xe = xe[$e], Oe++;
          }
        }
    };
    return ye(this), fe;
  }
  static assert(oe) {
    if (!(oe instanceof ZodError))
      throw new Error(`Not a ZodError: ${oe}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(oe = (ae) => ae.message) {
    const ae = {}, fe = [];
    for (const ye of this.issues)
      ye.path.length > 0 ? (ae[ye.path[0]] = ae[ye.path[0]] || [], ae[ye.path[0]].push(oe(ye))) : fe.push(oe(ye));
    return { formErrors: fe, fieldErrors: ae };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (ne) => new ZodError(ne);
const errorMap = (ne, oe) => {
  let ae;
  switch (ne.code) {
    case ZodIssueCode.invalid_type:
      ne.received === ZodParsedType.undefined ? ae = "Required" : ae = `Expected ${ne.expected}, received ${ne.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      ae = `Invalid literal value, expected ${JSON.stringify(ne.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      ae = `Unrecognized key(s) in object: ${util.joinValues(ne.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      ae = `Invalid discriminator value. Expected ${util.joinValues(ne.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      ae = `Invalid enum value. Expected ${util.joinValues(ne.options)}, received '${ne.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      ae = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      ae = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      ae = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof ne.validation == "object" ? "includes" in ne.validation ? (ae = `Invalid input: must include "${ne.validation.includes}"`, typeof ne.validation.position == "number" && (ae = `${ae} at one or more positions greater than or equal to ${ne.validation.position}`)) : "startsWith" in ne.validation ? ae = `Invalid input: must start with "${ne.validation.startsWith}"` : "endsWith" in ne.validation ? ae = `Invalid input: must end with "${ne.validation.endsWith}"` : util.assertNever(ne.validation) : ne.validation !== "regex" ? ae = `Invalid ${ne.validation}` : ae = "Invalid";
      break;
    case ZodIssueCode.too_small:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "more than"} ${ne.minimum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "over"} ${ne.minimum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${ne.minimum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(ne.minimum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "less than"} ${ne.maximum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "under"} ${ne.maximum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "bigint" ? ae = `BigInt must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly" : ne.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(ne.maximum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.custom:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      ae = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      ae = `Number must be a multiple of ${ne.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      ae = "Number must be finite";
      break;
    default:
      ae = oe.defaultError, util.assertNever(ne);
  }
  return { message: ae };
};
let overrideErrorMap = errorMap;
function setErrorMap(ne) {
  overrideErrorMap = ne;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (ne) => {
  const { data: oe, path: ae, errorMaps: fe, issueData: ye } = ne, we = [...ae, ...ye.path || []], _e = {
    ...ye,
    path: we
  };
  if (ye.message !== void 0)
    return {
      ...ye,
      path: we,
      message: ye.message
    };
  let xe = "";
  const Oe = fe.filter(($e) => !!$e).slice().reverse();
  for (const $e of Oe)
    xe = $e(_e, { data: oe, defaultError: xe }).message;
  return {
    ...ye,
    path: we,
    message: xe
  };
}, EMPTY_PATH = [];
function addIssueToContext(ne, oe) {
  const ae = getErrorMap(), fe = makeIssue({
    issueData: oe,
    data: ne.data,
    path: ne.path,
    errorMaps: [
      ne.common.contextualErrorMap,
      ne.schemaErrorMap,
      ae,
      ae === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((ye) => !!ye)
  });
  ne.common.issues.push(fe);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      if (ye.status === "aborted")
        return INVALID;
      ye.status === "dirty" && oe.dirty(), fe.push(ye.value);
    }
    return { status: oe.value, value: fe };
  }
  static async mergeObjectAsync(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      const we = await ye.key, _e = await ye.value;
      fe.push({
        key: we,
        value: _e
      });
    }
    return ParseStatus.mergeObjectSync(oe, fe);
  }
  static mergeObjectSync(oe, ae) {
    const fe = {};
    for (const ye of ae) {
      const { key: we, value: _e } = ye;
      if (we.status === "aborted" || _e.status === "aborted")
        return INVALID;
      we.status === "dirty" && oe.dirty(), _e.status === "dirty" && oe.dirty(), we.value !== "__proto__" && (typeof _e.value < "u" || ye.alwaysSet) && (fe[we.value] = _e.value);
    }
    return { status: oe.value, value: fe };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (ne) => ({ status: "dirty", value: ne }), OK = (ne) => ({ status: "valid", value: ne }), isAborted = (ne) => ne.status === "aborted", isDirty = (ne) => ne.status === "dirty", isValid = (ne) => ne.status === "valid", isAsync = (ne) => typeof Promise < "u" && ne instanceof Promise;
function __classPrivateFieldGet$2(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}
function __classPrivateFieldSet$1(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}
typeof SuppressedError == "function" && SuppressedError;
var errorUtil;
(function(ne) {
  ne.errToObj = (oe) => typeof oe == "string" ? { message: oe } : oe || {}, ne.toString = (oe) => typeof oe == "string" ? oe : oe == null ? void 0 : oe.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(oe, ae, fe, ye) {
    this._cachedPath = [], this.parent = oe, this.data = ae, this._path = fe, this._key = ye;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const handleResult = (ne, oe) => {
  if (isValid(oe))
    return { success: !0, data: oe.value };
  if (!ne.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const ae = new ZodError(ne.common.issues);
      return this._error = ae, this._error;
    }
  };
};
function processCreateParams(ne) {
  if (!ne)
    return {};
  const { errorMap: oe, invalid_type_error: ae, required_error: fe, description: ye } = ne;
  if (oe && (ae || fe))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return oe ? { errorMap: oe, description: ye } : { errorMap: (_e, xe) => {
    var Oe, $e;
    const { message: Re } = ne;
    return _e.code === "invalid_enum_value" ? { message: Re ?? xe.defaultError } : typeof xe.data > "u" ? { message: (Oe = Re ?? fe) !== null && Oe !== void 0 ? Oe : xe.defaultError } : _e.code !== "invalid_type" ? { message: xe.defaultError } : { message: ($e = Re ?? ae) !== null && $e !== void 0 ? $e : xe.defaultError };
  }, description: ye };
}
class ZodType {
  constructor(oe) {
    this.spa = this.safeParseAsync, this._def = oe, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(oe) {
    return getParsedType(oe.data);
  }
  _getOrReturnCtx(oe, ae) {
    return ae || {
      common: oe.parent.common,
      data: oe.data,
      parsedType: getParsedType(oe.data),
      schemaErrorMap: this._def.errorMap,
      path: oe.path,
      parent: oe.parent
    };
  }
  _processInputParams(oe) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: oe.parent.common,
        data: oe.data,
        parsedType: getParsedType(oe.data),
        schemaErrorMap: this._def.errorMap,
        path: oe.path,
        parent: oe.parent
      }
    };
  }
  _parseSync(oe) {
    const ae = this._parse(oe);
    if (isAsync(ae))
      throw new Error("Synchronous parse encountered promise.");
    return ae;
  }
  _parseAsync(oe) {
    const ae = this._parse(oe);
    return Promise.resolve(ae);
  }
  parse(oe, ae) {
    const fe = this.safeParse(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  safeParse(oe, ae) {
    var fe;
    const ye = {
      common: {
        issues: [],
        async: (fe = ae == null ? void 0 : ae.async) !== null && fe !== void 0 ? fe : !1,
        contextualErrorMap: ae == null ? void 0 : ae.errorMap
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, we = this._parseSync({ data: oe, path: ye.path, parent: ye });
    return handleResult(ye, we);
  }
  async parseAsync(oe, ae) {
    const fe = await this.safeParseAsync(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  async safeParseAsync(oe, ae) {
    const fe = {
      common: {
        issues: [],
        contextualErrorMap: ae == null ? void 0 : ae.errorMap,
        async: !0
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, ye = this._parse({ data: oe, path: fe.path, parent: fe }), we = await (isAsync(ye) ? ye : Promise.resolve(ye));
    return handleResult(fe, we);
  }
  refine(oe, ae) {
    const fe = (ye) => typeof ae == "string" || typeof ae > "u" ? { message: ae } : typeof ae == "function" ? ae(ye) : ae;
    return this._refinement((ye, we) => {
      const _e = oe(ye), xe = () => we.addIssue({
        code: ZodIssueCode.custom,
        ...fe(ye)
      });
      return typeof Promise < "u" && _e instanceof Promise ? _e.then((Oe) => Oe ? !0 : (xe(), !1)) : _e ? !0 : (xe(), !1);
    });
  }
  refinement(oe, ae) {
    return this._refinement((fe, ye) => oe(fe) ? !0 : (ye.addIssue(typeof ae == "function" ? ae(fe, ye) : ae), !1));
  }
  _refinement(oe) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement: oe }
    });
  }
  superRefine(oe) {
    return this._refinement(oe);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(oe) {
    return ZodUnion.create([this, oe], this._def);
  }
  and(oe) {
    return ZodIntersection.create(this, oe, this._def);
  }
  transform(oe) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: oe }
    });
  }
  default(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(oe) {
    const ae = this.constructor;
    return new ae({
      ...this._def,
      description: oe
    });
  }
  pipe(oe) {
    return ZodPipeline.create(this, oe);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(ne) {
  let oe = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return ne.precision ? oe = `${oe}\\.\\d{${ne.precision}}` : ne.precision == null && (oe = `${oe}(\\.\\d+)?`), oe;
}
function timeRegex(ne) {
  return new RegExp(`^${timeRegexSource(ne)}$`);
}
function datetimeRegex(ne) {
  let oe = `${dateRegexSource}T${timeRegexSource(ne)}`;
  const ae = [];
  return ae.push(ne.local ? "Z?" : "Z"), ne.offset && ae.push("([+-]\\d{2}:?\\d{2})"), oe = `${oe}(${ae.join("|")})`, new RegExp(`^${oe}$`);
}
function isValidIP(ne, oe) {
  return !!((oe === "v4" || !oe) && ipv4Regex.test(ne) || (oe === "v6" || !oe) && ipv6Regex.test(ne));
}
class ZodString extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = String(oe.data)), this._getType(oe) !== ZodParsedType.string) {
      const we = this._getOrReturnCtx(oe);
      return addIssueToContext(we, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: we.parsedType
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const we of this._def.checks)
      if (we.kind === "min")
        oe.data.length < we.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: we.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "max")
        oe.data.length > we.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: we.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "length") {
        const _e = oe.data.length > we.value, xe = oe.data.length < we.value;
        (_e || xe) && (ye = this._getOrReturnCtx(oe, ye), _e ? addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: we.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: we.message
        }) : xe && addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: we.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: we.message
        }), fe.dirty());
      } else if (we.kind === "email")
        emailRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "uuid")
        uuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "nanoid")
        nanoidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "cuid")
        cuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "cuid2")
        cuid2Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "ulid")
        ulidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty());
      else if (we.kind === "url")
        try {
          new URL(oe.data);
        } catch {
          ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: we.message
          }), fe.dirty();
        }
      else
        we.kind === "regex" ? (we.regex.lastIndex = 0, we.regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "regex",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty())) : we.kind === "trim" ? oe.data = oe.data.trim() : we.kind === "includes" ? oe.data.includes(we.value, we.position) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { includes: we.value, position: we.position },
          message: we.message
        }), fe.dirty()) : we.kind === "toLowerCase" ? oe.data = oe.data.toLowerCase() : we.kind === "toUpperCase" ? oe.data = oe.data.toUpperCase() : we.kind === "startsWith" ? oe.data.startsWith(we.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { startsWith: we.value },
          message: we.message
        }), fe.dirty()) : we.kind === "endsWith" ? oe.data.endsWith(we.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { endsWith: we.value },
          message: we.message
        }), fe.dirty()) : we.kind === "datetime" ? datetimeRegex(we).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "datetime",
          message: we.message
        }), fe.dirty()) : we.kind === "date" ? dateRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "date",
          message: we.message
        }), fe.dirty()) : we.kind === "time" ? timeRegex(we).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "time",
          message: we.message
        }), fe.dirty()) : we.kind === "duration" ? durationRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "duration",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty()) : we.kind === "ip" ? isValidIP(oe.data, we.version) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ip",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty()) : we.kind === "base64" ? base64Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "base64",
          code: ZodIssueCode.invalid_string,
          message: we.message
        }), fe.dirty()) : util.assertNever(we);
    return { status: fe.value, value: oe.data };
  }
  _regex(oe, ae, fe) {
    return this.refinement((ye) => oe.test(ye), {
      validation: ae,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(fe)
    });
  }
  _addCheck(oe) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  email(oe) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(oe) });
  }
  url(oe) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(oe) });
  }
  emoji(oe) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(oe) });
  }
  uuid(oe) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(oe) });
  }
  nanoid(oe) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(oe) });
  }
  cuid(oe) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(oe) });
  }
  cuid2(oe) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(oe) });
  }
  ulid(oe) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(oe) });
  }
  base64(oe) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(oe) });
  }
  ip(oe) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(oe) });
  }
  datetime(oe) {
    var ae, fe;
    return typeof oe == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: oe
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      offset: (ae = oe == null ? void 0 : oe.offset) !== null && ae !== void 0 ? ae : !1,
      local: (fe = oe == null ? void 0 : oe.local) !== null && fe !== void 0 ? fe : !1,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  date(oe) {
    return this._addCheck({ kind: "date", message: oe });
  }
  time(oe) {
    return typeof oe == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: oe
    }) : this._addCheck({
      kind: "time",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  duration(oe) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(oe) });
  }
  regex(oe, ae) {
    return this._addCheck({
      kind: "regex",
      regex: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  includes(oe, ae) {
    return this._addCheck({
      kind: "includes",
      value: oe,
      position: ae == null ? void 0 : ae.position,
      ...errorUtil.errToObj(ae == null ? void 0 : ae.message)
    });
  }
  startsWith(oe, ae) {
    return this._addCheck({
      kind: "startsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  endsWith(oe, ae) {
    return this._addCheck({
      kind: "endsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  length(oe, ae) {
    return this._addCheck({
      kind: "length",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(oe) {
    return this.min(1, errorUtil.errToObj(oe));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((oe) => oe.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((oe) => oe.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((oe) => oe.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((oe) => oe.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((oe) => oe.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((oe) => oe.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((oe) => oe.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((oe) => oe.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((oe) => oe.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((oe) => oe.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((oe) => oe.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((oe) => oe.kind === "base64");
  }
  get minLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodString.create = (ne) => {
  var oe;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
function floatSafeRemainder(ne, oe) {
  const ae = (ne.toString().split(".")[1] || "").length, fe = (oe.toString().split(".")[1] || "").length, ye = ae > fe ? ae : fe, we = parseInt(ne.toFixed(ye).replace(".", "")), _e = parseInt(oe.toFixed(ye).replace(".", ""));
  return we % _e / Math.pow(10, ye);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = Number(oe.data)), this._getType(oe) !== ZodParsedType.number) {
      const we = this._getOrReturnCtx(oe);
      return addIssueToContext(we, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: we.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const we of this._def.checks)
      we.kind === "int" ? util.isInteger(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: we.message
      }), ye.dirty()) : we.kind === "min" ? (we.inclusive ? oe.data < we.value : oe.data <= we.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: we.value,
        type: "number",
        inclusive: we.inclusive,
        exact: !1,
        message: we.message
      }), ye.dirty()) : we.kind === "max" ? (we.inclusive ? oe.data > we.value : oe.data >= we.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        maximum: we.value,
        type: "number",
        inclusive: we.inclusive,
        exact: !1,
        message: we.message
      }), ye.dirty()) : we.kind === "multipleOf" ? floatSafeRemainder(oe.data, we.value) !== 0 && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: we.value,
        message: we.message
      }), ye.dirty()) : we.kind === "finite" ? Number.isFinite(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_finite,
        message: we.message
      }), ye.dirty()) : util.assertNever(we);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  int(oe) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(oe)
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  finite(oe) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(oe)
    });
  }
  safe(oe) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
  get isInt() {
    return !!this._def.checks.find((oe) => oe.kind === "int" || oe.kind === "multipleOf" && util.isInteger(oe.value));
  }
  get isFinite() {
    let oe = null, ae = null;
    for (const fe of this._def.checks) {
      if (fe.kind === "finite" || fe.kind === "int" || fe.kind === "multipleOf")
        return !0;
      fe.kind === "min" ? (ae === null || fe.value > ae) && (ae = fe.value) : fe.kind === "max" && (oe === null || fe.value < oe) && (oe = fe.value);
    }
    return Number.isFinite(ae) && Number.isFinite(oe);
  }
}
ZodNumber.create = (ne) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = BigInt(oe.data)), this._getType(oe) !== ZodParsedType.bigint) {
      const we = this._getOrReturnCtx(oe);
      return addIssueToContext(we, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: we.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const we of this._def.checks)
      we.kind === "min" ? (we.inclusive ? oe.data < we.value : oe.data <= we.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: we.value,
        inclusive: we.inclusive,
        message: we.message
      }), ye.dirty()) : we.kind === "max" ? (we.inclusive ? oe.data > we.value : oe.data >= we.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: we.value,
        inclusive: we.inclusive,
        message: we.message
      }), ye.dirty()) : we.kind === "multipleOf" ? oe.data % we.value !== BigInt(0) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: we.value,
        message: we.message
      }), ye.dirty()) : util.assertNever(we);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodBigInt.create = (ne) => {
  var oe;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
class ZodBoolean extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = !!oe.data), this._getType(oe) !== ZodParsedType.boolean) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodBoolean.create = (ne) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodDate extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = new Date(oe.data)), this._getType(oe) !== ZodParsedType.date) {
      const we = this._getOrReturnCtx(oe);
      return addIssueToContext(we, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: we.parsedType
      }), INVALID;
    }
    if (isNaN(oe.data.getTime())) {
      const we = this._getOrReturnCtx(oe);
      return addIssueToContext(we, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const we of this._def.checks)
      we.kind === "min" ? oe.data.getTime() < we.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_small,
        message: we.message,
        inclusive: !0,
        exact: !1,
        minimum: we.value,
        type: "date"
      }), fe.dirty()) : we.kind === "max" ? oe.data.getTime() > we.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_big,
        message: we.message,
        inclusive: !0,
        exact: !1,
        maximum: we.value,
        type: "date"
      }), fe.dirty()) : util.assertNever(we);
    return {
      status: fe.value,
      value: new Date(oe.data.getTime())
    };
  }
  _addCheck(oe) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  get minDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
  get maxDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
}
ZodDate.create = (ne) => new ZodDate({
  checks: [],
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(ne)
});
class ZodSymbol extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.symbol) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodSymbol.create = (ne) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(ne)
});
class ZodUndefined extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodUndefined.create = (ne) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(ne)
});
class ZodNull extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.null) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodNull.create = (ne) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(ne)
});
class ZodAny extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodAny.create = (ne) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(ne)
});
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodUnknown.create = (ne) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(ne)
});
class ZodNever extends ZodType {
  _parse(oe) {
    const ae = this._getOrReturnCtx(oe);
    return addIssueToContext(ae, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ae.parsedType
    }), INVALID;
  }
}
ZodNever.create = (ne) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(ne)
});
class ZodVoid extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodVoid.create = (ne) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(ne)
});
class ZodArray extends ZodType {
  _parse(oe) {
    const { ctx: ae, status: fe } = this._processInputParams(oe), ye = this._def;
    if (ae.parsedType !== ZodParsedType.array)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ae.parsedType
      }), INVALID;
    if (ye.exactLength !== null) {
      const _e = ae.data.length > ye.exactLength.value, xe = ae.data.length < ye.exactLength.value;
      (_e || xe) && (addIssueToContext(ae, {
        code: _e ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: xe ? ye.exactLength.value : void 0,
        maximum: _e ? ye.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: ye.exactLength.message
      }), fe.dirty());
    }
    if (ye.minLength !== null && ae.data.length < ye.minLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_small,
      minimum: ye.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.minLength.message
    }), fe.dirty()), ye.maxLength !== null && ae.data.length > ye.maxLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.maxLength.message
    }), fe.dirty()), ae.common.async)
      return Promise.all([...ae.data].map((_e, xe) => ye.type._parseAsync(new ParseInputLazyPath(ae, _e, ae.path, xe)))).then((_e) => ParseStatus.mergeArray(fe, _e));
    const we = [...ae.data].map((_e, xe) => ye.type._parseSync(new ParseInputLazyPath(ae, _e, ae.path, xe)));
    return ParseStatus.mergeArray(fe, we);
  }
  get element() {
    return this._def.type;
  }
  min(oe, ae) {
    return new ZodArray({
      ...this._def,
      minLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  length(oe, ae) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodArray.create = (ne, oe) => new ZodArray({
  type: ne,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(oe)
});
function deepPartialify(ne) {
  if (ne instanceof ZodObject) {
    const oe = {};
    for (const ae in ne.shape) {
      const fe = ne.shape[ae];
      oe[ae] = ZodOptional.create(deepPartialify(fe));
    }
    return new ZodObject({
      ...ne._def,
      shape: () => oe
    });
  } else
    return ne instanceof ZodArray ? new ZodArray({
      ...ne._def,
      type: deepPartialify(ne.element)
    }) : ne instanceof ZodOptional ? ZodOptional.create(deepPartialify(ne.unwrap())) : ne instanceof ZodNullable ? ZodNullable.create(deepPartialify(ne.unwrap())) : ne instanceof ZodTuple ? ZodTuple.create(ne.items.map((oe) => deepPartialify(oe))) : ne;
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const oe = this._def.shape(), ae = util.objectKeys(oe);
    return this._cached = { shape: oe, keys: ae };
  }
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.object) {
      const $e = this._getOrReturnCtx(oe);
      return addIssueToContext($e, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: $e.parsedType
      }), INVALID;
    }
    const { status: fe, ctx: ye } = this._processInputParams(oe), { shape: we, keys: _e } = this._getCached(), xe = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (const $e in ye.data)
        _e.includes($e) || xe.push($e);
    const Oe = [];
    for (const $e of _e) {
      const Re = we[$e], Ne = ye.data[$e];
      Oe.push({
        key: { status: "valid", value: $e },
        value: Re._parse(new ParseInputLazyPath(ye, Ne, ye.path, $e)),
        alwaysSet: $e in ye.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const $e = this._def.unknownKeys;
      if ($e === "passthrough")
        for (const Re of xe)
          Oe.push({
            key: { status: "valid", value: Re },
            value: { status: "valid", value: ye.data[Re] }
          });
      else if ($e === "strict")
        xe.length > 0 && (addIssueToContext(ye, {
          code: ZodIssueCode.unrecognized_keys,
          keys: xe
        }), fe.dirty());
      else if ($e !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const $e = this._def.catchall;
      for (const Re of xe) {
        const Ne = ye.data[Re];
        Oe.push({
          key: { status: "valid", value: Re },
          value: $e._parse(
            new ParseInputLazyPath(ye, Ne, ye.path, Re)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: Re in ye.data
        });
      }
    }
    return ye.common.async ? Promise.resolve().then(async () => {
      const $e = [];
      for (const Re of Oe) {
        const Ne = await Re.key, je = await Re.value;
        $e.push({
          key: Ne,
          value: je,
          alwaysSet: Re.alwaysSet
        });
      }
      return $e;
    }).then(($e) => ParseStatus.mergeObjectSync(fe, $e)) : ParseStatus.mergeObjectSync(fe, Oe);
  }
  get shape() {
    return this._def.shape();
  }
  strict(oe) {
    return errorUtil.errToObj, new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...oe !== void 0 ? {
        errorMap: (ae, fe) => {
          var ye, we, _e, xe;
          const Oe = (_e = (we = (ye = this._def).errorMap) === null || we === void 0 ? void 0 : we.call(ye, ae, fe).message) !== null && _e !== void 0 ? _e : fe.defaultError;
          return ae.code === "unrecognized_keys" ? {
            message: (xe = errorUtil.errToObj(oe).message) !== null && xe !== void 0 ? xe : Oe
          } : {
            message: Oe
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(oe) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...oe
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(oe) {
    return new ZodObject({
      unknownKeys: oe._def.unknownKeys,
      catchall: oe._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...oe._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(oe, ae) {
    return this.augment({ [oe]: ae });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(oe) {
    return new ZodObject({
      ...this._def,
      catchall: oe
    });
  }
  pick(oe) {
    const ae = {};
    return util.objectKeys(oe).forEach((fe) => {
      oe[fe] && this.shape[fe] && (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  omit(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      oe[fe] || (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      const ye = this.shape[fe];
      oe && !oe[fe] ? ae[fe] = ye : ae[fe] = ye.optional();
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  required(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      if (oe && !oe[fe])
        ae[fe] = this.shape[fe];
      else {
        let we = this.shape[fe];
        for (; we instanceof ZodOptional; )
          we = we._def.innerType;
        ae[fe] = we;
      }
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.strictCreate = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.lazycreate = (ne, oe) => new ZodObject({
  shape: ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
class ZodUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = this._def.options;
    function ye(we) {
      for (const xe of we)
        if (xe.result.status === "valid")
          return xe.result;
      for (const xe of we)
        if (xe.result.status === "dirty")
          return ae.common.issues.push(...xe.ctx.common.issues), xe.result;
      const _e = we.map((xe) => new ZodError(xe.ctx.common.issues));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: _e
      }), INVALID;
    }
    if (ae.common.async)
      return Promise.all(fe.map(async (we) => {
        const _e = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await we._parseAsync({
            data: ae.data,
            path: ae.path,
            parent: _e
          }),
          ctx: _e
        };
      })).then(ye);
    {
      let we;
      const _e = [];
      for (const Oe of fe) {
        const $e = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        }, Re = Oe._parseSync({
          data: ae.data,
          path: ae.path,
          parent: $e
        });
        if (Re.status === "valid")
          return Re;
        Re.status === "dirty" && !we && (we = { result: Re, ctx: $e }), $e.common.issues.length && _e.push($e.common.issues);
      }
      if (we)
        return ae.common.issues.push(...we.ctx.common.issues), we.result;
      const xe = _e.map((Oe) => new ZodError(Oe));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: xe
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (ne, oe) => new ZodUnion({
  options: ne,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(oe)
});
const getDiscriminator = (ne) => ne instanceof ZodLazy ? getDiscriminator(ne.schema) : ne instanceof ZodEffects ? getDiscriminator(ne.innerType()) : ne instanceof ZodLiteral ? [ne.value] : ne instanceof ZodEnum ? ne.options : ne instanceof ZodNativeEnum ? util.objectValues(ne.enum) : ne instanceof ZodDefault ? getDiscriminator(ne._def.innerType) : ne instanceof ZodUndefined ? [void 0] : ne instanceof ZodNull ? [null] : ne instanceof ZodOptional ? [void 0, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodNullable ? [null, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodBranded || ne instanceof ZodReadonly ? getDiscriminator(ne.unwrap()) : ne instanceof ZodCatch ? getDiscriminator(ne._def.innerType) : [];
class ZodDiscriminatedUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.object)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ae.parsedType
      }), INVALID;
    const fe = this.discriminator, ye = ae.data[fe], we = this.optionsMap.get(ye);
    return we ? ae.common.async ? we._parseAsync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : we._parseSync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : (addIssueToContext(ae, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [fe]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(oe, ae, fe) {
    const ye = /* @__PURE__ */ new Map();
    for (const we of ae) {
      const _e = getDiscriminator(we.shape[oe]);
      if (!_e.length)
        throw new Error(`A discriminator value for key \`${oe}\` could not be extracted from all schema options`);
      for (const xe of _e) {
        if (ye.has(xe))
          throw new Error(`Discriminator property ${String(oe)} has duplicate value ${String(xe)}`);
        ye.set(xe, we);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: oe,
      options: ae,
      optionsMap: ye,
      ...processCreateParams(fe)
    });
  }
}
function mergeValues(ne, oe) {
  const ae = getParsedType(ne), fe = getParsedType(oe);
  if (ne === oe)
    return { valid: !0, data: ne };
  if (ae === ZodParsedType.object && fe === ZodParsedType.object) {
    const ye = util.objectKeys(oe), we = util.objectKeys(ne).filter((xe) => ye.indexOf(xe) !== -1), _e = { ...ne, ...oe };
    for (const xe of we) {
      const Oe = mergeValues(ne[xe], oe[xe]);
      if (!Oe.valid)
        return { valid: !1 };
      _e[xe] = Oe.data;
    }
    return { valid: !0, data: _e };
  } else if (ae === ZodParsedType.array && fe === ZodParsedType.array) {
    if (ne.length !== oe.length)
      return { valid: !1 };
    const ye = [];
    for (let we = 0; we < ne.length; we++) {
      const _e = ne[we], xe = oe[we], Oe = mergeValues(_e, xe);
      if (!Oe.valid)
        return { valid: !1 };
      ye.push(Oe.data);
    }
    return { valid: !0, data: ye };
  } else
    return ae === ZodParsedType.date && fe === ZodParsedType.date && +ne == +oe ? { valid: !0, data: ne } : { valid: !1 };
}
class ZodIntersection extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = (we, _e) => {
      if (isAborted(we) || isAborted(_e))
        return INVALID;
      const xe = mergeValues(we.value, _e.value);
      return xe.valid ? ((isDirty(we) || isDirty(_e)) && ae.dirty(), { status: ae.value, value: xe.data }) : (addIssueToContext(fe, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return fe.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      }),
      this._def.right._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      })
    ]).then(([we, _e]) => ye(we, _e)) : ye(this._def.left._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }), this._def.right._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }));
  }
}
ZodIntersection.create = (ne, oe, ae) => new ZodIntersection({
  left: ne,
  right: oe,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(ae)
});
class ZodTuple extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.array)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: fe.parsedType
      }), INVALID;
    if (fe.data.length < this._def.items.length)
      return addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && fe.data.length > this._def.items.length && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), ae.dirty());
    const we = [...fe.data].map((_e, xe) => {
      const Oe = this._def.items[xe] || this._def.rest;
      return Oe ? Oe._parse(new ParseInputLazyPath(fe, _e, fe.path, xe)) : null;
    }).filter((_e) => !!_e);
    return fe.common.async ? Promise.all(we).then((_e) => ParseStatus.mergeArray(ae, _e)) : ParseStatus.mergeArray(ae, we);
  }
  get items() {
    return this._def.items;
  }
  rest(oe) {
    return new ZodTuple({
      ...this._def,
      rest: oe
    });
  }
}
ZodTuple.create = (ne, oe) => {
  if (!Array.isArray(ne))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: ne,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(oe)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.object)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: fe.parsedType
      }), INVALID;
    const ye = [], we = this._def.keyType, _e = this._def.valueType;
    for (const xe in fe.data)
      ye.push({
        key: we._parse(new ParseInputLazyPath(fe, xe, fe.path, xe)),
        value: _e._parse(new ParseInputLazyPath(fe, fe.data[xe], fe.path, xe)),
        alwaysSet: xe in fe.data
      });
    return fe.common.async ? ParseStatus.mergeObjectAsync(ae, ye) : ParseStatus.mergeObjectSync(ae, ye);
  }
  get element() {
    return this._def.valueType;
  }
  static create(oe, ae, fe) {
    return ae instanceof ZodType ? new ZodRecord({
      keyType: oe,
      valueType: ae,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(fe)
    }) : new ZodRecord({
      keyType: ZodString.create(),
      valueType: oe,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(ae)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.map)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def.keyType, we = this._def.valueType, _e = [...fe.data.entries()].map(([xe, Oe], $e) => ({
      key: ye._parse(new ParseInputLazyPath(fe, xe, fe.path, [$e, "key"])),
      value: we._parse(new ParseInputLazyPath(fe, Oe, fe.path, [$e, "value"]))
    }));
    if (fe.common.async) {
      const xe = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const Oe of _e) {
          const $e = await Oe.key, Re = await Oe.value;
          if ($e.status === "aborted" || Re.status === "aborted")
            return INVALID;
          ($e.status === "dirty" || Re.status === "dirty") && ae.dirty(), xe.set($e.value, Re.value);
        }
        return { status: ae.value, value: xe };
      });
    } else {
      const xe = /* @__PURE__ */ new Map();
      for (const Oe of _e) {
        const $e = Oe.key, Re = Oe.value;
        if ($e.status === "aborted" || Re.status === "aborted")
          return INVALID;
        ($e.status === "dirty" || Re.status === "dirty") && ae.dirty(), xe.set($e.value, Re.value);
      }
      return { status: ae.value, value: xe };
    }
  }
}
ZodMap.create = (ne, oe, ae) => new ZodMap({
  valueType: oe,
  keyType: ne,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(ae)
});
class ZodSet extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.set)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def;
    ye.minSize !== null && fe.data.size < ye.minSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_small,
      minimum: ye.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.minSize.message
    }), ae.dirty()), ye.maxSize !== null && fe.data.size > ye.maxSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.maxSize.message
    }), ae.dirty());
    const we = this._def.valueType;
    function _e(Oe) {
      const $e = /* @__PURE__ */ new Set();
      for (const Re of Oe) {
        if (Re.status === "aborted")
          return INVALID;
        Re.status === "dirty" && ae.dirty(), $e.add(Re.value);
      }
      return { status: ae.value, value: $e };
    }
    const xe = [...fe.data.values()].map((Oe, $e) => we._parse(new ParseInputLazyPath(fe, Oe, fe.path, $e)));
    return fe.common.async ? Promise.all(xe).then((Oe) => _e(Oe)) : _e(xe);
  }
  min(oe, ae) {
    return new ZodSet({
      ...this._def,
      minSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  size(oe, ae) {
    return this.min(oe, ae).max(oe, ae);
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodSet.create = (ne, oe) => new ZodSet({
  valueType: ne,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(oe)
});
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.function)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ae.parsedType
      }), INVALID;
    function fe(xe, Oe) {
      return makeIssue({
        data: xe,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter(($e) => !!$e),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: Oe
        }
      });
    }
    function ye(xe, Oe) {
      return makeIssue({
        data: xe,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter(($e) => !!$e),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: Oe
        }
      });
    }
    const we = { errorMap: ae.common.contextualErrorMap }, _e = ae.data;
    if (this._def.returns instanceof ZodPromise) {
      const xe = this;
      return OK(async function(...Oe) {
        const $e = new ZodError([]), Re = await xe._def.args.parseAsync(Oe, we).catch((Be) => {
          throw $e.addIssue(fe(Oe, Be)), $e;
        }), Ne = await Reflect.apply(_e, this, Re);
        return await xe._def.returns._def.type.parseAsync(Ne, we).catch((Be) => {
          throw $e.addIssue(ye(Ne, Be)), $e;
        });
      });
    } else {
      const xe = this;
      return OK(function(...Oe) {
        const $e = xe._def.args.safeParse(Oe, we);
        if (!$e.success)
          throw new ZodError([fe(Oe, $e.error)]);
        const Re = Reflect.apply(_e, this, $e.data), Ne = xe._def.returns.safeParse(Re, we);
        if (!Ne.success)
          throw new ZodError([ye(Re, Ne.error)]);
        return Ne.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...oe) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(oe).rest(ZodUnknown.create())
    });
  }
  returns(oe) {
    return new ZodFunction({
      ...this._def,
      returns: oe
    });
  }
  implement(oe) {
    return this.parse(oe);
  }
  strictImplement(oe) {
    return this.parse(oe);
  }
  static create(oe, ae, fe) {
    return new ZodFunction({
      args: oe || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: ae || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(fe)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    return this._def.getter()._parse({ data: ae.data, path: ae.path, parent: ae });
  }
}
ZodLazy.create = (ne, oe) => new ZodLazy({
  getter: ne,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(oe)
});
class ZodLiteral extends ZodType {
  _parse(oe) {
    if (oe.data !== this._def.value) {
      const ae = this._getOrReturnCtx(oe);
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (ne, oe) => new ZodLiteral({
  value: ne,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(oe)
});
function createZodEnum(ne, oe) {
  return new ZodEnum({
    values: ne,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(oe)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    if (typeof oe.data != "string") {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        expected: util.joinValues(fe),
        received: ae.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodEnum_cache, new Set(this._def.values), "f"), !__classPrivateFieldGet$2(this, _ZodEnum_cache, "f").has(oe.data)) {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_enum_value,
        options: fe
      }), INVALID;
    }
    return OK(oe.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Values() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  extract(oe, ae = this._def) {
    return ZodEnum.create(oe, {
      ...this._def,
      ...ae
    });
  }
  exclude(oe, ae = this._def) {
    return ZodEnum.create(this.options.filter((fe) => !oe.includes(fe)), {
      ...this._def,
      ...ae
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    const ae = util.getValidEnumValues(this._def.values), fe = this._getOrReturnCtx(oe);
    if (fe.parsedType !== ZodParsedType.string && fe.parsedType !== ZodParsedType.number) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        expected: util.joinValues(ye),
        received: fe.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f"), !__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f").has(oe.data)) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        received: fe.data,
        code: ZodIssueCode.invalid_enum_value,
        options: ye
      }), INVALID;
    }
    return OK(oe.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (ne, oe) => new ZodNativeEnum({
  values: ne,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(oe)
});
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.promise && ae.common.async === !1)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ae.parsedType
      }), INVALID;
    const fe = ae.parsedType === ZodParsedType.promise ? ae.data : Promise.resolve(ae.data);
    return OK(fe.then((ye) => this._def.type.parseAsync(ye, {
      path: ae.path,
      errorMap: ae.common.contextualErrorMap
    })));
  }
}
ZodPromise.create = (ne, oe) => new ZodPromise({
  type: ne,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(oe)
});
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = this._def.effect || null, we = {
      addIssue: (_e) => {
        addIssueToContext(fe, _e), _e.fatal ? ae.abort() : ae.dirty();
      },
      get path() {
        return fe.path;
      }
    };
    if (we.addIssue = we.addIssue.bind(we), ye.type === "preprocess") {
      const _e = ye.transform(fe.data, we);
      if (fe.common.async)
        return Promise.resolve(_e).then(async (xe) => {
          if (ae.value === "aborted")
            return INVALID;
          const Oe = await this._def.schema._parseAsync({
            data: xe,
            path: fe.path,
            parent: fe
          });
          return Oe.status === "aborted" ? INVALID : Oe.status === "dirty" || ae.value === "dirty" ? DIRTY(Oe.value) : Oe;
        });
      {
        if (ae.value === "aborted")
          return INVALID;
        const xe = this._def.schema._parseSync({
          data: _e,
          path: fe.path,
          parent: fe
        });
        return xe.status === "aborted" ? INVALID : xe.status === "dirty" || ae.value === "dirty" ? DIRTY(xe.value) : xe;
      }
    }
    if (ye.type === "refinement") {
      const _e = (xe) => {
        const Oe = ye.refinement(xe, we);
        if (fe.common.async)
          return Promise.resolve(Oe);
        if (Oe instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return xe;
      };
      if (fe.common.async === !1) {
        const xe = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return xe.status === "aborted" ? INVALID : (xe.status === "dirty" && ae.dirty(), _e(xe.value), { status: ae.value, value: xe.value });
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((xe) => xe.status === "aborted" ? INVALID : (xe.status === "dirty" && ae.dirty(), _e(xe.value).then(() => ({ status: ae.value, value: xe.value }))));
    }
    if (ye.type === "transform")
      if (fe.common.async === !1) {
        const _e = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        if (!isValid(_e))
          return _e;
        const xe = ye.transform(_e.value, we);
        if (xe instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: ae.value, value: xe };
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((_e) => isValid(_e) ? Promise.resolve(ye.transform(_e.value, we)).then((xe) => ({ status: ae.value, value: xe })) : _e);
    util.assertNever(ye);
  }
}
ZodEffects.create = (ne, oe, ae) => new ZodEffects({
  schema: ne,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect: oe,
  ...processCreateParams(ae)
});
ZodEffects.createWithPreprocess = (ne, oe, ae) => new ZodEffects({
  schema: oe,
  effect: { type: "preprocess", transform: ne },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(ae)
});
class ZodOptional extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (ne, oe) => new ZodOptional({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(oe)
});
class ZodNullable extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (ne, oe) => new ZodNullable({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(oe)
});
class ZodDefault extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    let fe = ae.data;
    return ae.parsedType === ZodParsedType.undefined && (fe = this._def.defaultValue()), this._def.innerType._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (ne, oe) => new ZodDefault({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof oe.default == "function" ? oe.default : () => oe.default,
  ...processCreateParams(oe)
});
class ZodCatch extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = {
      ...ae,
      common: {
        ...ae.common,
        issues: []
      }
    }, ye = this._def.innerType._parse({
      data: fe.data,
      path: fe.path,
      parent: {
        ...fe
      }
    });
    return isAsync(ye) ? ye.then((we) => ({
      status: "valid",
      value: we.status === "valid" ? we.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    })) : {
      status: "valid",
      value: ye.status === "valid" ? ye.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (ne, oe) => new ZodCatch({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof oe.catch == "function" ? oe.catch : () => oe.catch,
  ...processCreateParams(oe)
});
class ZodNaN extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.nan) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: fe.parsedType
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
}
ZodNaN.create = (ne) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(ne)
});
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = ae.data;
    return this._def.type._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.common.async)
      return (async () => {
        const we = await this._def.in._parseAsync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return we.status === "aborted" ? INVALID : we.status === "dirty" ? (ae.dirty(), DIRTY(we.value)) : this._def.out._parseAsync({
          data: we.value,
          path: fe.path,
          parent: fe
        });
      })();
    {
      const ye = this._def.in._parseSync({
        data: fe.data,
        path: fe.path,
        parent: fe
      });
      return ye.status === "aborted" ? INVALID : ye.status === "dirty" ? (ae.dirty(), {
        status: "dirty",
        value: ye.value
      }) : this._def.out._parseSync({
        data: ye.value,
        path: fe.path,
        parent: fe
      });
    }
  }
  static create(oe, ae) {
    return new ZodPipeline({
      in: oe,
      out: ae,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(oe) {
    const ae = this._def.innerType._parse(oe), fe = (ye) => (isValid(ye) && (ye.value = Object.freeze(ye.value)), ye);
    return isAsync(ae) ? ae.then((ye) => fe(ye)) : fe(ae);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (ne, oe) => new ZodReadonly({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(oe)
});
function custom(ne, oe = {}, ae) {
  return ne ? ZodAny.create().superRefine((fe, ye) => {
    var we, _e;
    if (!ne(fe)) {
      const xe = typeof oe == "function" ? oe(fe) : typeof oe == "string" ? { message: oe } : oe, Oe = (_e = (we = xe.fatal) !== null && we !== void 0 ? we : ae) !== null && _e !== void 0 ? _e : !0, $e = typeof xe == "string" ? { message: xe } : xe;
      ye.addIssue({ code: "custom", ...$e, fatal: Oe });
    }
  }) : ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ne) {
  ne.ZodString = "ZodString", ne.ZodNumber = "ZodNumber", ne.ZodNaN = "ZodNaN", ne.ZodBigInt = "ZodBigInt", ne.ZodBoolean = "ZodBoolean", ne.ZodDate = "ZodDate", ne.ZodSymbol = "ZodSymbol", ne.ZodUndefined = "ZodUndefined", ne.ZodNull = "ZodNull", ne.ZodAny = "ZodAny", ne.ZodUnknown = "ZodUnknown", ne.ZodNever = "ZodNever", ne.ZodVoid = "ZodVoid", ne.ZodArray = "ZodArray", ne.ZodObject = "ZodObject", ne.ZodUnion = "ZodUnion", ne.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ne.ZodIntersection = "ZodIntersection", ne.ZodTuple = "ZodTuple", ne.ZodRecord = "ZodRecord", ne.ZodMap = "ZodMap", ne.ZodSet = "ZodSet", ne.ZodFunction = "ZodFunction", ne.ZodLazy = "ZodLazy", ne.ZodLiteral = "ZodLiteral", ne.ZodEnum = "ZodEnum", ne.ZodEffects = "ZodEffects", ne.ZodNativeEnum = "ZodNativeEnum", ne.ZodOptional = "ZodOptional", ne.ZodNullable = "ZodNullable", ne.ZodDefault = "ZodDefault", ne.ZodCatch = "ZodCatch", ne.ZodPromise = "ZodPromise", ne.ZodBranded = "ZodBranded", ne.ZodPipeline = "ZodPipeline", ne.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (ne, oe = {
  message: `Input not instance of ${ne.name}`
}) => custom((ae) => ae instanceof ne, oe), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = {
  string: (ne) => ZodString.create({ ...ne, coerce: !0 }),
  number: (ne) => ZodNumber.create({ ...ne, coerce: !0 }),
  boolean: (ne) => ZodBoolean.create({
    ...ne,
    coerce: !0
  }),
  bigint: (ne) => ZodBigInt.create({ ...ne, coerce: !0 }),
  date: (ne) => ZodDate.create({ ...ne, coerce: !0 })
}, NEVER = INVALID;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
z$2.object({ chainId: z$2.number(), address: z$2.string().refine(isHex$1).optional(), filters: z$2.array(z$2.object({ tableId: z$2.string().refine(isHex$1), key0: z$2.string().refine(isHex$1).optional(), key1: z$2.string().refine(isHex$1).optional() })).default([]) });
function invert(ne) {
  const oe = /* @__PURE__ */ Object.create(null);
  for (const ae in ne) {
    const fe = ne[ae];
    oe[fe] = ae;
  }
  return oe;
}
const TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);
invert(TRPC_ERROR_CODES_BY_KEY);
const noop$2 = () => {
};
function createInnerProxy(ne, oe) {
  return new Proxy(noop$2, {
    get(fe, ye) {
      if (!(typeof ye != "string" || ye === "then"))
        return createInnerProxy(ne, [
          ...oe,
          ye
        ]);
    },
    apply(fe, ye, we) {
      const _e = oe[oe.length - 1] === "apply";
      return ne({
        args: _e ? we.length >= 2 ? we[1] : [] : we,
        path: _e ? oe.slice(0, -1) : oe
      });
    }
  });
}
const createRecursiveProxy = (ne) => createInnerProxy(ne, []), createFlatProxy = (ne) => new Proxy(noop$2, {
  get(oe, ae) {
    if (!(typeof ae != "string" || ae === "then"))
      return ne(ae);
  }
});
var rO, oO, aO, iO, sO, uO;
typeof window > "u" || "Deno" in window || ((oO = (rO = globalThis.process) == null ? void 0 : rO.env) == null ? void 0 : oO.NODE_ENV) === "test" || (iO = (aO = globalThis.process) == null ? void 0 : aO.env) != null && iO.JEST_WORKER_ID || (uO = (sO = globalThis.process) == null ? void 0 : sO.env) != null && uO.VITEST_WORKER_ID;
var DoubleIndexedKV = (
  /** @class */
  function() {
    function ne() {
      this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
    }
    return ne.prototype.set = function(oe, ae) {
      this.keyToValue.set(oe, ae), this.valueToKey.set(ae, oe);
    }, ne.prototype.getByKey = function(oe) {
      return this.keyToValue.get(oe);
    }, ne.prototype.getByValue = function(oe) {
      return this.valueToKey.get(oe);
    }, ne.prototype.clear = function() {
      this.keyToValue.clear(), this.valueToKey.clear();
    }, ne;
  }()
), Registry = (
  /** @class */
  function() {
    function ne(oe) {
      this.generateIdentifier = oe, this.kv = new DoubleIndexedKV();
    }
    return ne.prototype.register = function(oe, ae) {
      this.kv.getByValue(oe) || (ae || (ae = this.generateIdentifier(oe)), this.kv.set(ae, oe));
    }, ne.prototype.clear = function() {
      this.kv.clear();
    }, ne.prototype.getIdentifier = function(oe) {
      return this.kv.getByValue(oe);
    }, ne.prototype.getValue = function(oe) {
      return this.kv.getByKey(oe);
    }, ne;
  }()
), __extends$1 = globalThis && globalThis.__extends || function() {
  var ne = function(oe, ae) {
    return ne = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ye) {
      fe.__proto__ = ye;
    } || function(fe, ye) {
      for (var we in ye)
        Object.prototype.hasOwnProperty.call(ye, we) && (fe[we] = ye[we]);
    }, ne(oe, ae);
  };
  return function(oe, ae) {
    if (typeof ae != "function" && ae !== null)
      throw new TypeError("Class extends value " + String(ae) + " is not a constructor or null");
    ne(oe, ae);
    function fe() {
      this.constructor = oe;
    }
    oe.prototype = ae === null ? Object.create(ae) : (fe.prototype = ae.prototype, new fe());
  };
}(), ClassRegistry = (
  /** @class */
  function(ne) {
    __extends$1(oe, ne);
    function oe() {
      var ae = ne.call(this, function(fe) {
        return fe.name;
      }) || this;
      return ae.classToAllowedProps = /* @__PURE__ */ new Map(), ae;
    }
    return oe.prototype.register = function(ae, fe) {
      typeof fe == "object" ? (fe.allowProps && this.classToAllowedProps.set(ae, fe.allowProps), ne.prototype.register.call(this, ae, fe.identifier)) : ne.prototype.register.call(this, ae, fe);
    }, oe.prototype.getAllowedProps = function(ae) {
      return this.classToAllowedProps.get(ae);
    }, oe;
  }(Registry)
), __read$4 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, we = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      we.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return we;
};
function valuesOfObj(ne) {
  if ("values" in Object)
    return Object.values(ne);
  var oe = [];
  for (var ae in ne)
    ne.hasOwnProperty(ae) && oe.push(ne[ae]);
  return oe;
}
function find(ne, oe) {
  var ae = valuesOfObj(ne);
  if ("find" in ae)
    return ae.find(oe);
  for (var fe = ae, ye = 0; ye < fe.length; ye++) {
    var we = fe[ye];
    if (oe(we))
      return we;
  }
}
function forEach(ne, oe) {
  Object.entries(ne).forEach(function(ae) {
    var fe = __read$4(ae, 2), ye = fe[0], we = fe[1];
    return oe(we, ye);
  });
}
function includes(ne, oe) {
  return ne.indexOf(oe) !== -1;
}
function findArr(ne, oe) {
  for (var ae = 0; ae < ne.length; ae++) {
    var fe = ne[ae];
    if (oe(fe))
      return fe;
  }
}
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function ne() {
      this.transfomers = {};
    }
    return ne.prototype.register = function(oe) {
      this.transfomers[oe.name] = oe;
    }, ne.prototype.findApplicable = function(oe) {
      return find(this.transfomers, function(ae) {
        return ae.isApplicable(oe);
      });
    }, ne.prototype.findByName = function(oe) {
      return this.transfomers[oe];
    }, ne;
  }()
), getType$1 = function(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}, isUndefined = function(ne) {
  return typeof ne > "u";
}, isNull = function(ne) {
  return ne === null;
}, isPlainObject$2 = function(ne) {
  return typeof ne != "object" || ne === null || ne === Object.prototype ? !1 : Object.getPrototypeOf(ne) === null ? !0 : Object.getPrototypeOf(ne) === Object.prototype;
}, isEmptyObject = function(ne) {
  return isPlainObject$2(ne) && Object.keys(ne).length === 0;
}, isArray$3 = function(ne) {
  return Array.isArray(ne);
}, isString = function(ne) {
  return typeof ne == "string";
}, isNumber = function(ne) {
  return typeof ne == "number" && !isNaN(ne);
}, isBoolean = function(ne) {
  return typeof ne == "boolean";
}, isRegExp = function(ne) {
  return ne instanceof RegExp;
}, isMap = function(ne) {
  return ne instanceof Map;
}, isSet = function(ne) {
  return ne instanceof Set;
}, isSymbol = function(ne) {
  return getType$1(ne) === "Symbol";
}, isDate = function(ne) {
  return ne instanceof Date && !isNaN(ne.valueOf());
}, isError = function(ne) {
  return ne instanceof Error;
}, isNaNValue = function(ne) {
  return typeof ne == "number" && isNaN(ne);
}, isPrimitive = function(ne) {
  return isBoolean(ne) || isNull(ne) || isUndefined(ne) || isNumber(ne) || isString(ne) || isSymbol(ne);
}, isBigint = function(ne) {
  return typeof ne == "bigint";
}, isInfinite = function(ne) {
  return ne === 1 / 0 || ne === -1 / 0;
}, isTypedArray = function(ne) {
  return ArrayBuffer.isView(ne) && !(ne instanceof DataView);
}, isURL = function(ne) {
  return ne instanceof URL;
}, escapeKey = function(ne) {
  return ne.replace(/\./g, "\\.");
}, stringifyPath = function(ne) {
  return ne.map(String).map(escapeKey).join(".");
}, parsePath = function(ne) {
  for (var oe = [], ae = "", fe = 0; fe < ne.length; fe++) {
    var ye = ne.charAt(fe), we = ye === "\\" && ne.charAt(fe + 1) === ".";
    if (we) {
      ae += ".", fe++;
      continue;
    }
    var _e = ye === ".";
    if (_e) {
      oe.push(ae), ae = "";
      continue;
    }
    ae += ye;
  }
  var xe = ae;
  return oe.push(xe), oe;
}, __assign$1 = globalThis && globalThis.__assign || function() {
  return __assign$1 = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign$1.apply(this, arguments);
}, __read$3 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, we = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      we.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return we;
}, __spreadArray$3 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function simpleTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
  }),
  simpleTransformation(isBigint, "bigint", function(ne) {
    return ne.toString();
  }, function(ne) {
    return typeof BigInt < "u" ? BigInt(ne) : (console.error("Please add a BigInt polyfill."), ne);
  }),
  simpleTransformation(isDate, "Date", function(ne) {
    return ne.toISOString();
  }, function(ne) {
    return new Date(ne);
  }),
  simpleTransformation(isError, "Error", function(ne, oe) {
    var ae = {
      name: ne.name,
      message: ne.message
    };
    return oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }, function(ne, oe) {
    var ae = new Error(ne.message);
    return ae.name = ne.name, ae.stack = ne.stack, oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }),
  simpleTransformation(isRegExp, "regexp", function(ne) {
    return "" + ne;
  }, function(ne) {
    var oe = ne.slice(1, ne.lastIndexOf("/")), ae = ne.slice(ne.lastIndexOf("/") + 1);
    return new RegExp(oe, ae);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(ne) {
      return __spreadArray$3([], __read$3(ne.values()));
    },
    function(ne) {
      return new Set(ne);
    }
  ),
  simpleTransformation(isMap, "map", function(ne) {
    return __spreadArray$3([], __read$3(ne.entries()));
  }, function(ne) {
    return new Map(ne);
  }),
  simpleTransformation(function(ne) {
    return isNaNValue(ne) || isInfinite(ne);
  }, "number", function(ne) {
    return isNaNValue(ne) ? "NaN" : ne > 0 ? "Infinity" : "-Infinity";
  }, Number),
  simpleTransformation(function(ne) {
    return ne === 0 && 1 / ne === -1 / 0;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(ne) {
    return ne.toString();
  }, function(ne) {
    return new URL(ne);
  })
];
function compositeTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var symbolRule = compositeTransformation(function(ne, oe) {
  if (isSymbol(ne)) {
    var ae = !!oe.symbolRegistry.getIdentifier(ne);
    return ae;
  }
  return !1;
}, function(ne, oe) {
  var ae = oe.symbolRegistry.getIdentifier(ne);
  return ["symbol", ae];
}, function(ne) {
  return ne.description;
}, function(ne, oe, ae) {
  var fe = ae.symbolRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown symbol");
  return fe;
}), constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(ne, oe) {
  return ne[oe.name] = oe, ne;
}, {}), typedArrayRule = compositeTransformation(isTypedArray, function(ne) {
  return ["typed-array", ne.constructor.name];
}, function(ne) {
  return __spreadArray$3([], __read$3(ne));
}, function(ne, oe) {
  var ae = constructorToName[oe[1]];
  if (!ae)
    throw new Error("Trying to deserialize unknown typed array");
  return new ae(ne);
});
function isInstanceOfRegisteredClass(ne, oe) {
  if (ne != null && ne.constructor) {
    var ae = !!oe.classRegistry.getIdentifier(ne.constructor);
    return ae;
  }
  return !1;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(ne, oe) {
  var ae = oe.classRegistry.getIdentifier(ne.constructor);
  return ["class", ae];
}, function(ne, oe) {
  var ae = oe.classRegistry.getAllowedProps(ne.constructor);
  if (!ae)
    return __assign$1({}, ne);
  var fe = {};
  return ae.forEach(function(ye) {
    fe[ye] = ne[ye];
  }), fe;
}, function(ne, oe, ae) {
  var fe = ae.classRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  return Object.assign(Object.create(fe.prototype), ne);
}), customRule = compositeTransformation(function(ne, oe) {
  return !!oe.customTransformerRegistry.findApplicable(ne);
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ["custom", ae.name];
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ae.serialize(ne);
}, function(ne, oe, ae) {
  var fe = ae.customTransformerRegistry.findByName(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown custom value");
  return fe.deserialize(ne);
}), compositeRules = [classRule, symbolRule, customRule, typedArrayRule], transformValue = function(ne, oe) {
  var ae = findArr(compositeRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (ae)
    return {
      value: ae.transform(ne, oe),
      type: ae.annotation(ne, oe)
    };
  var fe = findArr(simpleRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (fe)
    return {
      value: fe.transform(ne, oe),
      type: fe.annotation
    };
}, simpleRulesByAnnotation = {};
simpleRules.forEach(function(ne) {
  simpleRulesByAnnotation[ne.annotation] = ne;
});
var untransformValue = function(ne, oe, ae) {
  if (isArray$3(oe))
    switch (oe[0]) {
      case "symbol":
        return symbolRule.untransform(ne, oe, ae);
      case "class":
        return classRule.untransform(ne, oe, ae);
      case "custom":
        return customRule.untransform(ne, oe, ae);
      case "typed-array":
        return typedArrayRule.untransform(ne, oe, ae);
      default:
        throw new Error("Unknown transformation: " + oe);
    }
  else {
    var fe = simpleRulesByAnnotation[oe];
    if (!fe)
      throw new Error("Unknown transformation: " + oe);
    return fe.untransform(ne, ae);
  }
}, getNthKey = function(ne, oe) {
  for (var ae = ne.keys(); oe > 0; )
    ae.next(), oe--;
  return ae.next().value;
};
function validatePath(ne) {
  if (includes(ne, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (includes(ne, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (includes(ne, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var getDeep = function(ne, oe) {
  validatePath(oe);
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    if (isSet(ne))
      ne = getNthKey(ne, +fe);
    else if (isMap(ne)) {
      var ye = +fe, we = +oe[++ae] == 0 ? "key" : "value", _e = getNthKey(ne, ye);
      switch (we) {
        case "key":
          ne = _e;
          break;
        case "value":
          ne = ne.get(_e);
          break;
      }
    } else
      ne = ne[fe];
  }
  return ne;
}, setDeep = function(ne, oe, ae) {
  if (validatePath(oe), oe.length === 0)
    return ae(ne);
  for (var fe = ne, ye = 0; ye < oe.length - 1; ye++) {
    var we = oe[ye];
    if (isArray$3(fe)) {
      var _e = +we;
      fe = fe[_e];
    } else if (isPlainObject$2(fe))
      fe = fe[we];
    else if (isSet(fe)) {
      var xe = +we;
      fe = getNthKey(fe, xe);
    } else if (isMap(fe)) {
      var Oe = ye === oe.length - 2;
      if (Oe)
        break;
      var xe = +we, $e = +oe[++ye] == 0 ? "key" : "value", Re = getNthKey(fe, xe);
      switch ($e) {
        case "key":
          fe = Re;
          break;
        case "value":
          fe = fe.get(Re);
          break;
      }
    }
  }
  var Ne = oe[oe.length - 1];
  if (isArray$3(fe) ? fe[+Ne] = ae(fe[+Ne]) : isPlainObject$2(fe) && (fe[Ne] = ae(fe[Ne])), isSet(fe)) {
    var je = getNthKey(fe, +Ne), Be = ae(je);
    je !== Be && (fe.delete(je), fe.add(Be));
  }
  if (isMap(fe)) {
    var xe = +oe[oe.length - 2], ze = getNthKey(fe, xe), $e = +Ne == 0 ? "key" : "value";
    switch ($e) {
      case "key": {
        var He = ae(ze);
        fe.set(He, fe.get(ze)), He !== ze && fe.delete(ze);
        break;
      }
      case "value": {
        fe.set(ze, ae(fe.get(ze)));
        break;
      }
    }
  }
  return ne;
}, __read$2 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, we = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      we.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return we;
}, __spreadArray$2 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function traverse(ne, oe, ae) {
  if (ae === void 0 && (ae = []), !!ne) {
    if (!isArray$3(ne)) {
      forEach(ne, function(_e, xe) {
        return traverse(_e, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(xe))));
      });
      return;
    }
    var fe = __read$2(ne, 2), ye = fe[0], we = fe[1];
    we && forEach(we, function(_e, xe) {
      traverse(_e, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(xe))));
    }), oe(ye, ae);
  }
}
function applyValueAnnotations(ne, oe, ae) {
  return traverse(oe, function(fe, ye) {
    ne = setDeep(ne, ye, function(we) {
      return untransformValue(we, fe, ae);
    });
  }), ne;
}
function applyReferentialEqualityAnnotations(ne, oe) {
  function ae(_e, xe) {
    var Oe = getDeep(ne, parsePath(xe));
    _e.map(parsePath).forEach(function($e) {
      ne = setDeep(ne, $e, function() {
        return Oe;
      });
    });
  }
  if (isArray$3(oe)) {
    var fe = __read$2(oe, 2), ye = fe[0], we = fe[1];
    ye.forEach(function(_e) {
      ne = setDeep(ne, parsePath(_e), function() {
        return ne;
      });
    }), we && forEach(we, ae);
  } else
    forEach(oe, ae);
  return ne;
}
var isDeep = function(ne, oe) {
  return isPlainObject$2(ne) || isArray$3(ne) || isMap(ne) || isSet(ne) || isInstanceOfRegisteredClass(ne, oe);
};
function addIdentity(ne, oe, ae) {
  var fe = ae.get(ne);
  fe ? fe.push(oe) : ae.set(ne, [oe]);
}
function generateReferentialEqualityAnnotations(ne, oe) {
  var ae = {}, fe = void 0;
  return ne.forEach(function(ye) {
    if (!(ye.length <= 1)) {
      oe || (ye = ye.map(function(Oe) {
        return Oe.map(String);
      }).sort(function(Oe, $e) {
        return Oe.length - $e.length;
      }));
      var we = __read$2(ye), _e = we[0], xe = we.slice(1);
      _e.length === 0 ? fe = xe.map(stringifyPath) : ae[stringifyPath(_e)] = xe.map(stringifyPath);
    }
  }), fe ? isEmptyObject(ae) ? [fe] : [fe, ae] : isEmptyObject(ae) ? void 0 : ae;
}
var walker = function(ne, oe, ae, fe, ye, we, _e) {
  var xe;
  ye === void 0 && (ye = []), we === void 0 && (we = []), _e === void 0 && (_e = /* @__PURE__ */ new Map());
  var Oe = isPrimitive(ne);
  if (!Oe) {
    addIdentity(ne, ye, oe);
    var $e = _e.get(ne);
    if ($e)
      return fe ? {
        transformedValue: null
      } : $e;
  }
  if (!isDeep(ne, ae)) {
    var Re = transformValue(ne, ae), Ne = Re ? {
      transformedValue: Re.value,
      annotations: [Re.type]
    } : {
      transformedValue: ne
    };
    return Oe || _e.set(ne, Ne), Ne;
  }
  if (includes(we, ne))
    return {
      transformedValue: null
    };
  var je = transformValue(ne, ae), Be = (xe = je == null ? void 0 : je.value) !== null && xe !== void 0 ? xe : ne, ze = isArray$3(Be) ? [] : {}, He = {};
  forEach(Be, function(Ye, ot) {
    var tt = walker(Ye, oe, ae, fe, __spreadArray$2(__spreadArray$2([], __read$2(ye)), [ot]), __spreadArray$2(__spreadArray$2([], __read$2(we)), [ne]), _e);
    ze[ot] = tt.transformedValue, isArray$3(tt.annotations) ? He[ot] = tt.annotations : isPlainObject$2(tt.annotations) && forEach(tt.annotations, function(it, ht) {
      He[escapeKey(ot) + "." + ht] = it;
    });
  });
  var qe = isEmptyObject(He) ? {
    transformedValue: ze,
    annotations: je ? [je.type] : void 0
  } : {
    transformedValue: ze,
    annotations: je ? [je.type, He] : He
  };
  return Oe || _e.set(ne, qe), qe;
};
function getType(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}
function isArray$2(ne) {
  return getType(ne) === "Array";
}
function isPlainObject$1(ne) {
  if (getType(ne) !== "Object")
    return !1;
  const oe = Object.getPrototypeOf(ne);
  return !!oe && oe.constructor === Object && oe === Object.prototype;
}
function assignProp(ne, oe, ae, fe, ye) {
  const we = {}.propertyIsEnumerable.call(fe, oe) ? "enumerable" : "nonenumerable";
  we === "enumerable" && (ne[oe] = ae), ye && we === "nonenumerable" && Object.defineProperty(ne, oe, {
    value: ae,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function copy(ne, oe = {}) {
  if (isArray$2(ne))
    return ne.map((ye) => copy(ye, oe));
  if (!isPlainObject$1(ne))
    return ne;
  const ae = Object.getOwnPropertyNames(ne), fe = Object.getOwnPropertySymbols(ne);
  return [...ae, ...fe].reduce((ye, we) => {
    if (isArray$2(oe.props) && !oe.props.includes(we))
      return ye;
    const _e = ne[we], xe = copy(_e, oe);
    return assignProp(ye, we, xe, ne, oe.nonenumerable), ye;
  }, {});
}
var __assign = globalThis && globalThis.__assign || function() {
  return __assign = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign.apply(this, arguments);
}, __read$1 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, we = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      we.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return we;
}, __spreadArray$1 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
}, SuperJSON = (
  /** @class */
  function() {
    function ne(oe) {
      var ae = oe === void 0 ? {} : oe, fe = ae.dedupe, ye = fe === void 0 ? !1 : fe;
      this.classRegistry = new ClassRegistry(), this.symbolRegistry = new Registry(function(we) {
        var _e;
        return (_e = we.description) !== null && _e !== void 0 ? _e : "";
      }), this.customTransformerRegistry = new CustomTransformerRegistry(), this.allowedErrorProps = [], this.dedupe = ye;
    }
    return ne.prototype.serialize = function(oe) {
      var ae = /* @__PURE__ */ new Map(), fe = walker(oe, ae, this, this.dedupe), ye = {
        json: fe.transformedValue
      };
      fe.annotations && (ye.meta = __assign(__assign({}, ye.meta), { values: fe.annotations }));
      var we = generateReferentialEqualityAnnotations(ae, this.dedupe);
      return we && (ye.meta = __assign(__assign({}, ye.meta), { referentialEqualities: we })), ye;
    }, ne.prototype.deserialize = function(oe) {
      var ae = oe.json, fe = oe.meta, ye = copy(ae);
      return fe != null && fe.values && (ye = applyValueAnnotations(ye, fe.values, this)), fe != null && fe.referentialEqualities && (ye = applyReferentialEqualityAnnotations(ye, fe.referentialEqualities)), ye;
    }, ne.prototype.stringify = function(oe) {
      return JSON.stringify(this.serialize(oe));
    }, ne.prototype.parse = function(oe) {
      return this.deserialize(JSON.parse(oe));
    }, ne.prototype.registerClass = function(oe, ae) {
      this.classRegistry.register(oe, ae);
    }, ne.prototype.registerSymbol = function(oe, ae) {
      this.symbolRegistry.register(oe, ae);
    }, ne.prototype.registerCustom = function(oe, ae) {
      this.customTransformerRegistry.register(__assign({ name: ae }, oe));
    }, ne.prototype.allowErrorProps = function() {
      for (var oe, ae = [], fe = 0; fe < arguments.length; fe++)
        ae[fe] = arguments[fe];
      (oe = this.allowedErrorProps).push.apply(oe, __spreadArray$1([], __read$1(ae)));
    }, ne.defaultInstance = new ne(), ne.serialize = ne.defaultInstance.serialize.bind(ne.defaultInstance), ne.deserialize = ne.defaultInstance.deserialize.bind(ne.defaultInstance), ne.stringify = ne.defaultInstance.stringify.bind(ne.defaultInstance), ne.parse = ne.defaultInstance.parse.bind(ne.defaultInstance), ne.registerClass = ne.defaultInstance.registerClass.bind(ne.defaultInstance), ne.registerSymbol = ne.defaultInstance.registerSymbol.bind(ne.defaultInstance), ne.registerCustom = ne.defaultInstance.registerCustom.bind(ne.defaultInstance), ne.allowErrorProps = ne.defaultInstance.allowErrorProps.bind(ne.defaultInstance), ne;
  }()
);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
function identity$2(ne) {
  return ne;
}
function pipeFromArray$1(ne) {
  return ne.length === 0 ? identity$2 : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce((fe, ye) => ye(fe), ae);
  };
}
function observable$2(ne) {
  const oe = {
    subscribe(ae) {
      let fe = null, ye = !1, we = !1, _e = !1;
      function xe() {
        if (fe === null) {
          _e = !0;
          return;
        }
        we || (we = !0, typeof fe == "function" ? fe() : fe && fe.unsubscribe());
      }
      return fe = ne({
        next(Oe) {
          var $e;
          ye || ($e = ae.next) == null || $e.call(ae, Oe);
        },
        error(Oe) {
          var $e;
          ye || (ye = !0, ($e = ae.error) == null || $e.call(ae, Oe), xe());
        },
        complete() {
          var Oe;
          ye || (ye = !0, (Oe = ae.complete) == null || Oe.call(ae), xe());
        }
      }), _e && xe(), {
        unsubscribe: xe
      };
    },
    pipe(...ae) {
      return pipeFromArray$1(ae)(oe);
    }
  };
  return oe;
}
function share$1(ne) {
  return (oe) => {
    let ae = 0, fe = null;
    const ye = [];
    function we() {
      fe || (fe = oe.subscribe({
        next(xe) {
          var Oe;
          for (const $e of ye)
            (Oe = $e.next) == null || Oe.call($e, xe);
        },
        error(xe) {
          var Oe;
          for (const $e of ye)
            (Oe = $e.error) == null || Oe.call($e, xe);
        },
        complete() {
          var xe;
          for (const Oe of ye)
            (xe = Oe.complete) == null || xe.call(Oe);
        }
      }));
    }
    function _e() {
      if (ae === 0 && fe) {
        const xe = fe;
        fe = null, xe.unsubscribe();
      }
    }
    return {
      subscribe(xe) {
        return ae++, ye.push(xe), we(), {
          unsubscribe() {
            ae--, _e();
            const Oe = ye.findIndex(($e) => $e === xe);
            Oe > -1 && ye.splice(Oe, 1);
          }
        };
      }
    };
  };
}
class ObservableAbortError extends Error {
  constructor(oe) {
    super(oe), this.name = "ObservableAbortError", Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
}
function observableToPromise(ne) {
  let oe;
  return {
    promise: new Promise((fe, ye) => {
      let we = !1;
      function _e() {
        we || (we = !0, ye(new ObservableAbortError("This operation was aborted.")), xe.unsubscribe());
      }
      const xe = ne.subscribe({
        next(Oe) {
          we = !0, fe(Oe), _e();
        },
        error(Oe) {
          we = !0, ye(Oe), _e();
        },
        complete() {
          we = !0, _e();
        }
      });
      oe = _e;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: oe
  };
}
function createChain(ne) {
  return observable$2((oe) => {
    function ae(ye = 0, we = ne.op) {
      const _e = ne.links[ye];
      if (!_e)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return _e({
        op: we,
        next(Oe) {
          return ae(ye + 1, Oe);
        }
      });
    }
    return ae().subscribe(oe);
  });
}
function isTRPCClientError(ne) {
  return ne instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  ne.name === "TRPCClientError";
}
class TRPCClientError extends Error {
  static from(oe, ae = {}) {
    return oe instanceof Error ? isTRPCClientError(oe) ? (ae.meta && (oe.meta = {
      ...oe.meta,
      ...ae.meta
    }), oe) : new TRPCClientError(oe.message, {
      ...ae,
      cause: oe,
      result: null
    }) : new TRPCClientError(oe.error.message ?? "", {
      ...ae,
      cause: void 0,
      result: oe
    });
  }
  constructor(oe, ae) {
    var ye, we;
    const fe = ae == null ? void 0 : ae.cause;
    super(oe, {
      cause: fe
    }), this.meta = ae == null ? void 0 : ae.meta, this.cause = fe, this.shape = (ye = ae == null ? void 0 : ae.result) == null ? void 0 : ye.error, this.data = (we = ae == null ? void 0 : ae.result) == null ? void 0 : we.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
}
const isFunction$2 = (ne) => typeof ne == "function";
function getFetch(ne) {
  if (ne)
    return ne;
  if (typeof window < "u" && isFunction$2(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && isFunction$2(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function getAbortController(ne) {
  return ne || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function resolveHTTPLinkOptions(ne) {
  return {
    url: ne.url,
    fetch: ne.fetch,
    AbortController: getAbortController(ne.AbortController)
  };
}
function arrayToDict(ne) {
  const oe = {};
  for (let ae = 0; ae < ne.length; ae++) {
    const fe = ne[ae];
    oe[ae] = fe;
  }
  return oe;
}
const METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(ne) {
  return "input" in ne ? ne.runtime.transformer.serialize(ne.input) : arrayToDict(ne.inputs.map((oe) => ne.runtime.transformer.serialize(oe)));
}
const getUrl = (ne) => {
  let oe = ne.url + "/" + ne.path;
  const ae = [];
  if ("inputs" in ne && ae.push("batch=1"), ne.type === "query") {
    const fe = getInput(ne);
    fe !== void 0 && ae.push(`input=${encodeURIComponent(JSON.stringify(fe))}`);
  }
  return ae.length && (oe += "?" + ae.join("&")), oe;
}, getBody = (ne) => {
  if (ne.type === "query")
    return;
  const oe = getInput(ne);
  return oe !== void 0 ? JSON.stringify(oe) : void 0;
}, jsonHttpRequester = (ne) => httpRequest({
  ...ne,
  contentTypeHeader: "application/json",
  getUrl,
  getBody
});
async function fetchHTTPResponse(ne, oe) {
  const ae = ne.getUrl(ne), fe = ne.getBody(ne), { type: ye } = ne, we = await ne.headers();
  /* istanbul ignore if -- @preserve */
  if (ye === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const _e = {
    ...ne.contentTypeHeader ? {
      "content-type": ne.contentTypeHeader
    } : {},
    ...ne.batchModeHeader ? {
      "trpc-batch-mode": ne.batchModeHeader
    } : {},
    ...we
  };
  return getFetch(ne.fetch)(ae, {
    method: METHOD[ye],
    signal: oe == null ? void 0 : oe.signal,
    body: fe,
    headers: _e
  });
}
function httpRequest(ne) {
  const oe = ne.AbortController ? new ne.AbortController() : null, ae = {};
  return {
    promise: new Promise((we, _e) => {
      fetchHTTPResponse(ne, oe).then((xe) => (ae.response = xe, xe.json())).then((xe) => {
        ae.responseJSON = xe, we({
          json: xe,
          meta: ae
        });
      }).catch((xe) => {
        _e(TRPCClientError.from(xe, {
          meta: ae
        }));
      });
    }),
    cancel: () => {
      oe == null || oe.abort();
    }
  };
}
function isObject$1(ne) {
  return !!ne && !Array.isArray(ne) && typeof ne == "object";
}
function transformResultInner(ne, oe) {
  if ("error" in ne) {
    const fe = oe.transformer.deserialize(ne.error);
    return {
      ok: !1,
      error: {
        ...ne,
        error: fe
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...ne.result,
      ...(!ne.result.type || ne.result.type === "data") && {
        type: "data",
        data: oe.transformer.deserialize(ne.result.data)
      }
    }
  };
}
class TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function transformResult(ne, oe) {
  let ae;
  try {
    ae = transformResultInner(ne, oe);
  } catch {
    throw new TransformResultError();
  }
  if (!ae.ok && (!isObject$1(ae.error.error) || typeof ae.error.error.code != "number"))
    throw new TransformResultError();
  if (ae.ok && !isObject$1(ae.result))
    throw new TransformResultError();
  return ae;
}
const throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(ne) {
  let oe = null, ae = null;
  const fe = () => {
    clearTimeout(ae), ae = null, oe = null;
  };
  function ye(xe) {
    var Re, Ne;
    const Oe = [
      []
    ];
    let $e = 0;
    for (; ; ) {
      const je = xe[$e];
      if (!je)
        break;
      const Be = Oe[Oe.length - 1];
      if (je.aborted) {
        (Re = je.reject) == null || Re.call(je, new Error("Aborted")), $e++;
        continue;
      }
      if (ne.validate(Be.concat(je).map((He) => He.key))) {
        Be.push(je), $e++;
        continue;
      }
      if (Be.length === 0) {
        (Ne = je.reject) == null || Ne.call(je, new Error("Input is too big for a single dispatch")), $e++;
        continue;
      }
      Oe.push([]);
    }
    return Oe;
  }
  function we() {
    const xe = ye(oe);
    fe();
    for (const Oe of xe) {
      if (!Oe.length)
        continue;
      const $e = {
        items: Oe,
        cancel: throwFatalError
      };
      for (const Be of Oe)
        Be.batch = $e;
      const Re = (Be, ze) => {
        var qe;
        const He = $e.items[Be];
        (qe = He.resolve) == null || qe.call(He, ze), He.batch = null, He.reject = null, He.resolve = null;
      }, { promise: Ne, cancel: je } = ne.fetch($e.items.map((Be) => Be.key), Re);
      $e.cancel = je, Ne.then((Be) => {
        var ze;
        for (let He = 0; He < Be.length; He++) {
          const qe = Be[He];
          Re(He, qe);
        }
        for (const He of $e.items)
          (ze = He.reject) == null || ze.call(He, new Error("Missing result")), He.batch = null;
      }).catch((Be) => {
        var ze;
        for (const He of $e.items)
          (ze = He.reject) == null || ze.call(He, Be), He.batch = null;
      });
    }
  }
  function _e(xe) {
    const Oe = {
      aborted: !1,
      key: xe,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    }, $e = new Promise((Ne, je) => {
      Oe.reject = je, Oe.resolve = Ne, oe || (oe = []), oe.push(Oe);
    });
    return ae || (ae = setTimeout(we)), {
      promise: $e,
      cancel: () => {
        var Ne;
        Oe.aborted = !0, (Ne = Oe.batch) != null && Ne.items.every((je) => je.aborted) && (Oe.batch.cancel(), Oe.batch = null);
      }
    };
  }
  return {
    load: _e
  };
}
function createHTTPBatchLink(ne) {
  return function(ae) {
    const fe = resolveHTTPLinkOptions(ae), ye = ae.maxURLLength ?? 1 / 0;
    return (we) => {
      const _e = (Ne) => {
        const je = (ze) => {
          if (ye === 1 / 0)
            return !0;
          const He = ze.map((ot) => ot.path).join(","), qe = ze.map((ot) => ot.input);
          return getUrl({
            ...fe,
            runtime: we,
            type: Ne,
            path: He,
            inputs: qe
          }).length <= ye;
        }, Be = ne({
          ...fe,
          runtime: we,
          type: Ne,
          opts: ae
        });
        return {
          validate: je,
          fetch: Be
        };
      }, xe = dataLoader(_e("query")), Oe = dataLoader(_e("mutation")), $e = dataLoader(_e("subscription")), Re = {
        query: xe,
        subscription: $e,
        mutation: Oe
      };
      return ({ op: Ne }) => observable$2((je) => {
        const Be = Re[Ne.type], { promise: ze, cancel: He } = Be.load(Ne);
        let qe;
        return ze.then((Ye) => {
          qe = Ye;
          const ot = transformResult(Ye.json, we);
          if (!ot.ok) {
            je.error(TRPCClientError.from(ot.error, {
              meta: Ye.meta
            }));
            return;
          }
          je.next({
            context: Ye.meta,
            result: ot.result
          }), je.complete();
        }).catch((Ye) => {
          je.error(TRPCClientError.from(Ye, {
            meta: qe == null ? void 0 : qe.meta
          }));
        }), () => {
          He();
        };
      });
    };
  };
}
const batchRequester = (ne) => (oe) => {
  const ae = oe.map((_e) => _e.path).join(","), fe = oe.map((_e) => _e.input), { promise: ye, cancel: we } = jsonHttpRequester({
    ...ne,
    path: ae,
    inputs: fe,
    headers() {
      return ne.opts.headers ? typeof ne.opts.headers == "function" ? ne.opts.headers({
        opList: oe
      }) : ne.opts.headers : {};
    }
  });
  return {
    promise: ye.then((_e) => (Array.isArray(_e.json) ? _e.json : oe.map(() => _e.json)).map(($e) => ({
      meta: _e.meta,
      json: $e
    }))),
    cancel: we
  };
}, httpBatchLink = createHTTPBatchLink(batchRequester);
class TRPCUntypedClient {
  $request({ type: oe, input: ae, path: fe, context: ye = {} }) {
    return createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: oe,
        path: fe,
        input: ae,
        context: ye
      }
    }).pipe(share$1());
  }
  requestAsPromise(oe) {
    const ae = this.$request(oe), { promise: fe, abort: ye } = observableToPromise(ae);
    return new Promise((_e, xe) => {
      var Oe;
      (Oe = oe.signal) == null || Oe.addEventListener("abort", ye), fe.then(($e) => {
        _e($e.result.data);
      }).catch(($e) => {
        xe(TRPCClientError.from($e));
      });
    });
  }
  query(oe, ae, fe) {
    return this.requestAsPromise({
      type: "query",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  mutation(oe, ae, fe) {
    return this.requestAsPromise({
      type: "mutation",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  subscription(oe, ae, fe) {
    return this.$request({
      type: "subscription",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context
    }).subscribe({
      next(we) {
        var _e, xe, Oe;
        we.result.type === "started" ? (_e = fe.onStarted) == null || _e.call(fe) : we.result.type === "stopped" ? (xe = fe.onStopped) == null || xe.call(fe) : (Oe = fe.onData) == null || Oe.call(fe, we.result.data);
      },
      error(we) {
        var _e;
        (_e = fe.onError) == null || _e.call(fe, we);
      },
      complete() {
        var we;
        (we = fe.onComplete) == null || we.call(fe);
      }
    });
  }
  constructor(oe) {
    this.requestId = 0;
    const ae = (() => {
      const fe = oe.transformer;
      return fe ? "input" in fe ? oe.transformer : {
        input: fe,
        output: fe
      } : {
        input: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        },
        output: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (fe) => ae.input.serialize(fe),
        deserialize: (fe) => ae.output.deserialize(fe)
      },
      combinedTransformer: ae
    }, this.links = oe.links.map((fe) => fe(this.runtime));
  }
}
const clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, clientCallTypeToProcedureType = (ne) => clientCallTypeMap[ne];
function createTRPCClientProxy(ne) {
  return createFlatProxy((oe) => ne.hasOwnProperty(oe) ? ne[oe] : oe === "__untypedClient" ? ne : createRecursiveProxy(({ path: ae, args: fe }) => {
    const ye = [
      oe,
      ...ae
    ], we = clientCallTypeToProcedureType(ye.pop()), _e = ye.join(".");
    return ne[we](_e, ...fe);
  }));
}
function createTRPCProxyClient(ne) {
  const oe = new TRPCUntypedClient(ne);
  return createTRPCClientProxy(oe);
}
function g$8({ url: ne }) {
  return createTRPCProxyClient({ transformer: SuperJSON, links: [httpBatchLink({ url: ne })] });
}
function s$3({ url: ne }) {
  return { getLogs: async (oe) => {
    try {
      let ae = encodeURIComponent(JSON.stringify(oe)), fe = new URL(ne).origin, ye = await (await fetch(`${fe}/api/logs?input=${ae}`, { method: "GET" })).json();
      return i$8(ye) ? { ok: { ...ye, blockNumber: BigInt(ye.blockNumber) } } : { error: ye };
    } catch (ae) {
      return { error: ae };
    }
  } };
}
function i$8(ne) {
  return ne && typeof ne.blockNumber == "string" && Array.isArray(ne.logs);
}
var n$2 = ["uint8", "uint16", "uint24", "uint32", "uint40", "uint48", "uint56", "uint64", "uint72", "uint80", "uint88", "uint96", "uint104", "uint112", "uint120", "uint128", "uint136", "uint144", "uint152", "uint160", "uint168", "uint176", "uint184", "uint192", "uint200", "uint208", "uint216", "uint224", "uint232", "uint240", "uint248", "uint256", "int8", "int16", "int24", "int32", "int40", "int48", "int56", "int64", "int72", "int80", "int88", "int96", "int104", "int112", "int120", "int128", "int136", "int144", "int152", "int160", "int168", "int176", "int184", "int192", "int200", "int208", "int216", "int224", "int232", "int240", "int248", "int256", "bytes1", "bytes2", "bytes3", "bytes4", "bytes5", "bytes6", "bytes7", "bytes8", "bytes9", "bytes10", "bytes11", "bytes12", "bytes13", "bytes14", "bytes15", "bytes16", "bytes17", "bytes18", "bytes19", "bytes20", "bytes21", "bytes22", "bytes23", "bytes24", "bytes25", "bytes26", "bytes27", "bytes28", "bytes29", "bytes30", "bytes31", "bytes32", "bool", "address", "uint8[]", "uint16[]", "uint24[]", "uint32[]", "uint40[]", "uint48[]", "uint56[]", "uint64[]", "uint72[]", "uint80[]", "uint88[]", "uint96[]", "uint104[]", "uint112[]", "uint120[]", "uint128[]", "uint136[]", "uint144[]", "uint152[]", "uint160[]", "uint168[]", "uint176[]", "uint184[]", "uint192[]", "uint200[]", "uint208[]", "uint216[]", "uint224[]", "uint232[]", "uint240[]", "uint248[]", "uint256[]", "int8[]", "int16[]", "int24[]", "int32[]", "int40[]", "int48[]", "int56[]", "int64[]", "int72[]", "int80[]", "int88[]", "int96[]", "int104[]", "int112[]", "int120[]", "int128[]", "int136[]", "int144[]", "int152[]", "int160[]", "int168[]", "int176[]", "int184[]", "int192[]", "int200[]", "int208[]", "int216[]", "int224[]", "int232[]", "int240[]", "int248[]", "int256[]", "bytes1[]", "bytes2[]", "bytes3[]", "bytes4[]", "bytes5[]", "bytes6[]", "bytes7[]", "bytes8[]", "bytes9[]", "bytes10[]", "bytes11[]", "bytes12[]", "bytes13[]", "bytes14[]", "bytes15[]", "bytes16[]", "bytes17[]", "bytes18[]", "bytes19[]", "bytes20[]", "bytes21[]", "bytes22[]", "bytes23[]", "bytes24[]", "bytes25[]", "bytes26[]", "bytes27[]", "bytes28[]", "bytes29[]", "bytes30[]", "bytes31[]", "bytes32[]", "bool[]", "address[]", "bytes", "string"], a$6 = n$2.slice(0, 98), s$2 = n$2.slice(98);
function o$8(ne) {
  return n$2.includes(ne);
}
var b$8 = { uint8: 0, uint16: 0, uint24: 0, uint32: 0, uint40: 0, uint48: 0, uint56: 0n, uint64: 0n, uint72: 0n, uint80: 0n, uint88: 0n, uint96: 0n, uint104: 0n, uint112: 0n, uint120: 0n, uint128: 0n, uint136: 0n, uint144: 0n, uint152: 0n, uint160: 0n, uint168: 0n, uint176: 0n, uint184: 0n, uint192: 0n, uint200: 0n, uint208: 0n, uint216: 0n, uint224: 0n, uint232: 0n, uint240: 0n, uint248: 0n, uint256: 0n, int8: 0, int16: 0, int24: 0, int32: 0, int40: 0, int48: 0, int56: 0n, int64: 0n, int72: 0n, int80: 0n, int88: 0n, int96: 0n, int104: 0n, int112: 0n, int120: 0n, int128: 0n, int136: 0n, int144: 0n, int152: 0n, int160: 0n, int168: 0n, int176: 0n, int184: 0n, int192: 0n, int200: 0n, int208: 0n, int216: 0n, int224: 0n, int232: 0n, int240: 0n, int248: 0n, int256: 0n, bytes1: "0x00", bytes2: "0x0000", bytes3: "0x000000", bytes4: "0x00000000", bytes5: "0x0000000000", bytes6: "0x000000000000", bytes7: "0x00000000000000", bytes8: "0x0000000000000000", bytes9: "0x000000000000000000", bytes10: "0x00000000000000000000", bytes11: "0x0000000000000000000000", bytes12: "0x000000000000000000000000", bytes13: "0x00000000000000000000000000", bytes14: "0x0000000000000000000000000000", bytes15: "0x000000000000000000000000000000", bytes16: "0x00000000000000000000000000000000", bytes17: "0x0000000000000000000000000000000000", bytes18: "0x000000000000000000000000000000000000", bytes19: "0x00000000000000000000000000000000000000", bytes20: "0x0000000000000000000000000000000000000000", bytes21: "0x000000000000000000000000000000000000000000", bytes22: "0x00000000000000000000000000000000000000000000", bytes23: "0x0000000000000000000000000000000000000000000000", bytes24: "0x000000000000000000000000000000000000000000000000", bytes25: "0x00000000000000000000000000000000000000000000000000", bytes26: "0x0000000000000000000000000000000000000000000000000000", bytes27: "0x000000000000000000000000000000000000000000000000000000", bytes28: "0x00000000000000000000000000000000000000000000000000000000", bytes29: "0x0000000000000000000000000000000000000000000000000000000000", bytes30: "0x000000000000000000000000000000000000000000000000000000000000", bytes31: "0x00000000000000000000000000000000000000000000000000000000000000", bytes32: "0x0000000000000000000000000000000000000000000000000000000000000000", bool: !1, address: "0x0000000000000000000000000000000000000000" }, T$9 = { uint8: 1, uint16: 2, uint24: 3, uint32: 4, uint40: 5, uint48: 6, uint56: 7, uint64: 8, uint72: 9, uint80: 10, uint88: 11, uint96: 12, uint104: 13, uint112: 14, uint120: 15, uint128: 16, uint136: 17, uint144: 18, uint152: 19, uint160: 20, uint168: 21, uint176: 22, uint184: 23, uint192: 24, uint200: 25, uint208: 26, uint216: 27, uint224: 28, uint232: 29, uint240: 30, uint248: 31, uint256: 32, int8: 1, int16: 2, int24: 3, int32: 4, int40: 5, int48: 6, int56: 7, int64: 8, int72: 9, int80: 10, int88: 11, int96: 12, int104: 13, int112: 14, int120: 15, int128: 16, int136: 17, int144: 18, int152: 19, int160: 20, int168: 21, int176: 22, int184: 23, int192: 24, int200: 25, int208: 26, int216: 27, int224: 28, int232: 29, int240: 30, int248: 31, int256: 32, bytes1: 1, bytes2: 2, bytes3: 3, bytes4: 4, bytes5: 5, bytes6: 6, bytes7: 7, bytes8: 8, bytes9: 9, bytes10: 10, bytes11: 11, bytes12: 12, bytes13: 13, bytes14: 14, bytes15: 15, bytes16: 16, bytes17: 17, bytes18: 18, bytes19: 19, bytes20: 20, bytes21: 21, bytes22: 22, bytes23: 23, bytes24: 24, bytes25: 25, bytes26: 26, bytes27: 27, bytes28: 28, bytes29: 29, bytes30: 30, bytes31: 31, bytes32: 32, bool: 1, address: 20 };
function e$5(ne) {
  return a$6.includes(ne);
}
var y$8 = /\[\]$/, i$7 = /\[\d+\]$/;
function c$6(ne) {
  return typeof ne == "string" && y$8.test(ne) && e$5(ne.replace(y$8, ""));
}
function A$6(ne) {
  return typeof ne == "string" && i$7.test(ne) && e$5(ne.replace(i$7, ""));
}
function m$7(ne) {
  return ne.replace(y$8, "");
}
function f$6(ne) {
  return ne.replace(i$7, "[]");
}
var r$8 = { "uint8[]": [], "uint16[]": [], "uint24[]": [], "uint32[]": [], "uint40[]": [], "uint48[]": [], "uint56[]": [], "uint64[]": [], "uint72[]": [], "uint80[]": [], "uint88[]": [], "uint96[]": [], "uint104[]": [], "uint112[]": [], "uint120[]": [], "uint128[]": [], "uint136[]": [], "uint144[]": [], "uint152[]": [], "uint160[]": [], "uint168[]": [], "uint176[]": [], "uint184[]": [], "uint192[]": [], "uint200[]": [], "uint208[]": [], "uint216[]": [], "uint224[]": [], "uint232[]": [], "uint240[]": [], "uint248[]": [], "uint256[]": [], "int8[]": [], "int16[]": [], "int24[]": [], "int32[]": [], "int40[]": [], "int48[]": [], "int56[]": [], "int64[]": [], "int72[]": [], "int80[]": [], "int88[]": [], "int96[]": [], "int104[]": [], "int112[]": [], "int120[]": [], "int128[]": [], "int136[]": [], "int144[]": [], "int152[]": [], "int160[]": [], "int168[]": [], "int176[]": [], "int184[]": [], "int192[]": [], "int200[]": [], "int208[]": [], "int216[]": [], "int224[]": [], "int232[]": [], "int240[]": [], "int248[]": [], "int256[]": [], "bytes1[]": [], "bytes2[]": [], "bytes3[]": [], "bytes4[]": [], "bytes5[]": [], "bytes6[]": [], "bytes7[]": [], "bytes8[]": [], "bytes9[]": [], "bytes10[]": [], "bytes11[]": [], "bytes12[]": [], "bytes13[]": [], "bytes14[]": [], "bytes15[]": [], "bytes16[]": [], "bytes17[]": [], "bytes18[]": [], "bytes19[]": [], "bytes20[]": [], "bytes21[]": [], "bytes22[]": [], "bytes23[]": [], "bytes24[]": [], "bytes25[]": [], "bytes26[]": [], "bytes27[]": [], "bytes28[]": [], "bytes29[]": [], "bytes30[]": [], "bytes31[]": [], "bytes32[]": [], "bool[]": [], "address[]": [], bytes: "0x", string: "" };
function v$5(ne) {
  return s$2.includes(ne);
}
function u$4(ne, oe) {
  throw new Error(oe ?? `Unexpected value: ${ne}`);
}
function a$5(...ne) {
  return ne.reduce((oe, ae) => ae > oe ? ae : oe);
}
function l$6(...ne) {
  return ne.reduce((oe, ae) => ae < oe ? ae : oe);
}
function s$1(ne, oe) {
  return ne < oe ? -1 : ne > oe ? 1 : 0;
}
function* m$6(ne, oe) {
  for (let ae = 0; ae < ne.length; ae += oe)
    yield ne.slice(ae, ae + oe);
}
function y$7(ne, oe) {
  let ae = /* @__PURE__ */ new Map();
  for (let fe of ne) {
    let ye = oe(fe);
    ae.has(ye) || ae.set(ye, []), ae.get(ye).push(fe);
  }
  return ae;
}
function b$7(ne) {
  return ne !== void 0;
}
function P$8(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, oe(fe, ae)]));
}
function B$3(ne) {
  return new Promise((oe) => setTimeout(() => oe(), ne));
}
function N$7() {
  return new Promise((ne) => {
    typeof requestIdleCallback < "u" ? requestIdleCallback(() => ne()) : setTimeout(() => ne(), 1);
  });
}
var r$7 = class extends Error {
  constructor() {
    super(...arguments);
    dc(this, "name", "MUDError");
  }
}, browser$1 = { exports: {} }, ms$1, hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var ne = 1e3, oe = ne * 60, ae = oe * 60, fe = ae * 24, ye = fe * 7, we = fe * 365.25;
  ms$1 = function(Re, Ne) {
    Ne = Ne || {};
    var je = typeof Re;
    if (je === "string" && Re.length > 0)
      return _e(Re);
    if (je === "number" && isFinite(Re))
      return Ne.long ? Oe(Re) : xe(Re);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(Re)
    );
  };
  function _e(Re) {
    if (Re = String(Re), !(Re.length > 100)) {
      var Ne = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        Re
      );
      if (Ne) {
        var je = parseFloat(Ne[1]), Be = (Ne[2] || "ms").toLowerCase();
        switch (Be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return je * we;
          case "weeks":
          case "week":
          case "w":
            return je * ye;
          case "days":
          case "day":
          case "d":
            return je * fe;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return je * ae;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return je * oe;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return je * ne;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return je;
          default:
            return;
        }
      }
    }
  }
  function xe(Re) {
    var Ne = Math.abs(Re);
    return Ne >= fe ? Math.round(Re / fe) + "d" : Ne >= ae ? Math.round(Re / ae) + "h" : Ne >= oe ? Math.round(Re / oe) + "m" : Ne >= ne ? Math.round(Re / ne) + "s" : Re + "ms";
  }
  function Oe(Re) {
    var Ne = Math.abs(Re);
    return Ne >= fe ? $e(Re, Ne, fe, "day") : Ne >= ae ? $e(Re, Ne, ae, "hour") : Ne >= oe ? $e(Re, Ne, oe, "minute") : Ne >= ne ? $e(Re, Ne, ne, "second") : Re + " ms";
  }
  function $e(Re, Ne, je, Be) {
    var ze = Ne >= je * 1.5;
    return Math.round(Re / je) + " " + Be + (ze ? "s" : "");
  }
  return ms$1;
}
function setup$2(ne) {
  ae.debug = ae, ae.default = ae, ae.coerce = Oe, ae.disable = we, ae.enable = ye, ae.enabled = _e, ae.humanize = requireMs$1(), ae.destroy = $e, Object.keys(ne).forEach((Re) => {
    ae[Re] = ne[Re];
  }), ae.names = [], ae.skips = [], ae.formatters = {};
  function oe(Re) {
    let Ne = 0;
    for (let je = 0; je < Re.length; je++)
      Ne = (Ne << 5) - Ne + Re.charCodeAt(je), Ne |= 0;
    return ae.colors[Math.abs(Ne) % ae.colors.length];
  }
  ae.selectColor = oe;
  function ae(Re) {
    let Ne, je = null, Be, ze;
    function He(...qe) {
      if (!He.enabled)
        return;
      const Ye = He, ot = Number(/* @__PURE__ */ new Date()), tt = ot - (Ne || ot);
      Ye.diff = tt, Ye.prev = Ne, Ye.curr = ot, Ne = ot, qe[0] = ae.coerce(qe[0]), typeof qe[0] != "string" && qe.unshift("%O");
      let it = 0;
      qe[0] = qe[0].replace(/%([a-zA-Z%])/g, (gt, At) => {
        if (gt === "%%")
          return "%";
        it++;
        const St = ae.formatters[At];
        if (typeof St == "function") {
          const Nt = qe[it];
          gt = St.call(Ye, Nt), qe.splice(it, 1), it--;
        }
        return gt;
      }), ae.formatArgs.call(Ye, qe), (Ye.log || ae.log).apply(Ye, qe);
    }
    return He.namespace = Re, He.useColors = ae.useColors(), He.color = ae.selectColor(Re), He.extend = fe, He.destroy = ae.destroy, Object.defineProperty(He, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => je !== null ? je : (Be !== ae.namespaces && (Be = ae.namespaces, ze = ae.enabled(Re)), ze),
      set: (qe) => {
        je = qe;
      }
    }), typeof ae.init == "function" && ae.init(He), He;
  }
  function fe(Re, Ne) {
    const je = ae(this.namespace + (typeof Ne > "u" ? ":" : Ne) + Re);
    return je.log = this.log, je;
  }
  function ye(Re) {
    ae.save(Re), ae.namespaces = Re, ae.names = [], ae.skips = [];
    let Ne;
    const je = (typeof Re == "string" ? Re : "").split(/[\s,]+/), Be = je.length;
    for (Ne = 0; Ne < Be; Ne++)
      je[Ne] && (Re = je[Ne].replace(/\*/g, ".*?"), Re[0] === "-" ? ae.skips.push(new RegExp("^" + Re.slice(1) + "$")) : ae.names.push(new RegExp("^" + Re + "$")));
  }
  function we() {
    const Re = [
      ...ae.names.map(xe),
      ...ae.skips.map(xe).map((Ne) => "-" + Ne)
    ].join(",");
    return ae.enable(""), Re;
  }
  function _e(Re) {
    if (Re[Re.length - 1] === "*")
      return !0;
    let Ne, je;
    for (Ne = 0, je = ae.skips.length; Ne < je; Ne++)
      if (ae.skips[Ne].test(Re))
        return !1;
    for (Ne = 0, je = ae.names.length; Ne < je; Ne++)
      if (ae.names[Ne].test(Re))
        return !0;
    return !1;
  }
  function xe(Re) {
    return Re.toString().substring(2, Re.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function Oe(Re) {
    return Re instanceof Error ? Re.stack || Re.message : Re;
  }
  function $e() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ae.enable(ae.load()), ae;
}
var common$1 = setup$2;
(function(ne, oe) {
  oe.formatArgs = fe, oe.save = ye, oe.load = we, oe.useColors = ae, oe.storage = _e(), oe.destroy = (() => {
    let Oe = !1;
    return () => {
      Oe || (Oe = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), oe.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ae() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let Oe;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (Oe = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Oe[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fe(Oe) {
    if (Oe[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Oe[0] + (this.useColors ? "%c " : " ") + "+" + ne.exports.humanize(this.diff), !this.useColors)
      return;
    const $e = "color: " + this.color;
    Oe.splice(1, 0, $e, "color: inherit");
    let Re = 0, Ne = 0;
    Oe[0].replace(/%[a-zA-Z%]/g, (je) => {
      je !== "%%" && (Re++, je === "%c" && (Ne = Re));
    }), Oe.splice(Ne, 0, $e);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ye(Oe) {
    try {
      Oe ? oe.storage.setItem("debug", Oe) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function we() {
    let Oe;
    try {
      Oe = oe.storage.getItem("debug");
    } catch {
    }
    return !Oe && typeof process < "u" && "env" in process && (Oe = process.env.DEBUG), Oe;
  }
  function _e() {
    try {
      return localStorage;
    } catch {
    }
  }
  ne.exports = common$1(oe);
  const { formatters: xe } = ne.exports;
  xe.j = function(Oe) {
    try {
      return JSON.stringify(Oe);
    } catch ($e) {
      return "[UnexpectedJSONParseError]: " + $e.message;
    }
  };
})(browser$1, browser$1.exports);
var browserExports$1 = browser$1.exports;
const z$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var e$4 = z$1("mud:common"), r$6 = z$1("mud:common");
e$4.log = console.debug.bind(console);
r$6.log = console.error.bind(console);
var eventemitter3$1 = { exports: {} };
(function(ne) {
  var oe = Object.prototype.hasOwnProperty, ae = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (ae = !1));
  function ye(Oe, $e, Re) {
    this.fn = Oe, this.context = $e, this.once = Re || !1;
  }
  function we(Oe, $e, Re, Ne, je) {
    if (typeof Re != "function")
      throw new TypeError("The listener must be a function");
    var Be = new ye(Re, Ne || Oe, je), ze = ae ? ae + $e : $e;
    return Oe._events[ze] ? Oe._events[ze].fn ? Oe._events[ze] = [Oe._events[ze], Be] : Oe._events[ze].push(Be) : (Oe._events[ze] = Be, Oe._eventsCount++), Oe;
  }
  function _e(Oe, $e) {
    --Oe._eventsCount === 0 ? Oe._events = new fe() : delete Oe._events[$e];
  }
  function xe() {
    this._events = new fe(), this._eventsCount = 0;
  }
  xe.prototype.eventNames = function() {
    var $e = [], Re, Ne;
    if (this._eventsCount === 0)
      return $e;
    for (Ne in Re = this._events)
      oe.call(Re, Ne) && $e.push(ae ? Ne.slice(1) : Ne);
    return Object.getOwnPropertySymbols ? $e.concat(Object.getOwnPropertySymbols(Re)) : $e;
  }, xe.prototype.listeners = function($e) {
    var Re = ae ? ae + $e : $e, Ne = this._events[Re];
    if (!Ne)
      return [];
    if (Ne.fn)
      return [Ne.fn];
    for (var je = 0, Be = Ne.length, ze = new Array(Be); je < Be; je++)
      ze[je] = Ne[je].fn;
    return ze;
  }, xe.prototype.listenerCount = function($e) {
    var Re = ae ? ae + $e : $e, Ne = this._events[Re];
    return Ne ? Ne.fn ? 1 : Ne.length : 0;
  }, xe.prototype.emit = function($e, Re, Ne, je, Be, ze) {
    var He = ae ? ae + $e : $e;
    if (!this._events[He])
      return !1;
    var qe = this._events[He], Ye = arguments.length, ot, tt;
    if (qe.fn) {
      switch (qe.once && this.removeListener($e, qe.fn, void 0, !0), Ye) {
        case 1:
          return qe.fn.call(qe.context), !0;
        case 2:
          return qe.fn.call(qe.context, Re), !0;
        case 3:
          return qe.fn.call(qe.context, Re, Ne), !0;
        case 4:
          return qe.fn.call(qe.context, Re, Ne, je), !0;
        case 5:
          return qe.fn.call(qe.context, Re, Ne, je, Be), !0;
        case 6:
          return qe.fn.call(qe.context, Re, Ne, je, Be, ze), !0;
      }
      for (tt = 1, ot = new Array(Ye - 1); tt < Ye; tt++)
        ot[tt - 1] = arguments[tt];
      qe.fn.apply(qe.context, ot);
    } else {
      var it = qe.length, ht;
      for (tt = 0; tt < it; tt++)
        switch (qe[tt].once && this.removeListener($e, qe[tt].fn, void 0, !0), Ye) {
          case 1:
            qe[tt].fn.call(qe[tt].context);
            break;
          case 2:
            qe[tt].fn.call(qe[tt].context, Re);
            break;
          case 3:
            qe[tt].fn.call(qe[tt].context, Re, Ne);
            break;
          case 4:
            qe[tt].fn.call(qe[tt].context, Re, Ne, je);
            break;
          default:
            if (!ot)
              for (ht = 1, ot = new Array(Ye - 1); ht < Ye; ht++)
                ot[ht - 1] = arguments[ht];
            qe[tt].fn.apply(qe[tt].context, ot);
        }
    }
    return !0;
  }, xe.prototype.on = function($e, Re, Ne) {
    return we(this, $e, Re, Ne, !1);
  }, xe.prototype.once = function($e, Re, Ne) {
    return we(this, $e, Re, Ne, !0);
  }, xe.prototype.removeListener = function($e, Re, Ne, je) {
    var Be = ae ? ae + $e : $e;
    if (!this._events[Be])
      return this;
    if (!Re)
      return _e(this, Be), this;
    var ze = this._events[Be];
    if (ze.fn)
      ze.fn === Re && (!je || ze.once) && (!Ne || ze.context === Ne) && _e(this, Be);
    else {
      for (var He = 0, qe = [], Ye = ze.length; He < Ye; He++)
        (ze[He].fn !== Re || je && !ze[He].once || Ne && ze[He].context !== Ne) && qe.push(ze[He]);
      qe.length ? this._events[Be] = qe.length === 1 ? qe[0] : qe : _e(this, Be);
    }
    return this;
  }, xe.prototype.removeAllListeners = function($e) {
    var Re;
    return $e ? (Re = ae ? ae + $e : $e, this._events[Re] && _e(this, Re)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, xe.prototype.off = xe.prototype.removeListener, xe.prototype.addListener = xe.prototype.on, xe.prefixed = ae, xe.EventEmitter = xe, ne.exports = xe;
})(eventemitter3$1);
var eventemitter3Exports = eventemitter3$1.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError extends Error {
  constructor(oe) {
    super(oe), this.name = "TimeoutError";
  }
}
let AbortError$2 = class extends Error {
  constructor(oe) {
    super(), this.name = "AbortError", this.message = oe;
  }
};
const getDOMException$1 = (ne) => globalThis.DOMException === void 0 ? new AbortError$2(ne) : new DOMException(ne), getAbortedReason = (ne) => {
  const oe = ne.reason === void 0 ? getDOMException$1("This operation was aborted.") : ne.reason;
  return oe instanceof Error ? oe : getDOMException$1(oe);
};
function pTimeout(ne, oe, ae, fe) {
  let ye;
  const we = new Promise((_e, xe) => {
    if (typeof oe != "number" || Math.sign(oe) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${oe}\``);
    if (oe === Number.POSITIVE_INFINITY) {
      _e(ne);
      return;
    }
    if (fe = {
      customTimers: { setTimeout, clearTimeout },
      ...fe
    }, fe.signal) {
      const { signal: Oe } = fe;
      Oe.aborted && xe(getAbortedReason(Oe)), Oe.addEventListener("abort", () => {
        xe(getAbortedReason(Oe));
      });
    }
    ye = fe.customTimers.setTimeout.call(void 0, () => {
      if (typeof ae == "function") {
        try {
          _e(ae());
        } catch (Re) {
          xe(Re);
        }
        return;
      }
      const Oe = typeof ae == "string" ? ae : `Promise timed out after ${oe} milliseconds`, $e = ae instanceof Error ? ae : new TimeoutError(Oe);
      typeof ne.cancel == "function" && ne.cancel(), xe($e);
    }, oe), (async () => {
      try {
        _e(await ne);
      } catch (Oe) {
        xe(Oe);
      } finally {
        fe.customTimers.clearTimeout.call(void 0, ye);
      }
    })();
  });
  return we.clear = () => {
    clearTimeout(ye), ye = void 0;
  }, we;
}
function lowerBound(ne, oe, ae) {
  let fe = 0, ye = ne.length;
  for (; ye > 0; ) {
    const we = Math.trunc(ye / 2);
    let _e = fe + we;
    ae(ne[_e], oe) <= 0 ? (fe = ++_e, ye -= we + 1) : ye = we;
  }
  return fe;
}
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(oe, ae) {
    ae = {
      priority: 0,
      ...ae
    };
    const fe = {
      priority: ae.priority,
      run: oe
    };
    if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= ae.priority) {
      __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(fe);
      return;
    }
    const ye = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), fe, (we, _e) => _e.priority - we.priority);
    __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(ye, 0, fe);
  }
  dequeue() {
    const oe = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
    return oe == null ? void 0 : oe.run;
  }
  filter(oe) {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((ae) => ae.priority === oe.priority).map((ae) => ae.run);
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}, __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;
let AbortError$1 = class extends Error {
};
class PQueue extends EventEmitter {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(oe) {
    var ae, fe, ye, we;
    if (super(), _PQueue_instances.add(this), _PQueue_carryoverConcurrencyCount.set(this, void 0), _PQueue_isIntervalIgnored.set(this, void 0), _PQueue_intervalCount.set(this, 0), _PQueue_intervalCap.set(this, void 0), _PQueue_interval.set(this, void 0), _PQueue_intervalEnd.set(this, 0), _PQueue_intervalId.set(this, void 0), _PQueue_timeoutId.set(this, void 0), _PQueue_queue.set(this, void 0), _PQueue_queueClass.set(this, void 0), _PQueue_pending.set(this, 0), _PQueue_concurrency.set(this, void 0), _PQueue_isPaused.set(this, void 0), _PQueue_throwOnTimeout.set(this, void 0), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), oe = {
      carryoverConcurrencyCount: !1,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: !0,
      queueClass: PriorityQueue,
      ...oe
    }, !(typeof oe.intervalCap == "number" && oe.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(fe = (ae = oe.intervalCap) === null || ae === void 0 ? void 0 : ae.toString()) !== null && fe !== void 0 ? fe : ""}\` (${typeof oe.intervalCap})`);
    if (oe.interval === void 0 || !(Number.isFinite(oe.interval) && oe.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(we = (ye = oe.interval) === null || ye === void 0 ? void 0 : ye.toString()) !== null && we !== void 0 ? we : ""}\` (${typeof oe.interval})`);
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, oe.carryoverConcurrencyCount, "f"), __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, oe.intervalCap === Number.POSITIVE_INFINITY || oe.interval === 0, "f"), __classPrivateFieldSet(this, _PQueue_intervalCap, oe.intervalCap, "f"), __classPrivateFieldSet(this, _PQueue_interval, oe.interval, "f"), __classPrivateFieldSet(this, _PQueue_queue, new oe.queueClass(), "f"), __classPrivateFieldSet(this, _PQueue_queueClass, oe.queueClass, "f"), this.concurrency = oe.concurrency, this.timeout = oe.timeout, __classPrivateFieldSet(this, _PQueue_throwOnTimeout, oe.throwOnTimeout === !0, "f"), __classPrivateFieldSet(this, _PQueue_isPaused, oe.autoStart === !1, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet(this, _PQueue_concurrency, "f");
  }
  set concurrency(oe) {
    if (!(typeof oe == "number" && oe >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${oe}\` (${typeof oe})`);
    __classPrivateFieldSet(this, _PQueue_concurrency, oe, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(oe, ae = {}) {
    return ae = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f"),
      ...ae
    }, new Promise((fe, ye) => {
      __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(async () => {
        var we, _e, xe;
        __classPrivateFieldSet(this, _PQueue_pending, (_e = __classPrivateFieldGet(this, _PQueue_pending, "f"), _e++, _e), "f"), __classPrivateFieldSet(this, _PQueue_intervalCount, (xe = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"), xe++, xe), "f");
        try {
          if (!((we = ae.signal) === null || we === void 0) && we.aborted)
            throw new AbortError$1("The task was aborted.");
          let Oe = oe({ signal: ae.signal });
          ae.timeout && (Oe = pTimeout(Promise.resolve(Oe), ae.timeout)), ae.signal && (Oe = Promise.race([Oe, __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, ae.signal)]));
          const $e = await Oe;
          fe($e), this.emit("completed", $e);
        } catch (Oe) {
          if (Oe instanceof TimeoutError && !ae.throwOnTimeout) {
            fe();
            return;
          }
          ye(Oe), this.emit("error", Oe);
        } finally {
          __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, ae), this.emit("add"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(oe, ae) {
    return Promise.all(oe.map(async (fe) => this.add(fe, ae)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet(this, _PQueue_isPaused, !1, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, !0, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(oe) {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(oe) {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(oe).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_pending, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f");
}, _PQueue_next = function ne() {
  var oe;
  __classPrivateFieldSet(this, _PQueue_pending, (oe = __classPrivateFieldGet(this, _PQueue_pending, "f"), oe--, oe), "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("next");
}, _PQueue_onResumeInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function ne() {
  const oe = Date.now();
  if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
    const ae = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - oe;
    if (ae < 0)
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f");
    else
      return __classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
      }, ae), "f"), !0;
  }
  return !1;
}, _PQueue_tryToStartAnother = function ne() {
  if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0)
    return __classPrivateFieldGet(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f"), this.emit("empty"), __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && this.emit("idle"), !1;
  if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
    const oe = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const ae = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
      return ae ? (this.emit("active"), ae(), oe && __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), !0) : !1;
    }
  }
  return !1;
}, _PQueue_initializeIntervalIfNeeded = function ne() {
  __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet(this, _PQueue_interval, "f")), "f"), __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f"));
}, _PQueue_onInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f")), __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function ne() {
  for (; __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
    ;
}, _PQueue_throwOnAbort = async function ne(oe) {
  return new Promise((ae, fe) => {
    oe.addEventListener("abort", () => {
      fe(new AbortError$1("The task was aborted."));
    }, { once: !0 });
  });
}, _PQueue_onEvent = async function ne(oe, ae) {
  return new Promise((fe) => {
    const ye = () => {
      ae && !ae() || (this.off(oe, ye), fe());
    };
    this.on(oe, ye);
  });
};
var retry$3 = {};
function RetryOperation$1(ne, oe) {
  typeof oe == "boolean" && (oe = { forever: oe }), this._originalTimeouts = JSON.parse(JSON.stringify(ne)), this._timeouts = ne, this._options = oe || {}, this._maxRetryTime = oe && oe.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation$1 = RetryOperation$1;
RetryOperation$1.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation$1.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation$1.prototype.retry = function(ne) {
  if (this._timeout && clearTimeout(this._timeout), !ne)
    return !1;
  var oe = (/* @__PURE__ */ new Date()).getTime();
  if (ne && oe - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ne), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ne);
  var ae = this._timeouts.shift();
  if (ae === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), ae = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, ae), this._options.unref && this._timer.unref(), !0;
};
RetryOperation$1.prototype.attempt = function(ne, oe) {
  this._fn = ne, oe && (oe.timeout && (this._operationTimeout = oe.timeout), oe.cb && (this._operationTimeoutCb = oe.cb));
  var ae = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    ae._operationTimeoutCb();
  }, ae._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation$1.prototype.try = function(ne) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ne);
};
RetryOperation$1.prototype.start = function(ne) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ne);
};
RetryOperation$1.prototype.start = RetryOperation$1.prototype.try;
RetryOperation$1.prototype.errors = function() {
  return this._errors;
};
RetryOperation$1.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation$1.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ne = {}, oe = null, ae = 0, fe = 0; fe < this._errors.length; fe++) {
    var ye = this._errors[fe], we = ye.message, _e = (ne[we] || 0) + 1;
    ne[we] = _e, _e >= ae && (oe = ye, ae = _e);
  }
  return oe;
};
(function(ne) {
  var oe = retry_operation$1;
  ne.operation = function(ae) {
    var fe = ne.timeouts(ae);
    return new oe(fe, {
      forever: ae && (ae.forever || ae.retries === 1 / 0),
      unref: ae && ae.unref,
      maxRetryTime: ae && ae.maxRetryTime
    });
  }, ne.timeouts = function(ae) {
    if (ae instanceof Array)
      return [].concat(ae);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ye in ae)
      fe[ye] = ae[ye];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var we = [], _e = 0; _e < fe.retries; _e++)
      we.push(this.createTimeout(_e, fe));
    return ae && ae.forever && !we.length && we.push(this.createTimeout(_e, fe)), we.sort(function(xe, Oe) {
      return xe - Oe;
    }), we;
  }, ne.createTimeout = function(ae, fe) {
    var ye = fe.randomize ? Math.random() + 1 : 1, we = Math.round(ye * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, ae));
    return we = Math.min(we, fe.maxTimeout), we;
  }, ne.wrap = function(ae, fe, ye) {
    if (fe instanceof Array && (ye = fe, fe = null), !ye) {
      ye = [];
      for (var we in ae)
        typeof ae[we] == "function" && ye.push(we);
    }
    for (var _e = 0; _e < ye.length; _e++) {
      var xe = ye[_e], Oe = ae[xe];
      ae[xe] = (function(Re) {
        var Ne = ne.operation(fe), je = Array.prototype.slice.call(arguments, 1), Be = je.pop();
        je.push(function(ze) {
          Ne.retry(ze) || (ze && (arguments[0] = Ne.mainError()), Be.apply(this, arguments));
        }), Ne.attempt(function() {
          Re.apply(ae, je);
        });
      }).bind(ae, Oe), ae[xe].options = fe;
    }
  };
})(retry$3);
var retry$1 = retry$3;
const retry$2 = /* @__PURE__ */ getDefaultExportFromCjs(retry$1), networkErrorMsgs = /* @__PURE__ */ new Set([
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed",
  // `cross-fetch`
  "fetch failed"
  // Undici (Node.js)
]);
class AbortError extends Error {
  constructor(oe) {
    super(), oe instanceof Error ? (this.originalError = oe, { message: oe } = oe) : (this.originalError = new Error(oe), this.originalError.stack = this.stack), this.name = "AbortError", this.message = oe;
  }
}
const decorateErrorWithCounts = (ne, oe, ae) => {
  const fe = ae.retries - (oe - 1);
  return ne.attemptNumber = oe, ne.retriesLeft = fe, ne;
}, isNetworkError = (ne) => networkErrorMsgs.has(ne), getDOMException = (ne) => globalThis.DOMException === void 0 ? new Error(ne) : new DOMException(ne);
async function pRetry(ne, oe) {
  return new Promise((ae, fe) => {
    oe = {
      onFailedAttempt() {
      },
      retries: 10,
      ...oe
    };
    const ye = retry$2.operation(oe);
    ye.attempt(async (we) => {
      try {
        ae(await ne(we));
      } catch (_e) {
        if (!(_e instanceof Error)) {
          fe(new TypeError(`Non-error was thrown: "${_e}". You should only throw errors.`));
          return;
        }
        if (_e instanceof AbortError)
          ye.stop(), fe(_e.originalError);
        else if (_e instanceof TypeError && !isNetworkError(_e.message))
          ye.stop(), fe(_e);
        else {
          decorateErrorWithCounts(_e, we, oe);
          try {
            await oe.onFailedAttempt(_e);
          } catch (xe) {
            fe(xe);
            return;
          }
          ye.retry(_e) || fe(ye.mainError());
        }
      }
    }), oe.signal && !oe.signal.aborted && oe.signal.addEventListener("abort", () => {
      ye.stop();
      const we = oe.signal.reason === void 0 ? getDOMException("The operation was aborted.") : oe.signal.reason;
      fe(we instanceof Error ? we : getDOMException(we));
    }, {
      once: !0
    });
  });
}
function toAccount(ne) {
  if (typeof ne == "string") {
    if (!isAddress(ne, { strict: !1 }))
      throw new InvalidAddressError({ address: ne });
    return {
      address: ne,
      type: "json-rpc"
    };
  }
  if (!isAddress(ne.address, { strict: !1 }))
    throw new InvalidAddressError({ address: ne.address });
  return {
    address: ne.address,
    signMessage: ne.signMessage,
    signTransaction: ne.signTransaction,
    signTypedData: ne.signTypedData,
    source: "custom",
    type: "local"
  };
}
async function sign({ hash: ne, privateKey: oe }) {
  const { r: ae, s: fe, recovery: ye } = secp256k1.sign(ne.slice(2), oe.slice(2));
  return {
    r: toHex(ae),
    s: toHex(fe),
    v: ye ? 28n : 27n,
    yParity: ye
  };
}
async function signMessage({ message: ne, privateKey: oe }) {
  const ae = await sign({ hash: hashMessage(ne), privateKey: oe });
  return signatureToHex(ae);
}
async function signTransaction(ne) {
  const { privateKey: oe, transaction: ae, serializer: fe = serializeTransaction$1 } = ne, ye = (() => ae.type === "eip4844" ? {
    ...ae,
    sidecars: !1
  } : ae)(), we = await sign({
    hash: keccak256(fe(ye)),
    privateKey: oe
  });
  return fe(ae, we);
}
async function signTypedData(ne) {
  const { privateKey: oe, ...ae } = ne, fe = await sign({
    hash: hashTypedData(ae),
    privateKey: oe
  });
  return signatureToHex(fe);
}
function privateKeyToAccount(ne) {
  const oe = toHex(secp256k1.getPublicKey(ne.slice(2), !1)), ae = publicKeyToAddress(oe);
  return {
    ...toAccount({
      address: ae,
      async signMessage({ message: ye }) {
        return signMessage({ message: ye, privateKey: ne });
      },
      async signTransaction(ye, { serializer: we } = {}) {
        return signTransaction({ privateKey: ne, transaction: ye, serializer: we });
      },
      async signTypedData(ye) {
        return signTypedData({ ...ye, privateKey: ne });
      }
    }),
    publicKey: oe,
    source: "privateKey"
  };
}
async function h$3({ client: ne, address: oe, blockTag: ae }) {
  var fe;
  return `mud:createNonceManager:${((fe = ne.chain) == null ? void 0 : fe.id) ?? await getChainId(ne)}:${getAddress(oe)}:${ae}`;
}
var R = e$4.extend("createNonceManager");
function P$7({ client: ne, address: oe, blockTag: ae = "pending", broadcastChannelName: fe, queueConcurrency: ye = 1 }) {
  let we = { current: -1 }, _e = null;
  typeof BroadcastChannel < "u" && (fe ? Promise.resolve(fe) : h$3({ client: ne, address: oe, blockTag: ae })).then((Be) => {
    _e = new BroadcastChannel(Be), _e.addEventListener("message", (ze) => {
      let He = JSON.parse(ze.data);
      R("got nonce from broadcast channel", He), we.current = He;
    });
  });
  function xe() {
    return we.current >= 0;
  }
  function Oe() {
    if (!xe())
      throw new Error("call resetNonce before using getNonce");
    return we.current;
  }
  function $e() {
    if (!xe())
      throw new Error("call resetNonce before using nextNonce");
    let Be = we.current++;
    return _e == null || _e.postMessage(JSON.stringify(we.current)), Be;
  }
  async function Re() {
    let Be = await getTransactionCount(ne, { address: oe, blockTag: ae });
    we.current = Be, _e == null || _e.postMessage(JSON.stringify(we.current)), R("reset nonce to", we.current);
  }
  function Ne(Be) {
    return Be instanceof BaseError$1 && Be.walk((ze) => ze instanceof NonceTooLowError || ze instanceof NonceTooHighError) != null;
  }
  let je = new PQueue({ concurrency: ye });
  return { hasNonce: xe, getNonce: Oe, nextNonce: $e, resetNonce: Re, shouldResetNonce: Ne, mempoolQueue: je };
}
var T$8 = /* @__PURE__ */ new Map();
async function C$5({ client: ne, address: oe, blockTag: ae = "pending", ...fe }) {
  let ye = await h$3({ client: ne, address: oe, blockTag: ae }), we = T$8.get(ye);
  if (we)
    return we;
  let _e = P$7({ client: ne, address: oe, blockTag: ae, ...fe });
  return T$8.set(ye, _e), _e;
}
async function F$2({ client: ne, args: oe, refreshInterval: ae }) {
  let fe = { fees: {}, lastUpdatedTimestamp: 0 };
  async function ye() {
    let we = await estimateFeesPerGas(ne, oe);
    fe.fees = we, fe.lastUpdatedTimestamp = Date.now();
  }
  return setInterval(ye, ae), await ye(), fe;
}
var M$4 = /* @__PURE__ */ new Map();
async function N$6(ne) {
  var ye, we, _e;
  let oe = ((we = (ye = ne.args) == null ? void 0 : ye.chain) == null ? void 0 : we.id) ?? ((_e = ne.client.chain) == null ? void 0 : _e.id) ?? await getChainId(ne.client), ae = M$4.get(oe);
  if (ae)
    return ae;
  let fe = await F$2(ne);
  return M$4.set(oe, fe), fe;
}
var y$6 = e$4.extend("writeContract");
async function Je(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), we = ne.chain, _e = { chain: we, ...we != null && we.fees ? { type: "eip1559" } : {} }, xe = await C$5({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), Oe = await N$6({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: we } });
  async function $e() {
    if (oe.gas)
      return y$6("gas provided, skipping preparation", oe.functionName, oe.address), oe;
    let { abi: Re, address: Ne, args: je, dataSuffix: Be, functionName: ze } = oe, He = encodeFunctionData({ abi: Re, args: je, functionName: ze }), { nonce: qe, maxFeePerGas: Ye, maxPriorityFeePerGas: ot, ...tt } = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({ maxFeePerGas: 0n, maxPriorityFeePerGas: 0n, nonce: xe.getNonce(), ..._e, ...oe, blockTag: "pending", account: ye, data: `${He}${Be ? Be.replace("0x", "") : ""}`, to: Ne });
    return tt;
  }
  return xe.mempoolQueue.add(() => pRetry(async () => {
    xe.hasNonce() || await xe.resetNonce();
    let Re = await $e(), Ne = xe.nextNonce(), je = { ...Re, nonce: Ne, ...Oe.fees };
    return y$6("calling", je.functionName, "with nonce", Ne, "at", je.address), await writeContract(ne, je);
  }, { retries: 3, onFailedAttempt: async (Re) => {
    if (xe.shouldResetNonce(Re)) {
      y$6("got nonce error, retrying", Re.message), await xe.resetNonce();
      return;
    }
    throw Re;
  } }), { throwOnTimeout: !0 });
}
var b$6 = e$4.extend("sendTransaction");
async function Ve(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), we = ne.chain, _e = await C$5({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), xe = await N$6({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: we } });
  async function Oe() {
    return oe.gas ? (b$6("gas provided, skipping simulate", oe.to), oe) : (b$6("simulating tx to", oe.to), await call(ae.publicClient ?? ne, { ...oe, blockTag: "pending", account: ye }), oe);
  }
  return await _e.mempoolQueue.add(() => pRetry(async () => {
    let $e = await Oe();
    _e.hasNonce() || await _e.resetNonce();
    let Re = _e.nextNonce();
    b$6("sending tx with nonce", Re, "to", $e.to);
    let Ne = { ...$e, nonce: Re, ...xe.fees };
    return await sendTransaction(ne, Ne);
  }, { retries: 3, onFailedAttempt: async ($e) => {
    if (_e.shouldResetNonce($e)) {
      b$6("got nonce error, retrying", $e.message), await _e.resetNonce();
      return;
    }
    throw $e;
  } }), { throwOnTimeout: !0 });
}
var m$5 = ["table", "offchainTable", "namespace", "system"], o$7 = { table: "tb", offchainTable: "ot", namespace: "ns", system: "sy" };
function x$3(ne) {
  let oe = o$7[ne.type];
  if (ne.namespace.length > 14)
    throw new Error(`Namespaces must fit into \`bytes14\`, but "${ne.namespace}" is too long.`);
  return concatHex$1([stringToHex$1(oe, { size: 2 }), stringToHex$1(ne.namespace, { size: 14 }), stringToHex$1(ne.name.slice(0, 16), { size: 16 })]);
}
var y$5 = "";
function i$6({ namespace: ne, name: oe }) {
  return ne === y$5 ? oe : `${ne}__${oe}`;
}
var f$5 = Object.fromEntries(Object.entries(o$7).map(([ne, oe]) => [oe, ne]));
function T$7(ne) {
  let oe = f$5[ne];
  if (m$5.includes(oe))
    return oe;
}
function _$4(ne) {
  let oe = hexToString(sliceHex(ne, 0, 2)).replace(/\0+$/, ""), ae = T$7(oe), fe = hexToString(sliceHex(ne, 2, 16)).replace(/\0+$/, ""), ye = hexToString(sliceHex(ne, 16, 32)).replace(/\0+$/, "");
  if (!ae)
    throw new Error(`Unknown type (${oe}) for resource (${i$6({ namespace: fe, name: ye })})`);
  return { resourceId: ne, type: ae, namespace: fe, name: ye };
}
var T$6 = z$1("mud:benchmark");
T$6.log = console.info.bind(console);
function Q$4(ne) {
  return { ...privateKeyToAccount(ne) };
}
var C$4 = class extends Map {
  constructor(ae) {
    super();
    dc(this, "maxSize");
    this.maxSize = ae;
  }
  set(ae, fe) {
    return super.set(ae, fe), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
};
function a$4(ne, oe, ae) {
  return `0x${ne.replace(/^0x/, "").slice(oe * 2, ae != null ? ae * 2 : void 0).padEnd(((ae ?? oe) - oe) * 2, "0")}`;
}
function be(ne) {
  return "ok" in ne;
}
function Pe(ne, oe, ae = 0, fe = "0x") {
  return concatHex$1([a$4(ne, 0, oe), fe, a$4(ne, oe + ae)]);
}
var G$3 = e$4.extend("transportObserver");
function Ee(ne) {
  return (oe) => {
    let ae = ne(oe);
    return { ...ae, request: async (fe) => {
      if (fe.method === "eth_sendRawTransaction" && fe.params instanceof Array) {
        let ye = fe.params.map((we) => keccak256(we));
        G$3("saw txs", ye);
      }
      return ae.request(fe);
    } };
  };
}
var u$3 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" is an odd length (${ae.length - 2}). It must be an even length.`);
    dc(this, "name", "InvalidHexValueError");
  }
}, S$1 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for a schema.`);
    dc(this, "name", "InvalidHexLengthForSchemaError");
  }
}, g$7 = class extends r$7 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for encoded lengths.`);
    dc(this, "name", "InvalidHexLengthForEncodedLengthsError");
  }
}, A$5 = class extends r$7 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected length of ${T$9[ae] * 2} for ${ae} type.`);
    dc(this, "name", "InvalidHexLengthForStaticFieldError");
  }
}, v$4 = class extends r$7 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected a multiple of ${T$9[ae] * 2} for ${ae}[] type.`);
    dc(this, "name", "InvalidHexLengthForArrayFieldError");
  }
}, H$3 = class extends r$7 {
  constructor(ae, fe, ye) {
    super(`Schema "${ae}" static data length (${fe}) did not match the summed length of all static fields (${ye}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`);
    dc(this, "name", "SchemaStaticLengthMismatchError");
  }
}, F$1 = class extends r$7 {
  constructor(ae, fe, ye) {
    super(`EncodedLengths "${ae}" total bytes length (${fe}) did not match the summed length of all field byte lengths (${ye}).`);
    dc(this, "name", "EncodedLengthsLengthMismatchError");
  }
};
function y$4(ne, oe) {
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$3(oe);
  if ((oe.length - 2) / 2 !== T$9[ne])
    throw new A$5(ne, oe);
  switch (ne) {
    case "uint8":
    case "uint16":
    case "uint24":
    case "uint32":
    case "uint40":
    case "uint48":
    case "uint56":
    case "uint64":
    case "uint72":
    case "uint80":
    case "uint88":
    case "uint96":
    case "uint104":
    case "uint112":
    case "uint120":
    case "uint128":
    case "uint136":
    case "uint144":
    case "uint152":
    case "uint160":
    case "uint168":
    case "uint176":
    case "uint184":
    case "uint192":
    case "uint200":
    case "uint208":
    case "uint216":
    case "uint224":
    case "uint232":
    case "uint240":
    case "uint248":
    case "uint256":
    case "int8":
    case "int16":
    case "int24":
    case "int32":
    case "int40":
    case "int48":
    case "int56":
    case "int64":
    case "int72":
    case "int80":
    case "int88":
    case "int96":
    case "int104":
    case "int112":
    case "int120":
    case "int128":
    case "int136":
    case "int144":
    case "int152":
    case "int160":
    case "int168":
    case "int176":
    case "int184":
    case "int192":
    case "int200":
    case "int208":
    case "int216":
    case "int224":
    case "int232":
    case "int240":
    case "int248":
    case "int256": {
      let ae = hexToBigInt(oe, { signed: ne.startsWith("int") }), fe = typeof b$8[ne];
      if (fe === "number")
        return Number(ae);
      if (fe === "bigint")
        return ae;
      throw new Error(`Unexpected default value type (${fe}) for ABI type (${ne})`);
    }
    case "bytes1":
    case "bytes2":
    case "bytes3":
    case "bytes4":
    case "bytes5":
    case "bytes6":
    case "bytes7":
    case "bytes8":
    case "bytes9":
    case "bytes10":
    case "bytes11":
    case "bytes12":
    case "bytes13":
    case "bytes14":
    case "bytes15":
    case "bytes16":
    case "bytes17":
    case "bytes18":
    case "bytes19":
    case "bytes20":
    case "bytes21":
    case "bytes22":
    case "bytes23":
    case "bytes24":
    case "bytes25":
    case "bytes26":
    case "bytes27":
    case "bytes28":
    case "bytes29":
    case "bytes30":
    case "bytes31":
    case "bytes32":
      return oe;
    case "bool":
      return hexToBool(oe);
    case "address":
      return getAddress(oe);
  }
  return u$4(ne, `Unsupported static ABI type: ${ne}`);
}
function f$4(ne, oe) {
  if (ne === "bytes")
    return oe;
  if (ne === "string")
    return hexToString(oe);
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$3(oe);
  let ae = (oe.length - 2) / 2;
  switch (ne) {
    case "uint8[]":
    case "uint16[]":
    case "uint24[]":
    case "uint32[]":
    case "uint40[]":
    case "uint48[]":
    case "uint56[]":
    case "uint64[]":
    case "uint72[]":
    case "uint80[]":
    case "uint88[]":
    case "uint96[]":
    case "uint104[]":
    case "uint112[]":
    case "uint120[]":
    case "uint128[]":
    case "uint136[]":
    case "uint144[]":
    case "uint152[]":
    case "uint160[]":
    case "uint168[]":
    case "uint176[]":
    case "uint184[]":
    case "uint192[]":
    case "uint200[]":
    case "uint208[]":
    case "uint216[]":
    case "uint224[]":
    case "uint232[]":
    case "uint240[]":
    case "uint248[]":
    case "uint256[]":
    case "int8[]":
    case "int16[]":
    case "int24[]":
    case "int32[]":
    case "int40[]":
    case "int48[]":
    case "int56[]":
    case "int64[]":
    case "int72[]":
    case "int80[]":
    case "int88[]":
    case "int96[]":
    case "int104[]":
    case "int112[]":
    case "int120[]":
    case "int128[]":
    case "int136[]":
    case "int144[]":
    case "int152[]":
    case "int160[]":
    case "int168[]":
    case "int176[]":
    case "int184[]":
    case "int192[]":
    case "int200[]":
    case "int208[]":
    case "int216[]":
    case "int224[]":
    case "int232[]":
    case "int240[]":
    case "int248[]":
    case "int256[]":
    case "bytes1[]":
    case "bytes2[]":
    case "bytes3[]":
    case "bytes4[]":
    case "bytes5[]":
    case "bytes6[]":
    case "bytes7[]":
    case "bytes8[]":
    case "bytes9[]":
    case "bytes10[]":
    case "bytes11[]":
    case "bytes12[]":
    case "bytes13[]":
    case "bytes14[]":
    case "bytes15[]":
    case "bytes16[]":
    case "bytes17[]":
    case "bytes18[]":
    case "bytes19[]":
    case "bytes20[]":
    case "bytes21[]":
    case "bytes22[]":
    case "bytes23[]":
    case "bytes24[]":
    case "bytes25[]":
    case "bytes26[]":
    case "bytes27[]":
    case "bytes28[]":
    case "bytes29[]":
    case "bytes30[]":
    case "bytes31[]":
    case "bytes32[]":
    case "bool[]":
    case "address[]": {
      let fe = m$7(ne), ye = T$9[fe];
      if (ae % ye !== 0)
        throw new v$4(fe, oe);
      return new Array(ae / ye).fill(void 0).map((we, _e) => {
        let xe = sliceHex(oe, _e * ye, (_e + 1) * ye);
        return y$4(fe, xe);
      });
    }
  }
  return u$4(ne, `Unsupported dynamic ABI type: ${ne}`);
}
function V$3(ne, oe) {
  if (ne.staticFields.length !== oe.length)
    throw new Error(`key tuple length ${oe.length} does not match key schema length ${ne.staticFields.length}`);
  return oe.map((ae, fe) => decodeAbiParameters([{ type: ne.staticFields[fe] }], ae)[0]);
}
function lt$1(ne, oe) {
  let ae = V$3({ staticFields: Object.values(ne), dynamicFields: [] }, oe);
  return Object.fromEntries(Object.keys(ne).map((fe, ye) => [fe, ae[ye]]));
}
function E$4(ne) {
  if (ne.length !== 66)
    throw new g$7(ne);
  let oe = y$4("uint56", a$4(ne, 32 - 7, 32)), ae = f$4("uint40[]", a$4(ne, 0, 32 - 7)), fe = Object.freeze([...ae].reverse()), ye = BigInt(fe.reduce((we, _e) => we + _e, 0));
  if (ye !== oe)
    throw new F$1(ne, oe, ye);
  return { totalByteLength: oe, fieldByteLengths: fe };
}
function T$5(ne) {
  return ne.reduce((oe, ae) => oe + T$9[ae], 0);
}
function w$3(ne, oe) {
  let ae = [], fe = 0;
  ne.staticFields.forEach((_e) => {
    let xe = T$9[_e], Oe = y$4(_e, a$4(oe, fe, fe + xe));
    fe += xe, ae.push(Oe);
  });
  let ye = T$5(ne.staticFields), we = fe;
  if (we !== ye && console.warn("Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?", { expectedLength: ye, actualLength: we, bytesOffset: fe }), ne.dynamicFields.length > 0) {
    let _e = E$4(a$4(oe, fe, fe + 32));
    fe += 32, ne.dynamicFields.forEach((Oe, $e) => {
      let Re = _e.fieldByteLengths[$e];
      if (Re > 0) {
        let Ne = f$4(Oe, a$4(oe, fe, fe + Re));
        fe += Re, ae.push(Ne);
      } else
        ae.push(r$8[Oe]);
    });
    let xe = fe - 32 - we;
    BigInt(xe) !== _e.totalByteLength && console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?", { expectedLength: _e.totalByteLength, actualLength: xe, bytesOffset: fe });
  }
  return ae;
}
function j$4(ne, oe) {
  let ae = Object.values(ne).filter(e$5), fe = Object.values(ne).filter(v$5), ye = w$3({ staticFields: ae, dynamicFields: fe }, oe);
  return Object.fromEntries(Object.keys(ne).map((we, _e) => [we, ye[_e]]));
}
function zt$1(ne, { staticData: oe, encodedLengths: ae, dynamicData: fe }) {
  return j$4(ne, concatHex$1([a$4(oe, 0, T$5(Object.values(ne).filter(e$5))), ae, fe]));
}
function p$4(ne, oe) {
  if (c$6(ne) && Array.isArray(oe)) {
    let ae = m$7(ne);
    return oe.length === 0 ? "0x" : encodePacked(oe.map(() => ae), oe);
  }
  return encodePacked([ne], [oe]);
}
function I$9(ne, oe) {
  return oe.map((ae, fe) => encodeAbiParameters([{ type: ne.staticFields[fe] }], [ae]));
}
function Yt(ne, oe) {
  let ae = Object.values(ne).filter(e$5);
  return I$9({ staticFields: ae, dynamicFields: [] }, Object.values(oe));
}
function K$6(ne) {
  let oe = ne.map(size$2).reverse(), ae = oe.reduce((fe, ye) => fe + BigInt(ye), 0n);
  return padHex$1(concatHex$1([...oe.map((fe) => p$4("uint40", fe)), p$4("uint56", ae)]), { size: 32, dir: "left" });
}
function N$5(ne, oe) {
  let ae = Object.entries(ne), fe = ae.filter(([, Oe]) => e$5(Oe)), ye = ae.filter(([, Oe]) => v$5(Oe)), we = fe.map(([Oe, $e]) => p$4($e, oe[Oe])), _e = ye.map(([Oe, $e]) => p$4($e, oe[Oe])), xe = K$6(_e);
  return { staticData: concatHex$1(we), encodedLengths: xe, dynamicData: concatHex$1(_e) };
}
function D$3(ne) {
  if (ne.length !== 66)
    throw new S$1(ne);
  let oe = hexToNumber$1(sliceHex(ne, 0, 2)), ae = hexToNumber$1(sliceHex(ne, 2, 3)), fe = hexToNumber$1(sliceHex(ne, 3, 4)), ye = [], we = [];
  for (let xe = 4; xe < 4 + ae; xe++) {
    let Oe = hexToNumber$1(sliceHex(ne, xe, xe + 1));
    ye.push(n$2[Oe]);
  }
  for (let xe = 4 + ae; xe < 4 + ae + fe; xe++) {
    let Oe = hexToNumber$1(sliceHex(ne, xe, xe + 1));
    we.push(n$2[Oe]);
  }
  let _e = ye.reduce((xe, Oe) => xe + T$9[Oe], 0);
  if (_e !== oe)
    throw console.warn(`Schema "${ne}" static data length (${oe}) did not match the summed length of all static fields (${_e}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`), new H$3(ne, oe, _e);
  return { staticFields: ye, dynamicFields: we };
}
function P$6(ne) {
  let oe = ne.staticFields.map((fe) => n$2.indexOf(fe)), ae = ne.dynamicFields.map((fe) => n$2.indexOf(fe));
  return `0x${[T$5(ne.staticFields).toString(16).padStart(4, "0"), ne.staticFields.length.toString(16).padStart(2, "0"), ne.dynamicFields.length.toString(16).padStart(2, "0"), ...oe.map((fe) => fe.toString(16).padStart(2, "0")), ...ae.map((fe) => fe.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function zi(ne) {
  return P$6({ staticFields: Object.values(ne).filter(e$5), dynamicFields: [] });
}
function _i(ne) {
  let oe = Object.values(ne).filter(e$5), ae = Object.values(ne).filter(v$5), fe = oe.map((ye) => T$9[ye]);
  return `0x${[fe.reduce((ye, we) => ye + we, 0).toString(16).padStart(4, "0"), oe.length.toString(16).padStart(2, "0"), ae.length.toString(16).padStart(2, "0"), ...fe.map((ye) => ye.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function Ji(ne) {
  return P$6({ staticFields: Object.values(ne).filter(e$5), dynamicFields: Object.values(ne).filter(v$5) });
}
function Xi$1(ne) {
  return Object.fromEntries(ne.key.map((oe) => [oe, ne.schema[oe]]));
}
function Zi(ne) {
  return Object.fromEntries(Object.entries(ne.schema).filter(([oe]) => !ne.key.includes(oe)));
}
function ia(ne) {
  return P$8(ne, (oe) => oe.type);
}
function flatMorph$1(ne, oe) {
  var we;
  const ae = Array.isArray(ne), fe = Object.entries(ne).flatMap((_e, xe) => {
    const Oe = ae ? oe(xe, _e[1]) : oe(..._e, xe);
    return Array.isArray(Oe[0]) || Oe.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      Oe
    ) : [Oe];
  }), ye = Object.fromEntries(fe);
  return typeof ((we = fe[0]) == null ? void 0 : we[0]) == "number" ? Object.values(ye) : ye;
}
var Hkt$1;
(function(ne) {
  class oe {
  }
  ne.Kind = oe;
  class ae {
  }
  ne.Instantiable = ae, ne.reify = (ye) => ye.hkt;
  class fe {
  }
  ne.UnaryKind = fe, ne.pipe = (...ye) => (we) => ye.reduce((_e, xe) => xe.hkt(_e), we);
})(Hkt$1 || (Hkt$1 = {}));
const wellFormedNumberMatcher$1 = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
wellFormedNumberMatcher$1.test.bind(wellFormedNumberMatcher$1);
const wellFormedIntegerMatcher$1 = /^(?:0|(?:-?[1-9]\d*))$/;
wellFormedIntegerMatcher$1.test.bind(wellFormedIntegerMatcher$1);
const integerLikeMatcher$1 = /^-?\d+$/;
integerLikeMatcher$1.test.bind(integerLikeMatcher$1);
const prototypeKeysOf$1 = (ne) => {
  const oe = [];
  let ae = ne;
  for (; ae !== Object.prototype && ae !== null && ae !== void 0; ) {
    for (const fe of Object.getOwnPropertyNames(ae))
      fe !== "constructor" && !oe.includes(fe) && oe.push(fe);
    for (const fe of Object.getOwnPropertySymbols(ae))
      oe.includes(fe) || oe.push(fe);
    ae = Object.getPrototypeOf(ae);
  }
  return oe;
};
prototypeKeysOf$1(0n), prototypeKeysOf$1(!1), prototypeKeysOf$1(0), prototypeKeysOf$1(""), prototypeKeysOf$1(Symbol());
function c$5(ne, oe) {
  return typeof ne == "object" && ne != null && o$6(ne, oe) ? ne[oe] : void 0;
}
function o$6(ne, oe) {
  return typeof ne == "object" && ne !== null && ne.hasOwnProperty(oe);
}
function r$5(ne) {
  return ne != null && typeof ne == "object";
}
function i$5(ne, oe) {
  let ae = [.../* @__PURE__ */ new Set([...Object.keys(ne), ...Object.keys(oe)])];
  return Object.fromEntries(ae.map((fe) => [fe, typeof ne[fe] > "u" ? oe[fe] : ne[fe]]));
}
var b$5 = { storeImportPath: "@latticexyz/store/src", userTypesFilename: "common.sol", outputDirectory: "codegen", indexFilename: "index.sol" }, m$4 = { outputDirectory: "tables", tableIdArgument: !1, storeArgument: !1 }, N$4 = { disabled: !1 }, x$2 = { namespace: "", type: "table" }, T$4 = { sourceDirectory: "src", namespace: "" }, a$3 = { types: Object.fromEntries(n$2.map((ne) => [ne, ne])) };
function u$2(ne, oe) {
  return { types: { ...ne.types, ...oe } };
}
function h$2(ne, oe = a$3) {
  if (!r$5(ne))
    throw new Error(`Expected schema, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    if (!A$6(ae) && !o$6(oe.types, ae))
      throw new Error(`"${String(ae)}" is not a valid type in this scope.`);
}
function k$5(ne, oe = a$3) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, { type: A$6(fe) ? f$6(fe) : oe.types[fe], internalType: fe }]));
}
function v$3(ne, oe = a$3) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((ae) => A$6(ae) || o$6(oe.types, ae));
}
function Y$3(ne, oe = a$3) {
  return Object.entries(ne).filter(([, ae]) => o$6(oe.types, ae) && e$5(oe.types[ae])).map(([ae]) => ae);
}
function q$3(ne, oe, ae = a$3) {
  return Array.isArray(ne) && ne.every((fe) => o$6(oe, fe) && o$6(ae.types, oe[fe]) && e$5(ae.types[oe[fe]]));
}
function g$6(ne, oe = a$3, ae = { inStoreContext: !1 }) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full table config, got \`${JSON.stringify(ne)}\``);
  if (!o$6(ne, "schema"))
    throw new Error("Missing schema input");
  if (h$2(ne.schema, oe), !o$6(ne, "key") || !q$3(ne.key, ne.schema, oe))
    throw new Error(`Invalid key. Expected \`(${Y$3(ne.schema, oe).map((fe) => `"${String(fe)}"`).join(" | ")})[]\`, received \`${o$6(ne, "key") && Array.isArray(ne.key) ? `[${ne.key.map((fe) => `"${fe}"`).join(", ")}]` : String(c$5(ne, "key"))}\``);
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`Table \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$6(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`Table \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
  if (ae.inStoreContext && (o$6(ne, "label") || o$6(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for tables in this context.");
}
function H$2(ne) {
  let oe = ne.codegen;
  return { outputDirectory: c$5(oe, "outputDirectory") ?? m$4.outputDirectory, tableIdArgument: c$5(oe, "tableIdArgument") ?? m$4.tableIdArgument, storeArgument: c$5(oe, "storeArgument") ?? m$4.storeArgument, dataStruct: c$5(oe, "dataStruct") ?? Object.keys(ne.schema).length - ne.key.length > 1 };
}
function E$3(ne, oe = a$3) {
  let ae = ne.label, fe = ne.type ?? x$2.type, ye = ne.namespace ?? x$2.namespace, we = ne.name ?? ae.slice(0, 16), _e = x$3({ type: fe, namespace: ye, name: we });
  return { label: ae, type: fe, namespace: ye, name: we, tableId: _e, schema: k$5(ne.schema, oe), key: ne.key, codegen: H$2(ne), deploy: i$5(ne.deploy ?? {}, N$4) };
}
function D$2(ne) {
  return typeof ne == "string" || r$5(ne) && Object.values(ne).every((oe) => typeof oe == "string");
}
function A$4(ne, oe = a$3) {
  if (typeof ne == "string") {
    if (A$6(ne) || o$6(oe.types, ne))
      return;
    throw new Error(`Invalid ABI type. \`${ne}\` not found in scope.`);
  }
  if (typeof ne == "object" && ne !== null) {
    if (v$3(ne, oe)) {
      if (o$6(ne, "id") && e$5(oe.types[ne.id]))
        return;
      throw new Error("Invalid schema. Expected an `id` field with a static ABI type or an explicit `key` option.");
    }
    throw new Error("Invalid schema. Are you using invalid types or missing types in your scope?");
  }
  throw new Error("Invalid table shorthand.");
}
function l$5(ne, oe) {
  return typeof ne == "string" ? { schema: { id: "bytes32", value: ne }, key: ["id"] } : v$3(ne, oe) ? { schema: ne, key: ["id"] } : ne;
}
function d$2(ne, oe) {
  if (r$5(ne)) {
    for (let ae of Object.values(ne))
      D$2(ae) ? A$4(ae, oe) : g$6(ae, oe, { inStoreContext: !0 });
    return;
  }
  throw new Error(`Expected tables config, received ${JSON.stringify(ne)}`);
}
function I$8(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, E$3(i$5(l$5(fe, oe), { label: ae }), oe)]));
}
function Z$1(ne) {
  return P$8(ne, (oe) => oe.type);
}
function ee$1(ne) {
  return r$5(ne) && Object.values(ne).every((oe) => o$8(oe.type));
}
function U$4(ne, oe = a$3) {
  return ee$1(ne) ? u$2(oe, Z$1(ne)) : oe;
}
function L$3(ne) {
  if (!r$5(ne))
    throw new Error(`Expected userTypes, received ${JSON.stringify(ne)}`);
  for (let { type: oe } of Object.values(ne))
    if (!o$6(a$3.types, oe))
      throw new Error(`"${String(oe)}" is not a valid ABI type.`);
}
function te$3(ne) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((oe) => Array.isArray(oe) && oe.every((ae) => typeof ae == "string"));
}
function _$3(ne, oe = a$3) {
  if (te$3(ne)) {
    let ae = Object.fromEntries(Object.keys(ne).map((fe) => [fe, "uint8"]));
    return u$2(oe, ae);
  }
  return oe;
}
function j$3(ne) {
  return flatMorph$1(ne, (oe, ae) => [oe, flatMorph$1(ae, (fe, ye) => [ye, fe])]);
}
function C$3(ne) {
  return r$5(ne) ? i$5(ne, b$5) : b$5;
}
function K$5(ne, oe) {
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$6(ne, "tables") && d$2(ne.tables, oe);
}
function $$1(ne, oe = a$3) {
  let ae = ne.label, fe = ne.namespace ?? ae.slice(0, 14);
  return { label: ae, namespace: fe, tables: I$8(flatMorph$1(ne.tables ?? {}, (ye, we) => [ye, i$5(l$5(we, oe), { namespace: fe })]), oe) };
}
function w$2(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    K$5(ae, oe);
}
function f$3(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph$1(ne, (ye, we) => [ye, $$1(i$5(we, { label: ye }), oe)]), fe = Array.from(y$7(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function B$2(ne) {
  return Object.fromEntries(Object.entries(ne.namespaces).flatMap(([oe, ae]) => Object.entries(ae.tables).map(([fe, ye]) => [oe === "" ? fe : `${oe}__${fe}`, ye])));
}
function G$2(ne) {
  return _$3(c$5(ne, "enums"), U$4(c$5(ne, "userTypes")));
}
function pe$1(ne) {
  let oe = G$2(ne);
  if (o$6(ne, "namespaces")) {
    if (o$6(ne, "namespace") || o$6(ne, "tables"))
      throw new Error("Cannot use `namespaces` with `namespace` or `tables` keys.");
    w$2(ne.namespaces, oe);
  }
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$6(ne, "tables") && d$2(ne.tables, oe), o$6(ne, "userTypes") && L$3(ne.userTypes);
}
function re$1(ne) {
  let oe = G$2(ne), ae = ne.namespace ?? T$4.namespace, fe = ne.namespaces ? { multipleNamespaces: !0, namespace: null, namespaces: f$3(ne.namespaces, oe) } : { multipleNamespaces: !1, namespace: ae, namespaces: f$3({ [ae]: ne }, oe) }, ye = B$2(fe);
  return { ...fe, tables: ye, sourceDirectory: ne.sourceDirectory ?? T$4.sourceDirectory, userTypes: ne.userTypes ?? {}, enums: ne.enums ?? {}, enumValues: j$3(ne.enums ?? {}), codegen: C$3(ne.codegen) };
}
function Lt(ne) {
  return pe$1(ne), re$1(ne);
}
var o$5 = Lt({ namespace: "store", codegen: { storeImportPath: "./src" }, userTypes: { ResourceId: { filePath: "./src/ResourceId.sol", type: "bytes32" }, FieldLayout: { filePath: "./src/FieldLayout.sol", type: "bytes32" }, Schema: { filePath: "./src/Schema.sol", type: "bytes32" } }, tables: { StoreHooks: { schema: { tableId: "ResourceId", hooks: "bytes21[]" }, key: ["tableId"] }, Tables: { schema: { tableId: "ResourceId", fieldLayout: "FieldLayout", keySchema: "Schema", valueSchema: "Schema", abiEncodedKeyNames: "bytes", abiEncodedFieldNames: "bytes" }, key: ["tableId"] }, ResourceIds: { schema: { resourceId: "ResourceId", exists: "bool" }, key: ["resourceId"] }, Hooks: { schema: { resourceId: "ResourceId", hooks: "bytes21[]" }, key: ["resourceId"], codegen: { tableIdArgument: !0 }, deploy: { disabled: !0 } } } }), m$3 = { namespace: "", openAccess: !0, accessList: [] }, C$2 = { root: !1, args: [], artifactPath: void 0 }, I$7 = { worldInterfaceName: "IWorld", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src" }, b$4 = { customWorldContract: void 0, postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", upgradeableWorldImplementation: !1 }, P$5 = { systems: {}, tables: {}, excludeSystems: [], modules: [], codegen: I$7, deploy: b$4 };
function i$4(ne, oe = {}) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full system config, got \`${JSON.stringify(ne)}\``);
  if (oe.inNamespace && (o$6(ne, "label") || o$6(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for systems in this context.");
  if (o$6(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`System \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$6(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`System \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
}
function c$4(ne) {
  let oe = ne.label, ae = ne.namespace ?? m$3.namespace, fe = ne.name ?? oe.slice(0, 16), ye = x$3({ type: "system", namespace: ae, name: fe });
  return i$5({ ...ne, label: oe, namespace: ae, name: fe, systemId: ye }, m$3);
}
function y$3(ne) {
  if (r$5(ne)) {
    for (let oe of Object.values(ne))
      i$4(oe, { inNamespace: !0 });
    return;
  }
  throw new Error(`Expected system config, received ${JSON.stringify(ne)}`);
}
function l$4(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, c$4({ ...fe, label: ae, namespace: oe })]));
}
function Q$3(ne, oe) {
  o$6(ne, "systems") && y$3(ne.systems), K$5(ne, oe);
}
function X$1(ne, oe = a$3) {
  let ae = $$1(ne, oe), fe = l$4(ne.systems ?? {}, ae.namespace);
  return { ...ae, systems: fe };
}
function l$3(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    Q$3(ae, oe);
}
function r$4(ne, oe) {
  if (!r$5(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph$1(ne, (ye, we) => [ye, X$1(i$5(we, { label: ye }), oe)]), fe = Array.from(y$7(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function N$3(ne) {
  return r$5(ne) ? i$5(ne, I$7) : I$7;
}
function g$5(ne) {
  return r$5(ne) ? i$5(ne, b$4) : b$4;
}
function W$1(ne) {
  let oe = G$2(ne);
  if (o$6(ne, "namespaces")) {
    if (o$6(ne, "namespace") || o$6(ne, "tables") || o$6(ne, "systems"))
      throw new Error("Cannot use `namespaces` with `namespace`, `tables`, or `systems` keys.");
    l$3(ne.namespaces, oe);
  }
  o$6(ne, "systems") && y$3(ne.systems), pe$1(ne);
}
function _$2(ne) {
  let oe = G$2(ne), ae = re$1(ne), fe = ne.namespaces ? r$4(ne.namespaces, oe) : r$4({ [ae.namespace]: ne }, oe), ye = B$2({ namespaces: fe }), we = (ne.modules ?? P$5.modules).map((_e) => i$5(_e, C$2));
  return i$5({ ...ae, namespaces: fe, tables: ye, systems: !ae.multipleNamespaces && ne.systems ? l$4(ne.systems, ae.namespace) : P$5.systems, excludeSystems: c$5(ne, "excludeSystems"), codegen: i$5(ae.codegen, N$3(ne.codegen)), deploy: g$5(ne.deploy), modules: we }, P$5);
}
function te$2(ne) {
  return W$1(ne), _$2(ne);
}
var s = { namespace: "world", codegen: { worldImportPath: "./src", worldgenDirectory: "interfaces", worldInterfaceName: "IBaseWorld" }, userTypes: { ResourceId: { filePath: "@latticexyz/store/src/ResourceId.sol", type: "bytes32" } }, tables: { NamespaceOwner: { schema: { namespaceId: "ResourceId", owner: "address" }, key: ["namespaceId"] }, ResourceAccess: { schema: { resourceId: "ResourceId", caller: "address", access: "bool" }, key: ["resourceId", "caller"] }, InstalledModules: { schema: { moduleAddress: "address", argumentsHash: "bytes32", isInstalled: "bool" }, key: ["moduleAddress", "argumentsHash"] }, UserDelegationControl: { schema: { delegator: "address", delegatee: "address", delegationControlId: "ResourceId" }, key: ["delegator", "delegatee"] }, NamespaceDelegationControl: { schema: { namespaceId: "ResourceId", delegationControlId: "ResourceId" }, key: ["namespaceId"] }, Balances: { schema: { namespaceId: "ResourceId", balance: "uint256" }, key: ["namespaceId"] }, Systems: { schema: { systemId: "ResourceId", system: "address", publicAccess: "bool" }, key: ["systemId"], codegen: { dataStruct: !1 } }, SystemRegistry: { schema: { system: "address", systemId: "ResourceId" }, key: ["system"] }, SystemHooks: { schema: { systemId: "ResourceId", value: "bytes21[]" }, key: ["systemId"] }, FunctionSelectors: { schema: { worldFunctionSelector: "bytes4", systemId: "ResourceId", systemFunctionSelector: "bytes4" }, key: ["worldFunctionSelector"], codegen: { dataStruct: !1 } }, FunctionSignatures: { type: "offchainTable", schema: { functionSelector: "bytes4", functionSignature: "string" }, key: ["functionSelector"] }, InitModuleAddress: { schema: { value: "address" }, key: [] } }, excludeSystems: ["StoreRegistrationSystem"] }, a$2 = te$2(s), t$1 = "event Store_SetRecord(bytes32 indexed tableId, bytes32[] keyTuple, bytes staticData, bytes32 encodedLengths, bytes dynamicData)", o$4 = "event Store_SpliceStaticData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, bytes data)", r$3 = "event Store_SpliceDynamicData(bytes32 indexed tableId, bytes32[] keyTuple, uint8 dynamicFieldIndex, uint48 start, uint40 deleteCount, bytes32 encodedLengths, bytes data)", n$1 = "event Store_DeleteRecord(bytes32 indexed tableId, bytes32[] keyTuple)", e$3 = [t$1, o$4, r$3, n$1], p$3 = parseAbi(e$3), extendStatics = function(ne, oe) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ae, fe) {
    ae.__proto__ = fe;
  } || function(ae, fe) {
    for (var ye in fe)
      Object.prototype.hasOwnProperty.call(fe, ye) && (ae[ye] = fe[ye]);
  }, extendStatics(ne, oe);
};
function __extends(ne, oe) {
  if (typeof oe != "function" && oe !== null)
    throw new TypeError("Class extends value " + String(oe) + " is not a constructor or null");
  extendStatics(ne, oe);
  function ae() {
    this.constructor = ne;
  }
  ne.prototype = oe === null ? Object.create(oe) : (ae.prototype = oe.prototype, new ae());
}
function __awaiter(ne, oe, ae, fe) {
  function ye(we) {
    return we instanceof ae ? we : new ae(function(_e) {
      _e(we);
    });
  }
  return new (ae || (ae = Promise))(function(we, _e) {
    function xe(Re) {
      try {
        $e(fe.next(Re));
      } catch (Ne) {
        _e(Ne);
      }
    }
    function Oe(Re) {
      try {
        $e(fe.throw(Re));
      } catch (Ne) {
        _e(Ne);
      }
    }
    function $e(Re) {
      Re.done ? we(Re.value) : ye(Re.value).then(xe, Oe);
    }
    $e((fe = fe.apply(ne, oe || [])).next());
  });
}
function __generator(ne, oe) {
  var ae = { label: 0, sent: function() {
    if (we[0] & 1)
      throw we[1];
    return we[1];
  }, trys: [], ops: [] }, fe, ye, we, _e = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return _e.next = xe(0), _e.throw = xe(1), _e.return = xe(2), typeof Symbol == "function" && (_e[Symbol.iterator] = function() {
    return this;
  }), _e;
  function xe($e) {
    return function(Re) {
      return Oe([$e, Re]);
    };
  }
  function Oe($e) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; _e && (_e = 0, $e[0] && (ae = 0)), ae; )
      try {
        if (fe = 1, ye && (we = $e[0] & 2 ? ye.return : $e[0] ? ye.throw || ((we = ye.return) && we.call(ye), 0) : ye.next) && !(we = we.call(ye, $e[1])).done)
          return we;
        switch (ye = 0, we && ($e = [$e[0] & 2, we.value]), $e[0]) {
          case 0:
          case 1:
            we = $e;
            break;
          case 4:
            return ae.label++, { value: $e[1], done: !1 };
          case 5:
            ae.label++, ye = $e[1], $e = [0];
            continue;
          case 7:
            $e = ae.ops.pop(), ae.trys.pop();
            continue;
          default:
            if (we = ae.trys, !(we = we.length > 0 && we[we.length - 1]) && ($e[0] === 6 || $e[0] === 2)) {
              ae = 0;
              continue;
            }
            if ($e[0] === 3 && (!we || $e[1] > we[0] && $e[1] < we[3])) {
              ae.label = $e[1];
              break;
            }
            if ($e[0] === 6 && ae.label < we[1]) {
              ae.label = we[1], we = $e;
              break;
            }
            if (we && ae.label < we[2]) {
              ae.label = we[2], ae.ops.push($e);
              break;
            }
            we[2] && ae.ops.pop(), ae.trys.pop();
            continue;
        }
        $e = oe.call(ne, ae);
      } catch (Re) {
        $e = [6, Re], ye = 0;
      } finally {
        fe = we = 0;
      }
    if ($e[0] & 5)
      throw $e[1];
    return { value: $e[0] ? $e[1] : void 0, done: !0 };
  }
}
function __values(ne) {
  var oe = typeof Symbol == "function" && Symbol.iterator, ae = oe && ne[oe], fe = 0;
  if (ae)
    return ae.call(ne);
  if (ne && typeof ne.length == "number")
    return {
      next: function() {
        return ne && fe >= ne.length && (ne = void 0), { value: ne && ne[fe++], done: !ne };
      }
    };
  throw new TypeError(oe ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, we = [], _e;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      we.push(ye.value);
  } catch (xe) {
    _e = { error: xe };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (_e)
        throw _e.error;
    }
  }
  return we;
}
function __spreadArray(ne, oe, ae) {
  if (ae || arguments.length === 2)
    for (var fe = 0, ye = oe.length, we; fe < ye; fe++)
      (we || !(fe in oe)) && (we || (we = Array.prototype.slice.call(oe, 0, fe)), we[fe] = oe[fe]);
  return ne.concat(we || Array.prototype.slice.call(oe));
}
function __await(ne) {
  return this instanceof __await ? (this.v = ne, this) : new __await(ne);
}
function __asyncGenerator(ne, oe, ae) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var fe = ae.apply(ne, oe || []), ye, we = [];
  return ye = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), xe("next"), xe("throw"), xe("return", _e), ye[Symbol.asyncIterator] = function() {
    return this;
  }, ye;
  function _e(Be) {
    return function(ze) {
      return Promise.resolve(ze).then(Be, Ne);
    };
  }
  function xe(Be, ze) {
    fe[Be] && (ye[Be] = function(He) {
      return new Promise(function(qe, Ye) {
        we.push([Be, He, qe, Ye]) > 1 || Oe(Be, He);
      });
    }, ze && (ye[Be] = ze(ye[Be])));
  }
  function Oe(Be, ze) {
    try {
      $e(fe[Be](ze));
    } catch (He) {
      je(we[0][3], He);
    }
  }
  function $e(Be) {
    Be.value instanceof __await ? Promise.resolve(Be.value.v).then(Re, Ne) : je(we[0][2], Be);
  }
  function Re(Be) {
    Oe("next", Be);
  }
  function Ne(Be) {
    Oe("throw", Be);
  }
  function je(Be, ze) {
    Be(ze), we.shift(), we.length && Oe(we[0][0], we[0][1]);
  }
}
function __asyncValues(ne) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var oe = ne[Symbol.asyncIterator], ae;
  return oe ? oe.call(ne) : (ne = typeof __values == "function" ? __values(ne) : ne[Symbol.iterator](), ae = {}, fe("next"), fe("throw"), fe("return"), ae[Symbol.asyncIterator] = function() {
    return this;
  }, ae);
  function fe(we) {
    ae[we] = ne[we] && function(_e) {
      return new Promise(function(xe, Oe) {
        _e = ne[we](_e), ye(xe, Oe, _e.done, _e.value);
      });
    };
  }
  function ye(we, _e, xe, Oe) {
    Promise.resolve(Oe).then(function($e) {
      we({ value: $e, done: xe });
    }, _e);
  }
}
typeof SuppressedError == "function" && SuppressedError;
function isFunction$1(ne) {
  return typeof ne == "function";
}
function createErrorClass(ne) {
  var oe = function(fe) {
    Error.call(fe), fe.stack = new Error().stack;
  }, ae = ne(oe);
  return ae.prototype = Object.create(Error.prototype), ae.prototype.constructor = ae, ae;
}
var UnsubscriptionError = createErrorClass(function(ne) {
  return function(ae) {
    ne(this), this.message = ae ? ae.length + ` errors occurred during unsubscription:
` + ae.map(function(fe, ye) {
      return ye + 1 + ") " + fe.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = ae;
  };
});
function arrRemove(ne, oe) {
  if (ne) {
    var ae = ne.indexOf(oe);
    0 <= ae && ne.splice(ae, 1);
  }
}
var Subscription = function() {
  function ne(oe) {
    this.initialTeardown = oe, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return ne.prototype.unsubscribe = function() {
    var oe, ae, fe, ye, we;
    if (!this.closed) {
      this.closed = !0;
      var _e = this._parentage;
      if (_e)
        if (this._parentage = null, Array.isArray(_e))
          try {
            for (var xe = __values(_e), Oe = xe.next(); !Oe.done; Oe = xe.next()) {
              var $e = Oe.value;
              $e.remove(this);
            }
          } catch (He) {
            oe = { error: He };
          } finally {
            try {
              Oe && !Oe.done && (ae = xe.return) && ae.call(xe);
            } finally {
              if (oe)
                throw oe.error;
            }
          }
        else
          _e.remove(this);
      var Re = this.initialTeardown;
      if (isFunction$1(Re))
        try {
          Re();
        } catch (He) {
          we = He instanceof UnsubscriptionError ? He.errors : [He];
        }
      var Ne = this._finalizers;
      if (Ne) {
        this._finalizers = null;
        try {
          for (var je = __values(Ne), Be = je.next(); !Be.done; Be = je.next()) {
            var ze = Be.value;
            try {
              execFinalizer(ze);
            } catch (He) {
              we = we ?? [], He instanceof UnsubscriptionError ? we = __spreadArray(__spreadArray([], __read(we)), __read(He.errors)) : we.push(He);
            }
          }
        } catch (He) {
          fe = { error: He };
        } finally {
          try {
            Be && !Be.done && (ye = je.return) && ye.call(je);
          } finally {
            if (fe)
              throw fe.error;
          }
        }
      }
      if (we)
        throw new UnsubscriptionError(we);
    }
  }, ne.prototype.add = function(oe) {
    var ae;
    if (oe && oe !== this)
      if (this.closed)
        execFinalizer(oe);
      else {
        if (oe instanceof ne) {
          if (oe.closed || oe._hasParent(this))
            return;
          oe._addParent(this);
        }
        (this._finalizers = (ae = this._finalizers) !== null && ae !== void 0 ? ae : []).push(oe);
      }
  }, ne.prototype._hasParent = function(oe) {
    var ae = this._parentage;
    return ae === oe || Array.isArray(ae) && ae.includes(oe);
  }, ne.prototype._addParent = function(oe) {
    var ae = this._parentage;
    this._parentage = Array.isArray(ae) ? (ae.push(oe), ae) : ae ? [ae, oe] : oe;
  }, ne.prototype._removeParent = function(oe) {
    var ae = this._parentage;
    ae === oe ? this._parentage = null : Array.isArray(ae) && arrRemove(ae, oe);
  }, ne.prototype.remove = function(oe) {
    var ae = this._finalizers;
    ae && arrRemove(ae, oe), oe instanceof ne && oe._removeParent(this);
  }, ne.EMPTY = function() {
    var oe = new ne();
    return oe.closed = !0, oe;
  }(), ne;
}(), EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(ne) {
  return ne instanceof Subscription || ne && "closed" in ne && isFunction$1(ne.remove) && isFunction$1(ne.add) && isFunction$1(ne.unsubscribe);
}
function execFinalizer(ne) {
  isFunction$1(ne) ? ne() : ne.unsubscribe();
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, timeoutProvider = {
  setTimeout: function(ne, oe) {
    for (var ae = [], fe = 2; fe < arguments.length; fe++)
      ae[fe - 2] = arguments[fe];
    var ye = timeoutProvider.delegate;
    return ye != null && ye.setTimeout ? ye.setTimeout.apply(ye, __spreadArray([ne, oe], __read(ae))) : setTimeout.apply(void 0, __spreadArray([ne, oe], __read(ae)));
  },
  clearTimeout: function(ne) {
    var oe = timeoutProvider.delegate;
    return ((oe == null ? void 0 : oe.clearTimeout) || clearTimeout)(ne);
  },
  delegate: void 0
};
function reportUnhandledError(ne) {
  timeoutProvider.setTimeout(function() {
    throw ne;
  });
}
function noop$1() {
}
function errorContext(ne) {
  ne();
}
var Subscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae) {
    var fe = ne.call(this) || this;
    return fe.isStopped = !1, ae ? (fe.destination = ae, isSubscription(ae) && ae.add(fe)) : fe.destination = EMPTY_OBSERVER, fe;
  }
  return oe.create = function(ae, fe, ye) {
    return new SafeSubscriber(ae, fe, ye);
  }, oe.prototype.next = function(ae) {
    this.isStopped || this._next(ae);
  }, oe.prototype.error = function(ae) {
    this.isStopped || (this.isStopped = !0, this._error(ae));
  }, oe.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, oe.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, ne.prototype.unsubscribe.call(this), this.destination = null);
  }, oe.prototype._next = function(ae) {
    this.destination.next(ae);
  }, oe.prototype._error = function(ae) {
    try {
      this.destination.error(ae);
    } finally {
      this.unsubscribe();
    }
  }, oe.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, oe;
}(Subscription), _bind = Function.prototype.bind;
function bind(ne, oe) {
  return _bind.call(ne, oe);
}
var ConsumerObserver = function() {
  function ne(oe) {
    this.partialObserver = oe;
  }
  return ne.prototype.next = function(oe) {
    var ae = this.partialObserver;
    if (ae.next)
      try {
        ae.next(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
  }, ne.prototype.error = function(oe) {
    var ae = this.partialObserver;
    if (ae.error)
      try {
        ae.error(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
    else
      handleUnhandledError(oe);
  }, ne.prototype.complete = function() {
    var oe = this.partialObserver;
    if (oe.complete)
      try {
        oe.complete();
      } catch (ae) {
        handleUnhandledError(ae);
      }
  }, ne;
}(), SafeSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    var we = ne.call(this) || this, _e;
    if (isFunction$1(ae) || !ae)
      _e = {
        next: ae ?? void 0,
        error: fe ?? void 0,
        complete: ye ?? void 0
      };
    else {
      var xe;
      we && config.useDeprecatedNextContext ? (xe = Object.create(ae), xe.unsubscribe = function() {
        return we.unsubscribe();
      }, _e = {
        next: ae.next && bind(ae.next, xe),
        error: ae.error && bind(ae.error, xe),
        complete: ae.complete && bind(ae.complete, xe)
      }) : _e = ae;
    }
    return we.destination = new ConsumerObserver(_e), we;
  }
  return oe;
}(Subscriber);
function handleUnhandledError(ne) {
  reportUnhandledError(ne);
}
function defaultErrorHandler(ne) {
  throw ne;
}
var EMPTY_OBSERVER = {
  closed: !0,
  next: noop$1,
  error: defaultErrorHandler,
  complete: noop$1
}, observable$1 = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(ne) {
  return ne;
}
function pipe() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return pipeFromArray(ne);
}
function pipeFromArray(ne) {
  return ne.length === 0 ? identity$1 : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce(function(fe, ye) {
      return ye(fe);
    }, ae);
  };
}
var Observable = function() {
  function ne(oe) {
    oe && (this._subscribe = oe);
  }
  return ne.prototype.lift = function(oe) {
    var ae = new ne();
    return ae.source = this, ae.operator = oe, ae;
  }, ne.prototype.subscribe = function(oe, ae, fe) {
    var ye = this, we = isSubscriber(oe) ? oe : new SafeSubscriber(oe, ae, fe);
    return errorContext(function() {
      var _e = ye, xe = _e.operator, Oe = _e.source;
      we.add(xe ? xe.call(we, Oe) : Oe ? ye._subscribe(we) : ye._trySubscribe(we));
    }), we;
  }, ne.prototype._trySubscribe = function(oe) {
    try {
      return this._subscribe(oe);
    } catch (ae) {
      oe.error(ae);
    }
  }, ne.prototype.forEach = function(oe, ae) {
    var fe = this;
    return ae = getPromiseCtor(ae), new ae(function(ye, we) {
      var _e = new SafeSubscriber({
        next: function(xe) {
          try {
            oe(xe);
          } catch (Oe) {
            we(Oe), _e.unsubscribe();
          }
        },
        error: we,
        complete: ye
      });
      fe.subscribe(_e);
    });
  }, ne.prototype._subscribe = function(oe) {
    var ae;
    return (ae = this.source) === null || ae === void 0 ? void 0 : ae.subscribe(oe);
  }, ne.prototype[observable$1] = function() {
    return this;
  }, ne.prototype.pipe = function() {
    for (var oe = [], ae = 0; ae < arguments.length; ae++)
      oe[ae] = arguments[ae];
    return pipeFromArray(oe)(this);
  }, ne.prototype.toPromise = function(oe) {
    var ae = this;
    return oe = getPromiseCtor(oe), new oe(function(fe, ye) {
      var we;
      ae.subscribe(function(_e) {
        return we = _e;
      }, function(_e) {
        return ye(_e);
      }, function() {
        return fe(we);
      });
    });
  }, ne.create = function(oe) {
    return new ne(oe);
  }, ne;
}();
function getPromiseCtor(ne) {
  var oe;
  return (oe = ne ?? config.Promise) !== null && oe !== void 0 ? oe : Promise;
}
function isObserver(ne) {
  return ne && isFunction$1(ne.next) && isFunction$1(ne.error) && isFunction$1(ne.complete);
}
function isSubscriber(ne) {
  return ne && ne instanceof Subscriber || isObserver(ne) && isSubscription(ne);
}
function hasLift(ne) {
  return isFunction$1(ne == null ? void 0 : ne.lift);
}
function operate(ne) {
  return function(oe) {
    if (hasLift(oe))
      return oe.lift(function(ae) {
        try {
          return ne(ae, this);
        } catch (fe) {
          this.error(fe);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(ne, oe, ae, fe, ye) {
  return new OperatorSubscriber(ne, oe, ae, fe, ye);
}
var OperatorSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye, we, _e, xe) {
    var Oe = ne.call(this, ae) || this;
    return Oe.onFinalize = _e, Oe.shouldUnsubscribe = xe, Oe._next = fe ? function($e) {
      try {
        fe($e);
      } catch (Re) {
        ae.error(Re);
      }
    } : ne.prototype._next, Oe._error = we ? function($e) {
      try {
        we($e);
      } catch (Re) {
        ae.error(Re);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._error, Oe._complete = ye ? function() {
      try {
        ye();
      } catch ($e) {
        ae.error($e);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._complete, Oe;
  }
  return oe.prototype.unsubscribe = function() {
    var ae;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var fe = this.closed;
      ne.prototype.unsubscribe.call(this), !fe && ((ae = this.onFinalize) === null || ae === void 0 || ae.call(this));
    }
  }, oe;
}(Subscriber), ObjectUnsubscribedError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Subject = function(ne) {
  __extends(oe, ne);
  function oe() {
    var ae = ne.call(this) || this;
    return ae.closed = !1, ae.currentObservers = null, ae.observers = [], ae.isStopped = !1, ae.hasError = !1, ae.thrownError = null, ae;
  }
  return oe.prototype.lift = function(ae) {
    var fe = new AnonymousSubject(this, this);
    return fe.operator = ae, fe;
  }, oe.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
  }, oe.prototype.next = function(ae) {
    var fe = this;
    errorContext(function() {
      var ye, we;
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.currentObservers || (fe.currentObservers = Array.from(fe.observers));
        try {
          for (var _e = __values(fe.currentObservers), xe = _e.next(); !xe.done; xe = _e.next()) {
            var Oe = xe.value;
            Oe.next(ae);
          }
        } catch ($e) {
          ye = { error: $e };
        } finally {
          try {
            xe && !xe.done && (we = _e.return) && we.call(_e);
          } finally {
            if (ye)
              throw ye.error;
          }
        }
      }
    });
  }, oe.prototype.error = function(ae) {
    var fe = this;
    errorContext(function() {
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.hasError = fe.isStopped = !0, fe.thrownError = ae;
        for (var ye = fe.observers; ye.length; )
          ye.shift().error(ae);
      }
    });
  }, oe.prototype.complete = function() {
    var ae = this;
    errorContext(function() {
      if (ae._throwIfClosed(), !ae.isStopped) {
        ae.isStopped = !0;
        for (var fe = ae.observers; fe.length; )
          fe.shift().complete();
      }
    });
  }, oe.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(oe.prototype, "observed", {
    get: function() {
      var ae;
      return ((ae = this.observers) === null || ae === void 0 ? void 0 : ae.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), oe.prototype._trySubscribe = function(ae) {
    return this._throwIfClosed(), ne.prototype._trySubscribe.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(ae), this._innerSubscribe(ae);
  }, oe.prototype._innerSubscribe = function(ae) {
    var fe = this, ye = this, we = ye.hasError, _e = ye.isStopped, xe = ye.observers;
    return we || _e ? EMPTY_SUBSCRIPTION : (this.currentObservers = null, xe.push(ae), new Subscription(function() {
      fe.currentObservers = null, arrRemove(xe, ae);
    }));
  }, oe.prototype._checkFinalizedStatuses = function(ae) {
    var fe = this, ye = fe.hasError, we = fe.thrownError, _e = fe.isStopped;
    ye ? ae.error(we) : _e && ae.complete();
  }, oe.prototype.asObservable = function() {
    var ae = new Observable();
    return ae.source = this, ae;
  }, oe.create = function(ae, fe) {
    return new AnonymousSubject(ae, fe);
  }, oe;
}(Observable), AnonymousSubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe) {
    var ye = ne.call(this) || this;
    return ye.destination = ae, ye.source = fe, ye;
  }
  return oe.prototype.next = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.next) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.error = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.error) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.complete = function() {
    var ae, fe;
    (fe = (ae = this.destination) === null || ae === void 0 ? void 0 : ae.complete) === null || fe === void 0 || fe.call(ae);
  }, oe.prototype._subscribe = function(ae) {
    var fe, ye;
    return (ye = (fe = this.source) === null || fe === void 0 ? void 0 : fe.subscribe(ae)) !== null && ye !== void 0 ? ye : EMPTY_SUBSCRIPTION;
  }, oe;
}(Subject), dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
}, ReplaySubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    ae === void 0 && (ae = 1 / 0), fe === void 0 && (fe = 1 / 0), ye === void 0 && (ye = dateTimestampProvider);
    var we = ne.call(this) || this;
    return we._bufferSize = ae, we._windowTime = fe, we._timestampProvider = ye, we._buffer = [], we._infiniteTimeWindow = !0, we._infiniteTimeWindow = fe === 1 / 0, we._bufferSize = Math.max(1, ae), we._windowTime = Math.max(1, fe), we;
  }
  return oe.prototype.next = function(ae) {
    var fe = this, ye = fe.isStopped, we = fe._buffer, _e = fe._infiniteTimeWindow, xe = fe._timestampProvider, Oe = fe._windowTime;
    ye || (we.push(ae), !_e && we.push(xe.now() + Oe)), this._trimBuffer(), ne.prototype.next.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    this._throwIfClosed(), this._trimBuffer();
    for (var fe = this._innerSubscribe(ae), ye = this, we = ye._infiniteTimeWindow, _e = ye._buffer, xe = _e.slice(), Oe = 0; Oe < xe.length && !ae.closed; Oe += we ? 1 : 2)
      ae.next(xe[Oe]);
    return this._checkFinalizedStatuses(ae), fe;
  }, oe.prototype._trimBuffer = function() {
    var ae = this, fe = ae._bufferSize, ye = ae._timestampProvider, we = ae._buffer, _e = ae._infiniteTimeWindow, xe = (_e ? 1 : 2) * fe;
    if (fe < 1 / 0 && xe < we.length && we.splice(0, we.length - xe), !_e) {
      for (var Oe = ye.now(), $e = 0, Re = 1; Re < we.length && we[Re] <= Oe; Re += 2)
        $e = Re;
      $e && we.splice(0, $e + 1);
    }
  }, oe;
}(Subject), EMPTY = new Observable(function(ne) {
  return ne.complete();
});
function isScheduler(ne) {
  return ne && isFunction$1(ne.schedule);
}
function last(ne) {
  return ne[ne.length - 1];
}
function popResultSelector(ne) {
  return isFunction$1(last(ne)) ? ne.pop() : void 0;
}
function popScheduler(ne) {
  return isScheduler(last(ne)) ? ne.pop() : void 0;
}
function popNumber(ne, oe) {
  return typeof last(ne) == "number" ? ne.pop() : oe;
}
var isArrayLike = function(ne) {
  return ne && typeof ne.length == "number" && typeof ne != "function";
};
function isPromise(ne) {
  return isFunction$1(ne == null ? void 0 : ne.then);
}
function isInteropObservable(ne) {
  return isFunction$1(ne[observable$1]);
}
function isAsyncIterable(ne) {
  return Symbol.asyncIterator && isFunction$1(ne == null ? void 0 : ne[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(ne) {
  return new TypeError("You provided " + (ne !== null && typeof ne == "object" ? "an invalid object" : "'" + ne + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(ne) {
  return isFunction$1(ne == null ? void 0 : ne[iterator]);
}
function readableStreamLikeToAsyncGenerator(ne) {
  return __asyncGenerator(this, arguments, function() {
    var ae, fe, ye, we;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          ae = ne.getReader(), _e.label = 1;
        case 1:
          _e.trys.push([1, , 9, 10]), _e.label = 2;
        case 2:
          return [4, __await(ae.read())];
        case 3:
          return fe = _e.sent(), ye = fe.value, we = fe.done, we ? [4, __await(void 0)] : [3, 5];
        case 4:
          return [2, _e.sent()];
        case 5:
          return [4, __await(ye)];
        case 6:
          return [4, _e.sent()];
        case 7:
          return _e.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return ae.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(ne) {
  return isFunction$1(ne == null ? void 0 : ne.getReader);
}
function innerFrom(ne) {
  if (ne instanceof Observable)
    return ne;
  if (ne != null) {
    if (isInteropObservable(ne))
      return fromInteropObservable(ne);
    if (isArrayLike(ne))
      return fromArrayLike(ne);
    if (isPromise(ne))
      return fromPromise(ne);
    if (isAsyncIterable(ne))
      return fromAsyncIterable(ne);
    if (isIterable(ne))
      return fromIterable(ne);
    if (isReadableStreamLike(ne))
      return fromReadableStreamLike(ne);
  }
  throw createInvalidObservableTypeError(ne);
}
function fromInteropObservable(ne) {
  return new Observable(function(oe) {
    var ae = ne[observable$1]();
    if (isFunction$1(ae.subscribe))
      return ae.subscribe(oe);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(ne) {
  return new Observable(function(oe) {
    for (var ae = 0; ae < ne.length && !oe.closed; ae++)
      oe.next(ne[ae]);
    oe.complete();
  });
}
function fromPromise(ne) {
  return new Observable(function(oe) {
    ne.then(function(ae) {
      oe.closed || (oe.next(ae), oe.complete());
    }, function(ae) {
      return oe.error(ae);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(ne) {
  return new Observable(function(oe) {
    var ae, fe;
    try {
      for (var ye = __values(ne), we = ye.next(); !we.done; we = ye.next()) {
        var _e = we.value;
        if (oe.next(_e), oe.closed)
          return;
      }
    } catch (xe) {
      ae = { error: xe };
    } finally {
      try {
        we && !we.done && (fe = ye.return) && fe.call(ye);
      } finally {
        if (ae)
          throw ae.error;
      }
    }
    oe.complete();
  });
}
function fromAsyncIterable(ne) {
  return new Observable(function(oe) {
    process$1(ne, oe).catch(function(ae) {
      return oe.error(ae);
    });
  });
}
function fromReadableStreamLike(ne) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(ne));
}
function process$1(ne, oe) {
  var ae, fe, ye, we;
  return __awaiter(this, void 0, void 0, function() {
    var _e, xe;
    return __generator(this, function(Oe) {
      switch (Oe.label) {
        case 0:
          Oe.trys.push([0, 5, 6, 11]), ae = __asyncValues(ne), Oe.label = 1;
        case 1:
          return [4, ae.next()];
        case 2:
          if (fe = Oe.sent(), !!fe.done)
            return [3, 4];
          if (_e = fe.value, oe.next(_e), oe.closed)
            return [2];
          Oe.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return xe = Oe.sent(), ye = { error: xe }, [3, 11];
        case 6:
          return Oe.trys.push([6, , 9, 10]), fe && !fe.done && (we = ae.return) ? [4, we.call(ae)] : [3, 8];
        case 7:
          Oe.sent(), Oe.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (ye)
            throw ye.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return oe.complete(), [2];
      }
    });
  });
}
function executeSchedule(ne, oe, ae, fe, ye) {
  fe === void 0 && (fe = 0), ye === void 0 && (ye = !1);
  var we = oe.schedule(function() {
    ae(), ye ? ne.add(this.schedule(null, fe)) : this.unsubscribe();
  }, fe);
  if (ne.add(we), !ye)
    return we;
}
function observeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    ae.subscribe(createOperatorSubscriber(fe, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.next(ye);
      }, oe);
    }, function() {
      return executeSchedule(fe, ne, function() {
        return fe.complete();
      }, oe);
    }, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.error(ye);
      }, oe);
    }));
  });
}
function subscribeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    fe.add(ne.schedule(function() {
      return ae.subscribe(fe);
    }, oe));
  });
}
function scheduleObservable(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function schedulePromise(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function scheduleArray(ne, oe) {
  return new Observable(function(ae) {
    var fe = 0;
    return oe.schedule(function() {
      fe === ne.length ? ae.complete() : (ae.next(ne[fe++]), ae.closed || this.schedule());
    });
  });
}
function scheduleIterable(ne, oe) {
  return new Observable(function(ae) {
    var fe;
    return executeSchedule(ae, oe, function() {
      fe = ne[iterator](), executeSchedule(ae, oe, function() {
        var ye, we, _e;
        try {
          ye = fe.next(), we = ye.value, _e = ye.done;
        } catch (xe) {
          ae.error(xe);
          return;
        }
        _e ? ae.complete() : ae.next(we);
      }, 0, !0);
    }), function() {
      return isFunction$1(fe == null ? void 0 : fe.return) && fe.return();
    };
  });
}
function scheduleAsyncIterable(ne, oe) {
  if (!ne)
    throw new Error("Iterable cannot be null");
  return new Observable(function(ae) {
    executeSchedule(ae, oe, function() {
      var fe = ne[Symbol.asyncIterator]();
      executeSchedule(ae, oe, function() {
        fe.next().then(function(ye) {
          ye.done ? ae.complete() : ae.next(ye.value);
        });
      }, 0, !0);
    });
  });
}
function scheduleReadableStreamLike(ne, oe) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(ne), oe);
}
function scheduled(ne, oe) {
  if (ne != null) {
    if (isInteropObservable(ne))
      return scheduleObservable(ne, oe);
    if (isArrayLike(ne))
      return scheduleArray(ne, oe);
    if (isPromise(ne))
      return schedulePromise(ne, oe);
    if (isAsyncIterable(ne))
      return scheduleAsyncIterable(ne, oe);
    if (isIterable(ne))
      return scheduleIterable(ne, oe);
    if (isReadableStreamLike(ne))
      return scheduleReadableStreamLike(ne, oe);
  }
  throw createInvalidObservableTypeError(ne);
}
function from(ne, oe) {
  return oe ? scheduled(ne, oe) : innerFrom(ne);
}
function of() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne);
  return from(ne, ae);
}
var EmptyError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function firstValueFrom(ne, oe) {
  var ae = typeof oe == "object";
  return new Promise(function(fe, ye) {
    var we = new SafeSubscriber({
      next: function(_e) {
        fe(_e), we.unsubscribe();
      },
      error: ye,
      complete: function() {
        ae ? fe(oe.defaultValue) : ye(new EmptyError());
      }
    });
    ne.subscribe(we);
  });
}
function map(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(we) {
      fe.next(ne.call(oe, we, ye++));
    }));
  });
}
var isArray$1 = Array.isArray;
function callOrApply(ne, oe) {
  return isArray$1(oe) ? ne.apply(void 0, __spreadArray([], __read(oe))) : ne(oe);
}
function mapOneOrManyArgs(ne) {
  return map(function(oe) {
    return callOrApply(ne, oe);
  });
}
var isArray = Array.isArray, getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(ne) {
  if (ne.length === 1) {
    var oe = ne[0];
    if (isArray(oe))
      return { args: oe, keys: null };
    if (isPOJO(oe)) {
      var ae = getKeys(oe);
      return {
        args: ae.map(function(fe) {
          return oe[fe];
        }),
        keys: ae
      };
    }
  }
  return { args: ne, keys: null };
}
function isPOJO(ne) {
  return ne && typeof ne == "object" && getPrototypeOf(ne) === objectProto;
}
function createObject(ne, oe) {
  return ne.reduce(function(ae, fe, ye) {
    return ae[fe] = oe[ye], ae;
  }, {});
}
function combineLatest() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popResultSelector(ne), ye = argsArgArrayOrObject(ne), we = ye.args, _e = ye.keys;
  if (we.length === 0)
    return from([], ae);
  var xe = new Observable(combineLatestInit(we, ae, _e ? function(Oe) {
    return createObject(_e, Oe);
  } : identity$1));
  return fe ? xe.pipe(mapOneOrManyArgs(fe)) : xe;
}
function combineLatestInit(ne, oe, ae) {
  return ae === void 0 && (ae = identity$1), function(fe) {
    maybeSchedule(oe, function() {
      for (var ye = ne.length, we = new Array(ye), _e = ye, xe = ye, Oe = function(Re) {
        maybeSchedule(oe, function() {
          var Ne = from(ne[Re], oe), je = !1;
          Ne.subscribe(createOperatorSubscriber(fe, function(Be) {
            we[Re] = Be, je || (je = !0, xe--), xe || fe.next(ae(we.slice()));
          }, function() {
            --_e || fe.complete();
          }));
        }, fe);
      }, $e = 0; $e < ye; $e++)
        Oe($e);
    }, fe);
  };
}
function maybeSchedule(ne, oe, ae) {
  ne ? executeSchedule(ae, ne, oe) : oe();
}
function mergeInternals(ne, oe, ae, fe, ye, we, _e, xe) {
  var Oe = [], $e = 0, Re = 0, Ne = !1, je = function() {
    Ne && !Oe.length && !$e && oe.complete();
  }, Be = function(He) {
    return $e < fe ? ze(He) : Oe.push(He);
  }, ze = function(He) {
    we && oe.next(He), $e++;
    var qe = !1;
    innerFrom(ae(He, Re++)).subscribe(createOperatorSubscriber(oe, function(Ye) {
      ye == null || ye(Ye), we ? Be(Ye) : oe.next(Ye);
    }, function() {
      qe = !0;
    }, void 0, function() {
      if (qe)
        try {
          $e--;
          for (var Ye = function() {
            var ot = Oe.shift();
            _e ? executeSchedule(oe, _e, function() {
              return ze(ot);
            }) : ze(ot);
          }; Oe.length && $e < fe; )
            Ye();
          je();
        } catch (ot) {
          oe.error(ot);
        }
    }));
  };
  return ne.subscribe(createOperatorSubscriber(oe, Be, function() {
    Ne = !0, je();
  })), function() {
    xe == null || xe();
  };
}
function mergeMap(ne, oe, ae) {
  return ae === void 0 && (ae = 1 / 0), isFunction$1(oe) ? mergeMap(function(fe, ye) {
    return map(function(we, _e) {
      return oe(fe, we, ye, _e);
    })(innerFrom(ne(fe, ye)));
  }, ae) : (typeof oe == "number" && (ae = oe), operate(function(fe, ye) {
    return mergeInternals(fe, ye, ne, ae);
  }));
}
function mergeAll(ne) {
  return ne === void 0 && (ne = 1 / 0), mergeMap(identity$1, ne);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return concatAll()(from(ne, popScheduler(ne)));
}
function defer(ne) {
  return new Observable(function(oe) {
    innerFrom(ne()).subscribe(oe);
  });
}
function merge() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popNumber(ne, 1 / 0), ye = ne;
  return ye.length ? ye.length === 1 ? innerFrom(ye[0]) : mergeAll(fe)(from(ye, ae)) : EMPTY;
}
function filter(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(we) {
      return ne.call(oe, we, ye++) && fe.next(we);
    }));
  });
}
function catchError(ne) {
  return operate(function(oe, ae) {
    var fe = null, ye = !1, we;
    fe = oe.subscribe(createOperatorSubscriber(ae, void 0, void 0, function(_e) {
      we = innerFrom(ne(_e, catchError(ne)(oe))), fe ? (fe.unsubscribe(), fe = null, we.subscribe(ae)) : ye = !0;
    })), ye && (fe.unsubscribe(), fe = null, we.subscribe(ae));
  });
}
function scanInternals(ne, oe, ae, fe, ye) {
  return function(we, _e) {
    var xe = ae, Oe = oe, $e = 0;
    we.subscribe(createOperatorSubscriber(_e, function(Re) {
      var Ne = $e++;
      Oe = xe ? ne(Oe, Re, Ne) : (xe = !0, Re), fe && _e.next(Oe);
    }, ye && function() {
      xe && _e.next(Oe), _e.complete();
    }));
  };
}
function concatMap(ne, oe) {
  return isFunction$1(oe) ? mergeMap(ne, oe, 1) : mergeMap(ne, 1);
}
function take(ne) {
  return ne <= 0 ? function() {
    return EMPTY;
  } : operate(function(oe, ae) {
    var fe = 0;
    oe.subscribe(createOperatorSubscriber(ae, function(ye) {
      ++fe <= ne && (ae.next(ye), ne <= fe && ae.complete());
    }));
  });
}
function scan(ne, oe) {
  return operate(scanInternals(ne, oe, arguments.length >= 2, !0));
}
function share(ne) {
  ne === void 0 && (ne = {});
  var oe = ne.connector, ae = oe === void 0 ? function() {
    return new Subject();
  } : oe, fe = ne.resetOnError, ye = fe === void 0 ? !0 : fe, we = ne.resetOnComplete, _e = we === void 0 ? !0 : we, xe = ne.resetOnRefCountZero, Oe = xe === void 0 ? !0 : xe;
  return function($e) {
    var Re = null, Ne = null, je = null, Be = 0, ze = !1, He = !1, qe = function() {
      Ne == null || Ne.unsubscribe(), Ne = null;
    }, Ye = function() {
      qe(), Re = je = null, ze = He = !1;
    }, ot = function() {
      var tt = Re;
      Ye(), tt == null || tt.unsubscribe();
    };
    return operate(function(tt, it) {
      Be++, !He && !ze && qe();
      var ht = je = je ?? ae();
      it.add(function() {
        Be--, Be === 0 && !He && !ze && (Ne = handleReset(ot, Oe));
      }), ht.subscribe(it), Re || (Re = new SafeSubscriber({
        next: function(gt) {
          return ht.next(gt);
        },
        error: function(gt) {
          He = !0, qe(), Ne = handleReset(Ye, ye, gt), ht.error(gt);
        },
        complete: function() {
          ze = !0, qe(), Ne = handleReset(Ye, _e), ht.complete();
        }
      }), from(tt).subscribe(Re));
    })($e);
  };
}
function handleReset(ne, oe) {
  for (var ae = [], fe = 2; fe < arguments.length; fe++)
    ae[fe - 2] = arguments[fe];
  return oe === !0 ? (ne(), null) : oe === !1 ? null : oe.apply(void 0, __spreadArray([], __read(ae))).pipe(take(1)).subscribe(function() {
    return ne();
  });
}
function shareReplay(ne, oe, ae) {
  var fe, ye, we, _e, xe = !1;
  return ne && typeof ne == "object" ? (fe = ne.bufferSize, _e = fe === void 0 ? 1 / 0 : fe, ye = ne.windowTime, oe = ye === void 0 ? 1 / 0 : ye, we = ne.refCount, xe = we === void 0 ? !1 : we, ae = ne.scheduler) : _e = ne ?? 1 / 0, share({
    connector: function() {
      return new ReplaySubject(_e, oe, ae);
    },
    resetOnError: !0,
    resetOnComplete: !1,
    resetOnRefCountZero: xe
  });
}
function tap(ne, oe, ae) {
  var fe = isFunction$1(ne) || oe || ae ? { next: ne, error: oe, complete: ae } : ne;
  return fe ? operate(function(ye, we) {
    var _e;
    (_e = fe.subscribe) === null || _e === void 0 || _e.call(fe);
    var xe = !0;
    ye.subscribe(createOperatorSubscriber(we, function(Oe) {
      var $e;
      ($e = fe.next) === null || $e === void 0 || $e.call(fe, Oe), we.next(Oe);
    }, function() {
      var Oe;
      xe = !1, (Oe = fe.complete) === null || Oe === void 0 || Oe.call(fe), we.complete();
    }, function(Oe) {
      var $e;
      xe = !1, ($e = fe.error) === null || $e === void 0 || $e.call(fe, Oe), we.error(Oe);
    }, function() {
      var Oe, $e;
      xe && ((Oe = fe.unsubscribe) === null || Oe === void 0 || Oe.call(fe)), ($e = fe.finalize) === null || $e === void 0 || $e.call(fe);
    }));
  }) : identity$1;
}
var g$4 = z$1("mud:block-events-stream"), k$4 = z$1("mud:block-events-stream");
g$4.log = console.debug.bind(console);
k$4.log = console.error.bind(console);
var p$2 = ["rate limit exceeded", "over rate limit", "sender is over rate limit"], B$1 = ["block range exceeded", "backend response too large", "block range is too large", "block is out of range"];
async function* u$1({ maxBlockRange: ne = 1000n, maxRetryCount: oe = 3, publicClient: ae, ...fe }) {
  let ye = fe.fromBlock, we = l$6(ne, fe.toBlock - ye), _e = 0;
  for (; ye <= fe.toBlock; )
    try {
      let xe = ye + we;
      g$4("getting logs", { fromBlock: ye, toBlock: xe });
      let Oe = await ae.getLogs({ ...fe, fromBlock: ye, toBlock: xe, strict: !0 });
      yield { fromBlock: ye, toBlock: xe, logs: Oe }, ye = xe + 1n, we = l$6(ne, fe.toBlock - ye);
    } catch (xe) {
      if (g$4("error getting logs:", String(xe)), !(xe instanceof Error))
        throw xe;
      if (_e < oe && p$2.some((Oe) => xe.message.includes(Oe))) {
        let Oe = 2 * _e;
        g$4(`too many requests, retrying in ${Oe}s`, xe), await B$3(1e3 * Oe), _e += 1;
        continue;
      }
      if (B$1.some((Oe) => xe.message.includes(Oe))) {
        if (we /= 2n, we <= 0n)
          throw new Error("can't reduce block range any further");
        g$4("block range exceeded or too many logs in range, trying a smaller block range", xe);
        continue;
      }
      throw xe;
    }
}
function M$3({ publicClient: ne, blockTag: oe }) {
  return new Observable(function(ae) {
    return ne.watchBlocks({ blockTag: oe, emitOnBegin: !0, onBlock: (fe) => ae.next(fe), onError: (fe) => ae.error(fe) });
  });
}
function K$4(ne, oe) {
  let ae = Array.from(new Set(ne.map((we) => we.blockNumber)));
  ae.sort(s$1);
  let fe = ae.map((we) => {
    let _e = ne.filter((xe) => xe.blockNumber === we);
    if (_e.length && (_e.sort((xe, Oe) => xe.logIndex < Oe.logIndex ? -1 : xe.logIndex > Oe.logIndex ? 1 : 0), !!_e.length))
      return { blockNumber: we, logs: _e };
  }).filter(b$7), ye = ae.length > 0 ? ae[ae.length - 1] : null;
  return oe != null && (ye == null || oe > ye) && fe.push({ blockNumber: oe, logs: [] }), fe;
}
function O(ne) {
  let oe = Object.values(ne.namespaces).flatMap((ae) => Object.values(ae.tables));
  return Object.fromEntries(oe.map((ae) => [ae.label, ae]));
}
var A$3 = { ...O(o$5), ...O(a$2) }, K$3 = Object.values(A$3).map((ne) => ne.tableId), L$2 = { ...A$3.Tables, keySchema: ia(Xi$1(A$3.Tables)), valueSchema: ia(Zi(A$3.Tables)) }, V$2 = ((ne) => (ne.INITIALIZE = "initialize", ne.SNAPSHOT = "snapshot", ne.RPC = "rpc", ne.LIVE = "live", ne))(V$2 || {});
function j$2(ne) {
  return { eventName: "Store_SetRecord", address: ne.address, args: { tableId: L$2.tableId, keyTuple: Yt(L$2.keySchema, { tableId: ne.tableId }), ...N$5(L$2.valueSchema, { fieldLayout: _i(ne.valueSchema), keySchema: zi(ne.keySchema), valueSchema: Ji(ne.valueSchema), abiEncodedKeyNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.keySchema)]), abiEncodedFieldNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.valueSchema)]) }) } };
}
function P$4(ne) {
  return [...ne.map(j$2), ...ne.flatMap((oe) => oe.records.map((ae) => ({ eventName: "Store_SetRecord", address: oe.address, args: { tableId: oe.tableId, keyTuple: Yt(ia(Xi$1(oe)), ae.key), ...N$5(ia(Zi(oe)), ae.value) } })))];
}
var S = z$1("mud:store-sync"), he$1 = z$1("mud:store-sync");
S.log = console.debug.bind(console);
he$1.log = console.error.bind(console);
var I$6 = S.extend("getSnapshot");
async function U$3({ chainId: ne, address: oe, filters: ae, initialState: fe, initialBlockLogs: ye, indexerUrl: we }) {
  if (ye && fe)
    throw new Error("Only one of initialBlockLogs or initialState should be provided.");
  if (ye)
    return ye;
  if (fe)
    return { blockNumber: fe.blockNumber, logs: P$4(fe.tables) };
  if (!we)
    return;
  let _e = new URL(we).origin, xe = s$3({ url: _e }), Oe = g$8({ url: `${_e}/trpc` });
  I$6("fetching logs from indexer via get", we);
  let $e = await xe.getLogs({ chainId: ne, address: oe, filters: ae });
  if (be($e))
    return $e.ok;
  console.warn($e.error);
  try {
    return I$6("fetching logs from indexer via trpc", we), await Oe.getLogs.query({ chainId: ne, address: oe, filters: ae });
  } catch (Re) {
    if (Re instanceof TRPCClientError) {
      I$6("failed to fetch logs, fetching table records instead", we);
      let Ne = await Oe.findAll.query({ chainId: ne, address: oe, filters: ae });
      return console.warn(`The indexer at ${we} appears to be outdated. Consider upgrading to a recent version for better performance.`), Ne.blockNumber == null ? void 0 : { blockNumber: Ne.blockNumber, logs: P$4(Ne.tables) };
    }
    throw Re;
  }
}
async function* q$2({ storageAdapter: ne, logFilter: oe, ...ae }) {
  for await (let { logs: fe, toBlock: ye } of u$1(ae)) {
    let we = K$4(oe ? fe.filter(oe) : fe, ye);
    for (let _e of we)
      await ne(_e), yield _e;
  }
}
var m$2 = S.extend("createStoreSync"), We = K$3.map((ne) => ({ tableId: ne }));
async function Et({ storageAdapter: ne, onProgress: oe, publicClient: ae, address: fe, filters: ye = [], tableIds: we = [], followBlockTag: _e = "latest", startBlock: xe = 0n, maxBlockRange: Oe, initialState: $e, initialBlockLogs: Re, indexerUrl: Ne }) {
  let je = ye.length || we.length ? [...ye, ...we.map((Vt) => ({ tableId: Vt })), ...We] : [], Be = je.length ? (Vt) => je.some((on) => on.tableId === Vt.args.tableId && (on.key0 == null || on.key0 === Vt.args.keyTuple[0]) && (on.key1 == null || on.key1 === Vt.args.keyTuple[1])) : void 0, ze = defer(async () => {
    var tn;
    let Vt = ((tn = ae.chain) == null ? void 0 : tn.id) ?? await ae.getChainId();
    oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Getting snapshot" });
    let on = await U$3({ chainId: Vt, address: fe, filters: je, initialState: $e, initialBlockLogs: Re, indexerUrl: Ne !== !1 ? Ne ?? (ae.chain && "indexerUrl" in ae.chain && typeof ae.chain.indexerUrl == "string" ? ae.chain.indexerUrl : void 0) : void 0 });
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Got snapshot" }), on;
  }).pipe(catchError((Vt) => (m$2("error getting snapshot", Vt), oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: xe, message: "Failed to get snapshot" }), of(void 0))), shareReplay(1)), He = ze.pipe(filter(b$7), concatMap(async ({ blockNumber: Vt, logs: on }) => {
    m$2("hydrating", on.length, "logs to block", Vt), oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: Vt, message: "Hydrating from snapshot" });
    let tn = Math.max(100, Math.floor(on.length / 50)), _n = Array.from(m$6(on, tn));
    for (let [en, dn] of _n.entries())
      await ne({ blockNumber: Vt, logs: dn }), oe == null || oe({ step: "snapshot", percentage: (en + 1) / _n.length * 100, latestBlockNumber: 0n, lastBlockNumberProcessed: Vt, message: "Hydrating from snapshot" }), await N$7();
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: Vt, message: "Hydrated from snapshot" }), { blockNumber: Vt, logs: on };
  }), shareReplay(1)), qe = ze.pipe(map((Vt) => a$5((Vt == null ? void 0 : Vt.blockNumber) ?? 0n, xe)), tap((Vt) => m$2("starting sync from block", Vt))), Ye = M$3({ publicClient: ae, blockTag: _e }).pipe(shareReplay(1)), ot = Ye.pipe(map((Vt) => Vt.number), tap((Vt) => {
    m$2("on block number", Vt, "for", _e, "block tag");
  }), shareReplay(1)), tt = null, it = null, ht = null, gt = combineLatest([qe, ot]).pipe(map(([Vt, on]) => ({ startBlock: Vt, endBlock: on })), tap((Vt) => {
    tt = Vt.startBlock, it = Vt.endBlock;
  }), concatMap((Vt) => {
    let on = q$2({ publicClient: ae, address: fe, events: p$3, maxBlockRange: Oe, fromBlock: ht ? a$5(Vt.startBlock, ht + 1n) : Vt.startBlock, toBlock: Vt.endBlock, storageAdapter: ne, logFilter: Be });
    return from(on);
  }), tap(({ blockNumber: Vt, logs: on }) => {
    if (m$2("stored", on.length, "logs for block", Vt), ht = Vt, tt != null && it != null)
      if (Vt < it) {
        let tn = it - tt, _n = ht - tt;
        oe == null || oe({ step: "rpc", percentage: Number(_n * 1000n / tn) / 10, latestBlockNumber: it, lastBlockNumberProcessed: ht, message: "Hydrating from RPC" });
      } else
        oe == null || oe({ step: "live", percentage: 100, latestBlockNumber: it, lastBlockNumberProcessed: ht, message: "All caught up!" });
  }), share()), At = concat(He, gt).pipe(share()), St = 10, Nt = At.pipe(scan((Vt, on) => [on, ...Vt].slice(0, St), []), filter((Vt) => Vt.length > 0), shareReplay(1));
  async function Ft(Vt) {
    m$2("waiting for tx", Vt);
    let on = Nt.pipe(mergeMap(async (tn) => {
      for (let _n of tn)
        if (_n.logs.map((en) => en.transactionHash).includes(Vt))
          return { blockNumber: _n.blockNumber, status: "success", transactionHash: Vt };
      try {
        let _n = tn[0];
        m$2("fetching tx receipt for block", _n.blockNumber);
        let { status: en, blockNumber: dn, transactionHash: Ht } = await ae.getTransactionReceipt({ hash: Vt });
        if (_n.blockNumber >= dn)
          return { status: en, blockNumber: dn, transactionHash: Ht };
      } catch (_n) {
        if (_n instanceof TransactionReceiptNotFoundError)
          return;
        throw _n;
      }
    }), tap((tn) => m$2("has tx?", Vt, tn)));
    return await firstValueFrom(on.pipe(filter(b$7)));
  }
  return { latestBlock$: Ye, latestBlockNumber$: ot, storedBlockLogs$: At, waitForTransaction: Ft };
}
function L$1(ne) {
  return ne.eventName === "Store_SetRecord" && ne.args.tableId === L$2.tableId;
}
function K$2(ne) {
  let [oe, ...ae] = ne.args.keyTuple;
  ae.length && console.warn("registerSchema event is expected to have only one key in key tuple, but got multiple", ne);
  let fe = _$4(oe), ye = j$4(L$2.valueSchema, concatHex$1([ne.args.staticData, ne.args.encodedLengths, ne.args.dynamicData])), we = D$3(ye.keySchema), _e = D$3(ye.valueSchema), xe = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedKeyNames)[0], Oe = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedFieldNames)[0], $e = [..._e.staticFields, ..._e.dynamicFields], Re = Object.fromEntries(we.staticFields.map((je, Be) => [xe[Be], { type: je, internalType: je }])), Ne = Object.fromEntries($e.map((je, Be) => [Oe[Be], { type: je, internalType: je }]));
  return { address: ne.address, type: fe.type, namespace: fe.namespace, name: fe.name, tableId: oe, schema: { ...Re, ...Ne }, key: Object.keys(Re), keySchema: ia(Re), valueSchema: ia(Ne) };
}
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function ne(oe, ae) {
    return "Cannot apply '" + oe + "' to '" + ae.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function ne(oe, ae) {
    return "[mobx.array] Index out of bounds, " + oe + " is larger than " + ae;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function ne(oe) {
    return "Cannot initialize from classes that inherit from Map: " + oe.constructor.name;
  },
  20: function ne(oe) {
    return "Cannot initialize map from " + oe;
  },
  21: function ne(oe) {
    return "Cannot convert to map from '" + oe + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function ne(oe) {
    return "Cannot obtain administration from " + oe;
  },
  25: function ne(oe, ae) {
    return "the entry '" + oe + "' does not exist in the observable map '" + ae + "'";
  },
  26: "please specify a property",
  27: function ne(oe, ae) {
    return "no observable property '" + oe.toString() + "' found on the observable object '" + ae + "'";
  },
  28: function ne(oe) {
    return "Cannot obtain atom from " + oe;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function ne(oe, ae) {
    return "Cycle detected in computation " + oe + ": " + ae;
  },
  33: function ne(oe) {
    return "The setter of computed value '" + oe + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function ne(oe) {
    return "[ComputedValue '" + oe + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function ne(oe) {
    return "[mobx] `observableArray." + oe + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + oe + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
}, errors = process.env.NODE_ENV !== "production" ? niceErrors : {};
function die(ne) {
  for (var oe = arguments.length, ae = new Array(oe > 1 ? oe - 1 : 0), fe = 1; fe < oe; fe++)
    ae[fe - 1] = arguments[fe];
  if (process.env.NODE_ENV !== "production") {
    var ye = typeof ne == "string" ? ne : errors[ne];
    throw typeof ye == "function" && (ye = ye.apply(null, ae)), new Error("[MobX] " + ye);
  }
  throw new Error(typeof ne == "number" ? "[MobX] minified error nr: " + ne + (ae.length ? " " + ae.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + ne);
}
var mockGlobal = {};
function getGlobal() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : mockGlobal;
}
var assign = Object.assign, getDescriptor = Object.getOwnPropertyDescriptor, defineProperty = Object.defineProperty, objectPrototype = Object.prototype, EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy < "u", plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  hasProxy || die(process.env.NODE_ENV !== "production" ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
}
function warnAboutProxyRequirement(ne) {
  process.env.NODE_ENV !== "production" && globalState.verifyProxies && die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + ne);
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(ne) {
  var oe = !1;
  return function() {
    if (!oe)
      return oe = !0, ne.apply(this, arguments);
  };
}
var noop = function ne() {
};
function isFunction(ne) {
  return typeof ne == "function";
}
function isStringish(ne) {
  var oe = typeof ne;
  switch (oe) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function isObject(ne) {
  return ne !== null && typeof ne == "object";
}
function isPlainObject(ne) {
  if (!isObject(ne))
    return !1;
  var oe = Object.getPrototypeOf(ne);
  if (oe == null)
    return !0;
  var ae = Object.hasOwnProperty.call(oe, "constructor") && oe.constructor;
  return typeof ae == "function" && ae.toString() === plainObjectString;
}
function isGenerator(ne) {
  var oe = ne == null ? void 0 : ne.constructor;
  return oe ? oe.name === "GeneratorFunction" || oe.displayName === "GeneratorFunction" : !1;
}
function addHiddenProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: ae
  });
}
function addHiddenFinalProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: ae
  });
}
function createInstanceofPredicate(ne, oe) {
  var ae = "isMobX" + ne;
  return oe.prototype[ae] = !0, function(fe) {
    return isObject(fe) && fe[ae] === !0;
  };
}
function isES6Map(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Map]";
}
function isPlainES6Map(ne) {
  var oe = Object.getPrototypeOf(ne), ae = Object.getPrototypeOf(oe), fe = Object.getPrototypeOf(ae);
  return fe === null;
}
function isES6Set(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols < "u";
function getPlainObjectKeys(ne) {
  var oe = Object.keys(ne);
  if (!hasGetOwnPropertySymbols)
    return oe;
  var ae = Object.getOwnPropertySymbols(ne);
  return ae.length ? [].concat(oe, ae.filter(function(fe) {
    return objectPrototype.propertyIsEnumerable.call(ne, fe);
  })) : oe;
}
var ownKeys = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(ne) {
  return Object.getOwnPropertyNames(ne).concat(Object.getOwnPropertySymbols(ne));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function stringifyKey(ne) {
  return typeof ne == "string" ? ne : typeof ne == "symbol" ? ne.toString() : new String(ne).toString();
}
function toPrimitive(ne) {
  return ne === null ? null : typeof ne == "object" ? "" + ne : ne;
}
function hasProp(ne, oe) {
  return objectPrototype.hasOwnProperty.call(ne, oe);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function ne(oe) {
  var ae = {};
  return ownKeys(oe).forEach(function(fe) {
    ae[fe] = getDescriptor(oe, fe);
  }), ae;
};
function getFlag(ne, oe) {
  return !!(ne & oe);
}
function setFlag(ne, oe, ae) {
  return ae ? ne |= oe : ne &= ~oe, ne;
}
function _arrayLikeToArray(ne, oe) {
  (oe == null || oe > ne.length) && (oe = ne.length);
  for (var ae = 0, fe = Array(oe); ae < oe; ae++)
    fe[ae] = ne[ae];
  return fe;
}
function _defineProperties(ne, oe) {
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(ne, _toPropertyKey(fe.key), fe);
  }
}
function _createClass(ne, oe, ae) {
  return oe && _defineProperties(ne.prototype, oe), ae && _defineProperties(ne, ae), Object.defineProperty(ne, "prototype", {
    writable: !1
  }), ne;
}
function _createForOfIteratorHelperLoose(ne, oe) {
  var ae = typeof Symbol < "u" && ne[Symbol.iterator] || ne["@@iterator"];
  if (ae)
    return (ae = ae.call(ne)).next.bind(ae);
  if (Array.isArray(ne) || (ae = _unsupportedIterableToArray(ne)) || oe && ne && typeof ne.length == "number") {
    ae && (ne = ae);
    var fe = 0;
    return function() {
      return fe >= ne.length ? {
        done: !0
      } : {
        done: !1,
        value: ne[fe++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        ({}).hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(ne, oe) {
  ne.prototype = Object.create(oe.prototype), ne.prototype.constructor = ne, _setPrototypeOf(ne, oe);
}
function _setPrototypeOf(ne, oe) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ae, fe) {
    return ae.__proto__ = fe, ae;
  }, _setPrototypeOf(ne, oe);
}
function _toPrimitive(ne, oe) {
  if (typeof ne != "object" || !ne)
    return ne;
  var ae = ne[Symbol.toPrimitive];
  if (ae !== void 0) {
    var fe = ae.call(ne, oe || "default");
    if (typeof fe != "object")
      return fe;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (oe === "string" ? String : Number)(ne);
}
function _toPropertyKey(ne) {
  var oe = _toPrimitive(ne, "string");
  return typeof oe == "symbol" ? oe : oe + "";
}
function _unsupportedIterableToArray(ne, oe) {
  if (ne) {
    if (typeof ne == "string")
      return _arrayLikeToArray(ne, oe);
    var ae = {}.toString.call(ne).slice(8, -1);
    return ae === "Object" && ne.constructor && (ae = ne.constructor.name), ae === "Map" || ae === "Set" ? Array.from(ne) : ae === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ae) ? _arrayLikeToArray(ne, oe) : void 0;
  }
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(ne) {
  function oe(ae, fe) {
    if (is20223Decorator(fe))
      return ne.decorate_20223_(ae, fe);
    storeAnnotation(ae, fe, ne);
  }
  return Object.assign(oe, ne);
}
function storeAnnotation(ne, oe, ae) {
  if (hasProp(ne, storedAnnotationsSymbol) || addHiddenProp(ne, storedAnnotationsSymbol, _extends({}, ne[storedAnnotationsSymbol])), process.env.NODE_ENV !== "production" && isOverride(ae) && !hasProp(ne[storedAnnotationsSymbol], oe)) {
    var fe = ne.constructor.name + ".prototype." + oe.toString();
    die("'" + fe + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(ne, ae, oe), isOverride(ae) || (ne[storedAnnotationsSymbol][oe] = ae);
}
function assertNotDecorated(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne[storedAnnotationsSymbol], ae)) {
    var fe = ne.constructor.name + ".prototype." + ae.toString(), ye = ne[storedAnnotationsSymbol][ae].annotationType_, we = oe.annotationType_;
    die("Cannot apply '@" + we + "' to '" + fe + "':" + (`
The field is already decorated with '@` + ye + "'.") + `
Re-decorating fields is not allowed.
Use '@override' decorator for methods overridden by subclass.`);
  }
}
function is20223Decorator(ne) {
  return typeof ne == "object" && typeof ne.kind == "string";
}
function assert20223DecoratorType(ne, oe) {
  process.env.NODE_ENV !== "production" && !oe.includes(ne.kind) && die("The decorator applied to '" + String(ne.name) + "' cannot be used on a " + ne.kind + " element");
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration"), Atom = /* @__PURE__ */ function() {
  function ne(ae) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Atom@" + getNextId() : "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = ae;
  }
  var oe = ne.prototype;
  return oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.reportObserved = function() {
    return reportObserved(this);
  }, oe.reportChanged = function() {
    startBatch(), propagateChanged(this), endBatch();
  }, oe.toString = function() {
    return this.name_;
  }, _createClass(ne, [{
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(ne, oe, ae) {
  oe === void 0 && (oe = noop), ae === void 0 && (ae = noop);
  var fe = new Atom(ne);
  return oe !== noop && onBecomeObserved(fe, oe), ae !== noop && onBecomeUnobserved(fe, ae), fe;
}
function identityComparer(ne, oe) {
  return ne === oe;
}
function structuralComparer(ne, oe) {
  return deepEqual(ne, oe);
}
function shallowComparer(ne, oe) {
  return deepEqual(ne, oe, 1);
}
function defaultComparer(ne, oe) {
  return Object.is ? Object.is(ne, oe) : ne === oe ? ne !== 0 || 1 / ne === 1 / oe : ne !== ne && oe !== oe;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(ne, oe, ae) {
  return isObservable(ne) ? ne : Array.isArray(ne) ? observable.array(ne, {
    name: ae
  }) : isPlainObject(ne) ? observable.object(ne, void 0, {
    name: ae
  }) : isES6Map(ne) ? observable.map(ne, {
    name: ae
  }) : isES6Set(ne) ? observable.set(ne, {
    name: ae
  }) : typeof ne == "function" && !isAction(ne) && !isFlow(ne) ? isGenerator(ne) ? flow(ne) : autoAction(ae, ne) : ne;
}
function shallowEnhancer(ne, oe, ae) {
  if (ne == null || isObservableObject(ne) || isObservableArray(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (Array.isArray(ne))
    return observable.array(ne, {
      name: ae,
      deep: !1
    });
  if (isPlainObject(ne))
    return observable.object(ne, void 0, {
      name: ae,
      deep: !1
    });
  if (isES6Map(ne))
    return observable.map(ne, {
      name: ae,
      deep: !1
    });
  if (isES6Set(ne))
    return observable.set(ne, {
      name: ae,
      deep: !1
    });
  process.env.NODE_ENV !== "production" && die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(ne) {
  return ne;
}
function refStructEnhancer(ne, oe) {
  return process.env.NODE_ENV !== "production" && isObservable(ne) && die("observable.struct should not be used with observable values"), deepEqual(ne, oe) ? oe : ne;
}
var OVERRIDE = "override";
function isOverride(ne) {
  return ne.annotationType_ === OVERRIDE;
}
function createActionAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(ne, oe, ae, fe) {
  var ye;
  if ((ye = this.options_) != null && ye.bound)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if (isAction(ae.value))
    return 1;
  var we = createActionDescriptor(ne, this, oe, ae, !1);
  return defineProperty(fe, oe, we), 2;
}
function extend_$1(ne, oe, ae, fe) {
  var ye = createActionDescriptor(ne, this, oe, ae);
  return ne.defineProperty_(oe, ye, fe);
}
function decorate_20223_$1(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method", "field"]);
  var ae = oe.kind, fe = oe.name, ye = oe.addInitializer, we = this, _e = function($e) {
    var Re, Ne, je, Be;
    return createAction((Re = (Ne = we.options_) == null ? void 0 : Ne.name) != null ? Re : fe.toString(), $e, (je = (Be = we.options_) == null ? void 0 : Be.autoAction) != null ? je : !1);
  };
  if (ae == "field") {
    ye(function() {
      storeAnnotation(this, fe, we);
    });
    return;
  }
  if (ae == "method") {
    var xe;
    return isAction(ne) || (ne = _e(ne)), (xe = this.options_) != null && xe.bound && ye(function() {
      var Oe = this, $e = Oe[fe].bind(Oe);
      $e.isMobxAction = !0, Oe[fe] = $e;
    }), ne;
  }
  die("Cannot apply '" + we.annotationType_ + "' to '" + String(fe) + "' (kind: " + ae + "):" + (`
'` + we.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, we = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(we) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a function value."));
}
function createActionDescriptor(ne, oe, ae, fe, ye) {
  var we, _e, xe, Oe, $e, Re, Ne;
  ye === void 0 && (ye = globalState.safeDescriptors), assertActionDescriptor(ne, oe, ae, fe);
  var je = fe.value;
  if ((we = oe.options_) != null && we.bound) {
    var Be;
    je = je.bind((Be = ne.proxy_) != null ? Be : ne.target_);
  }
  return {
    value: createAction(
      (_e = (xe = oe.options_) == null ? void 0 : xe.name) != null ? _e : ae.toString(),
      je,
      (Oe = ($e = oe.options_) == null ? void 0 : $e.autoAction) != null ? Oe : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (Re = oe.options_) != null && Re.bound ? (Ne = ne.proxy_) != null ? Ne : ne.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: ye ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !ye
  };
}
function createFlowAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(ne, oe, ae, fe) {
  var ye;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if ((ye = this.options_) != null && ye.bound && (!hasProp(ne.target_, oe) || !isFlow(ne.target_[oe])) && this.extend_(ne, oe, ae, !1) === null)
    return 0;
  if (isFlow(ae.value))
    return 1;
  var we = createFlowDescriptor(ne, this, oe, ae, !1, !1);
  return defineProperty(fe, oe, we), 2;
}
function extend_$2(ne, oe, ae, fe) {
  var ye, we = createFlowDescriptor(ne, this, oe, ae, (ye = this.options_) == null ? void 0 : ye.bound);
  return ne.defineProperty_(oe, we, fe);
}
function decorate_20223_$2(ne, oe) {
  var ae;
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method"]);
  var fe = oe.name, ye = oe.addInitializer;
  return isFlow(ne) || (ne = flow(ne)), (ae = this.options_) != null && ae.bound && ye(function() {
    var we = this, _e = we[fe].bind(we);
    _e.isMobXFlow = !0, we[fe] = _e;
  }), ne;
}
function assertFlowDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, we = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(we) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a generator function value."));
}
function createFlowDescriptor(ne, oe, ae, fe, ye, we) {
  we === void 0 && (we = globalState.safeDescriptors), assertFlowDescriptor(ne, oe, ae, fe);
  var _e = fe.value;
  if (isFlow(_e) || (_e = flow(_e)), ye) {
    var xe;
    _e = _e.bind((xe = ne.proxy_) != null ? xe : ne.target_), _e.isMobXFlow = !0;
  }
  return {
    value: _e,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: we ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !we
  };
}
function createComputedAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$3(ne, oe, ae, fe) {
  return assertComputedDescriptor(ne, this, oe, ae), ne.defineComputedProperty_(oe, _extends({}, this.options_, {
    get: ae.get,
    set: ae.set
  }), fe);
}
function decorate_20223_$3(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["getter"]);
  var ae = this, fe = oe.name, ye = oe.addInitializer;
  return ye(function() {
    var we = asObservableObject(this)[$mobx], _e = _extends({}, ae.options_, {
      get: ne,
      context: this
    });
    _e.name || (_e.name = process.env.NODE_ENV !== "production" ? we.name_ + "." + fe.toString() : "ObservableObject." + fe.toString()), we.values_.set(fe, new ComputedValue(_e));
  }), function() {
    return this[$mobx].getObservablePropValue_(fe);
  };
}
function assertComputedDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, we = fe.get;
  process.env.NODE_ENV !== "production" && !we && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on getter(+setter) properties."));
}
function createObservableAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$4(ne, oe, ae, fe) {
  var ye, we;
  return assertObservableDescriptor(ne, this, oe, ae), ne.defineObservableProperty_(oe, ae.value, (ye = (we = this.options_) == null ? void 0 : we.enhancer) != null ? ye : deepEnhancer, fe);
}
function decorate_20223_$4(ne, oe) {
  if (process.env.NODE_ENV !== "production") {
    if (oe.kind === "field")
      throw die("Please use `@observable accessor " + String(oe.name) + "` instead of `@observable " + String(oe.name) + "`");
    assert20223DecoratorType(oe, ["accessor"]);
  }
  var ae = this, fe = oe.kind, ye = oe.name, we = /* @__PURE__ */ new WeakSet();
  function _e(xe, Oe) {
    var $e, Re, Ne = asObservableObject(xe)[$mobx], je = new ObservableValue(Oe, ($e = (Re = ae.options_) == null ? void 0 : Re.enhancer) != null ? $e : deepEnhancer, process.env.NODE_ENV !== "production" ? Ne.name_ + "." + ye.toString() : "ObservableObject." + ye.toString(), !1);
    Ne.values_.set(ye, je), we.add(xe);
  }
  if (fe == "accessor")
    return {
      get: function() {
        return we.has(this) || _e(this, ne.get.call(this)), this[$mobx].getObservablePropValue_(ye);
      },
      set: function(Oe) {
        return we.has(this) || _e(this, Oe), this[$mobx].setObservablePropValue_(ye, Oe);
      },
      init: function(Oe) {
        return we.has(this) || _e(this, Oe), Oe;
      }
    };
}
function assertObservableDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_;
  process.env.NODE_ENV !== "production" && !("value" in fe) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' cannot be used on getter/setter properties"));
}
var AUTO = "true", autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(ne) {
  return {
    annotationType_: AUTO,
    options_: ne,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(ne, oe, ae, fe) {
  var ye, we;
  if (ae.get)
    return computed.make_(ne, oe, ae, fe);
  if (ae.set) {
    var _e = createAction(oe.toString(), ae.set);
    return fe === ne.target_ ? ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: _e
    }) === null ? 0 : 2 : (defineProperty(fe, oe, {
      configurable: !0,
      set: _e
    }), 2);
  }
  if (fe !== ne.target_ && typeof ae.value == "function") {
    var xe;
    if (isGenerator(ae.value)) {
      var Oe, $e = (Oe = this.options_) != null && Oe.autoBind ? flow.bound : flow;
      return $e.make_(ne, oe, ae, fe);
    }
    var Re = (xe = this.options_) != null && xe.autoBind ? autoAction.bound : autoAction;
    return Re.make_(ne, oe, ae, fe);
  }
  var Ne = ((ye = this.options_) == null ? void 0 : ye.deep) === !1 ? observable.ref : observable;
  if (typeof ae.value == "function" && (we = this.options_) != null && we.autoBind) {
    var je;
    ae.value = ae.value.bind((je = ne.proxy_) != null ? je : ne.target_);
  }
  return Ne.make_(ne, oe, ae, fe);
}
function extend_$5(ne, oe, ae, fe) {
  var ye, we;
  if (ae.get)
    return computed.extend_(ne, oe, ae, fe);
  if (ae.set)
    return ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: createAction(oe.toString(), ae.set)
    }, fe);
  if (typeof ae.value == "function" && (ye = this.options_) != null && ye.autoBind) {
    var _e;
    ae.value = ae.value.bind((_e = ne.proxy_) != null ? _e : ne.target_);
  }
  var xe = ((we = this.options_) == null ? void 0 : we.deep) === !1 ? observable.ref : observable;
  return xe.extend_(ne, oe, ae, fe);
}
function decorate_20223_$5(ne, oe) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable", OBSERVABLE_REF = "observable.ref", OBSERVABLE_SHALLOW = "observable.shallow", OBSERVABLE_STRUCT = "observable.struct", defaultCreateObservableOptions = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(ne) {
  return ne || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE), observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
}), observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
}), observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
}), observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(ne) {
  return ne.deep === !0 ? deepEnhancer : ne.deep === !1 ? referenceEnhancer : getEnhancerFromAnnotation(ne.defaultDecorator);
}
function getAnnotationFromOptions(ne) {
  var oe;
  return ne ? (oe = ne.defaultDecorator) != null ? oe : createAutoAnnotation(ne) : void 0;
}
function getEnhancerFromAnnotation(ne) {
  var oe, ae;
  return ne && (oe = (ae = ne.options_) == null ? void 0 : ae.enhancer) != null ? oe : deepEnhancer;
}
function createObservable(ne, oe, ae) {
  if (is20223Decorator(oe))
    return observableAnnotation.decorate_20223_(ne, oe);
  if (isStringish(oe)) {
    storeAnnotation(ne, oe, observableAnnotation);
    return;
  }
  return isObservable(ne) ? ne : isPlainObject(ne) ? observable.object(ne, oe, ae) : Array.isArray(ne) ? observable.array(ne, oe) : isES6Map(ne) ? observable.map(ne, oe) : isES6Set(ne) ? observable.set(ne, oe) : typeof ne == "object" && ne !== null ? ne : observable.box(ne, oe);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableValue(oe, getEnhancerFromOptions(fe), fe.name, !0, fe.equals);
  },
  array: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return (globalState.useProxies === !1 || fe.proxy === !1 ? createLegacyArray : createObservableArray)(oe, getEnhancerFromOptions(fe), fe.name);
  },
  map: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableMap(oe, getEnhancerFromOptions(fe), fe.name);
  },
  set: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableSet(oe, getEnhancerFromOptions(fe), fe.name);
  },
  object: function ne(oe, ae, fe) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === !1 || (fe == null ? void 0 : fe.proxy) === !1 ? asObservableObject({}, fe) : asDynamicObservableObject({}, fe), oe, ae);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
}, observable = /* @__PURE__ */ assign(createObservable, observableFactories), COMPUTED = "computed", COMPUTED_STRUCT = "computed.struct", computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED), computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
}), computed = function ne(oe, ae) {
  if (is20223Decorator(ae))
    return computedAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, computedAnnotation);
  if (isPlainObject(oe))
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, oe));
  process.env.NODE_ENV !== "production" && (isFunction(oe) || die("First argument to `computed` should be an expression."), isFunction(ae) && die("A setter as second argument is no longer supported, use `{ set: fn }` option instead"));
  var fe = isPlainObject(ae) ? ae : {};
  return fe.get = oe, fe.name || (fe.name = oe.name || ""), new ComputedValue(fe);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor, currentActionId = 0, nextActionId = 1, isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : !1, tmpNameDescriptor = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function createAction(ne, oe, ae, fe) {
  ae === void 0 && (ae = !1), process.env.NODE_ENV !== "production" && (isFunction(oe) || die("`action` can only be invoked on functions"), (typeof ne != "string" || !ne) && die("actions should have valid names, got: '" + ne + "'"));
  function ye() {
    return executeAction(ne, ae, oe, fe || this, arguments);
  }
  return ye.isMobxAction = !0, ye.toString = function() {
    return oe.toString();
  }, isFunctionNameConfigurable && (tmpNameDescriptor.value = ne, defineProperty(ye, "name", tmpNameDescriptor)), ye;
}
function executeAction(ne, oe, ae, fe, ye) {
  var we = _startAction(ne, oe, fe, ye);
  try {
    return ae.apply(fe, ye);
  } catch (_e) {
    throw we.error_ = _e, _e;
  } finally {
    _endAction(we);
  }
}
function _startAction(ne, oe, ae, fe) {
  var ye = process.env.NODE_ENV !== "production" && isSpyEnabled() && !!ne, we = 0;
  if (process.env.NODE_ENV !== "production" && ye) {
    we = Date.now();
    var _e = fe ? Array.from(fe) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: ne,
      object: ae,
      arguments: _e
    });
  }
  var xe = globalState.trackingDerivation, Oe = !oe || !xe;
  startBatch();
  var $e = globalState.allowStateChanges;
  Oe && (untrackedStart(), $e = allowStateChangesStart(!0));
  var Re = allowStateReadsStart(!0), Ne = {
    runAsAction_: Oe,
    prevDerivation_: xe,
    prevAllowStateChanges_: $e,
    prevAllowStateReads_: Re,
    notifySpy_: ye,
    startTime_: we,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  return currentActionId = Ne.actionId_, Ne;
}
function _endAction(ne) {
  currentActionId !== ne.actionId_ && die(30), currentActionId = ne.parentActionId_, ne.error_ !== void 0 && (globalState.suppressReactionErrors = !0), allowStateChangesEnd(ne.prevAllowStateChanges_), allowStateReadsEnd(ne.prevAllowStateReads_), endBatch(), ne.runAsAction_ && untrackedEnd(ne.prevDerivation_), process.env.NODE_ENV !== "production" && ne.notifySpy_ && spyReportEnd({
    time: Date.now() - ne.startTime_
  }), globalState.suppressReactionErrors = !1;
}
function allowStateChangesStart(ne) {
  var oe = globalState.allowStateChanges;
  return globalState.allowStateChanges = ne, oe;
}
function allowStateChangesEnd(ne) {
  globalState.allowStateChanges = ne;
}
var CREATE = "create", ObservableValue = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, we, _e, xe) {
    var Oe;
    return we === void 0 && (we = process.env.NODE_ENV !== "production" ? "ObservableValue@" + getNextId() : "ObservableValue"), _e === void 0 && (_e = !0), xe === void 0 && (xe = comparer.default), Oe = ne.call(this, we) || this, Oe.enhancer = void 0, Oe.name_ = void 0, Oe.equals = void 0, Oe.hasUnreportedChange_ = !1, Oe.interceptors_ = void 0, Oe.changeListeners_ = void 0, Oe.value_ = void 0, Oe.dehancer = void 0, Oe.enhancer = ye, Oe.name_ = we, Oe.equals = xe, Oe.value_ = ye(fe, void 0, we), process.env.NODE_ENV !== "production" && _e && isSpyEnabled() && spyReport({
      type: CREATE,
      object: Oe,
      observableKind: "value",
      debugObjectName: Oe.name_,
      newValue: "" + Oe.value_
    }), Oe;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.dehanceValue = function(ye) {
    return this.dehancer !== void 0 ? this.dehancer(ye) : ye;
  }, ae.set = function(ye) {
    var we = this.value_;
    if (ye = this.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var _e = isSpyEnabled();
      process.env.NODE_ENV !== "production" && _e && spyReportStart({
        type: UPDATE,
        object: this,
        observableKind: "value",
        debugObjectName: this.name_,
        newValue: ye,
        oldValue: we
      }), this.setNewValue_(ye), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
    }
  }, ae.prepareNewValue_ = function(ye) {
    if (checkIfStateModificationsAreAllowed(this), hasInterceptors(this)) {
      var we = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: ye
      });
      if (!we)
        return globalState.UNCHANGED;
      ye = we.newValue;
    }
    return ye = this.enhancer(ye, this.value_, this.name_), this.equals(this.value_, ye) ? globalState.UNCHANGED : ye;
  }, ae.setNewValue_ = function(ye) {
    var we = this.value_;
    this.value_ = ye, this.reportChanged(), hasListeners(this) && notifyListeners(this, {
      type: UPDATE,
      object: this,
      newValue: ye,
      oldValue: we
    });
  }, ae.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, ae.intercept_ = function(ye) {
    return registerInterceptor(this, ye);
  }, ae.observe_ = function(ye, we) {
    return we && ye({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: void 0
    }), registerListener(this, ye);
  }, ae.raw = function() {
    return this.value_;
  }, ae.toJSON = function() {
    return this.get();
  }, ae.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, ae.valueOf = function() {
    return toPrimitive(this.get());
  }, ae[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, oe;
}(Atom), ComputedValue = /* @__PURE__ */ function() {
  function ne(ae) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new CaughtException(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = TraceMode.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, ae.get || die(31), this.derivation = ae.get, this.name_ = ae.name || (process.env.NODE_ENV !== "production" ? "ComputedValue@" + getNextId() : "ComputedValue"), ae.set && (this.setter_ = createAction(process.env.NODE_ENV !== "production" ? this.name_ + "-setter" : "ComputedValue-setter", ae.set)), this.equals_ = ae.equals || (ae.compareStructural || ae.struct ? comparer.structural : comparer.default), this.scope_ = ae.context, this.requiresReaction_ = ae.requiresReaction, this.keepAlive_ = !!ae.keepAlive;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    propagateMaybeChanged(this);
  }, oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.get = function() {
    if (this.isComputing && die(32, this.name_, this.derivation), globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      shouldCompute(this) && (this.warnAboutUntrackedRead_(), startBatch(), this.value_ = this.computeValue_(!1), endBatch());
    else if (reportObserved(this), shouldCompute(this)) {
      var fe = globalState.trackingContext;
      this.keepAlive_ && !fe && (globalState.trackingContext = this), this.trackAndCompute() && propagateChangeConfirmed(this), globalState.trackingContext = fe;
    }
    var ye = this.value_;
    if (isCaughtException(ye))
      throw ye.cause;
    return ye;
  }, oe.set = function(fe) {
    if (this.setter_) {
      this.isRunningSetter && die(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, fe);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      die(34, this.name_);
  }, oe.trackAndCompute = function() {
    var fe = this.value_, ye = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    ), we = this.computeValue_(!0), _e = ye || isCaughtException(fe) || isCaughtException(we) || !this.equals_(fe, we);
    return _e && (this.value_ = we, process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      observableKind: "computed",
      debugObjectName: this.name_,
      object: this.scope_,
      type: "update",
      oldValue: fe,
      newValue: we
    })), _e;
  }, oe.computeValue_ = function(fe) {
    this.isComputing = !0;
    var ye = allowStateChangesStart(!1), we;
    if (fe)
      we = trackDerivedFunction(this, this.derivation, this.scope_);
    else if (globalState.disableErrorBoundaries === !0)
      we = this.derivation.call(this.scope_);
    else
      try {
        we = this.derivation.call(this.scope_);
      } catch (_e) {
        we = new CaughtException(_e);
      }
    return allowStateChangesEnd(ye), this.isComputing = !1, we;
  }, oe.suspend_ = function() {
    this.keepAlive_ || (clearObserving(this), this.value_ = void 0, process.env.NODE_ENV !== "production" && this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access."));
  }, oe.observe_ = function(fe, ye) {
    var we = this, _e = !0, xe = void 0;
    return autorun(function() {
      var Oe = we.get();
      if (!_e || ye) {
        var $e = untrackedStart();
        fe({
          observableKind: "computed",
          debugObjectName: we.name_,
          type: UPDATE,
          object: we,
          newValue: Oe,
          oldValue: xe
        }), untrackedEnd($e);
      }
      _e = !1, xe = Oe;
    });
  }, oe.warnAboutUntrackedRead_ = function() {
    process.env.NODE_ENV !== "production" && (this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."), (typeof this.requiresReaction_ == "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) && console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."));
  }, oe.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, oe.valueOf = function() {
    return toPrimitive(this.get());
  }, oe[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, _createClass(ne, [{
    key: "isComputing",
    get: function() {
      return getFlag(this.flags_, ne.isComputingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isComputingMask_, fe);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return getFlag(this.flags_, ne.isRunningSetterMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningSetterMask_, fe);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue), IDerivationState_;
(function(ne) {
  ne[ne.NOT_TRACKING_ = -1] = "NOT_TRACKING_", ne[ne.UP_TO_DATE_ = 0] = "UP_TO_DATE_", ne[ne.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", ne[ne.STALE_ = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(ne) {
  ne[ne.NONE = 0] = "NONE", ne[ne.LOG = 1] = "LOG", ne[ne.BREAK = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function ne(oe) {
  this.cause = void 0, this.cause = oe;
};
function isCaughtException(ne) {
  return ne instanceof CaughtException;
}
function shouldCompute(ne) {
  switch (ne.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return !1;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return !0;
    case IDerivationState_.POSSIBLY_STALE_: {
      for (var oe = allowStateReadsStart(!0), ae = untrackedStart(), fe = ne.observing_, ye = fe.length, we = 0; we < ye; we++) {
        var _e = fe[we];
        if (isComputedValue(_e)) {
          if (globalState.disableErrorBoundaries)
            _e.get();
          else
            try {
              _e.get();
            } catch {
              return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
            }
          if (ne.dependenciesState_ === IDerivationState_.STALE_)
            return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
        }
      }
      return changeDependenciesStateTo0(ne), untrackedEnd(ae), allowStateReadsEnd(oe), !1;
    }
  }
}
function checkIfStateModificationsAreAllowed(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = ne.observers_.size > 0;
    !globalState.allowStateChanges && (oe || globalState.enforceActions === "always") && console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + ne.name_);
  }
}
function checkIfStateReadsAreAllowed(ne) {
  process.env.NODE_ENV !== "production" && !globalState.allowStateReads && globalState.observableRequiresReaction && console.warn("[mobx] Observable '" + ne.name_ + "' being read outside a reactive context.");
}
function trackDerivedFunction(ne, oe, ae) {
  var fe = allowStateReadsStart(!0);
  changeDependenciesStateTo0(ne), ne.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    ne.runId_ === 0 ? 100 : ne.observing_.length
  ), ne.unboundDepsCount_ = 0, ne.runId_ = ++globalState.runId;
  var ye = globalState.trackingDerivation;
  globalState.trackingDerivation = ne, globalState.inBatch++;
  var we;
  if (globalState.disableErrorBoundaries === !0)
    we = oe.call(ae);
  else
    try {
      we = oe.call(ae);
    } catch (_e) {
      we = new CaughtException(_e);
    }
  return globalState.inBatch--, globalState.trackingDerivation = ye, bindDependencies(ne), warnAboutDerivationWithoutDependencies(ne), allowStateReadsEnd(fe), we;
}
function warnAboutDerivationWithoutDependencies(ne) {
  process.env.NODE_ENV !== "production" && ne.observing_.length === 0 && (typeof ne.requiresObservable_ == "boolean" ? ne.requiresObservable_ : globalState.reactionRequiresObservable) && console.warn("[mobx] Derivation '" + ne.name_ + "' is created/updated without reading any observable value.");
}
function bindDependencies(ne) {
  for (var oe = ne.observing_, ae = ne.observing_ = ne.newObserving_, fe = IDerivationState_.UP_TO_DATE_, ye = 0, we = ne.unboundDepsCount_, _e = 0; _e < we; _e++) {
    var xe = ae[_e];
    xe.diffValue === 0 && (xe.diffValue = 1, ye !== _e && (ae[ye] = xe), ye++), xe.dependenciesState_ > fe && (fe = xe.dependenciesState_);
  }
  for (ae.length = ye, ne.newObserving_ = null, we = oe.length; we--; ) {
    var Oe = oe[we];
    Oe.diffValue === 0 && removeObserver(Oe, ne), Oe.diffValue = 0;
  }
  for (; ye--; ) {
    var $e = ae[ye];
    $e.diffValue === 1 && ($e.diffValue = 0, addObserver($e, ne));
  }
  fe !== IDerivationState_.UP_TO_DATE_ && (ne.dependenciesState_ = fe, ne.onBecomeStale_());
}
function clearObserving(ne) {
  var oe = ne.observing_;
  ne.observing_ = [];
  for (var ae = oe.length; ae--; )
    removeObserver(oe[ae], ne);
  ne.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(ne) {
  var oe = untrackedStart();
  try {
    return ne();
  } finally {
    untrackedEnd(oe);
  }
}
function untrackedStart() {
  var ne = globalState.trackingDerivation;
  return globalState.trackingDerivation = null, ne;
}
function untrackedEnd(ne) {
  globalState.trackingDerivation = ne;
}
function allowStateReadsStart(ne) {
  var oe = globalState.allowStateReads;
  return globalState.allowStateReads = ne, oe;
}
function allowStateReadsEnd(ne) {
  globalState.allowStateReads = ne;
}
function changeDependenciesStateTo0(ne) {
  if (ne.dependenciesState_ !== IDerivationState_.UP_TO_DATE_) {
    ne.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    for (var oe = ne.observing_, ae = oe.length; ae--; )
      oe[ae].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function ne() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, canMergeGlobalState = !0, globalState = /* @__PURE__ */ function() {
  var ne = /* @__PURE__ */ getGlobal();
  return ne.__mobxInstanceCount > 0 && !ne.__mobxGlobals && (canMergeGlobalState = !1), ne.__mobxGlobals && ne.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = !1), canMergeGlobalState ? ne.__mobxGlobals ? (ne.__mobxInstanceCount += 1, ne.__mobxGlobals.UNCHANGED || (ne.__mobxGlobals.UNCHANGED = {}), ne.__mobxGlobals) : (ne.__mobxInstanceCount = 1, ne.__mobxGlobals = /* @__PURE__ */ new MobXGlobals()) : (setTimeout(function() {
    die(35);
  }, 1), new MobXGlobals());
}();
function addObserver(ne, oe) {
  ne.observers_.add(oe), ne.lowestObserverState_ > oe.dependenciesState_ && (ne.lowestObserverState_ = oe.dependenciesState_);
}
function removeObserver(ne, oe) {
  ne.observers_.delete(oe), ne.observers_.size === 0 && queueForUnobservation(ne);
}
function queueForUnobservation(ne) {
  ne.isPendingUnobservation === !1 && (ne.isPendingUnobservation = !0, globalState.pendingUnobservations.push(ne));
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    for (var ne = globalState.pendingUnobservations, oe = 0; oe < ne.length; oe++) {
      var ae = ne[oe];
      ae.isPendingUnobservation = !1, ae.observers_.size === 0 && (ae.isBeingObserved && (ae.isBeingObserved = !1, ae.onBUO()), ae instanceof ComputedValue && ae.suspend_());
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(ne) {
  checkIfStateReadsAreAllowed(ne);
  var oe = globalState.trackingDerivation;
  return oe !== null ? (oe.runId_ !== ne.lastAccessedBy_ && (ne.lastAccessedBy_ = oe.runId_, oe.newObserving_[oe.unboundDepsCount_++] = ne, !ne.isBeingObserved && globalState.trackingContext && (ne.isBeingObserved = !0, ne.onBO())), ne.isBeingObserved) : (ne.observers_.size === 0 && globalState.inBatch > 0 && queueForUnobservation(ne), !1);
}
function propagateChanged(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne), oe.onBecomeStale_()), oe.dependenciesState_ = IDerivationState_.STALE_;
  }));
}
function propagateChangeConfirmed(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_ ? (oe.dependenciesState_ = IDerivationState_.STALE_, process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne)) : oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.UP_TO_DATE_);
  }));
}
function propagateMaybeChanged(ne) {
  ne.lowestObserverState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (oe.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_, oe.onBecomeStale_());
  }));
}
function logTraceInfo(ne, oe) {
  if (console.log("[mobx.trace] '" + ne.name_ + "' is invalidated due to a change in: '" + oe.name_ + "'"), ne.isTracing_ === TraceMode.BREAK) {
    var ae = [];
    printDepTree(getDependencyTree(ne), ae, 1), new Function(`debugger;
/*
Tracing '` + ne.name_ + `'

You are entering this break point because derivation '` + ne.name_ + "' is being traced and '" + oe.name_ + `' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

` + (ne instanceof ComputedValue ? ne.derivation.toString().replace(/[*]\//g, "/") : "") + `

The dependencies for this derivation are:

` + ae.join(`
`) + `
*/
    `)();
  }
}
function printDepTree(ne, oe, ae) {
  if (oe.length >= 1e3) {
    oe.push("(and many more)");
    return;
  }
  oe.push("" + "	".repeat(ae - 1) + ne.name), ne.dependencies && ne.dependencies.forEach(function(fe) {
    return printDepTree(fe, oe, ae + 1);
  });
}
var Reaction = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, we) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Reaction@" + getNextId() : "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = TraceMode.NONE, this.name_ = ae, this.onInvalidate_ = fe, this.errorHandler_ = ye, this.requiresObservable_ = we;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    this.schedule_();
  }, oe.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, globalState.pendingReactions.push(this), runReactions());
  }, oe.runReaction_ = function() {
    if (!this.isDisposed) {
      startBatch(), this.isScheduled = !1;
      var fe = globalState.trackingContext;
      if (globalState.trackingContext = this, shouldCompute(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_(), process.env.NODE_ENV !== "production" && this.isTrackPending && isSpyEnabled() && spyReport({
            name: this.name_,
            type: "scheduled-reaction"
          });
        } catch (ye) {
          this.reportExceptionInDerivation_(ye);
        }
      }
      globalState.trackingContext = fe, endBatch();
    }
  }, oe.track = function(fe) {
    if (!this.isDisposed) {
      startBatch();
      var ye = isSpyEnabled(), we;
      process.env.NODE_ENV !== "production" && ye && (we = Date.now(), spyReportStart({
        name: this.name_,
        type: "reaction"
      })), this.isRunning = !0;
      var _e = globalState.trackingContext;
      globalState.trackingContext = this;
      var xe = trackDerivedFunction(this, fe, void 0);
      globalState.trackingContext = _e, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && clearObserving(this), isCaughtException(xe) && this.reportExceptionInDerivation_(xe.cause), process.env.NODE_ENV !== "production" && ye && spyReportEnd({
        time: Date.now() - we
      }), endBatch();
    }
  }, oe.reportExceptionInDerivation_ = function(fe) {
    var ye = this;
    if (this.errorHandler_) {
      this.errorHandler_(fe, this);
      return;
    }
    if (globalState.disableErrorBoundaries)
      throw fe;
    var we = process.env.NODE_ENV !== "production" ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    globalState.suppressReactionErrors ? process.env.NODE_ENV !== "production" && console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(we, fe), process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      type: "error",
      name: this.name_,
      message: we,
      error: "" + fe
    }), globalState.globalReactionErrorHandlers.forEach(function(_e) {
      return _e(fe, ye);
    });
  }, oe.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (startBatch(), clearObserving(this), endBatch()));
  }, oe.getDisposer_ = function(fe) {
    var ye = this, we = function _e() {
      ye.dispose(), fe == null || fe.removeEventListener == null || fe.removeEventListener("abort", _e);
    };
    return fe == null || fe.addEventListener == null || fe.addEventListener("abort", we), we[$mobx] = this, we;
  }, oe.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, oe.trace = function(fe) {
    fe === void 0 && (fe = !1), trace(this, fe);
  }, _createClass(ne, [{
    key: "isDisposed",
    get: function() {
      return getFlag(this.flags_, ne.isDisposedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isDisposedMask_, fe);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return getFlag(this.flags_, ne.isScheduledMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isScheduledMask_, fe);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return getFlag(this.flags_, ne.isTrackPendingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isTrackPendingMask_, fe);
    }
  }, {
    key: "isRunning",
    get: function() {
      return getFlag(this.flags_, ne.isRunningMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100, reactionScheduler = function ne(oe) {
  return oe();
};
function runReactions() {
  globalState.inBatch > 0 || globalState.isRunningReactions || reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = !0;
  for (var ne = globalState.pendingReactions, oe = 0; ne.length > 0; ) {
    ++oe === MAX_REACTION_ITERATIONS && (console.error(process.env.NODE_ENV !== "production" ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + ne[0]) : "[mobx] cycle in reaction: " + ne[0]), ne.splice(0));
    for (var ae = ne.splice(0), fe = 0, ye = ae.length; fe < ye; fe++)
      ae[fe].runReaction_();
  }
  globalState.isRunningReactions = !1;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return process.env.NODE_ENV !== "production" && !!globalState.spyListeners.length;
}
function spyReport(ne) {
  if (process.env.NODE_ENV !== "production" && globalState.spyListeners.length)
    for (var oe = globalState.spyListeners, ae = 0, fe = oe.length; ae < fe; ae++)
      oe[ae](ne);
}
function spyReportStart(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = _extends({}, ne, {
      spyReportStart: !0
    });
    spyReport(oe);
  }
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: !0
};
function spyReportEnd(ne) {
  process.env.NODE_ENV !== "production" && spyReport(ne ? _extends({}, ne, {
    type: "report-end",
    spyReportEnd: !0
  }) : END_EVENT);
}
function spy(ne) {
  return process.env.NODE_ENV === "production" ? (console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  }) : (globalState.spyListeners.push(ne), once(function() {
    globalState.spyListeners = globalState.spyListeners.filter(function(oe) {
      return oe !== ne;
    });
  }));
}
var ACTION = "action", ACTION_BOUND = "action.bound", AUTOACTION = "autoAction", AUTOACTION_BOUND = "autoAction.bound", DEFAULT_ACTION_NAME = "<unnamed action>", actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION), actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: !0
}), autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: !0
}), autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: !0,
  bound: !0
});
function createActionFactory(ne) {
  var oe = function(fe, ye) {
    if (isFunction(fe))
      return createAction(fe.name || DEFAULT_ACTION_NAME, fe, ne);
    if (isFunction(ye))
      return createAction(fe, ye, ne);
    if (is20223Decorator(ye))
      return (ne ? autoActionAnnotation : actionAnnotation).decorate_20223_(fe, ye);
    if (isStringish(ye))
      return storeAnnotation(fe, ye, ne ? autoActionAnnotation : actionAnnotation);
    if (isStringish(fe))
      return createDecoratorAnnotation(createActionAnnotation(ne ? AUTOACTION : ACTION, {
        name: fe,
        autoAction: ne
      }));
    process.env.NODE_ENV !== "production" && die("Invalid arguments for `action`");
  };
  return oe;
}
var action = /* @__PURE__ */ createActionFactory(!1);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(!0);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(ne) {
  return isFunction(ne) && ne.isMobxAction === !0;
}
function autorun(ne, oe) {
  var ae, fe, ye, we;
  oe === void 0 && (oe = EMPTY_OBJECT), process.env.NODE_ENV !== "production" && (isFunction(ne) || die("Autorun expects a function as first argument"), isAction(ne) && die("Autorun does not accept actions since actions are untrackable"));
  var _e = (ae = (fe = oe) == null ? void 0 : fe.name) != null ? ae : process.env.NODE_ENV !== "production" ? ne.name || "Autorun@" + getNextId() : "Autorun", xe = !oe.scheduler && !oe.delay, Oe;
  if (xe)
    Oe = new Reaction(_e, function() {
      this.track(Ne);
    }, oe.onError, oe.requiresObservable);
  else {
    var $e = createSchedulerFromOptions(oe), Re = !1;
    Oe = new Reaction(_e, function() {
      Re || (Re = !0, $e(function() {
        Re = !1, Oe.isDisposed || Oe.track(Ne);
      }));
    }, oe.onError, oe.requiresObservable);
  }
  function Ne() {
    ne(Oe);
  }
  return (ye = oe) != null && (ye = ye.signal) != null && ye.aborted || Oe.schedule_(), Oe.getDisposer_((we = oe) == null ? void 0 : we.signal);
}
var run = function ne(oe) {
  return oe();
};
function createSchedulerFromOptions(ne) {
  return ne.scheduler ? ne.scheduler : ne.delay ? function(oe) {
    return setTimeout(oe, ne.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO", ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_OBSERVED, ne, oe, ae);
}
function onBecomeUnobserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_UNOBSERVED, ne, oe, ae);
}
function interceptHook(ne, oe, ae, fe) {
  var ye = typeof fe == "function" ? getAtom(oe, ae) : getAtom(oe), we = isFunction(fe) ? fe : ae, _e = ne + "L";
  return ye[_e] ? ye[_e].add(we) : ye[_e] = /* @__PURE__ */ new Set([we]), function() {
    var xe = ye[_e];
    xe && (xe.delete(we), xe.size === 0 && delete ye[_e]);
  };
}
function extendObservable(ne, oe, ae, fe) {
  process.env.NODE_ENV !== "production" && (arguments.length > 4 && die("'extendObservable' expected 2-4 arguments"), typeof ne != "object" && die("'extendObservable' expects an object as first argument"), isObservableMap(ne) && die("'extendObservable' should not be used on maps, use map.merge instead"), isPlainObject(oe) || die("'extendObservable' only accepts plain objects as second argument"), (isObservable(oe) || isObservable(ae)) && die("Extending an object with another observable (object) is not supported"));
  var ye = getOwnPropertyDescriptors(oe);
  return initObservable(function() {
    var we = asObservableObject(ne, fe)[$mobx];
    ownKeys(ye).forEach(function(_e) {
      we.extend_(
        _e,
        ye[_e],
        // must pass "undefined" for { key: undefined }
        ae && _e in ae ? ae[_e] : !0
      );
    });
  }), ne;
}
function getDependencyTree(ne, oe) {
  return nodeToDependencyTree(getAtom(ne, oe));
}
function nodeToDependencyTree(ne) {
  var oe = {
    name: ne.name_
  };
  return ne.observing_ && ne.observing_.length > 0 && (oe.dependencies = unique(ne.observing_).map(nodeToDependencyTree)), oe;
}
function unique(ne) {
  return Array.from(new Set(ne));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow"), flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: !0
}), flow = /* @__PURE__ */ Object.assign(function ne(oe, ae) {
  if (is20223Decorator(ae))
    return flowAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, flowAnnotation);
  process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("Flow expects single argument with generator function");
  var fe = oe, ye = fe.name || "<unnamed flow>", we = function() {
    var xe = this, Oe = arguments, $e = ++generatorId, Re = action(ye + " - runid: " + $e + " - init", fe).apply(xe, Oe), Ne, je = void 0, Be = new Promise(function(ze, He) {
      var qe = 0;
      Ne = He;
      function Ye(it) {
        je = void 0;
        var ht;
        try {
          ht = action(ye + " - runid: " + $e + " - yield " + qe++, Re.next).call(Re, it);
        } catch (gt) {
          return He(gt);
        }
        tt(ht);
      }
      function ot(it) {
        je = void 0;
        var ht;
        try {
          ht = action(ye + " - runid: " + $e + " - yield " + qe++, Re.throw).call(Re, it);
        } catch (gt) {
          return He(gt);
        }
        tt(ht);
      }
      function tt(it) {
        if (isFunction(it == null ? void 0 : it.then)) {
          it.then(tt, He);
          return;
        }
        return it.done ? ze(it.value) : (je = Promise.resolve(it.value), je.then(Ye, ot));
      }
      Ye(void 0);
    });
    return Be.cancel = action(ye + " - runid: " + $e + " - cancel", function() {
      try {
        je && cancelPromise(je);
        var ze = Re.return(void 0), He = Promise.resolve(ze.value);
        He.then(noop, noop), cancelPromise(He), Ne(new FlowCancellationError());
      } catch (qe) {
        Ne(qe);
      }
    }), Be;
  };
  return we.isMobXFlow = !0, we;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(ne) {
  isFunction(ne.cancel) && ne.cancel();
}
function isFlow(ne) {
  return (ne == null ? void 0 : ne.isMobXFlow) === !0;
}
function _isObservable(ne, oe) {
  return ne ? oe !== void 0 ? process.env.NODE_ENV !== "production" && (isObservableMap(ne) || isObservableArray(ne)) ? die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.") : isObservableObject(ne) ? ne[$mobx].values_.has(oe) : !1 : isObservableObject(ne) || !!ne[$mobx] || isAtom(ne) || isReaction(ne) || isComputedValue(ne) : !1;
}
function isObservable(ne) {
  return process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"), _isObservable(ne);
}
function trace() {
  if (process.env.NODE_ENV !== "production") {
    for (var ne = !1, oe = arguments.length, ae = new Array(oe), fe = 0; fe < oe; fe++)
      ae[fe] = arguments[fe];
    typeof ae[ae.length - 1] == "boolean" && (ne = ae.pop());
    var ye = getAtomFromArgs(ae);
    if (!ye)
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    ye.isTracing_ === TraceMode.NONE && console.log("[mobx.trace] '" + ye.name_ + "' tracing enabled"), ye.isTracing_ = ne ? TraceMode.BREAK : TraceMode.LOG;
  }
}
function getAtomFromArgs(ne) {
  switch (ne.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(ne[0]);
    case 2:
      return getAtom(ne[0], ne[1]);
  }
}
function transaction(ne, oe) {
  oe === void 0 && (oe = void 0), startBatch();
  try {
    return ne.apply(oe);
  } finally {
    endBatch();
  }
}
function getAdm(ne) {
  return ne[$mobx];
}
var objectProxyTraps = {
  has: function ne(oe, ae) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."), getAdm(oe).has_(ae);
  },
  get: function ne(oe, ae) {
    return getAdm(oe).get_(ae);
  },
  set: function ne(oe, ae, fe) {
    var ye;
    return isStringish(ae) ? (process.env.NODE_ENV !== "production" && !getAdm(oe).values_.has(ae) && warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead."), (ye = getAdm(oe).set_(ae, fe, !0)) != null ? ye : !0) : !1;
  },
  deleteProperty: function ne(oe, ae) {
    var fe;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead."), isStringish(ae) ? (fe = getAdm(oe).delete_(ae, !0)) != null ? fe : !0 : !1;
  },
  defineProperty: function ne(oe, ae, fe) {
    var ye;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead."), (ye = getAdm(oe).defineProperty_(ae, fe)) != null ? ye : !0;
  },
  ownKeys: function ne(oe) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."), getAdm(oe).ownKeys_();
  },
  preventExtensions: function ne(oe) {
    die(13);
  }
};
function asDynamicObservableObject(ne, oe) {
  var ae, fe;
  return assertProxies(), ne = asObservableObject(ne, oe), (fe = (ae = ne[$mobx]).proxy_) != null ? fe : ae.proxy_ = new Proxy(ne, objectProxyTraps);
}
function hasInterceptors(ne) {
  return ne.interceptors_ !== void 0 && ne.interceptors_.length > 0;
}
function registerInterceptor(ne, oe) {
  var ae = ne.interceptors_ || (ne.interceptors_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function interceptChange(ne, oe) {
  var ae = untrackedStart();
  try {
    for (var fe = [].concat(ne.interceptors_ || []), ye = 0, we = fe.length; ye < we && (oe = fe[ye](oe), oe && !oe.type && die(14), !!oe); ye++)
      ;
    return oe;
  } finally {
    untrackedEnd(ae);
  }
}
function hasListeners(ne) {
  return ne.changeListeners_ !== void 0 && ne.changeListeners_.length > 0;
}
function registerListener(ne, oe) {
  var ae = ne.changeListeners_ || (ne.changeListeners_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function notifyListeners(ne, oe) {
  var ae = untrackedStart(), fe = ne.changeListeners_;
  if (fe) {
    fe = fe.slice();
    for (var ye = 0, we = fe.length; ye < we; ye++)
      fe[ye](oe);
    untrackedEnd(ae);
  }
}
var SPLICE = "splice", UPDATE = "update", MAX_SPLICE_SIZE = 1e4, arrayTraps = {
  get: function ne(oe, ae) {
    var fe = oe[$mobx];
    return ae === $mobx ? fe : ae === "length" ? fe.getArrayLength_() : typeof ae == "string" && !isNaN(ae) ? fe.get_(parseInt(ae)) : hasProp(arrayExtensions, ae) ? arrayExtensions[ae] : oe[ae];
  },
  set: function ne(oe, ae, fe) {
    var ye = oe[$mobx];
    return ae === "length" && ye.setArrayLength_(fe), typeof ae == "symbol" || isNaN(ae) ? oe[ae] = fe : ye.set_(parseInt(ae), fe), !0;
  },
  preventExtensions: function ne() {
    die(15);
  }
}, ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, we) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = ye, this.legacyMode_ = we, this.atom_ = new Atom(ae), this.enhancer_ = function(_e, xe) {
      return fe(_e, xe, process.env.NODE_ENV !== "production" ? ae + "[..]" : "ObservableArray[..]");
    };
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.dehanceValues_ = function(fe) {
    return this.dehancer !== void 0 && fe.length > 0 ? fe.map(this.dehancer) : fe;
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.observe_ = function(fe, ye) {
    return ye === void 0 && (ye = !1), ye && fe({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), registerListener(this, fe);
  }, oe.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, oe.setArrayLength_ = function(fe) {
    (typeof fe != "number" || isNaN(fe) || fe < 0) && die("Out of range: " + fe);
    var ye = this.values_.length;
    if (fe !== ye)
      if (fe > ye) {
        for (var we = new Array(fe - ye), _e = 0; _e < fe - ye; _e++)
          we[_e] = void 0;
        this.spliceWithArray_(ye, 0, we);
      } else
        this.spliceWithArray_(fe, ye - fe);
  }, oe.updateArrayLength_ = function(fe, ye) {
    fe !== this.lastKnownLength_ && die(16), this.lastKnownLength_ += ye, this.legacyMode_ && ye > 0 && reserveArrayBuffer(fe + ye + 1);
  }, oe.spliceWithArray_ = function(fe, ye, we) {
    var _e = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var xe = this.values_.length;
    if (fe === void 0 ? fe = 0 : fe > xe ? fe = xe : fe < 0 && (fe = Math.max(0, xe + fe)), arguments.length === 1 ? ye = xe - fe : ye == null ? ye = 0 : ye = Math.max(0, Math.min(ye, xe - fe)), we === void 0 && (we = EMPTY_ARRAY), hasInterceptors(this)) {
      var Oe = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: fe,
        removedCount: ye,
        added: we
      });
      if (!Oe)
        return EMPTY_ARRAY;
      ye = Oe.removedCount, we = Oe.added;
    }
    if (we = we.length === 0 ? we : we.map(function(Ne) {
      return _e.enhancer_(Ne, void 0);
    }), this.legacyMode_ || process.env.NODE_ENV !== "production") {
      var $e = we.length - ye;
      this.updateArrayLength_(xe, $e);
    }
    var Re = this.spliceItemsIntoValues_(fe, ye, we);
    return (ye !== 0 || we.length !== 0) && this.notifyArraySplice_(fe, we, Re), this.dehanceValues_(Re);
  }, oe.spliceItemsIntoValues_ = function(fe, ye, we) {
    if (we.length < MAX_SPLICE_SIZE) {
      var _e;
      return (_e = this.values_).splice.apply(_e, [fe, ye].concat(we));
    } else {
      var xe = this.values_.slice(fe, fe + ye), Oe = this.values_.slice(fe + ye);
      this.values_.length += we.length - ye;
      for (var $e = 0; $e < we.length; $e++)
        this.values_[fe + $e] = we[$e];
      for (var Re = 0; Re < Oe.length; Re++)
        this.values_[fe + we.length + Re] = Oe[Re];
      return xe;
    }
  }, oe.notifyArrayChildUpdate_ = function(fe, ye, we) {
    var _e = !this.owned_ && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: fe,
      newValue: ye,
      oldValue: we
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), this.atom_.reportChanged(), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.notifyArraySplice_ = function(fe, ye, we) {
    var _e = !this.owned_ && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: fe,
      removed: we,
      added: ye,
      removedCount: we.length,
      addedCount: ye.length
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), this.atom_.reportChanged(), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.get_ = function(fe) {
    if (this.legacyMode_ && fe >= this.values_.length) {
      console.warn(process.env.NODE_ENV !== "production" ? "[mobx.array] Attempt to read an array index (" + fe + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + fe);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[fe]);
  }, oe.set_ = function(fe, ye) {
    var we = this.values_;
    if (this.legacyMode_ && fe > we.length && die(17, fe, we.length), fe < we.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var _e = we[fe];
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: fe,
          newValue: ye
        });
        if (!xe)
          return;
        ye = xe.newValue;
      }
      ye = this.enhancer_(ye, _e);
      var Oe = ye !== _e;
      Oe && (we[fe] = ye, this.notifyArrayChildUpdate_(fe, ye, _e));
    } else {
      for (var $e = new Array(fe + 1 - we.length), Re = 0; Re < $e.length - 1; Re++)
        $e[Re] = void 0;
      $e[$e.length - 1] = ye, this.spliceWithArray_(we.length, 0, $e);
    }
  }, ne;
}();
function createObservableArray(ne, oe, ae, fe) {
  return ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), fe === void 0 && (fe = !1), assertProxies(), initObservable(function() {
    var ye = new ObservableArrayAdministration(ae, oe, fe, !1);
    addHiddenFinalProp(ye.values_, $mobx, ye);
    var we = new Proxy(ye.values_, arrayTraps);
    return ye.proxy_ = we, ne && ne.length && ye.spliceWithArray_(0, 0, ne), we;
  });
}
var arrayExtensions = {
  clear: function ne() {
    return this.splice(0);
  },
  replace: function ne(oe) {
    var ae = this[$mobx];
    return ae.spliceWithArray_(0, ae.values_.length, oe);
  },
  // Used by JSON.stringify
  toJSON: function ne() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function ne(oe, ae) {
    for (var fe = arguments.length, ye = new Array(fe > 2 ? fe - 2 : 0), we = 2; we < fe; we++)
      ye[we - 2] = arguments[we];
    var _e = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return _e.spliceWithArray_(oe);
      case 2:
        return _e.spliceWithArray_(oe, ae);
    }
    return _e.spliceWithArray_(oe, ae, ye);
  },
  spliceWithArray: function ne(oe, ae, fe) {
    return this[$mobx].spliceWithArray_(oe, ae, fe);
  },
  push: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(oe.values_.length, 0, fe), oe.values_.length;
  },
  pop: function ne() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function ne() {
    return this.splice(0, 1)[0];
  },
  unshift: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(0, 0, fe), oe.values_.length;
  },
  reverse: function ne() {
    return globalState.trackingDerivation && die(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function ne() {
    globalState.trackingDerivation && die(37, "sort");
    var oe = this.slice();
    return oe.sort.apply(oe, arguments), this.replace(oe), this;
  },
  remove: function ne(oe) {
    var ae = this[$mobx], fe = ae.dehanceValues_(ae.values_).indexOf(oe);
    return fe > -1 ? (this.splice(fe, 1), !0) : !1;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(ne, oe) {
  typeof Array.prototype[ne] == "function" && (arrayExtensions[ne] = oe(ne));
}
function simpleFunc(ne) {
  return function() {
    var oe = this[$mobx];
    oe.atom_.reportObserved();
    var ae = oe.dehanceValues_(oe.values_);
    return ae[ne].apply(ae, arguments);
  };
}
function mapLikeFunc(ne) {
  return function(oe, ae) {
    var fe = this, ye = this[$mobx];
    ye.atom_.reportObserved();
    var we = ye.dehanceValues_(ye.values_);
    return we[ne](function(_e, xe) {
      return oe.call(ae, _e, xe, fe);
    });
  };
}
function reduceLikeFunc(ne) {
  return function() {
    var oe = this, ae = this[$mobx];
    ae.atom_.reportObserved();
    var fe = ae.dehanceValues_(ae.values_), ye = arguments[0];
    return arguments[0] = function(we, _e, xe) {
      return ye(we, _e, xe, oe);
    }, fe[ne].apply(fe, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(ne) {
  return isObject(ne) && isObservableArrayAdministration(ne[$mobx]);
}
var ObservableMapMarker = {}, ADD = "add", DELETE = "delete", ObservableMap = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var we = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableMap@" + getNextId() : "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[$mobx] = ObservableMapMarker, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = fe, this.name_ = ye, isFunction(Map) || die(18), initObservable(function() {
      we.keysAtom_ = createAtom(process.env.NODE_ENV !== "production" ? we.name_ + ".keys()" : "ObservableMap.keys()"), we.data_ = /* @__PURE__ */ new Map(), we.hasMap_ = /* @__PURE__ */ new Map(), ae && we.merge(ae);
    });
  }
  var oe = ne.prototype;
  return oe.has_ = function(fe) {
    return this.data_.has(fe);
  }, oe.has = function(fe) {
    var ye = this;
    if (!globalState.trackingDerivation)
      return this.has_(fe);
    var we = this.hasMap_.get(fe);
    if (!we) {
      var _e = we = new ObservableValue(this.has_(fe), referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableMap.key?", !1);
      this.hasMap_.set(fe, _e), onBecomeUnobserved(_e, function() {
        return ye.hasMap_.delete(fe);
      });
    }
    return we.get();
  }, oe.set = function(fe, ye) {
    var we = this.has_(fe);
    if (hasInterceptors(this)) {
      var _e = interceptChange(this, {
        type: we ? UPDATE : ADD,
        object: this,
        newValue: ye,
        name: fe
      });
      if (!_e)
        return this;
      ye = _e.newValue;
    }
    return we ? this.updateValue_(fe, ye) : this.addValue_(fe, ye), this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.keysAtom_), hasInterceptors(this)) {
      var we = interceptChange(this, {
        type: DELETE,
        object: this,
        name: fe
      });
      if (!we)
        return !1;
    }
    if (this.has_(fe)) {
      var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(fe).value_,
        name: fe
      } : null;
      return process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), transaction(function() {
        var $e;
        ye.keysAtom_.reportChanged(), ($e = ye.hasMap_.get(fe)) == null || $e.setNewValue_(!1);
        var Re = ye.data_.get(fe);
        Re.setNewValue_(void 0), ye.data_.delete(fe);
      }), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd(), !0;
    }
    return !1;
  }, oe.updateValue_ = function(fe, ye) {
    var we = this.data_.get(fe);
    if (ye = we.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: we.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), we.setNewValue_(ye), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
    }
  }, oe.addValue_ = function(fe, ye) {
    var we = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_), transaction(function() {
      var $e, Re = new ObservableValue(ye, we.enhancer_, process.env.NODE_ENV !== "production" ? we.name_ + "." + stringifyKey(fe) : "ObservableMap.key", !1);
      we.data_.set(fe, Re), ye = Re.value_, ($e = we.hasMap_.get(fe)) == null || $e.setNewValue_(!0), we.keysAtom_.reportChanged();
    });
    var _e = isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: fe,
      newValue: ye
    } : null;
    process.env.NODE_ENV !== "production" && _e && spyReportStart(Oe), xe && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
  }, oe.get = function(fe) {
    return this.has(fe) ? this.dehanceValue_(this.data_.get(fe).get()) : this.dehanceValue_(void 0);
  }, oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, oe.values = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var _e = ye.next(), xe = _e.done, Oe = _e.value;
        return {
          done: xe,
          value: xe ? void 0 : fe.get(Oe)
        };
      }
    });
  }, oe.entries = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var _e = ye.next(), xe = _e.done, Oe = _e.value;
        return {
          done: xe,
          value: xe ? void 0 : [Oe, fe.get(Oe)]
        };
      }
    });
  }, oe[Symbol.iterator] = function() {
    return this.entries();
  }, oe.forEach = function(fe, ye) {
    for (var we = _createForOfIteratorHelperLoose(this), _e; !(_e = we()).done; ) {
      var xe = _e.value, Oe = xe[0], $e = xe[1];
      fe.call(ye, $e, Oe, this);
    }
  }, oe.merge = function(fe) {
    var ye = this;
    return isObservableMap(fe) && (fe = new Map(fe)), transaction(function() {
      isPlainObject(fe) ? getPlainObjectKeys(fe).forEach(function(we) {
        return ye.set(we, fe[we]);
      }) : Array.isArray(fe) ? fe.forEach(function(we) {
        var _e = we[0], xe = we[1];
        return ye.set(_e, xe);
      }) : isES6Map(fe) ? (isPlainES6Map(fe) || die(19, fe), fe.forEach(function(we, _e) {
        return ye.set(_e, we);
      })) : fe != null && die(20, fe);
    }), this;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.keys()), we; !(we = ye()).done; ) {
          var _e = we.value;
          fe.delete(_e);
        }
      });
    });
  }, oe.replace = function(fe) {
    var ye = this;
    return transaction(function() {
      for (var we = convertToMap(fe), _e = /* @__PURE__ */ new Map(), xe = !1, Oe = _createForOfIteratorHelperLoose(ye.data_.keys()), $e; !($e = Oe()).done; ) {
        var Re = $e.value;
        if (!we.has(Re)) {
          var Ne = ye.delete(Re);
          if (Ne)
            xe = !0;
          else {
            var je = ye.data_.get(Re);
            _e.set(Re, je);
          }
        }
      }
      for (var Be = _createForOfIteratorHelperLoose(we.entries()), ze; !(ze = Be()).done; ) {
        var He = ze.value, qe = He[0], Ye = He[1], ot = ye.data_.has(qe);
        if (ye.set(qe, Ye), ye.data_.has(qe)) {
          var tt = ye.data_.get(qe);
          _e.set(qe, tt), ot || (xe = !0);
        }
      }
      if (!xe)
        if (ye.data_.size !== _e.size)
          ye.keysAtom_.reportChanged();
        else
          for (var it = ye.data_.keys(), ht = _e.keys(), gt = it.next(), At = ht.next(); !gt.done; ) {
            if (gt.value !== At.value) {
              ye.keysAtom_.reportChanged();
              break;
            }
            gt = it.next(), At = ht.next();
          }
      ye.data_ = _e;
    }), this;
  }, oe.toString = function() {
    return "[object ObservableMap]";
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with maps."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(ne) {
  if (isES6Map(ne) || isObservableMap(ne))
    return ne;
  if (Array.isArray(ne))
    return new Map(ne);
  if (isPlainObject(ne)) {
    var oe = /* @__PURE__ */ new Map();
    for (var ae in ne)
      oe.set(ae, ne[ae]);
    return oe;
  } else
    return die(21, ne);
}
var ObservableSetMarker = {}, ObservableSet = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var we = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableSet@" + getNextId() : "ObservableSet"), this.name_ = void 0, this[$mobx] = ObservableSetMarker, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = ye, isFunction(Set) || die(22), this.enhancer_ = function(_e, xe) {
      return fe(_e, xe, ye);
    }, initObservable(function() {
      we.atom_ = createAtom(we.name_), ae && we.replace(ae);
    });
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.data_.values()), we; !(we = ye()).done; ) {
          var _e = we.value;
          fe.delete(_e);
        }
      });
    });
  }, oe.forEach = function(fe, ye) {
    for (var we = _createForOfIteratorHelperLoose(this), _e; !(_e = we()).done; ) {
      var xe = _e.value;
      fe.call(ye, xe, xe, this);
    }
  }, oe.add = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.atom_), hasInterceptors(this)) {
      var we = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: fe
      });
      if (!we)
        return this;
    }
    if (!this.has(fe)) {
      transaction(function() {
        ye.data_.add(ye.enhancer_(fe, void 0)), ye.atom_.reportChanged();
      });
      var _e = process.env.NODE_ENV !== "production" && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: fe
      } : null;
      _e && process.env.NODE_ENV !== "production" && spyReportStart(Oe), xe && notifyListeners(this, Oe), _e && process.env.NODE_ENV !== "production" && spyReportEnd();
    }
    return this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (hasInterceptors(this)) {
      var we = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: fe
      });
      if (!we)
        return !1;
    }
    if (this.has(fe)) {
      var _e = process.env.NODE_ENV !== "production" && isSpyEnabled(), xe = hasListeners(this), Oe = xe || _e ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: fe
      } : null;
      return _e && process.env.NODE_ENV !== "production" && spyReportStart(Oe), transaction(function() {
        ye.atom_.reportChanged(), ye.data_.delete(fe);
      }), xe && notifyListeners(this, Oe), _e && process.env.NODE_ENV !== "production" && spyReportEnd(), !0;
    }
    return !1;
  }, oe.has = function(fe) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(fe));
  }, oe.entries = function() {
    var fe = 0, ye = Array.from(this.keys()), we = Array.from(this.values());
    return makeIterable({
      next: function() {
        var xe = fe;
        return fe += 1, xe < we.length ? {
          value: [ye[xe], we[xe]],
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.keys = function() {
    return this.values();
  }, oe.values = function() {
    this.atom_.reportObserved();
    var fe = this, ye = 0, we = Array.from(this.data_.values());
    return makeIterable({
      next: function() {
        return ye < we.length ? {
          value: fe.dehanceValue_(we[ye++]),
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.intersection = function(fe) {
    if (isES6Set(fe))
      return fe.intersection(this);
    var ye = new Set(this);
    return ye.intersection(fe);
  }, oe.union = function(fe) {
    if (isES6Set(fe))
      return fe.union(this);
    var ye = new Set(this);
    return ye.union(fe);
  }, oe.difference = function(fe) {
    return new Set(this).difference(fe);
  }, oe.symmetricDifference = function(fe) {
    if (isES6Set(fe))
      return fe.symmetricDifference(this);
    var ye = new Set(this);
    return ye.symmetricDifference(fe);
  }, oe.isSubsetOf = function(fe) {
    return new Set(this).isSubsetOf(fe);
  }, oe.isSupersetOf = function(fe) {
    return new Set(this).isSupersetOf(fe);
  }, oe.isDisjointFrom = function(fe) {
    if (isES6Set(fe))
      return fe.isDisjointFrom(this);
    var ye = new Set(this);
    return ye.isDisjointFrom(fe);
  }, oe.replace = function(fe) {
    var ye = this;
    return isObservableSet(fe) && (fe = new Set(fe)), transaction(function() {
      Array.isArray(fe) ? (ye.clear(), fe.forEach(function(we) {
        return ye.add(we);
      })) : isES6Set(fe) ? (ye.clear(), fe.forEach(function(we) {
        return ye.add(we);
      })) : fe != null && die("Cannot initialize set from " + fe);
    }), this;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with sets."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.toString = function() {
    return "[object ObservableSet]";
  }, oe[Symbol.iterator] = function() {
    return this.values();
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet), descriptorCache = /* @__PURE__ */ Object.create(null), REMOVE = "remove", ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, we) {
    fe === void 0 && (fe = /* @__PURE__ */ new Map()), we === void 0 && (we = autoAnnotation), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = ae, this.values_ = fe, this.name_ = ye, this.defaultAnnotation_ = we, this.keysAtom_ = new Atom(process.env.NODE_ENV !== "production" ? this.name_ + ".keys" : "ObservableObject.keys"), this.isPlainObject_ = isPlainObject(this.target_), process.env.NODE_ENV !== "production" && !isAnnotation(this.defaultAnnotation_) && die("defaultAnnotation must be valid annotation"), process.env.NODE_ENV !== "production" && (this.appliedAnnotations_ = {});
  }
  var oe = ne.prototype;
  return oe.getObservablePropValue_ = function(fe) {
    return this.values_.get(fe).get();
  }, oe.setObservablePropValue_ = function(fe, ye) {
    var we = this.values_.get(fe);
    if (we instanceof ComputedValue)
      return we.set(ye), !0;
    if (hasInterceptors(this)) {
      var _e = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      });
      if (!_e)
        return null;
      ye = _e.newValue;
    }
    if (ye = we.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var xe = hasListeners(this), Oe = process.env.NODE_ENV !== "production" && isSpyEnabled(), $e = xe || Oe ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: we.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && Oe && spyReportStart($e), we.setNewValue_(ye), xe && notifyListeners(this, $e), process.env.NODE_ENV !== "production" && Oe && spyReportEnd();
    }
    return !0;
  }, oe.get_ = function(fe) {
    return globalState.trackingDerivation && !hasProp(this.target_, fe) && this.has_(fe), this.target_[fe];
  }, oe.set_ = function(fe, ye, we) {
    return we === void 0 && (we = !1), hasProp(this.target_, fe) ? this.values_.has(fe) ? this.setObservablePropValue_(fe, ye) : we ? Reflect.set(this.target_, fe, ye) : (this.target_[fe] = ye, !0) : this.extend_(fe, {
      value: ye,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, we);
  }, oe.has_ = function(fe) {
    if (!globalState.trackingDerivation)
      return fe in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var ye = this.pendingKeys_.get(fe);
    return ye || (ye = new ObservableValue(fe in this.target_, referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableObject.key?", !1), this.pendingKeys_.set(fe, ye)), ye.get();
  }, oe.make_ = function(fe, ye) {
    if (ye === !0 && (ye = this.defaultAnnotation_), ye !== !1) {
      if (assertAnnotable(this, ye, fe), !(fe in this.target_)) {
        var we;
        if ((we = this.target_[storedAnnotationsSymbol]) != null && we[fe])
          return;
        die(1, ye.annotationType_, this.name_ + "." + fe.toString());
      }
      for (var _e = this.target_; _e && _e !== objectPrototype; ) {
        var xe = getDescriptor(_e, fe);
        if (xe) {
          var Oe = ye.make_(this, fe, xe, _e);
          if (Oe === 0)
            return;
          if (Oe === 1)
            break;
        }
        _e = Object.getPrototypeOf(_e);
      }
      recordAnnotationApplied(this, ye, fe);
    }
  }, oe.extend_ = function(fe, ye, we, _e) {
    if (_e === void 0 && (_e = !1), we === !0 && (we = this.defaultAnnotation_), we === !1)
      return this.defineProperty_(fe, ye, _e);
    assertAnnotable(this, we, fe);
    var xe = we.extend_(this, fe, ye, _e);
    return xe && recordAnnotationApplied(this, we, fe), xe;
  }, oe.defineProperty_ = function(fe, ye, we) {
    we === void 0 && (we = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var _e = this.delete_(fe);
      if (!_e)
        return _e;
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye.value
        });
        if (!xe)
          return null;
        var Oe = xe.newValue;
        ye.value !== Oe && (ye = _extends({}, ye, {
          value: Oe
        }));
      }
      if (we) {
        if (!Reflect.defineProperty(this.target_, fe, ye))
          return !1;
      } else
        defineProperty(this.target_, fe, ye);
      this.notifyPropertyAddition_(fe, ye.value);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineObservableProperty_ = function(fe, ye, we, _e) {
    _e === void 0 && (_e = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var xe = this.delete_(fe);
      if (!xe)
        return xe;
      if (hasInterceptors(this)) {
        var Oe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye
        });
        if (!Oe)
          return null;
        ye = Oe.newValue;
      }
      var $e = getCachedObservablePropDescriptor(fe), Re = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: $e.get,
        set: $e.set
      };
      if (_e) {
        if (!Reflect.defineProperty(this.target_, fe, Re))
          return !1;
      } else
        defineProperty(this.target_, fe, Re);
      var Ne = new ObservableValue(ye, we, process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key", !1);
      this.values_.set(fe, Ne), this.notifyPropertyAddition_(fe, Ne.value_);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineComputedProperty_ = function(fe, ye, we) {
    we === void 0 && (we = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var _e = this.delete_(fe);
      if (!_e)
        return _e;
      if (hasInterceptors(this)) {
        var xe = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: void 0
        });
        if (!xe)
          return null;
      }
      ye.name || (ye.name = process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key"), ye.context = this.proxy_ || this.target_;
      var Oe = getCachedObservablePropDescriptor(fe), $e = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: Oe.get,
        set: Oe.set
      };
      if (we) {
        if (!Reflect.defineProperty(this.target_, fe, $e))
          return !1;
      } else
        defineProperty(this.target_, fe, $e);
      this.values_.set(fe, new ComputedValue(ye)), this.notifyPropertyAddition_(fe, void 0);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.delete_ = function(fe, ye) {
    if (ye === void 0 && (ye = !1), checkIfStateModificationsAreAllowed(this.keysAtom_), !hasProp(this.target_, fe))
      return !0;
    if (hasInterceptors(this)) {
      var we = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: fe,
        type: REMOVE
      });
      if (!we)
        return null;
    }
    try {
      var _e;
      startBatch();
      var xe = hasListeners(this), Oe = process.env.NODE_ENV !== "production" && isSpyEnabled(), $e = this.values_.get(fe), Re = void 0;
      if (!$e && (xe || Oe)) {
        var Ne;
        Re = (Ne = getDescriptor(this.target_, fe)) == null ? void 0 : Ne.value;
      }
      if (ye) {
        if (!Reflect.deleteProperty(this.target_, fe))
          return !1;
      } else
        delete this.target_[fe];
      if (process.env.NODE_ENV !== "production" && delete this.appliedAnnotations_[fe], $e && (this.values_.delete(fe), $e instanceof ObservableValue && (Re = $e.value_), propagateChanged($e)), this.keysAtom_.reportChanged(), (_e = this.pendingKeys_) == null || (_e = _e.get(fe)) == null || _e.set(fe in this.target_), xe || Oe) {
        var je = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: Re,
          name: fe
        };
        process.env.NODE_ENV !== "production" && Oe && spyReportStart(je), xe && notifyListeners(this, je), process.env.NODE_ENV !== "production" && Oe && spyReportEnd();
      }
    } finally {
      endBatch();
    }
    return !0;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support the fire immediately property for observable objects."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.notifyPropertyAddition_ = function(fe, ye) {
    var we, _e = hasListeners(this), xe = process.env.NODE_ENV !== "production" && isSpyEnabled();
    if (_e || xe) {
      var Oe = _e || xe ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && xe && spyReportStart(Oe), _e && notifyListeners(this, Oe), process.env.NODE_ENV !== "production" && xe && spyReportEnd();
    }
    (we = this.pendingKeys_) == null || (we = we.get(fe)) == null || we.set(!0), this.keysAtom_.reportChanged();
  }, oe.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), ownKeys(this.target_);
  }, oe.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, ne;
}();
function asObservableObject(ne, oe) {
  var ae;
  if (process.env.NODE_ENV !== "production" && oe && isObservableObject(ne) && die("Options can't be provided for already observable objects."), hasProp(ne, $mobx))
    return process.env.NODE_ENV !== "production" && !(getAdministration(ne) instanceof ObservableObjectAdministration) && die("Cannot convert '" + getDebugName(ne) + `' into observable object:
The target is already observable of different type.
Extending builtins is not supported.`), ne;
  process.env.NODE_ENV !== "production" && !Object.isExtensible(ne) && die("Cannot make the designated object observable; it is not extensible");
  var fe = (ae = oe == null ? void 0 : oe.name) != null ? ae : process.env.NODE_ENV !== "production" ? (isPlainObject(ne) ? "ObservableObject" : ne.constructor.name) + "@" + getNextId() : "ObservableObject", ye = new ObservableObjectAdministration(ne, /* @__PURE__ */ new Map(), String(fe), getAnnotationFromOptions(oe));
  return addHiddenProp(ne, $mobx, ye), ne;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(ne) {
  return descriptorCache[ne] || (descriptorCache[ne] = {
    get: function() {
      return this[$mobx].getObservablePropValue_(ne);
    },
    set: function(ae) {
      return this[$mobx].setObservablePropValue_(ne, ae);
    }
  });
}
function isObservableObject(ne) {
  return isObject(ne) ? isObservableObjectAdministration(ne[$mobx]) : !1;
}
function recordAnnotationApplied(ne, oe, ae) {
  var fe;
  process.env.NODE_ENV !== "production" && (ne.appliedAnnotations_[ae] = oe), (fe = ne.target_[storedAnnotationsSymbol]) == null || delete fe[ae];
}
function assertAnnotable(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isAnnotation(oe) && die("Cannot annotate '" + ne.name_ + "." + ae.toString() + "': Invalid annotation."), process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne.appliedAnnotations_, ae)) {
    var fe = ne.name_ + "." + ae.toString(), ye = ne.appliedAnnotations_[ae].annotationType_, we = oe.annotationType_;
    die("Cannot apply '" + we + "' to '" + fe + "':" + (`
The field is already annotated with '` + ye + "'.") + `
Re-annotating fields is not allowed.
Use 'override' annotation for methods overridden by subclass.`);
  }
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0), safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var ne = !1, oe = {};
  return Object.defineProperty(oe, "0", {
    set: function() {
      ne = !0;
    }
  }), Object.create(oe)[0] = 1, ne === !1;
}(), OBSERVABLE_ARRAY_BUFFER_SIZE = 0, StubArray = function ne() {
};
function inherit(ne, oe) {
  Object.setPrototypeOf ? Object.setPrototypeOf(ne.prototype, oe) : ne.prototype.__proto__ !== void 0 ? ne.prototype.__proto__ = oe : ne.prototype = oe;
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, we, _e) {
    var xe;
    return we === void 0 && (we = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), _e === void 0 && (_e = !1), xe = ne.call(this) || this, initObservable(function() {
      var Oe = new ObservableArrayAdministration(we, ye, _e, !0);
      Oe.proxy_ = xe, addHiddenFinalProp(xe, $mobx, Oe), fe && fe.length && xe.spliceWithArray(0, 0, fe), safariPrototypeSetterInheritanceBug && Object.defineProperty(xe, "0", ENTRY_0);
    }), xe;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.concat = function() {
    this[$mobx].atom_.reportObserved();
    for (var ye = arguments.length, we = new Array(ye), _e = 0; _e < ye; _e++)
      we[_e] = arguments[_e];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      we.map(function(xe) {
        return isObservableArray(xe) ? xe.slice() : xe;
      })
    );
  }, ae[Symbol.iterator] = function() {
    var fe = this, ye = 0;
    return makeIterable({
      next: function() {
        return ye < fe.length ? {
          value: fe[ye++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, _createClass(oe, [{
    key: "length",
    get: function() {
      return this[$mobx].getArrayLength_();
    },
    set: function(ye) {
      this[$mobx].setArrayLength_(ye);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(ne) {
  var oe = ne[0], ae = ne[1];
  oe !== "concat" && addHiddenProp(LegacyObservableArray.prototype, oe, ae);
});
function createArrayEntryDescriptor(ne) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[$mobx].get_(ne);
    },
    set: function(ae) {
      this[$mobx].set_(ne, ae);
    }
  };
}
function createArrayBufferItem(ne) {
  defineProperty(LegacyObservableArray.prototype, "" + ne, createArrayEntryDescriptor(ne));
}
function reserveArrayBuffer(ne) {
  if (ne > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var oe = OBSERVABLE_ARRAY_BUFFER_SIZE; oe < ne + 100; oe++)
      createArrayBufferItem(oe);
    OBSERVABLE_ARRAY_BUFFER_SIZE = ne;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(ne, oe, ae) {
  return new LegacyObservableArray(ne, oe, ae);
}
function getAtom(ne, oe) {
  if (typeof ne == "object" && ne !== null) {
    if (isObservableArray(ne))
      return oe !== void 0 && die(23), ne[$mobx].atom_;
    if (isObservableSet(ne))
      return ne.atom_;
    if (isObservableMap(ne)) {
      if (oe === void 0)
        return ne.keysAtom_;
      var ae = ne.data_.get(oe) || ne.hasMap_.get(oe);
      return ae || die(25, oe, getDebugName(ne)), ae;
    }
    if (isObservableObject(ne)) {
      if (!oe)
        return die(26);
      var fe = ne[$mobx].values_.get(oe);
      return fe || die(27, oe, getDebugName(ne)), fe;
    }
    if (isAtom(ne) || isComputedValue(ne) || isReaction(ne))
      return ne;
  } else if (isFunction(ne) && isReaction(ne[$mobx]))
    return ne[$mobx];
  die(28);
}
function getAdministration(ne, oe) {
  if (ne || die(29), oe !== void 0)
    return getAdministration(getAtom(ne, oe));
  if (isAtom(ne) || isComputedValue(ne) || isReaction(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (ne[$mobx])
    return ne[$mobx];
  die(24, ne);
}
function getDebugName(ne, oe) {
  var ae;
  if (oe !== void 0)
    ae = getAtom(ne, oe);
  else {
    if (isAction(ne))
      return ne.name;
    isObservableObject(ne) || isObservableMap(ne) || isObservableSet(ne) ? ae = getAdministration(ne) : ae = getAtom(ne);
  }
  return ae.name_;
}
function initObservable(ne) {
  var oe = untrackedStart(), ae = allowStateChangesStart(!0);
  startBatch();
  try {
    return ne();
  } finally {
    endBatch(), allowStateChangesEnd(ae), untrackedEnd(oe);
  }
}
var toString = objectPrototype.toString;
function deepEqual(ne, oe, ae) {
  return ae === void 0 && (ae = -1), eq$1(ne, oe, ae);
}
function eq$1(ne, oe, ae, fe, ye) {
  if (ne === oe)
    return ne !== 0 || 1 / ne === 1 / oe;
  if (ne == null || oe == null)
    return !1;
  if (ne !== ne)
    return oe !== oe;
  var we = typeof ne;
  if (we !== "function" && we !== "object" && typeof oe != "object")
    return !1;
  var _e = toString.call(ne);
  if (_e !== toString.call(oe))
    return !1;
  switch (_e) {
    case "[object RegExp]":
    case "[object String]":
      return "" + ne == "" + oe;
    case "[object Number]":
      return +ne != +ne ? +oe != +oe : +ne == 0 ? 1 / +ne === 1 / oe : +ne == +oe;
    case "[object Date]":
    case "[object Boolean]":
      return +ne == +oe;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(ne) === Symbol.valueOf.call(oe);
    case "[object Map]":
    case "[object Set]":
      ae >= 0 && ae++;
      break;
  }
  ne = unwrap(ne), oe = unwrap(oe);
  var xe = _e === "[object Array]";
  if (!xe) {
    if (typeof ne != "object" || typeof oe != "object")
      return !1;
    var Oe = ne.constructor, $e = oe.constructor;
    if (Oe !== $e && !(isFunction(Oe) && Oe instanceof Oe && isFunction($e) && $e instanceof $e) && "constructor" in ne && "constructor" in oe)
      return !1;
  }
  if (ae === 0)
    return !1;
  ae < 0 && (ae = -1), fe = fe || [], ye = ye || [];
  for (var Re = fe.length; Re--; )
    if (fe[Re] === ne)
      return ye[Re] === oe;
  if (fe.push(ne), ye.push(oe), xe) {
    if (Re = ne.length, Re !== oe.length)
      return !1;
    for (; Re--; )
      if (!eq$1(ne[Re], oe[Re], ae - 1, fe, ye))
        return !1;
  } else {
    var Ne = Object.keys(ne), je;
    if (Re = Ne.length, Object.keys(oe).length !== Re)
      return !1;
    for (; Re--; )
      if (je = Ne[Re], !(hasProp(oe, je) && eq$1(ne[je], oe[je], ae - 1, fe, ye)))
        return !1;
  }
  return fe.pop(), ye.pop(), !0;
}
function unwrap(ne) {
  return isObservableArray(ne) ? ne.slice() : isES6Map(ne) || isObservableMap(ne) || isES6Set(ne) || isObservableSet(ne) ? Array.from(ne.entries()) : ne;
}
function makeIterable(ne) {
  return ne[Symbol.iterator] = getSelf, ne;
}
function getSelf() {
  return this;
}
function isAnnotation(ne) {
  return (
    // Can be function
    ne instanceof Object && typeof ne.annotationType_ == "string" && isFunction(ne.make_) && isFunction(ne.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(ne) {
  var oe = getGlobal();
  typeof oe[ne] > "u" && die("MobX requires global '" + ne + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy,
  extras: {
    getDebugName
  },
  $mobx
});
function $r(ne, oe) {
  let ae = {};
  for (let fe in ne)
    ae[fe] = oe(ne[fe], fe);
  return ae;
}
function ur() {
  return pipe(filter((ne) => ne != null));
}
var ue$1 = function() {
  let ne = cr, oe = mr;
  return oe(ne(32), 8) + "-" + oe(ne(16), 4) + "-" + oe(16384 | ne(12), 4) + "-" + oe(32768 | ne(14), 4) + "-" + oe(ne(48), 12);
}, cr = function(ne) {
  if (ne < 0 || ne > 53)
    return NaN;
  let oe = 0 | Math.random() * 1073741824;
  return ne > 30 ? oe + (0 | Math.random() * (1 << ne - 30)) * 1073741824 : oe >>> 30 - ne;
}, mr = function(ne, oe) {
  let ae = ne.toString(16), fe = oe - ae.length, ye = "0";
  for (; fe > 0; fe >>>= 1, ye += ye)
    fe & 1 && (ae = ye + ae);
  return ae;
};
function y$2(ne) {
  return { ...ne, [Symbol.iterator]() {
    return this;
  } };
}
function I$5(ne, oe) {
  return y$2({ next() {
    let { done: ae, value: fe } = ne.next();
    return { done: ae, value: ae ? fe : oe(fe) };
  } });
}
function yr$1(ne) {
  if (ne < 2)
    throw new Error("Minimum size is 2");
  if (ne > 64)
    throw new Error("Maximum size is 64");
  let oe = 2 ** (ne - 1) - 1, ae = -oe - 1;
  return (fe) => {
    if (fe = fe << 0, fe > oe || fe < ae)
      throw console.log("value", fe, oe, ae, fe > oe, fe < ae), new Error(`Int${ne} overflow`);
    return fe < 0 ? 2 ** ne + fe : fe;
  };
}
yr$1(32);
/**
* UUID.core.js - UUID.js for Minimalists
*
* @file
* @author  LiosK
* @version v4.2.0
* @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
* @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
*/
var P$3 = ((ne) => (ne[ne.Boolean = 0] = "Boolean", ne[ne.Number = 1] = "Number", ne[ne.OptionalNumber = 2] = "OptionalNumber", ne[ne.BigInt = 3] = "BigInt", ne[ne.OptionalBigInt = 4] = "OptionalBigInt", ne[ne.String = 5] = "String", ne[ne.OptionalString = 6] = "OptionalString", ne[ne.NumberArray = 7] = "NumberArray", ne[ne.OptionalNumberArray = 8] = "OptionalNumberArray", ne[ne.BigIntArray = 9] = "BigIntArray", ne[ne.OptionalBigIntArray = 10] = "OptionalBigIntArray", ne[ne.StringArray = 11] = "StringArray", ne[ne.OptionalStringArray = 12] = "OptionalStringArray", ne[ne.Entity = 13] = "Entity", ne[ne.OptionalEntity = 14] = "OptionalEntity", ne[ne.EntityArray = 15] = "EntityArray", ne[ne.OptionalEntityArray = 16] = "OptionalEntityArray", ne[ne.T = 17] = "T", ne[ne.OptionalT = 18] = "OptionalT", ne))(P$3 || {}), k$3 = ((ne) => (ne[ne.Enter = 0] = "Enter", ne[ne.Exit = 1] = "Exit", ne[ne.Update = 2] = "Update", ne[ne.Noop = 3] = "Noop", ne))(k$3 || {}), w$1 = [14, 16, 2, 8, 4, 10, 6, 12, 18];
function M$2(ne) {
  let oe = /* @__PURE__ */ new Map();
  function ae(xe) {
    let Oe = oe.get(fe(xe));
    return Oe ? new Set([...Oe].map(v$2)) : /* @__PURE__ */ new Set();
  }
  function fe(xe) {
    return Object.values(xe).join("/");
  }
  function ye(xe, Oe) {
    if (!Oe)
      return;
    let $e = fe(Oe), Re = oe.get($e);
    Re || (Re = /* @__PURE__ */ new Set(), oe.set($e, Re)), Re.add(xe);
  }
  function we(xe, Oe) {
    if (!Oe)
      return;
    let $e = fe(Oe), Re = oe.get($e);
    Re && Re.delete(xe);
  }
  for (let xe of V$1(ne)) {
    let Oe = g$3(ne, xe);
    ye(p$1(xe), Oe);
  }
  let _e = ne.update$.subscribe(({ entity: xe, value: Oe }) => {
    we(p$1(xe), Oe[1]), ye(p$1(xe), Oe[0]);
  });
  return ne.world.registerDisposer(() => _e == null ? void 0 : _e.unsubscribe()), { ...ne, getEntitiesWithValue: ae };
}
function U$2(ne, oe) {
  let ae = g$3(oe, ne);
  return { entity: ne, component: oe, value: [ae, void 0], type: ae == null ? 3 : 0 };
}
function Y$2(ne) {
  return pipe(map((oe) => U$2(oe, ne)));
}
function I$4(ne) {
  return "getEntitiesWithValue" in ne;
}
function T$3(ne, oe) {
  return Object.keys(ne.schema).every((ae) => ae in oe);
}
function b$3(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) ?? ((ae = ne.metadata) == null ? void 0 : ae.tableName) ?? ((fe = ne.metadata) == null ? void 0 : fe.tableId) ?? ((ye = ne.metadata) == null ? void 0 : ye.contractId) ?? ne.id;
}
function ie(ne, oe, ae) {
  if (Object.keys(oe).length === 0)
    throw new Error("Component schema must have at least one key");
  let fe = (ae == null ? void 0 : ae.id) ?? ue$1(), ye = $r(oe, () => /* @__PURE__ */ new Map()), we = new Subject(), _e = ae == null ? void 0 : ae.metadata, xe = { values: ye, schema: oe, id: fe, update$: we, metadata: _e, entities: () => I$5(Object.values(ye)[0].keys(), v$2), world: ne };
  return ae != null && ae.indexed && (xe = M$2(xe)), ne.registerComponent(xe), xe;
}
function E$2(ne, oe, ae, fe = {}) {
  var _e;
  let ye = p$1(oe), we = g$3(ne, oe);
  for (let [xe, Oe] of Object.entries(ae))
    ne.values[xe] ? ne.values[xe].set(ye, Oe) : (_e = ne.metadata) != null && _e.tableId && /^\d+$/.test(xe) || console.warn("Component definition for", b$3(ne), "is missing key", xe, ", ignoring value", Oe, "for entity", oe, ". Existing keys: ", Object.keys(ne.values));
  fe.skipUpdateStream || ne.update$.next({ entity: oe, value: [ae, we], component: ne });
}
function ue(ne, oe, ae = {}) {
  let fe = p$1(oe), ye = g$3(ne, oe);
  for (let we of Object.keys(ne.values))
    ne.values[we].delete(fe);
  ae.skipUpdateStream || ne.update$.next({ entity: oe, value: [void 0, ye], component: ne });
}
function le$1(ne, oe) {
  let ae = p$1(oe);
  return Object.values(ne.values)[0].has(ae);
}
function g$3(ne, oe) {
  let ae = {}, fe = p$1(oe), ye = Object.keys(ne.schema);
  for (let we of ye) {
    let _e = ne.values[we].get(fe);
    if (_e === void 0 && !w$1.includes(ne.schema[we]))
      return;
    ae[we] = _e;
  }
  return ae;
}
function de(ne, oe) {
  let ae = g$3(ne, oe);
  if (!ae)
    throw new Error(`No value for component ${b$3(ne)} on entity ${oe}`);
  return ae;
}
function K$1(ne, oe) {
  if (!ne && !oe)
    return !0;
  if (!ne || !oe)
    return !1;
  let ae = !0;
  for (let fe of Object.keys(ne))
    if (ae = ne[fe] === oe[fe], !ae)
      return !1;
  return ae;
}
function ce(ne, oe) {
  if (I$4(ne) && T$3(ne, oe))
    return ne.getEntitiesWithValue(oe);
  let ae = /* @__PURE__ */ new Set();
  for (let fe of V$1(ne)) {
    let ye = g$3(ne, fe);
    K$1(oe, ye) && ae.add(fe);
  }
  return ae;
}
function V$1(ne) {
  return ne.entities();
}
function p$1(ne) {
  return Symbol.for(ne);
}
function v$2(ne) {
  return Symbol.keyFor(ne);
}
var N$2 = ((ne) => (ne[ne.Has = 0] = "Has", ne[ne.HasValue = 1] = "HasValue", ne[ne.Not = 2] = "Not", ne[ne.NotValue = 3] = "NotValue", ne[ne.ProxyRead = 4] = "ProxyRead", ne[ne.ProxyExpand = 5] = "ProxyExpand", ne))(N$2 || {});
function Le(ne) {
  return { type: 0, component: ne };
}
function c$3(ne, oe) {
  if (oe.type === 0)
    return le$1(oe.component, ne);
  if (oe.type === 1)
    return K$1(oe.value, g$3(oe.component, ne));
  if (oe.type === 2)
    return !le$1(oe.component, ne);
  if (oe.type === 3)
    return !K$1(oe.value, g$3(oe.component, ne));
  throw new Error("Unknown query fragment");
}
function G$1(ne) {
  return ne.type === 0 || ne.type == 1;
}
function P$2(ne) {
  return ne.type === 2 || ne.type == 3;
}
function J(ne) {
  return ne.type === 5 || ne.type == 4;
}
function U$1(ne, oe) {
  return ne && G$1(oe) || !ne && P$2(oe);
}
function I$3(ne, oe, ae) {
  let fe = ne, ye = !1;
  for (let we = 0; we < ae.depth; we++) {
    let _e = g$3(ae.component, fe);
    if (!_e)
      return null;
    let xe = _e.value;
    if (!xe)
      return null;
    if (fe = xe, ye = c$3(fe, oe), U$1(ye, oe))
      return ye;
  }
  return ye;
}
function Q$2(ne, oe, ae) {
  if (ae === 0)
    return /* @__PURE__ */ new Set();
  let fe = ce(oe, { value: ne });
  if (ae === 1)
    return fe;
  let ye = [...fe].map((we) => [...Q$2(we, oe, ae - 1)]).flat();
  return /* @__PURE__ */ new Set([...fe, ...ye]);
}
function A$2(ne, oe) {
  let ae = oe ? /* @__PURE__ */ new Set([...oe]) : void 0, fe, ye;
  for (let we = 0; we < ne.length; we++) {
    let _e = ne[we];
    if (J(_e))
      _e.type === 4 && (fe = _e), _e.type === 5 && (ye = _e);
    else if (ae)
      for (let xe of [...ae]) {
        let Oe = c$3(xe, _e);
        if (fe && fe.depth > 0 && !U$1(Oe, _e) && (Oe = I$3(xe, _e, fe) ?? Oe), Oe || ae.delete(xe), ye && ye.depth > 0) {
          let $e = Q$2(xe, ye.component, ye.depth);
          for (let Re of $e)
            (c$3(Re, _e) || fe && fe.depth > 0 && I$3(Re, _e, fe)) && ae.add(Re);
        }
      }
    else {
      if (P$2(_e))
        throw new Error("First EntityQueryFragment must be Has or HasValue");
      if (ae = _e.type === 0 ? /* @__PURE__ */ new Set([...V$1(_e.component)]) : ce(_e.component, _e.value), ye && ye.depth > 0)
        for (let xe of [...ae])
          for (let Oe of Q$2(xe, ye.component, ye.depth))
            ae.add(Oe);
    }
  }
  return ae ?? /* @__PURE__ */ new Set();
}
function f$2(ne, oe) {
  let ae = oe != null && oe.runOnInit || oe != null && oe.initialSet ? A$2(ne, oe.initialSet) : /* @__PURE__ */ new Set(), fe = observable(ae), ye = from(fe).pipe(Y$2(ne[0].component)), we = ne.findIndex((xe) => [5, 4].includes(xe.type)) !== -1, _e = merge(...ne.map((xe) => xe.component.update$)).pipe(we ? concatMap((xe) => {
    let Oe = A$2(ne, oe == null ? void 0 : oe.initialSet), $e = [];
    for (let Re of fe)
      Oe.has(Re) || (fe.delete(Re), $e.push({ entity: Re, type: 1, component: xe.component, value: [void 0, void 0] }));
    for (let Re of Oe)
      fe.has(Re) ? $e.push({ entity: Re, type: 2, component: xe.component, value: [g$3(xe.component, Re), void 0] }) : (fe.add(Re), $e.push({ entity: Re, type: 0, component: xe.component, value: [g$3(xe.component, Re), void 0] }));
    return of(...$e);
  }) : map((xe) => {
    if (fe.has(xe.entity))
      return ne.filter((Oe) => Oe.component.id === xe.component.id).every((Oe) => c$3(xe.entity, Oe)) ? { ...xe, type: 2 } : (fe.delete(xe.entity), { ...xe, type: 1 });
    if (ne.every((Oe) => c$3(xe.entity, Oe)))
      return fe.add(xe.entity), { ...xe, type: 0 };
  }), ur());
  return { matching: fe, update$: concat(ye, _e).pipe(share()) };
}
function lt() {
  let ne = /* @__PURE__ */ new Set(), oe = [], ae = [];
  function fe({ id: Re, idSuffix: Ne } = {}) {
    let je = Re || ne.size + (Ne ? "-" + Ne : ""), Be = p$1(je);
    return ne.add(Be), je;
  }
  function ye() {
    return I$5(ne.values(), v$2);
  }
  function we(Re) {
    oe.push(Re);
  }
  function _e(Re) {
    for (let [, Ne] of ae.filter((je) => !Re || je[0] === Re))
      Ne();
    ae = ae.filter((Ne) => Re && Ne[0] !== Re);
  }
  function xe(Re, Ne = "") {
    ae.push([Ne, Re]);
  }
  function Oe(Re) {
    let Ne = p$1(Re);
    return ne.has(Ne);
  }
  function $e(Re) {
    for (let Ne of oe)
      le$1(Ne, Re) && ue(Ne, Re);
    ne.delete(p$1(Re));
  }
  return { registerEntity: fe, components: oe, registerComponent: we, dispose: _e, registerDisposer: xe, hasEntity: Oe, getEntities: ye, entitySymbols: ne, deleteEntity: $e };
}
function v$1(ne) {
  if (!isHex$1(ne))
    throw new Error(`entity ${ne} is not a hex string`);
  let oe = size$2(ne);
  if (oe % 32 !== 0)
    throw new Error(`entity length ${oe} is not a multiple of 32 bytes`);
  return new Array(oe / 32).fill(0).map((ae, fe) => sliceHex(ne, fe * 32, (fe + 1) * 32));
}
var H$1 = /* @__PURE__ */ new Map();
function nt$1(ne) {
  let oe = H$1.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$4(8096);
  return H$1.set(ne, ae), ae;
}
function rt(ne, oe) {
  let ae = v$1(oe);
  if (ae.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ae.length} does not match key schema length ${Object.keys(ne).length}`);
  return Object.fromEntries(Object.entries(ne).map(([fe, ye], we) => [fe, decodeAbiParameters([{ type: ye }], ae[we])[0]]));
}
function vt(ne, oe) {
  let ae = nt$1(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = v$1(oe);
  if (ye.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ye.length} does not match key schema length ${Object.keys(ne).length}`);
  let we = rt(ne, oe);
  return ae.set(oe, we), we;
}
function d$1(ne) {
  return concatHex$1(ne);
}
var j$1 = /* @__PURE__ */ new Map();
function st(ne) {
  let oe = j$1.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$4(8096);
  return j$1.set(ne, ae), ae;
}
function mt(ne, oe) {
  if (Object.keys(ne).length !== Object.keys(oe).length)
    throw new Error(`key length ${Object.keys(oe).length} does not match key schema length ${Object.keys(ne).length}`);
  return d$1(Object.entries(ne).map(([ae, fe]) => encodeAbiParameters([{ type: fe }], [oe[ae]])));
}
function M$1(ne, oe) {
  let ae = st(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = mt(ne, oe);
  return ae.set(oe, ye), ye;
}
function Pt(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) != null && ((ae = ne.metadata) == null ? void 0 : ae.tableName) != null && ((fe = ne.metadata) == null ? void 0 : fe.keySchema) != null && ((ye = ne.metadata) == null ? void 0 : ye.valueSchema) != null;
}
var b$2 = S.extend("recs"), ct = S.extend("reccs");
b$2.log = console.debug.bind(console);
ct.log = console.error.bind(console);
function V(ne) {
  return { RegisteredTables: ie(ne, { table: P$3.T }, { metadata: { componentName: "RegisteredTables" } }), SyncProgress: ie(ne, { step: P$3.String, message: P$3.String, percentage: P$3.Number, latestBlockNumber: P$3.BigInt, lastBlockNumberProcessed: P$3.BigInt }, { metadata: { componentName: "SyncProgress" } }) };
}
function E$1(ne) {
  return M$1({ address: "address", namespace: "bytes16", name: "bytes16" }, { address: ne.address, namespace: stringToHex$1(ne.namespace, { size: 16 }), name: stringToHex$1(ne.name, { size: 16 }) });
}
var T$2 = d$1([]), z = { uint8: P$3.Number, uint16: P$3.Number, uint24: P$3.Number, uint32: P$3.Number, uint40: P$3.Number, uint48: P$3.Number, uint56: P$3.BigInt, uint64: P$3.BigInt, uint72: P$3.BigInt, uint80: P$3.BigInt, uint88: P$3.BigInt, uint96: P$3.BigInt, uint104: P$3.BigInt, uint112: P$3.BigInt, uint120: P$3.BigInt, uint128: P$3.BigInt, uint136: P$3.BigInt, uint144: P$3.BigInt, uint152: P$3.BigInt, uint160: P$3.BigInt, uint168: P$3.BigInt, uint176: P$3.BigInt, uint184: P$3.BigInt, uint192: P$3.BigInt, uint200: P$3.BigInt, uint208: P$3.BigInt, uint216: P$3.BigInt, uint224: P$3.BigInt, uint232: P$3.BigInt, uint240: P$3.BigInt, uint248: P$3.BigInt, uint256: P$3.BigInt, int8: P$3.Number, int16: P$3.Number, int24: P$3.Number, int32: P$3.Number, int40: P$3.Number, int48: P$3.Number, int56: P$3.BigInt, int64: P$3.BigInt, int72: P$3.BigInt, int80: P$3.BigInt, int88: P$3.BigInt, int96: P$3.BigInt, int104: P$3.BigInt, int112: P$3.BigInt, int120: P$3.BigInt, int128: P$3.BigInt, int136: P$3.BigInt, int144: P$3.BigInt, int152: P$3.BigInt, int160: P$3.BigInt, int168: P$3.BigInt, int176: P$3.BigInt, int184: P$3.BigInt, int192: P$3.BigInt, int200: P$3.BigInt, int208: P$3.BigInt, int216: P$3.BigInt, int224: P$3.BigInt, int232: P$3.BigInt, int240: P$3.BigInt, int248: P$3.BigInt, int256: P$3.BigInt, bytes1: P$3.String, bytes2: P$3.String, bytes3: P$3.String, bytes4: P$3.String, bytes5: P$3.String, bytes6: P$3.String, bytes7: P$3.String, bytes8: P$3.String, bytes9: P$3.String, bytes10: P$3.String, bytes11: P$3.String, bytes12: P$3.String, bytes13: P$3.String, bytes14: P$3.String, bytes15: P$3.String, bytes16: P$3.String, bytes17: P$3.String, bytes18: P$3.String, bytes19: P$3.String, bytes20: P$3.String, bytes21: P$3.String, bytes22: P$3.String, bytes23: P$3.String, bytes24: P$3.String, bytes25: P$3.String, bytes26: P$3.String, bytes27: P$3.String, bytes28: P$3.String, bytes29: P$3.String, bytes30: P$3.String, bytes31: P$3.String, bytes32: P$3.String, bool: P$3.Boolean, address: P$3.String, "uint8[]": P$3.NumberArray, "uint16[]": P$3.NumberArray, "uint24[]": P$3.NumberArray, "uint32[]": P$3.NumberArray, "uint40[]": P$3.NumberArray, "uint48[]": P$3.NumberArray, "uint56[]": P$3.BigIntArray, "uint64[]": P$3.BigIntArray, "uint72[]": P$3.BigIntArray, "uint80[]": P$3.BigIntArray, "uint88[]": P$3.BigIntArray, "uint96[]": P$3.BigIntArray, "uint104[]": P$3.BigIntArray, "uint112[]": P$3.BigIntArray, "uint120[]": P$3.BigIntArray, "uint128[]": P$3.BigIntArray, "uint136[]": P$3.BigIntArray, "uint144[]": P$3.BigIntArray, "uint152[]": P$3.BigIntArray, "uint160[]": P$3.BigIntArray, "uint168[]": P$3.BigIntArray, "uint176[]": P$3.BigIntArray, "uint184[]": P$3.BigIntArray, "uint192[]": P$3.BigIntArray, "uint200[]": P$3.BigIntArray, "uint208[]": P$3.BigIntArray, "uint216[]": P$3.BigIntArray, "uint224[]": P$3.BigIntArray, "uint232[]": P$3.BigIntArray, "uint240[]": P$3.BigIntArray, "uint248[]": P$3.BigIntArray, "uint256[]": P$3.BigIntArray, "int8[]": P$3.NumberArray, "int16[]": P$3.NumberArray, "int24[]": P$3.NumberArray, "int32[]": P$3.NumberArray, "int40[]": P$3.NumberArray, "int48[]": P$3.NumberArray, "int56[]": P$3.BigIntArray, "int64[]": P$3.BigIntArray, "int72[]": P$3.BigIntArray, "int80[]": P$3.BigIntArray, "int88[]": P$3.BigIntArray, "int96[]": P$3.BigIntArray, "int104[]": P$3.BigIntArray, "int112[]": P$3.BigIntArray, "int120[]": P$3.BigIntArray, "int128[]": P$3.BigIntArray, "int136[]": P$3.BigIntArray, "int144[]": P$3.BigIntArray, "int152[]": P$3.BigIntArray, "int160[]": P$3.BigIntArray, "int168[]": P$3.BigIntArray, "int176[]": P$3.BigIntArray, "int184[]": P$3.BigIntArray, "int192[]": P$3.BigIntArray, "int200[]": P$3.BigIntArray, "int208[]": P$3.BigIntArray, "int216[]": P$3.BigIntArray, "int224[]": P$3.BigIntArray, "int232[]": P$3.BigIntArray, "int240[]": P$3.BigIntArray, "int248[]": P$3.BigIntArray, "int256[]": P$3.BigIntArray, "bytes1[]": P$3.StringArray, "bytes2[]": P$3.StringArray, "bytes3[]": P$3.StringArray, "bytes4[]": P$3.StringArray, "bytes5[]": P$3.StringArray, "bytes6[]": P$3.StringArray, "bytes7[]": P$3.StringArray, "bytes8[]": P$3.StringArray, "bytes9[]": P$3.StringArray, "bytes10[]": P$3.StringArray, "bytes11[]": P$3.StringArray, "bytes12[]": P$3.StringArray, "bytes13[]": P$3.StringArray, "bytes14[]": P$3.StringArray, "bytes15[]": P$3.StringArray, "bytes16[]": P$3.StringArray, "bytes17[]": P$3.StringArray, "bytes18[]": P$3.StringArray, "bytes19[]": P$3.StringArray, "bytes20[]": P$3.StringArray, "bytes21[]": P$3.StringArray, "bytes22[]": P$3.StringArray, "bytes23[]": P$3.StringArray, "bytes24[]": P$3.StringArray, "bytes25[]": P$3.StringArray, "bytes26[]": P$3.StringArray, "bytes27[]": P$3.StringArray, "bytes28[]": P$3.StringArray, "bytes29[]": P$3.StringArray, "bytes30[]": P$3.StringArray, "bytes31[]": P$3.StringArray, "bytes32[]": P$3.StringArray, "bool[]": P$3.T, "address[]": P$3.StringArray, bytes: P$3.String, string: P$3.String };
function q$1(ne, oe) {
  let ae = ia(Xi$1(oe)), fe = ia(Zi(oe));
  return ie(ne, { ...P$8(fe, (ye) => z[ye]), __staticData: P$3.OptionalString, __encodedLengths: P$3.OptionalString, __dynamicData: P$3.OptionalString }, { id: oe.tableId, metadata: { componentName: oe.label, tableName: oe.label, keySchema: ae, valueSchema: fe } });
}
function F(ne, oe) {
  return Object.fromEntries(Object.entries(oe).map(([, ae]) => [ae.label, q$1(ne, ae)]));
}
function Q$1({ world: ne, tables: oe, shouldSkipUpdateStream: ae }) {
  ne.registerEntity({ id: T$2 });
  let fe = { ...F(ne, oe), ...V(ne) };
  async function ye({ logs: we }) {
    var xe, Oe;
    let _e = we.filter(L$1).map(K$2);
    for (let $e of _e) {
      let Re = E$1($e);
      le$1(fe.RegisteredTables, Re) ? console.warn("table already registered, ignoring", { newTable: $e, existingTable: (xe = g$3(fe.RegisteredTables, Re)) == null ? void 0 : xe.table }) : E$2(fe.RegisteredTables, Re, { table: $e }, { skipUpdateStream: ae == null ? void 0 : ae() });
    }
    for (let $e of we) {
      let { namespace: Re, name: Ne } = _$4($e.args.tableId), je = (Oe = g$3(fe.RegisteredTables, E$1({ address: $e.address, namespace: Re, name: Ne }))) == null ? void 0 : Oe.table;
      if (!je) {
        b$2(`skipping update for unknown table: ${i$6({ namespace: Re, name: Ne })} at ${$e.address}`);
        continue;
      }
      let Be = ne.components.find((He) => He.id === je.tableId);
      if (!Be) {
        b$2(`skipping update for unknown component: ${je.tableId} (${i$6({ namespace: Re, name: Ne })}). Available components: ${Object.keys(fe)}`);
        continue;
      }
      let ze = d$1($e.args.keyTuple);
      if ($e.eventName === "Store_SetRecord") {
        let He = zt$1(je.valueSchema, $e.args);
        b$2("setting component", { namespace: je.namespace, name: je.name, entity: ze, value: He }), E$2(Be, ze, { ...He, __staticData: $e.args.staticData, __encodedLengths: $e.args.encodedLengths, __dynamicData: $e.args.dynamicData }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if ($e.eventName === "Store_SpliceStaticData") {
        let He = g$3(Be, ze), qe = (He == null ? void 0 : He.__staticData) ?? "0x", Ye = Pe(qe, $e.args.start, size$2($e.args.data), $e.args.data), ot = zt$1(je.valueSchema, { staticData: Ye, encodedLengths: (He == null ? void 0 : He.__encodedLengths) ?? "0x", dynamicData: (He == null ? void 0 : He.__dynamicData) ?? "0x" });
        b$2("setting component via splice static", { namespace: je.namespace, name: je.name, entity: ze, previousStaticData: qe, newStaticData: Ye, previousValue: He, newValue: ot }), E$2(Be, ze, { ...ot, __staticData: Ye }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if ($e.eventName === "Store_SpliceDynamicData") {
        let He = g$3(Be, ze), qe = (He == null ? void 0 : He.__dynamicData) ?? "0x", Ye = Pe(qe, $e.args.start, $e.args.deleteCount, $e.args.data), ot = zt$1(je.valueSchema, { staticData: (He == null ? void 0 : He.__staticData) ?? "0x", encodedLengths: $e.args.encodedLengths, dynamicData: Ye });
        b$2("setting component via splice dynamic", { namespace: je.namespace, name: je.name, entity: ze, previousDynamicData: qe, newDynamicData: Ye, previousValue: He, newValue: ot }), E$2(Be, ze, { ...ot, __encodedLengths: $e.args.encodedLengths, __dynamicData: Ye }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else
        $e.eventName === "Store_DeleteRecord" && (b$2("deleting component", { namespace: je.namespace, name: je.name, entity: ze }), ue(Be, ze, { skipUpdateStream: ae == null ? void 0 : ae() }));
    }
  }
  return { storageAdapter: ye, components: fe };
}
async function Ke({ world: ne, config: oe, tables: ae = {}, startSync: fe = !0, ...ye }) {
  let we = { ...O(oe), ...ae, ...A$3 }, { storageAdapter: _e, components: xe } = Q$1({ world: ne, tables: we, shouldSkipUpdateStream: () => {
    var Ne;
    return ((Ne = g$3(xe.SyncProgress, T$2)) == null ? void 0 : Ne.step) !== "live";
  } }), Oe = await Et({ storageAdapter: _e, config: oe, ...ye, onProgress: ({ step: Ne, percentage: je, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }) => {
    var qe;
    if (((qe = g$3(xe.SyncProgress, T$2)) == null ? void 0 : qe.step) !== "live" && (E$2(xe.SyncProgress, T$2, { step: Ne, percentage: je, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }), Ne === "live"))
      for (let Ye of Object.values(xe)) {
        let ot = Ye;
        for (let tt of ot.entities()) {
          let it = g$3(ot, tt);
          ot.update$.next({ component: ot, entity: tt, value: [it, it] });
        }
      }
  } }), $e = fe ? Oe.storedBlockLogs$.subscribe() : null, Re = () => {
    $e == null || $e.unsubscribe();
  };
  return ne.registerDisposer(Re), { ...Oe, components: xe, stopSync: Re };
}
const worldsJson = {
  4242: {
    address: "0x079f71c3f6e9f4813ef249980F2a3b22dDc1263c",
    ToadNumber: 27977825
  },
  17069: {
    address: "0xfd24503495bf2aeeb06fe8eaa28a07e00c111045",
    blockNumber: 6673606
  },
  31337: {
    address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
  }
}, contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(ne) {
      var ae;
      return {
        transactions: (ae = ne.transactions) == null ? void 0 : ae.map((fe) => {
          if (typeof fe == "string")
            return fe;
          const ye = formatTransaction(fe);
          return ye.typeHex === "0x7e" && (ye.isSystemTx = fe.isSystemTx, ye.mint = fe.mint ? hexToBigInt(fe.mint) : void 0, ye.sourceHash = fe.sourceHash, ye.type = "deposit"), ye;
        }),
        stateRoot: ne.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(ne) {
      const oe = {};
      return ne.type === "0x7e" && (oe.isSystemTx = ne.isSystemTx, oe.mint = ne.mint ? hexToBigInt(ne.mint) : void 0, oe.sourceHash = ne.sourceHash, oe.type = "deposit"), oe;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(ne) {
      return {
        l1GasPrice: ne.l1GasPrice ? hexToBigInt(ne.l1GasPrice) : null,
        l1GasUsed: ne.l1GasUsed ? hexToBigInt(ne.l1GasUsed) : null,
        l1Fee: ne.l1Fee ? hexToBigInt(ne.l1Fee) : null,
        l1FeeScalar: ne.l1FeeScalar ? Number(ne.l1FeeScalar) : null
      };
    }
  })
};
function serializeTransaction(ne, oe) {
  return isDeposit(ne) ? serializeTransactionDeposit(ne) : serializeTransaction$1(ne, oe);
}
const serializers = {
  transaction: serializeTransaction
};
function serializeTransactionDeposit(ne) {
  assertTransactionDeposit(ne);
  const { sourceHash: oe, data: ae, from: fe, gas: ye, isSystemTx: we, mint: _e, to: xe, value: Oe } = ne, $e = [
    oe,
    fe,
    xe ?? "0x",
    _e ? toHex(_e) : "0x",
    Oe ? toHex(Oe) : "0x",
    ye ? toHex(ye) : "0x",
    we ? "0x1" : "0x",
    ae ?? "0x"
  ];
  return concatHex$1([
    "0x7e",
    toRlp($e)
  ]);
}
function isDeposit(ne) {
  return ne.type === "deposit" || typeof ne.sourceHash < "u";
}
function assertTransactionDeposit(ne) {
  const { from: oe, to: ae } = ne;
  if (oe && !isAddress(oe))
    throw new InvalidAddressError({ address: oe });
  if (ae && !isAddress(ae))
    throw new InvalidAddressError({ address: ae });
}
const chainConfig = {
  contracts,
  formatters,
  serializers
}, foundry = /* @__PURE__ */ defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});
var o$3 = { ...foundry, fees: { defaultPriorityFee: 0n } }, e$2 = 17e3, c$2 = { ...chainConfig, id: 17069, sourceId: e$2, name: "Garnet Holesky", testnet: !0, nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 }, rpcUrls: { default: { http: ["https://rpc.garnetchain.com"], webSocket: ["wss://rpc.garnetchain.com"] } }, blockExplorers: { default: { name: "Blockscout", url: "https://explorer.garnetchain.com" } }, contracts: { ...chainConfig.contracts, multicall3: { address: "0xca11bde05977b3631167028862be2a173976ca11" }, portal: { [e$2]: { address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909", blockCreated: 1274684 } }, l2OutputOracle: { [e$2]: { address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B", blockCreated: 1274684 } }, l1StandardBridge: { [e$2]: { address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE", blockCreated: 1274684 } } }, iconUrls: ["https://redstone.xyz/chain-icons/garnet.png"], indexerUrl: "https://indexer.mud.garnetchain.com" }, t = 1;
({ ...chainConfig, contracts: { ...chainConfig.contracts, portal: t + "", l2OutputOracle: t + "", l1StandardBridge: t + "" } });
const supportedChains = [o$3, c$2], worlds = worldsJson;
async function getNetworkConfig() {
  const ne = new URLSearchParams(window.location.search), oe = Number(ne.get("chainId") || ne.get("chainid") || {}.VITE_CHAIN_ID || 17069), ae = supportedChains.findIndex((Oe) => Oe.id === oe), fe = supportedChains[ae];
  if (!fe)
    throw new Error(`Chain ${oe} not found`);
  const ye = worlds[fe.id.toString()], we = ne.get("worldAddress") || (ye == null ? void 0 : ye.address);
  if (!we)
    throw new Error(`No world address found for chain ${oe}. Did you run \`mud deploy\`?`);
  const _e = ne.has("initialBlockNumber") ? Number(ne.get("initialBlockNumber")) : (ye == null ? void 0 : ye.blockNumber) ?? 0n;
  return {
    privateKey: ne.get("pk") || "0x000000000000000000000000832cce0f0faef94f242adad051e015bed9ffa7d4",
    //getBurnerPrivateKey(),
    chainId: oe,
    chain: fe,
    faucetServiceUrl: ne.get("faucet") ?? fe.faucetUrl,
    worldAddress: we,
    initialBlockNumber: _e
  };
}
const world = lt(), IWorldAbi = [
  {
    type: "function",
    name: "_calculateLosses",
    inputs: [
      {
        name: "armyKey",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "defenceLocation",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256[8]",
        internalType: "uint256[8]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "attack",
    inputs: [
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCall",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallData[]",
        components: [
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCallFrom",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallFromData[]",
        components: [
          {
            name: "from",
            type: "address",
            internalType: "address"
          },
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryA",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryC",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantry",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantryByToken",
    inputs: [
      {
        name: "token_type",
        type: "uint8",
        internalType: "enum TokenType"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "call",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "callFrom",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "claim",
    inputs: [
      {
        name: "proof",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "claimRewardB",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "creator",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "farming",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "garrison",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getArmyPower",
    inputs: [
      {
        name: "entityKey",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldSlice",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLayout",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getKeySchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLandPower",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPairAmounts",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStageOneEndTime",
    inputs: [],
    outputs: [
      {
        name: "timestamp",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getStakeLimit",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTokenAmounts",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getValueSchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initAllowance",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "initModule",
        type: "address",
        internalType: "contract IModule"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installRootModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "march",
    inputs: [
      {
        name: "destination",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "passiveUnStake",
    inputs: [
      {
        name: "defender",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "attacker",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "popFromDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "byteLengthToPop",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pushToDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "dataToPush",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespace",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerRootFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "worldFunctionSignature",
        type: "string",
        internalType: "string"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystem",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "system",
        type: "address",
        internalType: "contract System"
      },
      {
        name: "publicAccess",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerTable",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      },
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "keyNames",
        type: "string[]",
        internalType: "string[]"
      },
      {
        name: "fieldNames",
        type: "string[]",
        internalType: "string[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBurnRate",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setLastStakeTime",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setMerkleRoot",
    inputs: [
      {
        name: "_merkleRoot",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setNetValue",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setOwner",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPassiveUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setRewardPerSecondReward",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spawnCapital",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "spawnPlayer",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stakeTokenB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "storeVersion",
    inputs: [],
    outputs: [
      {
        name: "version",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "swapA2B",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "swapA2C",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToAddress",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToNamespace",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ultraBurnTokenB",
    inputs: [
      {
        name: "net_value",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "stake_reward",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ultraMintTokenB",
    inputs: [
      {
        name: "net_value",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "stake_reward",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unstakeB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "withdrawToken",
    inputs: [
      {
        name: "tokenAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "worldVersion",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "HelloStore",
    inputs: [
      {
        name: "storeVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "HelloWorld",
    inputs: [
      {
        name: "worldVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_DeleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SetRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        indexed: !1,
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "deleteCount",
        type: "uint40",
        indexed: !1,
        internalType: "uint40"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "EncodedLengths_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_Empty",
    inputs: []
  },
  {
    type: "error",
    name: "FieldLayout_InvalidStaticDataLength",
    inputs: [
      {
        name: "staticDataLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "computedStaticDataLength",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthDoesNotFitInAWord",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsNotZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyDynamicFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Module_AlreadyInstalled",
    inputs: []
  },
  {
    type: "error",
    name: "Module_MissingDependency",
    inputs: [
      {
        name: "dependency",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "Module_NonRootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Module_RootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Schema_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Schema_StaticTypeAfterDynamicType",
    inputs: []
  },
  {
    type: "error",
    name: "Slice_OutOfBounds",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_IndexOutOfBounds",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "accessedIndex",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidBounds",
    inputs: [
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidFieldNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidKeyNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidSplice",
    inputs: [
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "fieldLength",
        type: "uint40",
        internalType: "uint40"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidStaticDataLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaDynamicLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaStaticLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableAlreadyExists",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableNotFound",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_AccessDenied",
    inputs: [
      {
        name: "resource",
        type: "string",
        internalType: "string"
      },
      {
        name: "caller",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_AlreadyInitialized",
    inputs: []
  },
  {
    type: "error",
    name: "World_CallbackNotAllowed",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_DelegationNotFound",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorAlreadyExists",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorNotFound",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "World_InterfaceNotSupported",
    inputs: [
      {
        name: "contractAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidNamespace",
    inputs: [
      {
        name: "namespace",
        type: "bytes14",
        internalType: "bytes14"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceId",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceAlreadyExists",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceNotFound",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_SystemAlreadyExists",
    inputs: [
      {
        name: "system",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_UnlimitedDelegationNotAllowed",
    inputs: []
  }
], IERC20Abi = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "spender",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "balanceOf",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalSupply",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "transfer",
    inputs: [
      {
        name: "to",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferFrom",
    inputs: [
      {
        name: "from",
        type: "address",
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        name: "owner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  }
];
var n = ["uint8", "uint16", "uint24", "uint32", "uint40", "uint48", "uint56", "uint64", "uint72", "uint80", "uint88", "uint96", "uint104", "uint112", "uint120", "uint128", "uint136", "uint144", "uint152", "uint160", "uint168", "uint176", "uint184", "uint192", "uint200", "uint208", "uint216", "uint224", "uint232", "uint240", "uint248", "uint256", "int8", "int16", "int24", "int32", "int40", "int48", "int56", "int64", "int72", "int80", "int88", "int96", "int104", "int112", "int120", "int128", "int136", "int144", "int152", "int160", "int168", "int176", "int184", "int192", "int200", "int208", "int216", "int224", "int232", "int240", "int248", "int256", "bytes1", "bytes2", "bytes3", "bytes4", "bytes5", "bytes6", "bytes7", "bytes8", "bytes9", "bytes10", "bytes11", "bytes12", "bytes13", "bytes14", "bytes15", "bytes16", "bytes17", "bytes18", "bytes19", "bytes20", "bytes21", "bytes22", "bytes23", "bytes24", "bytes25", "bytes26", "bytes27", "bytes28", "bytes29", "bytes30", "bytes31", "bytes32", "bool", "address", "uint8[]", "uint16[]", "uint24[]", "uint32[]", "uint40[]", "uint48[]", "uint56[]", "uint64[]", "uint72[]", "uint80[]", "uint88[]", "uint96[]", "uint104[]", "uint112[]", "uint120[]", "uint128[]", "uint136[]", "uint144[]", "uint152[]", "uint160[]", "uint168[]", "uint176[]", "uint184[]", "uint192[]", "uint200[]", "uint208[]", "uint216[]", "uint224[]", "uint232[]", "uint240[]", "uint248[]", "uint256[]", "int8[]", "int16[]", "int24[]", "int32[]", "int40[]", "int48[]", "int56[]", "int64[]", "int72[]", "int80[]", "int88[]", "int96[]", "int104[]", "int112[]", "int120[]", "int128[]", "int136[]", "int144[]", "int152[]", "int160[]", "int168[]", "int176[]", "int184[]", "int192[]", "int200[]", "int208[]", "int216[]", "int224[]", "int232[]", "int240[]", "int248[]", "int256[]", "bytes1[]", "bytes2[]", "bytes3[]", "bytes4[]", "bytes5[]", "bytes6[]", "bytes7[]", "bytes8[]", "bytes9[]", "bytes10[]", "bytes11[]", "bytes12[]", "bytes13[]", "bytes14[]", "bytes15[]", "bytes16[]", "bytes17[]", "bytes18[]", "bytes19[]", "bytes20[]", "bytes21[]", "bytes22[]", "bytes23[]", "bytes24[]", "bytes25[]", "bytes26[]", "bytes27[]", "bytes28[]", "bytes29[]", "bytes30[]", "bytes31[]", "bytes32[]", "bool[]", "address[]", "bytes", "string"], a$1 = n.slice(0, 98);
function o$2(ne) {
  return n.includes(ne);
}
function e$1(ne) {
  return a$1.includes(ne);
}
var i$3 = /\[\d+\]$/;
function A$1(ne) {
  return typeof ne == "string" && i$3.test(ne) && e$1(ne.replace(i$3, ""));
}
function f$1(ne) {
  return ne.replace(i$3, "[]");
}
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var ne = 1e3, oe = ne * 60, ae = oe * 60, fe = ae * 24, ye = fe * 7, we = fe * 365.25;
  ms = function(Re, Ne) {
    Ne = Ne || {};
    var je = typeof Re;
    if (je === "string" && Re.length > 0)
      return _e(Re);
    if (je === "number" && isFinite(Re))
      return Ne.long ? Oe(Re) : xe(Re);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(Re)
    );
  };
  function _e(Re) {
    if (Re = String(Re), !(Re.length > 100)) {
      var Ne = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        Re
      );
      if (Ne) {
        var je = parseFloat(Ne[1]), Be = (Ne[2] || "ms").toLowerCase();
        switch (Be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return je * we;
          case "weeks":
          case "week":
          case "w":
            return je * ye;
          case "days":
          case "day":
          case "d":
            return je * fe;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return je * ae;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return je * oe;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return je * ne;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return je;
          default:
            return;
        }
      }
    }
  }
  function xe(Re) {
    var Ne = Math.abs(Re);
    return Ne >= fe ? Math.round(Re / fe) + "d" : Ne >= ae ? Math.round(Re / ae) + "h" : Ne >= oe ? Math.round(Re / oe) + "m" : Ne >= ne ? Math.round(Re / ne) + "s" : Re + "ms";
  }
  function Oe(Re) {
    var Ne = Math.abs(Re);
    return Ne >= fe ? $e(Re, Ne, fe, "day") : Ne >= ae ? $e(Re, Ne, ae, "hour") : Ne >= oe ? $e(Re, Ne, oe, "minute") : Ne >= ne ? $e(Re, Ne, ne, "second") : Re + " ms";
  }
  function $e(Re, Ne, je, Be) {
    var ze = Ne >= je * 1.5;
    return Math.round(Re / je) + " " + Be + (ze ? "s" : "");
  }
  return ms;
}
function setup$1(ne) {
  ae.debug = ae, ae.default = ae, ae.coerce = Oe, ae.disable = we, ae.enable = ye, ae.enabled = _e, ae.humanize = requireMs(), ae.destroy = $e, Object.keys(ne).forEach((Re) => {
    ae[Re] = ne[Re];
  }), ae.names = [], ae.skips = [], ae.formatters = {};
  function oe(Re) {
    let Ne = 0;
    for (let je = 0; je < Re.length; je++)
      Ne = (Ne << 5) - Ne + Re.charCodeAt(je), Ne |= 0;
    return ae.colors[Math.abs(Ne) % ae.colors.length];
  }
  ae.selectColor = oe;
  function ae(Re) {
    let Ne, je = null, Be, ze;
    function He(...qe) {
      if (!He.enabled)
        return;
      const Ye = He, ot = Number(/* @__PURE__ */ new Date()), tt = ot - (Ne || ot);
      Ye.diff = tt, Ye.prev = Ne, Ye.curr = ot, Ne = ot, qe[0] = ae.coerce(qe[0]), typeof qe[0] != "string" && qe.unshift("%O");
      let it = 0;
      qe[0] = qe[0].replace(/%([a-zA-Z%])/g, (gt, At) => {
        if (gt === "%%")
          return "%";
        it++;
        const St = ae.formatters[At];
        if (typeof St == "function") {
          const Nt = qe[it];
          gt = St.call(Ye, Nt), qe.splice(it, 1), it--;
        }
        return gt;
      }), ae.formatArgs.call(Ye, qe), (Ye.log || ae.log).apply(Ye, qe);
    }
    return He.namespace = Re, He.useColors = ae.useColors(), He.color = ae.selectColor(Re), He.extend = fe, He.destroy = ae.destroy, Object.defineProperty(He, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => je !== null ? je : (Be !== ae.namespaces && (Be = ae.namespaces, ze = ae.enabled(Re)), ze),
      set: (qe) => {
        je = qe;
      }
    }), typeof ae.init == "function" && ae.init(He), He;
  }
  function fe(Re, Ne) {
    const je = ae(this.namespace + (typeof Ne > "u" ? ":" : Ne) + Re);
    return je.log = this.log, je;
  }
  function ye(Re) {
    ae.save(Re), ae.namespaces = Re, ae.names = [], ae.skips = [];
    let Ne;
    const je = (typeof Re == "string" ? Re : "").split(/[\s,]+/), Be = je.length;
    for (Ne = 0; Ne < Be; Ne++)
      je[Ne] && (Re = je[Ne].replace(/\*/g, ".*?"), Re[0] === "-" ? ae.skips.push(new RegExp("^" + Re.slice(1) + "$")) : ae.names.push(new RegExp("^" + Re + "$")));
  }
  function we() {
    const Re = [
      ...ae.names.map(xe),
      ...ae.skips.map(xe).map((Ne) => "-" + Ne)
    ].join(",");
    return ae.enable(""), Re;
  }
  function _e(Re) {
    if (Re[Re.length - 1] === "*")
      return !0;
    let Ne, je;
    for (Ne = 0, je = ae.skips.length; Ne < je; Ne++)
      if (ae.skips[Ne].test(Re))
        return !1;
    for (Ne = 0, je = ae.names.length; Ne < je; Ne++)
      if (ae.names[Ne].test(Re))
        return !0;
    return !1;
  }
  function xe(Re) {
    return Re.toString().substring(2, Re.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function Oe(Re) {
    return Re instanceof Error ? Re.stack || Re.message : Re;
  }
  function $e() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ae.enable(ae.load()), ae;
}
var common = setup$1;
(function(ne, oe) {
  oe.formatArgs = fe, oe.save = ye, oe.load = we, oe.useColors = ae, oe.storage = _e(), oe.destroy = (() => {
    let Oe = !1;
    return () => {
      Oe || (Oe = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), oe.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ae() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let Oe;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (Oe = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Oe[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fe(Oe) {
    if (Oe[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Oe[0] + (this.useColors ? "%c " : " ") + "+" + ne.exports.humanize(this.diff), !this.useColors)
      return;
    const $e = "color: " + this.color;
    Oe.splice(1, 0, $e, "color: inherit");
    let Re = 0, Ne = 0;
    Oe[0].replace(/%[a-zA-Z%]/g, (je) => {
      je !== "%%" && (Re++, je === "%c" && (Ne = Re));
    }), Oe.splice(Ne, 0, $e);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ye(Oe) {
    try {
      Oe ? oe.storage.setItem("debug", Oe) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function we() {
    let Oe;
    try {
      Oe = oe.storage.getItem("debug");
    } catch {
    }
    return !Oe && typeof process < "u" && "env" in process && (Oe = process.env.DEBUG), Oe;
  }
  function _e() {
    try {
      return localStorage;
    } catch {
    }
  }
  ne.exports = common(oe);
  const { formatters: xe } = ne.exports;
  xe.j = function(Oe) {
    try {
      return JSON.stringify(Oe);
    } catch ($e) {
      return "[UnexpectedJSONParseError]: " + $e.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const k$2 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var e = k$2("mud:common"), r$2 = k$2("mud:common");
e.log = console.debug.bind(console);
r$2.log = console.error.bind(console);
function isHex(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
function size(ne) {
  return isHex(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
const version = "2.9.20", getVersion = () => `viem@${version}`;
class BaseError extends Error {
  constructor(oe, ae = {}) {
    var we;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion()
    });
    const fe = ae.cause instanceof BaseError ? ae.cause.details : (we = ae.cause) != null && we.message ? ae.cause.message : ae.details, ye = ae.cause instanceof BaseError && ae.cause.docsPath || ae.docsPath;
    this.message = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [
        `Docs: https://viem.sh${ye}${ae.docsSlug ? `#${ae.docsSlug}` : ""}`
      ] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
  walk(oe) {
    return walk(this, oe);
  }
}
function walk(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? walk(ne.cause, oe) : oe ? null : ne;
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} size (${oe}) exceeds padding size (${ae}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
function pad(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? padHex(ne, { dir: oe, size: ae }) : padBytes(ne, { dir: oe, size: ae });
}
function padHex(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  const fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(fe.length / 2),
      targetSize: ae,
      type: "hex"
    });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function padBytes(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new SizeExceedsPaddingSizeError({
      size: ne.length,
      targetSize: ae,
      type: "bytes"
    });
  const fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    const we = oe === "right";
    fe[we ? ye : ae - ye - 1] = ne[we ? ye : ne.length - ye - 1];
  }
  return fe;
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize: oe, maxSize: ae }) {
    super(`Size cannot exceed ${ae} bytes. Given size: ${oe} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
}
function assertSize(ne, { size: oe }) {
  if (size(ne) > oe)
    throw new SizeOverflowError({
      givenSize: size(ne),
      maxSize: oe
    });
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function bytesToHex(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += hexes[ne[ye]];
  const fe = `0x${ae}`;
  return typeof oe.size == "number" ? (assertSize(fe, { size: oe.size }), pad(fe, { dir: "right", size: oe.size })) : fe;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(ne, oe = {}) {
  const ae = encoder.encode(ne);
  return bytesToHex(ae, oe);
}
function concatHex(ne) {
  return `0x${ne.reduce((oe, ae) => oe + ae.replace("0x", ""), "")}`;
}
var eventemitter3 = { exports: {} };
(function(ne) {
  var oe = Object.prototype.hasOwnProperty, ae = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (ae = !1));
  function ye(Oe, $e, Re) {
    this.fn = Oe, this.context = $e, this.once = Re || !1;
  }
  function we(Oe, $e, Re, Ne, je) {
    if (typeof Re != "function")
      throw new TypeError("The listener must be a function");
    var Be = new ye(Re, Ne || Oe, je), ze = ae ? ae + $e : $e;
    return Oe._events[ze] ? Oe._events[ze].fn ? Oe._events[ze] = [Oe._events[ze], Be] : Oe._events[ze].push(Be) : (Oe._events[ze] = Be, Oe._eventsCount++), Oe;
  }
  function _e(Oe, $e) {
    --Oe._eventsCount === 0 ? Oe._events = new fe() : delete Oe._events[$e];
  }
  function xe() {
    this._events = new fe(), this._eventsCount = 0;
  }
  xe.prototype.eventNames = function() {
    var $e = [], Re, Ne;
    if (this._eventsCount === 0)
      return $e;
    for (Ne in Re = this._events)
      oe.call(Re, Ne) && $e.push(ae ? Ne.slice(1) : Ne);
    return Object.getOwnPropertySymbols ? $e.concat(Object.getOwnPropertySymbols(Re)) : $e;
  }, xe.prototype.listeners = function($e) {
    var Re = ae ? ae + $e : $e, Ne = this._events[Re];
    if (!Ne)
      return [];
    if (Ne.fn)
      return [Ne.fn];
    for (var je = 0, Be = Ne.length, ze = new Array(Be); je < Be; je++)
      ze[je] = Ne[je].fn;
    return ze;
  }, xe.prototype.listenerCount = function($e) {
    var Re = ae ? ae + $e : $e, Ne = this._events[Re];
    return Ne ? Ne.fn ? 1 : Ne.length : 0;
  }, xe.prototype.emit = function($e, Re, Ne, je, Be, ze) {
    var He = ae ? ae + $e : $e;
    if (!this._events[He])
      return !1;
    var qe = this._events[He], Ye = arguments.length, ot, tt;
    if (qe.fn) {
      switch (qe.once && this.removeListener($e, qe.fn, void 0, !0), Ye) {
        case 1:
          return qe.fn.call(qe.context), !0;
        case 2:
          return qe.fn.call(qe.context, Re), !0;
        case 3:
          return qe.fn.call(qe.context, Re, Ne), !0;
        case 4:
          return qe.fn.call(qe.context, Re, Ne, je), !0;
        case 5:
          return qe.fn.call(qe.context, Re, Ne, je, Be), !0;
        case 6:
          return qe.fn.call(qe.context, Re, Ne, je, Be, ze), !0;
      }
      for (tt = 1, ot = new Array(Ye - 1); tt < Ye; tt++)
        ot[tt - 1] = arguments[tt];
      qe.fn.apply(qe.context, ot);
    } else {
      var it = qe.length, ht;
      for (tt = 0; tt < it; tt++)
        switch (qe[tt].once && this.removeListener($e, qe[tt].fn, void 0, !0), Ye) {
          case 1:
            qe[tt].fn.call(qe[tt].context);
            break;
          case 2:
            qe[tt].fn.call(qe[tt].context, Re);
            break;
          case 3:
            qe[tt].fn.call(qe[tt].context, Re, Ne);
            break;
          case 4:
            qe[tt].fn.call(qe[tt].context, Re, Ne, je);
            break;
          default:
            if (!ot)
              for (ht = 1, ot = new Array(Ye - 1); ht < Ye; ht++)
                ot[ht - 1] = arguments[ht];
            qe[tt].fn.apply(qe[tt].context, ot);
        }
    }
    return !0;
  }, xe.prototype.on = function($e, Re, Ne) {
    return we(this, $e, Re, Ne, !1);
  }, xe.prototype.once = function($e, Re, Ne) {
    return we(this, $e, Re, Ne, !0);
  }, xe.prototype.removeListener = function($e, Re, Ne, je) {
    var Be = ae ? ae + $e : $e;
    if (!this._events[Be])
      return this;
    if (!Re)
      return _e(this, Be), this;
    var ze = this._events[Be];
    if (ze.fn)
      ze.fn === Re && (!je || ze.once) && (!Ne || ze.context === Ne) && _e(this, Be);
    else {
      for (var He = 0, qe = [], Ye = ze.length; He < Ye; He++)
        (ze[He].fn !== Re || je && !ze[He].once || Ne && ze[He].context !== Ne) && qe.push(ze[He]);
      qe.length ? this._events[Be] = qe.length === 1 ? qe[0] : qe : _e(this, Be);
    }
    return this;
  }, xe.prototype.removeAllListeners = function($e) {
    var Re;
    return $e ? (Re = ae ? ae + $e : $e, this._events[Re] && _e(this, Re)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, xe.prototype.off = xe.prototype.removeListener, xe.prototype.addListener = xe.prototype.on, xe.prefixed = ae, xe.EventEmitter = xe, ne.exports = xe;
})(eventemitter3);
globalThis && globalThis.__classPrivateFieldGet;
globalThis && globalThis.__classPrivateFieldSet;
globalThis && globalThis.__classPrivateFieldGet;
var retry = {};
function RetryOperation(ne, oe) {
  typeof oe == "boolean" && (oe = { forever: oe }), this._originalTimeouts = JSON.parse(JSON.stringify(ne)), this._timeouts = ne, this._options = oe || {}, this._maxRetryTime = oe && oe.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(ne) {
  if (this._timeout && clearTimeout(this._timeout), !ne)
    return !1;
  var oe = (/* @__PURE__ */ new Date()).getTime();
  if (ne && oe - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ne), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ne);
  var ae = this._timeouts.shift();
  if (ae === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), ae = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, ae), this._options.unref && this._timer.unref(), !0;
};
RetryOperation.prototype.attempt = function(ne, oe) {
  this._fn = ne, oe && (oe.timeout && (this._operationTimeout = oe.timeout), oe.cb && (this._operationTimeoutCb = oe.cb));
  var ae = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    ae._operationTimeoutCb();
  }, ae._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation.prototype.try = function(ne) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = function(ne) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ne = {}, oe = null, ae = 0, fe = 0; fe < this._errors.length; fe++) {
    var ye = this._errors[fe], we = ye.message, _e = (ne[we] || 0) + 1;
    ne[we] = _e, _e >= ae && (oe = ye, ae = _e);
  }
  return oe;
};
(function(ne) {
  var oe = retry_operation;
  ne.operation = function(ae) {
    var fe = ne.timeouts(ae);
    return new oe(fe, {
      forever: ae && (ae.forever || ae.retries === 1 / 0),
      unref: ae && ae.unref,
      maxRetryTime: ae && ae.maxRetryTime
    });
  }, ne.timeouts = function(ae) {
    if (ae instanceof Array)
      return [].concat(ae);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ye in ae)
      fe[ye] = ae[ye];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var we = [], _e = 0; _e < fe.retries; _e++)
      we.push(this.createTimeout(_e, fe));
    return ae && ae.forever && !we.length && we.push(this.createTimeout(_e, fe)), we.sort(function(xe, Oe) {
      return xe - Oe;
    }), we;
  }, ne.createTimeout = function(ae, fe) {
    var ye = fe.randomize ? Math.random() + 1 : 1, we = Math.round(ye * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, ae));
    return we = Math.min(we, fe.maxTimeout), we;
  }, ne.wrap = function(ae, fe, ye) {
    if (fe instanceof Array && (ye = fe, fe = null), !ye) {
      ye = [];
      for (var we in ae)
        typeof ae[we] == "function" && ye.push(we);
    }
    for (var _e = 0; _e < ye.length; _e++) {
      var xe = ye[_e], Oe = ae[xe];
      ae[xe] = (function(Re) {
        var Ne = ne.operation(fe), je = Array.prototype.slice.call(arguments, 1), Be = je.pop();
        je.push(function(ze) {
          Ne.retry(ze) || (ze && (arguments[0] = Ne.mainError()), Be.apply(this, arguments));
        }), Ne.attempt(function() {
          Re.apply(ae, je);
        });
      }).bind(ae, Oe), ae[xe].options = fe;
    }
  };
})(retry);
e.extend("createNonceManager");
e.extend("writeContract");
e.extend("sendTransaction");
var o$1 = { table: "tb", offchainTable: "ot", namespace: "ns", system: "sy" };
function x$1(ne) {
  let oe = o$1[ne.type];
  if (ne.namespace.length > 14)
    throw new Error(`Namespaces must fit into \`bytes14\`, but "${ne.namespace}" is too long.`);
  return concatHex([stringToHex(oe, { size: 2 }), stringToHex(ne.namespace, { size: 14 }), stringToHex(ne.name.slice(0, 16), { size: 16 })]);
}
Object.fromEntries(Object.entries(o$1).map(([ne, oe]) => [oe, ne]));
var T$1 = k$2("mud:benchmark");
T$1.log = console.info.bind(console);
e.extend("transportObserver");
function y$1(ne, oe) {
  let ae = /* @__PURE__ */ new Map();
  for (let fe of ne) {
    let ye = oe(fe);
    ae.has(ye) || ae.set(ye, []), ae.get(ye).push(fe);
  }
  return ae;
}
function P$1(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, oe(fe, ae)]));
}
function flatMorph(ne, oe) {
  var we;
  const ae = Array.isArray(ne), fe = Object.entries(ne).flatMap((_e, xe) => {
    const Oe = ae ? oe(xe, _e[1]) : oe(..._e, xe);
    return Array.isArray(Oe[0]) || Oe.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      Oe
    ) : [Oe];
  }), ye = Object.fromEntries(fe);
  return typeof ((we = fe[0]) == null ? void 0 : we[0]) == "number" ? Object.values(ye) : ye;
}
var Hkt;
(function(ne) {
  class oe {
  }
  ne.Kind = oe;
  class ae {
  }
  ne.Instantiable = ae, ne.reify = (ye) => ye.hkt;
  class fe {
  }
  ne.UnaryKind = fe, ne.pipe = (...ye) => (we) => ye.reduce((_e, xe) => xe.hkt(_e), we);
})(Hkt || (Hkt = {}));
const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);
const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);
const integerLikeMatcher = /^-?\d+$/;
integerLikeMatcher.test.bind(integerLikeMatcher);
const prototypeKeysOf = (ne) => {
  const oe = [];
  let ae = ne;
  for (; ae !== Object.prototype && ae !== null && ae !== void 0; ) {
    for (const fe of Object.getOwnPropertyNames(ae))
      fe !== "constructor" && !oe.includes(fe) && oe.push(fe);
    for (const fe of Object.getOwnPropertySymbols(ae))
      oe.includes(fe) || oe.push(fe);
    ae = Object.getPrototypeOf(ae);
  }
  return oe;
};
prototypeKeysOf(0n), prototypeKeysOf(!1), prototypeKeysOf(0), prototypeKeysOf(""), prototypeKeysOf(Symbol());
function c$1(ne, oe) {
  return typeof ne == "object" && ne != null && o(ne, oe) ? ne[oe] : void 0;
}
function o(ne, oe) {
  return typeof ne == "object" && ne !== null && ne.hasOwnProperty(oe);
}
function r$1(ne) {
  return ne != null && typeof ne == "object";
}
function i$2(ne, oe) {
  let ae = [.../* @__PURE__ */ new Set([...Object.keys(ne), ...Object.keys(oe)])];
  return Object.fromEntries(ae.map((fe) => [fe, typeof ne[fe] > "u" ? oe[fe] : ne[fe]]));
}
var b$1 = { storeImportPath: "@latticexyz/store/src", userTypesFilename: "common.sol", outputDirectory: "codegen", indexFilename: "index.sol" }, m$1 = { outputDirectory: "tables", tableIdArgument: !1, storeArgument: !1 }, N$1 = { disabled: !1 }, x = { namespace: "", type: "table" }, T = { sourceDirectory: "src", namespace: "" }, a = { types: Object.fromEntries(n.map((ne) => [ne, ne])) };
function u(ne, oe) {
  return { types: { ...ne.types, ...oe } };
}
function h$1(ne, oe = a) {
  if (!r$1(ne))
    throw new Error(`Expected schema, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    if (!A$1(ae) && !o(oe.types, ae))
      throw new Error(`"${String(ae)}" is not a valid type in this scope.`);
}
function k$1(ne, oe = a) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, { type: A$1(fe) ? f$1(fe) : oe.types[fe], internalType: fe }]));
}
function v(ne, oe = a) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((ae) => A$1(ae) || o(oe.types, ae));
}
function Y$1(ne, oe = a) {
  return Object.entries(ne).filter(([, ae]) => o(oe.types, ae) && e$1(oe.types[ae])).map(([ae]) => ae);
}
function q(ne, oe, ae = a) {
  return Array.isArray(ne) && ne.every((fe) => o(oe, fe) && o(ae.types, oe[fe]) && e$1(ae.types[oe[fe]]));
}
function g$2(ne, oe = a, ae = { inStoreContext: !1 }) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full table config, got \`${JSON.stringify(ne)}\``);
  if (!o(ne, "schema"))
    throw new Error("Missing schema input");
  if (h$1(ne.schema, oe), !o(ne, "key") || !q(ne.key, ne.schema, oe))
    throw new Error(`Invalid key. Expected \`(${Y$1(ne.schema, oe).map((fe) => `"${String(fe)}"`).join(" | ")})[]\`, received \`${o(ne, "key") && Array.isArray(ne.key) ? `[${ne.key.map((fe) => `"${fe}"`).join(", ")}]` : String(c$1(ne, "key"))}\``);
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`Table \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`Table \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
  if (ae.inStoreContext && (o(ne, "label") || o(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for tables in this context.");
}
function H(ne) {
  let oe = ne.codegen;
  return { outputDirectory: c$1(oe, "outputDirectory") ?? m$1.outputDirectory, tableIdArgument: c$1(oe, "tableIdArgument") ?? m$1.tableIdArgument, storeArgument: c$1(oe, "storeArgument") ?? m$1.storeArgument, dataStruct: c$1(oe, "dataStruct") ?? Object.keys(ne.schema).length - ne.key.length > 1 };
}
function E(ne, oe = a) {
  let ae = ne.label, fe = ne.type ?? x.type, ye = ne.namespace ?? x.namespace, we = ne.name ?? ae.slice(0, 16), _e = x$1({ type: fe, namespace: ye, name: we });
  return { label: ae, type: fe, namespace: ye, name: we, tableId: _e, schema: k$1(ne.schema, oe), key: ne.key, codegen: H(ne), deploy: i$2(ne.deploy ?? {}, N$1) };
}
function D$1(ne) {
  return typeof ne == "string" || r$1(ne) && Object.values(ne).every((oe) => typeof oe == "string");
}
function A(ne, oe = a) {
  if (typeof ne == "string") {
    if (A$1(ne) || o(oe.types, ne))
      return;
    throw new Error(`Invalid ABI type. \`${ne}\` not found in scope.`);
  }
  if (typeof ne == "object" && ne !== null) {
    if (v(ne, oe)) {
      if (o(ne, "id") && e$1(oe.types[ne.id]))
        return;
      throw new Error("Invalid schema. Expected an `id` field with a static ABI type or an explicit `key` option.");
    }
    throw new Error("Invalid schema. Are you using invalid types or missing types in your scope?");
  }
  throw new Error("Invalid table shorthand.");
}
function l$2(ne, oe) {
  return typeof ne == "string" ? { schema: { id: "bytes32", value: ne }, key: ["id"] } : v(ne, oe) ? { schema: ne, key: ["id"] } : ne;
}
function d(ne, oe) {
  if (r$1(ne)) {
    for (let ae of Object.values(ne))
      D$1(ae) ? A(ae, oe) : g$2(ae, oe, { inStoreContext: !0 });
    return;
  }
  throw new Error(`Expected tables config, received ${JSON.stringify(ne)}`);
}
function I$2(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, E(i$2(l$2(fe, oe), { label: ae }), oe)]));
}
function Z(ne) {
  return P$1(ne, (oe) => oe.type);
}
function ee(ne) {
  return r$1(ne) && Object.values(ne).every((oe) => o$2(oe.type));
}
function U(ne, oe = a) {
  return ee(ne) ? u(oe, Z(ne)) : oe;
}
function L(ne) {
  if (!r$1(ne))
    throw new Error(`Expected userTypes, received ${JSON.stringify(ne)}`);
  for (let { type: oe } of Object.values(ne))
    if (!o(a.types, oe))
      throw new Error(`"${String(oe)}" is not a valid ABI type.`);
}
function te$1(ne) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((oe) => Array.isArray(oe) && oe.every((ae) => typeof ae == "string"));
}
function _$1(ne, oe = a) {
  if (te$1(ne)) {
    let ae = Object.fromEntries(Object.keys(ne).map((fe) => [fe, "uint8"]));
    return u(oe, ae);
  }
  return oe;
}
function j(ne) {
  return flatMorph(ne, (oe, ae) => [oe, flatMorph(ae, (fe, ye) => [ye, fe])]);
}
function C$1(ne) {
  return r$1(ne) ? i$2(ne, b$1) : b$1;
}
function K(ne, oe) {
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o(ne, "tables") && d(ne.tables, oe);
}
function $(ne, oe = a) {
  let ae = ne.label, fe = ne.namespace ?? ae.slice(0, 14);
  return { label: ae, namespace: fe, tables: I$2(flatMorph(ne.tables ?? {}, (ye, we) => [ye, i$2(l$2(we, oe), { namespace: fe })]), oe) };
}
function w(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    K(ae, oe);
}
function f(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, we) => [ye, $(i$2(we, { label: ye }), oe)]), fe = Array.from(y$1(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function B(ne) {
  return Object.fromEntries(Object.entries(ne.namespaces).flatMap(([oe, ae]) => Object.entries(ae.tables).map(([fe, ye]) => [oe === "" ? fe : `${oe}__${fe}`, ye])));
}
function G(ne) {
  return _$1(c$1(ne, "enums"), U(c$1(ne, "userTypes")));
}
function pe(ne) {
  let oe = G(ne);
  if (o(ne, "namespaces")) {
    if (o(ne, "namespace") || o(ne, "tables"))
      throw new Error("Cannot use `namespaces` with `namespace` or `tables` keys.");
    w(ne.namespaces, oe);
  }
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o(ne, "tables") && d(ne.tables, oe), o(ne, "userTypes") && L(ne.userTypes);
}
function re(ne) {
  let oe = G(ne), ae = ne.namespace ?? T.namespace, fe = ne.namespaces ? { multipleNamespaces: !0, namespace: null, namespaces: f(ne.namespaces, oe) } : { multipleNamespaces: !1, namespace: ae, namespaces: f({ [ae]: ne }, oe) }, ye = B(fe);
  return { ...fe, tables: ye, sourceDirectory: ne.sourceDirectory ?? T.sourceDirectory, userTypes: ne.userTypes ?? {}, enums: ne.enums ?? {}, enumValues: j(ne.enums ?? {}), codegen: C$1(ne.codegen) };
}
var m = { namespace: "", openAccess: !0, accessList: [] }, C = { root: !1, args: [], artifactPath: void 0 }, I$1 = { worldInterfaceName: "IWorld", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src" }, b = { customWorldContract: void 0, postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", upgradeableWorldImplementation: !1 }, P = { systems: {}, tables: {}, excludeSystems: [], modules: [], codegen: I$1, deploy: b };
function i$1(ne, oe = {}) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full system config, got \`${JSON.stringify(ne)}\``);
  if (oe.inNamespace && (o(ne, "label") || o(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for systems in this context.");
  if (o(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`System \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`System \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
}
function c(ne) {
  let oe = ne.label, ae = ne.namespace ?? m.namespace, fe = ne.name ?? oe.slice(0, 16), ye = x$1({ type: "system", namespace: ae, name: fe });
  return i$2({ ...ne, label: oe, namespace: ae, name: fe, systemId: ye }, m);
}
function y(ne) {
  if (r$1(ne)) {
    for (let oe of Object.values(ne))
      i$1(oe, { inNamespace: !0 });
    return;
  }
  throw new Error(`Expected system config, received ${JSON.stringify(ne)}`);
}
function l$1(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, c({ ...fe, label: ae, namespace: oe })]));
}
function Q(ne, oe) {
  o(ne, "systems") && y(ne.systems), K(ne, oe);
}
function X(ne, oe = a) {
  let ae = $(ne, oe), fe = l$1(ne.systems ?? {}, ae.namespace);
  return { ...ae, systems: fe };
}
function l(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    Q(ae, oe);
}
function r(ne, oe) {
  if (!r$1(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, we) => [ye, X(i$2(we, { label: ye }), oe)]), fe = Array.from(y$1(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function N(ne) {
  return r$1(ne) ? i$2(ne, I$1) : I$1;
}
function g$1(ne) {
  return r$1(ne) ? i$2(ne, b) : b;
}
function W(ne) {
  let oe = G(ne);
  if (o(ne, "namespaces")) {
    if (o(ne, "namespace") || o(ne, "tables") || o(ne, "systems"))
      throw new Error("Cannot use `namespaces` with `namespace`, `tables`, or `systems` keys.");
    l(ne.namespaces, oe);
  }
  o(ne, "systems") && y(ne.systems), pe(ne);
}
function _(ne) {
  let oe = G(ne), ae = re(ne), fe = ne.namespaces ? r(ne.namespaces, oe) : r({ [ae.namespace]: ne }, oe), ye = B({ namespaces: fe }), we = (ne.modules ?? P.modules).map((_e) => i$2(_e, C));
  return i$2({ ...ae, namespaces: fe, tables: ye, systems: !ae.multipleNamespaces && ne.systems ? l$1(ne.systems, ae.namespace) : P.systems, excludeSystems: c$1(ne, "excludeSystems"), codegen: i$2(ae.codegen, N(ne.codegen)), deploy: g$1(ne.deploy), modules: we }, P);
}
function te(ne) {
  return W(ne), _(ne);
}
const mudConfig = te({
  worldContractName: "RoR",
  enums: {
    TokenType: ["TokenA", "TokenB", "TokenC"]
  },
  systems: {
    SpawnSystem: {
      name: "spwan",
      openAccess: !0
    },
    TokenManagerSystem: {
      name: "tokenManager",
      openAccess: !1
    }
  },
  tables: {
    Player: "bool",
    PlayerDetail: {
      schema: {
        id: "bytes32",
        wallet: "address",
        gold: "uint256",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lands: "uint16",
        isSpawnCapital: "bool"
      },
      key: ["id"]
    },
    Army: {
      key: ["key"],
      schema: {
        key: "bytes32",
        owner: "bytes32",
        id: "uint8",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        destination: "uint16"
      }
    },
    Capital: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        lastTime: "uint32"
      }
    },
    Land: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        attackAble: "bool"
      }
    },
    BattleReport: {
      key: ["key"],
      schema: {
        key: "bytes32",
        landId: "uint16",
        timestamp: "uint32",
        attacker: "address",
        defender: "address",
        attackWin: "bool",
        losses: "uint256[8]"
      }
    },
    GlobalStatistics: {
      schema: {
        consumptionTokenB: "uint256",
        consumptionTokenC: "uint256"
      },
      key: []
    },
    GlobalStake: {
      schema: {
        tokenB: "uint256",
        tokenC: "uint256",
        lastStakeTime: "uint256",
        isPositive: "bool",
        mintB: "uint256",
        burnB: "uint256",
        netValue: "uint256",
        burnRate: "uint256",
        perSecondReward: "uint256"
      },
      key: []
    },
    GlobalConfig: {
      schema: {
        unStakeFee: "uint256",
        passiveUnStakeFee: "uint256",
        owner: "address",
        merkleRoot: "bytes32"
      },
      key: []
    },
    PlayerStake: {
      schema: {
        wallet: "address",
        tokenB: "uint256",
        tokenC: "uint256",
        lastRewardTimeB: "uint256",
        lastRewardTimeC: "uint256"
      },
      key: ["wallet"]
    },
    PlayerAirdrop: {
      schema: {
        wallet: "address",
        isClaimed: "bool"
      },
      key: ["wallet"]
    }
    // PlayerStatistics:{
    //   schema: {
    //     id: "bytes32",
    //
    //   },
    //   key: ['id']
    // }
  },
  deploysDirectory: "./mud-deploys"
});
function p(ne = {}) {
  return (oe) => ({ writeContract: (ae) => Je(oe, ae, ne), sendTransaction: (ae) => Ve(oe, ae, ne) });
}
function h({ onWrite: ne }) {
  let oe = 0;
  return (ae) => ({ writeContract: (fe) => {
    let ye = getAction(ae, writeContract, "writeContract")(fe), we = `${ae.chain.id}:${ae.account.address}:${oe++}`;
    return ne({ id: we, request: fe, result: ye }), ye;
  } });
}
const createStoreImpl = (ne) => {
  let oe;
  const ae = /* @__PURE__ */ new Set(), fe = (Re, Ne) => {
    const je = typeof Re == "function" ? Re(oe) : Re;
    if (!Object.is(je, oe)) {
      const Be = oe;
      oe = Ne ?? (typeof je != "object" || je === null) ? je : Object.assign({}, oe, je), ae.forEach((ze) => ze(oe, Be));
    }
  }, ye = () => oe, Oe = { setState: fe, getState: ye, getInitialState: () => $e, subscribe: (Re) => (ae.add(Re), () => ae.delete(Re)), destroy: () => {
    ae.clear();
  } }, $e = oe = ne(fe, ye, Oe);
  return Oe;
}, createStore = (ne) => ne ? createStoreImpl(ne) : createStoreImpl;
var react = { exports: {} }, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min)
    return react_production_min;
  hasRequiredReact_production_min = 1;
  var ne = Symbol.for("react.element"), oe = Symbol.for("react.portal"), ae = Symbol.for("react.fragment"), fe = Symbol.for("react.strict_mode"), ye = Symbol.for("react.profiler"), we = Symbol.for("react.provider"), _e = Symbol.for("react.context"), xe = Symbol.for("react.forward_ref"), Oe = Symbol.for("react.suspense"), $e = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), Ne = Symbol.iterator;
  function je(yt) {
    return yt === null || typeof yt != "object" ? null : (yt = Ne && yt[Ne] || yt["@@iterator"], typeof yt == "function" ? yt : null);
  }
  var Be = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, ze = Object.assign, He = {};
  function qe(yt, jt, Mn) {
    this.props = yt, this.context = jt, this.refs = He, this.updater = Mn || Be;
  }
  qe.prototype.isReactComponent = {}, qe.prototype.setState = function(yt, jt) {
    if (typeof yt != "object" && typeof yt != "function" && yt != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, yt, jt, "setState");
  }, qe.prototype.forceUpdate = function(yt) {
    this.updater.enqueueForceUpdate(this, yt, "forceUpdate");
  };
  function Ye() {
  }
  Ye.prototype = qe.prototype;
  function ot(yt, jt, Mn) {
    this.props = yt, this.context = jt, this.refs = He, this.updater = Mn || Be;
  }
  var tt = ot.prototype = new Ye();
  tt.constructor = ot, ze(tt, qe.prototype), tt.isPureReactComponent = !0;
  var it = Array.isArray, ht = Object.prototype.hasOwnProperty, gt = { current: null }, At = { key: !0, ref: !0, __self: !0, __source: !0 };
  function St(yt, jt, Mn) {
    var $n, Zt = {}, vn = null, Fn = null;
    if (jt != null)
      for ($n in jt.ref !== void 0 && (Fn = jt.ref), jt.key !== void 0 && (vn = "" + jt.key), jt)
        ht.call(jt, $n) && !At.hasOwnProperty($n) && (Zt[$n] = jt[$n]);
    var Qn = arguments.length - 2;
    if (Qn === 1)
      Zt.children = Mn;
    else if (1 < Qn) {
      for (var Un = Array(Qn), ar = 0; ar < Qn; ar++)
        Un[ar] = arguments[ar + 2];
      Zt.children = Un;
    }
    if (yt && yt.defaultProps)
      for ($n in Qn = yt.defaultProps, Qn)
        Zt[$n] === void 0 && (Zt[$n] = Qn[$n]);
    return { $$typeof: ne, type: yt, key: vn, ref: Fn, props: Zt, _owner: gt.current };
  }
  function Nt(yt, jt) {
    return { $$typeof: ne, type: yt.type, key: jt, ref: yt.ref, props: yt.props, _owner: yt._owner };
  }
  function Ft(yt) {
    return typeof yt == "object" && yt !== null && yt.$$typeof === ne;
  }
  function Vt(yt) {
    var jt = { "=": "=0", ":": "=2" };
    return "$" + yt.replace(/[=:]/g, function(Mn) {
      return jt[Mn];
    });
  }
  var on = /\/+/g;
  function tn(yt, jt) {
    return typeof yt == "object" && yt !== null && yt.key != null ? Vt("" + yt.key) : jt.toString(36);
  }
  function _n(yt, jt, Mn, $n, Zt) {
    var vn = typeof yt;
    (vn === "undefined" || vn === "boolean") && (yt = null);
    var Fn = !1;
    if (yt === null)
      Fn = !0;
    else
      switch (vn) {
        case "string":
        case "number":
          Fn = !0;
          break;
        case "object":
          switch (yt.$$typeof) {
            case ne:
            case oe:
              Fn = !0;
          }
      }
    if (Fn)
      return Fn = yt, Zt = Zt(Fn), yt = $n === "" ? "." + tn(Fn, 0) : $n, it(Zt) ? (Mn = "", yt != null && (Mn = yt.replace(on, "$&/") + "/"), _n(Zt, jt, Mn, "", function(ar) {
        return ar;
      })) : Zt != null && (Ft(Zt) && (Zt = Nt(Zt, Mn + (!Zt.key || Fn && Fn.key === Zt.key ? "" : ("" + Zt.key).replace(on, "$&/") + "/") + yt)), jt.push(Zt)), 1;
    if (Fn = 0, $n = $n === "" ? "." : $n + ":", it(yt))
      for (var Qn = 0; Qn < yt.length; Qn++) {
        vn = yt[Qn];
        var Un = $n + tn(vn, Qn);
        Fn += _n(vn, jt, Mn, Un, Zt);
      }
    else if (Un = je(yt), typeof Un == "function")
      for (yt = Un.call(yt), Qn = 0; !(vn = yt.next()).done; )
        vn = vn.value, Un = $n + tn(vn, Qn++), Fn += _n(vn, jt, Mn, Un, Zt);
    else if (vn === "object")
      throw jt = String(yt), Error("Objects are not valid as a React child (found: " + (jt === "[object Object]" ? "object with keys {" + Object.keys(yt).join(", ") + "}" : jt) + "). If you meant to render a collection of children, use an array instead.");
    return Fn;
  }
  function en(yt, jt, Mn) {
    if (yt == null)
      return yt;
    var $n = [], Zt = 0;
    return _n(yt, $n, "", "", function(vn) {
      return jt.call(Mn, vn, Zt++);
    }), $n;
  }
  function dn(yt) {
    if (yt._status === -1) {
      var jt = yt._result;
      jt = jt(), jt.then(function(Mn) {
        (yt._status === 0 || yt._status === -1) && (yt._status = 1, yt._result = Mn);
      }, function(Mn) {
        (yt._status === 0 || yt._status === -1) && (yt._status = 2, yt._result = Mn);
      }), yt._status === -1 && (yt._status = 0, yt._result = jt);
    }
    if (yt._status === 1)
      return yt._result.default;
    throw yt._result;
  }
  var Ht = { current: null }, hn = { transition: null }, kn = { ReactCurrentDispatcher: Ht, ReactCurrentBatchConfig: hn, ReactCurrentOwner: gt };
  function Dn() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return react_production_min.Children = { map: en, forEach: function(yt, jt, Mn) {
    en(yt, function() {
      jt.apply(this, arguments);
    }, Mn);
  }, count: function(yt) {
    var jt = 0;
    return en(yt, function() {
      jt++;
    }), jt;
  }, toArray: function(yt) {
    return en(yt, function(jt) {
      return jt;
    }) || [];
  }, only: function(yt) {
    if (!Ft(yt))
      throw Error("React.Children.only expected to receive a single React element child.");
    return yt;
  } }, react_production_min.Component = qe, react_production_min.Fragment = ae, react_production_min.Profiler = ye, react_production_min.PureComponent = ot, react_production_min.StrictMode = fe, react_production_min.Suspense = Oe, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kn, react_production_min.act = Dn, react_production_min.cloneElement = function(yt, jt, Mn) {
    if (yt == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + yt + ".");
    var $n = ze({}, yt.props), Zt = yt.key, vn = yt.ref, Fn = yt._owner;
    if (jt != null) {
      if (jt.ref !== void 0 && (vn = jt.ref, Fn = gt.current), jt.key !== void 0 && (Zt = "" + jt.key), yt.type && yt.type.defaultProps)
        var Qn = yt.type.defaultProps;
      for (Un in jt)
        ht.call(jt, Un) && !At.hasOwnProperty(Un) && ($n[Un] = jt[Un] === void 0 && Qn !== void 0 ? Qn[Un] : jt[Un]);
    }
    var Un = arguments.length - 2;
    if (Un === 1)
      $n.children = Mn;
    else if (1 < Un) {
      Qn = Array(Un);
      for (var ar = 0; ar < Un; ar++)
        Qn[ar] = arguments[ar + 2];
      $n.children = Qn;
    }
    return { $$typeof: ne, type: yt.type, key: Zt, ref: vn, props: $n, _owner: Fn };
  }, react_production_min.createContext = function(yt) {
    return yt = { $$typeof: _e, _currentValue: yt, _currentValue2: yt, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, yt.Provider = { $$typeof: we, _context: yt }, yt.Consumer = yt;
  }, react_production_min.createElement = St, react_production_min.createFactory = function(yt) {
    var jt = St.bind(null, yt);
    return jt.type = yt, jt;
  }, react_production_min.createRef = function() {
    return { current: null };
  }, react_production_min.forwardRef = function(yt) {
    return { $$typeof: xe, render: yt };
  }, react_production_min.isValidElement = Ft, react_production_min.lazy = function(yt) {
    return { $$typeof: Re, _payload: { _status: -1, _result: yt }, _init: dn };
  }, react_production_min.memo = function(yt, jt) {
    return { $$typeof: $e, type: yt, compare: jt === void 0 ? null : jt };
  }, react_production_min.startTransition = function(yt) {
    var jt = hn.transition;
    hn.transition = {};
    try {
      yt();
    } finally {
      hn.transition = jt;
    }
  }, react_production_min.unstable_act = Dn, react_production_min.useCallback = function(yt, jt) {
    return Ht.current.useCallback(yt, jt);
  }, react_production_min.useContext = function(yt) {
    return Ht.current.useContext(yt);
  }, react_production_min.useDebugValue = function() {
  }, react_production_min.useDeferredValue = function(yt) {
    return Ht.current.useDeferredValue(yt);
  }, react_production_min.useEffect = function(yt, jt) {
    return Ht.current.useEffect(yt, jt);
  }, react_production_min.useId = function() {
    return Ht.current.useId();
  }, react_production_min.useImperativeHandle = function(yt, jt, Mn) {
    return Ht.current.useImperativeHandle(yt, jt, Mn);
  }, react_production_min.useInsertionEffect = function(yt, jt) {
    return Ht.current.useInsertionEffect(yt, jt);
  }, react_production_min.useLayoutEffect = function(yt, jt) {
    return Ht.current.useLayoutEffect(yt, jt);
  }, react_production_min.useMemo = function(yt, jt) {
    return Ht.current.useMemo(yt, jt);
  }, react_production_min.useReducer = function(yt, jt, Mn) {
    return Ht.current.useReducer(yt, jt, Mn);
  }, react_production_min.useRef = function(yt) {
    return Ht.current.useRef(yt);
  }, react_production_min.useState = function(yt) {
    return Ht.current.useState(yt);
  }, react_production_min.useSyncExternalStore = function(yt, jt, Mn) {
    return Ht.current.useSyncExternalStore(yt, jt, Mn);
  }, react_production_min.useTransition = function() {
    return Ht.current.useTransition();
  }, react_production_min.version = "18.3.1", react_production_min;
}
var react_development = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  return hasRequiredReact_development || (hasRequiredReact_development = 1, function(ne, oe) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ae = "18.3.1", fe = Symbol.for("react.element"), ye = Symbol.for("react.portal"), we = Symbol.for("react.fragment"), _e = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), Oe = Symbol.for("react.provider"), $e = Symbol.for("react.context"), Re = Symbol.for("react.forward_ref"), Ne = Symbol.for("react.suspense"), je = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), qe = Symbol.iterator, Ye = "@@iterator";
      function ot(Ge) {
        if (Ge === null || typeof Ge != "object")
          return null;
        var dt = qe && Ge[qe] || Ge[Ye];
        return typeof dt == "function" ? dt : null;
      }
      var tt = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, it = {
        transition: null
      }, ht = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, gt = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, At = {}, St = null;
      function Nt(Ge) {
        St = Ge;
      }
      At.setExtraStackFrame = function(Ge) {
        St = Ge;
      }, At.getCurrentStack = null, At.getStackAddendum = function() {
        var Ge = "";
        St && (Ge += St);
        var dt = At.getCurrentStack;
        return dt && (Ge += dt() || ""), Ge;
      };
      var Ft = !1, Vt = !1, on = !1, tn = !1, _n = !1, en = {
        ReactCurrentDispatcher: tt,
        ReactCurrentBatchConfig: it,
        ReactCurrentOwner: gt
      };
      en.ReactDebugCurrentFrame = At, en.ReactCurrentActQueue = ht;
      function dn(Ge) {
        {
          for (var dt = arguments.length, Ot = new Array(dt > 1 ? dt - 1 : 0), $t = 1; $t < dt; $t++)
            Ot[$t - 1] = arguments[$t];
          hn("warn", Ge, Ot);
        }
      }
      function Ht(Ge) {
        {
          for (var dt = arguments.length, Ot = new Array(dt > 1 ? dt - 1 : 0), $t = 1; $t < dt; $t++)
            Ot[$t - 1] = arguments[$t];
          hn("error", Ge, Ot);
        }
      }
      function hn(Ge, dt, Ot) {
        {
          var $t = en.ReactDebugCurrentFrame, Xt = $t.getStackAddendum();
          Xt !== "" && (dt += "%s", Ot = Ot.concat([Xt]));
          var An = Ot.map(function(gn) {
            return String(gn);
          });
          An.unshift("Warning: " + dt), Function.prototype.apply.call(console[Ge], console, An);
        }
      }
      var kn = {};
      function Dn(Ge, dt) {
        {
          var Ot = Ge.constructor, $t = Ot && (Ot.displayName || Ot.name) || "ReactClass", Xt = $t + "." + dt;
          if (kn[Xt])
            return;
          Ht("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", dt, $t), kn[Xt] = !0;
        }
      }
      var yt = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(Ge) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(Ge, dt, Ot) {
          Dn(Ge, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(Ge, dt, Ot, $t) {
          Dn(Ge, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(Ge, dt, Ot, $t) {
          Dn(Ge, "setState");
        }
      }, jt = Object.assign, Mn = {};
      Object.freeze(Mn);
      function $n(Ge, dt, Ot) {
        this.props = Ge, this.context = dt, this.refs = Mn, this.updater = Ot || yt;
      }
      $n.prototype.isReactComponent = {}, $n.prototype.setState = function(Ge, dt) {
        if (typeof Ge != "object" && typeof Ge != "function" && Ge != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, Ge, dt, "setState");
      }, $n.prototype.forceUpdate = function(Ge) {
        this.updater.enqueueForceUpdate(this, Ge, "forceUpdate");
      };
      {
        var Zt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, vn = function(Ge, dt) {
          Object.defineProperty($n.prototype, Ge, {
            get: function() {
              dn("%s(...) is deprecated in plain JavaScript React classes. %s", dt[0], dt[1]);
            }
          });
        };
        for (var Fn in Zt)
          Zt.hasOwnProperty(Fn) && vn(Fn, Zt[Fn]);
      }
      function Qn() {
      }
      Qn.prototype = $n.prototype;
      function Un(Ge, dt, Ot) {
        this.props = Ge, this.context = dt, this.refs = Mn, this.updater = Ot || yt;
      }
      var ar = Un.prototype = new Qn();
      ar.constructor = Un, jt(ar, $n.prototype), ar.isPureReactComponent = !0;
      function Zo() {
        var Ge = {
          current: null
        };
        return Object.seal(Ge), Ge;
      }
      var ao = Array.isArray;
      function Yr(Ge) {
        return ao(Ge);
      }
      function so(Ge) {
        {
          var dt = typeof Symbol == "function" && Symbol.toStringTag, Ot = dt && Ge[Symbol.toStringTag] || Ge.constructor.name || "Object";
          return Ot;
        }
      }
      function Io(Ge) {
        try {
          return Po(Ge), !1;
        } catch {
          return !0;
        }
      }
      function Po(Ge) {
        return "" + Ge;
      }
      function vo(Ge) {
        if (Io(Ge))
          return Ht("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", so(Ge)), Po(Ge);
      }
      function na(Ge, dt, Ot) {
        var $t = Ge.displayName;
        if ($t)
          return $t;
        var Xt = dt.displayName || dt.name || "";
        return Xt !== "" ? Ot + "(" + Xt + ")" : Ot;
      }
      function va(Ge) {
        return Ge.displayName || "Context";
      }
      function go(Ge) {
        if (Ge == null)
          return null;
        if (typeof Ge.tag == "number" && Ht("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ge == "function")
          return Ge.displayName || Ge.name || null;
        if (typeof Ge == "string")
          return Ge;
        switch (Ge) {
          case we:
            return "Fragment";
          case ye:
            return "Portal";
          case xe:
            return "Profiler";
          case _e:
            return "StrictMode";
          case Ne:
            return "Suspense";
          case je:
            return "SuspenseList";
        }
        if (typeof Ge == "object")
          switch (Ge.$$typeof) {
            case $e:
              var dt = Ge;
              return va(dt) + ".Consumer";
            case Oe:
              var Ot = Ge;
              return va(Ot._context) + ".Provider";
            case Re:
              return na(Ge, Ge.render, "ForwardRef");
            case Be:
              var $t = Ge.displayName || null;
              return $t !== null ? $t : go(Ge.type) || "Memo";
            case ze: {
              var Xt = Ge, An = Xt._payload, gn = Xt._init;
              try {
                return go(gn(An));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Fo = Object.prototype.hasOwnProperty, Ro = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, la, Ia, Go;
      Go = {};
      function Yo(Ge) {
        if (Fo.call(Ge, "ref")) {
          var dt = Object.getOwnPropertyDescriptor(Ge, "ref").get;
          if (dt && dt.isReactWarning)
            return !1;
        }
        return Ge.ref !== void 0;
      }
      function Ra(Ge) {
        if (Fo.call(Ge, "key")) {
          var dt = Object.getOwnPropertyDescriptor(Ge, "key").get;
          if (dt && dt.isReactWarning)
            return !1;
        }
        return Ge.key !== void 0;
      }
      function Bo(Ge, dt) {
        var Ot = function() {
          la || (la = !0, Ht("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", dt));
        };
        Ot.isReactWarning = !0, Object.defineProperty(Ge, "key", {
          get: Ot,
          configurable: !0
        });
      }
      function Na(Ge, dt) {
        var Ot = function() {
          Ia || (Ia = !0, Ht("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", dt));
        };
        Ot.isReactWarning = !0, Object.defineProperty(Ge, "ref", {
          get: Ot,
          configurable: !0
        });
      }
      function Bt(Ge) {
        if (typeof Ge.ref == "string" && gt.current && Ge.__self && gt.current.stateNode !== Ge.__self) {
          var dt = go(gt.current.type);
          Go[dt] || (Ht('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', dt, Ge.ref), Go[dt] = !0);
        }
      }
      var Kt = function(Ge, dt, Ot, $t, Xt, An, gn) {
        var In = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: fe,
          // Built-in properties that belong on the element
          type: Ge,
          key: dt,
          ref: Ot,
          props: gn,
          // Record the component responsible for creating this element.
          _owner: An
        };
        return In._store = {}, Object.defineProperty(In._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(In, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: $t
        }), Object.defineProperty(In, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Xt
        }), Object.freeze && (Object.freeze(In.props), Object.freeze(In)), In;
      };
      function mn(Ge, dt, Ot) {
        var $t, Xt = {}, An = null, gn = null, In = null, Zn = null;
        if (dt != null) {
          Yo(dt) && (gn = dt.ref, Bt(dt)), Ra(dt) && (vo(dt.key), An = "" + dt.key), In = dt.__self === void 0 ? null : dt.__self, Zn = dt.__source === void 0 ? null : dt.__source;
          for ($t in dt)
            Fo.call(dt, $t) && !Ro.hasOwnProperty($t) && (Xt[$t] = dt[$t]);
        }
        var br = arguments.length - 2;
        if (br === 1)
          Xt.children = Ot;
        else if (br > 1) {
          for (var Er = Array(br), Cr = 0; Cr < br; Cr++)
            Er[Cr] = arguments[Cr + 2];
          Object.freeze && Object.freeze(Er), Xt.children = Er;
        }
        if (Ge && Ge.defaultProps) {
          var Ir = Ge.defaultProps;
          for ($t in Ir)
            Xt[$t] === void 0 && (Xt[$t] = Ir[$t]);
        }
        if (An || gn) {
          var Vr = typeof Ge == "function" ? Ge.displayName || Ge.name || "Unknown" : Ge;
          An && Bo(Xt, Vr), gn && Na(Xt, Vr);
        }
        return Kt(Ge, An, gn, In, Zn, gt.current, Xt);
      }
      function jn(Ge, dt) {
        var Ot = Kt(Ge.type, dt, Ge.ref, Ge._self, Ge._source, Ge._owner, Ge.props);
        return Ot;
      }
      function zn(Ge, dt, Ot) {
        if (Ge == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + Ge + ".");
        var $t, Xt = jt({}, Ge.props), An = Ge.key, gn = Ge.ref, In = Ge._self, Zn = Ge._source, br = Ge._owner;
        if (dt != null) {
          Yo(dt) && (gn = dt.ref, br = gt.current), Ra(dt) && (vo(dt.key), An = "" + dt.key);
          var Er;
          Ge.type && Ge.type.defaultProps && (Er = Ge.type.defaultProps);
          for ($t in dt)
            Fo.call(dt, $t) && !Ro.hasOwnProperty($t) && (dt[$t] === void 0 && Er !== void 0 ? Xt[$t] = Er[$t] : Xt[$t] = dt[$t]);
        }
        var Cr = arguments.length - 2;
        if (Cr === 1)
          Xt.children = Ot;
        else if (Cr > 1) {
          for (var Ir = Array(Cr), Vr = 0; Vr < Cr; Vr++)
            Ir[Vr] = arguments[Vr + 2];
          Xt.children = Ir;
        }
        return Kt(Ge.type, An, gn, In, Zn, br, Xt);
      }
      function qn(Ge) {
        return typeof Ge == "object" && Ge !== null && Ge.$$typeof === fe;
      }
      var rr = ".", or = ":";
      function Wn(Ge) {
        var dt = /[=:]/g, Ot = {
          "=": "=0",
          ":": "=2"
        }, $t = Ge.replace(dt, function(Xt) {
          return Ot[Xt];
        });
        return "$" + $t;
      }
      var Ar = !1, Br = /\/+/g;
      function wo(Ge) {
        return Ge.replace(Br, "$&/");
      }
      function wr(Ge, dt) {
        return typeof Ge == "object" && Ge !== null && Ge.key != null ? (vo(Ge.key), Wn("" + Ge.key)) : dt.toString(36);
      }
      function _r(Ge, dt, Ot, $t, Xt) {
        var An = typeof Ge;
        (An === "undefined" || An === "boolean") && (Ge = null);
        var gn = !1;
        if (Ge === null)
          gn = !0;
        else
          switch (An) {
            case "string":
            case "number":
              gn = !0;
              break;
            case "object":
              switch (Ge.$$typeof) {
                case fe:
                case ye:
                  gn = !0;
              }
          }
        if (gn) {
          var In = Ge, Zn = Xt(In), br = $t === "" ? rr + wr(In, 0) : $t;
          if (Yr(Zn)) {
            var Er = "";
            br != null && (Er = wo(br) + "/"), _r(Zn, dt, Er, "", function(uf) {
              return uf;
            });
          } else
            Zn != null && (qn(Zn) && (Zn.key && (!In || In.key !== Zn.key) && vo(Zn.key), Zn = jn(
              Zn,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              Ot + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Zn.key && (!In || In.key !== Zn.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                wo("" + Zn.key) + "/"
              ) : "") + br
            )), dt.push(Zn));
          return 1;
        }
        var Cr, Ir, Vr = 0, Kr = $t === "" ? rr : $t + or;
        if (Yr(Ge))
          for (var No = 0; No < Ge.length; No++)
            Cr = Ge[No], Ir = Kr + wr(Cr, No), Vr += _r(Cr, dt, Ot, Ir, Xt);
        else {
          var iu = ot(Ge);
          if (typeof iu == "function") {
            var pc = Ge;
            iu === pc.entries && (Ar || dn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ar = !0);
            for (var sf = iu.call(pc), od, su = 0; !(od = sf.next()).done; )
              Cr = od.value, Ir = Kr + wr(Cr, su++), Vr += _r(Cr, dt, Ot, Ir, Xt);
          } else if (An === "object") {
            var Pl = String(Ge);
            throw new Error("Objects are not valid as a React child (found: " + (Pl === "[object Object]" ? "object with keys {" + Object.keys(Ge).join(", ") + "}" : Pl) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Vr;
      }
      function To(Ge, dt, Ot) {
        if (Ge == null)
          return Ge;
        var $t = [], Xt = 0;
        return _r(Ge, $t, "", "", function(An) {
          return dt.call(Ot, An, Xt++);
        }), $t;
      }
      function Ha(Ge) {
        var dt = 0;
        return To(Ge, function() {
          dt++;
        }), dt;
      }
      function Bi(Ge, dt, Ot) {
        To(Ge, function() {
          dt.apply(this, arguments);
        }, Ot);
      }
      function Ui(Ge) {
        return To(Ge, function(dt) {
          return dt;
        }) || [];
      }
      function qa(Ge) {
        if (!qn(Ge))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return Ge;
      }
      function si(Ge) {
        var dt = {
          $$typeof: $e,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: Ge,
          _currentValue2: Ge,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        dt.Provider = {
          $$typeof: Oe,
          _context: dt
        };
        var Ot = !1, $t = !1, Xt = !1;
        {
          var An = {
            $$typeof: $e,
            _context: dt
          };
          Object.defineProperties(An, {
            Provider: {
              get: function() {
                return $t || ($t = !0, Ht("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), dt.Provider;
              },
              set: function(gn) {
                dt.Provider = gn;
              }
            },
            _currentValue: {
              get: function() {
                return dt._currentValue;
              },
              set: function(gn) {
                dt._currentValue = gn;
              }
            },
            _currentValue2: {
              get: function() {
                return dt._currentValue2;
              },
              set: function(gn) {
                dt._currentValue2 = gn;
              }
            },
            _threadCount: {
              get: function() {
                return dt._threadCount;
              },
              set: function(gn) {
                dt._threadCount = gn;
              }
            },
            Consumer: {
              get: function() {
                return Ot || (Ot = !0, Ht("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), dt.Consumer;
              }
            },
            displayName: {
              get: function() {
                return dt.displayName;
              },
              set: function(gn) {
                Xt || (dn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", gn), Xt = !0);
              }
            }
          }), dt.Consumer = An;
        }
        return dt._currentRenderer = null, dt._currentRenderer2 = null, dt;
      }
      var ra = -1, Ta = 0, ci = 1, wa = 2;
      function fo(Ge) {
        if (Ge._status === ra) {
          var dt = Ge._result, Ot = dt();
          if (Ot.then(function(An) {
            if (Ge._status === Ta || Ge._status === ra) {
              var gn = Ge;
              gn._status = ci, gn._result = An;
            }
          }, function(An) {
            if (Ge._status === Ta || Ge._status === ra) {
              var gn = Ge;
              gn._status = wa, gn._result = An;
            }
          }), Ge._status === ra) {
            var $t = Ge;
            $t._status = Ta, $t._result = Ot;
          }
        }
        if (Ge._status === ci) {
          var Xt = Ge._result;
          return Xt === void 0 && Ht(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Xt), "default" in Xt || Ht(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Xt), Xt.default;
        } else
          throw Ge._result;
      }
      function _o(Ge) {
        var dt = {
          // We use these fields to store the result.
          _status: ra,
          _result: Ge
        }, Ot = {
          $$typeof: ze,
          _payload: dt,
          _init: fo
        };
        {
          var $t, Xt;
          Object.defineProperties(Ot, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return $t;
              },
              set: function(An) {
                Ht("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), $t = An, Object.defineProperty(Ot, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Xt;
              },
              set: function(An) {
                Ht("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Xt = An, Object.defineProperty(Ot, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Ot;
      }
      function oa(Ge) {
        Ge != null && Ge.$$typeof === Be ? Ht("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof Ge != "function" ? Ht("forwardRef requires a render function but was given %s.", Ge === null ? "null" : typeof Ge) : Ge.length !== 0 && Ge.length !== 2 && Ht("forwardRef render functions accept exactly two parameters: props and ref. %s", Ge.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), Ge != null && (Ge.defaultProps != null || Ge.propTypes != null) && Ht("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var dt = {
          $$typeof: Re,
          render: Ge
        };
        {
          var Ot;
          Object.defineProperty(dt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ot;
            },
            set: function($t) {
              Ot = $t, !Ge.name && !Ge.displayName && (Ge.displayName = $t);
            }
          });
        }
        return dt;
      }
      var Ma;
      Ma = Symbol.for("react.module.reference");
      function Rt(Ge) {
        return !!(typeof Ge == "string" || typeof Ge == "function" || Ge === we || Ge === xe || _n || Ge === _e || Ge === Ne || Ge === je || tn || Ge === He || Ft || Vt || on || typeof Ge == "object" && Ge !== null && (Ge.$$typeof === ze || Ge.$$typeof === Be || Ge.$$typeof === Oe || Ge.$$typeof === $e || Ge.$$typeof === Re || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        Ge.$$typeof === Ma || Ge.getModuleId !== void 0));
      }
      function Cn(Ge, dt) {
        Rt(Ge) || Ht("memo: The first argument must be a component. Instead received: %s", Ge === null ? "null" : typeof Ge);
        var Ot = {
          $$typeof: Be,
          type: Ge,
          compare: dt === void 0 ? null : dt
        };
        {
          var $t;
          Object.defineProperty(Ot, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return $t;
            },
            set: function(Xt) {
              $t = Xt, !Ge.name && !Ge.displayName && (Ge.displayName = Xt);
            }
          });
        }
        return Ot;
      }
      function Pn() {
        var Ge = tt.current;
        return Ge === null && Ht(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), Ge;
      }
      function hr(Ge) {
        var dt = Pn();
        if (Ge._context !== void 0) {
          var Ot = Ge._context;
          Ot.Consumer === Ge ? Ht("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Ot.Provider === Ge && Ht("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dt.useContext(Ge);
      }
      function Dr(Ge) {
        var dt = Pn();
        return dt.useState(Ge);
      }
      function Jr(Ge, dt, Ot) {
        var $t = Pn();
        return $t.useReducer(Ge, dt, Ot);
      }
      function zr(Ge) {
        var dt = Pn();
        return dt.useRef(Ge);
      }
      function gr(Ge, dt) {
        var Ot = Pn();
        return Ot.useEffect(Ge, dt);
      }
      function aa(Ge, dt) {
        var Ot = Pn();
        return Ot.useInsertionEffect(Ge, dt);
      }
      function Oo(Ge, dt) {
        var Ot = Pn();
        return Ot.useLayoutEffect(Ge, dt);
      }
      function Ao(Ge, dt) {
        var Ot = Pn();
        return Ot.useCallback(Ge, dt);
      }
      function ka(Ge, dt) {
        var Ot = Pn();
        return Ot.useMemo(Ge, dt);
      }
      function ys(Ge, dt, Ot) {
        var $t = Pn();
        return $t.useImperativeHandle(Ge, dt, Ot);
      }
      function Qu(Ge, dt) {
        {
          var Ot = Pn();
          return Ot.useDebugValue(Ge, dt);
        }
      }
      function uo() {
        var Ge = Pn();
        return Ge.useTransition();
      }
      function nd(Ge) {
        var dt = Pn();
        return dt.useDeferredValue(Ge);
      }
      function Yi() {
        var Ge = Pn();
        return Ge.useId();
      }
      function Wr(Ge, dt, Ot) {
        var $t = Pn();
        return $t.useSyncExternalStore(Ge, dt, Ot);
      }
      var Ea = 0, Ku, Fu, Ms, Ka, Xu, ja, Ju;
      function el() {
      }
      el.__reactDisabledLog = !0;
      function rd() {
        {
          if (Ea === 0) {
            Ku = console.log, Fu = console.info, Ms = console.warn, Ka = console.error, Xu = console.group, ja = console.groupCollapsed, Ju = console.groupEnd;
            var Ge = {
              configurable: !0,
              enumerable: !0,
              value: el,
              writable: !0
            };
            Object.defineProperties(console, {
              info: Ge,
              log: Ge,
              warn: Ge,
              error: Ge,
              group: Ge,
              groupCollapsed: Ge,
              groupEnd: Ge
            });
          }
          Ea++;
        }
      }
      function tl() {
        {
          if (Ea--, Ea === 0) {
            var Ge = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: jt({}, Ge, {
                value: Ku
              }),
              info: jt({}, Ge, {
                value: Fu
              }),
              warn: jt({}, Ge, {
                value: Ms
              }),
              error: jt({}, Ge, {
                value: Ka
              }),
              group: jt({}, Ge, {
                value: Xu
              }),
              groupCollapsed: jt({}, Ge, {
                value: ja
              }),
              groupEnd: jt({}, Ge, {
                value: Ju
              })
            });
          }
          Ea < 0 && Ht("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Vi = en.ReactCurrentDispatcher, gi;
      function ca(Ge, dt, Ot) {
        {
          if (gi === void 0)
            try {
              throw Error();
            } catch (Xt) {
              var $t = Xt.stack.trim().match(/\n( *(at )?)/);
              gi = $t && $t[1] || "";
            }
          return `
` + gi + Ge;
        }
      }
      var js = !1, Hi;
      {
        var gl = typeof WeakMap == "function" ? WeakMap : Map;
        Hi = new gl();
      }
      function ru(Ge, dt) {
        if (!Ge || js)
          return "";
        {
          var Ot = Hi.get(Ge);
          if (Ot !== void 0)
            return Ot;
        }
        var $t;
        js = !0;
        var Xt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var An;
        An = Vi.current, Vi.current = null, rd();
        try {
          if (dt) {
            var gn = function() {
              throw Error();
            };
            if (Object.defineProperty(gn.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(gn, []);
              } catch (Kr) {
                $t = Kr;
              }
              Reflect.construct(Ge, [], gn);
            } else {
              try {
                gn.call();
              } catch (Kr) {
                $t = Kr;
              }
              Ge.call(gn.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Kr) {
              $t = Kr;
            }
            Ge();
          }
        } catch (Kr) {
          if (Kr && $t && typeof Kr.stack == "string") {
            for (var In = Kr.stack.split(`
`), Zn = $t.stack.split(`
`), br = In.length - 1, Er = Zn.length - 1; br >= 1 && Er >= 0 && In[br] !== Zn[Er]; )
              Er--;
            for (; br >= 1 && Er >= 0; br--, Er--)
              if (In[br] !== Zn[Er]) {
                if (br !== 1 || Er !== 1)
                  do
                    if (br--, Er--, Er < 0 || In[br] !== Zn[Er]) {
                      var Cr = `
` + In[br].replace(" at new ", " at ");
                      return Ge.displayName && Cr.includes("<anonymous>") && (Cr = Cr.replace("<anonymous>", Ge.displayName)), typeof Ge == "function" && Hi.set(Ge, Cr), Cr;
                    }
                  while (br >= 1 && Er >= 0);
                break;
              }
          }
        } finally {
          js = !1, Vi.current = An, tl(), Error.prepareStackTrace = Xt;
        }
        var Ir = Ge ? Ge.displayName || Ge.name : "", Vr = Ir ? ca(Ir) : "";
        return typeof Ge == "function" && Hi.set(Ge, Vr), Vr;
      }
      function wl(Ge, dt, Ot) {
        return ru(Ge, !1);
      }
      function Ds(Ge) {
        var dt = Ge.prototype;
        return !!(dt && dt.isReactComponent);
      }
      function Ls(Ge, dt, Ot) {
        if (Ge == null)
          return "";
        if (typeof Ge == "function")
          return ru(Ge, Ds(Ge));
        if (typeof Ge == "string")
          return ca(Ge);
        switch (Ge) {
          case Ne:
            return ca("Suspense");
          case je:
            return ca("SuspenseList");
        }
        if (typeof Ge == "object")
          switch (Ge.$$typeof) {
            case Re:
              return wl(Ge.render);
            case Be:
              return Ls(Ge.type, dt, Ot);
            case ze: {
              var $t = Ge, Xt = $t._payload, An = $t._init;
              try {
                return Ls(An(Xt), dt, Ot);
              } catch {
              }
            }
          }
        return "";
      }
      var Fs = {}, po = en.ReactDebugCurrentFrame;
      function ts(Ge) {
        if (Ge) {
          var dt = Ge._owner, Ot = Ls(Ge.type, Ge._source, dt ? dt.type : null);
          po.setExtraStackFrame(Ot);
        } else
          po.setExtraStackFrame(null);
      }
      function fc(Ge, dt, Ot, $t, Xt) {
        {
          var An = Function.call.bind(Fo);
          for (var gn in Ge)
            if (An(Ge, gn)) {
              var In = void 0;
              try {
                if (typeof Ge[gn] != "function") {
                  var Zn = Error(($t || "React class") + ": " + Ot + " type `" + gn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ge[gn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Zn.name = "Invariant Violation", Zn;
                }
                In = Ge[gn](dt, gn, $t, Ot, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (br) {
                In = br;
              }
              In && !(In instanceof Error) && (ts(Xt), Ht("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $t || "React class", Ot, gn, typeof In), ts(null)), In instanceof Error && !(In.message in Fs) && (Fs[In.message] = !0, ts(Xt), Ht("Failed %s type: %s", Ot, In.message), ts(null));
            }
        }
      }
      function Da(Ge) {
        if (Ge) {
          var dt = Ge._owner, Ot = Ls(Ge.type, Ge._source, dt ? dt.type : null);
          Nt(Ot);
        } else
          Nt(null);
      }
      var ho;
      ho = !1;
      function nl() {
        if (gt.current) {
          var Ge = go(gt.current.type);
          if (Ge)
            return `

Check the render method of \`` + Ge + "`.";
        }
        return "";
      }
      function _l(Ge) {
        if (Ge !== void 0) {
          var dt = Ge.fileName.replace(/^.*[\\\/]/, ""), Ot = Ge.lineNumber;
          return `

Check your code at ` + dt + ":" + Ot + ".";
        }
        return "";
      }
      function Mr(Ge) {
        return Ge != null ? _l(Ge.__source) : "";
      }
      var Bs = {};
      function Wo(Ge) {
        var dt = nl();
        if (!dt) {
          var Ot = typeof Ge == "string" ? Ge : Ge.displayName || Ge.name;
          Ot && (dt = `

Check the top-level render call using <` + Ot + ">.");
        }
        return dt;
      }
      function La(Ge, dt) {
        if (!(!Ge._store || Ge._store.validated || Ge.key != null)) {
          Ge._store.validated = !0;
          var Ot = Wo(dt);
          if (!Bs[Ot]) {
            Bs[Ot] = !0;
            var $t = "";
            Ge && Ge._owner && Ge._owner !== gt.current && ($t = " It was passed a child from " + go(Ge._owner.type) + "."), Da(Ge), Ht('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ot, $t), Da(null);
          }
        }
      }
      function Fa(Ge, dt) {
        if (typeof Ge == "object") {
          if (Yr(Ge))
            for (var Ot = 0; Ot < Ge.length; Ot++) {
              var $t = Ge[Ot];
              qn($t) && La($t, dt);
            }
          else if (qn(Ge))
            Ge._store && (Ge._store.validated = !0);
          else if (Ge) {
            var Xt = ot(Ge);
            if (typeof Xt == "function" && Xt !== Ge.entries)
              for (var An = Xt.call(Ge), gn; !(gn = An.next()).done; )
                qn(gn.value) && La(gn.value, dt);
          }
        }
      }
      function zs(Ge) {
        {
          var dt = Ge.type;
          if (dt == null || typeof dt == "string")
            return;
          var Ot;
          if (typeof dt == "function")
            Ot = dt.propTypes;
          else if (typeof dt == "object" && (dt.$$typeof === Re || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          dt.$$typeof === Be))
            Ot = dt.propTypes;
          else
            return;
          if (Ot) {
            var $t = go(dt);
            fc(Ot, Ge.props, "prop", $t, Ge);
          } else if (dt.PropTypes !== void 0 && !ho) {
            ho = !0;
            var Xt = go(dt);
            Ht("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Xt || "Unknown");
          }
          typeof dt.getDefaultProps == "function" && !dt.getDefaultProps.isReactClassApproved && Ht("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Qo(Ge) {
        {
          for (var dt = Object.keys(Ge.props), Ot = 0; Ot < dt.length; Ot++) {
            var $t = dt[Ot];
            if ($t !== "children" && $t !== "key") {
              Da(Ge), Ht("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $t), Da(null);
              break;
            }
          }
          Ge.ref !== null && (Da(Ge), Ht("Invalid attribute `ref` supplied to `React.Fragment`."), Da(null));
        }
      }
      function mo(Ge, dt, Ot) {
        var $t = Rt(Ge);
        if (!$t) {
          var Xt = "";
          (Ge === void 0 || typeof Ge == "object" && Ge !== null && Object.keys(Ge).length === 0) && (Xt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var An = Mr(dt);
          An ? Xt += An : Xt += nl();
          var gn;
          Ge === null ? gn = "null" : Yr(Ge) ? gn = "array" : Ge !== void 0 && Ge.$$typeof === fe ? (gn = "<" + (go(Ge.type) || "Unknown") + " />", Xt = " Did you accidentally export a JSX literal instead of a component?") : gn = typeof Ge, Ht("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", gn, Xt);
        }
        var In = mn.apply(this, arguments);
        if (In == null)
          return In;
        if ($t)
          for (var Zn = 2; Zn < arguments.length; Zn++)
            Fa(arguments[Zn], Ge);
        return Ge === we ? Qo(In) : zs(In), In;
      }
      var El = !1;
      function wi(Ge) {
        var dt = mo.bind(null, Ge);
        return dt.type = Ge, El || (El = !0, dn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(dt, "type", {
          enumerable: !1,
          get: function() {
            return dn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: Ge
            }), Ge;
          }
        }), dt;
      }
      function xa(Ge, dt, Ot) {
        for (var $t = zn.apply(this, arguments), Xt = 2; Xt < arguments.length; Xt++)
          Fa(arguments[Xt], $t.type);
        return zs($t), $t;
      }
      function bs(Ge, dt) {
        var Ot = it.transition;
        it.transition = {};
        var $t = it.transition;
        it.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          Ge();
        } finally {
          if (it.transition = Ot, Ot === null && $t._updatedFibers) {
            var Xt = $t._updatedFibers.size;
            Xt > 10 && dn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), $t._updatedFibers.clear();
          }
        }
      }
      var rl = !1, di = null;
      function xl(Ge) {
        if (di === null)
          try {
            var dt = ("require" + Math.random()).slice(0, 7), Ot = ne && ne[dt];
            di = Ot.call(ne, "timers").setImmediate;
          } catch {
            di = function(Xt) {
              rl === !1 && (rl = !0, typeof MessageChannel > "u" && Ht("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var An = new MessageChannel();
              An.port1.onmessage = Xt, An.port2.postMessage(void 0);
            };
          }
        return di(Ge);
      }
      var fi = 0, Us = !1;
      function ou(Ge) {
        {
          var dt = fi;
          fi++, ht.current === null && (ht.current = []);
          var Ot = ht.isBatchingLegacy, $t;
          try {
            if (ht.isBatchingLegacy = !0, $t = Ge(), !Ot && ht.didScheduleLegacyUpdate) {
              var Xt = ht.current;
              Xt !== null && (ht.didScheduleLegacyUpdate = !1, vs(Xt));
            }
          } catch (Ir) {
            throw pi(dt), Ir;
          } finally {
            ht.isBatchingLegacy = Ot;
          }
          if ($t !== null && typeof $t == "object" && typeof $t.then == "function") {
            var An = $t, gn = !1, In = {
              then: function(Ir, Vr) {
                gn = !0, An.then(function(Kr) {
                  pi(dt), fi === 0 ? Ei(Kr, Ir, Vr) : Ir(Kr);
                }, function(Kr) {
                  pi(dt), Vr(Kr);
                });
              }
            };
            return !Us && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              gn || (Us = !0, Ht("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), In;
          } else {
            var Zn = $t;
            if (pi(dt), fi === 0) {
              var br = ht.current;
              br !== null && (vs(br), ht.current = null);
              var Er = {
                then: function(Ir, Vr) {
                  ht.current === null ? (ht.current = [], Ei(Zn, Ir, Vr)) : Ir(Zn);
                }
              };
              return Er;
            } else {
              var Cr = {
                then: function(Ir, Vr) {
                  Ir(Zn);
                }
              };
              return Cr;
            }
          }
        }
      }
      function pi(Ge) {
        Ge !== fi - 1 && Ht("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), fi = Ge;
      }
      function Ei(Ge, dt, Ot) {
        {
          var $t = ht.current;
          if ($t !== null)
            try {
              vs($t), xl(function() {
                $t.length === 0 ? (ht.current = null, dt(Ge)) : Ei(Ge, dt, Ot);
              });
            } catch (Xt) {
              Ot(Xt);
            }
          else
            dt(Ge);
        }
      }
      var au = !1;
      function vs(Ge) {
        if (!au) {
          au = !0;
          var dt = 0;
          try {
            for (; dt < Ge.length; dt++) {
              var Ot = Ge[dt];
              do
                Ot = Ot(!0);
              while (Ot !== null);
            }
            Ge.length = 0;
          } catch ($t) {
            throw Ge = Ge.slice(dt + 1), $t;
          } finally {
            au = !1;
          }
        }
      }
      var ol = mo, Bu = xa, al = wi, Sl = {
        map: To,
        forEach: Bi,
        count: Ha,
        toArray: Ui,
        only: qa
      };
      oe.Children = Sl, oe.Component = $n, oe.Fragment = we, oe.Profiler = xe, oe.PureComponent = Un, oe.StrictMode = _e, oe.Suspense = Ne, oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = en, oe.act = ou, oe.cloneElement = Bu, oe.createContext = si, oe.createElement = ol, oe.createFactory = al, oe.createRef = Zo, oe.forwardRef = oa, oe.isValidElement = qn, oe.lazy = _o, oe.memo = Cn, oe.startTransition = bs, oe.unstable_act = ou, oe.useCallback = Ao, oe.useContext = hr, oe.useDebugValue = Qu, oe.useDeferredValue = nd, oe.useEffect = gr, oe.useId = Yi, oe.useImperativeHandle = ys, oe.useInsertionEffect = aa, oe.useLayoutEffect = Oo, oe.useMemo = ka, oe.useReducer = Jr, oe.useRef = zr, oe.useState = Dr, oe.useSyncExternalStore = Wr, oe.useTransition = uo, oe.version = ae, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(react_development, react_development.exports)), react_development.exports;
}
process.env.NODE_ENV === "production" ? react.exports = requireReact_production_min() : react.exports = requireReact_development();
var reactExports = react.exports;
const ReactExports = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production_min;
function requireUseSyncExternalStoreShim_production_min() {
  if (hasRequiredUseSyncExternalStoreShim_production_min)
    return useSyncExternalStoreShim_production_min;
  hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var ne = reactExports;
  function oe(Ne, je) {
    return Ne === je && (Ne !== 0 || 1 / Ne === 1 / je) || Ne !== Ne && je !== je;
  }
  var ae = typeof Object.is == "function" ? Object.is : oe, fe = ne.useState, ye = ne.useEffect, we = ne.useLayoutEffect, _e = ne.useDebugValue;
  function xe(Ne, je) {
    var Be = je(), ze = fe({ inst: { value: Be, getSnapshot: je } }), He = ze[0].inst, qe = ze[1];
    return we(function() {
      He.value = Be, He.getSnapshot = je, Oe(He) && qe({ inst: He });
    }, [Ne, Be, je]), ye(function() {
      return Oe(He) && qe({ inst: He }), Ne(function() {
        Oe(He) && qe({ inst: He });
      });
    }, [Ne]), _e(Be), Be;
  }
  function Oe(Ne) {
    var je = Ne.getSnapshot;
    Ne = Ne.value;
    try {
      var Be = je();
      return !ae(Ne, Be);
    } catch {
      return !0;
    }
  }
  function $e(Ne, je) {
    return je();
  }
  var Re = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? $e : xe;
  return useSyncExternalStoreShim_production_min.useSyncExternalStore = ne.useSyncExternalStore !== void 0 ? ne.useSyncExternalStore : Re, useSyncExternalStoreShim_production_min;
}
var useSyncExternalStoreShim_development = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  return hasRequiredUseSyncExternalStoreShim_development || (hasRequiredUseSyncExternalStoreShim_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ne = reactExports, oe = ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ae(tt) {
      {
        for (var it = arguments.length, ht = new Array(it > 1 ? it - 1 : 0), gt = 1; gt < it; gt++)
          ht[gt - 1] = arguments[gt];
        fe("error", tt, ht);
      }
    }
    function fe(tt, it, ht) {
      {
        var gt = oe.ReactDebugCurrentFrame, At = gt.getStackAddendum();
        At !== "" && (it += "%s", ht = ht.concat([At]));
        var St = ht.map(function(Nt) {
          return String(Nt);
        });
        St.unshift("Warning: " + it), Function.prototype.apply.call(console[tt], console, St);
      }
    }
    function ye(tt, it) {
      return tt === it && (tt !== 0 || 1 / tt === 1 / it) || tt !== tt && it !== it;
    }
    var we = typeof Object.is == "function" ? Object.is : ye, _e = ne.useState, xe = ne.useEffect, Oe = ne.useLayoutEffect, $e = ne.useDebugValue, Re = !1, Ne = !1;
    function je(tt, it, ht) {
      Re || ne.startTransition !== void 0 && (Re = !0, ae("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var gt = it();
      if (!Ne) {
        var At = it();
        we(gt, At) || (ae("The result of getSnapshot should be cached to avoid an infinite loop"), Ne = !0);
      }
      var St = _e({
        inst: {
          value: gt,
          getSnapshot: it
        }
      }), Nt = St[0].inst, Ft = St[1];
      return Oe(function() {
        Nt.value = gt, Nt.getSnapshot = it, Be(Nt) && Ft({
          inst: Nt
        });
      }, [tt, gt, it]), xe(function() {
        Be(Nt) && Ft({
          inst: Nt
        });
        var Vt = function() {
          Be(Nt) && Ft({
            inst: Nt
          });
        };
        return tt(Vt);
      }, [tt]), $e(gt), gt;
    }
    function Be(tt) {
      var it = tt.getSnapshot, ht = tt.value;
      try {
        var gt = it();
        return !we(ht, gt);
      } catch {
        return !0;
      }
    }
    function ze(tt, it, ht) {
      return it();
    }
    var He = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", qe = !He, Ye = qe ? ze : je, ot = ne.useSyncExternalStore !== void 0 ? ne.useSyncExternalStore : Ye;
    useSyncExternalStoreShim_development.useSyncExternalStore = ot, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), useSyncExternalStoreShim_development;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, process.env.NODE_ENV === "production" ? shim.exports = requireUseSyncExternalStoreShim_production_min() : shim.exports = requireUseSyncExternalStoreShim_development()), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production_min;
function requireWithSelector_production_min() {
  if (hasRequiredWithSelector_production_min)
    return withSelector_production_min;
  hasRequiredWithSelector_production_min = 1;
  var ne = reactExports, oe = requireShim();
  function ae($e, Re) {
    return $e === Re && ($e !== 0 || 1 / $e === 1 / Re) || $e !== $e && Re !== Re;
  }
  var fe = typeof Object.is == "function" ? Object.is : ae, ye = oe.useSyncExternalStore, we = ne.useRef, _e = ne.useEffect, xe = ne.useMemo, Oe = ne.useDebugValue;
  return withSelector_production_min.useSyncExternalStoreWithSelector = function($e, Re, Ne, je, Be) {
    var ze = we(null);
    if (ze.current === null) {
      var He = { hasValue: !1, value: null };
      ze.current = He;
    } else
      He = ze.current;
    ze = xe(function() {
      function Ye(gt) {
        if (!ot) {
          if (ot = !0, tt = gt, gt = je(gt), Be !== void 0 && He.hasValue) {
            var At = He.value;
            if (Be(At, gt))
              return it = At;
          }
          return it = gt;
        }
        if (At = it, fe(tt, gt))
          return At;
        var St = je(gt);
        return Be !== void 0 && Be(At, St) ? At : (tt = gt, it = St);
      }
      var ot = !1, tt, it, ht = Ne === void 0 ? null : Ne;
      return [function() {
        return Ye(Re());
      }, ht === null ? void 0 : function() {
        return Ye(ht());
      }];
    }, [Re, Ne, je, Be]);
    var qe = ye($e, ze[0], ze[1]);
    return _e(function() {
      He.hasValue = !0, He.value = qe;
    }, [qe]), Oe(qe), qe;
  }, withSelector_production_min;
}
var withSelector_development = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  return hasRequiredWithSelector_development || (hasRequiredWithSelector_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ne = reactExports, oe = requireShim();
    function ae(Re, Ne) {
      return Re === Ne && (Re !== 0 || 1 / Re === 1 / Ne) || Re !== Re && Ne !== Ne;
    }
    var fe = typeof Object.is == "function" ? Object.is : ae, ye = oe.useSyncExternalStore, we = ne.useRef, _e = ne.useEffect, xe = ne.useMemo, Oe = ne.useDebugValue;
    function $e(Re, Ne, je, Be, ze) {
      var He = we(null), qe;
      He.current === null ? (qe = {
        hasValue: !1,
        value: null
      }, He.current = qe) : qe = He.current;
      var Ye = xe(function() {
        var ht = !1, gt, At, St = function(on) {
          if (!ht) {
            ht = !0, gt = on;
            var tn = Be(on);
            if (ze !== void 0 && qe.hasValue) {
              var _n = qe.value;
              if (ze(_n, tn))
                return At = _n, _n;
            }
            return At = tn, tn;
          }
          var en = gt, dn = At;
          if (fe(en, on))
            return dn;
          var Ht = Be(on);
          return ze !== void 0 && ze(dn, Ht) ? dn : (gt = on, At = Ht, Ht);
        }, Nt = je === void 0 ? null : je, Ft = function() {
          return St(Ne());
        }, Vt = Nt === null ? void 0 : function() {
          return St(Nt());
        };
        return [Ft, Vt];
      }, [Ne, je, Be, ze]), ot = Ye[0], tt = Ye[1], it = ye(Re, ot, tt);
      return _e(function() {
        qe.hasValue = !0, qe.value = it;
      }, [it]), Oe(it), it;
    }
    withSelector_development.useSyncExternalStoreWithSelector = $e, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), withSelector_development;
}
process.env.NODE_ENV === "production" ? withSelector.exports = requireWithSelector_production_min() : withSelector.exports = requireWithSelector_development();
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), { useDebugValue } = ReactExports, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = !1;
const identity = (ne) => ne;
function useStore(ne, oe = identity, ae) {
  const fe = useSyncExternalStoreWithSelector(
    ne.subscribe,
    ne.getState,
    ne.getServerState || ne.getInitialState,
    oe,
    ae
  );
  return useDebugValue(fe), fe;
}
const createImpl = (ne) => {
  const oe = typeof ne == "function" ? createStore(ne) : ne, ae = (fe, ye) => useStore(oe, fe, ye);
  return Object.assign(ae, oe), ae;
}, create = (ne) => ne ? createImpl(ne) : createImpl;
var i = S.extend("zustand"), D = S.extend("zustand");
i.log = console.debug.bind(console);
D.log = console.error.bind(console);
function g({ tableId: ne, keyTuple: oe }) {
  return `${ne}:${concatHex$1(oe)}`;
}
function I({ store: ne }) {
  return async function({ logs: oe }) {
    let ae = /* @__PURE__ */ new Map(), fe = { ...ne.getState().rawRecords };
    for (let Oe of oe) {
      let $e = ne.getState().tables[Oe.args.tableId];
      if (!$e) {
        let { namespace: Ne, name: je } = _$4(Oe.args.tableId);
        i(`skipping update for unknown table: ${i$6({ namespace: Ne, name: je })} (${Oe.args.tableId}) at ${Oe.address}`);
        continue;
      }
      let Re = g(Oe.args);
      if (Oe.eventName === "Store_SetRecord")
        i("setting record", { namespace: $e.namespace, name: $e.name, id: Re, log: Oe }), fe[Re] = { id: Re, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: Oe.args.staticData, encodedLengths: Oe.args.encodedLengths, dynamicData: Oe.args.dynamicData }, ae.set(Re, !1);
      else if (Oe.eventName === "Store_SpliceStaticData") {
        i("splicing static data", { namespace: $e.namespace, name: $e.name, id: Re, log: Oe });
        let Ne = fe[Re] ?? { id: Re, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: "0x", encodedLengths: "0x", dynamicData: "0x" }, je = Pe(Ne.staticData, Oe.args.start, size$2(Oe.args.data), Oe.args.data);
        fe[Re] = { ...Ne, staticData: je }, ae.set(Re, !1);
      } else if (Oe.eventName === "Store_SpliceDynamicData") {
        i("splicing dynamic data", { namespace: $e.namespace, name: $e.name, id: Re, log: Oe });
        let Ne = fe[Re] ?? { id: Re, tableId: Oe.args.tableId, keyTuple: Oe.args.keyTuple, staticData: "0x", encodedLengths: "0x", dynamicData: "0x" }, je = Oe.args.encodedLengths, Be = Pe(Ne.dynamicData, Oe.args.start, Oe.args.deleteCount, Oe.args.data);
        fe[Re] = { ...Ne, encodedLengths: je, dynamicData: Be }, ae.set(Re, !1);
      } else
        Oe.eventName === "Store_DeleteRecord" && (i("deleting record", { namespace: $e.namespace, name: $e.name, id: Re, log: Oe }), delete fe[Re], ae.set(Re, !0));
    }
    if (!ae.size)
      return;
    let ye = Array.from(ae.keys()).filter((Oe) => ae.get(Oe) === !1), we = Array.from(ae.keys()).filter((Oe) => ae.get(Oe) === !0), _e = ne.getState().records, xe = { ...Object.fromEntries(Object.entries(_e).filter(([Oe]) => !we.includes(Oe))), ...Object.fromEntries(ye.map((Oe) => {
      let $e = fe[Oe];
      if (!$e) {
        console.warn("no raw record found for updated ID", Oe);
        return;
      }
      let Re = ne.getState().tables[$e.tableId];
      if (!Re) {
        console.warn("no table found for record", $e);
        return;
      }
      let Ne = lt$1(ia(Xi$1(Re)), $e.keyTuple), je = zt$1(ia(Zi(Re)), $e);
      return [Oe, { id: Oe, table: ne.getState().tables[$e.tableId], keyTuple: $e.keyTuple, key: Ne, value: je, fields: { ...Ne, ...je } }];
    }).filter(b$7)) };
    ne.setState({ rawRecords: fe, records: xe });
  };
}
function k(ne) {
  return create((oe, ae) => ({ syncProgress: { step: "initialize", message: "Connecting", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n }, tables: Object.fromEntries(Object.entries(ne.tables).map(([, fe]) => [fe.tableId, fe])), rawRecords: {}, records: {}, getRecords: (fe) => {
    let ye = ae().records;
    return Object.fromEntries(Object.entries(ye).filter(([we, _e]) => _e.table.tableId === fe.tableId));
  }, getRecord: (fe, ye) => {
    let we = Yt(ia(Xi$1(fe)), ye), _e = g({ tableId: fe.tableId, keyTuple: we });
    return ae().records[_e];
  }, getValue: (fe, ye) => {
    var we;
    return (we = ae().getRecord(fe, ye)) == null ? void 0 : we.value;
  } }));
}
async function ge({ config: ne, tables: oe = {}, store: ae, startSync: fe = !0, ...ye }) {
  let we = { ...O(ne), ...oe, ...A$3 }, _e = ae ?? k({ tables: we }), xe = I({ store: _e }), Oe = await Et({ storageAdapter: xe, ...ye, onProgress: (Re) => {
    _e.getState().syncProgress.step !== "live" && _e.setState(() => ({ syncProgress: Re }));
  } }), $e = fe ? Oe.storedBlockLogs$.subscribe() : null;
  return { ...Oe, tables: we, useStore: _e, stopSync: () => {
    $e == null || $e.unsubscribe();
  } };
}
async function setupNetwork() {
  const ne = await getNetworkConfig();
  console.log("chain", ne.chain);
  const oe = {
    chain: ne.chain,
    transport: Ee(fallback([webSocket(), http()])),
    pollingInterval: 1e3
  };
  console.log("clientOptions", oe);
  const ae = createPublicClient(oe);
  console.log("publicClient", ae);
  const fe = new Subject(), ye = Q$4(ne.privateKey), we = createWalletClient({
    ...oe,
    account: ye
  }).extend(p()).extend(h({ onWrite: (He) => fe.next(He) }));
  console.log("burnerAccount", ye), console.log("burnerWalletClient", we);
  const _e = getContract({
    address: ne.worldAddress,
    abi: IWorldAbi,
    client: { public: ae, wallet: we }
  });
  console.log("worldContract", _e);
  const xe = getContract({
    address: "0x6f780376B0b9C47b45fae617d74c5a0359cbBA11",
    abi: IERC20Abi,
    client: { public: ae, wallet: we }
  }), Oe = getContract({
    address: "0x6f780376B0b9C47b45fae617d74c5a0359cbBA11",
    abi: IERC20Abi,
    client: { public: ae, wallet: we }
  }), $e = getContract({
    address: "0x6f780376B0b9C47b45fae617d74c5a0359cbBA11",
    abi: IERC20Abi,
    client: { public: ae, wallet: we }
  }), { components: Re, latestBlock$: Ne, storedBlockLogs$: je, waitForTransaction: Be } = await Ke({
    world,
    config: mudConfig,
    address: ne.worldAddress,
    publicClient: ae,
    startBlock: BigInt(ne.initialBlockNumber)
  }), { useStore: ze } = await ge({
    world,
    config: mudConfig,
    address: ne.worldAddress,
    publicClient: ae,
    startBlock: BigInt(ne.initialBlockNumber)
  });
  if (ne.faucetServiceUrl) {
    const He = ye.address;
    console.info("[Dev Faucet]: Player address -> ", He);
    const qe = createFaucetService(ne.faucetServiceUrl), Ye = async () => {
      const ot = await ae.getBalance({ address: He });
      console.info(`[Dev Faucet]: Player balance -> ${ot}`), ot < parseEther("1") && (console.info("[Dev Faucet]: Balance is low, dripping funds to player"), await qe.dripDev({ address: He }), await qe.dripDev({ address: He }));
    };
    Ye(), setInterval(Ye, 2e4);
  }
  return console.log("components", Re), console.log("useStore", ze), {
    world,
    components: Re,
    playerEntity: M$1({ address: "address" }, { address: we.account.address }),
    publicClient: ae,
    walletClient: we,
    latestBlock$: Ne,
    storedBlockLogs$: je,
    waitForTransaction: Be,
    worldContract: _e,
    write$: fe.asObservable().pipe(share()),
    useStore: ze,
    tokenAContract: xe,
    tokenBContract: Oe,
    tokenCContract: $e
    // tables
  };
}
async function setup() {
  const ne = await setupNetwork(), oe = createClientComponents(ne), ae = createSystemCalls(ne);
  return {
    network: ne,
    components: oe,
    systemCalls: ae
  };
}
var pX = Object.create, AR = Object.defineProperty, vX = Object.getOwnPropertyDescriptor, mX = Object.getOwnPropertyNames, hX = Object.getPrototypeOf, yX = Object.prototype.hasOwnProperty, Y = (ne, oe) => () => (ne && (oe = ne(ne = 0)), oe), M = (ne, oe) => () => (oe || ne((oe = { exports: {} }).exports, oe), oe.exports), Uj = (ne, oe) => {
  for (var ae in oe)
    AR(ne, ae, { get: oe[ae], enumerable: !0 });
}, gX = (ne, oe, ae, fe) => {
  if (oe && typeof oe == "object" || typeof oe == "function")
    for (let ye of mX(oe))
      !yX.call(ne, ye) && ye !== ae && AR(ne, ye, { get: () => oe[ye], enumerable: !(fe = vX(oe, ye)) || fe.enumerable });
  return ne;
}, le = (ne, oe, ae) => (ae = ne != null ? pX(hX(ne)) : {}, gX(oe || !ne || !ne.__esModule ? AR(ae, "default", { value: ne, enumerable: !0 }) : ae, ne)), Gj = M((ne) => {
  var oe = Symbol.for("react.element"), ae = Symbol.for("react.portal"), fe = Symbol.for("react.fragment"), ye = Symbol.for("react.strict_mode"), we = Symbol.for("react.profiler"), _e = Symbol.for("react.provider"), xe = Symbol.for("react.context"), Oe = Symbol.for("react.forward_ref"), $e = Symbol.for("react.suspense"), Re = Symbol.for("react.memo"), Ne = Symbol.for("react.lazy"), je = Symbol.iterator;
  function Be(yt) {
    return yt === null || typeof yt != "object" ? null : (yt = je && yt[je] || yt["@@iterator"], typeof yt == "function" ? yt : null);
  }
  var ze = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, He = Object.assign, qe = {};
  function Ye(yt, jt, Mn) {
    this.props = yt, this.context = jt, this.refs = qe, this.updater = Mn || ze;
  }
  Ye.prototype.isReactComponent = {}, Ye.prototype.setState = function(yt, jt) {
    if (typeof yt != "object" && typeof yt != "function" && yt != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, yt, jt, "setState");
  }, Ye.prototype.forceUpdate = function(yt) {
    this.updater.enqueueForceUpdate(this, yt, "forceUpdate");
  };
  function ot() {
  }
  ot.prototype = Ye.prototype;
  function tt(yt, jt, Mn) {
    this.props = yt, this.context = jt, this.refs = qe, this.updater = Mn || ze;
  }
  var it = tt.prototype = new ot();
  it.constructor = tt, He(it, Ye.prototype), it.isPureReactComponent = !0;
  var ht = Array.isArray, gt = Object.prototype.hasOwnProperty, At = { current: null }, St = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Nt(yt, jt, Mn) {
    var $n, Zt = {}, vn = null, Fn = null;
    if (jt != null)
      for ($n in jt.ref !== void 0 && (Fn = jt.ref), jt.key !== void 0 && (vn = "" + jt.key), jt)
        gt.call(jt, $n) && !St.hasOwnProperty($n) && (Zt[$n] = jt[$n]);
    var Qn = arguments.length - 2;
    if (Qn === 1)
      Zt.children = Mn;
    else if (1 < Qn) {
      for (var Un = Array(Qn), ar = 0; ar < Qn; ar++)
        Un[ar] = arguments[ar + 2];
      Zt.children = Un;
    }
    if (yt && yt.defaultProps)
      for ($n in Qn = yt.defaultProps, Qn)
        Zt[$n] === void 0 && (Zt[$n] = Qn[$n]);
    return { $$typeof: oe, type: yt, key: vn, ref: Fn, props: Zt, _owner: At.current };
  }
  function Ft(yt, jt) {
    return { $$typeof: oe, type: yt.type, key: jt, ref: yt.ref, props: yt.props, _owner: yt._owner };
  }
  function Vt(yt) {
    return typeof yt == "object" && yt !== null && yt.$$typeof === oe;
  }
  function on(yt) {
    var jt = { "=": "=0", ":": "=2" };
    return "$" + yt.replace(/[=:]/g, function(Mn) {
      return jt[Mn];
    });
  }
  var tn = /\/+/g;
  function _n(yt, jt) {
    return typeof yt == "object" && yt !== null && yt.key != null ? on("" + yt.key) : jt.toString(36);
  }
  function en(yt, jt, Mn, $n, Zt) {
    var vn = typeof yt;
    (vn === "undefined" || vn === "boolean") && (yt = null);
    var Fn = !1;
    if (yt === null)
      Fn = !0;
    else
      switch (vn) {
        case "string":
        case "number":
          Fn = !0;
          break;
        case "object":
          switch (yt.$$typeof) {
            case oe:
            case ae:
              Fn = !0;
          }
      }
    if (Fn)
      return Fn = yt, Zt = Zt(Fn), yt = $n === "" ? "." + _n(Fn, 0) : $n, ht(Zt) ? (Mn = "", yt != null && (Mn = yt.replace(tn, "$&/") + "/"), en(Zt, jt, Mn, "", function(ar) {
        return ar;
      })) : Zt != null && (Vt(Zt) && (Zt = Ft(Zt, Mn + (!Zt.key || Fn && Fn.key === Zt.key ? "" : ("" + Zt.key).replace(tn, "$&/") + "/") + yt)), jt.push(Zt)), 1;
    if (Fn = 0, $n = $n === "" ? "." : $n + ":", ht(yt))
      for (var Qn = 0; Qn < yt.length; Qn++) {
        vn = yt[Qn];
        var Un = $n + _n(vn, Qn);
        Fn += en(vn, jt, Mn, Un, Zt);
      }
    else if (Un = Be(yt), typeof Un == "function")
      for (yt = Un.call(yt), Qn = 0; !(vn = yt.next()).done; )
        vn = vn.value, Un = $n + _n(vn, Qn++), Fn += en(vn, jt, Mn, Un, Zt);
    else if (vn === "object")
      throw jt = String(yt), Error("Objects are not valid as a React child (found: " + (jt === "[object Object]" ? "object with keys {" + Object.keys(yt).join(", ") + "}" : jt) + "). If you meant to render a collection of children, use an array instead.");
    return Fn;
  }
  function dn(yt, jt, Mn) {
    if (yt == null)
      return yt;
    var $n = [], Zt = 0;
    return en(yt, $n, "", "", function(vn) {
      return jt.call(Mn, vn, Zt++);
    }), $n;
  }
  function Ht(yt) {
    if (yt._status === -1) {
      var jt = yt._result;
      jt = jt(), jt.then(function(Mn) {
        (yt._status === 0 || yt._status === -1) && (yt._status = 1, yt._result = Mn);
      }, function(Mn) {
        (yt._status === 0 || yt._status === -1) && (yt._status = 2, yt._result = Mn);
      }), yt._status === -1 && (yt._status = 0, yt._result = jt);
    }
    if (yt._status === 1)
      return yt._result.default;
    throw yt._result;
  }
  var hn = { current: null }, kn = { transition: null }, Dn = { ReactCurrentDispatcher: hn, ReactCurrentBatchConfig: kn, ReactCurrentOwner: At };
  ne.Children = { map: dn, forEach: function(yt, jt, Mn) {
    dn(yt, function() {
      jt.apply(this, arguments);
    }, Mn);
  }, count: function(yt) {
    var jt = 0;
    return dn(yt, function() {
      jt++;
    }), jt;
  }, toArray: function(yt) {
    return dn(yt, function(jt) {
      return jt;
    }) || [];
  }, only: function(yt) {
    if (!Vt(yt))
      throw Error("React.Children.only expected to receive a single React element child.");
    return yt;
  } }, ne.Component = Ye, ne.Fragment = fe, ne.Profiler = we, ne.PureComponent = tt, ne.StrictMode = ye, ne.Suspense = $e, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Dn, ne.cloneElement = function(yt, jt, Mn) {
    if (yt == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + yt + ".");
    var $n = He({}, yt.props), Zt = yt.key, vn = yt.ref, Fn = yt._owner;
    if (jt != null) {
      if (jt.ref !== void 0 && (vn = jt.ref, Fn = At.current), jt.key !== void 0 && (Zt = "" + jt.key), yt.type && yt.type.defaultProps)
        var Qn = yt.type.defaultProps;
      for (Un in jt)
        gt.call(jt, Un) && !St.hasOwnProperty(Un) && ($n[Un] = jt[Un] === void 0 && Qn !== void 0 ? Qn[Un] : jt[Un]);
    }
    var Un = arguments.length - 2;
    if (Un === 1)
      $n.children = Mn;
    else if (1 < Un) {
      Qn = Array(Un);
      for (var ar = 0; ar < Un; ar++)
        Qn[ar] = arguments[ar + 2];
      $n.children = Qn;
    }
    return { $$typeof: oe, type: yt.type, key: Zt, ref: vn, props: $n, _owner: Fn };
  }, ne.createContext = function(yt) {
    return yt = { $$typeof: xe, _currentValue: yt, _currentValue2: yt, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, yt.Provider = { $$typeof: _e, _context: yt }, yt.Consumer = yt;
  }, ne.createElement = Nt, ne.createFactory = function(yt) {
    var jt = Nt.bind(null, yt);
    return jt.type = yt, jt;
  }, ne.createRef = function() {
    return { current: null };
  }, ne.forwardRef = function(yt) {
    return { $$typeof: Oe, render: yt };
  }, ne.isValidElement = Vt, ne.lazy = function(yt) {
    return { $$typeof: Ne, _payload: { _status: -1, _result: yt }, _init: Ht };
  }, ne.memo = function(yt, jt) {
    return { $$typeof: Re, type: yt, compare: jt === void 0 ? null : jt };
  }, ne.startTransition = function(yt) {
    var jt = kn.transition;
    kn.transition = {};
    try {
      yt();
    } finally {
      kn.transition = jt;
    }
  }, ne.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, ne.useCallback = function(yt, jt) {
    return hn.current.useCallback(yt, jt);
  }, ne.useContext = function(yt) {
    return hn.current.useContext(yt);
  }, ne.useDebugValue = function() {
  }, ne.useDeferredValue = function(yt) {
    return hn.current.useDeferredValue(yt);
  }, ne.useEffect = function(yt, jt) {
    return hn.current.useEffect(yt, jt);
  }, ne.useId = function() {
    return hn.current.useId();
  }, ne.useImperativeHandle = function(yt, jt, Mn) {
    return hn.current.useImperativeHandle(yt, jt, Mn);
  }, ne.useInsertionEffect = function(yt, jt) {
    return hn.current.useInsertionEffect(yt, jt);
  }, ne.useLayoutEffect = function(yt, jt) {
    return hn.current.useLayoutEffect(yt, jt);
  }, ne.useMemo = function(yt, jt) {
    return hn.current.useMemo(yt, jt);
  }, ne.useReducer = function(yt, jt, Mn) {
    return hn.current.useReducer(yt, jt, Mn);
  }, ne.useRef = function(yt) {
    return hn.current.useRef(yt);
  }, ne.useState = function(yt) {
    return hn.current.useState(yt);
  }, ne.useSyncExternalStore = function(yt, jt, Mn) {
    return hn.current.useSyncExternalStore(yt, jt, Mn);
  }, ne.useTransition = function() {
    return hn.current.useTransition();
  }, ne.version = "18.2.0";
}), Qj = M((ne, oe) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ae = "18.2.0", fe = Symbol.for("react.element"), ye = Symbol.for("react.portal"), we = Symbol.for("react.fragment"), _e = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), Oe = Symbol.for("react.provider"), $e = Symbol.for("react.context"), Re = Symbol.for("react.forward_ref"), Ne = Symbol.for("react.suspense"), je = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), qe = Symbol.iterator, Ye = "@@iterator";
    function ot(Ge) {
      if (Ge === null || typeof Ge != "object")
        return null;
      var dt = qe && Ge[qe] || Ge[Ye];
      return typeof dt == "function" ? dt : null;
    }
    var tt = { current: null }, it = { transition: null }, ht = { current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1 }, gt = { current: null }, At = {}, St = null;
    function Nt(Ge) {
      St = Ge;
    }
    At.setExtraStackFrame = function(Ge) {
      St = Ge;
    }, At.getCurrentStack = null, At.getStackAddendum = function() {
      var Ge = "";
      St && (Ge += St);
      var dt = At.getCurrentStack;
      return dt && (Ge += dt() || ""), Ge;
    };
    var Ft = !1, Vt = !1, on = !1, tn = !1, _n = !1, en = { ReactCurrentDispatcher: tt, ReactCurrentBatchConfig: it, ReactCurrentOwner: gt };
    en.ReactDebugCurrentFrame = At, en.ReactCurrentActQueue = ht;
    function dn(Ge) {
      {
        for (var dt = arguments.length, Ot = new Array(dt > 1 ? dt - 1 : 0), $t = 1; $t < dt; $t++)
          Ot[$t - 1] = arguments[$t];
        hn("warn", Ge, Ot);
      }
    }
    function Ht(Ge) {
      {
        for (var dt = arguments.length, Ot = new Array(dt > 1 ? dt - 1 : 0), $t = 1; $t < dt; $t++)
          Ot[$t - 1] = arguments[$t];
        hn("error", Ge, Ot);
      }
    }
    function hn(Ge, dt, Ot) {
      {
        var $t = en.ReactDebugCurrentFrame, Xt = $t.getStackAddendum();
        Xt !== "" && (dt += "%s", Ot = Ot.concat([Xt]));
        var An = Ot.map(function(gn) {
          return String(gn);
        });
        An.unshift("Warning: " + dt), Function.prototype.apply.call(console[Ge], console, An);
      }
    }
    var kn = {};
    function Dn(Ge, dt) {
      {
        var Ot = Ge.constructor, $t = Ot && (Ot.displayName || Ot.name) || "ReactClass", Xt = $t + "." + dt;
        if (kn[Xt])
          return;
        Ht("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", dt, $t), kn[Xt] = !0;
      }
    }
    var yt = { isMounted: function(Ge) {
      return !1;
    }, enqueueForceUpdate: function(Ge, dt, Ot) {
      Dn(Ge, "forceUpdate");
    }, enqueueReplaceState: function(Ge, dt, Ot, $t) {
      Dn(Ge, "replaceState");
    }, enqueueSetState: function(Ge, dt, Ot, $t) {
      Dn(Ge, "setState");
    } }, jt = Object.assign, Mn = {};
    Object.freeze(Mn);
    function $n(Ge, dt, Ot) {
      this.props = Ge, this.context = dt, this.refs = Mn, this.updater = Ot || yt;
    }
    $n.prototype.isReactComponent = {}, $n.prototype.setState = function(Ge, dt) {
      if (typeof Ge != "object" && typeof Ge != "function" && Ge != null)
        throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, Ge, dt, "setState");
    }, $n.prototype.forceUpdate = function(Ge) {
      this.updater.enqueueForceUpdate(this, Ge, "forceUpdate");
    };
    {
      var Zt = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] }, vn = function(Ge, dt) {
        Object.defineProperty($n.prototype, Ge, { get: function() {
          dn("%s(...) is deprecated in plain JavaScript React classes. %s", dt[0], dt[1]);
        } });
      };
      for (var Fn in Zt)
        Zt.hasOwnProperty(Fn) && vn(Fn, Zt[Fn]);
    }
    function Qn() {
    }
    Qn.prototype = $n.prototype;
    function Un(Ge, dt, Ot) {
      this.props = Ge, this.context = dt, this.refs = Mn, this.updater = Ot || yt;
    }
    var ar = Un.prototype = new Qn();
    ar.constructor = Un, jt(ar, $n.prototype), ar.isPureReactComponent = !0;
    function Zo() {
      var Ge = { current: null };
      return Object.seal(Ge), Ge;
    }
    var ao = Array.isArray;
    function Yr(Ge) {
      return ao(Ge);
    }
    function so(Ge) {
      {
        var dt = typeof Symbol == "function" && Symbol.toStringTag, Ot = dt && Ge[Symbol.toStringTag] || Ge.constructor.name || "Object";
        return Ot;
      }
    }
    function Io(Ge) {
      try {
        return Po(Ge), !1;
      } catch {
        return !0;
      }
    }
    function Po(Ge) {
      return "" + Ge;
    }
    function vo(Ge) {
      if (Io(Ge))
        return Ht("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", so(Ge)), Po(Ge);
    }
    function na(Ge, dt, Ot) {
      var $t = Ge.displayName;
      if ($t)
        return $t;
      var Xt = dt.displayName || dt.name || "";
      return Xt !== "" ? Ot + "(" + Xt + ")" : Ot;
    }
    function va(Ge) {
      return Ge.displayName || "Context";
    }
    function go(Ge) {
      if (Ge == null)
        return null;
      if (typeof Ge.tag == "number" && Ht("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ge == "function")
        return Ge.displayName || Ge.name || null;
      if (typeof Ge == "string")
        return Ge;
      switch (Ge) {
        case we:
          return "Fragment";
        case ye:
          return "Portal";
        case xe:
          return "Profiler";
        case _e:
          return "StrictMode";
        case Ne:
          return "Suspense";
        case je:
          return "SuspenseList";
      }
      if (typeof Ge == "object")
        switch (Ge.$$typeof) {
          case $e:
            var dt = Ge;
            return va(dt) + ".Consumer";
          case Oe:
            var Ot = Ge;
            return va(Ot._context) + ".Provider";
          case Re:
            return na(Ge, Ge.render, "ForwardRef");
          case Be:
            var $t = Ge.displayName || null;
            return $t !== null ? $t : go(Ge.type) || "Memo";
          case ze: {
            var Xt = Ge, An = Xt._payload, gn = Xt._init;
            try {
              return go(gn(An));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Fo = Object.prototype.hasOwnProperty, Ro = { key: !0, ref: !0, __self: !0, __source: !0 }, la, Ia, Go;
    Go = {};
    function Yo(Ge) {
      if (Fo.call(Ge, "ref")) {
        var dt = Object.getOwnPropertyDescriptor(Ge, "ref").get;
        if (dt && dt.isReactWarning)
          return !1;
      }
      return Ge.ref !== void 0;
    }
    function Ra(Ge) {
      if (Fo.call(Ge, "key")) {
        var dt = Object.getOwnPropertyDescriptor(Ge, "key").get;
        if (dt && dt.isReactWarning)
          return !1;
      }
      return Ge.key !== void 0;
    }
    function Bo(Ge, dt) {
      var Ot = function() {
        la || (la = !0, Ht("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", dt));
      };
      Ot.isReactWarning = !0, Object.defineProperty(Ge, "key", { get: Ot, configurable: !0 });
    }
    function Na(Ge, dt) {
      var Ot = function() {
        Ia || (Ia = !0, Ht("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", dt));
      };
      Ot.isReactWarning = !0, Object.defineProperty(Ge, "ref", { get: Ot, configurable: !0 });
    }
    function Bt(Ge) {
      if (typeof Ge.ref == "string" && gt.current && Ge.__self && gt.current.stateNode !== Ge.__self) {
        var dt = go(gt.current.type);
        Go[dt] || (Ht('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', dt, Ge.ref), Go[dt] = !0);
      }
    }
    var Kt = function(Ge, dt, Ot, $t, Xt, An, gn) {
      var In = { $$typeof: fe, type: Ge, key: dt, ref: Ot, props: gn, _owner: An };
      return In._store = {}, Object.defineProperty(In._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(In, "_self", { configurable: !1, enumerable: !1, writable: !1, value: $t }), Object.defineProperty(In, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Xt }), Object.freeze && (Object.freeze(In.props), Object.freeze(In)), In;
    };
    function mn(Ge, dt, Ot) {
      var $t, Xt = {}, An = null, gn = null, In = null, Zn = null;
      if (dt != null) {
        Yo(dt) && (gn = dt.ref, Bt(dt)), Ra(dt) && (vo(dt.key), An = "" + dt.key), In = dt.__self === void 0 ? null : dt.__self, Zn = dt.__source === void 0 ? null : dt.__source;
        for ($t in dt)
          Fo.call(dt, $t) && !Ro.hasOwnProperty($t) && (Xt[$t] = dt[$t]);
      }
      var br = arguments.length - 2;
      if (br === 1)
        Xt.children = Ot;
      else if (br > 1) {
        for (var Er = Array(br), Cr = 0; Cr < br; Cr++)
          Er[Cr] = arguments[Cr + 2];
        Object.freeze && Object.freeze(Er), Xt.children = Er;
      }
      if (Ge && Ge.defaultProps) {
        var Ir = Ge.defaultProps;
        for ($t in Ir)
          Xt[$t] === void 0 && (Xt[$t] = Ir[$t]);
      }
      if (An || gn) {
        var Vr = typeof Ge == "function" ? Ge.displayName || Ge.name || "Unknown" : Ge;
        An && Bo(Xt, Vr), gn && Na(Xt, Vr);
      }
      return Kt(Ge, An, gn, In, Zn, gt.current, Xt);
    }
    function jn(Ge, dt) {
      var Ot = Kt(Ge.type, dt, Ge.ref, Ge._self, Ge._source, Ge._owner, Ge.props);
      return Ot;
    }
    function zn(Ge, dt, Ot) {
      if (Ge == null)
        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + Ge + ".");
      var $t, Xt = jt({}, Ge.props), An = Ge.key, gn = Ge.ref, In = Ge._self, Zn = Ge._source, br = Ge._owner;
      if (dt != null) {
        Yo(dt) && (gn = dt.ref, br = gt.current), Ra(dt) && (vo(dt.key), An = "" + dt.key);
        var Er;
        Ge.type && Ge.type.defaultProps && (Er = Ge.type.defaultProps);
        for ($t in dt)
          Fo.call(dt, $t) && !Ro.hasOwnProperty($t) && (dt[$t] === void 0 && Er !== void 0 ? Xt[$t] = Er[$t] : Xt[$t] = dt[$t]);
      }
      var Cr = arguments.length - 2;
      if (Cr === 1)
        Xt.children = Ot;
      else if (Cr > 1) {
        for (var Ir = Array(Cr), Vr = 0; Vr < Cr; Vr++)
          Ir[Vr] = arguments[Vr + 2];
        Xt.children = Ir;
      }
      return Kt(Ge.type, An, gn, In, Zn, br, Xt);
    }
    function qn(Ge) {
      return typeof Ge == "object" && Ge !== null && Ge.$$typeof === fe;
    }
    var rr = ".", or = ":";
    function Wn(Ge) {
      var dt = /[=:]/g, Ot = { "=": "=0", ":": "=2" }, $t = Ge.replace(dt, function(Xt) {
        return Ot[Xt];
      });
      return "$" + $t;
    }
    var Ar = !1, Br = /\/+/g;
    function wo(Ge) {
      return Ge.replace(Br, "$&/");
    }
    function wr(Ge, dt) {
      return typeof Ge == "object" && Ge !== null && Ge.key != null ? (vo(Ge.key), Wn("" + Ge.key)) : dt.toString(36);
    }
    function _r(Ge, dt, Ot, $t, Xt) {
      var An = typeof Ge;
      (An === "undefined" || An === "boolean") && (Ge = null);
      var gn = !1;
      if (Ge === null)
        gn = !0;
      else
        switch (An) {
          case "string":
          case "number":
            gn = !0;
            break;
          case "object":
            switch (Ge.$$typeof) {
              case fe:
              case ye:
                gn = !0;
            }
        }
      if (gn) {
        var In = Ge, Zn = Xt(In), br = $t === "" ? rr + wr(In, 0) : $t;
        if (Yr(Zn)) {
          var Er = "";
          br != null && (Er = wo(br) + "/"), _r(Zn, dt, Er, "", function(uf) {
            return uf;
          });
        } else
          Zn != null && (qn(Zn) && (Zn.key && (!In || In.key !== Zn.key) && vo(Zn.key), Zn = jn(Zn, Ot + (Zn.key && (!In || In.key !== Zn.key) ? wo("" + Zn.key) + "/" : "") + br)), dt.push(Zn));
        return 1;
      }
      var Cr, Ir, Vr = 0, Kr = $t === "" ? rr : $t + or;
      if (Yr(Ge))
        for (var No = 0; No < Ge.length; No++)
          Cr = Ge[No], Ir = Kr + wr(Cr, No), Vr += _r(Cr, dt, Ot, Ir, Xt);
      else {
        var iu = ot(Ge);
        if (typeof iu == "function") {
          var pc = Ge;
          iu === pc.entries && (Ar || dn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ar = !0);
          for (var sf = iu.call(pc), od, su = 0; !(od = sf.next()).done; )
            Cr = od.value, Ir = Kr + wr(Cr, su++), Vr += _r(Cr, dt, Ot, Ir, Xt);
        } else if (An === "object") {
          var Pl = String(Ge);
          throw new Error("Objects are not valid as a React child (found: " + (Pl === "[object Object]" ? "object with keys {" + Object.keys(Ge).join(", ") + "}" : Pl) + "). If you meant to render a collection of children, use an array instead.");
        }
      }
      return Vr;
    }
    function To(Ge, dt, Ot) {
      if (Ge == null)
        return Ge;
      var $t = [], Xt = 0;
      return _r(Ge, $t, "", "", function(An) {
        return dt.call(Ot, An, Xt++);
      }), $t;
    }
    function Ha(Ge) {
      var dt = 0;
      return To(Ge, function() {
        dt++;
      }), dt;
    }
    function Bi(Ge, dt, Ot) {
      To(Ge, function() {
        dt.apply(this, arguments);
      }, Ot);
    }
    function Ui(Ge) {
      return To(Ge, function(dt) {
        return dt;
      }) || [];
    }
    function qa(Ge) {
      if (!qn(Ge))
        throw new Error("React.Children.only expected to receive a single React element child.");
      return Ge;
    }
    function si(Ge) {
      var dt = { $$typeof: $e, _currentValue: Ge, _currentValue2: Ge, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      dt.Provider = { $$typeof: Oe, _context: dt };
      var Ot = !1, $t = !1, Xt = !1;
      {
        var An = { $$typeof: $e, _context: dt };
        Object.defineProperties(An, { Provider: { get: function() {
          return $t || ($t = !0, Ht("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), dt.Provider;
        }, set: function(gn) {
          dt.Provider = gn;
        } }, _currentValue: { get: function() {
          return dt._currentValue;
        }, set: function(gn) {
          dt._currentValue = gn;
        } }, _currentValue2: { get: function() {
          return dt._currentValue2;
        }, set: function(gn) {
          dt._currentValue2 = gn;
        } }, _threadCount: { get: function() {
          return dt._threadCount;
        }, set: function(gn) {
          dt._threadCount = gn;
        } }, Consumer: { get: function() {
          return Ot || (Ot = !0, Ht("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), dt.Consumer;
        } }, displayName: { get: function() {
          return dt.displayName;
        }, set: function(gn) {
          Xt || (dn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", gn), Xt = !0);
        } } }), dt.Consumer = An;
      }
      return dt._currentRenderer = null, dt._currentRenderer2 = null, dt;
    }
    var ra = -1, Ta = 0, ci = 1, wa = 2;
    function fo(Ge) {
      if (Ge._status === ra) {
        var dt = Ge._result, Ot = dt();
        if (Ot.then(function(An) {
          if (Ge._status === Ta || Ge._status === ra) {
            var gn = Ge;
            gn._status = ci, gn._result = An;
          }
        }, function(An) {
          if (Ge._status === Ta || Ge._status === ra) {
            var gn = Ge;
            gn._status = wa, gn._result = An;
          }
        }), Ge._status === ra) {
          var $t = Ge;
          $t._status = Ta, $t._result = Ot;
        }
      }
      if (Ge._status === ci) {
        var Xt = Ge._result;
        return Xt === void 0 && Ht(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Xt), "default" in Xt || Ht(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Xt), Xt.default;
      } else
        throw Ge._result;
    }
    function _o(Ge) {
      var dt = { _status: ra, _result: Ge }, Ot = { $$typeof: ze, _payload: dt, _init: fo };
      {
        var $t, Xt;
        Object.defineProperties(Ot, { defaultProps: { configurable: !0, get: function() {
          return $t;
        }, set: function(An) {
          Ht("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), $t = An, Object.defineProperty(Ot, "defaultProps", { enumerable: !0 });
        } }, propTypes: { configurable: !0, get: function() {
          return Xt;
        }, set: function(An) {
          Ht("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Xt = An, Object.defineProperty(Ot, "propTypes", { enumerable: !0 });
        } } });
      }
      return Ot;
    }
    function oa(Ge) {
      Ge != null && Ge.$$typeof === Be ? Ht("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof Ge != "function" ? Ht("forwardRef requires a render function but was given %s.", Ge === null ? "null" : typeof Ge) : Ge.length !== 0 && Ge.length !== 2 && Ht("forwardRef render functions accept exactly two parameters: props and ref. %s", Ge.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), Ge != null && (Ge.defaultProps != null || Ge.propTypes != null) && Ht("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
      var dt = { $$typeof: Re, render: Ge };
      {
        var Ot;
        Object.defineProperty(dt, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return Ot;
        }, set: function($t) {
          Ot = $t, !Ge.name && !Ge.displayName && (Ge.displayName = $t);
        } });
      }
      return dt;
    }
    var Ma;
    Ma = Symbol.for("react.module.reference");
    function Rt(Ge) {
      return !!(typeof Ge == "string" || typeof Ge == "function" || Ge === we || Ge === xe || _n || Ge === _e || Ge === Ne || Ge === je || tn || Ge === He || Ft || Vt || on || typeof Ge == "object" && Ge !== null && (Ge.$$typeof === ze || Ge.$$typeof === Be || Ge.$$typeof === Oe || Ge.$$typeof === $e || Ge.$$typeof === Re || Ge.$$typeof === Ma || Ge.getModuleId !== void 0));
    }
    function Cn(Ge, dt) {
      Rt(Ge) || Ht("memo: The first argument must be a component. Instead received: %s", Ge === null ? "null" : typeof Ge);
      var Ot = { $$typeof: Be, type: Ge, compare: dt === void 0 ? null : dt };
      {
        var $t;
        Object.defineProperty(Ot, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return $t;
        }, set: function(Xt) {
          $t = Xt, !Ge.name && !Ge.displayName && (Ge.displayName = Xt);
        } });
      }
      return Ot;
    }
    function Pn() {
      var Ge = tt.current;
      return Ge === null && Ht(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), Ge;
    }
    function hr(Ge) {
      var dt = Pn();
      if (Ge._context !== void 0) {
        var Ot = Ge._context;
        Ot.Consumer === Ge ? Ht("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Ot.Provider === Ge && Ht("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
      }
      return dt.useContext(Ge);
    }
    function Dr(Ge) {
      var dt = Pn();
      return dt.useState(Ge);
    }
    function Jr(Ge, dt, Ot) {
      var $t = Pn();
      return $t.useReducer(Ge, dt, Ot);
    }
    function zr(Ge) {
      var dt = Pn();
      return dt.useRef(Ge);
    }
    function gr(Ge, dt) {
      var Ot = Pn();
      return Ot.useEffect(Ge, dt);
    }
    function aa(Ge, dt) {
      var Ot = Pn();
      return Ot.useInsertionEffect(Ge, dt);
    }
    function Oo(Ge, dt) {
      var Ot = Pn();
      return Ot.useLayoutEffect(Ge, dt);
    }
    function Ao(Ge, dt) {
      var Ot = Pn();
      return Ot.useCallback(Ge, dt);
    }
    function ka(Ge, dt) {
      var Ot = Pn();
      return Ot.useMemo(Ge, dt);
    }
    function ys(Ge, dt, Ot) {
      var $t = Pn();
      return $t.useImperativeHandle(Ge, dt, Ot);
    }
    function Qu(Ge, dt) {
      {
        var Ot = Pn();
        return Ot.useDebugValue(Ge, dt);
      }
    }
    function uo() {
      var Ge = Pn();
      return Ge.useTransition();
    }
    function nd(Ge) {
      var dt = Pn();
      return dt.useDeferredValue(Ge);
    }
    function Yi() {
      var Ge = Pn();
      return Ge.useId();
    }
    function Wr(Ge, dt, Ot) {
      var $t = Pn();
      return $t.useSyncExternalStore(Ge, dt, Ot);
    }
    var Ea = 0, Ku, Fu, Ms, Ka, Xu, ja, Ju;
    function el() {
    }
    el.__reactDisabledLog = !0;
    function rd() {
      {
        if (Ea === 0) {
          Ku = console.log, Fu = console.info, Ms = console.warn, Ka = console.error, Xu = console.group, ja = console.groupCollapsed, Ju = console.groupEnd;
          var Ge = { configurable: !0, enumerable: !0, value: el, writable: !0 };
          Object.defineProperties(console, { info: Ge, log: Ge, warn: Ge, error: Ge, group: Ge, groupCollapsed: Ge, groupEnd: Ge });
        }
        Ea++;
      }
    }
    function tl() {
      {
        if (Ea--, Ea === 0) {
          var Ge = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: jt({}, Ge, { value: Ku }), info: jt({}, Ge, { value: Fu }), warn: jt({}, Ge, { value: Ms }), error: jt({}, Ge, { value: Ka }), group: jt({}, Ge, { value: Xu }), groupCollapsed: jt({}, Ge, { value: ja }), groupEnd: jt({}, Ge, { value: Ju }) });
        }
        Ea < 0 && Ht("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Vi = en.ReactCurrentDispatcher, gi;
    function ca(Ge, dt, Ot) {
      {
        if (gi === void 0)
          try {
            throw Error();
          } catch (Xt) {
            var $t = Xt.stack.trim().match(/\n( *(at )?)/);
            gi = $t && $t[1] || "";
          }
        return `
` + gi + Ge;
      }
    }
    var js = !1, Hi;
    {
      var gl = typeof WeakMap == "function" ? WeakMap : Map;
      Hi = new gl();
    }
    function ru(Ge, dt) {
      if (!Ge || js)
        return "";
      {
        var Ot = Hi.get(Ge);
        if (Ot !== void 0)
          return Ot;
      }
      var $t;
      js = !0;
      var Xt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var An;
      An = Vi.current, Vi.current = null, rd();
      try {
        if (dt) {
          var gn = function() {
            throw Error();
          };
          if (Object.defineProperty(gn.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gn, []);
            } catch (Kr) {
              $t = Kr;
            }
            Reflect.construct(Ge, [], gn);
          } else {
            try {
              gn.call();
            } catch (Kr) {
              $t = Kr;
            }
            Ge.call(gn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Kr) {
            $t = Kr;
          }
          Ge();
        }
      } catch (Kr) {
        if (Kr && $t && typeof Kr.stack == "string") {
          for (var In = Kr.stack.split(`
`), Zn = $t.stack.split(`
`), br = In.length - 1, Er = Zn.length - 1; br >= 1 && Er >= 0 && In[br] !== Zn[Er]; )
            Er--;
          for (; br >= 1 && Er >= 0; br--, Er--)
            if (In[br] !== Zn[Er]) {
              if (br !== 1 || Er !== 1)
                do
                  if (br--, Er--, Er < 0 || In[br] !== Zn[Er]) {
                    var Cr = `
` + In[br].replace(" at new ", " at ");
                    return Ge.displayName && Cr.includes("<anonymous>") && (Cr = Cr.replace("<anonymous>", Ge.displayName)), typeof Ge == "function" && Hi.set(Ge, Cr), Cr;
                  }
                while (br >= 1 && Er >= 0);
              break;
            }
        }
      } finally {
        js = !1, Vi.current = An, tl(), Error.prepareStackTrace = Xt;
      }
      var Ir = Ge ? Ge.displayName || Ge.name : "", Vr = Ir ? ca(Ir) : "";
      return typeof Ge == "function" && Hi.set(Ge, Vr), Vr;
    }
    function wl(Ge, dt, Ot) {
      return ru(Ge, !1);
    }
    function Ds(Ge) {
      var dt = Ge.prototype;
      return !!(dt && dt.isReactComponent);
    }
    function Ls(Ge, dt, Ot) {
      if (Ge == null)
        return "";
      if (typeof Ge == "function")
        return ru(Ge, Ds(Ge));
      if (typeof Ge == "string")
        return ca(Ge);
      switch (Ge) {
        case Ne:
          return ca("Suspense");
        case je:
          return ca("SuspenseList");
      }
      if (typeof Ge == "object")
        switch (Ge.$$typeof) {
          case Re:
            return wl(Ge.render);
          case Be:
            return Ls(Ge.type, dt, Ot);
          case ze: {
            var $t = Ge, Xt = $t._payload, An = $t._init;
            try {
              return Ls(An(Xt), dt, Ot);
            } catch {
            }
          }
        }
      return "";
    }
    var Fs = {}, po = en.ReactDebugCurrentFrame;
    function ts(Ge) {
      if (Ge) {
        var dt = Ge._owner, Ot = Ls(Ge.type, Ge._source, dt ? dt.type : null);
        po.setExtraStackFrame(Ot);
      } else
        po.setExtraStackFrame(null);
    }
    function fc(Ge, dt, Ot, $t, Xt) {
      {
        var An = Function.call.bind(Fo);
        for (var gn in Ge)
          if (An(Ge, gn)) {
            var In = void 0;
            try {
              if (typeof Ge[gn] != "function") {
                var Zn = Error(($t || "React class") + ": " + Ot + " type `" + gn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ge[gn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Zn.name = "Invariant Violation", Zn;
              }
              In = Ge[gn](dt, gn, $t, Ot, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (br) {
              In = br;
            }
            In && !(In instanceof Error) && (ts(Xt), Ht("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $t || "React class", Ot, gn, typeof In), ts(null)), In instanceof Error && !(In.message in Fs) && (Fs[In.message] = !0, ts(Xt), Ht("Failed %s type: %s", Ot, In.message), ts(null));
          }
      }
    }
    function Da(Ge) {
      if (Ge) {
        var dt = Ge._owner, Ot = Ls(Ge.type, Ge._source, dt ? dt.type : null);
        Nt(Ot);
      } else
        Nt(null);
    }
    var ho;
    ho = !1;
    function nl() {
      if (gt.current) {
        var Ge = go(gt.current.type);
        if (Ge)
          return `

Check the render method of \`` + Ge + "`.";
      }
      return "";
    }
    function _l(Ge) {
      if (Ge !== void 0) {
        var dt = Ge.fileName.replace(/^.*[\\\/]/, ""), Ot = Ge.lineNumber;
        return `

Check your code at ` + dt + ":" + Ot + ".";
      }
      return "";
    }
    function Mr(Ge) {
      return Ge != null ? _l(Ge.__source) : "";
    }
    var Bs = {};
    function Wo(Ge) {
      var dt = nl();
      if (!dt) {
        var Ot = typeof Ge == "string" ? Ge : Ge.displayName || Ge.name;
        Ot && (dt = `

Check the top-level render call using <` + Ot + ">.");
      }
      return dt;
    }
    function La(Ge, dt) {
      if (!(!Ge._store || Ge._store.validated || Ge.key != null)) {
        Ge._store.validated = !0;
        var Ot = Wo(dt);
        if (!Bs[Ot]) {
          Bs[Ot] = !0;
          var $t = "";
          Ge && Ge._owner && Ge._owner !== gt.current && ($t = " It was passed a child from " + go(Ge._owner.type) + "."), Da(Ge), Ht('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ot, $t), Da(null);
        }
      }
    }
    function Fa(Ge, dt) {
      if (typeof Ge == "object") {
        if (Yr(Ge))
          for (var Ot = 0; Ot < Ge.length; Ot++) {
            var $t = Ge[Ot];
            qn($t) && La($t, dt);
          }
        else if (qn(Ge))
          Ge._store && (Ge._store.validated = !0);
        else if (Ge) {
          var Xt = ot(Ge);
          if (typeof Xt == "function" && Xt !== Ge.entries)
            for (var An = Xt.call(Ge), gn; !(gn = An.next()).done; )
              qn(gn.value) && La(gn.value, dt);
        }
      }
    }
    function zs(Ge) {
      {
        var dt = Ge.type;
        if (dt == null || typeof dt == "string")
          return;
        var Ot;
        if (typeof dt == "function")
          Ot = dt.propTypes;
        else if (typeof dt == "object" && (dt.$$typeof === Re || dt.$$typeof === Be))
          Ot = dt.propTypes;
        else
          return;
        if (Ot) {
          var $t = go(dt);
          fc(Ot, Ge.props, "prop", $t, Ge);
        } else if (dt.PropTypes !== void 0 && !ho) {
          ho = !0;
          var Xt = go(dt);
          Ht("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Xt || "Unknown");
        }
        typeof dt.getDefaultProps == "function" && !dt.getDefaultProps.isReactClassApproved && Ht("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Qo(Ge) {
      {
        for (var dt = Object.keys(Ge.props), Ot = 0; Ot < dt.length; Ot++) {
          var $t = dt[Ot];
          if ($t !== "children" && $t !== "key") {
            Da(Ge), Ht("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $t), Da(null);
            break;
          }
        }
        Ge.ref !== null && (Da(Ge), Ht("Invalid attribute `ref` supplied to `React.Fragment`."), Da(null));
      }
    }
    function mo(Ge, dt, Ot) {
      var $t = Rt(Ge);
      if (!$t) {
        var Xt = "";
        (Ge === void 0 || typeof Ge == "object" && Ge !== null && Object.keys(Ge).length === 0) && (Xt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var An = Mr(dt);
        An ? Xt += An : Xt += nl();
        var gn;
        Ge === null ? gn = "null" : Yr(Ge) ? gn = "array" : Ge !== void 0 && Ge.$$typeof === fe ? (gn = "<" + (go(Ge.type) || "Unknown") + " />", Xt = " Did you accidentally export a JSX literal instead of a component?") : gn = typeof Ge, Ht("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", gn, Xt);
      }
      var In = mn.apply(this, arguments);
      if (In == null)
        return In;
      if ($t)
        for (var Zn = 2; Zn < arguments.length; Zn++)
          Fa(arguments[Zn], Ge);
      return Ge === we ? Qo(In) : zs(In), In;
    }
    var El = !1;
    function wi(Ge) {
      var dt = mo.bind(null, Ge);
      return dt.type = Ge, El || (El = !0, dn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(dt, "type", { enumerable: !1, get: function() {
        return dn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: Ge }), Ge;
      } }), dt;
    }
    function xa(Ge, dt, Ot) {
      for (var $t = zn.apply(this, arguments), Xt = 2; Xt < arguments.length; Xt++)
        Fa(arguments[Xt], $t.type);
      return zs($t), $t;
    }
    function bs(Ge, dt) {
      var Ot = it.transition;
      it.transition = {};
      var $t = it.transition;
      it.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        Ge();
      } finally {
        if (it.transition = Ot, Ot === null && $t._updatedFibers) {
          var Xt = $t._updatedFibers.size;
          Xt > 10 && dn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), $t._updatedFibers.clear();
        }
      }
    }
    var rl = !1, di = null;
    function xl(Ge) {
      if (di === null)
        try {
          var dt = ("require" + Math.random()).slice(0, 7), Ot = oe && oe[dt];
          di = Ot.call(oe, "timers").setImmediate;
        } catch {
          di = function($t) {
            rl === !1 && (rl = !0, typeof MessageChannel > "u" && Ht("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var Xt = new MessageChannel();
            Xt.port1.onmessage = $t, Xt.port2.postMessage(void 0);
          };
        }
      return di(Ge);
    }
    var fi = 0, Us = !1;
    function ou(Ge) {
      {
        var dt = fi;
        fi++, ht.current === null && (ht.current = []);
        var Ot = ht.isBatchingLegacy, $t;
        try {
          if (ht.isBatchingLegacy = !0, $t = Ge(), !Ot && ht.didScheduleLegacyUpdate) {
            var Xt = ht.current;
            Xt !== null && (ht.didScheduleLegacyUpdate = !1, vs(Xt));
          }
        } catch (Ir) {
          throw pi(dt), Ir;
        } finally {
          ht.isBatchingLegacy = Ot;
        }
        if ($t !== null && typeof $t == "object" && typeof $t.then == "function") {
          var An = $t, gn = !1, In = { then: function(Ir, Vr) {
            gn = !0, An.then(function(Kr) {
              pi(dt), fi === 0 ? Ei(Kr, Ir, Vr) : Ir(Kr);
            }, function(Kr) {
              pi(dt), Vr(Kr);
            });
          } };
          return !Us && typeof Promise < "u" && Promise.resolve().then(function() {
          }).then(function() {
            gn || (Us = !0, Ht("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
          }), In;
        } else {
          var Zn = $t;
          if (pi(dt), fi === 0) {
            var br = ht.current;
            br !== null && (vs(br), ht.current = null);
            var Er = { then: function(Ir, Vr) {
              ht.current === null ? (ht.current = [], Ei(Zn, Ir, Vr)) : Ir(Zn);
            } };
            return Er;
          } else {
            var Cr = { then: function(Ir, Vr) {
              Ir(Zn);
            } };
            return Cr;
          }
        }
      }
    }
    function pi(Ge) {
      Ge !== fi - 1 && Ht("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), fi = Ge;
    }
    function Ei(Ge, dt, Ot) {
      {
        var $t = ht.current;
        if ($t !== null)
          try {
            vs($t), xl(function() {
              $t.length === 0 ? (ht.current = null, dt(Ge)) : Ei(Ge, dt, Ot);
            });
          } catch (Xt) {
            Ot(Xt);
          }
        else
          dt(Ge);
      }
    }
    var au = !1;
    function vs(Ge) {
      if (!au) {
        au = !0;
        var dt = 0;
        try {
          for (; dt < Ge.length; dt++) {
            var Ot = Ge[dt];
            do
              Ot = Ot(!0);
            while (Ot !== null);
          }
          Ge.length = 0;
        } catch ($t) {
          throw Ge = Ge.slice(dt + 1), $t;
        } finally {
          au = !1;
        }
      }
    }
    var ol = mo, Bu = xa, al = wi, Sl = { map: To, forEach: Bi, count: Ha, toArray: Ui, only: qa };
    ne.Children = Sl, ne.Component = $n, ne.Fragment = we, ne.Profiler = xe, ne.PureComponent = Un, ne.StrictMode = _e, ne.Suspense = Ne, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = en, ne.cloneElement = Bu, ne.createContext = si, ne.createElement = ol, ne.createFactory = al, ne.createRef = Zo, ne.forwardRef = oa, ne.isValidElement = qn, ne.lazy = _o, ne.memo = Cn, ne.startTransition = bs, ne.unstable_act = ou, ne.useCallback = Ao, ne.useContext = hr, ne.useDebugValue = Qu, ne.useDeferredValue = nd, ne.useEffect = gr, ne.useId = Yi, ne.useImperativeHandle = ys, ne.useInsertionEffect = aa, ne.useLayoutEffect = Oo, ne.useMemo = ka, ne.useReducer = Jr, ne.useRef = zr, ne.useState = Dr, ne.useSyncExternalStore = Wr, ne.useTransition = uo, ne.version = ae, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), ir = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Gj() : oe.exports = Qj();
}), Xj = M((ne) => {
  var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.fragment"), ye = Object.prototype.hasOwnProperty, we = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, _e = { key: !0, ref: !0, __self: !0, __source: !0 };
  function xe(Oe, $e, Re) {
    var Ne, je = {}, Be = null, ze = null;
    Re !== void 0 && (Be = "" + Re), $e.key !== void 0 && (Be = "" + $e.key), $e.ref !== void 0 && (ze = $e.ref);
    for (Ne in $e)
      ye.call($e, Ne) && !_e.hasOwnProperty(Ne) && (je[Ne] = $e[Ne]);
    if (Oe && Oe.defaultProps)
      for (Ne in $e = Oe.defaultProps, $e)
        je[Ne] === void 0 && (je[Ne] = $e[Ne]);
    return { $$typeof: ae, type: Oe, key: Be, ref: ze, props: je, _owner: we.current };
  }
  ne.Fragment = fe, ne.jsx = xe, ne.jsxs = xe;
}), Jj = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.portal"), ye = Symbol.for("react.fragment"), we = Symbol.for("react.strict_mode"), _e = Symbol.for("react.profiler"), xe = Symbol.for("react.provider"), Oe = Symbol.for("react.context"), $e = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), Ne = Symbol.for("react.suspense_list"), je = Symbol.for("react.memo"), Be = Symbol.for("react.lazy"), ze = Symbol.for("react.offscreen"), He = Symbol.iterator, qe = "@@iterator";
    function Ye(Rt) {
      if (Rt === null || typeof Rt != "object")
        return null;
      var Cn = He && Rt[He] || Rt[qe];
      return typeof Cn == "function" ? Cn : null;
    }
    var ot = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function tt(Rt) {
      {
        for (var Cn = arguments.length, Pn = new Array(Cn > 1 ? Cn - 1 : 0), hr = 1; hr < Cn; hr++)
          Pn[hr - 1] = arguments[hr];
        it("error", Rt, Pn);
      }
    }
    function it(Rt, Cn, Pn) {
      {
        var hr = ot.ReactDebugCurrentFrame, Dr = hr.getStackAddendum();
        Dr !== "" && (Cn += "%s", Pn = Pn.concat([Dr]));
        var Jr = Pn.map(function(zr) {
          return String(zr);
        });
        Jr.unshift("Warning: " + Cn), Function.prototype.apply.call(console[Rt], console, Jr);
      }
    }
    var ht = !1, gt = !1, At = !1, St = !1, Nt = !1, Ft;
    Ft = Symbol.for("react.module.reference");
    function Vt(Rt) {
      return !!(typeof Rt == "string" || typeof Rt == "function" || Rt === ye || Rt === _e || Nt || Rt === we || Rt === Re || Rt === Ne || St || Rt === ze || ht || gt || At || typeof Rt == "object" && Rt !== null && (Rt.$$typeof === Be || Rt.$$typeof === je || Rt.$$typeof === xe || Rt.$$typeof === Oe || Rt.$$typeof === $e || Rt.$$typeof === Ft || Rt.getModuleId !== void 0));
    }
    function on(Rt, Cn, Pn) {
      var hr = Rt.displayName;
      if (hr)
        return hr;
      var Dr = Cn.displayName || Cn.name || "";
      return Dr !== "" ? Pn + "(" + Dr + ")" : Pn;
    }
    function tn(Rt) {
      return Rt.displayName || "Context";
    }
    function _n(Rt) {
      if (Rt == null)
        return null;
      if (typeof Rt.tag == "number" && tt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Rt == "function")
        return Rt.displayName || Rt.name || null;
      if (typeof Rt == "string")
        return Rt;
      switch (Rt) {
        case ye:
          return "Fragment";
        case fe:
          return "Portal";
        case _e:
          return "Profiler";
        case we:
          return "StrictMode";
        case Re:
          return "Suspense";
        case Ne:
          return "SuspenseList";
      }
      if (typeof Rt == "object")
        switch (Rt.$$typeof) {
          case Oe:
            var Cn = Rt;
            return tn(Cn) + ".Consumer";
          case xe:
            var Pn = Rt;
            return tn(Pn._context) + ".Provider";
          case $e:
            return on(Rt, Rt.render, "ForwardRef");
          case je:
            var hr = Rt.displayName || null;
            return hr !== null ? hr : _n(Rt.type) || "Memo";
          case Be: {
            var Dr = Rt, Jr = Dr._payload, zr = Dr._init;
            try {
              return _n(zr(Jr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var en = Object.assign, dn = 0, Ht, hn, kn, Dn, yt, jt, Mn;
    function $n() {
    }
    $n.__reactDisabledLog = !0;
    function Zt() {
      {
        if (dn === 0) {
          Ht = console.log, hn = console.info, kn = console.warn, Dn = console.error, yt = console.group, jt = console.groupCollapsed, Mn = console.groupEnd;
          var Rt = { configurable: !0, enumerable: !0, value: $n, writable: !0 };
          Object.defineProperties(console, { info: Rt, log: Rt, warn: Rt, error: Rt, group: Rt, groupCollapsed: Rt, groupEnd: Rt });
        }
        dn++;
      }
    }
    function vn() {
      {
        if (dn--, dn === 0) {
          var Rt = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: en({}, Rt, { value: Ht }), info: en({}, Rt, { value: hn }), warn: en({}, Rt, { value: kn }), error: en({}, Rt, { value: Dn }), group: en({}, Rt, { value: yt }), groupCollapsed: en({}, Rt, { value: jt }), groupEnd: en({}, Rt, { value: Mn }) });
        }
        dn < 0 && tt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fn = ot.ReactCurrentDispatcher, Qn;
    function Un(Rt, Cn, Pn) {
      {
        if (Qn === void 0)
          try {
            throw Error();
          } catch (Dr) {
            var hr = Dr.stack.trim().match(/\n( *(at )?)/);
            Qn = hr && hr[1] || "";
          }
        return `
` + Qn + Rt;
      }
    }
    var ar = !1, Zo;
    {
      var ao = typeof WeakMap == "function" ? WeakMap : Map;
      Zo = new ao();
    }
    function Yr(Rt, Cn) {
      if (!Rt || ar)
        return "";
      {
        var Pn = Zo.get(Rt);
        if (Pn !== void 0)
          return Pn;
      }
      var hr;
      ar = !0;
      var Dr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Jr;
      Jr = Fn.current, Fn.current = null, Zt();
      try {
        if (Cn) {
          var zr = function() {
            throw Error();
          };
          if (Object.defineProperty(zr.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(zr, []);
            } catch (uo) {
              hr = uo;
            }
            Reflect.construct(Rt, [], zr);
          } else {
            try {
              zr.call();
            } catch (uo) {
              hr = uo;
            }
            Rt.call(zr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (uo) {
            hr = uo;
          }
          Rt();
        }
      } catch (uo) {
        if (uo && hr && typeof uo.stack == "string") {
          for (var gr = uo.stack.split(`
`), aa = hr.stack.split(`
`), Oo = gr.length - 1, Ao = aa.length - 1; Oo >= 1 && Ao >= 0 && gr[Oo] !== aa[Ao]; )
            Ao--;
          for (; Oo >= 1 && Ao >= 0; Oo--, Ao--)
            if (gr[Oo] !== aa[Ao]) {
              if (Oo !== 1 || Ao !== 1)
                do
                  if (Oo--, Ao--, Ao < 0 || gr[Oo] !== aa[Ao]) {
                    var ka = `
` + gr[Oo].replace(" at new ", " at ");
                    return Rt.displayName && ka.includes("<anonymous>") && (ka = ka.replace("<anonymous>", Rt.displayName)), typeof Rt == "function" && Zo.set(Rt, ka), ka;
                  }
                while (Oo >= 1 && Ao >= 0);
              break;
            }
        }
      } finally {
        ar = !1, Fn.current = Jr, vn(), Error.prepareStackTrace = Dr;
      }
      var ys = Rt ? Rt.displayName || Rt.name : "", Qu = ys ? Un(ys) : "";
      return typeof Rt == "function" && Zo.set(Rt, Qu), Qu;
    }
    function so(Rt, Cn, Pn) {
      return Yr(Rt, !1);
    }
    function Io(Rt) {
      var Cn = Rt.prototype;
      return !!(Cn && Cn.isReactComponent);
    }
    function Po(Rt, Cn, Pn) {
      if (Rt == null)
        return "";
      if (typeof Rt == "function")
        return Yr(Rt, Io(Rt));
      if (typeof Rt == "string")
        return Un(Rt);
      switch (Rt) {
        case Re:
          return Un("Suspense");
        case Ne:
          return Un("SuspenseList");
      }
      if (typeof Rt == "object")
        switch (Rt.$$typeof) {
          case $e:
            return so(Rt.render);
          case je:
            return Po(Rt.type, Cn, Pn);
          case Be: {
            var hr = Rt, Dr = hr._payload, Jr = hr._init;
            try {
              return Po(Jr(Dr), Cn, Pn);
            } catch {
            }
          }
        }
      return "";
    }
    var vo = Object.prototype.hasOwnProperty, na = {}, va = ot.ReactDebugCurrentFrame;
    function go(Rt) {
      if (Rt) {
        var Cn = Rt._owner, Pn = Po(Rt.type, Rt._source, Cn ? Cn.type : null);
        va.setExtraStackFrame(Pn);
      } else
        va.setExtraStackFrame(null);
    }
    function Fo(Rt, Cn, Pn, hr, Dr) {
      {
        var Jr = Function.call.bind(vo);
        for (var zr in Rt)
          if (Jr(Rt, zr)) {
            var gr = void 0;
            try {
              if (typeof Rt[zr] != "function") {
                var aa = Error((hr || "React class") + ": " + Pn + " type `" + zr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Rt[zr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw aa.name = "Invariant Violation", aa;
              }
              gr = Rt[zr](Cn, zr, hr, Pn, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Oo) {
              gr = Oo;
            }
            gr && !(gr instanceof Error) && (go(Dr), tt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", hr || "React class", Pn, zr, typeof gr), go(null)), gr instanceof Error && !(gr.message in na) && (na[gr.message] = !0, go(Dr), tt("Failed %s type: %s", Pn, gr.message), go(null));
          }
      }
    }
    var Ro = Array.isArray;
    function la(Rt) {
      return Ro(Rt);
    }
    function Ia(Rt) {
      {
        var Cn = typeof Symbol == "function" && Symbol.toStringTag, Pn = Cn && Rt[Symbol.toStringTag] || Rt.constructor.name || "Object";
        return Pn;
      }
    }
    function Go(Rt) {
      try {
        return Yo(Rt), !1;
      } catch {
        return !0;
      }
    }
    function Yo(Rt) {
      return "" + Rt;
    }
    function Ra(Rt) {
      if (Go(Rt))
        return tt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ia(Rt)), Yo(Rt);
    }
    var Bo = ot.ReactCurrentOwner, Na = { key: !0, ref: !0, __self: !0, __source: !0 }, Bt, Kt, mn;
    mn = {};
    function jn(Rt) {
      if (vo.call(Rt, "ref")) {
        var Cn = Object.getOwnPropertyDescriptor(Rt, "ref").get;
        if (Cn && Cn.isReactWarning)
          return !1;
      }
      return Rt.ref !== void 0;
    }
    function zn(Rt) {
      if (vo.call(Rt, "key")) {
        var Cn = Object.getOwnPropertyDescriptor(Rt, "key").get;
        if (Cn && Cn.isReactWarning)
          return !1;
      }
      return Rt.key !== void 0;
    }
    function qn(Rt, Cn) {
      if (typeof Rt.ref == "string" && Bo.current && Cn && Bo.current.stateNode !== Cn) {
        var Pn = _n(Bo.current.type);
        mn[Pn] || (tt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', _n(Bo.current.type), Rt.ref), mn[Pn] = !0);
      }
    }
    function rr(Rt, Cn) {
      {
        var Pn = function() {
          Bt || (Bt = !0, tt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Cn));
        };
        Pn.isReactWarning = !0, Object.defineProperty(Rt, "key", { get: Pn, configurable: !0 });
      }
    }
    function or(Rt, Cn) {
      {
        var Pn = function() {
          Kt || (Kt = !0, tt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Cn));
        };
        Pn.isReactWarning = !0, Object.defineProperty(Rt, "ref", { get: Pn, configurable: !0 });
      }
    }
    var Wn = function(Rt, Cn, Pn, hr, Dr, Jr, zr) {
      var gr = { $$typeof: ae, type: Rt, key: Cn, ref: Pn, props: zr, _owner: Jr };
      return gr._store = {}, Object.defineProperty(gr._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(gr, "_self", { configurable: !1, enumerable: !1, writable: !1, value: hr }), Object.defineProperty(gr, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Dr }), Object.freeze && (Object.freeze(gr.props), Object.freeze(gr)), gr;
    };
    function Ar(Rt, Cn, Pn, hr, Dr) {
      {
        var Jr, zr = {}, gr = null, aa = null;
        Pn !== void 0 && (Ra(Pn), gr = "" + Pn), zn(Cn) && (Ra(Cn.key), gr = "" + Cn.key), jn(Cn) && (aa = Cn.ref, qn(Cn, Dr));
        for (Jr in Cn)
          vo.call(Cn, Jr) && !Na.hasOwnProperty(Jr) && (zr[Jr] = Cn[Jr]);
        if (Rt && Rt.defaultProps) {
          var Oo = Rt.defaultProps;
          for (Jr in Oo)
            zr[Jr] === void 0 && (zr[Jr] = Oo[Jr]);
        }
        if (gr || aa) {
          var Ao = typeof Rt == "function" ? Rt.displayName || Rt.name || "Unknown" : Rt;
          gr && rr(zr, Ao), aa && or(zr, Ao);
        }
        return Wn(Rt, gr, aa, Dr, hr, Bo.current, zr);
      }
    }
    var Br = ot.ReactCurrentOwner, wo = ot.ReactDebugCurrentFrame;
    function wr(Rt) {
      if (Rt) {
        var Cn = Rt._owner, Pn = Po(Rt.type, Rt._source, Cn ? Cn.type : null);
        wo.setExtraStackFrame(Pn);
      } else
        wo.setExtraStackFrame(null);
    }
    var _r;
    _r = !1;
    function To(Rt) {
      return typeof Rt == "object" && Rt !== null && Rt.$$typeof === ae;
    }
    function Ha() {
      {
        if (Br.current) {
          var Rt = _n(Br.current.type);
          if (Rt)
            return `

Check the render method of \`` + Rt + "`.";
        }
        return "";
      }
    }
    function Bi(Rt) {
      {
        if (Rt !== void 0) {
          var Cn = Rt.fileName.replace(/^.*[\\\/]/, ""), Pn = Rt.lineNumber;
          return `

Check your code at ` + Cn + ":" + Pn + ".";
        }
        return "";
      }
    }
    var Ui = {};
    function qa(Rt) {
      {
        var Cn = Ha();
        if (!Cn) {
          var Pn = typeof Rt == "string" ? Rt : Rt.displayName || Rt.name;
          Pn && (Cn = `

Check the top-level render call using <` + Pn + ">.");
        }
        return Cn;
      }
    }
    function si(Rt, Cn) {
      {
        if (!Rt._store || Rt._store.validated || Rt.key != null)
          return;
        Rt._store.validated = !0;
        var Pn = qa(Cn);
        if (Ui[Pn])
          return;
        Ui[Pn] = !0;
        var hr = "";
        Rt && Rt._owner && Rt._owner !== Br.current && (hr = " It was passed a child from " + _n(Rt._owner.type) + "."), wr(Rt), tt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Pn, hr), wr(null);
      }
    }
    function ra(Rt, Cn) {
      {
        if (typeof Rt != "object")
          return;
        if (la(Rt))
          for (var Pn = 0; Pn < Rt.length; Pn++) {
            var hr = Rt[Pn];
            To(hr) && si(hr, Cn);
          }
        else if (To(Rt))
          Rt._store && (Rt._store.validated = !0);
        else if (Rt) {
          var Dr = Ye(Rt);
          if (typeof Dr == "function" && Dr !== Rt.entries)
            for (var Jr = Dr.call(Rt), zr; !(zr = Jr.next()).done; )
              To(zr.value) && si(zr.value, Cn);
        }
      }
    }
    function Ta(Rt) {
      {
        var Cn = Rt.type;
        if (Cn == null || typeof Cn == "string")
          return;
        var Pn;
        if (typeof Cn == "function")
          Pn = Cn.propTypes;
        else if (typeof Cn == "object" && (Cn.$$typeof === $e || Cn.$$typeof === je))
          Pn = Cn.propTypes;
        else
          return;
        if (Pn) {
          var hr = _n(Cn);
          Fo(Pn, Rt.props, "prop", hr, Rt);
        } else if (Cn.PropTypes !== void 0 && !_r) {
          _r = !0;
          var Dr = _n(Cn);
          tt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Dr || "Unknown");
        }
        typeof Cn.getDefaultProps == "function" && !Cn.getDefaultProps.isReactClassApproved && tt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ci(Rt) {
      {
        for (var Cn = Object.keys(Rt.props), Pn = 0; Pn < Cn.length; Pn++) {
          var hr = Cn[Pn];
          if (hr !== "children" && hr !== "key") {
            wr(Rt), tt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", hr), wr(null);
            break;
          }
        }
        Rt.ref !== null && (wr(Rt), tt("Invalid attribute `ref` supplied to `React.Fragment`."), wr(null));
      }
    }
    function wa(Rt, Cn, Pn, hr, Dr, Jr) {
      {
        var zr = Vt(Rt);
        if (!zr) {
          var gr = "";
          (Rt === void 0 || typeof Rt == "object" && Rt !== null && Object.keys(Rt).length === 0) && (gr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var aa = Bi(Dr);
          aa ? gr += aa : gr += Ha();
          var Oo;
          Rt === null ? Oo = "null" : la(Rt) ? Oo = "array" : Rt !== void 0 && Rt.$$typeof === ae ? (Oo = "<" + (_n(Rt.type) || "Unknown") + " />", gr = " Did you accidentally export a JSX literal instead of a component?") : Oo = typeof Rt, tt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Oo, gr);
        }
        var Ao = Ar(Rt, Cn, Pn, Dr, Jr);
        if (Ao == null)
          return Ao;
        if (zr) {
          var ka = Cn.children;
          if (ka !== void 0)
            if (hr)
              if (la(ka)) {
                for (var ys = 0; ys < ka.length; ys++)
                  ra(ka[ys], Rt);
                Object.freeze && Object.freeze(ka);
              } else
                tt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ra(ka, Rt);
        }
        return Rt === ye ? ci(Ao) : Ta(Ao), Ao;
      }
    }
    function fo(Rt, Cn, Pn) {
      return wa(Rt, Cn, Pn, !0);
    }
    function _o(Rt, Cn, Pn) {
      return wa(Rt, Cn, Pn, !1);
    }
    var oa = _o, Ma = fo;
    ne.Fragment = ye, ne.jsx = oa, ne.jsxs = Ma;
  }();
}), ke = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Xj() : oe.exports = Jj();
}), l2 = M((ne) => {
  function oe(hn, kn) {
    var Dn = hn.length;
    hn.push(kn);
    e:
      for (; 0 < Dn; ) {
        var yt = Dn - 1 >>> 1, jt = hn[yt];
        if (0 < ye(jt, kn))
          hn[yt] = kn, hn[Dn] = jt, Dn = yt;
        else
          break e;
      }
  }
  function ae(hn) {
    return hn.length === 0 ? null : hn[0];
  }
  function fe(hn) {
    if (hn.length === 0)
      return null;
    var kn = hn[0], Dn = hn.pop();
    if (Dn !== kn) {
      hn[0] = Dn;
      e:
        for (var yt = 0, jt = hn.length, Mn = jt >>> 1; yt < Mn; ) {
          var $n = 2 * (yt + 1) - 1, Zt = hn[$n], vn = $n + 1, Fn = hn[vn];
          if (0 > ye(Zt, Dn))
            vn < jt && 0 > ye(Fn, Zt) ? (hn[yt] = Fn, hn[vn] = Dn, yt = vn) : (hn[yt] = Zt, hn[$n] = Dn, yt = $n);
          else if (vn < jt && 0 > ye(Fn, Dn))
            hn[yt] = Fn, hn[vn] = Dn, yt = vn;
          else
            break e;
        }
    }
    return kn;
  }
  function ye(hn, kn) {
    var Dn = hn.sortIndex - kn.sortIndex;
    return Dn !== 0 ? Dn : hn.id - kn.id;
  }
  typeof performance == "object" && typeof performance.now == "function" ? (we = performance, ne.unstable_now = function() {
    return we.now();
  }) : (_e = Date, xe = _e.now(), ne.unstable_now = function() {
    return _e.now() - xe;
  });
  var we, _e, xe, Oe = [], $e = [], Re = 1, Ne = null, je = 3, Be = !1, ze = !1, He = !1, qe = typeof setTimeout == "function" ? setTimeout : null, Ye = typeof clearTimeout == "function" ? clearTimeout : null, ot = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function tt(hn) {
    for (var kn = ae($e); kn !== null; ) {
      if (kn.callback === null)
        fe($e);
      else if (kn.startTime <= hn)
        fe($e), kn.sortIndex = kn.expirationTime, oe(Oe, kn);
      else
        break;
      kn = ae($e);
    }
  }
  function it(hn) {
    if (He = !1, tt(hn), !ze)
      if (ae(Oe) !== null)
        ze = !0, dn(ht);
      else {
        var kn = ae($e);
        kn !== null && Ht(it, kn.startTime - hn);
      }
  }
  function ht(hn, kn) {
    ze = !1, He && (He = !1, Ye(St), St = -1), Be = !0;
    var Dn = je;
    try {
      for (tt(kn), Ne = ae(Oe); Ne !== null && (!(Ne.expirationTime > kn) || hn && !Vt()); ) {
        var yt = Ne.callback;
        if (typeof yt == "function") {
          Ne.callback = null, je = Ne.priorityLevel;
          var jt = yt(Ne.expirationTime <= kn);
          kn = ne.unstable_now(), typeof jt == "function" ? Ne.callback = jt : Ne === ae(Oe) && fe(Oe), tt(kn);
        } else
          fe(Oe);
        Ne = ae(Oe);
      }
      if (Ne !== null)
        var Mn = !0;
      else {
        var $n = ae($e);
        $n !== null && Ht(it, $n.startTime - kn), Mn = !1;
      }
      return Mn;
    } finally {
      Ne = null, je = Dn, Be = !1;
    }
  }
  var gt = !1, At = null, St = -1, Nt = 5, Ft = -1;
  function Vt() {
    return !(ne.unstable_now() - Ft < Nt);
  }
  function on() {
    if (At !== null) {
      var hn = ne.unstable_now();
      Ft = hn;
      var kn = !0;
      try {
        kn = At(!0, hn);
      } finally {
        kn ? tn() : (gt = !1, At = null);
      }
    } else
      gt = !1;
  }
  var tn;
  typeof ot == "function" ? tn = function() {
    ot(on);
  } : typeof MessageChannel < "u" ? (_n = new MessageChannel(), en = _n.port2, _n.port1.onmessage = on, tn = function() {
    en.postMessage(null);
  }) : tn = function() {
    qe(on, 0);
  };
  var _n, en;
  function dn(hn) {
    At = hn, gt || (gt = !0, tn());
  }
  function Ht(hn, kn) {
    St = qe(function() {
      hn(ne.unstable_now());
    }, kn);
  }
  ne.unstable_IdlePriority = 5, ne.unstable_ImmediatePriority = 1, ne.unstable_LowPriority = 4, ne.unstable_NormalPriority = 3, ne.unstable_Profiling = null, ne.unstable_UserBlockingPriority = 2, ne.unstable_cancelCallback = function(hn) {
    hn.callback = null;
  }, ne.unstable_continueExecution = function() {
    ze || Be || (ze = !0, dn(ht));
  }, ne.unstable_forceFrameRate = function(hn) {
    0 > hn || 125 < hn ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Nt = 0 < hn ? Math.floor(1e3 / hn) : 5;
  }, ne.unstable_getCurrentPriorityLevel = function() {
    return je;
  }, ne.unstable_getFirstCallbackNode = function() {
    return ae(Oe);
  }, ne.unstable_next = function(hn) {
    switch (je) {
      case 1:
      case 2:
      case 3:
        var kn = 3;
        break;
      default:
        kn = je;
    }
    var Dn = je;
    je = kn;
    try {
      return hn();
    } finally {
      je = Dn;
    }
  }, ne.unstable_pauseExecution = function() {
  }, ne.unstable_requestPaint = function() {
  }, ne.unstable_runWithPriority = function(hn, kn) {
    switch (hn) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        hn = 3;
    }
    var Dn = je;
    je = hn;
    try {
      return kn();
    } finally {
      je = Dn;
    }
  }, ne.unstable_scheduleCallback = function(hn, kn, Dn) {
    var yt = ne.unstable_now();
    switch (typeof Dn == "object" && Dn !== null ? (Dn = Dn.delay, Dn = typeof Dn == "number" && 0 < Dn ? yt + Dn : yt) : Dn = yt, hn) {
      case 1:
        var jt = -1;
        break;
      case 2:
        jt = 250;
        break;
      case 5:
        jt = 1073741823;
        break;
      case 4:
        jt = 1e4;
        break;
      default:
        jt = 5e3;
    }
    return jt = Dn + jt, hn = { id: Re++, callback: kn, priorityLevel: hn, startTime: Dn, expirationTime: jt, sortIndex: -1 }, Dn > yt ? (hn.sortIndex = Dn, oe($e, hn), ae(Oe) === null && hn === ae($e) && (He ? (Ye(St), St = -1) : He = !0, Ht(it, Dn - yt))) : (hn.sortIndex = jt, oe(Oe, hn), ze || Be || (ze = !0, dn(ht))), hn;
  }, ne.unstable_shouldYield = Vt, ne.unstable_wrapCallback = function(hn) {
    var kn = je;
    return function() {
      var Dn = je;
      je = kn;
      try {
        return hn.apply(this, arguments);
      } finally {
        je = Dn;
      }
    };
  };
}), s2 = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = !1, ae = !1, fe = 5;
    function ye(Bt, Kt) {
      var mn = Bt.length;
      Bt.push(Kt), xe(Bt, Kt, mn);
    }
    function we(Bt) {
      return Bt.length === 0 ? null : Bt[0];
    }
    function _e(Bt) {
      if (Bt.length === 0)
        return null;
      var Kt = Bt[0], mn = Bt.pop();
      return mn !== Kt && (Bt[0] = mn, Oe(Bt, mn, 0)), Kt;
    }
    function xe(Bt, Kt, mn) {
      for (var jn = mn; jn > 0; ) {
        var zn = jn - 1 >>> 1, qn = Bt[zn];
        if ($e(qn, Kt) > 0)
          Bt[zn] = Kt, Bt[jn] = qn, jn = zn;
        else
          return;
      }
    }
    function Oe(Bt, Kt, mn) {
      for (var jn = mn, zn = Bt.length, qn = zn >>> 1; jn < qn; ) {
        var rr = (jn + 1) * 2 - 1, or = Bt[rr], Wn = rr + 1, Ar = Bt[Wn];
        if ($e(or, Kt) < 0)
          Wn < zn && $e(Ar, or) < 0 ? (Bt[jn] = Ar, Bt[Wn] = Kt, jn = Wn) : (Bt[jn] = or, Bt[rr] = Kt, jn = rr);
        else if (Wn < zn && $e(Ar, Kt) < 0)
          Bt[jn] = Ar, Bt[Wn] = Kt, jn = Wn;
        else
          return;
      }
    }
    function $e(Bt, Kt) {
      var mn = Bt.sortIndex - Kt.sortIndex;
      return mn !== 0 ? mn : Bt.id - Kt.id;
    }
    var Re = 1, Ne = 2, je = 3, Be = 4, ze = 5, He = typeof performance == "object" && typeof performance.now == "function";
    if (He) {
      var qe = performance;
      ne.unstable_now = function() {
        return qe.now();
      };
    } else {
      var Ye = Date, ot = Ye.now();
      ne.unstable_now = function() {
        return Ye.now() - ot;
      };
    }
    var tt = 1073741823, it = -1, ht = 250, gt = 5e3, At = 1e4, St = tt, Nt = [], Ft = [], Vt = 1, on = null, tn = je, _n = !1, en = !1, dn = !1, Ht = typeof setTimeout == "function" ? setTimeout : null, hn = typeof clearTimeout == "function" ? clearTimeout : null, kn = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Dn(Bt) {
      for (var Kt = we(Ft); Kt !== null; ) {
        if (Kt.callback === null)
          _e(Ft);
        else if (Kt.startTime <= Bt)
          _e(Ft), Kt.sortIndex = Kt.expirationTime, ye(Nt, Kt);
        else
          return;
        Kt = we(Ft);
      }
    }
    function yt(Bt) {
      if (dn = !1, Dn(Bt), !en)
        if (we(Nt) !== null)
          en = !0, Go(jt);
        else {
          var Kt = we(Ft);
          Kt !== null && Yo(yt, Kt.startTime - Bt);
        }
    }
    function jt(Bt, Kt) {
      en = !1, dn && (dn = !1, Ra()), _n = !0;
      var mn = tn;
      try {
        var jn;
        if (!ae)
          return Mn(Bt, Kt);
      } finally {
        on = null, tn = mn, _n = !1;
      }
    }
    function Mn(Bt, Kt) {
      var mn = Kt;
      for (Dn(mn), on = we(Nt); on !== null && !oe && !(on.expirationTime > mn && (!Bt || na())); ) {
        var jn = on.callback;
        if (typeof jn == "function") {
          on.callback = null, tn = on.priorityLevel;
          var zn = on.expirationTime <= mn, qn = jn(zn);
          mn = ne.unstable_now(), typeof qn == "function" ? on.callback = qn : on === we(Nt) && _e(Nt), Dn(mn);
        } else
          _e(Nt);
        on = we(Nt);
      }
      if (on !== null)
        return !0;
      var rr = we(Ft);
      return rr !== null && Yo(yt, rr.startTime - mn), !1;
    }
    function $n(Bt, Kt) {
      switch (Bt) {
        case Re:
        case Ne:
        case je:
        case Be:
        case ze:
          break;
        default:
          Bt = je;
      }
      var mn = tn;
      tn = Bt;
      try {
        return Kt();
      } finally {
        tn = mn;
      }
    }
    function Zt(Bt) {
      var Kt;
      switch (tn) {
        case Re:
        case Ne:
        case je:
          Kt = je;
          break;
        default:
          Kt = tn;
          break;
      }
      var mn = tn;
      tn = Kt;
      try {
        return Bt();
      } finally {
        tn = mn;
      }
    }
    function vn(Bt) {
      var Kt = tn;
      return function() {
        var mn = tn;
        tn = Kt;
        try {
          return Bt.apply(this, arguments);
        } finally {
          tn = mn;
        }
      };
    }
    function Fn(Bt, Kt, mn) {
      var jn = ne.unstable_now(), zn;
      if (typeof mn == "object" && mn !== null) {
        var qn = mn.delay;
        typeof qn == "number" && qn > 0 ? zn = jn + qn : zn = jn;
      } else
        zn = jn;
      var rr;
      switch (Bt) {
        case Re:
          rr = it;
          break;
        case Ne:
          rr = ht;
          break;
        case ze:
          rr = St;
          break;
        case Be:
          rr = At;
          break;
        case je:
        default:
          rr = gt;
          break;
      }
      var or = zn + rr, Wn = { id: Vt++, callback: Kt, priorityLevel: Bt, startTime: zn, expirationTime: or, sortIndex: -1 };
      return zn > jn ? (Wn.sortIndex = zn, ye(Ft, Wn), we(Nt) === null && Wn === we(Ft) && (dn ? Ra() : dn = !0, Yo(yt, zn - jn))) : (Wn.sortIndex = or, ye(Nt, Wn), !en && !_n && (en = !0, Go(jt))), Wn;
    }
    function Qn() {
    }
    function Un() {
      !en && !_n && (en = !0, Go(jt));
    }
    function ar() {
      return we(Nt);
    }
    function Zo(Bt) {
      Bt.callback = null;
    }
    function ao() {
      return tn;
    }
    var Yr = !1, so = null, Io = -1, Po = fe, vo = -1;
    function na() {
      var Bt = ne.unstable_now() - vo;
      return !(Bt < Po);
    }
    function va() {
    }
    function go(Bt) {
      if (Bt < 0 || Bt > 125) {
        console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
        return;
      }
      Bt > 0 ? Po = Math.floor(1e3 / Bt) : Po = fe;
    }
    var Fo = function() {
      if (so !== null) {
        var Bt = ne.unstable_now();
        vo = Bt;
        var Kt = !0, mn = !0;
        try {
          mn = so(Kt, Bt);
        } finally {
          mn ? Ro() : (Yr = !1, so = null);
        }
      } else
        Yr = !1;
    }, Ro;
    if (typeof kn == "function")
      Ro = function() {
        kn(Fo);
      };
    else if (typeof MessageChannel < "u") {
      var la = new MessageChannel(), Ia = la.port2;
      la.port1.onmessage = Fo, Ro = function() {
        Ia.postMessage(null);
      };
    } else
      Ro = function() {
        Ht(Fo, 0);
      };
    function Go(Bt) {
      so = Bt, Yr || (Yr = !0, Ro());
    }
    function Yo(Bt, Kt) {
      Io = Ht(function() {
        Bt(ne.unstable_now());
      }, Kt);
    }
    function Ra() {
      hn(Io), Io = -1;
    }
    var Bo = va, Na = null;
    ne.unstable_IdlePriority = ze, ne.unstable_ImmediatePriority = Re, ne.unstable_LowPriority = Be, ne.unstable_NormalPriority = je, ne.unstable_Profiling = Na, ne.unstable_UserBlockingPriority = Ne, ne.unstable_cancelCallback = Zo, ne.unstable_continueExecution = Un, ne.unstable_forceFrameRate = go, ne.unstable_getCurrentPriorityLevel = ao, ne.unstable_getFirstCallbackNode = ar, ne.unstable_next = Zt, ne.unstable_pauseExecution = Qn, ne.unstable_requestPaint = Bo, ne.unstable_runWithPriority = $n, ne.unstable_scheduleCallback = Fn, ne.unstable_shouldYield = na, ne.unstable_wrapCallback = vn, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), GR = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = l2() : oe.exports = s2();
}), mz = M((ne) => {
  var oe = ir(), ae = GR();
  function fe(Se) {
    for (var Ce = "https://reactjs.org/docs/error-decoder.html?invariant=" + Se, De = 1; De < arguments.length; De++)
      Ce += "&args[]=" + encodeURIComponent(arguments[De]);
    return "Minified React error #" + Se + "; visit " + Ce + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var ye = /* @__PURE__ */ new Set(), we = {};
  function _e(Se, Ce) {
    xe(Se, Ce), xe(Se + "Capture", Ce);
  }
  function xe(Se, Ce) {
    for (we[Se] = Ce, Se = 0; Se < Ce.length; Se++)
      ye.add(Ce[Se]);
  }
  var Oe = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), $e = Object.prototype.hasOwnProperty, Re = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ne = {}, je = {};
  function Be(Se) {
    return $e.call(je, Se) ? !0 : $e.call(Ne, Se) ? !1 : Re.test(Se) ? je[Se] = !0 : (Ne[Se] = !0, !1);
  }
  function ze(Se, Ce, De, Ue) {
    if (De !== null && De.type === 0)
      return !1;
    switch (typeof Ce) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return Ue ? !1 : De !== null ? !De.acceptsBooleans : (Se = Se.toLowerCase().slice(0, 5), Se !== "data-" && Se !== "aria-");
      default:
        return !1;
    }
  }
  function He(Se, Ce, De, Ue) {
    if (Ce === null || typeof Ce > "u" || ze(Se, Ce, De, Ue))
      return !0;
    if (Ue)
      return !1;
    if (De !== null)
      switch (De.type) {
        case 3:
          return !Ce;
        case 4:
          return Ce === !1;
        case 5:
          return isNaN(Ce);
        case 6:
          return isNaN(Ce) || 1 > Ce;
      }
    return !1;
  }
  function qe(Se, Ce, De, Ue, Qe, et, bt) {
    this.acceptsBooleans = Ce === 2 || Ce === 3 || Ce === 4, this.attributeName = Ue, this.attributeNamespace = Qe, this.mustUseProperty = De, this.propertyName = Se, this.type = Ce, this.sanitizeURL = et, this.removeEmptyString = bt;
  }
  var Ye = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(Se) {
    Ye[Se] = new qe(Se, 0, !1, Se, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(Se) {
    var Ce = Se[0];
    Ye[Ce] = new qe(Ce, 1, !1, Se[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 2, !1, Se.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 2, !1, Se, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(Se) {
    Ye[Se] = new qe(Se, 3, !1, Se.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 3, !0, Se, null, !1, !1);
  }), ["capture", "download"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 4, !1, Se, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 6, !1, Se, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 5, !1, Se.toLowerCase(), null, !1, !1);
  });
  var ot = /[\-:]([a-z])/g;
  function tt(Se) {
    return Se[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(Se) {
    var Ce = Se.replace(ot, tt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(Se) {
    var Ce = Se.replace(ot, tt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(Se) {
    var Ce = Se.replace(ot, tt);
    Ye[Ce] = new qe(Ce, 1, !1, Se, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 1, !1, Se.toLowerCase(), null, !1, !1);
  }), Ye.xlinkHref = new qe("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(Se) {
    Ye[Se] = new qe(Se, 1, !1, Se.toLowerCase(), null, !0, !0);
  });
  function it(Se, Ce, De, Ue) {
    var Qe = Ye.hasOwnProperty(Ce) ? Ye[Ce] : null;
    (Qe !== null ? Qe.type !== 0 : Ue || !(2 < Ce.length) || Ce[0] !== "o" && Ce[0] !== "O" || Ce[1] !== "n" && Ce[1] !== "N") && (He(Ce, De, Qe, Ue) && (De = null), Ue || Qe === null ? Be(Ce) && (De === null ? Se.removeAttribute(Ce) : Se.setAttribute(Ce, "" + De)) : Qe.mustUseProperty ? Se[Qe.propertyName] = De === null ? Qe.type === 3 ? !1 : "" : De : (Ce = Qe.attributeName, Ue = Qe.attributeNamespace, De === null ? Se.removeAttribute(Ce) : (Qe = Qe.type, De = Qe === 3 || Qe === 4 && De === !0 ? "" : "" + De, Ue ? Se.setAttributeNS(Ue, Ce, De) : Se.setAttribute(Ce, De))));
  }
  var ht = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, gt = Symbol.for("react.element"), At = Symbol.for("react.portal"), St = Symbol.for("react.fragment"), Nt = Symbol.for("react.strict_mode"), Ft = Symbol.for("react.profiler"), Vt = Symbol.for("react.provider"), on = Symbol.for("react.context"), tn = Symbol.for("react.forward_ref"), _n = Symbol.for("react.suspense"), en = Symbol.for("react.suspense_list"), dn = Symbol.for("react.memo"), Ht = Symbol.for("react.lazy"), hn = Symbol.for("react.offscreen"), kn = Symbol.iterator;
  function Dn(Se) {
    return Se === null || typeof Se != "object" ? null : (Se = kn && Se[kn] || Se["@@iterator"], typeof Se == "function" ? Se : null);
  }
  var yt = Object.assign, jt;
  function Mn(Se) {
    if (jt === void 0)
      try {
        throw Error();
      } catch (De) {
        var Ce = De.stack.trim().match(/\n( *(at )?)/);
        jt = Ce && Ce[1] || "";
      }
    return `
` + jt + Se;
  }
  var $n = !1;
  function Zt(Se, Ce) {
    if (!Se || $n)
      return "";
    $n = !0;
    var De = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (Ce)
        if (Ce = function() {
          throw Error();
        }, Object.defineProperty(Ce.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(Ce, []);
          } catch (bn) {
            var Ue = bn;
          }
          Reflect.construct(Se, [], Ce);
        } else {
          try {
            Ce.call();
          } catch (bn) {
            Ue = bn;
          }
          Se.call(Ce.prototype);
        }
      else {
        try {
          throw Error();
        } catch (bn) {
          Ue = bn;
        }
        Se();
      }
    } catch (bn) {
      if (bn && Ue && typeof bn.stack == "string") {
        for (var Qe = bn.stack.split(`
`), et = Ue.stack.split(`
`), bt = Qe.length - 1, It = et.length - 1; 1 <= bt && 0 <= It && Qe[bt] !== et[It]; )
          It--;
        for (; 1 <= bt && 0 <= It; bt--, It--)
          if (Qe[bt] !== et[It]) {
            if (bt !== 1 || It !== 1)
              do
                if (bt--, It--, 0 > It || Qe[bt] !== et[It]) {
                  var Ut = `
` + Qe[bt].replace(" at new ", " at ");
                  return Se.displayName && Ut.includes("<anonymous>") && (Ut = Ut.replace("<anonymous>", Se.displayName)), Ut;
                }
              while (1 <= bt && 0 <= It);
            break;
          }
      }
    } finally {
      $n = !1, Error.prepareStackTrace = De;
    }
    return (Se = Se ? Se.displayName || Se.name : "") ? Mn(Se) : "";
  }
  function vn(Se) {
    switch (Se.tag) {
      case 5:
        return Mn(Se.type);
      case 16:
        return Mn("Lazy");
      case 13:
        return Mn("Suspense");
      case 19:
        return Mn("SuspenseList");
      case 0:
      case 2:
      case 15:
        return Se = Zt(Se.type, !1), Se;
      case 11:
        return Se = Zt(Se.type.render, !1), Se;
      case 1:
        return Se = Zt(Se.type, !0), Se;
      default:
        return "";
    }
  }
  function Fn(Se) {
    if (Se == null)
      return null;
    if (typeof Se == "function")
      return Se.displayName || Se.name || null;
    if (typeof Se == "string")
      return Se;
    switch (Se) {
      case St:
        return "Fragment";
      case At:
        return "Portal";
      case Ft:
        return "Profiler";
      case Nt:
        return "StrictMode";
      case _n:
        return "Suspense";
      case en:
        return "SuspenseList";
    }
    if (typeof Se == "object")
      switch (Se.$$typeof) {
        case on:
          return (Se.displayName || "Context") + ".Consumer";
        case Vt:
          return (Se._context.displayName || "Context") + ".Provider";
        case tn:
          var Ce = Se.render;
          return Se = Se.displayName, Se || (Se = Ce.displayName || Ce.name || "", Se = Se !== "" ? "ForwardRef(" + Se + ")" : "ForwardRef"), Se;
        case dn:
          return Ce = Se.displayName || null, Ce !== null ? Ce : Fn(Se.type) || "Memo";
        case Ht:
          Ce = Se._payload, Se = Se._init;
          try {
            return Fn(Se(Ce));
          } catch {
          }
      }
    return null;
  }
  function Qn(Se) {
    var Ce = Se.type;
    switch (Se.tag) {
      case 24:
        return "Cache";
      case 9:
        return (Ce.displayName || "Context") + ".Consumer";
      case 10:
        return (Ce._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return Se = Ce.render, Se = Se.displayName || Se.name || "", Ce.displayName || (Se !== "" ? "ForwardRef(" + Se + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return Ce;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Fn(Ce);
      case 8:
        return Ce === Nt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof Ce == "function")
          return Ce.displayName || Ce.name || null;
        if (typeof Ce == "string")
          return Ce;
    }
    return null;
  }
  function Un(Se) {
    switch (typeof Se) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return Se;
      case "object":
        return Se;
      default:
        return "";
    }
  }
  function ar(Se) {
    var Ce = Se.type;
    return (Se = Se.nodeName) && Se.toLowerCase() === "input" && (Ce === "checkbox" || Ce === "radio");
  }
  function Zo(Se) {
    var Ce = ar(Se) ? "checked" : "value", De = Object.getOwnPropertyDescriptor(Se.constructor.prototype, Ce), Ue = "" + Se[Ce];
    if (!Se.hasOwnProperty(Ce) && typeof De < "u" && typeof De.get == "function" && typeof De.set == "function") {
      var Qe = De.get, et = De.set;
      return Object.defineProperty(Se, Ce, { configurable: !0, get: function() {
        return Qe.call(this);
      }, set: function(bt) {
        Ue = "" + bt, et.call(this, bt);
      } }), Object.defineProperty(Se, Ce, { enumerable: De.enumerable }), { getValue: function() {
        return Ue;
      }, setValue: function(bt) {
        Ue = "" + bt;
      }, stopTracking: function() {
        Se._valueTracker = null, delete Se[Ce];
      } };
    }
  }
  function ao(Se) {
    Se._valueTracker || (Se._valueTracker = Zo(Se));
  }
  function Yr(Se) {
    if (!Se)
      return !1;
    var Ce = Se._valueTracker;
    if (!Ce)
      return !0;
    var De = Ce.getValue(), Ue = "";
    return Se && (Ue = ar(Se) ? Se.checked ? "true" : "false" : Se.value), Se = Ue, Se !== De ? (Ce.setValue(Se), !0) : !1;
  }
  function so(Se) {
    if (Se = Se || (typeof document < "u" ? document : void 0), typeof Se > "u")
      return null;
    try {
      return Se.activeElement || Se.body;
    } catch {
      return Se.body;
    }
  }
  function Io(Se, Ce) {
    var De = Ce.checked;
    return yt({}, Ce, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: De ?? Se._wrapperState.initialChecked });
  }
  function Po(Se, Ce) {
    var De = Ce.defaultValue == null ? "" : Ce.defaultValue, Ue = Ce.checked != null ? Ce.checked : Ce.defaultChecked;
    De = Un(Ce.value != null ? Ce.value : De), Se._wrapperState = { initialChecked: Ue, initialValue: De, controlled: Ce.type === "checkbox" || Ce.type === "radio" ? Ce.checked != null : Ce.value != null };
  }
  function vo(Se, Ce) {
    Ce = Ce.checked, Ce != null && it(Se, "checked", Ce, !1);
  }
  function na(Se, Ce) {
    vo(Se, Ce);
    var De = Un(Ce.value), Ue = Ce.type;
    if (De != null)
      Ue === "number" ? (De === 0 && Se.value === "" || Se.value != De) && (Se.value = "" + De) : Se.value !== "" + De && (Se.value = "" + De);
    else if (Ue === "submit" || Ue === "reset") {
      Se.removeAttribute("value");
      return;
    }
    Ce.hasOwnProperty("value") ? go(Se, Ce.type, De) : Ce.hasOwnProperty("defaultValue") && go(Se, Ce.type, Un(Ce.defaultValue)), Ce.checked == null && Ce.defaultChecked != null && (Se.defaultChecked = !!Ce.defaultChecked);
  }
  function va(Se, Ce, De) {
    if (Ce.hasOwnProperty("value") || Ce.hasOwnProperty("defaultValue")) {
      var Ue = Ce.type;
      if (!(Ue !== "submit" && Ue !== "reset" || Ce.value !== void 0 && Ce.value !== null))
        return;
      Ce = "" + Se._wrapperState.initialValue, De || Ce === Se.value || (Se.value = Ce), Se.defaultValue = Ce;
    }
    De = Se.name, De !== "" && (Se.name = ""), Se.defaultChecked = !!Se._wrapperState.initialChecked, De !== "" && (Se.name = De);
  }
  function go(Se, Ce, De) {
    (Ce !== "number" || so(Se.ownerDocument) !== Se) && (De == null ? Se.defaultValue = "" + Se._wrapperState.initialValue : Se.defaultValue !== "" + De && (Se.defaultValue = "" + De));
  }
  var Fo = Array.isArray;
  function Ro(Se, Ce, De, Ue) {
    if (Se = Se.options, Ce) {
      Ce = {};
      for (var Qe = 0; Qe < De.length; Qe++)
        Ce["$" + De[Qe]] = !0;
      for (De = 0; De < Se.length; De++)
        Qe = Ce.hasOwnProperty("$" + Se[De].value), Se[De].selected !== Qe && (Se[De].selected = Qe), Qe && Ue && (Se[De].defaultSelected = !0);
    } else {
      for (De = "" + Un(De), Ce = null, Qe = 0; Qe < Se.length; Qe++) {
        if (Se[Qe].value === De) {
          Se[Qe].selected = !0, Ue && (Se[Qe].defaultSelected = !0);
          return;
        }
        Ce !== null || Se[Qe].disabled || (Ce = Se[Qe]);
      }
      Ce !== null && (Ce.selected = !0);
    }
  }
  function la(Se, Ce) {
    if (Ce.dangerouslySetInnerHTML != null)
      throw Error(fe(91));
    return yt({}, Ce, { value: void 0, defaultValue: void 0, children: "" + Se._wrapperState.initialValue });
  }
  function Ia(Se, Ce) {
    var De = Ce.value;
    if (De == null) {
      if (De = Ce.children, Ce = Ce.defaultValue, De != null) {
        if (Ce != null)
          throw Error(fe(92));
        if (Fo(De)) {
          if (1 < De.length)
            throw Error(fe(93));
          De = De[0];
        }
        Ce = De;
      }
      Ce == null && (Ce = ""), De = Ce;
    }
    Se._wrapperState = { initialValue: Un(De) };
  }
  function Go(Se, Ce) {
    var De = Un(Ce.value), Ue = Un(Ce.defaultValue);
    De != null && (De = "" + De, De !== Se.value && (Se.value = De), Ce.defaultValue == null && Se.defaultValue !== De && (Se.defaultValue = De)), Ue != null && (Se.defaultValue = "" + Ue);
  }
  function Yo(Se) {
    var Ce = Se.textContent;
    Ce === Se._wrapperState.initialValue && Ce !== "" && Ce !== null && (Se.value = Ce);
  }
  function Ra(Se) {
    switch (Se) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Bo(Se, Ce) {
    return Se == null || Se === "http://www.w3.org/1999/xhtml" ? Ra(Ce) : Se === "http://www.w3.org/2000/svg" && Ce === "foreignObject" ? "http://www.w3.org/1999/xhtml" : Se;
  }
  var Na, Bt = function(Se) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(Ce, De, Ue, Qe) {
      MSApp.execUnsafeLocalFunction(function() {
        return Se(Ce, De, Ue, Qe);
      });
    } : Se;
  }(function(Se, Ce) {
    if (Se.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in Se)
      Se.innerHTML = Ce;
    else {
      for (Na = Na || document.createElement("div"), Na.innerHTML = "<svg>" + Ce.valueOf().toString() + "</svg>", Ce = Na.firstChild; Se.firstChild; )
        Se.removeChild(Se.firstChild);
      for (; Ce.firstChild; )
        Se.appendChild(Ce.firstChild);
    }
  });
  function Kt(Se, Ce) {
    if (Ce) {
      var De = Se.firstChild;
      if (De && De === Se.lastChild && De.nodeType === 3) {
        De.nodeValue = Ce;
        return;
      }
    }
    Se.textContent = Ce;
  }
  var mn = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, jn = ["Webkit", "ms", "Moz", "O"];
  Object.keys(mn).forEach(function(Se) {
    jn.forEach(function(Ce) {
      Ce = Ce + Se.charAt(0).toUpperCase() + Se.substring(1), mn[Ce] = mn[Se];
    });
  });
  function zn(Se, Ce, De) {
    return Ce == null || typeof Ce == "boolean" || Ce === "" ? "" : De || typeof Ce != "number" || Ce === 0 || mn.hasOwnProperty(Se) && mn[Se] ? ("" + Ce).trim() : Ce + "px";
  }
  function qn(Se, Ce) {
    Se = Se.style;
    for (var De in Ce)
      if (Ce.hasOwnProperty(De)) {
        var Ue = De.indexOf("--") === 0, Qe = zn(De, Ce[De], Ue);
        De === "float" && (De = "cssFloat"), Ue ? Se.setProperty(De, Qe) : Se[De] = Qe;
      }
  }
  var rr = yt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function or(Se, Ce) {
    if (Ce) {
      if (rr[Se] && (Ce.children != null || Ce.dangerouslySetInnerHTML != null))
        throw Error(fe(137, Se));
      if (Ce.dangerouslySetInnerHTML != null) {
        if (Ce.children != null)
          throw Error(fe(60));
        if (typeof Ce.dangerouslySetInnerHTML != "object" || !("__html" in Ce.dangerouslySetInnerHTML))
          throw Error(fe(61));
      }
      if (Ce.style != null && typeof Ce.style != "object")
        throw Error(fe(62));
    }
  }
  function Wn(Se, Ce) {
    if (Se.indexOf("-") === -1)
      return typeof Ce.is == "string";
    switch (Se) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Ar = null;
  function Br(Se) {
    return Se = Se.target || Se.srcElement || window, Se.correspondingUseElement && (Se = Se.correspondingUseElement), Se.nodeType === 3 ? Se.parentNode : Se;
  }
  var wo = null, wr = null, _r = null;
  function To(Se) {
    if (Se = xp(Se)) {
      if (typeof wo != "function")
        throw Error(fe(280));
      var Ce = Se.stateNode;
      Ce && (Ce = Sr(Ce), wo(Se.stateNode, Se.type, Ce));
    }
  }
  function Ha(Se) {
    wr ? _r ? _r.push(Se) : _r = [Se] : wr = Se;
  }
  function Bi() {
    if (wr) {
      var Se = wr, Ce = _r;
      if (_r = wr = null, To(Se), Ce)
        for (Se = 0; Se < Ce.length; Se++)
          To(Ce[Se]);
    }
  }
  function Ui(Se, Ce) {
    return Se(Ce);
  }
  function qa() {
  }
  var si = !1;
  function ra(Se, Ce, De) {
    if (si)
      return Se(Ce, De);
    si = !0;
    try {
      return Ui(Se, Ce, De);
    } finally {
      si = !1, (wr !== null || _r !== null) && (qa(), Bi());
    }
  }
  function Ta(Se, Ce) {
    var De = Se.stateNode;
    if (De === null)
      return null;
    var Ue = Sr(De);
    if (Ue === null)
      return null;
    De = Ue[Ce];
    e:
      switch (Ce) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (Ue = !Ue.disabled) || (Se = Se.type, Ue = !(Se === "button" || Se === "input" || Se === "select" || Se === "textarea")), Se = !Ue;
          break e;
        default:
          Se = !1;
      }
    if (Se)
      return null;
    if (De && typeof De != "function")
      throw Error(fe(231, Ce, typeof De));
    return De;
  }
  var ci = !1;
  if (Oe)
    try {
      wa = {}, Object.defineProperty(wa, "passive", { get: function() {
        ci = !0;
      } }), window.addEventListener("test", wa, wa), window.removeEventListener("test", wa, wa);
    } catch {
      ci = !1;
    }
  var wa;
  function fo(Se, Ce, De, Ue, Qe, et, bt, It, Ut) {
    var bn = Array.prototype.slice.call(arguments, 3);
    try {
      Ce.apply(De, bn);
    } catch (Rn) {
      this.onError(Rn);
    }
  }
  var _o = !1, oa = null, Ma = !1, Rt = null, Cn = { onError: function(Se) {
    _o = !0, oa = Se;
  } };
  function Pn(Se, Ce, De, Ue, Qe, et, bt, It, Ut) {
    _o = !1, oa = null, fo.apply(Cn, arguments);
  }
  function hr(Se, Ce, De, Ue, Qe, et, bt, It, Ut) {
    if (Pn.apply(this, arguments), _o) {
      if (_o) {
        var bn = oa;
        _o = !1, oa = null;
      } else
        throw Error(fe(198));
      Ma || (Ma = !0, Rt = bn);
    }
  }
  function Dr(Se) {
    var Ce = Se, De = Se;
    if (Se.alternate)
      for (; Ce.return; )
        Ce = Ce.return;
    else {
      Se = Ce;
      do
        Ce = Se, Ce.flags & 4098 && (De = Ce.return), Se = Ce.return;
      while (Se);
    }
    return Ce.tag === 3 ? De : null;
  }
  function Jr(Se) {
    if (Se.tag === 13) {
      var Ce = Se.memoizedState;
      if (Ce === null && (Se = Se.alternate, Se !== null && (Ce = Se.memoizedState)), Ce !== null)
        return Ce.dehydrated;
    }
    return null;
  }
  function zr(Se) {
    if (Dr(Se) !== Se)
      throw Error(fe(188));
  }
  function gr(Se) {
    var Ce = Se.alternate;
    if (!Ce) {
      if (Ce = Dr(Se), Ce === null)
        throw Error(fe(188));
      return Ce !== Se ? null : Se;
    }
    for (var De = Se, Ue = Ce; ; ) {
      var Qe = De.return;
      if (Qe === null)
        break;
      var et = Qe.alternate;
      if (et === null) {
        if (Ue = Qe.return, Ue !== null) {
          De = Ue;
          continue;
        }
        break;
      }
      if (Qe.child === et.child) {
        for (et = Qe.child; et; ) {
          if (et === De)
            return zr(Qe), Se;
          if (et === Ue)
            return zr(Qe), Ce;
          et = et.sibling;
        }
        throw Error(fe(188));
      }
      if (De.return !== Ue.return)
        De = Qe, Ue = et;
      else {
        for (var bt = !1, It = Qe.child; It; ) {
          if (It === De) {
            bt = !0, De = Qe, Ue = et;
            break;
          }
          if (It === Ue) {
            bt = !0, Ue = Qe, De = et;
            break;
          }
          It = It.sibling;
        }
        if (!bt) {
          for (It = et.child; It; ) {
            if (It === De) {
              bt = !0, De = et, Ue = Qe;
              break;
            }
            if (It === Ue) {
              bt = !0, Ue = et, De = Qe;
              break;
            }
            It = It.sibling;
          }
          if (!bt)
            throw Error(fe(189));
        }
      }
      if (De.alternate !== Ue)
        throw Error(fe(190));
    }
    if (De.tag !== 3)
      throw Error(fe(188));
    return De.stateNode.current === De ? Se : Ce;
  }
  function aa(Se) {
    return Se = gr(Se), Se !== null ? Oo(Se) : null;
  }
  function Oo(Se) {
    if (Se.tag === 5 || Se.tag === 6)
      return Se;
    for (Se = Se.child; Se !== null; ) {
      var Ce = Oo(Se);
      if (Ce !== null)
        return Ce;
      Se = Se.sibling;
    }
    return null;
  }
  var Ao = ae.unstable_scheduleCallback, ka = ae.unstable_cancelCallback, ys = ae.unstable_shouldYield, Qu = ae.unstable_requestPaint, uo = ae.unstable_now, nd = ae.unstable_getCurrentPriorityLevel, Yi = ae.unstable_ImmediatePriority, Wr = ae.unstable_UserBlockingPriority, Ea = ae.unstable_NormalPriority, Ku = ae.unstable_LowPriority, Fu = ae.unstable_IdlePriority, Ms = null, Ka = null;
  function Xu(Se) {
    if (Ka && typeof Ka.onCommitFiberRoot == "function")
      try {
        Ka.onCommitFiberRoot(Ms, Se, void 0, (Se.current.flags & 128) === 128);
      } catch {
      }
  }
  var ja = Math.clz32 ? Math.clz32 : rd, Ju = Math.log, el = Math.LN2;
  function rd(Se) {
    return Se >>>= 0, Se === 0 ? 32 : 31 - (Ju(Se) / el | 0) | 0;
  }
  var tl = 64, Vi = 4194304;
  function gi(Se) {
    switch (Se & -Se) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return Se & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return Se & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return Se;
    }
  }
  function ca(Se, Ce) {
    var De = Se.pendingLanes;
    if (De === 0)
      return 0;
    var Ue = 0, Qe = Se.suspendedLanes, et = Se.pingedLanes, bt = De & 268435455;
    if (bt !== 0) {
      var It = bt & ~Qe;
      It !== 0 ? Ue = gi(It) : (et &= bt, et !== 0 && (Ue = gi(et)));
    } else
      bt = De & ~Qe, bt !== 0 ? Ue = gi(bt) : et !== 0 && (Ue = gi(et));
    if (Ue === 0)
      return 0;
    if (Ce !== 0 && Ce !== Ue && !(Ce & Qe) && (Qe = Ue & -Ue, et = Ce & -Ce, Qe >= et || Qe === 16 && (et & 4194240) !== 0))
      return Ce;
    if (Ue & 4 && (Ue |= De & 16), Ce = Se.entangledLanes, Ce !== 0)
      for (Se = Se.entanglements, Ce &= Ue; 0 < Ce; )
        De = 31 - ja(Ce), Qe = 1 << De, Ue |= Se[De], Ce &= ~Qe;
    return Ue;
  }
  function js(Se, Ce) {
    switch (Se) {
      case 1:
      case 2:
      case 4:
        return Ce + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return Ce + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Hi(Se, Ce) {
    for (var De = Se.suspendedLanes, Ue = Se.pingedLanes, Qe = Se.expirationTimes, et = Se.pendingLanes; 0 < et; ) {
      var bt = 31 - ja(et), It = 1 << bt, Ut = Qe[bt];
      Ut === -1 ? (!(It & De) || It & Ue) && (Qe[bt] = js(It, Ce)) : Ut <= Ce && (Se.expiredLanes |= It), et &= ~It;
    }
  }
  function gl(Se) {
    return Se = Se.pendingLanes & -1073741825, Se !== 0 ? Se : Se & 1073741824 ? 1073741824 : 0;
  }
  function ru() {
    var Se = tl;
    return tl <<= 1, !(tl & 4194240) && (tl = 64), Se;
  }
  function wl(Se) {
    for (var Ce = [], De = 0; 31 > De; De++)
      Ce.push(Se);
    return Ce;
  }
  function Ds(Se, Ce, De) {
    Se.pendingLanes |= Ce, Ce !== 536870912 && (Se.suspendedLanes = 0, Se.pingedLanes = 0), Se = Se.eventTimes, Ce = 31 - ja(Ce), Se[Ce] = De;
  }
  function Ls(Se, Ce) {
    var De = Se.pendingLanes & ~Ce;
    Se.pendingLanes = Ce, Se.suspendedLanes = 0, Se.pingedLanes = 0, Se.expiredLanes &= Ce, Se.mutableReadLanes &= Ce, Se.entangledLanes &= Ce, Ce = Se.entanglements;
    var Ue = Se.eventTimes;
    for (Se = Se.expirationTimes; 0 < De; ) {
      var Qe = 31 - ja(De), et = 1 << Qe;
      Ce[Qe] = 0, Ue[Qe] = -1, Se[Qe] = -1, De &= ~et;
    }
  }
  function Fs(Se, Ce) {
    var De = Se.entangledLanes |= Ce;
    for (Se = Se.entanglements; De; ) {
      var Ue = 31 - ja(De), Qe = 1 << Ue;
      Qe & Ce | Se[Ue] & Ce && (Se[Ue] |= Ce), De &= ~Qe;
    }
  }
  var po = 0;
  function ts(Se) {
    return Se &= -Se, 1 < Se ? 4 < Se ? Se & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var fc, Da, ho, nl, _l, Mr = !1, Bs = [], Wo = null, La = null, Fa = null, zs = /* @__PURE__ */ new Map(), Qo = /* @__PURE__ */ new Map(), mo = [], El = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function wi(Se, Ce) {
    switch (Se) {
      case "focusin":
      case "focusout":
        Wo = null;
        break;
      case "dragenter":
      case "dragleave":
        La = null;
        break;
      case "mouseover":
      case "mouseout":
        Fa = null;
        break;
      case "pointerover":
      case "pointerout":
        zs.delete(Ce.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Qo.delete(Ce.pointerId);
    }
  }
  function xa(Se, Ce, De, Ue, Qe, et) {
    return Se === null || Se.nativeEvent !== et ? (Se = { blockedOn: Ce, domEventName: De, eventSystemFlags: Ue, nativeEvent: et, targetContainers: [Qe] }, Ce !== null && (Ce = xp(Ce), Ce !== null && Da(Ce)), Se) : (Se.eventSystemFlags |= Ue, Ce = Se.targetContainers, Qe !== null && Ce.indexOf(Qe) === -1 && Ce.push(Qe), Se);
  }
  function bs(Se, Ce, De, Ue, Qe) {
    switch (Ce) {
      case "focusin":
        return Wo = xa(Wo, Se, Ce, De, Ue, Qe), !0;
      case "dragenter":
        return La = xa(La, Se, Ce, De, Ue, Qe), !0;
      case "mouseover":
        return Fa = xa(Fa, Se, Ce, De, Ue, Qe), !0;
      case "pointerover":
        var et = Qe.pointerId;
        return zs.set(et, xa(zs.get(et) || null, Se, Ce, De, Ue, Qe)), !0;
      case "gotpointercapture":
        return et = Qe.pointerId, Qo.set(et, xa(Qo.get(et) || null, Se, Ce, De, Ue, Qe)), !0;
    }
    return !1;
  }
  function rl(Se) {
    var Ce = lu(Se.target);
    if (Ce !== null) {
      var De = Dr(Ce);
      if (De !== null) {
        if (Ce = De.tag, Ce === 13) {
          if (Ce = Jr(De), Ce !== null) {
            Se.blockedOn = Ce, _l(Se.priority, function() {
              ho(De);
            });
            return;
          }
        } else if (Ce === 3 && De.stateNode.current.memoizedState.isDehydrated) {
          Se.blockedOn = De.tag === 3 ? De.stateNode.containerInfo : null;
          return;
        }
      }
    }
    Se.blockedOn = null;
  }
  function di(Se) {
    if (Se.blockedOn !== null)
      return !1;
    for (var Ce = Se.targetContainers; 0 < Ce.length; ) {
      var De = al(Se.domEventName, Se.eventSystemFlags, Ce[0], Se.nativeEvent);
      if (De === null) {
        De = Se.nativeEvent;
        var Ue = new De.constructor(De.type, De);
        Ar = Ue, De.target.dispatchEvent(Ue), Ar = null;
      } else
        return Ce = xp(De), Ce !== null && Da(Ce), Se.blockedOn = De, !1;
      Ce.shift();
    }
    return !0;
  }
  function xl(Se, Ce, De) {
    di(Se) && De.delete(Ce);
  }
  function fi() {
    Mr = !1, Wo !== null && di(Wo) && (Wo = null), La !== null && di(La) && (La = null), Fa !== null && di(Fa) && (Fa = null), zs.forEach(xl), Qo.forEach(xl);
  }
  function Us(Se, Ce) {
    Se.blockedOn === Ce && (Se.blockedOn = null, Mr || (Mr = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, fi)));
  }
  function ou(Se) {
    function Ce(Qe) {
      return Us(Qe, Se);
    }
    if (0 < Bs.length) {
      Us(Bs[0], Se);
      for (var De = 1; De < Bs.length; De++) {
        var Ue = Bs[De];
        Ue.blockedOn === Se && (Ue.blockedOn = null);
      }
    }
    for (Wo !== null && Us(Wo, Se), La !== null && Us(La, Se), Fa !== null && Us(Fa, Se), zs.forEach(Ce), Qo.forEach(Ce), De = 0; De < mo.length; De++)
      Ue = mo[De], Ue.blockedOn === Se && (Ue.blockedOn = null);
    for (; 0 < mo.length && (De = mo[0], De.blockedOn === null); )
      rl(De), De.blockedOn === null && mo.shift();
  }
  var pi = ht.ReactCurrentBatchConfig, Ei = !0;
  function au(Se, Ce, De, Ue) {
    var Qe = po, et = pi.transition;
    pi.transition = null;
    try {
      po = 1, ol(Se, Ce, De, Ue);
    } finally {
      po = Qe, pi.transition = et;
    }
  }
  function vs(Se, Ce, De, Ue) {
    var Qe = po, et = pi.transition;
    pi.transition = null;
    try {
      po = 4, ol(Se, Ce, De, Ue);
    } finally {
      po = Qe, pi.transition = et;
    }
  }
  function ol(Se, Ce, De, Ue) {
    if (Ei) {
      var Qe = al(Se, Ce, De, Ue);
      if (Qe === null)
        hm(Se, Ce, Ue, Bu, De), wi(Se, Ue);
      else if (bs(Qe, Se, Ce, De, Ue))
        Ue.stopPropagation();
      else if (wi(Se, Ue), Ce & 4 && -1 < El.indexOf(Se)) {
        for (; Qe !== null; ) {
          var et = xp(Qe);
          if (et !== null && fc(et), et = al(Se, Ce, De, Ue), et === null && hm(Se, Ce, Ue, Bu, De), et === Qe)
            break;
          Qe = et;
        }
        Qe !== null && Ue.stopPropagation();
      } else
        hm(Se, Ce, Ue, null, De);
    }
  }
  var Bu = null;
  function al(Se, Ce, De, Ue) {
    if (Bu = null, Se = Br(Ue), Se = lu(Se), Se !== null)
      if (Ce = Dr(Se), Ce === null)
        Se = null;
      else if (De = Ce.tag, De === 13) {
        if (Se = Jr(Ce), Se !== null)
          return Se;
        Se = null;
      } else if (De === 3) {
        if (Ce.stateNode.current.memoizedState.isDehydrated)
          return Ce.tag === 3 ? Ce.stateNode.containerInfo : null;
        Se = null;
      } else
        Ce !== Se && (Se = null);
    return Bu = Se, null;
  }
  function Sl(Se) {
    switch (Se) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (nd()) {
          case Yi:
            return 1;
          case Wr:
            return 4;
          case Ea:
          case Ku:
            return 16;
          case Fu:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ge = null, dt = null, Ot = null;
  function $t() {
    if (Ot)
      return Ot;
    var Se, Ce = dt, De = Ce.length, Ue, Qe = "value" in Ge ? Ge.value : Ge.textContent, et = Qe.length;
    for (Se = 0; Se < De && Ce[Se] === Qe[Se]; Se++)
      ;
    var bt = De - Se;
    for (Ue = 1; Ue <= bt && Ce[De - Ue] === Qe[et - Ue]; Ue++)
      ;
    return Ot = Qe.slice(Se, 1 < Ue ? 1 - Ue : void 0);
  }
  function Xt(Se) {
    var Ce = Se.keyCode;
    return "charCode" in Se ? (Se = Se.charCode, Se === 0 && Ce === 13 && (Se = 13)) : Se = Ce, Se === 10 && (Se = 13), 32 <= Se || Se === 13 ? Se : 0;
  }
  function An() {
    return !0;
  }
  function gn() {
    return !1;
  }
  function In(Se) {
    function Ce(De, Ue, Qe, et, bt) {
      this._reactName = De, this._targetInst = Qe, this.type = Ue, this.nativeEvent = et, this.target = bt, this.currentTarget = null;
      for (var It in Se)
        Se.hasOwnProperty(It) && (De = Se[It], this[It] = De ? De(et) : et[It]);
      return this.isDefaultPrevented = (et.defaultPrevented != null ? et.defaultPrevented : et.returnValue === !1) ? An : gn, this.isPropagationStopped = gn, this;
    }
    return yt(Ce.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var De = this.nativeEvent;
      De && (De.preventDefault ? De.preventDefault() : typeof De.returnValue != "unknown" && (De.returnValue = !1), this.isDefaultPrevented = An);
    }, stopPropagation: function() {
      var De = this.nativeEvent;
      De && (De.stopPropagation ? De.stopPropagation() : typeof De.cancelBubble != "unknown" && (De.cancelBubble = !0), this.isPropagationStopped = An);
    }, persist: function() {
    }, isPersistent: An }), Ce;
  }
  var Zn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(Se) {
    return Se.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, br = In(Zn), Er = yt({}, Zn, { view: 0, detail: 0 }), Cr = In(Er), Ir, Vr, Kr, No = yt({}, Er, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Qy, button: 0, buttons: 0, relatedTarget: function(Se) {
    return Se.relatedTarget === void 0 ? Se.fromElement === Se.srcElement ? Se.toElement : Se.fromElement : Se.relatedTarget;
  }, movementX: function(Se) {
    return "movementX" in Se ? Se.movementX : (Se !== Kr && (Kr && Se.type === "mousemove" ? (Ir = Se.screenX - Kr.screenX, Vr = Se.screenY - Kr.screenY) : Vr = Ir = 0, Kr = Se), Ir);
  }, movementY: function(Se) {
    return "movementY" in Se ? Se.movementY : Vr;
  } }), iu = In(No), pc = yt({}, No, { dataTransfer: 0 }), sf = In(pc), od = yt({}, Er, { relatedTarget: 0 }), su = In(od), Pl = yt({}, Zn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), uf = In(Pl), n_ = yt({}, Zn, { clipboardData: function(Se) {
    return "clipboardData" in Se ? Se.clipboardData : window.clipboardData;
  } }), r_ = In(n_), o_ = yt({}, Zn, { data: 0 }), Gy = In(o_), Yy = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Zv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Gv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Yv(Se) {
    var Ce = this.nativeEvent;
    return Ce.getModifierState ? Ce.getModifierState(Se) : (Se = Gv[Se]) ? !!Ce[Se] : !1;
  }
  function Qy() {
    return Yv;
  }
  var Tl = yt({}, Er, { key: function(Se) {
    if (Se.key) {
      var Ce = Yy[Se.key] || Se.key;
      if (Ce !== "Unidentified")
        return Ce;
    }
    return Se.type === "keypress" ? (Se = Xt(Se), Se === 13 ? "Enter" : String.fromCharCode(Se)) : Se.type === "keydown" || Se.type === "keyup" ? Zv[Se.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Qy, charCode: function(Se) {
    return Se.type === "keypress" ? Xt(Se) : 0;
  }, keyCode: function(Se) {
    return Se.type === "keydown" || Se.type === "keyup" ? Se.keyCode : 0;
  }, which: function(Se) {
    return Se.type === "keypress" ? Xt(Se) : Se.type === "keydown" || Se.type === "keyup" ? Se.keyCode : 0;
  } }), a_ = In(Tl), Ky = yt({}, No, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), am = In(Ky), Xy = yt({}, Er, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Qy }), i_ = In(Xy), im = yt({}, Zn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Qv = In(im), gs = yt({}, No, { deltaX: function(Se) {
    return "deltaX" in Se ? Se.deltaX : "wheelDeltaX" in Se ? -Se.wheelDeltaX : 0;
  }, deltaY: function(Se) {
    return "deltaY" in Se ? Se.deltaY : "wheelDeltaY" in Se ? -Se.wheelDeltaY : "wheelDelta" in Se ? -Se.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 }), kl = In(gs), Ba = [9, 13, 27, 32], zu = Oe && "CompositionEvent" in window, ad = null;
  Oe && "documentMode" in document && (ad = document.documentMode);
  var sm = Oe && "TextEvent" in window && !ad, Kv = Oe && (!zu || ad && 8 < ad && 11 >= ad), lf = String.fromCharCode(32), Xv = !1;
  function Jv(Se, Ce) {
    switch (Se) {
      case "keyup":
        return Ba.indexOf(Ce.keyCode) !== -1;
      case "keydown":
        return Ce.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function um(Se) {
    return Se = Se.detail, typeof Se == "object" && "data" in Se ? Se.data : null;
  }
  var cf = !1;
  function s_(Se, Ce) {
    switch (Se) {
      case "compositionend":
        return um(Ce);
      case "keypress":
        return Ce.which !== 32 ? null : (Xv = !0, lf);
      case "textInput":
        return Se = Ce.data, Se === lf && Xv ? null : Se;
      default:
        return null;
    }
  }
  function u_(Se, Ce) {
    if (cf)
      return Se === "compositionend" || !zu && Jv(Se, Ce) ? (Se = $t(), Ot = dt = Ge = null, cf = !1, Se) : null;
    switch (Se) {
      case "paste":
        return null;
      case "keypress":
        if (!(Ce.ctrlKey || Ce.altKey || Ce.metaKey) || Ce.ctrlKey && Ce.altKey) {
          if (Ce.char && 1 < Ce.char.length)
            return Ce.char;
          if (Ce.which)
            return String.fromCharCode(Ce.which);
        }
        return null;
      case "compositionend":
        return Kv && Ce.locale !== "ko" ? null : Ce.data;
      default:
        return null;
    }
  }
  var eg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function tg(Se) {
    var Ce = Se && Se.nodeName && Se.nodeName.toLowerCase();
    return Ce === "input" ? !!eg[Se.type] : Ce === "textarea";
  }
  function ng(Se, Ce, De, Ue) {
    Ha(Ue), Ce = wp(Ce, "onChange"), 0 < Ce.length && (De = new br("onChange", "change", null, De, Ue), Se.push({ event: De, listeners: Ce }));
  }
  var hp = null, df = null;
  function ff(Se) {
    pm(Se, 0);
  }
  function pf(Se) {
    var Ce = bf(Se);
    if (Yr(Ce))
      return Se;
  }
  function rg(Se, Ce) {
    if (Se === "change")
      return Ce;
  }
  var Jy = !1;
  Oe && (Oe ? (lm = "oninput" in document, lm || (tb = document.createElement("div"), tb.setAttribute("oninput", "return;"), lm = typeof tb.oninput == "function"), eb = lm) : eb = !1, Jy = eb && (!document.documentMode || 9 < document.documentMode));
  var eb, lm, tb;
  function og() {
    hp && (hp.detachEvent("onpropertychange", ag), df = hp = null);
  }
  function ag(Se) {
    if (Se.propertyName === "value" && pf(df)) {
      var Ce = [];
      ng(Ce, df, Se, Br(Se)), ra(ff, Ce);
    }
  }
  function l_(Se, Ce, De) {
    Se === "focusin" ? (og(), hp = Ce, df = De, hp.attachEvent("onpropertychange", ag)) : Se === "focusout" && og();
  }
  function c_(Se) {
    if (Se === "selectionchange" || Se === "keyup" || Se === "keydown")
      return pf(df);
  }
  function d_(Se, Ce) {
    if (Se === "click")
      return pf(Ce);
  }
  function ig(Se, Ce) {
    if (Se === "input" || Se === "change")
      return pf(Ce);
  }
  function f_(Se, Ce) {
    return Se === Ce && (Se !== 0 || 1 / Se === 1 / Ce) || Se !== Se && Ce !== Ce;
  }
  var uu = typeof Object.is == "function" ? Object.is : f_;
  function mp(Se, Ce) {
    if (uu(Se, Ce))
      return !0;
    if (typeof Se != "object" || Se === null || typeof Ce != "object" || Ce === null)
      return !1;
    var De = Object.keys(Se), Ue = Object.keys(Ce);
    if (De.length !== Ue.length)
      return !1;
    for (Ue = 0; Ue < De.length; Ue++) {
      var Qe = De[Ue];
      if (!$e.call(Ce, Qe) || !uu(Se[Qe], Ce[Qe]))
        return !1;
    }
    return !0;
  }
  function sg(Se) {
    for (; Se && Se.firstChild; )
      Se = Se.firstChild;
    return Se;
  }
  function ug(Se, Ce) {
    var De = sg(Se);
    Se = 0;
    for (var Ue; De; ) {
      if (De.nodeType === 3) {
        if (Ue = Se + De.textContent.length, Se <= Ce && Ue >= Ce)
          return { node: De, offset: Ce - Se };
        Se = Ue;
      }
      e: {
        for (; De; ) {
          if (De.nextSibling) {
            De = De.nextSibling;
            break e;
          }
          De = De.parentNode;
        }
        De = void 0;
      }
      De = sg(De);
    }
  }
  function lg(Se, Ce) {
    return Se && Ce ? Se === Ce ? !0 : Se && Se.nodeType === 3 ? !1 : Ce && Ce.nodeType === 3 ? lg(Se, Ce.parentNode) : "contains" in Se ? Se.contains(Ce) : Se.compareDocumentPosition ? !!(Se.compareDocumentPosition(Ce) & 16) : !1 : !1;
  }
  function cm() {
    for (var Se = window, Ce = so(); Ce instanceof Se.HTMLIFrameElement; ) {
      try {
        var De = typeof Ce.contentWindow.location.href == "string";
      } catch {
        De = !1;
      }
      if (De)
        Se = Ce.contentWindow;
      else
        break;
      Ce = so(Se.document);
    }
    return Ce;
  }
  function Ol(Se) {
    var Ce = Se && Se.nodeName && Se.nodeName.toLowerCase();
    return Ce && (Ce === "input" && (Se.type === "text" || Se.type === "search" || Se.type === "tel" || Se.type === "url" || Se.type === "password") || Ce === "textarea" || Se.contentEditable === "true");
  }
  function dm(Se) {
    var Ce = cm(), De = Se.focusedElem, Ue = Se.selectionRange;
    if (Ce !== De && De && De.ownerDocument && lg(De.ownerDocument.documentElement, De)) {
      if (Ue !== null && Ol(De)) {
        if (Ce = Ue.start, Se = Ue.end, Se === void 0 && (Se = Ce), "selectionStart" in De)
          De.selectionStart = Ce, De.selectionEnd = Math.min(Se, De.value.length);
        else if (Se = (Ce = De.ownerDocument || document) && Ce.defaultView || window, Se.getSelection) {
          Se = Se.getSelection();
          var Qe = De.textContent.length, et = Math.min(Ue.start, Qe);
          Ue = Ue.end === void 0 ? et : Math.min(Ue.end, Qe), !Se.extend && et > Ue && (Qe = Ue, Ue = et, et = Qe), Qe = ug(De, et);
          var bt = ug(De, Ue);
          Qe && bt && (Se.rangeCount !== 1 || Se.anchorNode !== Qe.node || Se.anchorOffset !== Qe.offset || Se.focusNode !== bt.node || Se.focusOffset !== bt.offset) && (Ce = Ce.createRange(), Ce.setStart(Qe.node, Qe.offset), Se.removeAllRanges(), et > Ue ? (Se.addRange(Ce), Se.extend(bt.node, bt.offset)) : (Ce.setEnd(bt.node, bt.offset), Se.addRange(Ce)));
        }
      }
      for (Ce = [], Se = De; Se = Se.parentNode; )
        Se.nodeType === 1 && Ce.push({ element: Se, left: Se.scrollLeft, top: Se.scrollTop });
      for (typeof De.focus == "function" && De.focus(), De = 0; De < Ce.length; De++)
        Se = Ce[De], Se.element.scrollLeft = Se.left, Se.element.scrollTop = Se.top;
    }
  }
  var cg = Oe && "documentMode" in document && 11 >= document.documentMode, Uu = null, nb = null, yp = null, rb = !1;
  function dg(Se, Ce, De) {
    var Ue = De.window === De ? De.document : De.nodeType === 9 ? De : De.ownerDocument;
    rb || Uu == null || Uu !== so(Ue) || (Ue = Uu, "selectionStart" in Ue && Ol(Ue) ? Ue = { start: Ue.selectionStart, end: Ue.selectionEnd } : (Ue = (Ue.ownerDocument && Ue.ownerDocument.defaultView || window).getSelection(), Ue = { anchorNode: Ue.anchorNode, anchorOffset: Ue.anchorOffset, focusNode: Ue.focusNode, focusOffset: Ue.focusOffset }), yp && mp(yp, Ue) || (yp = Ue, Ue = wp(nb, "onSelect"), 0 < Ue.length && (Ce = new br("onSelect", "select", null, Ce, De), Se.push({ event: Ce, listeners: Ue }), Ce.target = Uu)));
  }
  function fm(Se, Ce) {
    var De = {};
    return De[Se.toLowerCase()] = Ce.toLowerCase(), De["Webkit" + Se] = "webkit" + Ce, De["Moz" + Se] = "moz" + Ce, De;
  }
  var id = { animationend: fm("Animation", "AnimationEnd"), animationiteration: fm("Animation", "AnimationIteration"), animationstart: fm("Animation", "AnimationStart"), transitionend: fm("Transition", "TransitionEnd") }, ob = {}, ab = {};
  Oe && (ab = document.createElement("div").style, "AnimationEvent" in window || (delete id.animationend.animation, delete id.animationiteration.animation, delete id.animationstart.animation), "TransitionEvent" in window || delete id.transitionend.transition);
  function hi(Se) {
    if (ob[Se])
      return ob[Se];
    if (!id[Se])
      return Se;
    var Ce = id[Se], De;
    for (De in Ce)
      if (Ce.hasOwnProperty(De) && De in ab)
        return ob[Se] = Ce[De];
    return Se;
  }
  var ib = hi("animationend"), fg = hi("animationiteration"), pg = hi("animationstart"), hg = hi("transitionend"), mg = /* @__PURE__ */ new Map(), yg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Al(Se, Ce) {
    mg.set(Se, Ce), _e(Ce, [Se]);
  }
  for (hc = 0; hc < yg.length; hc++)
    hf = yg[hc], mf = hf.toLowerCase(), bg = hf[0].toUpperCase() + hf.slice(1), Al(mf, "on" + bg);
  var hf, mf, bg, hc;
  Al(ib, "onAnimationEnd"), Al(fg, "onAnimationIteration"), Al(pg, "onAnimationStart"), Al("dblclick", "onDoubleClick"), Al("focusin", "onFocus"), Al("focusout", "onBlur"), Al(hg, "onTransitionEnd"), xe("onMouseEnter", ["mouseout", "mouseover"]), xe("onMouseLeave", ["mouseout", "mouseover"]), xe("onPointerEnter", ["pointerout", "pointerover"]), xe("onPointerLeave", ["pointerout", "pointerover"]), _e("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), _e("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), _e("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), _e("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), _e("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), _e("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var bp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), p_ = new Set("cancel close invalid load scroll toggle".split(" ").concat(bp));
  function vg(Se, Ce, De) {
    var Ue = Se.type || "unknown-event";
    Se.currentTarget = De, hr(Ue, Ce, void 0, Se), Se.currentTarget = null;
  }
  function pm(Se, Ce) {
    Ce = (Ce & 4) !== 0;
    for (var De = 0; De < Se.length; De++) {
      var Ue = Se[De], Qe = Ue.event;
      Ue = Ue.listeners;
      e: {
        var et = void 0;
        if (Ce)
          for (var bt = Ue.length - 1; 0 <= bt; bt--) {
            var It = Ue[bt], Ut = It.instance, bn = It.currentTarget;
            if (It = It.listener, Ut !== et && Qe.isPropagationStopped())
              break e;
            vg(Qe, It, bn), et = Ut;
          }
        else
          for (bt = 0; bt < Ue.length; bt++) {
            if (It = Ue[bt], Ut = It.instance, bn = It.currentTarget, It = It.listener, Ut !== et && Qe.isPropagationStopped())
              break e;
            vg(Qe, It, bn), et = Ut;
          }
      }
    }
    if (Ma)
      throw Se = Rt, Ma = !1, Rt = null, Se;
  }
  function Uo(Se, Ce) {
    var De = Ce[pb];
    De === void 0 && (De = Ce[pb] = /* @__PURE__ */ new Set());
    var Ue = Se + "__bubble";
    De.has(Ue) || (gg(Ce, Se, 2, !1), De.add(Ue));
  }
  function mc(Se, Ce, De) {
    var Ue = 0;
    Ce && (Ue |= 4), gg(De, Se, Ue, Ce);
  }
  var Cl = "_reactListening" + Math.random().toString(36).slice(2);
  function yf(Se) {
    if (!Se[Cl]) {
      Se[Cl] = !0, ye.forEach(function(De) {
        De !== "selectionchange" && (p_.has(De) || mc(De, !1, Se), mc(De, !0, Se));
      });
      var Ce = Se.nodeType === 9 ? Se : Se.ownerDocument;
      Ce === null || Ce[Cl] || (Ce[Cl] = !0, mc("selectionchange", !1, Ce));
    }
  }
  function gg(Se, Ce, De, Ue) {
    switch (Sl(Ce)) {
      case 1:
        var Qe = au;
        break;
      case 4:
        Qe = vs;
        break;
      default:
        Qe = ol;
    }
    De = Qe.bind(null, Ce, De, Se), Qe = void 0, !ci || Ce !== "touchstart" && Ce !== "touchmove" && Ce !== "wheel" || (Qe = !0), Ue ? Qe !== void 0 ? Se.addEventListener(Ce, De, { capture: !0, passive: Qe }) : Se.addEventListener(Ce, De, !0) : Qe !== void 0 ? Se.addEventListener(Ce, De, { passive: Qe }) : Se.addEventListener(Ce, De, !1);
  }
  function hm(Se, Ce, De, Ue, Qe) {
    var et = Ue;
    if (!(Ce & 1) && !(Ce & 2) && Ue !== null)
      e:
        for (; ; ) {
          if (Ue === null)
            return;
          var bt = Ue.tag;
          if (bt === 3 || bt === 4) {
            var It = Ue.stateNode.containerInfo;
            if (It === Qe || It.nodeType === 8 && It.parentNode === Qe)
              break;
            if (bt === 4)
              for (bt = Ue.return; bt !== null; ) {
                var Ut = bt.tag;
                if ((Ut === 3 || Ut === 4) && (Ut = bt.stateNode.containerInfo, Ut === Qe || Ut.nodeType === 8 && Ut.parentNode === Qe))
                  return;
                bt = bt.return;
              }
            for (; It !== null; ) {
              if (bt = lu(It), bt === null)
                return;
              if (Ut = bt.tag, Ut === 5 || Ut === 6) {
                Ue = et = bt;
                continue e;
              }
              It = It.parentNode;
            }
          }
          Ue = Ue.return;
        }
    ra(function() {
      var bn = et, Rn = Br(De), Ln = [];
      e: {
        var Nn = mg.get(Se);
        if (Nn !== void 0) {
          var er = br, lr = Se;
          switch (Se) {
            case "keypress":
              if (Xt(De) === 0)
                break e;
            case "keydown":
            case "keyup":
              er = a_;
              break;
            case "focusin":
              lr = "focus", er = su;
              break;
            case "focusout":
              lr = "blur", er = su;
              break;
            case "beforeblur":
            case "afterblur":
              er = su;
              break;
            case "click":
              if (De.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              er = iu;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              er = sf;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              er = i_;
              break;
            case ib:
            case fg:
            case pg:
              er = uf;
              break;
            case hg:
              er = Qv;
              break;
            case "scroll":
              er = Cr;
              break;
            case "wheel":
              er = kl;
              break;
            case "copy":
            case "cut":
            case "paste":
              er = r_;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              er = am;
          }
          var fr = (Ce & 4) !== 0, Ca = !fr && Se === "scroll", nn = fr ? Nn !== null ? Nn + "Capture" : null : Nn;
          fr = [];
          for (var Qt = bn, un; Qt !== null; ) {
            un = Qt;
            var Vn = un.stateNode;
            if (un.tag === 5 && Vn !== null && (un = Vn, nn !== null && (Vn = Ta(Qt, nn), Vn != null && fr.push(gp(Qt, Vn, un)))), Ca)
              break;
            Qt = Qt.return;
          }
          0 < fr.length && (Nn = new er(Nn, lr, null, De, Rn), Ln.push({ event: Nn, listeners: fr }));
        }
      }
      if (!(Ce & 7)) {
        e: {
          if (Nn = Se === "mouseover" || Se === "pointerover", er = Se === "mouseout" || Se === "pointerout", Nn && De !== Ar && (lr = De.relatedTarget || De.fromElement) && (lu(lr) || lr[Rl]))
            break e;
          if ((er || Nn) && (Nn = Rn.window === Rn ? Rn : (Nn = Rn.ownerDocument) ? Nn.defaultView || Nn.parentWindow : window, er ? (lr = De.relatedTarget || De.toElement, er = bn, lr = lr ? lu(lr) : null, lr !== null && (Ca = Dr(lr), lr !== Ca || lr.tag !== 5 && lr.tag !== 6) && (lr = null)) : (er = null, lr = bn), er !== lr)) {
            if (fr = iu, Vn = "onMouseLeave", nn = "onMouseEnter", Qt = "mouse", (Se === "pointerout" || Se === "pointerover") && (fr = am, Vn = "onPointerLeave", nn = "onPointerEnter", Qt = "pointer"), Ca = er == null ? Nn : bf(er), un = lr == null ? Nn : bf(lr), Nn = new fr(Vn, Qt + "leave", er, De, Rn), Nn.target = Ca, Nn.relatedTarget = un, Vn = null, lu(Rn) === bn && (fr = new fr(nn, Qt + "enter", lr, De, Rn), fr.target = un, fr.relatedTarget = Ca, Vn = fr), Ca = Vn, er && lr)
              t: {
                for (fr = er, nn = lr, Qt = 0, un = fr; un; un = ud(un))
                  Qt++;
                for (un = 0, Vn = nn; Vn; Vn = ud(Vn))
                  un++;
                for (; 0 < Qt - un; )
                  fr = ud(fr), Qt--;
                for (; 0 < un - Qt; )
                  nn = ud(nn), un--;
                for (; Qt--; ) {
                  if (fr === nn || nn !== null && fr === nn.alternate)
                    break t;
                  fr = ud(fr), nn = ud(nn);
                }
                fr = null;
              }
            else
              fr = null;
            er !== null && sb(Ln, Nn, er, fr, !1), lr !== null && Ca !== null && sb(Ln, Ca, lr, fr, !0);
          }
        }
        e: {
          if (Nn = bn ? bf(bn) : window, er = Nn.nodeName && Nn.nodeName.toLowerCase(), er === "select" || er === "input" && Nn.type === "file")
            var Jn = rg;
          else if (tg(Nn))
            if (Jy)
              Jn = ig;
            else {
              Jn = c_;
              var xr = l_;
            }
          else
            (er = Nn.nodeName) && er.toLowerCase() === "input" && (Nn.type === "checkbox" || Nn.type === "radio") && (Jn = d_);
          if (Jn && (Jn = Jn(Se, bn))) {
            ng(Ln, Jn, De, Rn);
            break e;
          }
          xr && xr(Se, Nn, bn), Se === "focusout" && (xr = Nn._wrapperState) && xr.controlled && Nn.type === "number" && go(Nn, "number", Nn.value);
        }
        switch (xr = bn ? bf(bn) : window, Se) {
          case "focusin":
            (tg(xr) || xr.contentEditable === "true") && (Uu = xr, nb = bn, yp = null);
            break;
          case "focusout":
            yp = nb = Uu = null;
            break;
          case "mousedown":
            rb = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            rb = !1, dg(Ln, De, Rn);
            break;
          case "selectionchange":
            if (cg)
              break;
          case "keydown":
          case "keyup":
            dg(Ln, De, Rn);
        }
        var kr;
        if (zu)
          e: {
            switch (Se) {
              case "compositionstart":
                var Fr = "onCompositionStart";
                break e;
              case "compositionend":
                Fr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Fr = "onCompositionUpdate";
                break e;
            }
            Fr = void 0;
          }
        else
          cf ? Jv(Se, De) && (Fr = "onCompositionEnd") : Se === "keydown" && De.keyCode === 229 && (Fr = "onCompositionStart");
        Fr && (Kv && De.locale !== "ko" && (cf || Fr !== "onCompositionStart" ? Fr === "onCompositionEnd" && cf && (kr = $t()) : (Ge = Rn, dt = "value" in Ge ? Ge.value : Ge.textContent, cf = !0)), xr = wp(bn, Fr), 0 < xr.length && (Fr = new Gy(Fr, Se, null, De, Rn), Ln.push({ event: Fr, listeners: xr }), kr ? Fr.data = kr : (kr = um(De), kr !== null && (Fr.data = kr)))), (kr = sm ? s_(Se, De) : u_(Se, De)) && (bn = wp(bn, "onBeforeInput"), 0 < bn.length && (Rn = new Gy("onBeforeInput", "beforeinput", null, De, Rn), Ln.push({ event: Rn, listeners: bn }), Rn.data = kr));
      }
      pm(Ln, Ce);
    });
  }
  function gp(Se, Ce, De) {
    return { instance: Se, listener: Ce, currentTarget: De };
  }
  function wp(Se, Ce) {
    for (var De = Ce + "Capture", Ue = []; Se !== null; ) {
      var Qe = Se, et = Qe.stateNode;
      Qe.tag === 5 && et !== null && (Qe = et, et = Ta(Se, De), et != null && Ue.unshift(gp(Se, et, Qe)), et = Ta(Se, Ce), et != null && Ue.push(gp(Se, et, Qe))), Se = Se.return;
    }
    return Ue;
  }
  function ud(Se) {
    if (Se === null)
      return null;
    do
      Se = Se.return;
    while (Se && Se.tag !== 5);
    return Se || null;
  }
  function sb(Se, Ce, De, Ue, Qe) {
    for (var et = Ce._reactName, bt = []; De !== null && De !== Ue; ) {
      var It = De, Ut = It.alternate, bn = It.stateNode;
      if (Ut !== null && Ut === Ue)
        break;
      It.tag === 5 && bn !== null && (It = bn, Qe ? (Ut = Ta(De, et), Ut != null && bt.unshift(gp(De, Ut, It))) : Qe || (Ut = Ta(De, et), Ut != null && bt.push(gp(De, Ut, It)))), De = De.return;
    }
    bt.length !== 0 && Se.push({ event: Ce, listeners: bt });
  }
  var ub = /\r\n?/g, m_ = /\u0000|\uFFFD/g;
  function lb(Se) {
    return (typeof Se == "string" ? Se : "" + Se).replace(ub, `
`).replace(m_, "");
  }
  function mm(Se, Ce, De) {
    if (Ce = lb(Ce), lb(Se) !== Ce && De)
      throw Error(fe(425));
  }
  function ym() {
  }
  var cb = null, ld = null;
  function _p(Se, Ce) {
    return Se === "textarea" || Se === "noscript" || typeof Ce.children == "string" || typeof Ce.children == "number" || typeof Ce.dangerouslySetInnerHTML == "object" && Ce.dangerouslySetInnerHTML !== null && Ce.dangerouslySetInnerHTML.__html != null;
  }
  var bd = typeof setTimeout == "function" ? setTimeout : void 0, wg = typeof clearTimeout == "function" ? clearTimeout : void 0, db = typeof Promise == "function" ? Promise : void 0, fb = typeof queueMicrotask == "function" ? queueMicrotask : typeof db < "u" ? function(Se) {
    return db.resolve(null).then(Se).catch(y_);
  } : bd;
  function y_(Se) {
    setTimeout(function() {
      throw Se;
    });
  }
  function yc(Se, Ce) {
    var De = Ce, Ue = 0;
    do {
      var Qe = De.nextSibling;
      if (Se.removeChild(De), Qe && Qe.nodeType === 8)
        if (De = Qe.data, De === "/$") {
          if (Ue === 0) {
            Se.removeChild(Qe), ou(Ce);
            return;
          }
          Ue--;
        } else
          De !== "$" && De !== "$?" && De !== "$!" || Ue++;
      De = Qe;
    } while (De);
    ou(Ce);
  }
  function Vu(Se) {
    for (; Se != null; Se = Se.nextSibling) {
      var Ce = Se.nodeType;
      if (Ce === 1 || Ce === 3)
        break;
      if (Ce === 8) {
        if (Ce = Se.data, Ce === "$" || Ce === "$!" || Ce === "$?")
          break;
        if (Ce === "/$")
          return null;
      }
    }
    return Se;
  }
  function Ep(Se) {
    Se = Se.previousSibling;
    for (var Ce = 0; Se; ) {
      if (Se.nodeType === 8) {
        var De = Se.data;
        if (De === "$" || De === "$!" || De === "$?") {
          if (Ce === 0)
            return Se;
          Ce--;
        } else
          De === "/$" && Ce++;
      }
      Se = Se.previousSibling;
    }
    return null;
  }
  var bc = Math.random().toString(36).slice(2), il = "__reactFiber$" + bc, wd = "__reactProps$" + bc, Rl = "__reactContainer$" + bc, pb = "__reactEvents$" + bc, b_ = "__reactListeners$" + bc, hb = "__reactHandles$" + bc;
  function lu(Se) {
    var Ce = Se[il];
    if (Ce)
      return Ce;
    for (var De = Se.parentNode; De; ) {
      if (Ce = De[Rl] || De[il]) {
        if (De = Ce.alternate, Ce.child !== null || De !== null && De.child !== null)
          for (Se = Ep(Se); Se !== null; ) {
            if (De = Se[il])
              return De;
            Se = Ep(Se);
          }
        return Ce;
      }
      Se = De, De = Se.parentNode;
    }
    return null;
  }
  function xp(Se) {
    return Se = Se[il] || Se[Rl], !Se || Se.tag !== 5 && Se.tag !== 6 && Se.tag !== 13 && Se.tag !== 3 ? null : Se;
  }
  function bf(Se) {
    if (Se.tag === 5 || Se.tag === 6)
      return Se.stateNode;
    throw Error(fe(33));
  }
  function Sr(Se) {
    return Se[wd] || null;
  }
  var vc = [], Ko = -1;
  function qr(Se) {
    return { current: Se };
  }
  function ko(Se) {
    0 > Ko || (Se.current = vc[Ko], vc[Ko] = null, Ko--);
  }
  function Co(Se, Ce) {
    Ko++, vc[Ko] = Se.current, Se.current = Ce;
  }
  var sl = {}, Lr = qr(sl), Sa = qr(!1), ws = sl;
  function cu(Se, Ce) {
    var De = Se.type.contextTypes;
    if (!De)
      return sl;
    var Ue = Se.stateNode;
    if (Ue && Ue.__reactInternalMemoizedUnmaskedChildContext === Ce)
      return Ue.__reactInternalMemoizedMaskedChildContext;
    var Qe = {}, et;
    for (et in De)
      Qe[et] = Ce[et];
    return Ue && (Se = Se.stateNode, Se.__reactInternalMemoizedUnmaskedChildContext = Ce, Se.__reactInternalMemoizedMaskedChildContext = Qe), Qe;
  }
  function sa(Se) {
    return Se = Se.childContextTypes, Se != null;
  }
  function du() {
    ko(Sa), ko(Lr);
  }
  function gc(Se, Ce, De) {
    if (Lr.current !== sl)
      throw Error(fe(168));
    Co(Lr, Ce), Co(Sa, De);
  }
  function Sp(Se, Ce, De) {
    var Ue = Se.stateNode;
    if (Ce = Ce.childContextTypes, typeof Ue.getChildContext != "function")
      return De;
    Ue = Ue.getChildContext();
    for (var Qe in Ue)
      if (!(Qe in Ce))
        throw Error(fe(108, Qn(Se) || "Unknown", Qe));
    return yt({}, De, Ue);
  }
  function bm(Se) {
    return Se = (Se = Se.stateNode) && Se.__reactInternalMemoizedMergedChildContext || sl, ws = Lr.current, Co(Lr, Se), Co(Sa, Sa.current), !0;
  }
  function _g(Se, Ce, De) {
    var Ue = Se.stateNode;
    if (!Ue)
      throw Error(fe(169));
    De ? (Se = Sp(Se, Ce, ws), Ue.__reactInternalMemoizedMergedChildContext = Se, ko(Sa), ko(Lr), Co(Lr, Se)) : ko(Sa), Co(Sa, De);
  }
  var Vs = null, mi = !1, Pp = !1;
  function mb(Se) {
    Vs === null ? Vs = [Se] : Vs.push(Se);
  }
  function yb(Se) {
    mi = !0, mb(Se);
  }
  function _s() {
    if (!Pp && Vs !== null) {
      Pp = !0;
      var Se = 0, Ce = po;
      try {
        var De = Vs;
        for (po = 1; Se < De.length; Se++) {
          var Ue = De[Se];
          do
            Ue = Ue(!0);
          while (Ue !== null);
        }
        Vs = null, mi = !1;
      } catch (Qe) {
        throw Vs !== null && (Vs = Vs.slice(Se + 1)), Ao(Yi, _s), Qe;
      } finally {
        po = Ce, Pp = !1;
      }
    }
    return null;
  }
  var wc = [], Es = 0, _d = null, vf = 0, xs = [], Wi = 0, fu = null, xi = 1, Nl = "";
  function Hs(Se, Ce) {
    wc[Es++] = vf, wc[Es++] = _d, _d = Se, vf = Ce;
  }
  function bb(Se, Ce, De) {
    xs[Wi++] = xi, xs[Wi++] = Nl, xs[Wi++] = fu, fu = Se;
    var Ue = xi;
    Se = Nl;
    var Qe = 32 - ja(Ue) - 1;
    Ue &= ~(1 << Qe), De += 1;
    var et = 32 - ja(Ce) + Qe;
    if (30 < et) {
      var bt = Qe - Qe % 5;
      et = (Ue & (1 << bt) - 1).toString(32), Ue >>= bt, Qe -= bt, xi = 1 << 32 - ja(Ce) + Qe | De << Qe | Ue, Nl = et + Se;
    } else
      xi = 1 << et | De << Qe | Ue, Nl = Se;
  }
  function vm(Se) {
    Se.return !== null && (Hs(Se, 1), bb(Se, 1, 0));
  }
  function vb(Se) {
    for (; Se === _d; )
      _d = wc[--Es], wc[Es] = null, vf = wc[--Es], wc[Es] = null;
    for (; Se === fu; )
      fu = xs[--Wi], xs[Wi] = null, Nl = xs[--Wi], xs[Wi] = null, xi = xs[--Wi], xs[Wi] = null;
  }
  var Ws = null, Ss = null, Xo = !1, pu = null;
  function gb(Se, Ce) {
    var De = gu(5, null, null, 0);
    De.elementType = "DELETED", De.stateNode = Ce, De.return = Se, Ce = Se.deletions, Ce === null ? (Se.deletions = [De], Se.flags |= 16) : Ce.push(De);
  }
  function Eg(Se, Ce) {
    switch (Se.tag) {
      case 5:
        var De = Se.type;
        return Ce = Ce.nodeType !== 1 || De.toLowerCase() !== Ce.nodeName.toLowerCase() ? null : Ce, Ce !== null ? (Se.stateNode = Ce, Ws = Se, Ss = Vu(Ce.firstChild), !0) : !1;
      case 6:
        return Ce = Se.pendingProps === "" || Ce.nodeType !== 3 ? null : Ce, Ce !== null ? (Se.stateNode = Ce, Ws = Se, Ss = null, !0) : !1;
      case 13:
        return Ce = Ce.nodeType !== 8 ? null : Ce, Ce !== null ? (De = fu !== null ? { id: xi, overflow: Nl } : null, Se.memoizedState = { dehydrated: Ce, treeContext: De, retryLane: 1073741824 }, De = gu(18, null, null, 0), De.stateNode = Ce, De.return = Se, Se.child = De, Ws = Se, Ss = null, !0) : !1;
      default:
        return !1;
    }
  }
  function gm(Se) {
    return (Se.mode & 1) !== 0 && (Se.flags & 128) === 0;
  }
  function wm(Se) {
    if (Xo) {
      var Ce = Ss;
      if (Ce) {
        var De = Ce;
        if (!Eg(Se, Ce)) {
          if (gm(Se))
            throw Error(fe(418));
          Ce = Vu(De.nextSibling);
          var Ue = Ws;
          Ce && Eg(Se, Ce) ? gb(Ue, De) : (Se.flags = Se.flags & -4097 | 2, Xo = !1, Ws = Se);
        }
      } else {
        if (gm(Se))
          throw Error(fe(418));
        Se.flags = Se.flags & -4097 | 2, Xo = !1, Ws = Se;
      }
    }
  }
  function xg(Se) {
    for (Se = Se.return; Se !== null && Se.tag !== 5 && Se.tag !== 3 && Se.tag !== 13; )
      Se = Se.return;
    Ws = Se;
  }
  function _m(Se) {
    if (Se !== Ws)
      return !1;
    if (!Xo)
      return xg(Se), Xo = !0, !1;
    var Ce;
    if ((Ce = Se.tag !== 3) && !(Ce = Se.tag !== 5) && (Ce = Se.type, Ce = Ce !== "head" && Ce !== "body" && !_p(Se.type, Se.memoizedProps)), Ce && (Ce = Ss)) {
      if (gm(Se))
        throw Sg(), Error(fe(418));
      for (; Ce; )
        gb(Se, Ce), Ce = Vu(Ce.nextSibling);
    }
    if (xg(Se), Se.tag === 13) {
      if (Se = Se.memoizedState, Se = Se !== null ? Se.dehydrated : null, !Se)
        throw Error(fe(317));
      e: {
        for (Se = Se.nextSibling, Ce = 0; Se; ) {
          if (Se.nodeType === 8) {
            var De = Se.data;
            if (De === "/$") {
              if (Ce === 0) {
                Ss = Vu(Se.nextSibling);
                break e;
              }
              Ce--;
            } else
              De !== "$" && De !== "$!" && De !== "$?" || Ce++;
          }
          Se = Se.nextSibling;
        }
        Ss = null;
      }
    } else
      Ss = Ws ? Vu(Se.stateNode.nextSibling) : null;
    return !0;
  }
  function Sg() {
    for (var Se = Ss; Se; )
      Se = Vu(Se.nextSibling);
  }
  function da() {
    Ss = Ws = null, Xo = !1;
  }
  function wb(Se) {
    pu === null ? pu = [Se] : pu.push(Se);
  }
  var Em = ht.ReactCurrentBatchConfig;
  function qs(Se, Ce) {
    if (Se && Se.defaultProps) {
      Ce = yt({}, Ce), Se = Se.defaultProps;
      for (var De in Se)
        Ce[De] === void 0 && (Ce[De] = Se[De]);
      return Ce;
    }
    return Ce;
  }
  var ul = qr(null), xm = null, Pc = null, _b = null;
  function Eb() {
    _b = Pc = xm = null;
  }
  function kc(Se) {
    var Ce = ul.current;
    ko(ul), Se._currentValue = Ce;
  }
  function yi(Se, Ce, De) {
    for (; Se !== null; ) {
      var Ue = Se.alternate;
      if ((Se.childLanes & Ce) !== Ce ? (Se.childLanes |= Ce, Ue !== null && (Ue.childLanes |= Ce)) : Ue !== null && (Ue.childLanes & Ce) !== Ce && (Ue.childLanes |= Ce), Se === De)
        break;
      Se = Se.return;
    }
  }
  function Gn(Se, Ce) {
    xm = Se, _b = Pc = null, Se = Se.dependencies, Se !== null && Se.firstContext !== null && (Se.lanes & Ce && (za = !0), Se.firstContext = null);
  }
  function Oa(Se) {
    var Ce = Se._currentValue;
    if (_b !== Se)
      if (Se = { context: Se, memoizedValue: Ce, next: null }, Pc === null) {
        if (xm === null)
          throw Error(fe(308));
        Pc = Se, xm.dependencies = { lanes: 0, firstContext: Se };
      } else
        Pc = Pc.next = Se;
    return Ce;
  }
  var Si = null;
  function xb(Se) {
    Si === null ? Si = [Se] : Si.push(Se);
  }
  function Pg(Se, Ce, De, Ue) {
    var Qe = Ce.interleaved;
    return Qe === null ? (De.next = De, xb(Ce)) : (De.next = Qe.next, Qe.next = De), Ce.interleaved = De, Ml(Se, Ue);
  }
  function Ml(Se, Ce) {
    Se.lanes |= Ce;
    var De = Se.alternate;
    for (De !== null && (De.lanes |= Ce), De = Se, Se = Se.return; Se !== null; )
      Se.childLanes |= Ce, De = Se.alternate, De !== null && (De.childLanes |= Ce), De = Se, Se = Se.return;
    return De.tag === 3 ? De.stateNode : null;
  }
  var Ac = !1;
  function Sb(Se) {
    Se.updateQueue = { baseState: Se.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Xa(Se, Ce) {
    Se = Se.updateQueue, Ce.updateQueue === Se && (Ce.updateQueue = { baseState: Se.baseState, firstBaseUpdate: Se.firstBaseUpdate, lastBaseUpdate: Se.lastBaseUpdate, shared: Se.shared, effects: Se.effects });
  }
  function Dl(Se, Ce) {
    return { eventTime: Se, lane: Ce, tag: 0, payload: null, callback: null, next: null };
  }
  function $c(Se, Ce, De) {
    var Ue = Se.updateQueue;
    if (Ue === null)
      return null;
    if (Ue = Ue.shared, lo & 2) {
      var Qe = Ue.pending;
      return Qe === null ? Ce.next = Ce : (Ce.next = Qe.next, Qe.next = Ce), Ue.pending = Ce, Ml(Se, De);
    }
    return Qe = Ue.interleaved, Qe === null ? (Ce.next = Ce, xb(Ue)) : (Ce.next = Qe.next, Qe.next = Ce), Ue.interleaved = Ce, Ml(Se, De);
  }
  function Sm(Se, Ce, De) {
    if (Ce = Ce.updateQueue, Ce !== null && (Ce = Ce.shared, (De & 4194240) !== 0)) {
      var Ue = Ce.lanes;
      Ue &= Se.pendingLanes, De |= Ue, Ce.lanes = De, Fs(Se, De);
    }
  }
  function Pb(Se, Ce) {
    var De = Se.updateQueue, Ue = Se.alternate;
    if (Ue !== null && (Ue = Ue.updateQueue, De === Ue)) {
      var Qe = null, et = null;
      if (De = De.firstBaseUpdate, De !== null) {
        do {
          var bt = { eventTime: De.eventTime, lane: De.lane, tag: De.tag, payload: De.payload, callback: De.callback, next: null };
          et === null ? Qe = et = bt : et = et.next = bt, De = De.next;
        } while (De !== null);
        et === null ? Qe = et = Ce : et = et.next = Ce;
      } else
        Qe = et = Ce;
      De = { baseState: Ue.baseState, firstBaseUpdate: Qe, lastBaseUpdate: et, shared: Ue.shared, effects: Ue.effects }, Se.updateQueue = De;
      return;
    }
    Se = De.lastBaseUpdate, Se === null ? De.firstBaseUpdate = Ce : Se.next = Ce, De.lastBaseUpdate = Ce;
  }
  function Ic(Se, Ce, De, Ue) {
    var Qe = Se.updateQueue;
    Ac = !1;
    var et = Qe.firstBaseUpdate, bt = Qe.lastBaseUpdate, It = Qe.shared.pending;
    if (It !== null) {
      Qe.shared.pending = null;
      var Ut = It, bn = Ut.next;
      Ut.next = null, bt === null ? et = bn : bt.next = bn, bt = Ut;
      var Rn = Se.alternate;
      Rn !== null && (Rn = Rn.updateQueue, It = Rn.lastBaseUpdate, It !== bt && (It === null ? Rn.firstBaseUpdate = bn : It.next = bn, Rn.lastBaseUpdate = Ut));
    }
    if (et !== null) {
      var Ln = Qe.baseState;
      bt = 0, Rn = bn = Ut = null, It = et;
      do {
        var Nn = It.lane, er = It.eventTime;
        if ((Ue & Nn) === Nn) {
          Rn !== null && (Rn = Rn.next = { eventTime: er, lane: 0, tag: It.tag, payload: It.payload, callback: It.callback, next: null });
          e: {
            var lr = Se, fr = It;
            switch (Nn = Ce, er = De, fr.tag) {
              case 1:
                if (lr = fr.payload, typeof lr == "function") {
                  Ln = lr.call(er, Ln, Nn);
                  break e;
                }
                Ln = lr;
                break e;
              case 3:
                lr.flags = lr.flags & -65537 | 128;
              case 0:
                if (lr = fr.payload, Nn = typeof lr == "function" ? lr.call(er, Ln, Nn) : lr, Nn == null)
                  break e;
                Ln = yt({}, Ln, Nn);
                break e;
              case 2:
                Ac = !0;
            }
          }
          It.callback !== null && It.lane !== 0 && (Se.flags |= 64, Nn = Qe.effects, Nn === null ? Qe.effects = [It] : Nn.push(It));
        } else
          er = { eventTime: er, lane: Nn, tag: It.tag, payload: It.payload, callback: It.callback, next: null }, Rn === null ? (bn = Rn = er, Ut = Ln) : Rn = Rn.next = er, bt |= Nn;
        if (It = It.next, It === null) {
          if (It = Qe.shared.pending, It === null)
            break;
          Nn = It, It = Nn.next, Nn.next = null, Qe.lastBaseUpdate = Nn, Qe.shared.pending = null;
        }
      } while (1);
      if (Rn === null && (Ut = Ln), Qe.baseState = Ut, Qe.firstBaseUpdate = bn, Qe.lastBaseUpdate = Rn, Ce = Qe.shared.interleaved, Ce !== null) {
        Qe = Ce;
        do
          bt |= Qe.lane, Qe = Qe.next;
        while (Qe !== Ce);
      } else
        et === null && (Qe.shared.lanes = 0);
      Ld |= bt, Se.lanes = bt, Se.memoizedState = Ln;
    }
  }
  function Ed(Se, Ce, De) {
    if (Se = Ce.effects, Ce.effects = null, Se !== null)
      for (Ce = 0; Ce < Se.length; Ce++) {
        var Ue = Se[Ce], Qe = Ue.callback;
        if (Qe !== null) {
          if (Ue.callback = null, Ue = De, typeof Qe != "function")
            throw Error(fe(191, Qe));
          Qe.call(Ue);
        }
      }
  }
  var Tg = new oe.Component().refs;
  function Tb(Se, Ce, De, Ue) {
    Ce = Se.memoizedState, De = De(Ue, Ce), De = De == null ? Ce : yt({}, Ce, De), Se.memoizedState = De, Se.lanes === 0 && (Se.updateQueue.baseState = De);
  }
  var Pm = { isMounted: function(Se) {
    return (Se = Se._reactInternals) ? Dr(Se) === Se : !1;
  }, enqueueSetState: function(Se, Ce, De) {
    Se = Se._reactInternals;
    var Ue = Ho(), Qe = Qs(Se), et = Dl(Ue, Qe);
    et.payload = Ce, De != null && (et.callback = De), Ce = $c(Se, et, Qe), Ce !== null && (Ks(Ce, Se, Qe, Ue), Sm(Ce, Se, Qe));
  }, enqueueReplaceState: function(Se, Ce, De) {
    Se = Se._reactInternals;
    var Ue = Ho(), Qe = Qs(Se), et = Dl(Ue, Qe);
    et.tag = 1, et.payload = Ce, De != null && (et.callback = De), Ce = $c(Se, et, Qe), Ce !== null && (Ks(Ce, Se, Qe, Ue), Sm(Ce, Se, Qe));
  }, enqueueForceUpdate: function(Se, Ce) {
    Se = Se._reactInternals;
    var De = Ho(), Ue = Qs(Se), Qe = Dl(De, Ue);
    Qe.tag = 2, Ce != null && (Qe.callback = Ce), Ce = $c(Se, Qe, Ue), Ce !== null && (Ks(Ce, Se, Ue, De), Sm(Ce, Se, Ue));
  } };
  function kg(Se, Ce, De, Ue, Qe, et, bt) {
    return Se = Se.stateNode, typeof Se.shouldComponentUpdate == "function" ? Se.shouldComponentUpdate(Ue, et, bt) : Ce.prototype && Ce.prototype.isPureReactComponent ? !mp(De, Ue) || !mp(Qe, et) : !0;
  }
  function Og(Se, Ce, De) {
    var Ue = !1, Qe = sl, et = Ce.contextType;
    return typeof et == "object" && et !== null ? et = Oa(et) : (Qe = sa(Ce) ? ws : Lr.current, Ue = Ce.contextTypes, et = (Ue = Ue != null) ? cu(Se, Qe) : sl), Ce = new Ce(De, et), Se.memoizedState = Ce.state !== null && Ce.state !== void 0 ? Ce.state : null, Ce.updater = Pm, Se.stateNode = Ce, Ce._reactInternals = Se, Ue && (Se = Se.stateNode, Se.__reactInternalMemoizedUnmaskedChildContext = Qe, Se.__reactInternalMemoizedMaskedChildContext = et), Ce;
  }
  function Ag(Se, Ce, De, Ue) {
    Se = Ce.state, typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps(De, Ue), typeof Ce.UNSAFE_componentWillReceiveProps == "function" && Ce.UNSAFE_componentWillReceiveProps(De, Ue), Ce.state !== Se && Pm.enqueueReplaceState(Ce, Ce.state, null);
  }
  function Tm(Se, Ce, De, Ue) {
    var Qe = Se.stateNode;
    Qe.props = De, Qe.state = Se.memoizedState, Qe.refs = Tg, Sb(Se);
    var et = Ce.contextType;
    typeof et == "object" && et !== null ? Qe.context = Oa(et) : (et = sa(Ce) ? ws : Lr.current, Qe.context = cu(Se, et)), Qe.state = Se.memoizedState, et = Ce.getDerivedStateFromProps, typeof et == "function" && (Tb(Se, Ce, et, De), Qe.state = Se.memoizedState), typeof Ce.getDerivedStateFromProps == "function" || typeof Qe.getSnapshotBeforeUpdate == "function" || typeof Qe.UNSAFE_componentWillMount != "function" && typeof Qe.componentWillMount != "function" || (Ce = Qe.state, typeof Qe.componentWillMount == "function" && Qe.componentWillMount(), typeof Qe.UNSAFE_componentWillMount == "function" && Qe.UNSAFE_componentWillMount(), Ce !== Qe.state && Pm.enqueueReplaceState(Qe, Qe.state, null), Ic(Se, De, Qe, Ue), Qe.state = Se.memoizedState), typeof Qe.componentDidMount == "function" && (Se.flags |= 4194308);
  }
  function gf(Se, Ce, De) {
    if (Se = De.ref, Se !== null && typeof Se != "function" && typeof Se != "object") {
      if (De._owner) {
        if (De = De._owner, De) {
          if (De.tag !== 1)
            throw Error(fe(309));
          var Ue = De.stateNode;
        }
        if (!Ue)
          throw Error(fe(147, Se));
        var Qe = Ue, et = "" + Se;
        return Ce !== null && Ce.ref !== null && typeof Ce.ref == "function" && Ce.ref._stringRef === et ? Ce.ref : (Ce = function(bt) {
          var It = Qe.refs;
          It === Tg && (It = Qe.refs = {}), bt === null ? delete It[et] : It[et] = bt;
        }, Ce._stringRef = et, Ce);
      }
      if (typeof Se != "string")
        throw Error(fe(284));
      if (!De._owner)
        throw Error(fe(290, Se));
    }
    return Se;
  }
  function km(Se, Ce) {
    throw Se = Object.prototype.toString.call(Ce), Error(fe(31, Se === "[object Object]" ? "object with keys {" + Object.keys(Ce).join(", ") + "}" : Se));
  }
  function Cg(Se) {
    var Ce = Se._init;
    return Ce(Se._payload);
  }
  function $g(Se) {
    function Ce(nn, Qt) {
      if (Se) {
        var un = nn.deletions;
        un === null ? (nn.deletions = [Qt], nn.flags |= 16) : un.push(Qt);
      }
    }
    function De(nn, Qt) {
      if (!Se)
        return null;
      for (; Qt !== null; )
        Ce(nn, Qt), Qt = Qt.sibling;
      return null;
    }
    function Ue(nn, Qt) {
      for (nn = /* @__PURE__ */ new Map(); Qt !== null; )
        Qt.key !== null ? nn.set(Qt.key, Qt) : nn.set(Qt.index, Qt), Qt = Qt.sibling;
      return nn;
    }
    function Qe(nn, Qt) {
      return nn = Uc(nn, Qt), nn.index = 0, nn.sibling = null, nn;
    }
    function et(nn, Qt, un) {
      return nn.index = un, Se ? (un = nn.alternate, un !== null ? (un = un.index, un < Qt ? (nn.flags |= 2, Qt) : un) : (nn.flags |= 2, Qt)) : (nn.flags |= 1048576, Qt);
    }
    function bt(nn) {
      return Se && nn.alternate === null && (nn.flags |= 2), nn;
    }
    function It(nn, Qt, un, Vn) {
      return Qt === null || Qt.tag !== 6 ? (Qt = Hd(un, nn.mode, Vn), Qt.return = nn, Qt) : (Qt = Qe(Qt, un), Qt.return = nn, Qt);
    }
    function Ut(nn, Qt, un, Vn) {
      var Jn = un.type;
      return Jn === St ? Rn(nn, Qt, un.props.children, Vn, un.key) : Qt !== null && (Qt.elementType === Jn || typeof Jn == "object" && Jn !== null && Jn.$$typeof === Ht && Cg(Jn) === Qt.type) ? (Vn = Qe(Qt, un.props), Vn.ref = gf(nn, Qt, un), Vn.return = nn, Vn) : (Vn = cy(un.type, un.key, un.props, null, nn.mode, Vn), Vn.ref = gf(nn, Qt, un), Vn.return = nn, Vn);
    }
    function bn(nn, Qt, un, Vn) {
      return Qt === null || Qt.tag !== 4 || Qt.stateNode.containerInfo !== un.containerInfo || Qt.stateNode.implementation !== un.implementation ? (Qt = Zb(un, nn.mode, Vn), Qt.return = nn, Qt) : (Qt = Qe(Qt, un.children || []), Qt.return = nn, Qt);
    }
    function Rn(nn, Qt, un, Vn, Jn) {
      return Qt === null || Qt.tag !== 7 ? (Qt = Vc(un, nn.mode, Vn, Jn), Qt.return = nn, Qt) : (Qt = Qe(Qt, un), Qt.return = nn, Qt);
    }
    function Ln(nn, Qt, un) {
      if (typeof Qt == "string" && Qt !== "" || typeof Qt == "number")
        return Qt = Hd("" + Qt, nn.mode, un), Qt.return = nn, Qt;
      if (typeof Qt == "object" && Qt !== null) {
        switch (Qt.$$typeof) {
          case gt:
            return un = cy(Qt.type, Qt.key, Qt.props, null, nn.mode, un), un.ref = gf(nn, null, Qt), un.return = nn, un;
          case At:
            return Qt = Zb(Qt, nn.mode, un), Qt.return = nn, Qt;
          case Ht:
            var Vn = Qt._init;
            return Ln(nn, Vn(Qt._payload), un);
        }
        if (Fo(Qt) || Dn(Qt))
          return Qt = Vc(Qt, nn.mode, un, null), Qt.return = nn, Qt;
        km(nn, Qt);
      }
      return null;
    }
    function Nn(nn, Qt, un, Vn) {
      var Jn = Qt !== null ? Qt.key : null;
      if (typeof un == "string" && un !== "" || typeof un == "number")
        return Jn !== null ? null : It(nn, Qt, "" + un, Vn);
      if (typeof un == "object" && un !== null) {
        switch (un.$$typeof) {
          case gt:
            return un.key === Jn ? Ut(nn, Qt, un, Vn) : null;
          case At:
            return un.key === Jn ? bn(nn, Qt, un, Vn) : null;
          case Ht:
            return Jn = un._init, Nn(nn, Qt, Jn(un._payload), Vn);
        }
        if (Fo(un) || Dn(un))
          return Jn !== null ? null : Rn(nn, Qt, un, Vn, null);
        km(nn, un);
      }
      return null;
    }
    function er(nn, Qt, un, Vn, Jn) {
      if (typeof Vn == "string" && Vn !== "" || typeof Vn == "number")
        return nn = nn.get(un) || null, It(Qt, nn, "" + Vn, Jn);
      if (typeof Vn == "object" && Vn !== null) {
        switch (Vn.$$typeof) {
          case gt:
            return nn = nn.get(Vn.key === null ? un : Vn.key) || null, Ut(Qt, nn, Vn, Jn);
          case At:
            return nn = nn.get(Vn.key === null ? un : Vn.key) || null, bn(Qt, nn, Vn, Jn);
          case Ht:
            var xr = Vn._init;
            return er(nn, Qt, un, xr(Vn._payload), Jn);
        }
        if (Fo(Vn) || Dn(Vn))
          return nn = nn.get(un) || null, Rn(Qt, nn, Vn, Jn, null);
        km(Qt, Vn);
      }
      return null;
    }
    function lr(nn, Qt, un, Vn) {
      for (var Jn = null, xr = null, kr = Qt, Fr = Qt = 0, ri = null; kr !== null && Fr < un.length; Fr++) {
        kr.index > Fr ? (ri = kr, kr = null) : ri = kr.sibling;
        var Eo = Nn(nn, kr, un[Fr], Vn);
        if (Eo === null) {
          kr === null && (kr = ri);
          break;
        }
        Se && kr && Eo.alternate === null && Ce(nn, kr), Qt = et(Eo, Qt, Fr), xr === null ? Jn = Eo : xr.sibling = Eo, xr = Eo, kr = ri;
      }
      if (Fr === un.length)
        return De(nn, kr), Xo && Hs(nn, Fr), Jn;
      if (kr === null) {
        for (; Fr < un.length; Fr++)
          kr = Ln(nn, un[Fr], Vn), kr !== null && (Qt = et(kr, Qt, Fr), xr === null ? Jn = kr : xr.sibling = kr, xr = kr);
        return Xo && Hs(nn, Fr), Jn;
      }
      for (kr = Ue(nn, kr); Fr < un.length; Fr++)
        ri = er(kr, nn, Fr, un[Fr], Vn), ri !== null && (Se && ri.alternate !== null && kr.delete(ri.key === null ? Fr : ri.key), Qt = et(ri, Qt, Fr), xr === null ? Jn = ri : xr.sibling = ri, xr = ri);
      return Se && kr.forEach(function(Wc) {
        return Ce(nn, Wc);
      }), Xo && Hs(nn, Fr), Jn;
    }
    function fr(nn, Qt, un, Vn) {
      var Jn = Dn(un);
      if (typeof Jn != "function")
        throw Error(fe(150));
      if (un = Jn.call(un), un == null)
        throw Error(fe(151));
      for (var xr = Jn = null, kr = Qt, Fr = Qt = 0, ri = null, Eo = un.next(); kr !== null && !Eo.done; Fr++, Eo = un.next()) {
        kr.index > Fr ? (ri = kr, kr = null) : ri = kr.sibling;
        var Wc = Nn(nn, kr, Eo.value, Vn);
        if (Wc === null) {
          kr === null && (kr = ri);
          break;
        }
        Se && kr && Wc.alternate === null && Ce(nn, kr), Qt = et(Wc, Qt, Fr), xr === null ? Jn = Wc : xr.sibling = Wc, xr = Wc, kr = ri;
      }
      if (Eo.done)
        return De(nn, kr), Xo && Hs(nn, Fr), Jn;
      if (kr === null) {
        for (; !Eo.done; Fr++, Eo = un.next())
          Eo = Ln(nn, Eo.value, Vn), Eo !== null && (Qt = et(Eo, Qt, Fr), xr === null ? Jn = Eo : xr.sibling = Eo, xr = Eo);
        return Xo && Hs(nn, Fr), Jn;
      }
      for (kr = Ue(nn, kr); !Eo.done; Fr++, Eo = un.next())
        Eo = er(kr, nn, Fr, Eo.value, Vn), Eo !== null && (Se && Eo.alternate !== null && kr.delete(Eo.key === null ? Fr : Eo.key), Qt = et(Eo, Qt, Fr), xr === null ? Jn = Eo : xr.sibling = Eo, xr = Eo);
      return Se && kr.forEach(function(N_) {
        return Ce(nn, N_);
      }), Xo && Hs(nn, Fr), Jn;
    }
    function Ca(nn, Qt, un, Vn) {
      if (typeof un == "object" && un !== null && un.type === St && un.key === null && (un = un.props.children), typeof un == "object" && un !== null) {
        switch (un.$$typeof) {
          case gt:
            e: {
              for (var Jn = un.key, xr = Qt; xr !== null; ) {
                if (xr.key === Jn) {
                  if (Jn = un.type, Jn === St) {
                    if (xr.tag === 7) {
                      De(nn, xr.sibling), Qt = Qe(xr, un.props.children), Qt.return = nn, nn = Qt;
                      break e;
                    }
                  } else if (xr.elementType === Jn || typeof Jn == "object" && Jn !== null && Jn.$$typeof === Ht && Cg(Jn) === xr.type) {
                    De(nn, xr.sibling), Qt = Qe(xr, un.props), Qt.ref = gf(nn, xr, un), Qt.return = nn, nn = Qt;
                    break e;
                  }
                  De(nn, xr);
                  break;
                } else
                  Ce(nn, xr);
                xr = xr.sibling;
              }
              un.type === St ? (Qt = Vc(un.props.children, nn.mode, Vn, un.key), Qt.return = nn, nn = Qt) : (Vn = cy(un.type, un.key, un.props, null, nn.mode, Vn), Vn.ref = gf(nn, Qt, un), Vn.return = nn, nn = Vn);
            }
            return bt(nn);
          case At:
            e: {
              for (xr = un.key; Qt !== null; ) {
                if (Qt.key === xr)
                  if (Qt.tag === 4 && Qt.stateNode.containerInfo === un.containerInfo && Qt.stateNode.implementation === un.implementation) {
                    De(nn, Qt.sibling), Qt = Qe(Qt, un.children || []), Qt.return = nn, nn = Qt;
                    break e;
                  } else {
                    De(nn, Qt);
                    break;
                  }
                else
                  Ce(nn, Qt);
                Qt = Qt.sibling;
              }
              Qt = Zb(un, nn.mode, Vn), Qt.return = nn, nn = Qt;
            }
            return bt(nn);
          case Ht:
            return xr = un._init, Ca(nn, Qt, xr(un._payload), Vn);
        }
        if (Fo(un))
          return lr(nn, Qt, un, Vn);
        if (Dn(un))
          return fr(nn, Qt, un, Vn);
        km(nn, un);
      }
      return typeof un == "string" && un !== "" || typeof un == "number" ? (un = "" + un, Qt !== null && Qt.tag === 6 ? (De(nn, Qt.sibling), Qt = Qe(Qt, un), Qt.return = nn, nn = Qt) : (De(nn, Qt), Qt = Hd(un, nn.mode, Vn), Qt.return = nn, nn = Qt), bt(nn)) : De(nn, Qt);
    }
    return Ca;
  }
  var wf = $g(!0), Ig = $g(!1), Tp = {}, Hu = qr(Tp), kp = qr(Tp), _f = qr(Tp);
  function xd(Se) {
    if (Se === Tp)
      throw Error(fe(174));
    return Se;
  }
  function kb(Se, Ce) {
    switch (Co(_f, Ce), Co(kp, Se), Co(Hu, Tp), Se = Ce.nodeType, Se) {
      case 9:
      case 11:
        Ce = (Ce = Ce.documentElement) ? Ce.namespaceURI : Bo(null, "");
        break;
      default:
        Se = Se === 8 ? Ce.parentNode : Ce, Ce = Se.namespaceURI || null, Se = Se.tagName, Ce = Bo(Ce, Se);
    }
    ko(Hu), Co(Hu, Ce);
  }
  function Nc() {
    ko(Hu), ko(kp), ko(_f);
  }
  function Tr(Se) {
    xd(_f.current);
    var Ce = xd(Hu.current), De = Bo(Ce, Se.type);
    Ce !== De && (Co(kp, Se), Co(Hu, De));
  }
  function oo(Se) {
    kp.current === Se && (ko(Hu), ko(kp));
  }
  var Rr = qr(0);
  function fa(Se) {
    for (var Ce = Se; Ce !== null; ) {
      if (Ce.tag === 13) {
        var De = Ce.memoizedState;
        if (De !== null && (De = De.dehydrated, De === null || De.data === "$?" || De.data === "$!"))
          return Ce;
      } else if (Ce.tag === 19 && Ce.memoizedProps.revealOrder !== void 0) {
        if (Ce.flags & 128)
          return Ce;
      } else if (Ce.child !== null) {
        Ce.child.return = Ce, Ce = Ce.child;
        continue;
      }
      if (Ce === Se)
        break;
      for (; Ce.sibling === null; ) {
        if (Ce.return === null || Ce.return === Se)
          return null;
        Ce = Ce.return;
      }
      Ce.sibling.return = Ce.return, Ce = Ce.sibling;
    }
    return null;
  }
  var hu = [];
  function Om() {
    for (var Se = 0; Se < hu.length; Se++)
      hu[Se]._workInProgressVersionPrimary = null;
    hu.length = 0;
  }
  var Am = ht.ReactCurrentDispatcher, Ob = ht.ReactCurrentBatchConfig, Pd = 0, Jo = null, xn = null, yo = null, Nr = !1, ll = !1, Zs = 0, Td = 0;
  function ea() {
    throw Error(fe(321));
  }
  function Od(Se, Ce) {
    if (Ce === null)
      return !1;
    for (var De = 0; De < Ce.length && De < Se.length; De++)
      if (!uu(Se[De], Ce[De]))
        return !1;
    return !0;
  }
  function Mc(Se, Ce, De, Ue, Qe, et) {
    if (Pd = et, Jo = Ce, Ce.memoizedState = null, Ce.updateQueue = null, Ce.lanes = 0, Am.current = Se === null || Se.memoizedState === null ? g_ : w_, Se = De(Ue, Qe), ll) {
      et = 0;
      do {
        if (ll = !1, Zs = 0, 25 <= et)
          throw Error(fe(301));
        et += 1, yo = xn = null, Ce.updateQueue = null, Am.current = Cb, Se = De(Ue, Qe);
      } while (ll);
    }
    if (Am.current = Wm, Ce = xn !== null && xn.next !== null, Pd = 0, yo = xn = Jo = null, Nr = !1, Ce)
      throw Error(fe(300));
    return Se;
  }
  function Ad() {
    var Se = Zs !== 0;
    return Zs = 0, Se;
  }
  function mu() {
    var Se = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return yo === null ? Jo.memoizedState = yo = Se : yo = yo.next = Se, yo;
  }
  function Ps() {
    if (xn === null) {
      var Se = Jo.alternate;
      Se = Se !== null ? Se.memoizedState : null;
    } else
      Se = xn.next;
    var Ce = yo === null ? Jo.memoizedState : yo.next;
    if (Ce !== null)
      yo = Ce, xn = Se;
    else {
      if (Se === null)
        throw Error(fe(310));
      xn = Se, Se = { memoizedState: xn.memoizedState, baseState: xn.baseState, baseQueue: xn.baseQueue, queue: xn.queue, next: null }, yo === null ? Jo.memoizedState = yo = Se : yo = yo.next = Se;
    }
    return yo;
  }
  function Cd(Se, Ce) {
    return typeof Ce == "function" ? Ce(Se) : Ce;
  }
  function Ap(Se) {
    var Ce = Ps(), De = Ce.queue;
    if (De === null)
      throw Error(fe(311));
    De.lastRenderedReducer = Se;
    var Ue = xn, Qe = Ue.baseQueue, et = De.pending;
    if (et !== null) {
      if (Qe !== null) {
        var bt = Qe.next;
        Qe.next = et.next, et.next = bt;
      }
      Ue.baseQueue = Qe = et, De.pending = null;
    }
    if (Qe !== null) {
      et = Qe.next, Ue = Ue.baseState;
      var It = bt = null, Ut = null, bn = et;
      do {
        var Rn = bn.lane;
        if ((Pd & Rn) === Rn)
          Ut !== null && (Ut = Ut.next = { lane: 0, action: bn.action, hasEagerState: bn.hasEagerState, eagerState: bn.eagerState, next: null }), Ue = bn.hasEagerState ? bn.eagerState : Se(Ue, bn.action);
        else {
          var Ln = { lane: Rn, action: bn.action, hasEagerState: bn.hasEagerState, eagerState: bn.eagerState, next: null };
          Ut === null ? (It = Ut = Ln, bt = Ue) : Ut = Ut.next = Ln, Jo.lanes |= Rn, Ld |= Rn;
        }
        bn = bn.next;
      } while (bn !== null && bn !== et);
      Ut === null ? bt = Ue : Ut.next = It, uu(Ue, Ce.memoizedState) || (za = !0), Ce.memoizedState = Ue, Ce.baseState = bt, Ce.baseQueue = Ut, De.lastRenderedState = Ue;
    }
    if (Se = De.interleaved, Se !== null) {
      Qe = Se;
      do
        et = Qe.lane, Jo.lanes |= et, Ld |= et, Qe = Qe.next;
      while (Qe !== Se);
    } else
      Qe === null && (De.lanes = 0);
    return [Ce.memoizedState, De.dispatch];
  }
  function Cp(Se) {
    var Ce = Ps(), De = Ce.queue;
    if (De === null)
      throw Error(fe(311));
    De.lastRenderedReducer = Se;
    var Ue = De.dispatch, Qe = De.pending, et = Ce.memoizedState;
    if (Qe !== null) {
      De.pending = null;
      var bt = Qe = Qe.next;
      do
        et = Se(et, bt.action), bt = bt.next;
      while (bt !== Qe);
      uu(et, Ce.memoizedState) || (za = !0), Ce.memoizedState = et, Ce.baseQueue === null && (Ce.baseState = et), De.lastRenderedState = et;
    }
    return [et, Ue];
  }
  function Cm() {
  }
  function $m(Se, Ce) {
    var De = Jo, Ue = Ps(), Qe = Ce(), et = !uu(Ue.memoizedState, Qe);
    if (et && (Ue.memoizedState = Qe, za = !0), Ue = Ue.queue, $p(Nm.bind(null, De, Ue, Se), [Se]), Ue.getSnapshot !== Ce || et || yo !== null && yo.memoizedState.tag & 1) {
      if (De.flags |= 2048, $d(9, Rm.bind(null, De, Ue, Qe, Ce), void 0, null), Ua === null)
        throw Error(fe(349));
      Pd & 30 || Im(De, Ce, Qe);
    }
    return Qe;
  }
  function Im(Se, Ce, De) {
    Se.flags |= 16384, Se = { getSnapshot: Ce, value: De }, Ce = Jo.updateQueue, Ce === null ? (Ce = { lastEffect: null, stores: null }, Jo.updateQueue = Ce, Ce.stores = [Se]) : (De = Ce.stores, De === null ? Ce.stores = [Se] : De.push(Se));
  }
  function Rm(Se, Ce, De, Ue) {
    Ce.value = De, Ce.getSnapshot = Ue, Mm(Ce) && jm(Se);
  }
  function Nm(Se, Ce, De) {
    return De(function() {
      Mm(Ce) && jm(Se);
    });
  }
  function Mm(Se) {
    var Ce = Se.getSnapshot;
    Se = Se.value;
    try {
      var De = Ce();
      return !uu(Se, De);
    } catch {
      return !0;
    }
  }
  function jm(Se) {
    var Ce = Ml(Se, 1);
    Ce !== null && Ks(Ce, Se, 1, -1);
  }
  function Dm(Se) {
    var Ce = mu();
    return typeof Se == "function" && (Se = Se()), Ce.memoizedState = Ce.baseState = Se, Se = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Cd, lastRenderedState: Se }, Ce.queue = Se, Se = Se.dispatch = Hm.bind(null, Jo, Se), [Ce.memoizedState, Se];
  }
  function $d(Se, Ce, De, Ue) {
    return Se = { tag: Se, create: Ce, destroy: De, deps: Ue, next: null }, Ce = Jo.updateQueue, Ce === null ? (Ce = { lastEffect: null, stores: null }, Jo.updateQueue = Ce, Ce.lastEffect = Se.next = Se) : (De = Ce.lastEffect, De === null ? Ce.lastEffect = Se.next = Se : (Ue = De.next, De.next = Se, Se.next = Ue, Ce.lastEffect = Se)), Se;
  }
  function Lm() {
    return Ps().memoizedState;
  }
  function Id(Se, Ce, De, Ue) {
    var Qe = mu();
    Jo.flags |= Se, Qe.memoizedState = $d(1 | Ce, De, void 0, Ue === void 0 ? null : Ue);
  }
  function Bl(Se, Ce, De, Ue) {
    var Qe = Ps();
    Ue = Ue === void 0 ? null : Ue;
    var et = void 0;
    if (xn !== null) {
      var bt = xn.memoizedState;
      if (et = bt.destroy, Ue !== null && Od(Ue, bt.deps)) {
        Qe.memoizedState = $d(Ce, De, et, Ue);
        return;
      }
    }
    Jo.flags |= Se, Qe.memoizedState = $d(1 | Ce, De, et, Ue);
  }
  function Fm(Se, Ce) {
    return Id(8390656, 8, Se, Ce);
  }
  function $p(Se, Ce) {
    return Bl(2048, 8, Se, Ce);
  }
  function Bm(Se, Ce) {
    return Bl(4, 2, Se, Ce);
  }
  function zm(Se, Ce) {
    return Bl(4, 4, Se, Ce);
  }
  function Ab(Se, Ce) {
    if (typeof Ce == "function")
      return Se = Se(), Ce(Se), function() {
        Ce(null);
      };
    if (Ce != null)
      return Se = Se(), Ce.current = Se, function() {
        Ce.current = null;
      };
  }
  function Ef(Se, Ce, De) {
    return De = De != null ? De.concat([Se]) : null, Bl(4, 4, Ab.bind(null, Ce, Se), De);
  }
  function Um() {
  }
  function xf(Se, Ce) {
    var De = Ps();
    Ce = Ce === void 0 ? null : Ce;
    var Ue = De.memoizedState;
    return Ue !== null && Ce !== null && Od(Ce, Ue[1]) ? Ue[0] : (De.memoizedState = [Se, Ce], Se);
  }
  function jc(Se, Ce) {
    var De = Ps();
    Ce = Ce === void 0 ? null : Ce;
    var Ue = De.memoizedState;
    return Ue !== null && Ce !== null && Od(Ce, Ue[1]) ? Ue[0] : (Se = Se(), De.memoizedState = [Se, Ce], Se);
  }
  function Ts(Se, Ce, De) {
    return Pd & 21 ? (uu(De, Ce) || (De = ru(), Jo.lanes |= De, Ld |= De, Se.baseState = !0), Ce) : (Se.baseState && (Se.baseState = !1, za = !0), Se.memoizedState = De);
  }
  function v_(Se, Ce) {
    var De = po;
    po = De !== 0 && 4 > De ? De : 4, Se(!0);
    var Ue = Ob.transition;
    Ob.transition = {};
    try {
      Se(!1), Ce();
    } finally {
      po = De, Ob.transition = Ue;
    }
  }
  function Vo() {
    return Ps().memoizedState;
  }
  function Vm(Se, Ce, De) {
    var Ue = Qs(Se);
    if (De = { lane: Ue, action: De, hasEagerState: !1, eagerState: null, next: null }, Sf(Se))
      Ip(Ce, De);
    else if (De = Pg(Se, Ce, De, Ue), De !== null) {
      var Qe = Ho();
      Ks(De, Se, Ue, Qe), Rg(De, Ce, Ue);
    }
  }
  function Hm(Se, Ce, De) {
    var Ue = Qs(Se), Qe = { lane: Ue, action: De, hasEagerState: !1, eagerState: null, next: null };
    if (Sf(Se))
      Ip(Ce, Qe);
    else {
      var et = Se.alternate;
      if (Se.lanes === 0 && (et === null || et.lanes === 0) && (et = Ce.lastRenderedReducer, et !== null))
        try {
          var bt = Ce.lastRenderedState, It = et(bt, De);
          if (Qe.hasEagerState = !0, Qe.eagerState = It, uu(It, bt)) {
            var Ut = Ce.interleaved;
            Ut === null ? (Qe.next = Qe, xb(Ce)) : (Qe.next = Ut.next, Ut.next = Qe), Ce.interleaved = Qe;
            return;
          }
        } catch {
        } finally {
        }
      De = Pg(Se, Ce, Qe, Ue), De !== null && (Qe = Ho(), Ks(De, Se, Ue, Qe), Rg(De, Ce, Ue));
    }
  }
  function Sf(Se) {
    var Ce = Se.alternate;
    return Se === Jo || Ce !== null && Ce === Jo;
  }
  function Ip(Se, Ce) {
    ll = Nr = !0;
    var De = Se.pending;
    De === null ? Ce.next = Ce : (Ce.next = De.next, De.next = Ce), Se.pending = Ce;
  }
  function Rg(Se, Ce, De) {
    if (De & 4194240) {
      var Ue = Ce.lanes;
      Ue &= Se.pendingLanes, De |= Ue, Ce.lanes = De, Fs(Se, De);
    }
  }
  var Wm = { readContext: Oa, useCallback: ea, useContext: ea, useEffect: ea, useImperativeHandle: ea, useInsertionEffect: ea, useLayoutEffect: ea, useMemo: ea, useReducer: ea, useRef: ea, useState: ea, useDebugValue: ea, useDeferredValue: ea, useTransition: ea, useMutableSource: ea, useSyncExternalStore: ea, useId: ea, unstable_isNewReconciler: !1 }, g_ = { readContext: Oa, useCallback: function(Se, Ce) {
    return mu().memoizedState = [Se, Ce === void 0 ? null : Ce], Se;
  }, useContext: Oa, useEffect: Fm, useImperativeHandle: function(Se, Ce, De) {
    return De = De != null ? De.concat([Se]) : null, Id(4194308, 4, Ab.bind(null, Ce, Se), De);
  }, useLayoutEffect: function(Se, Ce) {
    return Id(4194308, 4, Se, Ce);
  }, useInsertionEffect: function(Se, Ce) {
    return Id(4, 2, Se, Ce);
  }, useMemo: function(Se, Ce) {
    var De = mu();
    return Ce = Ce === void 0 ? null : Ce, Se = Se(), De.memoizedState = [Se, Ce], Se;
  }, useReducer: function(Se, Ce, De) {
    var Ue = mu();
    return Ce = De !== void 0 ? De(Ce) : Ce, Ue.memoizedState = Ue.baseState = Ce, Se = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Se, lastRenderedState: Ce }, Ue.queue = Se, Se = Se.dispatch = Vm.bind(null, Jo, Se), [Ue.memoizedState, Se];
  }, useRef: function(Se) {
    var Ce = mu();
    return Se = { current: Se }, Ce.memoizedState = Se;
  }, useState: Dm, useDebugValue: Um, useDeferredValue: function(Se) {
    return mu().memoizedState = Se;
  }, useTransition: function() {
    var Se = Dm(!1), Ce = Se[0];
    return Se = v_.bind(null, Se[1]), mu().memoizedState = Se, [Ce, Se];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(Se, Ce, De) {
    var Ue = Jo, Qe = mu();
    if (Xo) {
      if (De === void 0)
        throw Error(fe(407));
      De = De();
    } else {
      if (De = Ce(), Ua === null)
        throw Error(fe(349));
      Pd & 30 || Im(Ue, Ce, De);
    }
    Qe.memoizedState = De;
    var et = { value: De, getSnapshot: Ce };
    return Qe.queue = et, Fm(Nm.bind(null, Ue, et, Se), [Se]), Ue.flags |= 2048, $d(9, Rm.bind(null, Ue, et, De, Ce), void 0, null), De;
  }, useId: function() {
    var Se = mu(), Ce = Ua.identifierPrefix;
    if (Xo) {
      var De = Nl, Ue = xi;
      De = (Ue & ~(1 << 32 - ja(Ue) - 1)).toString(32) + De, Ce = ":" + Ce + "R" + De, De = Zs++, 0 < De && (Ce += "H" + De.toString(32)), Ce += ":";
    } else
      De = Td++, Ce = ":" + Ce + "r" + De.toString(32) + ":";
    return Se.memoizedState = Ce;
  }, unstable_isNewReconciler: !1 }, w_ = { readContext: Oa, useCallback: xf, useContext: Oa, useEffect: $p, useImperativeHandle: Ef, useInsertionEffect: Bm, useLayoutEffect: zm, useMemo: jc, useReducer: Ap, useRef: Lm, useState: function() {
    return Ap(Cd);
  }, useDebugValue: Um, useDeferredValue: function(Se) {
    var Ce = Ps();
    return Ts(Ce, xn.memoizedState, Se);
  }, useTransition: function() {
    var Se = Ap(Cd)[0], Ce = Ps().memoizedState;
    return [Se, Ce];
  }, useMutableSource: Cm, useSyncExternalStore: $m, useId: Vo, unstable_isNewReconciler: !1 }, Cb = { readContext: Oa, useCallback: xf, useContext: Oa, useEffect: $p, useImperativeHandle: Ef, useInsertionEffect: Bm, useLayoutEffect: zm, useMemo: jc, useReducer: Cp, useRef: Lm, useState: function() {
    return Cp(Cd);
  }, useDebugValue: Um, useDeferredValue: function(Se) {
    var Ce = Ps();
    return xn === null ? Ce.memoizedState = Se : Ts(Ce, xn.memoizedState, Se);
  }, useTransition: function() {
    var Se = Cp(Cd)[0], Ce = Ps().memoizedState;
    return [Se, Ce];
  }, useMutableSource: Cm, useSyncExternalStore: $m, useId: Vo, unstable_isNewReconciler: !1 };
  function Pf(Se, Ce) {
    try {
      var De = "", Ue = Ce;
      do
        De += vn(Ue), Ue = Ue.return;
      while (Ue);
      var Qe = De;
    } catch (et) {
      Qe = `
Error generating stack: ` + et.message + `
` + et.stack;
    }
    return { value: Se, source: Ce, stack: Qe, digest: null };
  }
  function Rp(Se, Ce, De) {
    return { value: Se, source: null, stack: De ?? null, digest: Ce ?? null };
  }
  function qm(Se, Ce) {
    try {
      console.error(Ce.value);
    } catch (De) {
      setTimeout(function() {
        throw De;
      });
    }
  }
  var __ = typeof WeakMap == "function" ? WeakMap : Map;
  function Ng(Se, Ce, De) {
    De = Dl(-1, De), De.tag = 3, De.payload = { element: null };
    var Ue = Ce.value;
    return De.callback = function() {
      Fc || (Fc = !0, Up = Ue), qm(Se, Ce);
    }, De;
  }
  function Np(Se, Ce, De) {
    De = Dl(-1, De), De.tag = 3;
    var Ue = Se.type.getDerivedStateFromError;
    if (typeof Ue == "function") {
      var Qe = Ce.value;
      De.payload = function() {
        return Ue(Qe);
      }, De.callback = function() {
        qm(Se, Ce);
      };
    }
    var et = Se.stateNode;
    return et !== null && typeof et.componentDidCatch == "function" && (De.callback = function() {
      qm(Se, Ce), typeof Ue != "function" && (vu === null ? vu = /* @__PURE__ */ new Set([this]) : vu.add(this));
      var bt = Ce.stack;
      this.componentDidCatch(Ce.value, { componentStack: bt !== null ? bt : "" });
    }), De;
  }
  function Mg(Se, Ce, De) {
    var Ue = Se.pingCache;
    if (Ue === null) {
      Ue = Se.pingCache = new __();
      var Qe = /* @__PURE__ */ new Set();
      Ue.set(Ce, Qe);
    } else
      Qe = Ue.get(Ce), Qe === void 0 && (Qe = /* @__PURE__ */ new Set(), Ue.set(Ce, Qe));
    Qe.has(De) || (Qe.add(De), Se = Hb.bind(null, Se, Ce, De), Ce.then(Se, Se));
  }
  function $b(Se) {
    do {
      var Ce;
      if ((Ce = Se.tag === 13) && (Ce = Se.memoizedState, Ce = Ce !== null ? Ce.dehydrated !== null : !0), Ce)
        return Se;
      Se = Se.return;
    } while (Se !== null);
    return null;
  }
  function Ib(Se, Ce, De, Ue, Qe) {
    return Se.mode & 1 ? (Se.flags |= 65536, Se.lanes = Qe, Se) : (Se === Ce ? Se.flags |= 65536 : (Se.flags |= 128, De.flags |= 131072, De.flags &= -52805, De.tag === 1 && (De.alternate === null ? De.tag = 17 : (Ce = Dl(-1, 1), Ce.tag = 2, $c(De, Ce, 1))), De.lanes |= 1), Se);
  }
  var E_ = ht.ReactCurrentOwner, za = !1;
  function ei(Se, Ce, De, Ue) {
    Ce.child = Se === null ? Ig(Ce, null, De, Ue) : wf(Ce, Se.child, De, Ue);
  }
  function Dc(Se, Ce, De, Ue, Qe) {
    De = De.render;
    var et = Ce.ref;
    return Gn(Ce, Qe), Ue = Mc(Se, Ce, De, Ue, et, Qe), De = Ad(), Se !== null && !za ? (Ce.updateQueue = Se.updateQueue, Ce.flags &= -2053, Se.lanes &= ~Qe, Pi(Se, Ce, Qe)) : (Xo && De && vm(Ce), Ce.flags |= 1, ei(Se, Ce, Ue, Qe), Ce.child);
  }
  function Gm(Se, Ce, De, Ue, Qe) {
    if (Se === null) {
      var et = De.type;
      return typeof et == "function" && !qb(et) && et.defaultProps === void 0 && De.compare === null && De.defaultProps === void 0 ? (Ce.tag = 15, Ce.type = et, ks(Se, Ce, et, Ue, Qe)) : (Se = cy(De.type, null, Ue, Ce, Ce.mode, Qe), Se.ref = Ce.ref, Se.return = Ce, Ce.child = Se);
    }
    if (et = Se.child, !(Se.lanes & Qe)) {
      var bt = et.memoizedProps;
      if (De = De.compare, De = De !== null ? De : mp, De(bt, Ue) && Se.ref === Ce.ref)
        return Pi(Se, Ce, Qe);
    }
    return Ce.flags |= 1, Se = Uc(et, Ue), Se.ref = Ce.ref, Se.return = Ce, Ce.child = Se;
  }
  function ks(Se, Ce, De, Ue, Qe) {
    if (Se !== null) {
      var et = Se.memoizedProps;
      if (mp(et, Ue) && Se.ref === Ce.ref)
        if (za = !1, Ce.pendingProps = Ue = et, (Se.lanes & Qe) !== 0)
          Se.flags & 131072 && (za = !0);
        else
          return Ce.lanes = Se.lanes, Pi(Se, Ce, Qe);
    }
    return Tf(Se, Ce, De, Ue, Qe);
  }
  function Rd(Se, Ce, De) {
    var Ue = Ce.pendingProps, Qe = Ue.children, et = Se !== null ? Se.memoizedState : null;
    if (Ue.mode === "hidden")
      if (!(Ce.mode & 1))
        Ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Co(Cf, Ys), Ys |= De;
      else {
        if (!(De & 1073741824))
          return Se = et !== null ? et.baseLanes | De : De, Ce.lanes = Ce.childLanes = 1073741824, Ce.memoizedState = { baseLanes: Se, cachePool: null, transitions: null }, Ce.updateQueue = null, Co(Cf, Ys), Ys |= Se, null;
        Ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ue = et !== null ? et.baseLanes : De, Co(Cf, Ys), Ys |= Ue;
      }
    else
      et !== null ? (Ue = et.baseLanes | De, Ce.memoizedState = null) : Ue = De, Co(Cf, Ys), Ys |= Ue;
    return ei(Se, Ce, Qe, De), Ce.child;
  }
  function Zr(Se, Ce) {
    var De = Ce.ref;
    (Se === null && De !== null || Se !== null && Se.ref !== De) && (Ce.flags |= 512, Ce.flags |= 2097152);
  }
  function Tf(Se, Ce, De, Ue, Qe) {
    var et = sa(De) ? ws : Lr.current;
    return et = cu(Ce, et), Gn(Ce, Qe), De = Mc(Se, Ce, De, Ue, et, Qe), Ue = Ad(), Se !== null && !za ? (Ce.updateQueue = Se.updateQueue, Ce.flags &= -2053, Se.lanes &= ~Qe, Pi(Se, Ce, Qe)) : (Xo && Ue && vm(Ce), Ce.flags |= 1, ei(Se, Ce, De, Qe), Ce.child);
  }
  function Rb(Se, Ce, De, Ue, Qe) {
    if (sa(De)) {
      var et = !0;
      bm(Ce);
    } else
      et = !1;
    if (Gn(Ce, Qe), Ce.stateNode === null)
      yu(Se, Ce), Og(Ce, De, Ue), Tm(Ce, De, Ue, Qe), Ue = !0;
    else if (Se === null) {
      var bt = Ce.stateNode, It = Ce.memoizedProps;
      bt.props = It;
      var Ut = bt.context, bn = De.contextType;
      typeof bn == "object" && bn !== null ? bn = Oa(bn) : (bn = sa(De) ? ws : Lr.current, bn = cu(Ce, bn));
      var Rn = De.getDerivedStateFromProps, Ln = typeof Rn == "function" || typeof bt.getSnapshotBeforeUpdate == "function";
      Ln || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (It !== Ue || Ut !== bn) && Ag(Ce, bt, Ue, bn), Ac = !1;
      var Nn = Ce.memoizedState;
      bt.state = Nn, Ic(Ce, Ue, bt, Qe), Ut = Ce.memoizedState, It !== Ue || Nn !== Ut || Sa.current || Ac ? (typeof Rn == "function" && (Tb(Ce, De, Rn, Ue), Ut = Ce.memoizedState), (It = Ac || kg(Ce, De, It, Ue, Nn, Ut, bn)) ? (Ln || typeof bt.UNSAFE_componentWillMount != "function" && typeof bt.componentWillMount != "function" || (typeof bt.componentWillMount == "function" && bt.componentWillMount(), typeof bt.UNSAFE_componentWillMount == "function" && bt.UNSAFE_componentWillMount()), typeof bt.componentDidMount == "function" && (Ce.flags |= 4194308)) : (typeof bt.componentDidMount == "function" && (Ce.flags |= 4194308), Ce.memoizedProps = Ue, Ce.memoizedState = Ut), bt.props = Ue, bt.state = Ut, bt.context = bn, Ue = It) : (typeof bt.componentDidMount == "function" && (Ce.flags |= 4194308), Ue = !1);
    } else {
      bt = Ce.stateNode, Xa(Se, Ce), It = Ce.memoizedProps, bn = Ce.type === Ce.elementType ? It : qs(Ce.type, It), bt.props = bn, Ln = Ce.pendingProps, Nn = bt.context, Ut = De.contextType, typeof Ut == "object" && Ut !== null ? Ut = Oa(Ut) : (Ut = sa(De) ? ws : Lr.current, Ut = cu(Ce, Ut));
      var er = De.getDerivedStateFromProps;
      (Rn = typeof er == "function" || typeof bt.getSnapshotBeforeUpdate == "function") || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (It !== Ln || Nn !== Ut) && Ag(Ce, bt, Ue, Ut), Ac = !1, Nn = Ce.memoizedState, bt.state = Nn, Ic(Ce, Ue, bt, Qe);
      var lr = Ce.memoizedState;
      It !== Ln || Nn !== lr || Sa.current || Ac ? (typeof er == "function" && (Tb(Ce, De, er, Ue), lr = Ce.memoizedState), (bn = Ac || kg(Ce, De, bn, Ue, Nn, lr, Ut) || !1) ? (Rn || typeof bt.UNSAFE_componentWillUpdate != "function" && typeof bt.componentWillUpdate != "function" || (typeof bt.componentWillUpdate == "function" && bt.componentWillUpdate(Ue, lr, Ut), typeof bt.UNSAFE_componentWillUpdate == "function" && bt.UNSAFE_componentWillUpdate(Ue, lr, Ut)), typeof bt.componentDidUpdate == "function" && (Ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate == "function" && (Ce.flags |= 1024)) : (typeof bt.componentDidUpdate != "function" || It === Se.memoizedProps && Nn === Se.memoizedState || (Ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || It === Se.memoizedProps && Nn === Se.memoizedState || (Ce.flags |= 1024), Ce.memoizedProps = Ue, Ce.memoizedState = lr), bt.props = Ue, bt.state = lr, bt.context = Ut, Ue = bn) : (typeof bt.componentDidUpdate != "function" || It === Se.memoizedProps && Nn === Se.memoizedState || (Ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || It === Se.memoizedProps && Nn === Se.memoizedState || (Ce.flags |= 1024), Ue = !1);
    }
    return Nb(Se, Ce, De, Ue, et, Qe);
  }
  function Nb(Se, Ce, De, Ue, Qe, et) {
    Zr(Se, Ce);
    var bt = (Ce.flags & 128) !== 0;
    if (!Ue && !bt)
      return Qe && _g(Ce, De, !1), Pi(Se, Ce, et);
    Ue = Ce.stateNode, E_.current = Ce;
    var It = bt && typeof De.getDerivedStateFromError != "function" ? null : Ue.render();
    return Ce.flags |= 1, Se !== null && bt ? (Ce.child = wf(Ce, Se.child, null, et), Ce.child = wf(Ce, null, It, et)) : ei(Se, Ce, It, et), Ce.memoizedState = Ue.state, Qe && _g(Ce, De, !0), Ce.child;
  }
  function Ym(Se) {
    var Ce = Se.stateNode;
    Ce.pendingContext ? gc(Se, Ce.pendingContext, Ce.pendingContext !== Ce.context) : Ce.context && gc(Se, Ce.context, !1), kb(Se, Ce.containerInfo);
  }
  function kf(Se, Ce, De, Ue, Qe) {
    return da(), wb(Qe), Ce.flags |= 256, ei(Se, Ce, De, Ue), Ce.child;
  }
  var Mb = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Qm(Se) {
    return { baseLanes: Se, cachePool: null, transitions: null };
  }
  function jg(Se, Ce, De) {
    var Ue = Ce.pendingProps, Qe = Rr.current, et = !1, bt = (Ce.flags & 128) !== 0, It;
    if ((It = bt) || (It = Se !== null && Se.memoizedState === null ? !1 : (Qe & 2) !== 0), It ? (et = !0, Ce.flags &= -129) : (Se === null || Se.memoizedState !== null) && (Qe |= 1), Co(Rr, Qe & 1), Se === null)
      return wm(Ce), Se = Ce.memoizedState, Se !== null && (Se = Se.dehydrated, Se !== null) ? (Ce.mode & 1 ? Se.data === "$!" ? Ce.lanes = 8 : Ce.lanes = 1073741824 : Ce.lanes = 1, null) : (bt = Ue.children, Se = Ue.fallback, et ? (Ue = Ce.mode, et = Ce.child, bt = { mode: "hidden", children: bt }, !(Ue & 1) && et !== null ? (et.childLanes = 0, et.pendingProps = bt) : et = jf(bt, Ue, 0, null), Se = Vc(Se, Ue, De, null), et.return = Ce, Se.return = Ce, et.sibling = Se, Ce.child = et, Ce.child.memoizedState = Qm(De), Ce.memoizedState = Mb, Se) : Mp(Ce, bt));
    if (Qe = Se.memoizedState, Qe !== null && (It = Qe.dehydrated, It !== null))
      return Dg(Se, Ce, bt, Ue, It, Qe, De);
    if (et) {
      et = Ue.fallback, bt = Ce.mode, Qe = Se.child, It = Qe.sibling;
      var Ut = { mode: "hidden", children: Ue.children };
      return !(bt & 1) && Ce.child !== Qe ? (Ue = Ce.child, Ue.childLanes = 0, Ue.pendingProps = Ut, Ce.deletions = null) : (Ue = Uc(Qe, Ut), Ue.subtreeFlags = Qe.subtreeFlags & 14680064), It !== null ? et = Uc(It, et) : (et = Vc(et, bt, De, null), et.flags |= 2), et.return = Ce, Ue.return = Ce, Ue.sibling = et, Ce.child = Ue, Ue = et, et = Ce.child, bt = Se.child.memoizedState, bt = bt === null ? Qm(De) : { baseLanes: bt.baseLanes | De, cachePool: null, transitions: bt.transitions }, et.memoizedState = bt, et.childLanes = Se.childLanes & ~De, Ce.memoizedState = Mb, Ue;
    }
    return et = Se.child, Se = et.sibling, Ue = Uc(et, { mode: "visible", children: Ue.children }), !(Ce.mode & 1) && (Ue.lanes = De), Ue.return = Ce, Ue.sibling = null, Se !== null && (De = Ce.deletions, De === null ? (Ce.deletions = [Se], Ce.flags |= 16) : De.push(Se)), Ce.child = Ue, Ce.memoizedState = null, Ue;
  }
  function Mp(Se, Ce) {
    return Ce = jf({ mode: "visible", children: Ce }, Se.mode, 0, null), Ce.return = Se, Se.child = Ce;
  }
  function Km(Se, Ce, De, Ue) {
    return Ue !== null && wb(Ue), wf(Ce, Se.child, null, De), Se = Mp(Ce, Ce.pendingProps.children), Se.flags |= 2, Ce.memoizedState = null, Se;
  }
  function Dg(Se, Ce, De, Ue, Qe, et, bt) {
    if (De)
      return Ce.flags & 256 ? (Ce.flags &= -257, Ue = Rp(Error(fe(422))), Km(Se, Ce, bt, Ue)) : Ce.memoizedState !== null ? (Ce.child = Se.child, Ce.flags |= 128, null) : (et = Ue.fallback, Qe = Ce.mode, Ue = jf({ mode: "visible", children: Ue.children }, Qe, 0, null), et = Vc(et, Qe, bt, null), et.flags |= 2, Ue.return = Ce, et.return = Ce, Ue.sibling = et, Ce.child = Ue, Ce.mode & 1 && wf(Ce, Se.child, null, bt), Ce.child.memoizedState = Qm(bt), Ce.memoizedState = Mb, et);
    if (!(Ce.mode & 1))
      return Km(Se, Ce, bt, null);
    if (Qe.data === "$!") {
      if (Ue = Qe.nextSibling && Qe.nextSibling.dataset, Ue)
        var It = Ue.dgst;
      return Ue = It, et = Error(fe(419)), Ue = Rp(et, Ue, void 0), Km(Se, Ce, bt, Ue);
    }
    if (It = (bt & Se.childLanes) !== 0, za || It) {
      if (Ue = Ua, Ue !== null) {
        switch (bt & -bt) {
          case 4:
            Qe = 2;
            break;
          case 16:
            Qe = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            Qe = 32;
            break;
          case 536870912:
            Qe = 268435456;
            break;
          default:
            Qe = 0;
        }
        Qe = Qe & (Ue.suspendedLanes | bt) ? 0 : Qe, Qe !== 0 && Qe !== et.retryLane && (et.retryLane = Qe, Ml(Se, Qe), Ks(Ue, Se, Qe, -1));
      }
      return Ub(), Ue = Rp(Error(fe(421))), Km(Se, Ce, bt, Ue);
    }
    return Qe.data === "$?" ? (Ce.flags |= 128, Ce.child = Se.child, Ce = O_.bind(null, Se), Qe._reactRetry = Ce, null) : (Se = et.treeContext, Ss = Vu(Qe.nextSibling), Ws = Ce, Xo = !0, pu = null, Se !== null && (xs[Wi++] = xi, xs[Wi++] = Nl, xs[Wi++] = fu, xi = Se.id, Nl = Se.overflow, fu = Ce), Ce = Mp(Ce, Ue.children), Ce.flags |= 4096, Ce);
  }
  function jb(Se, Ce, De) {
    Se.lanes |= Ce;
    var Ue = Se.alternate;
    Ue !== null && (Ue.lanes |= Ce), yi(Se.return, Ce, De);
  }
  function ey(Se, Ce, De, Ue, Qe) {
    var et = Se.memoizedState;
    et === null ? Se.memoizedState = { isBackwards: Ce, rendering: null, renderingStartTime: 0, last: Ue, tail: De, tailMode: Qe } : (et.isBackwards = Ce, et.rendering = null, et.renderingStartTime = 0, et.last = Ue, et.tail = De, et.tailMode = Qe);
  }
  function Os(Se, Ce, De) {
    var Ue = Ce.pendingProps, Qe = Ue.revealOrder, et = Ue.tail;
    if (ei(Se, Ce, Ue.children, De), Ue = Rr.current, Ue & 2)
      Ue = Ue & 1 | 2, Ce.flags |= 128;
    else {
      if (Se !== null && Se.flags & 128)
        e:
          for (Se = Ce.child; Se !== null; ) {
            if (Se.tag === 13)
              Se.memoizedState !== null && jb(Se, De, Ce);
            else if (Se.tag === 19)
              jb(Se, De, Ce);
            else if (Se.child !== null) {
              Se.child.return = Se, Se = Se.child;
              continue;
            }
            if (Se === Ce)
              break e;
            for (; Se.sibling === null; ) {
              if (Se.return === null || Se.return === Ce)
                break e;
              Se = Se.return;
            }
            Se.sibling.return = Se.return, Se = Se.sibling;
          }
      Ue &= 1;
    }
    if (Co(Rr, Ue), !(Ce.mode & 1))
      Ce.memoizedState = null;
    else
      switch (Qe) {
        case "forwards":
          for (De = Ce.child, Qe = null; De !== null; )
            Se = De.alternate, Se !== null && fa(Se) === null && (Qe = De), De = De.sibling;
          De = Qe, De === null ? (Qe = Ce.child, Ce.child = null) : (Qe = De.sibling, De.sibling = null), ey(Ce, !1, Qe, De, et);
          break;
        case "backwards":
          for (De = null, Qe = Ce.child, Ce.child = null; Qe !== null; ) {
            if (Se = Qe.alternate, Se !== null && fa(Se) === null) {
              Ce.child = Qe;
              break;
            }
            Se = Qe.sibling, Qe.sibling = De, De = Qe, Qe = Se;
          }
          ey(Ce, !0, De, null, et);
          break;
        case "together":
          ey(Ce, !1, null, null, void 0);
          break;
        default:
          Ce.memoizedState = null;
      }
    return Ce.child;
  }
  function yu(Se, Ce) {
    !(Ce.mode & 1) && Se !== null && (Se.alternate = null, Ce.alternate = null, Ce.flags |= 2);
  }
  function Pi(Se, Ce, De) {
    if (Se !== null && (Ce.dependencies = Se.dependencies), Ld |= Ce.lanes, !(De & Ce.childLanes))
      return null;
    if (Se !== null && Ce.child !== Se.child)
      throw Error(fe(153));
    if (Ce.child !== null) {
      for (Se = Ce.child, De = Uc(Se, Se.pendingProps), Ce.child = De, De.return = Ce; Se.sibling !== null; )
        Se = Se.sibling, De = De.sibling = Uc(Se, Se.pendingProps), De.return = Ce;
      De.sibling = null;
    }
    return Ce.child;
  }
  function ty(Se, Ce, De) {
    switch (Ce.tag) {
      case 3:
        Ym(Ce), da();
        break;
      case 5:
        Tr(Ce);
        break;
      case 1:
        sa(Ce.type) && bm(Ce);
        break;
      case 4:
        kb(Ce, Ce.stateNode.containerInfo);
        break;
      case 10:
        var Ue = Ce.type._context, Qe = Ce.memoizedProps.value;
        Co(ul, Ue._currentValue), Ue._currentValue = Qe;
        break;
      case 13:
        if (Ue = Ce.memoizedState, Ue !== null)
          return Ue.dehydrated !== null ? (Co(Rr, Rr.current & 1), Ce.flags |= 128, null) : De & Ce.child.childLanes ? jg(Se, Ce, De) : (Co(Rr, Rr.current & 1), Se = Pi(Se, Ce, De), Se !== null ? Se.sibling : null);
        Co(Rr, Rr.current & 1);
        break;
      case 19:
        if (Ue = (De & Ce.childLanes) !== 0, Se.flags & 128) {
          if (Ue)
            return Os(Se, Ce, De);
          Ce.flags |= 128;
        }
        if (Qe = Ce.memoizedState, Qe !== null && (Qe.rendering = null, Qe.tail = null, Qe.lastEffect = null), Co(Rr, Rr.current), Ue)
          break;
        return null;
      case 22:
      case 23:
        return Ce.lanes = 0, Rd(Se, Ce, De);
    }
    return Pi(Se, Ce, De);
  }
  var Of, Gs, ti, Lg;
  Of = function(Se, Ce) {
    for (var De = Ce.child; De !== null; ) {
      if (De.tag === 5 || De.tag === 6)
        Se.appendChild(De.stateNode);
      else if (De.tag !== 4 && De.child !== null) {
        De.child.return = De, De = De.child;
        continue;
      }
      if (De === Ce)
        break;
      for (; De.sibling === null; ) {
        if (De.return === null || De.return === Ce)
          return;
        De = De.return;
      }
      De.sibling.return = De.return, De = De.sibling;
    }
  }, Gs = function() {
  }, ti = function(Se, Ce, De, Ue) {
    var Qe = Se.memoizedProps;
    if (Qe !== Ue) {
      Se = Ce.stateNode, xd(Hu.current);
      var et = null;
      switch (De) {
        case "input":
          Qe = Io(Se, Qe), Ue = Io(Se, Ue), et = [];
          break;
        case "select":
          Qe = yt({}, Qe, { value: void 0 }), Ue = yt({}, Ue, { value: void 0 }), et = [];
          break;
        case "textarea":
          Qe = la(Se, Qe), Ue = la(Se, Ue), et = [];
          break;
        default:
          typeof Qe.onClick != "function" && typeof Ue.onClick == "function" && (Se.onclick = ym);
      }
      or(De, Ue);
      var bt;
      De = null;
      for (bn in Qe)
        if (!Ue.hasOwnProperty(bn) && Qe.hasOwnProperty(bn) && Qe[bn] != null)
          if (bn === "style") {
            var It = Qe[bn];
            for (bt in It)
              It.hasOwnProperty(bt) && (De || (De = {}), De[bt] = "");
          } else
            bn !== "dangerouslySetInnerHTML" && bn !== "children" && bn !== "suppressContentEditableWarning" && bn !== "suppressHydrationWarning" && bn !== "autoFocus" && (we.hasOwnProperty(bn) ? et || (et = []) : (et = et || []).push(bn, null));
      for (bn in Ue) {
        var Ut = Ue[bn];
        if (It = Qe == null ? void 0 : Qe[bn], Ue.hasOwnProperty(bn) && Ut !== It && (Ut != null || It != null))
          if (bn === "style")
            if (It) {
              for (bt in It)
                !It.hasOwnProperty(bt) || Ut && Ut.hasOwnProperty(bt) || (De || (De = {}), De[bt] = "");
              for (bt in Ut)
                Ut.hasOwnProperty(bt) && It[bt] !== Ut[bt] && (De || (De = {}), De[bt] = Ut[bt]);
            } else
              De || (et || (et = []), et.push(bn, De)), De = Ut;
          else
            bn === "dangerouslySetInnerHTML" ? (Ut = Ut ? Ut.__html : void 0, It = It ? It.__html : void 0, Ut != null && It !== Ut && (et = et || []).push(bn, Ut)) : bn === "children" ? typeof Ut != "string" && typeof Ut != "number" || (et = et || []).push(bn, "" + Ut) : bn !== "suppressContentEditableWarning" && bn !== "suppressHydrationWarning" && (we.hasOwnProperty(bn) ? (Ut != null && bn === "onScroll" && Uo("scroll", Se), et || It === Ut || (et = [])) : (et = et || []).push(bn, Ut));
      }
      De && (et = et || []).push("style", De);
      var bn = et;
      (Ce.updateQueue = bn) && (Ce.flags |= 4);
    }
  }, Lg = function(Se, Ce, De, Ue) {
    De !== Ue && (Ce.flags |= 4);
  };
  function jp(Se, Ce) {
    if (!Xo)
      switch (Se.tailMode) {
        case "hidden":
          Ce = Se.tail;
          for (var De = null; Ce !== null; )
            Ce.alternate !== null && (De = Ce), Ce = Ce.sibling;
          De === null ? Se.tail = null : De.sibling = null;
          break;
        case "collapsed":
          De = Se.tail;
          for (var Ue = null; De !== null; )
            De.alternate !== null && (Ue = De), De = De.sibling;
          Ue === null ? Ce || Se.tail === null ? Se.tail = null : Se.tail.sibling = null : Ue.sibling = null;
      }
  }
  function qi(Se) {
    var Ce = Se.alternate !== null && Se.alternate.child === Se.child, De = 0, Ue = 0;
    if (Ce)
      for (var Qe = Se.child; Qe !== null; )
        De |= Qe.lanes | Qe.childLanes, Ue |= Qe.subtreeFlags & 14680064, Ue |= Qe.flags & 14680064, Qe.return = Se, Qe = Qe.sibling;
    else
      for (Qe = Se.child; Qe !== null; )
        De |= Qe.lanes | Qe.childLanes, Ue |= Qe.subtreeFlags, Ue |= Qe.flags, Qe.return = Se, Qe = Qe.sibling;
    return Se.subtreeFlags |= Ue, Se.childLanes = De, Ce;
  }
  function Db(Se, Ce, De) {
    var Ue = Ce.pendingProps;
    switch (vb(Ce), Ce.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return qi(Ce), null;
      case 1:
        return sa(Ce.type) && du(), qi(Ce), null;
      case 3:
        return Ue = Ce.stateNode, Nc(), ko(Sa), ko(Lr), Om(), Ue.pendingContext && (Ue.context = Ue.pendingContext, Ue.pendingContext = null), (Se === null || Se.child === null) && (_m(Ce) ? Ce.flags |= 4 : Se === null || Se.memoizedState.isDehydrated && !(Ce.flags & 256) || (Ce.flags |= 1024, pu !== null && (qp(pu), pu = null))), Gs(Se, Ce), qi(Ce), null;
      case 5:
        oo(Ce);
        var Qe = xd(_f.current);
        if (De = Ce.type, Se !== null && Ce.stateNode != null)
          ti(Se, Ce, De, Ue, Qe), Se.ref !== Ce.ref && (Ce.flags |= 512, Ce.flags |= 2097152);
        else {
          if (!Ue) {
            if (Ce.stateNode === null)
              throw Error(fe(166));
            return qi(Ce), null;
          }
          if (Se = xd(Hu.current), _m(Ce)) {
            Ue = Ce.stateNode, De = Ce.type;
            var et = Ce.memoizedProps;
            switch (Ue[il] = Ce, Ue[wd] = et, Se = (Ce.mode & 1) !== 0, De) {
              case "dialog":
                Uo("cancel", Ue), Uo("close", Ue);
                break;
              case "iframe":
              case "object":
              case "embed":
                Uo("load", Ue);
                break;
              case "video":
              case "audio":
                for (Qe = 0; Qe < bp.length; Qe++)
                  Uo(bp[Qe], Ue);
                break;
              case "source":
                Uo("error", Ue);
                break;
              case "img":
              case "image":
              case "link":
                Uo("error", Ue), Uo("load", Ue);
                break;
              case "details":
                Uo("toggle", Ue);
                break;
              case "input":
                Po(Ue, et), Uo("invalid", Ue);
                break;
              case "select":
                Ue._wrapperState = { wasMultiple: !!et.multiple }, Uo("invalid", Ue);
                break;
              case "textarea":
                Ia(Ue, et), Uo("invalid", Ue);
            }
            or(De, et), Qe = null;
            for (var bt in et)
              if (et.hasOwnProperty(bt)) {
                var It = et[bt];
                bt === "children" ? typeof It == "string" ? Ue.textContent !== It && (et.suppressHydrationWarning !== !0 && mm(Ue.textContent, It, Se), Qe = ["children", It]) : typeof It == "number" && Ue.textContent !== "" + It && (et.suppressHydrationWarning !== !0 && mm(Ue.textContent, It, Se), Qe = ["children", "" + It]) : we.hasOwnProperty(bt) && It != null && bt === "onScroll" && Uo("scroll", Ue);
              }
            switch (De) {
              case "input":
                ao(Ue), va(Ue, et, !0);
                break;
              case "textarea":
                ao(Ue), Yo(Ue);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof et.onClick == "function" && (Ue.onclick = ym);
            }
            Ue = Qe, Ce.updateQueue = Ue, Ue !== null && (Ce.flags |= 4);
          } else {
            bt = Qe.nodeType === 9 ? Qe : Qe.ownerDocument, Se === "http://www.w3.org/1999/xhtml" && (Se = Ra(De)), Se === "http://www.w3.org/1999/xhtml" ? De === "script" ? (Se = bt.createElement("div"), Se.innerHTML = "<script><\/script>", Se = Se.removeChild(Se.firstChild)) : typeof Ue.is == "string" ? Se = bt.createElement(De, { is: Ue.is }) : (Se = bt.createElement(De), De === "select" && (bt = Se, Ue.multiple ? bt.multiple = !0 : Ue.size && (bt.size = Ue.size))) : Se = bt.createElementNS(Se, De), Se[il] = Ce, Se[wd] = Ue, Of(Se, Ce, !1, !1), Ce.stateNode = Se;
            e: {
              switch (bt = Wn(De, Ue), De) {
                case "dialog":
                  Uo("cancel", Se), Uo("close", Se), Qe = Ue;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Uo("load", Se), Qe = Ue;
                  break;
                case "video":
                case "audio":
                  for (Qe = 0; Qe < bp.length; Qe++)
                    Uo(bp[Qe], Se);
                  Qe = Ue;
                  break;
                case "source":
                  Uo("error", Se), Qe = Ue;
                  break;
                case "img":
                case "image":
                case "link":
                  Uo("error", Se), Uo("load", Se), Qe = Ue;
                  break;
                case "details":
                  Uo("toggle", Se), Qe = Ue;
                  break;
                case "input":
                  Po(Se, Ue), Qe = Io(Se, Ue), Uo("invalid", Se);
                  break;
                case "option":
                  Qe = Ue;
                  break;
                case "select":
                  Se._wrapperState = { wasMultiple: !!Ue.multiple }, Qe = yt({}, Ue, { value: void 0 }), Uo("invalid", Se);
                  break;
                case "textarea":
                  Ia(Se, Ue), Qe = la(Se, Ue), Uo("invalid", Se);
                  break;
                default:
                  Qe = Ue;
              }
              or(De, Qe), It = Qe;
              for (et in It)
                if (It.hasOwnProperty(et)) {
                  var Ut = It[et];
                  et === "style" ? qn(Se, Ut) : et === "dangerouslySetInnerHTML" ? (Ut = Ut ? Ut.__html : void 0, Ut != null && Bt(Se, Ut)) : et === "children" ? typeof Ut == "string" ? (De !== "textarea" || Ut !== "") && Kt(Se, Ut) : typeof Ut == "number" && Kt(Se, "" + Ut) : et !== "suppressContentEditableWarning" && et !== "suppressHydrationWarning" && et !== "autoFocus" && (we.hasOwnProperty(et) ? Ut != null && et === "onScroll" && Uo("scroll", Se) : Ut != null && it(Se, et, Ut, bt));
                }
              switch (De) {
                case "input":
                  ao(Se), va(Se, Ue, !1);
                  break;
                case "textarea":
                  ao(Se), Yo(Se);
                  break;
                case "option":
                  Ue.value != null && Se.setAttribute("value", "" + Un(Ue.value));
                  break;
                case "select":
                  Se.multiple = !!Ue.multiple, et = Ue.value, et != null ? Ro(Se, !!Ue.multiple, et, !1) : Ue.defaultValue != null && Ro(Se, !!Ue.multiple, Ue.defaultValue, !0);
                  break;
                default:
                  typeof Qe.onClick == "function" && (Se.onclick = ym);
              }
              switch (De) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  Ue = !!Ue.autoFocus;
                  break e;
                case "img":
                  Ue = !0;
                  break e;
                default:
                  Ue = !1;
              }
            }
            Ue && (Ce.flags |= 4);
          }
          Ce.ref !== null && (Ce.flags |= 512, Ce.flags |= 2097152);
        }
        return qi(Ce), null;
      case 6:
        if (Se && Ce.stateNode != null)
          Lg(Se, Ce, Se.memoizedProps, Ue);
        else {
          if (typeof Ue != "string" && Ce.stateNode === null)
            throw Error(fe(166));
          if (De = xd(_f.current), xd(Hu.current), _m(Ce)) {
            if (Ue = Ce.stateNode, De = Ce.memoizedProps, Ue[il] = Ce, (et = Ue.nodeValue !== De) && (Se = Ws, Se !== null))
              switch (Se.tag) {
                case 3:
                  mm(Ue.nodeValue, De, (Se.mode & 1) !== 0);
                  break;
                case 5:
                  Se.memoizedProps.suppressHydrationWarning !== !0 && mm(Ue.nodeValue, De, (Se.mode & 1) !== 0);
              }
            et && (Ce.flags |= 4);
          } else
            Ue = (De.nodeType === 9 ? De : De.ownerDocument).createTextNode(Ue), Ue[il] = Ce, Ce.stateNode = Ue;
        }
        return qi(Ce), null;
      case 13:
        if (ko(Rr), Ue = Ce.memoizedState, Se === null || Se.memoizedState !== null && Se.memoizedState.dehydrated !== null) {
          if (Xo && Ss !== null && Ce.mode & 1 && !(Ce.flags & 128))
            Sg(), da(), Ce.flags |= 98560, et = !1;
          else if (et = _m(Ce), Ue !== null && Ue.dehydrated !== null) {
            if (Se === null) {
              if (!et)
                throw Error(fe(318));
              if (et = Ce.memoizedState, et = et !== null ? et.dehydrated : null, !et)
                throw Error(fe(317));
              et[il] = Ce;
            } else
              da(), !(Ce.flags & 128) && (Ce.memoizedState = null), Ce.flags |= 4;
            qi(Ce), et = !1;
          } else
            pu !== null && (qp(pu), pu = null), et = !0;
          if (!et)
            return Ce.flags & 65536 ? Ce : null;
        }
        return Ce.flags & 128 ? (Ce.lanes = De, Ce) : (Ue = Ue !== null, Ue !== (Se !== null && Se.memoizedState !== null) && Ue && (Ce.child.flags |= 8192, Ce.mode & 1 && (Se === null || Rr.current & 1 ? ni === 0 && (ni = 3) : Ub())), Ce.updateQueue !== null && (Ce.flags |= 4), qi(Ce), null);
      case 4:
        return Nc(), Gs(Se, Ce), Se === null && yf(Ce.stateNode.containerInfo), qi(Ce), null;
      case 10:
        return kc(Ce.type._context), qi(Ce), null;
      case 17:
        return sa(Ce.type) && du(), qi(Ce), null;
      case 19:
        if (ko(Rr), et = Ce.memoizedState, et === null)
          return qi(Ce), null;
        if (Ue = (Ce.flags & 128) !== 0, bt = et.rendering, bt === null)
          if (Ue)
            jp(et, !1);
          else {
            if (ni !== 0 || Se !== null && Se.flags & 128)
              for (Se = Ce.child; Se !== null; ) {
                if (bt = fa(Se), bt !== null) {
                  for (Ce.flags |= 128, jp(et, !1), Ue = bt.updateQueue, Ue !== null && (Ce.updateQueue = Ue, Ce.flags |= 4), Ce.subtreeFlags = 0, Ue = De, De = Ce.child; De !== null; )
                    et = De, Se = Ue, et.flags &= 14680066, bt = et.alternate, bt === null ? (et.childLanes = 0, et.lanes = Se, et.child = null, et.subtreeFlags = 0, et.memoizedProps = null, et.memoizedState = null, et.updateQueue = null, et.dependencies = null, et.stateNode = null) : (et.childLanes = bt.childLanes, et.lanes = bt.lanes, et.child = bt.child, et.subtreeFlags = 0, et.deletions = null, et.memoizedProps = bt.memoizedProps, et.memoizedState = bt.memoizedState, et.updateQueue = bt.updateQueue, et.type = bt.type, Se = bt.dependencies, et.dependencies = Se === null ? null : { lanes: Se.lanes, firstContext: Se.firstContext }), De = De.sibling;
                  return Co(Rr, Rr.current & 1 | 2), Ce.child;
                }
                Se = Se.sibling;
              }
            et.tail !== null && uo() > If && (Ce.flags |= 128, Ue = !0, jp(et, !1), Ce.lanes = 4194304);
          }
        else {
          if (!Ue)
            if (Se = fa(bt), Se !== null) {
              if (Ce.flags |= 128, Ue = !0, De = Se.updateQueue, De !== null && (Ce.updateQueue = De, Ce.flags |= 4), jp(et, !0), et.tail === null && et.tailMode === "hidden" && !bt.alternate && !Xo)
                return qi(Ce), null;
            } else
              2 * uo() - et.renderingStartTime > If && De !== 1073741824 && (Ce.flags |= 128, Ue = !0, jp(et, !1), Ce.lanes = 4194304);
          et.isBackwards ? (bt.sibling = Ce.child, Ce.child = bt) : (De = et.last, De !== null ? De.sibling = bt : Ce.child = bt, et.last = bt);
        }
        return et.tail !== null ? (Ce = et.tail, et.rendering = Ce, et.tail = Ce.sibling, et.renderingStartTime = uo(), Ce.sibling = null, De = Rr.current, Co(Rr, Ue ? De & 1 | 2 : De & 1), Ce) : (qi(Ce), null);
      case 22:
      case 23:
        return zb(), Ue = Ce.memoizedState !== null, Se !== null && Se.memoizedState !== null !== Ue && (Ce.flags |= 8192), Ue && Ce.mode & 1 ? Ys & 1073741824 && (qi(Ce), Ce.subtreeFlags & 6 && (Ce.flags |= 8192)) : qi(Ce), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(fe(156, Ce.tag));
  }
  function Fg(Se, Ce) {
    switch (vb(Ce), Ce.tag) {
      case 1:
        return sa(Ce.type) && du(), Se = Ce.flags, Se & 65536 ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 3:
        return Nc(), ko(Sa), ko(Lr), Om(), Se = Ce.flags, Se & 65536 && !(Se & 128) ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 5:
        return oo(Ce), null;
      case 13:
        if (ko(Rr), Se = Ce.memoizedState, Se !== null && Se.dehydrated !== null) {
          if (Ce.alternate === null)
            throw Error(fe(340));
          da();
        }
        return Se = Ce.flags, Se & 65536 ? (Ce.flags = Se & -65537 | 128, Ce) : null;
      case 19:
        return ko(Rr), null;
      case 4:
        return Nc(), null;
      case 10:
        return kc(Ce.type._context), null;
      case 22:
      case 23:
        return zb(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Nd = !1, Ci = !1, x_ = typeof WeakSet == "function" ? WeakSet : Set, sr = null;
  function Lc(Se, Ce) {
    var De = Se.ref;
    if (De !== null)
      if (typeof De == "function")
        try {
          De(null);
        } catch (Ue) {
          Pa(Se, Ce, Ue);
        }
      else
        De.current = null;
  }
  function Bg(Se, Ce, De) {
    try {
      De();
    } catch (Ue) {
      Pa(Se, Ce, Ue);
    }
  }
  var Lb = !1;
  function S_(Se, Ce) {
    if (cb = Ei, Se = cm(), Ol(Se)) {
      if ("selectionStart" in Se)
        var De = { start: Se.selectionStart, end: Se.selectionEnd };
      else
        e: {
          De = (De = Se.ownerDocument) && De.defaultView || window;
          var Ue = De.getSelection && De.getSelection();
          if (Ue && Ue.rangeCount !== 0) {
            De = Ue.anchorNode;
            var Qe = Ue.anchorOffset, et = Ue.focusNode;
            Ue = Ue.focusOffset;
            try {
              De.nodeType, et.nodeType;
            } catch {
              De = null;
              break e;
            }
            var bt = 0, It = -1, Ut = -1, bn = 0, Rn = 0, Ln = Se, Nn = null;
            t:
              for (; ; ) {
                for (var er; Ln !== De || Qe !== 0 && Ln.nodeType !== 3 || (It = bt + Qe), Ln !== et || Ue !== 0 && Ln.nodeType !== 3 || (Ut = bt + Ue), Ln.nodeType === 3 && (bt += Ln.nodeValue.length), (er = Ln.firstChild) !== null; )
                  Nn = Ln, Ln = er;
                for (; ; ) {
                  if (Ln === Se)
                    break t;
                  if (Nn === De && ++bn === Qe && (It = bt), Nn === et && ++Rn === Ue && (Ut = bt), (er = Ln.nextSibling) !== null)
                    break;
                  Ln = Nn, Nn = Ln.parentNode;
                }
                Ln = er;
              }
            De = It === -1 || Ut === -1 ? null : { start: It, end: Ut };
          } else
            De = null;
        }
      De = De || { start: 0, end: 0 };
    } else
      De = null;
    for (ld = { focusedElem: Se, selectionRange: De }, Ei = !1, sr = Ce; sr !== null; )
      if (Ce = sr, Se = Ce.child, (Ce.subtreeFlags & 1028) !== 0 && Se !== null)
        Se.return = Ce, sr = Se;
      else
        for (; sr !== null; ) {
          Ce = sr;
          try {
            var lr = Ce.alternate;
            if (Ce.flags & 1024)
              switch (Ce.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (lr !== null) {
                    var fr = lr.memoizedProps, Ca = lr.memoizedState, nn = Ce.stateNode, Qt = nn.getSnapshotBeforeUpdate(Ce.elementType === Ce.type ? fr : qs(Ce.type, fr), Ca);
                    nn.__reactInternalSnapshotBeforeUpdate = Qt;
                  }
                  break;
                case 3:
                  var un = Ce.stateNode.containerInfo;
                  un.nodeType === 1 ? un.textContent = "" : un.nodeType === 9 && un.documentElement && un.removeChild(un.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(fe(163));
              }
          } catch (Vn) {
            Pa(Ce, Ce.return, Vn);
          }
          if (Se = Ce.sibling, Se !== null) {
            Se.return = Ce.return, sr = Se;
            break;
          }
          sr = Ce.return;
        }
    return lr = Lb, Lb = !1, lr;
  }
  function Af(Se, Ce, De) {
    var Ue = Ce.updateQueue;
    if (Ue = Ue !== null ? Ue.lastEffect : null, Ue !== null) {
      var Qe = Ue = Ue.next;
      do {
        if ((Qe.tag & Se) === Se) {
          var et = Qe.destroy;
          Qe.destroy = void 0, et !== void 0 && Bg(Ce, De, et);
        }
        Qe = Qe.next;
      } while (Qe !== Ue);
    }
  }
  function ny(Se, Ce) {
    if (Ce = Ce.updateQueue, Ce = Ce !== null ? Ce.lastEffect : null, Ce !== null) {
      var De = Ce = Ce.next;
      do {
        if ((De.tag & Se) === Se) {
          var Ue = De.create;
          De.destroy = Ue();
        }
        De = De.next;
      } while (De !== Ce);
    }
  }
  function ry(Se) {
    var Ce = Se.ref;
    if (Ce !== null) {
      var De = Se.stateNode;
      switch (Se.tag) {
        case 5:
          Se = De;
          break;
        default:
          Se = De;
      }
      typeof Ce == "function" ? Ce(Se) : Ce.current = Se;
    }
  }
  function zg(Se) {
    var Ce = Se.alternate;
    Ce !== null && (Se.alternate = null, zg(Ce)), Se.child = null, Se.deletions = null, Se.sibling = null, Se.tag === 5 && (Ce = Se.stateNode, Ce !== null && (delete Ce[il], delete Ce[wd], delete Ce[pb], delete Ce[b_], delete Ce[hb])), Se.stateNode = null, Se.return = null, Se.dependencies = null, Se.memoizedProps = null, Se.memoizedState = null, Se.pendingProps = null, Se.stateNode = null, Se.updateQueue = null;
  }
  function oy(Se) {
    return Se.tag === 5 || Se.tag === 3 || Se.tag === 4;
  }
  function Dp(Se) {
    e:
      for (; ; ) {
        for (; Se.sibling === null; ) {
          if (Se.return === null || oy(Se.return))
            return null;
          Se = Se.return;
        }
        for (Se.sibling.return = Se.return, Se = Se.sibling; Se.tag !== 5 && Se.tag !== 6 && Se.tag !== 18; ) {
          if (Se.flags & 2 || Se.child === null || Se.tag === 4)
            continue e;
          Se.child.return = Se, Se = Se.child;
        }
        if (!(Se.flags & 2))
          return Se.stateNode;
      }
  }
  function cl(Se, Ce, De) {
    var Ue = Se.tag;
    if (Ue === 5 || Ue === 6)
      Se = Se.stateNode, Ce ? De.nodeType === 8 ? De.parentNode.insertBefore(Se, Ce) : De.insertBefore(Se, Ce) : (De.nodeType === 8 ? (Ce = De.parentNode, Ce.insertBefore(Se, De)) : (Ce = De, Ce.appendChild(Se)), De = De._reactRootContainer, De != null || Ce.onclick !== null || (Ce.onclick = ym));
    else if (Ue !== 4 && (Se = Se.child, Se !== null))
      for (cl(Se, Ce, De), Se = Se.sibling; Se !== null; )
        cl(Se, Ce, De), Se = Se.sibling;
  }
  function dl(Se, Ce, De) {
    var Ue = Se.tag;
    if (Ue === 5 || Ue === 6)
      Se = Se.stateNode, Ce ? De.insertBefore(Se, Ce) : De.appendChild(Se);
    else if (Ue !== 4 && (Se = Se.child, Se !== null))
      for (dl(Se, Ce, De), Se = Se.sibling; Se !== null; )
        dl(Se, Ce, De), Se = Se.sibling;
  }
  var ua = null, ns = !1;
  function bu(Se, Ce, De) {
    for (De = De.child; De !== null; )
      Vl(Se, Ce, De), De = De.sibling;
  }
  function Vl(Se, Ce, De) {
    if (Ka && typeof Ka.onCommitFiberUnmount == "function")
      try {
        Ka.onCommitFiberUnmount(Ms, De);
      } catch {
      }
    switch (De.tag) {
      case 5:
        Ci || Lc(De, Ce);
      case 6:
        var Ue = ua, Qe = ns;
        ua = null, bu(Se, Ce, De), ua = Ue, ns = Qe, ua !== null && (ns ? (Se = ua, De = De.stateNode, Se.nodeType === 8 ? Se.parentNode.removeChild(De) : Se.removeChild(De)) : ua.removeChild(De.stateNode));
        break;
      case 18:
        ua !== null && (ns ? (Se = ua, De = De.stateNode, Se.nodeType === 8 ? yc(Se.parentNode, De) : Se.nodeType === 1 && yc(Se, De), ou(Se)) : yc(ua, De.stateNode));
        break;
      case 4:
        Ue = ua, Qe = ns, ua = De.stateNode.containerInfo, ns = !0, bu(Se, Ce, De), ua = Ue, ns = Qe;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Ci && (Ue = De.updateQueue, Ue !== null && (Ue = Ue.lastEffect, Ue !== null))) {
          Qe = Ue = Ue.next;
          do {
            var et = Qe, bt = et.destroy;
            et = et.tag, bt !== void 0 && (et & 2 || et & 4) && Bg(De, Ce, bt), Qe = Qe.next;
          } while (Qe !== Ue);
        }
        bu(Se, Ce, De);
        break;
      case 1:
        if (!Ci && (Lc(De, Ce), Ue = De.stateNode, typeof Ue.componentWillUnmount == "function"))
          try {
            Ue.props = De.memoizedProps, Ue.state = De.memoizedState, Ue.componentWillUnmount();
          } catch (It) {
            Pa(De, Ce, It);
          }
        bu(Se, Ce, De);
        break;
      case 21:
        bu(Se, Ce, De);
        break;
      case 22:
        De.mode & 1 ? (Ci = (Ue = Ci) || De.memoizedState !== null, bu(Se, Ce, De), Ci = Ue) : bu(Se, Ce, De);
        break;
      default:
        bu(Se, Ce, De);
    }
  }
  function Ug(Se) {
    var Ce = Se.updateQueue;
    if (Ce !== null) {
      Se.updateQueue = null;
      var De = Se.stateNode;
      De === null && (De = Se.stateNode = new x_()), Ce.forEach(function(Ue) {
        var Qe = A_.bind(null, Se, Ue);
        De.has(Ue) || (De.add(Ue), Ue.then(Qe, Qe));
      });
    }
  }
  function Wu(Se, Ce) {
    var De = Ce.deletions;
    if (De !== null)
      for (var Ue = 0; Ue < De.length; Ue++) {
        var Qe = De[Ue];
        try {
          var et = Se, bt = Ce, It = bt;
          e:
            for (; It !== null; ) {
              switch (It.tag) {
                case 5:
                  ua = It.stateNode, ns = !1;
                  break e;
                case 3:
                  ua = It.stateNode.containerInfo, ns = !0;
                  break e;
                case 4:
                  ua = It.stateNode.containerInfo, ns = !0;
                  break e;
              }
              It = It.return;
            }
          if (ua === null)
            throw Error(fe(160));
          Vl(et, bt, Qe), ua = null, ns = !1;
          var Ut = Qe.alternate;
          Ut !== null && (Ut.return = null), Qe.return = null;
        } catch (bn) {
          Pa(Qe, Ce, bn);
        }
      }
    if (Ce.subtreeFlags & 12854)
      for (Ce = Ce.child; Ce !== null; )
        Vg(Ce, Se), Ce = Ce.sibling;
  }
  function Vg(Se, Ce) {
    var De = Se.alternate, Ue = Se.flags;
    switch (Se.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Wu(Ce, Se), qu(Se), Ue & 4) {
          try {
            Af(3, Se, Se.return), ny(3, Se);
          } catch (fr) {
            Pa(Se, Se.return, fr);
          }
          try {
            Af(5, Se, Se.return);
          } catch (fr) {
            Pa(Se, Se.return, fr);
          }
        }
        break;
      case 1:
        Wu(Ce, Se), qu(Se), Ue & 512 && De !== null && Lc(De, De.return);
        break;
      case 5:
        if (Wu(Ce, Se), qu(Se), Ue & 512 && De !== null && Lc(De, De.return), Se.flags & 32) {
          var Qe = Se.stateNode;
          try {
            Kt(Qe, "");
          } catch (fr) {
            Pa(Se, Se.return, fr);
          }
        }
        if (Ue & 4 && (Qe = Se.stateNode, Qe != null)) {
          var et = Se.memoizedProps, bt = De !== null ? De.memoizedProps : et, It = Se.type, Ut = Se.updateQueue;
          if (Se.updateQueue = null, Ut !== null)
            try {
              It === "input" && et.type === "radio" && et.name != null && vo(Qe, et), Wn(It, bt);
              var bn = Wn(It, et);
              for (bt = 0; bt < Ut.length; bt += 2) {
                var Rn = Ut[bt], Ln = Ut[bt + 1];
                Rn === "style" ? qn(Qe, Ln) : Rn === "dangerouslySetInnerHTML" ? Bt(Qe, Ln) : Rn === "children" ? Kt(Qe, Ln) : it(Qe, Rn, Ln, bn);
              }
              switch (It) {
                case "input":
                  na(Qe, et);
                  break;
                case "textarea":
                  Go(Qe, et);
                  break;
                case "select":
                  var Nn = Qe._wrapperState.wasMultiple;
                  Qe._wrapperState.wasMultiple = !!et.multiple;
                  var er = et.value;
                  er != null ? Ro(Qe, !!et.multiple, er, !1) : Nn !== !!et.multiple && (et.defaultValue != null ? Ro(Qe, !!et.multiple, et.defaultValue, !0) : Ro(Qe, !!et.multiple, et.multiple ? [] : "", !1));
              }
              Qe[wd] = et;
            } catch (fr) {
              Pa(Se, Se.return, fr);
            }
        }
        break;
      case 6:
        if (Wu(Ce, Se), qu(Se), Ue & 4) {
          if (Se.stateNode === null)
            throw Error(fe(162));
          Qe = Se.stateNode, et = Se.memoizedProps;
          try {
            Qe.nodeValue = et;
          } catch (fr) {
            Pa(Se, Se.return, fr);
          }
        }
        break;
      case 3:
        if (Wu(Ce, Se), qu(Se), Ue & 4 && De !== null && De.memoizedState.isDehydrated)
          try {
            ou(Ce.containerInfo);
          } catch (fr) {
            Pa(Se, Se.return, fr);
          }
        break;
      case 4:
        Wu(Ce, Se), qu(Se);
        break;
      case 13:
        Wu(Ce, Se), qu(Se), Qe = Se.child, Qe.flags & 8192 && (et = Qe.memoizedState !== null, Qe.stateNode.isHidden = et, !et || Qe.alternate !== null && Qe.alternate.memoizedState !== null || (Bb = uo())), Ue & 4 && Ug(Se);
        break;
      case 22:
        if (Rn = De !== null && De.memoizedState !== null, Se.mode & 1 ? (Ci = (bn = Ci) || Rn, Wu(Ce, Se), Ci = bn) : Wu(Ce, Se), qu(Se), Ue & 8192) {
          if (bn = Se.memoizedState !== null, (Se.stateNode.isHidden = bn) && !Rn && Se.mode & 1)
            for (sr = Se, Rn = Se.child; Rn !== null; ) {
              for (Ln = sr = Rn; sr !== null; ) {
                switch (Nn = sr, er = Nn.child, Nn.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Af(4, Nn, Nn.return);
                    break;
                  case 1:
                    Lc(Nn, Nn.return);
                    var lr = Nn.stateNode;
                    if (typeof lr.componentWillUnmount == "function") {
                      Ue = Nn, De = Nn.return;
                      try {
                        Ce = Ue, lr.props = Ce.memoizedProps, lr.state = Ce.memoizedState, lr.componentWillUnmount();
                      } catch (fr) {
                        Pa(Ue, De, fr);
                      }
                    }
                    break;
                  case 5:
                    Lc(Nn, Nn.return);
                    break;
                  case 22:
                    if (Nn.memoizedState !== null) {
                      Wg(Ln);
                      continue;
                    }
                }
                er !== null ? (er.return = Nn, sr = er) : Wg(Ln);
              }
              Rn = Rn.sibling;
            }
          e:
            for (Rn = null, Ln = Se; ; ) {
              if (Ln.tag === 5) {
                if (Rn === null) {
                  Rn = Ln;
                  try {
                    Qe = Ln.stateNode, bn ? (et = Qe.style, typeof et.setProperty == "function" ? et.setProperty("display", "none", "important") : et.display = "none") : (It = Ln.stateNode, Ut = Ln.memoizedProps.style, bt = Ut != null && Ut.hasOwnProperty("display") ? Ut.display : null, It.style.display = zn("display", bt));
                  } catch (fr) {
                    Pa(Se, Se.return, fr);
                  }
                }
              } else if (Ln.tag === 6) {
                if (Rn === null)
                  try {
                    Ln.stateNode.nodeValue = bn ? "" : Ln.memoizedProps;
                  } catch (fr) {
                    Pa(Se, Se.return, fr);
                  }
              } else if ((Ln.tag !== 22 && Ln.tag !== 23 || Ln.memoizedState === null || Ln === Se) && Ln.child !== null) {
                Ln.child.return = Ln, Ln = Ln.child;
                continue;
              }
              if (Ln === Se)
                break e;
              for (; Ln.sibling === null; ) {
                if (Ln.return === null || Ln.return === Se)
                  break e;
                Rn === Ln && (Rn = null), Ln = Ln.return;
              }
              Rn === Ln && (Rn = null), Ln.sibling.return = Ln.return, Ln = Ln.sibling;
            }
        }
        break;
      case 19:
        Wu(Ce, Se), qu(Se), Ue & 4 && Ug(Se);
        break;
      case 21:
        break;
      default:
        Wu(Ce, Se), qu(Se);
    }
  }
  function qu(Se) {
    var Ce = Se.flags;
    if (Ce & 2) {
      try {
        e: {
          for (var De = Se.return; De !== null; ) {
            if (oy(De)) {
              var Ue = De;
              break e;
            }
            De = De.return;
          }
          throw Error(fe(160));
        }
        switch (Ue.tag) {
          case 5:
            var Qe = Ue.stateNode;
            Ue.flags & 32 && (Kt(Qe, ""), Ue.flags &= -33);
            var et = Dp(Se);
            dl(Se, et, Qe);
            break;
          case 3:
          case 4:
            var bt = Ue.stateNode.containerInfo, It = Dp(Se);
            cl(Se, It, bt);
            break;
          default:
            throw Error(fe(161));
        }
      } catch (Ut) {
        Pa(Se, Se.return, Ut);
      }
      Se.flags &= -3;
    }
    Ce & 4096 && (Se.flags &= -4097);
  }
  function Lp(Se, Ce, De) {
    sr = Se, Hg(Se);
  }
  function Hg(Se, Ce, De) {
    for (var Ue = (Se.mode & 1) !== 0; sr !== null; ) {
      var Qe = sr, et = Qe.child;
      if (Qe.tag === 22 && Ue) {
        var bt = Qe.memoizedState !== null || Nd;
        if (!bt) {
          var It = Qe.alternate, Ut = It !== null && It.memoizedState !== null || Ci;
          It = Nd;
          var bn = Ci;
          if (Nd = bt, (Ci = Ut) && !bn)
            for (sr = Qe; sr !== null; )
              bt = sr, Ut = bt.child, bt.tag === 22 && bt.memoizedState !== null ? Bp(Qe) : Ut !== null ? (Ut.return = bt, sr = Ut) : Bp(Qe);
          for (; et !== null; )
            sr = et, Hg(et), et = et.sibling;
          sr = Qe, Nd = It, Ci = bn;
        }
        Fb(Se);
      } else
        Qe.subtreeFlags & 8772 && et !== null ? (et.return = Qe, sr = et) : Fb(Se);
    }
  }
  function Fb(Se) {
    for (; sr !== null; ) {
      var Ce = sr;
      if (Ce.flags & 8772) {
        var De = Ce.alternate;
        try {
          if (Ce.flags & 8772)
            switch (Ce.tag) {
              case 0:
              case 11:
              case 15:
                Ci || ny(5, Ce);
                break;
              case 1:
                var Ue = Ce.stateNode;
                if (Ce.flags & 4 && !Ci)
                  if (De === null)
                    Ue.componentDidMount();
                  else {
                    var Qe = Ce.elementType === Ce.type ? De.memoizedProps : qs(Ce.type, De.memoizedProps);
                    Ue.componentDidUpdate(Qe, De.memoizedState, Ue.__reactInternalSnapshotBeforeUpdate);
                  }
                var et = Ce.updateQueue;
                et !== null && Ed(Ce, et, Ue);
                break;
              case 3:
                var bt = Ce.updateQueue;
                if (bt !== null) {
                  if (De = null, Ce.child !== null)
                    switch (Ce.child.tag) {
                      case 5:
                        De = Ce.child.stateNode;
                        break;
                      case 1:
                        De = Ce.child.stateNode;
                    }
                  Ed(Ce, bt, De);
                }
                break;
              case 5:
                var It = Ce.stateNode;
                if (De === null && Ce.flags & 4) {
                  De = It;
                  var Ut = Ce.memoizedProps;
                  switch (Ce.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ut.autoFocus && De.focus();
                      break;
                    case "img":
                      Ut.src && (De.src = Ut.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Ce.memoizedState === null) {
                  var bn = Ce.alternate;
                  if (bn !== null) {
                    var Rn = bn.memoizedState;
                    if (Rn !== null) {
                      var Ln = Rn.dehydrated;
                      Ln !== null && ou(Ln);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(fe(163));
            }
          Ci || Ce.flags & 512 && ry(Ce);
        } catch (Nn) {
          Pa(Ce, Ce.return, Nn);
        }
      }
      if (Ce === Se) {
        sr = null;
        break;
      }
      if (De = Ce.sibling, De !== null) {
        De.return = Ce.return, sr = De;
        break;
      }
      sr = Ce.return;
    }
  }
  function Wg(Se) {
    for (; sr !== null; ) {
      var Ce = sr;
      if (Ce === Se) {
        sr = null;
        break;
      }
      var De = Ce.sibling;
      if (De !== null) {
        De.return = Ce.return, sr = De;
        break;
      }
      sr = Ce.return;
    }
  }
  function Bp(Se) {
    for (; sr !== null; ) {
      var Ce = sr;
      try {
        switch (Ce.tag) {
          case 0:
          case 11:
          case 15:
            var De = Ce.return;
            try {
              ny(4, Ce);
            } catch (Ut) {
              Pa(Ce, De, Ut);
            }
            break;
          case 1:
            var Ue = Ce.stateNode;
            if (typeof Ue.componentDidMount == "function") {
              var Qe = Ce.return;
              try {
                Ue.componentDidMount();
              } catch (Ut) {
                Pa(Ce, Qe, Ut);
              }
            }
            var et = Ce.return;
            try {
              ry(Ce);
            } catch (Ut) {
              Pa(Ce, et, Ut);
            }
            break;
          case 5:
            var bt = Ce.return;
            try {
              ry(Ce);
            } catch (Ut) {
              Pa(Ce, bt, Ut);
            }
        }
      } catch (Ut) {
        Pa(Ce, Ce.return, Ut);
      }
      if (Ce === Se) {
        sr = null;
        break;
      }
      var It = Ce.sibling;
      if (It !== null) {
        It.return = Ce.return, sr = It;
        break;
      }
      sr = Ce.return;
    }
  }
  var qg = Math.ceil, ay = ht.ReactCurrentDispatcher, Md = ht.ReactCurrentOwner, Gi = ht.ReactCurrentBatchConfig, lo = 0, Ua = null, Aa = null, $i = 0, Ys = 0, Cf = qr(0), ni = 0, jd = null, Ld = 0, Fd = 0, zp = 0, $f = null, As = null, Bb = 0, If = 1 / 0, Hl = null, Fc = !1, Up = null, vu = null, iy = !1, Bc = null, Vp = 0, Rf = 0, Nf = null, Bd = -1, Hp = 0;
  function Ho() {
    return lo & 6 ? uo() : Bd !== -1 ? Bd : Bd = uo();
  }
  function Qs(Se) {
    return Se.mode & 1 ? lo & 2 && $i !== 0 ? $i & -$i : Em.transition !== null ? (Hp === 0 && (Hp = ru()), Hp) : (Se = po, Se !== 0 || (Se = window.event, Se = Se === void 0 ? 16 : Sl(Se.type)), Se) : 1;
  }
  function Ks(Se, Ce, De, Ue) {
    if (50 < Rf)
      throw Rf = 0, Nf = null, Error(fe(185));
    Ds(Se, De, Ue), (!(lo & 2) || Se !== Ua) && (Se === Ua && (!(lo & 2) && (Fd |= De), ni === 4 && zc(Se, $i)), bi(Se, Ue), De === 1 && lo === 0 && !(Ce.mode & 1) && (If = uo() + 500, mi && _s()));
  }
  function bi(Se, Ce) {
    var De = Se.callbackNode;
    Hi(Se, Ce);
    var Ue = ca(Se, Se === Ua ? $i : 0);
    if (Ue === 0)
      De !== null && ka(De), Se.callbackNode = null, Se.callbackPriority = 0;
    else if (Ce = Ue & -Ue, Se.callbackPriority !== Ce) {
      if (De != null && ka(De), Ce === 1)
        Se.tag === 0 ? yb(Gp.bind(null, Se)) : mb(Gp.bind(null, Se)), fb(function() {
          !(lo & 6) && _s();
        }), De = null;
      else {
        switch (ts(Ue)) {
          case 1:
            De = Yi;
            break;
          case 4:
            De = Wr;
            break;
          case 16:
            De = Ea;
            break;
          case 536870912:
            De = Fu;
            break;
          default:
            De = Ea;
        }
        De = Xg(De, Zg.bind(null, Se));
      }
      Se.callbackPriority = Ce, Se.callbackNode = De;
    }
  }
  function Zg(Se, Ce) {
    if (Bd = -1, Hp = 0, lo & 6)
      throw Error(fe(327));
    var De = Se.callbackNode;
    if (Mf() && Se.callbackNode !== De)
      return null;
    var Ue = ca(Se, Se === Ua ? $i : 0);
    if (Ue === 0)
      return null;
    if (Ue & 30 || Ue & Se.expiredLanes || Ce)
      Ce = ly(Se, Ue);
    else {
      Ce = Ue;
      var Qe = lo;
      lo |= 2;
      var et = Gg();
      (Ua !== Se || $i !== Ce) && (Hl = null, If = uo() + 500, Ud(Se, Ce));
      do
        try {
          T_();
          break;
        } catch (It) {
          uy(Se, It);
        }
      while (1);
      Eb(), ay.current = et, lo = Qe, Aa !== null ? Ce = 0 : (Ua = null, $i = 0, Ce = ni);
    }
    if (Ce !== 0) {
      if (Ce === 2 && (Qe = gl(Se), Qe !== 0 && (Ue = Qe, Ce = Wp(Se, Qe))), Ce === 1)
        throw De = jd, Ud(Se, 0), zc(Se, Ue), bi(Se, uo()), De;
      if (Ce === 6)
        zc(Se, Ue);
      else {
        if (Qe = Se.current.alternate, !(Ue & 30) && !Zp(Qe) && (Ce = ly(Se, Ue), Ce === 2 && (et = gl(Se), et !== 0 && (Ue = et, Ce = Wp(Se, et))), Ce === 1))
          throw De = jd, Ud(Se, 0), zc(Se, Ue), bi(Se, uo()), De;
        switch (Se.finishedWork = Qe, Se.finishedLanes = Ue, Ce) {
          case 0:
          case 1:
            throw Error(fe(345));
          case 2:
            Vd(Se, As, Hl);
            break;
          case 3:
            if (zc(Se, Ue), (Ue & 130023424) === Ue && (Ce = Bb + 500 - uo(), 10 < Ce)) {
              if (ca(Se, 0) !== 0)
                break;
              if (Qe = Se.suspendedLanes, (Qe & Ue) !== Ue) {
                Ho(), Se.pingedLanes |= Se.suspendedLanes & Qe;
                break;
              }
              Se.timeoutHandle = bd(Vd.bind(null, Se, As, Hl), Ce);
              break;
            }
            Vd(Se, As, Hl);
            break;
          case 4:
            if (zc(Se, Ue), (Ue & 4194240) === Ue)
              break;
            for (Ce = Se.eventTimes, Qe = -1; 0 < Ue; ) {
              var bt = 31 - ja(Ue);
              et = 1 << bt, bt = Ce[bt], bt > Qe && (Qe = bt), Ue &= ~et;
            }
            if (Ue = Qe, Ue = uo() - Ue, Ue = (120 > Ue ? 120 : 480 > Ue ? 480 : 1080 > Ue ? 1080 : 1920 > Ue ? 1920 : 3e3 > Ue ? 3e3 : 4320 > Ue ? 4320 : 1960 * qg(Ue / 1960)) - Ue, 10 < Ue) {
              Se.timeoutHandle = bd(Vd.bind(null, Se, As, Hl), Ue);
              break;
            }
            Vd(Se, As, Hl);
            break;
          case 5:
            Vd(Se, As, Hl);
            break;
          default:
            throw Error(fe(329));
        }
      }
    }
    return bi(Se, uo()), Se.callbackNode === De ? Zg.bind(null, Se) : null;
  }
  function Wp(Se, Ce) {
    var De = $f;
    return Se.current.memoizedState.isDehydrated && (Ud(Se, Ce).flags |= 256), Se = ly(Se, Ce), Se !== 2 && (Ce = As, As = De, Ce !== null && qp(Ce)), Se;
  }
  function qp(Se) {
    As === null ? As = Se : As.push.apply(As, Se);
  }
  function Zp(Se) {
    for (var Ce = Se; ; ) {
      if (Ce.flags & 16384) {
        var De = Ce.updateQueue;
        if (De !== null && (De = De.stores, De !== null))
          for (var Ue = 0; Ue < De.length; Ue++) {
            var Qe = De[Ue], et = Qe.getSnapshot;
            Qe = Qe.value;
            try {
              if (!uu(et(), Qe))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (De = Ce.child, Ce.subtreeFlags & 16384 && De !== null)
        De.return = Ce, Ce = De;
      else {
        if (Ce === Se)
          break;
        for (; Ce.sibling === null; ) {
          if (Ce.return === null || Ce.return === Se)
            return !0;
          Ce = Ce.return;
        }
        Ce.sibling.return = Ce.return, Ce = Ce.sibling;
      }
    }
    return !0;
  }
  function zc(Se, Ce) {
    for (Ce &= ~zp, Ce &= ~Fd, Se.suspendedLanes |= Ce, Se.pingedLanes &= ~Ce, Se = Se.expirationTimes; 0 < Ce; ) {
      var De = 31 - ja(Ce), Ue = 1 << De;
      Se[De] = -1, Ce &= ~Ue;
    }
  }
  function Gp(Se) {
    if (lo & 6)
      throw Error(fe(327));
    Mf();
    var Ce = ca(Se, 0);
    if (!(Ce & 1))
      return bi(Se, uo()), null;
    var De = ly(Se, Ce);
    if (Se.tag !== 0 && De === 2) {
      var Ue = gl(Se);
      Ue !== 0 && (Ce = Ue, De = Wp(Se, Ue));
    }
    if (De === 1)
      throw De = jd, Ud(Se, 0), zc(Se, Ce), bi(Se, uo()), De;
    if (De === 6)
      throw Error(fe(345));
    return Se.finishedWork = Se.current.alternate, Se.finishedLanes = Ce, Vd(Se, As, Hl), bi(Se, uo()), null;
  }
  function sy(Se, Ce) {
    var De = lo;
    lo |= 1;
    try {
      return Se(Ce);
    } finally {
      lo = De, lo === 0 && (If = uo() + 500, mi && _s());
    }
  }
  function zd(Se) {
    Bc !== null && Bc.tag === 0 && !(lo & 6) && Mf();
    var Ce = lo;
    lo |= 1;
    var De = Gi.transition, Ue = po;
    try {
      if (Gi.transition = null, po = 1, Se)
        return Se();
    } finally {
      po = Ue, Gi.transition = De, lo = Ce, !(lo & 6) && _s();
    }
  }
  function zb() {
    Ys = Cf.current, ko(Cf);
  }
  function Ud(Se, Ce) {
    Se.finishedWork = null, Se.finishedLanes = 0;
    var De = Se.timeoutHandle;
    if (De !== -1 && (Se.timeoutHandle = -1, wg(De)), Aa !== null)
      for (De = Aa.return; De !== null; ) {
        var Ue = De;
        switch (vb(Ue), Ue.tag) {
          case 1:
            Ue = Ue.type.childContextTypes, Ue != null && du();
            break;
          case 3:
            Nc(), ko(Sa), ko(Lr), Om();
            break;
          case 5:
            oo(Ue);
            break;
          case 4:
            Nc();
            break;
          case 13:
            ko(Rr);
            break;
          case 19:
            ko(Rr);
            break;
          case 10:
            kc(Ue.type._context);
            break;
          case 22:
          case 23:
            zb();
        }
        De = De.return;
      }
    if (Ua = Se, Aa = Se = Uc(Se.current, null), $i = Ys = Ce, ni = 0, jd = null, zp = Fd = Ld = 0, As = $f = null, Si !== null) {
      for (Ce = 0; Ce < Si.length; Ce++)
        if (De = Si[Ce], Ue = De.interleaved, Ue !== null) {
          De.interleaved = null;
          var Qe = Ue.next, et = De.pending;
          if (et !== null) {
            var bt = et.next;
            et.next = Qe, Ue.next = bt;
          }
          De.pending = Ue;
        }
      Si = null;
    }
    return Se;
  }
  function uy(Se, Ce) {
    do {
      var De = Aa;
      try {
        if (Eb(), Am.current = Wm, Nr) {
          for (var Ue = Jo.memoizedState; Ue !== null; ) {
            var Qe = Ue.queue;
            Qe !== null && (Qe.pending = null), Ue = Ue.next;
          }
          Nr = !1;
        }
        if (Pd = 0, yo = xn = Jo = null, ll = !1, Zs = 0, Md.current = null, De === null || De.return === null) {
          ni = 1, jd = Ce, Aa = null;
          break;
        }
        e: {
          var et = Se, bt = De.return, It = De, Ut = Ce;
          if (Ce = $i, It.flags |= 32768, Ut !== null && typeof Ut == "object" && typeof Ut.then == "function") {
            var bn = Ut, Rn = It, Ln = Rn.tag;
            if (!(Rn.mode & 1) && (Ln === 0 || Ln === 11 || Ln === 15)) {
              var Nn = Rn.alternate;
              Nn ? (Rn.updateQueue = Nn.updateQueue, Rn.memoizedState = Nn.memoizedState, Rn.lanes = Nn.lanes) : (Rn.updateQueue = null, Rn.memoizedState = null);
            }
            var er = $b(bt);
            if (er !== null) {
              er.flags &= -257, Ib(er, bt, It, et, Ce), er.mode & 1 && Mg(et, bn, Ce), Ce = er, Ut = bn;
              var lr = Ce.updateQueue;
              if (lr === null) {
                var fr = /* @__PURE__ */ new Set();
                fr.add(Ut), Ce.updateQueue = fr;
              } else
                lr.add(Ut);
              break e;
            } else {
              if (!(Ce & 1)) {
                Mg(et, bn, Ce), Ub();
                break e;
              }
              Ut = Error(fe(426));
            }
          } else if (Xo && It.mode & 1) {
            var Ca = $b(bt);
            if (Ca !== null) {
              !(Ca.flags & 65536) && (Ca.flags |= 256), Ib(Ca, bt, It, et, Ce), wb(Pf(Ut, It));
              break e;
            }
          }
          et = Ut = Pf(Ut, It), ni !== 4 && (ni = 2), $f === null ? $f = [et] : $f.push(et), et = bt;
          do {
            switch (et.tag) {
              case 3:
                et.flags |= 65536, Ce &= -Ce, et.lanes |= Ce;
                var nn = Ng(et, Ut, Ce);
                Pb(et, nn);
                break e;
              case 1:
                It = Ut;
                var Qt = et.type, un = et.stateNode;
                if (!(et.flags & 128) && (typeof Qt.getDerivedStateFromError == "function" || un !== null && typeof un.componentDidCatch == "function" && (vu === null || !vu.has(un)))) {
                  et.flags |= 65536, Ce &= -Ce, et.lanes |= Ce;
                  var Vn = Np(et, It, Ce);
                  Pb(et, Vn);
                  break e;
                }
            }
            et = et.return;
          } while (et !== null);
        }
        Yg(De);
      } catch (Jn) {
        Ce = Jn, Aa === De && De !== null && (Aa = De = De.return);
        continue;
      }
      break;
    } while (1);
  }
  function Gg() {
    var Se = ay.current;
    return ay.current = Wm, Se === null ? Wm : Se;
  }
  function Ub() {
    (ni === 0 || ni === 3 || ni === 2) && (ni = 4), Ua === null || !(Ld & 268435455) && !(Fd & 268435455) || zc(Ua, $i);
  }
  function ly(Se, Ce) {
    var De = lo;
    lo |= 2;
    var Ue = Gg();
    (Ua !== Se || $i !== Ce) && (Hl = null, Ud(Se, Ce));
    do
      try {
        P_();
        break;
      } catch (Qe) {
        uy(Se, Qe);
      }
    while (1);
    if (Eb(), lo = De, ay.current = Ue, Aa !== null)
      throw Error(fe(261));
    return Ua = null, $i = 0, ni;
  }
  function P_() {
    for (; Aa !== null; )
      Vb(Aa);
  }
  function T_() {
    for (; Aa !== null && !ys(); )
      Vb(Aa);
  }
  function Vb(Se) {
    var Ce = Wb(Se.alternate, Se, Ys);
    Se.memoizedProps = Se.pendingProps, Ce === null ? Yg(Se) : Aa = Ce, Md.current = null;
  }
  function Yg(Se) {
    var Ce = Se;
    do {
      var De = Ce.alternate;
      if (Se = Ce.return, Ce.flags & 32768) {
        if (De = Fg(De, Ce), De !== null) {
          De.flags &= 32767, Aa = De;
          return;
        }
        if (Se !== null)
          Se.flags |= 32768, Se.subtreeFlags = 0, Se.deletions = null;
        else {
          ni = 6, Aa = null;
          return;
        }
      } else if (De = Db(De, Ce, Ys), De !== null) {
        Aa = De;
        return;
      }
      if (Ce = Ce.sibling, Ce !== null) {
        Aa = Ce;
        return;
      }
      Aa = Ce = Se;
    } while (Ce !== null);
    ni === 0 && (ni = 5);
  }
  function Vd(Se, Ce, De) {
    var Ue = po, Qe = Gi.transition;
    try {
      Gi.transition = null, po = 1, k_(Se, Ce, De, Ue);
    } finally {
      Gi.transition = Qe, po = Ue;
    }
    return null;
  }
  function k_(Se, Ce, De, Ue) {
    do
      Mf();
    while (Bc !== null);
    if (lo & 6)
      throw Error(fe(327));
    De = Se.finishedWork;
    var Qe = Se.finishedLanes;
    if (De === null)
      return null;
    if (Se.finishedWork = null, Se.finishedLanes = 0, De === Se.current)
      throw Error(fe(177));
    Se.callbackNode = null, Se.callbackPriority = 0;
    var et = De.lanes | De.childLanes;
    if (Ls(Se, et), Se === Ua && (Aa = Ua = null, $i = 0), !(De.subtreeFlags & 2064) && !(De.flags & 2064) || iy || (iy = !0, Xg(Ea, function() {
      return Mf(), null;
    })), et = (De.flags & 15990) !== 0, De.subtreeFlags & 15990 || et) {
      et = Gi.transition, Gi.transition = null;
      var bt = po;
      po = 1;
      var It = lo;
      lo |= 4, Md.current = null, S_(Se, De), Vg(De, Se), dm(ld), Ei = !!cb, ld = cb = null, Se.current = De, Lp(De), Qu(), lo = It, po = bt, Gi.transition = et;
    } else
      Se.current = De;
    if (iy && (iy = !1, Bc = Se, Vp = Qe), et = Se.pendingLanes, et === 0 && (vu = null), Xu(De.stateNode), bi(Se, uo()), Ce !== null)
      for (Ue = Se.onRecoverableError, De = 0; De < Ce.length; De++)
        Qe = Ce[De], Ue(Qe.value, { componentStack: Qe.stack, digest: Qe.digest });
    if (Fc)
      throw Fc = !1, Se = Up, Up = null, Se;
    return Vp & 1 && Se.tag !== 0 && Mf(), et = Se.pendingLanes, et & 1 ? Se === Nf ? Rf++ : (Rf = 0, Nf = Se) : Rf = 0, _s(), null;
  }
  function Mf() {
    if (Bc !== null) {
      var Se = ts(Vp), Ce = Gi.transition, De = po;
      try {
        if (Gi.transition = null, po = 16 > Se ? 16 : Se, Bc === null)
          var Ue = !1;
        else {
          if (Se = Bc, Bc = null, Vp = 0, lo & 6)
            throw Error(fe(331));
          var Qe = lo;
          for (lo |= 4, sr = Se.current; sr !== null; ) {
            var et = sr, bt = et.child;
            if (sr.flags & 16) {
              var It = et.deletions;
              if (It !== null) {
                for (var Ut = 0; Ut < It.length; Ut++) {
                  var bn = It[Ut];
                  for (sr = bn; sr !== null; ) {
                    var Rn = sr;
                    switch (Rn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Af(8, Rn, et);
                    }
                    var Ln = Rn.child;
                    if (Ln !== null)
                      Ln.return = Rn, sr = Ln;
                    else
                      for (; sr !== null; ) {
                        Rn = sr;
                        var Nn = Rn.sibling, er = Rn.return;
                        if (zg(Rn), Rn === bn) {
                          sr = null;
                          break;
                        }
                        if (Nn !== null) {
                          Nn.return = er, sr = Nn;
                          break;
                        }
                        sr = er;
                      }
                  }
                }
                var lr = et.alternate;
                if (lr !== null) {
                  var fr = lr.child;
                  if (fr !== null) {
                    lr.child = null;
                    do {
                      var Ca = fr.sibling;
                      fr.sibling = null, fr = Ca;
                    } while (fr !== null);
                  }
                }
                sr = et;
              }
            }
            if (et.subtreeFlags & 2064 && bt !== null)
              bt.return = et, sr = bt;
            else
              e:
                for (; sr !== null; ) {
                  if (et = sr, et.flags & 2048)
                    switch (et.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Af(9, et, et.return);
                    }
                  var nn = et.sibling;
                  if (nn !== null) {
                    nn.return = et.return, sr = nn;
                    break e;
                  }
                  sr = et.return;
                }
          }
          var Qt = Se.current;
          for (sr = Qt; sr !== null; ) {
            bt = sr;
            var un = bt.child;
            if (bt.subtreeFlags & 2064 && un !== null)
              un.return = bt, sr = un;
            else
              e:
                for (bt = Qt; sr !== null; ) {
                  if (It = sr, It.flags & 2048)
                    try {
                      switch (It.tag) {
                        case 0:
                        case 11:
                        case 15:
                          ny(9, It);
                      }
                    } catch (Jn) {
                      Pa(It, It.return, Jn);
                    }
                  if (It === bt) {
                    sr = null;
                    break e;
                  }
                  var Vn = It.sibling;
                  if (Vn !== null) {
                    Vn.return = It.return, sr = Vn;
                    break e;
                  }
                  sr = It.return;
                }
          }
          if (lo = Qe, _s(), Ka && typeof Ka.onPostCommitFiberRoot == "function")
            try {
              Ka.onPostCommitFiberRoot(Ms, Se);
            } catch {
            }
          Ue = !0;
        }
        return Ue;
      } finally {
        po = De, Gi.transition = Ce;
      }
    }
    return !1;
  }
  function Qg(Se, Ce, De) {
    Ce = Pf(De, Ce), Ce = Ng(Se, Ce, 1), Se = $c(Se, Ce, 1), Ce = Ho(), Se !== null && (Ds(Se, 1, Ce), bi(Se, Ce));
  }
  function Pa(Se, Ce, De) {
    if (Se.tag === 3)
      Qg(Se, Se, De);
    else
      for (; Ce !== null; ) {
        if (Ce.tag === 3) {
          Qg(Ce, Se, De);
          break;
        } else if (Ce.tag === 1) {
          var Ue = Ce.stateNode;
          if (typeof Ce.type.getDerivedStateFromError == "function" || typeof Ue.componentDidCatch == "function" && (vu === null || !vu.has(Ue))) {
            Se = Pf(De, Se), Se = Np(Ce, Se, 1), Ce = $c(Ce, Se, 1), Se = Ho(), Ce !== null && (Ds(Ce, 1, Se), bi(Ce, Se));
            break;
          }
        }
        Ce = Ce.return;
      }
  }
  function Hb(Se, Ce, De) {
    var Ue = Se.pingCache;
    Ue !== null && Ue.delete(Ce), Ce = Ho(), Se.pingedLanes |= Se.suspendedLanes & De, Ua === Se && ($i & De) === De && (ni === 4 || ni === 3 && ($i & 130023424) === $i && 500 > uo() - Bb ? Ud(Se, 0) : zp |= De), bi(Se, Ce);
  }
  function Kg(Se, Ce) {
    Ce === 0 && (Se.mode & 1 ? (Ce = Vi, Vi <<= 1, !(Vi & 130023424) && (Vi = 4194304)) : Ce = 1);
    var De = Ho();
    Se = Ml(Se, Ce), Se !== null && (Ds(Se, Ce, De), bi(Se, De));
  }
  function O_(Se) {
    var Ce = Se.memoizedState, De = 0;
    Ce !== null && (De = Ce.retryLane), Kg(Se, De);
  }
  function A_(Se, Ce) {
    var De = 0;
    switch (Se.tag) {
      case 13:
        var Ue = Se.stateNode, Qe = Se.memoizedState;
        Qe !== null && (De = Qe.retryLane);
        break;
      case 19:
        Ue = Se.stateNode;
        break;
      default:
        throw Error(fe(314));
    }
    Ue !== null && Ue.delete(Ce), Kg(Se, De);
  }
  var Wb;
  Wb = function(Se, Ce, De) {
    if (Se !== null)
      if (Se.memoizedProps !== Ce.pendingProps || Sa.current)
        za = !0;
      else {
        if (!(Se.lanes & De) && !(Ce.flags & 128))
          return za = !1, ty(Se, Ce, De);
        za = !!(Se.flags & 131072);
      }
    else
      za = !1, Xo && Ce.flags & 1048576 && bb(Ce, vf, Ce.index);
    switch (Ce.lanes = 0, Ce.tag) {
      case 2:
        var Ue = Ce.type;
        yu(Se, Ce), Se = Ce.pendingProps;
        var Qe = cu(Ce, Lr.current);
        Gn(Ce, De), Qe = Mc(null, Ce, Ue, Se, Qe, De);
        var et = Ad();
        return Ce.flags |= 1, typeof Qe == "object" && Qe !== null && typeof Qe.render == "function" && Qe.$$typeof === void 0 ? (Ce.tag = 1, Ce.memoizedState = null, Ce.updateQueue = null, sa(Ue) ? (et = !0, bm(Ce)) : et = !1, Ce.memoizedState = Qe.state !== null && Qe.state !== void 0 ? Qe.state : null, Sb(Ce), Qe.updater = Pm, Ce.stateNode = Qe, Qe._reactInternals = Ce, Tm(Ce, Ue, Se, De), Ce = Nb(null, Ce, Ue, !0, et, De)) : (Ce.tag = 0, Xo && et && vm(Ce), ei(null, Ce, Qe, De), Ce = Ce.child), Ce;
      case 16:
        Ue = Ce.elementType;
        e: {
          switch (yu(Se, Ce), Se = Ce.pendingProps, Qe = Ue._init, Ue = Qe(Ue._payload), Ce.type = Ue, Qe = Ce.tag = $_(Ue), Se = qs(Ue, Se), Qe) {
            case 0:
              Ce = Tf(null, Ce, Ue, Se, De);
              break e;
            case 1:
              Ce = Rb(null, Ce, Ue, Se, De);
              break e;
            case 11:
              Ce = Dc(null, Ce, Ue, Se, De);
              break e;
            case 14:
              Ce = Gm(null, Ce, Ue, qs(Ue.type, Se), De);
              break e;
          }
          throw Error(fe(306, Ue, ""));
        }
        return Ce;
      case 0:
        return Ue = Ce.type, Qe = Ce.pendingProps, Qe = Ce.elementType === Ue ? Qe : qs(Ue, Qe), Tf(Se, Ce, Ue, Qe, De);
      case 1:
        return Ue = Ce.type, Qe = Ce.pendingProps, Qe = Ce.elementType === Ue ? Qe : qs(Ue, Qe), Rb(Se, Ce, Ue, Qe, De);
      case 3:
        e: {
          if (Ym(Ce), Se === null)
            throw Error(fe(387));
          Ue = Ce.pendingProps, et = Ce.memoizedState, Qe = et.element, Xa(Se, Ce), Ic(Ce, Ue, null, De);
          var bt = Ce.memoizedState;
          if (Ue = bt.element, et.isDehydrated)
            if (et = { element: Ue, isDehydrated: !1, cache: bt.cache, pendingSuspenseBoundaries: bt.pendingSuspenseBoundaries, transitions: bt.transitions }, Ce.updateQueue.baseState = et, Ce.memoizedState = et, Ce.flags & 256) {
              Qe = Pf(Error(fe(423)), Ce), Ce = kf(Se, Ce, Ue, De, Qe);
              break e;
            } else if (Ue !== Qe) {
              Qe = Pf(Error(fe(424)), Ce), Ce = kf(Se, Ce, Ue, De, Qe);
              break e;
            } else
              for (Ss = Vu(Ce.stateNode.containerInfo.firstChild), Ws = Ce, Xo = !0, pu = null, De = Ig(Ce, null, Ue, De), Ce.child = De; De; )
                De.flags = De.flags & -3 | 4096, De = De.sibling;
          else {
            if (da(), Ue === Qe) {
              Ce = Pi(Se, Ce, De);
              break e;
            }
            ei(Se, Ce, Ue, De);
          }
          Ce = Ce.child;
        }
        return Ce;
      case 5:
        return Tr(Ce), Se === null && wm(Ce), Ue = Ce.type, Qe = Ce.pendingProps, et = Se !== null ? Se.memoizedProps : null, bt = Qe.children, _p(Ue, Qe) ? bt = null : et !== null && _p(Ue, et) && (Ce.flags |= 32), Zr(Se, Ce), ei(Se, Ce, bt, De), Ce.child;
      case 6:
        return Se === null && wm(Ce), null;
      case 13:
        return jg(Se, Ce, De);
      case 4:
        return kb(Ce, Ce.stateNode.containerInfo), Ue = Ce.pendingProps, Se === null ? Ce.child = wf(Ce, null, Ue, De) : ei(Se, Ce, Ue, De), Ce.child;
      case 11:
        return Ue = Ce.type, Qe = Ce.pendingProps, Qe = Ce.elementType === Ue ? Qe : qs(Ue, Qe), Dc(Se, Ce, Ue, Qe, De);
      case 7:
        return ei(Se, Ce, Ce.pendingProps, De), Ce.child;
      case 8:
        return ei(Se, Ce, Ce.pendingProps.children, De), Ce.child;
      case 12:
        return ei(Se, Ce, Ce.pendingProps.children, De), Ce.child;
      case 10:
        e: {
          if (Ue = Ce.type._context, Qe = Ce.pendingProps, et = Ce.memoizedProps, bt = Qe.value, Co(ul, Ue._currentValue), Ue._currentValue = bt, et !== null)
            if (uu(et.value, bt)) {
              if (et.children === Qe.children && !Sa.current) {
                Ce = Pi(Se, Ce, De);
                break e;
              }
            } else
              for (et = Ce.child, et !== null && (et.return = Ce); et !== null; ) {
                var It = et.dependencies;
                if (It !== null) {
                  bt = et.child;
                  for (var Ut = It.firstContext; Ut !== null; ) {
                    if (Ut.context === Ue) {
                      if (et.tag === 1) {
                        Ut = Dl(-1, De & -De), Ut.tag = 2;
                        var bn = et.updateQueue;
                        if (bn !== null) {
                          bn = bn.shared;
                          var Rn = bn.pending;
                          Rn === null ? Ut.next = Ut : (Ut.next = Rn.next, Rn.next = Ut), bn.pending = Ut;
                        }
                      }
                      et.lanes |= De, Ut = et.alternate, Ut !== null && (Ut.lanes |= De), yi(et.return, De, Ce), It.lanes |= De;
                      break;
                    }
                    Ut = Ut.next;
                  }
                } else if (et.tag === 10)
                  bt = et.type === Ce.type ? null : et.child;
                else if (et.tag === 18) {
                  if (bt = et.return, bt === null)
                    throw Error(fe(341));
                  bt.lanes |= De, It = bt.alternate, It !== null && (It.lanes |= De), yi(bt, De, Ce), bt = et.sibling;
                } else
                  bt = et.child;
                if (bt !== null)
                  bt.return = et;
                else
                  for (bt = et; bt !== null; ) {
                    if (bt === Ce) {
                      bt = null;
                      break;
                    }
                    if (et = bt.sibling, et !== null) {
                      et.return = bt.return, bt = et;
                      break;
                    }
                    bt = bt.return;
                  }
                et = bt;
              }
          ei(Se, Ce, Qe.children, De), Ce = Ce.child;
        }
        return Ce;
      case 9:
        return Qe = Ce.type, Ue = Ce.pendingProps.children, Gn(Ce, De), Qe = Oa(Qe), Ue = Ue(Qe), Ce.flags |= 1, ei(Se, Ce, Ue, De), Ce.child;
      case 14:
        return Ue = Ce.type, Qe = qs(Ue, Ce.pendingProps), Qe = qs(Ue.type, Qe), Gm(Se, Ce, Ue, Qe, De);
      case 15:
        return ks(Se, Ce, Ce.type, Ce.pendingProps, De);
      case 17:
        return Ue = Ce.type, Qe = Ce.pendingProps, Qe = Ce.elementType === Ue ? Qe : qs(Ue, Qe), yu(Se, Ce), Ce.tag = 1, sa(Ue) ? (Se = !0, bm(Ce)) : Se = !1, Gn(Ce, De), Og(Ce, Ue, Qe), Tm(Ce, Ue, Qe, De), Nb(null, Ce, Ue, !0, Se, De);
      case 19:
        return Os(Se, Ce, De);
      case 22:
        return Rd(Se, Ce, De);
    }
    throw Error(fe(156, Ce.tag));
  };
  function Xg(Se, Ce) {
    return Ao(Se, Ce);
  }
  function C_(Se, Ce, De, Ue) {
    this.tag = Se, this.key = De, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = Ce, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Ue, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function gu(Se, Ce, De, Ue) {
    return new C_(Se, Ce, De, Ue);
  }
  function qb(Se) {
    return Se = Se.prototype, !(!Se || !Se.isReactComponent);
  }
  function $_(Se) {
    if (typeof Se == "function")
      return qb(Se) ? 1 : 0;
    if (Se != null) {
      if (Se = Se.$$typeof, Se === tn)
        return 11;
      if (Se === dn)
        return 14;
    }
    return 2;
  }
  function Uc(Se, Ce) {
    var De = Se.alternate;
    return De === null ? (De = gu(Se.tag, Ce, Se.key, Se.mode), De.elementType = Se.elementType, De.type = Se.type, De.stateNode = Se.stateNode, De.alternate = Se, Se.alternate = De) : (De.pendingProps = Ce, De.type = Se.type, De.flags = 0, De.subtreeFlags = 0, De.deletions = null), De.flags = Se.flags & 14680064, De.childLanes = Se.childLanes, De.lanes = Se.lanes, De.child = Se.child, De.memoizedProps = Se.memoizedProps, De.memoizedState = Se.memoizedState, De.updateQueue = Se.updateQueue, Ce = Se.dependencies, De.dependencies = Ce === null ? null : { lanes: Ce.lanes, firstContext: Ce.firstContext }, De.sibling = Se.sibling, De.index = Se.index, De.ref = Se.ref, De;
  }
  function cy(Se, Ce, De, Ue, Qe, et) {
    var bt = 2;
    if (Ue = Se, typeof Se == "function")
      qb(Se) && (bt = 1);
    else if (typeof Se == "string")
      bt = 5;
    else
      e:
        switch (Se) {
          case St:
            return Vc(De.children, Qe, et, Ce);
          case Nt:
            bt = 8, Qe |= 8;
            break;
          case Ft:
            return Se = gu(12, De, Ce, Qe | 2), Se.elementType = Ft, Se.lanes = et, Se;
          case _n:
            return Se = gu(13, De, Ce, Qe), Se.elementType = _n, Se.lanes = et, Se;
          case en:
            return Se = gu(19, De, Ce, Qe), Se.elementType = en, Se.lanes = et, Se;
          case hn:
            return jf(De, Qe, et, Ce);
          default:
            if (typeof Se == "object" && Se !== null)
              switch (Se.$$typeof) {
                case Vt:
                  bt = 10;
                  break e;
                case on:
                  bt = 9;
                  break e;
                case tn:
                  bt = 11;
                  break e;
                case dn:
                  bt = 14;
                  break e;
                case Ht:
                  bt = 16, Ue = null;
                  break e;
              }
            throw Error(fe(130, Se == null ? Se : typeof Se, ""));
        }
    return Ce = gu(bt, De, Ce, Qe), Ce.elementType = Se, Ce.type = Ue, Ce.lanes = et, Ce;
  }
  function Vc(Se, Ce, De, Ue) {
    return Se = gu(7, Se, Ue, Ce), Se.lanes = De, Se;
  }
  function jf(Se, Ce, De, Ue) {
    return Se = gu(22, Se, Ue, Ce), Se.elementType = hn, Se.lanes = De, Se.stateNode = { isHidden: !1 }, Se;
  }
  function Hd(Se, Ce, De) {
    return Se = gu(6, Se, null, Ce), Se.lanes = De, Se;
  }
  function Zb(Se, Ce, De) {
    return Ce = gu(4, Se.children !== null ? Se.children : [], Se.key, Ce), Ce.lanes = De, Ce.stateNode = { containerInfo: Se.containerInfo, pendingChildren: null, implementation: Se.implementation }, Ce;
  }
  function Jg(Se, Ce, De, Ue, Qe) {
    this.tag = Ce, this.containerInfo = Se, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = wl(0), this.expirationTimes = wl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = wl(0), this.identifierPrefix = Ue, this.onRecoverableError = Qe, this.mutableSourceEagerHydrationData = null;
  }
  function dy(Se, Ce, De, Ue, Qe, et, bt, It, Ut) {
    return Se = new Jg(Se, Ce, De, It, Ut), Ce === 1 ? (Ce = 1, et === !0 && (Ce |= 8)) : Ce = 0, et = gu(3, null, null, Ce), Se.current = et, et.stateNode = Se, et.memoizedState = { element: Ue, isDehydrated: De, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Sb(et), Se;
  }
  function e0(Se, Ce, De) {
    var Ue = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: At, key: Ue == null ? null : "" + Ue, children: Se, containerInfo: Ce, implementation: De };
  }
  function t0(Se) {
    if (!Se)
      return sl;
    Se = Se._reactInternals;
    e: {
      if (Dr(Se) !== Se || Se.tag !== 1)
        throw Error(fe(170));
      var Ce = Se;
      do {
        switch (Ce.tag) {
          case 3:
            Ce = Ce.stateNode.context;
            break e;
          case 1:
            if (sa(Ce.type)) {
              Ce = Ce.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        Ce = Ce.return;
      } while (Ce !== null);
      throw Error(fe(171));
    }
    if (Se.tag === 1) {
      var De = Se.type;
      if (sa(De))
        return Sp(Se, De, Ce);
    }
    return Ce;
  }
  function Gb(Se, Ce, De, Ue, Qe, et, bt, It, Ut) {
    return Se = dy(De, Ue, !0, Se, Qe, et, bt, It, Ut), Se.context = t0(null), De = Se.current, Ue = Ho(), Qe = Qs(De), et = Dl(Ue, Qe), et.callback = Ce ?? null, $c(De, et, Qe), Se.current.lanes = Qe, Ds(Se, Qe, Ue), bi(Se, Ue), Se;
  }
  function fy(Se, Ce, De, Ue) {
    var Qe = Ce.current, et = Ho(), bt = Qs(Qe);
    return De = t0(De), Ce.context === null ? Ce.context = De : Ce.pendingContext = De, Ce = Dl(et, bt), Ce.payload = { element: Se }, Ue = Ue === void 0 ? null : Ue, Ue !== null && (Ce.callback = Ue), Se = $c(Qe, Ce, bt), Se !== null && (Ks(Se, Qe, bt, et), Sm(Se, Qe, bt)), bt;
  }
  function py(Se) {
    if (Se = Se.current, !Se.child)
      return null;
    switch (Se.child.tag) {
      case 5:
        return Se.child.stateNode;
      default:
        return Se.child.stateNode;
    }
  }
  function n0(Se, Ce) {
    if (Se = Se.memoizedState, Se !== null && Se.dehydrated !== null) {
      var De = Se.retryLane;
      Se.retryLane = De !== 0 && De < Ce ? De : Ce;
    }
  }
  function hy(Se, Ce) {
    n0(Se, Ce), (Se = Se.alternate) && n0(Se, Ce);
  }
  function r0() {
    return null;
  }
  var Yb = typeof reportError == "function" ? reportError : function(Se) {
    console.error(Se);
  };
  function Hc(Se) {
    this._internalRoot = Se;
  }
  my.prototype.render = Hc.prototype.render = function(Se) {
    var Ce = this._internalRoot;
    if (Ce === null)
      throw Error(fe(409));
    fy(Se, Ce, null, null);
  }, my.prototype.unmount = Hc.prototype.unmount = function() {
    var Se = this._internalRoot;
    if (Se !== null) {
      this._internalRoot = null;
      var Ce = Se.containerInfo;
      zd(function() {
        fy(null, Se, null, null);
      }), Ce[Rl] = null;
    }
  };
  function my(Se) {
    this._internalRoot = Se;
  }
  my.prototype.unstable_scheduleHydration = function(Se) {
    if (Se) {
      var Ce = nl();
      Se = { blockedOn: null, target: Se, priority: Ce };
      for (var De = 0; De < mo.length && Ce !== 0 && Ce < mo[De].priority; De++)
        ;
      mo.splice(De, 0, Se), De === 0 && rl(Se);
    }
  };
  function Qb(Se) {
    return !(!Se || Se.nodeType !== 1 && Se.nodeType !== 9 && Se.nodeType !== 11);
  }
  function yy(Se) {
    return !(!Se || Se.nodeType !== 1 && Se.nodeType !== 9 && Se.nodeType !== 11 && (Se.nodeType !== 8 || Se.nodeValue !== " react-mount-point-unstable "));
  }
  function o0() {
  }
  function I_(Se, Ce, De, Ue, Qe) {
    if (Qe) {
      if (typeof Ue == "function") {
        var et = Ue;
        Ue = function() {
          var bn = py(bt);
          et.call(bn);
        };
      }
      var bt = Gb(Ce, Ue, Se, 0, null, !1, !1, "", o0);
      return Se._reactRootContainer = bt, Se[Rl] = bt.current, yf(Se.nodeType === 8 ? Se.parentNode : Se), zd(), bt;
    }
    for (; Qe = Se.lastChild; )
      Se.removeChild(Qe);
    if (typeof Ue == "function") {
      var It = Ue;
      Ue = function() {
        var bn = py(Ut);
        It.call(bn);
      };
    }
    var Ut = dy(Se, 0, !1, null, null, !1, !1, "", o0);
    return Se._reactRootContainer = Ut, Se[Rl] = Ut.current, yf(Se.nodeType === 8 ? Se.parentNode : Se), zd(function() {
      fy(Ce, Ut, De, Ue);
    }), Ut;
  }
  function by(Se, Ce, De, Ue, Qe) {
    var et = De._reactRootContainer;
    if (et) {
      var bt = et;
      if (typeof Qe == "function") {
        var It = Qe;
        Qe = function() {
          var Ut = py(bt);
          It.call(Ut);
        };
      }
      fy(Ce, bt, Se, Qe);
    } else
      bt = I_(De, Ce, Se, Qe, Ue);
    return py(bt);
  }
  fc = function(Se) {
    switch (Se.tag) {
      case 3:
        var Ce = Se.stateNode;
        if (Ce.current.memoizedState.isDehydrated) {
          var De = gi(Ce.pendingLanes);
          De !== 0 && (Fs(Ce, De | 1), bi(Ce, uo()), !(lo & 6) && (If = uo() + 500, _s()));
        }
        break;
      case 13:
        zd(function() {
          var Ue = Ml(Se, 1);
          if (Ue !== null) {
            var Qe = Ho();
            Ks(Ue, Se, 1, Qe);
          }
        }), hy(Se, 1);
    }
  }, Da = function(Se) {
    if (Se.tag === 13) {
      var Ce = Ml(Se, 134217728);
      if (Ce !== null) {
        var De = Ho();
        Ks(Ce, Se, 134217728, De);
      }
      hy(Se, 134217728);
    }
  }, ho = function(Se) {
    if (Se.tag === 13) {
      var Ce = Qs(Se), De = Ml(Se, Ce);
      if (De !== null) {
        var Ue = Ho();
        Ks(De, Se, Ce, Ue);
      }
      hy(Se, Ce);
    }
  }, nl = function() {
    return po;
  }, _l = function(Se, Ce) {
    var De = po;
    try {
      return po = Se, Ce();
    } finally {
      po = De;
    }
  }, wo = function(Se, Ce, De) {
    switch (Ce) {
      case "input":
        if (na(Se, De), Ce = De.name, De.type === "radio" && Ce != null) {
          for (De = Se; De.parentNode; )
            De = De.parentNode;
          for (De = De.querySelectorAll("input[name=" + JSON.stringify("" + Ce) + '][type="radio"]'), Ce = 0; Ce < De.length; Ce++) {
            var Ue = De[Ce];
            if (Ue !== Se && Ue.form === Se.form) {
              var Qe = Sr(Ue);
              if (!Qe)
                throw Error(fe(90));
              Yr(Ue), na(Ue, Qe);
            }
          }
        }
        break;
      case "textarea":
        Go(Se, De);
        break;
      case "select":
        Ce = De.value, Ce != null && Ro(Se, !!De.multiple, Ce, !1);
    }
  }, Ui = sy, qa = zd;
  var a0 = { usingClientEntryPoint: !1, Events: [xp, bf, Sr, Ha, Bi, sy] }, Yp = { findFiberByHostInstance: lu, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, R_ = { bundleType: Yp.bundleType, version: Yp.version, rendererPackageName: Yp.rendererPackageName, rendererConfig: Yp.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ht.ReactCurrentDispatcher, findHostInstanceByFiber: function(Se) {
    return Se = aa(Se), Se === null ? null : Se.stateNode;
  }, findFiberByHostInstance: Yp.findFiberByHostInstance || r0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Df = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Df.isDisabled && Df.supportsFiber))
    try {
      Ms = Df.inject(R_), Ka = Df;
    } catch {
    }
  var Df;
  ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = a0, ne.createPortal = function(Se, Ce) {
    var De = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Qb(Ce))
      throw Error(fe(200));
    return e0(Se, Ce, null, De);
  }, ne.createRoot = function(Se, Ce) {
    if (!Qb(Se))
      throw Error(fe(299));
    var De = !1, Ue = "", Qe = Yb;
    return Ce != null && (Ce.unstable_strictMode === !0 && (De = !0), Ce.identifierPrefix !== void 0 && (Ue = Ce.identifierPrefix), Ce.onRecoverableError !== void 0 && (Qe = Ce.onRecoverableError)), Ce = dy(Se, 1, !1, null, null, De, !1, Ue, Qe), Se[Rl] = Ce.current, yf(Se.nodeType === 8 ? Se.parentNode : Se), new Hc(Ce);
  }, ne.findDOMNode = function(Se) {
    if (Se == null)
      return null;
    if (Se.nodeType === 1)
      return Se;
    var Ce = Se._reactInternals;
    if (Ce === void 0)
      throw typeof Se.render == "function" ? Error(fe(188)) : (Se = Object.keys(Se).join(","), Error(fe(268, Se)));
    return Se = aa(Ce), Se = Se === null ? null : Se.stateNode, Se;
  }, ne.flushSync = function(Se) {
    return zd(Se);
  }, ne.hydrate = function(Se, Ce, De) {
    if (!yy(Ce))
      throw Error(fe(200));
    return by(null, Se, Ce, !0, De);
  }, ne.hydrateRoot = function(Se, Ce, De) {
    if (!Qb(Se))
      throw Error(fe(405));
    var Ue = De != null && De.hydratedSources || null, Qe = !1, et = "", bt = Yb;
    if (De != null && (De.unstable_strictMode === !0 && (Qe = !0), De.identifierPrefix !== void 0 && (et = De.identifierPrefix), De.onRecoverableError !== void 0 && (bt = De.onRecoverableError)), Ce = Gb(Ce, null, Se, 1, De ?? null, Qe, !1, et, bt), Se[Rl] = Ce.current, yf(Se), Ue)
      for (Se = 0; Se < Ue.length; Se++)
        De = Ue[Se], Qe = De._getVersion, Qe = Qe(De._source), Ce.mutableSourceEagerHydrationData == null ? Ce.mutableSourceEagerHydrationData = [De, Qe] : Ce.mutableSourceEagerHydrationData.push(De, Qe);
    return new my(Ce);
  }, ne.render = function(Se, Ce, De) {
    if (!yy(Ce))
      throw Error(fe(200));
    return by(null, Se, Ce, !1, De);
  }, ne.unmountComponentAtNode = function(Se) {
    if (!yy(Se))
      throw Error(fe(40));
    return Se._reactRootContainer ? (zd(function() {
      by(null, null, Se, !1, function() {
        Se._reactRootContainer = null, Se[Rl] = null;
      });
    }), !0) : !1;
  }, ne.unstable_batchedUpdates = sy, ne.unstable_renderSubtreeIntoContainer = function(Se, Ce, De, Ue) {
    if (!yy(De))
      throw Error(fe(200));
    if (Se == null || Se._reactInternals === void 0)
      throw Error(fe(38));
    return by(Se, Ce, De, !1, Ue);
  }, ne.version = "18.2.0-next-9e3b772b8-20220608";
}), hz = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = ir(), ae = GR(), fe = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ye = !1;
    function we(me) {
      ye = me;
    }
    function _e(me) {
      if (!ye) {
        for (var ve = arguments.length, Ie = new Array(ve > 1 ? ve - 1 : 0), Me = 1; Me < ve; Me++)
          Ie[Me - 1] = arguments[Me];
        Oe("warn", me, Ie);
      }
    }
    function xe(me) {
      if (!ye) {
        for (var ve = arguments.length, Ie = new Array(ve > 1 ? ve - 1 : 0), Me = 1; Me < ve; Me++)
          Ie[Me - 1] = arguments[Me];
        Oe("error", me, Ie);
      }
    }
    function Oe(me, ve, Ie) {
      {
        var Me = fe.ReactDebugCurrentFrame, Fe = Me.getStackAddendum();
        Fe !== "" && (ve += "%s", Ie = Ie.concat([Fe]));
        var Ze = Ie.map(function(Xe) {
          return String(Xe);
        });
        Ze.unshift("Warning: " + ve), Function.prototype.apply.call(console[me], console, Ze);
      }
    }
    var $e = 0, Re = 1, Ne = 2, je = 3, Be = 4, ze = 5, He = 6, qe = 7, Ye = 8, ot = 9, tt = 10, it = 11, ht = 12, gt = 13, At = 14, St = 15, Nt = 16, Ft = 17, Vt = 18, on = 19, tn = 21, _n = 22, en = 23, dn = 24, Ht = 25, hn = !0, kn = !1, Dn = !1, yt = !1, jt = !1, Mn = !0, $n = !1, Zt = !1, vn = !0, Fn = !0, Qn = !0, Un = /* @__PURE__ */ new Set(), ar = {}, Zo = {};
    function ao(me, ve) {
      Yr(me, ve), Yr(me + "Capture", ve);
    }
    function Yr(me, ve) {
      ar[me] && xe("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", me), ar[me] = ve;
      {
        var Ie = me.toLowerCase();
        Zo[Ie] = me, me === "onDoubleClick" && (Zo.ondblclick = me);
      }
      for (var Me = 0; Me < ve.length; Me++)
        Un.add(ve[Me]);
    }
    var so = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Io = Object.prototype.hasOwnProperty;
    function Po(me) {
      {
        var ve = typeof Symbol == "function" && Symbol.toStringTag, Ie = ve && me[Symbol.toStringTag] || me.constructor.name || "Object";
        return Ie;
      }
    }
    function vo(me) {
      try {
        return na(me), !1;
      } catch {
        return !0;
      }
    }
    function na(me) {
      return "" + me;
    }
    function va(me, ve) {
      if (vo(me))
        return xe("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, Po(me)), na(me);
    }
    function go(me) {
      if (vo(me))
        return xe("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Po(me)), na(me);
    }
    function Fo(me, ve) {
      if (vo(me))
        return xe("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, Po(me)), na(me);
    }
    function Ro(me, ve) {
      if (vo(me))
        return xe("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, Po(me)), na(me);
    }
    function la(me) {
      if (vo(me))
        return xe("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Po(me)), na(me);
    }
    function Ia(me) {
      if (vo(me))
        return xe("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Po(me)), na(me);
    }
    var Go = 0, Yo = 1, Ra = 2, Bo = 3, Na = 4, Bt = 5, Kt = 6, mn = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", jn = mn + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", zn = new RegExp("^[" + mn + "][" + jn + "]*$"), qn = {}, rr = {};
    function or(me) {
      return Io.call(rr, me) ? !0 : Io.call(qn, me) ? !1 : zn.test(me) ? (rr[me] = !0, !0) : (qn[me] = !0, xe("Invalid attribute name: `%s`", me), !1);
    }
    function Wn(me, ve, Ie) {
      return ve !== null ? ve.type === Go : Ie ? !1 : me.length > 2 && (me[0] === "o" || me[0] === "O") && (me[1] === "n" || me[1] === "N");
    }
    function Ar(me, ve, Ie, Me) {
      if (Ie !== null && Ie.type === Go)
        return !1;
      switch (typeof ve) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (Me)
            return !1;
          if (Ie !== null)
            return !Ie.acceptsBooleans;
          var Fe = me.toLowerCase().slice(0, 5);
          return Fe !== "data-" && Fe !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Br(me, ve, Ie, Me) {
      if (ve === null || typeof ve > "u" || Ar(me, ve, Ie, Me))
        return !0;
      if (Me)
        return !1;
      if (Ie !== null)
        switch (Ie.type) {
          case Bo:
            return !ve;
          case Na:
            return ve === !1;
          case Bt:
            return isNaN(ve);
          case Kt:
            return isNaN(ve) || ve < 1;
        }
      return !1;
    }
    function wo(me) {
      return _r.hasOwnProperty(me) ? _r[me] : null;
    }
    function wr(me, ve, Ie, Me, Fe, Ze, Xe) {
      this.acceptsBooleans = ve === Ra || ve === Bo || ve === Na, this.attributeName = Me, this.attributeNamespace = Fe, this.mustUseProperty = Ie, this.propertyName = me, this.type = ve, this.sanitizeURL = Ze, this.removeEmptyString = Xe;
    }
    var _r = {}, To = ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"];
    To.forEach(function(me) {
      _r[me] = new wr(me, Go, !1, me, null, !1, !1);
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(me) {
      var ve = me[0], Ie = me[1];
      _r[ve] = new wr(ve, Yo, !1, Ie, null, !1, !1);
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(me) {
      _r[me] = new wr(me, Ra, !1, me.toLowerCase(), null, !1, !1);
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(me) {
      _r[me] = new wr(me, Ra, !1, me, null, !1, !1);
    }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(function(me) {
      _r[me] = new wr(me, Bo, !1, me.toLowerCase(), null, !1, !1);
    }), ["checked", "multiple", "muted", "selected"].forEach(function(me) {
      _r[me] = new wr(me, Bo, !0, me, null, !1, !1);
    }), ["capture", "download"].forEach(function(me) {
      _r[me] = new wr(me, Na, !1, me, null, !1, !1);
    }), ["cols", "rows", "size", "span"].forEach(function(me) {
      _r[me] = new wr(me, Kt, !1, me, null, !1, !1);
    }), ["rowSpan", "start"].forEach(function(me) {
      _r[me] = new wr(me, Bt, !1, me.toLowerCase(), null, !1, !1);
    });
    var Ha = /[\-\:]([a-z])/g, Bi = function(me) {
      return me[1].toUpperCase();
    };
    ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(function(me) {
      var ve = me.replace(Ha, Bi);
      _r[ve] = new wr(ve, Yo, !1, me, null, !1, !1);
    }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(function(me) {
      var ve = me.replace(Ha, Bi);
      _r[ve] = new wr(ve, Yo, !1, me, "http://www.w3.org/1999/xlink", !1, !1);
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function(me) {
      var ve = me.replace(Ha, Bi);
      _r[ve] = new wr(ve, Yo, !1, me, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }), ["tabIndex", "crossOrigin"].forEach(function(me) {
      _r[me] = new wr(me, Yo, !1, me.toLowerCase(), null, !1, !1);
    });
    var Ui = "xlinkHref";
    _r[Ui] = new wr("xlinkHref", Yo, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(me) {
      _r[me] = new wr(me, Yo, !1, me.toLowerCase(), null, !0, !0);
    });
    var qa = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, si = !1;
    function ra(me) {
      !si && qa.test(me) && (si = !0, xe("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(me)));
    }
    function Ta(me, ve, Ie, Me) {
      if (Me.mustUseProperty) {
        var Fe = Me.propertyName;
        return me[Fe];
      } else {
        va(Ie, ve), Me.sanitizeURL && ra("" + Ie);
        var Ze = Me.attributeName, Xe = null;
        if (Me.type === Na) {
          if (me.hasAttribute(Ze)) {
            var at = me.getAttribute(Ze);
            return at === "" ? !0 : Br(ve, Ie, Me, !1) ? at : at === "" + Ie ? Ie : at;
          }
        } else if (me.hasAttribute(Ze)) {
          if (Br(ve, Ie, Me, !1))
            return me.getAttribute(Ze);
          if (Me.type === Bo)
            return Ie;
          Xe = me.getAttribute(Ze);
        }
        return Br(ve, Ie, Me, !1) ? Xe === null ? Ie : Xe : Xe === "" + Ie ? Ie : Xe;
      }
    }
    function ci(me, ve, Ie, Me) {
      {
        if (!or(ve))
          return;
        if (!me.hasAttribute(ve))
          return Ie === void 0 ? void 0 : null;
        var Fe = me.getAttribute(ve);
        return va(Ie, ve), Fe === "" + Ie ? Ie : Fe;
      }
    }
    function wa(me, ve, Ie, Me) {
      var Fe = wo(ve);
      if (!Wn(ve, Fe, Me)) {
        if (Br(ve, Ie, Fe, Me) && (Ie = null), Me || Fe === null) {
          if (or(ve)) {
            var Ze = ve;
            Ie === null ? me.removeAttribute(Ze) : (va(Ie, ve), me.setAttribute(Ze, "" + Ie));
          }
          return;
        }
        var Xe = Fe.mustUseProperty;
        if (Xe) {
          var at = Fe.propertyName;
          if (Ie === null) {
            var pt = Fe.type;
            me[at] = pt === Bo ? !1 : "";
          } else
            me[at] = Ie;
          return;
        }
        var wt = Fe.attributeName, Ct = Fe.attributeNamespace;
        if (Ie === null)
          me.removeAttribute(wt);
        else {
          var Jt = Fe.type, Gt;
          Jt === Bo || Jt === Na && Ie === !0 ? Gt = "" : (va(Ie, wt), Gt = "" + Ie, Fe.sanitizeURL && ra(Gt.toString())), Ct ? me.setAttributeNS(Ct, wt, Gt) : me.setAttribute(wt, Gt);
        }
      }
    }
    var fo = Symbol.for("react.element"), _o = Symbol.for("react.portal"), oa = Symbol.for("react.fragment"), Ma = Symbol.for("react.strict_mode"), Rt = Symbol.for("react.profiler"), Cn = Symbol.for("react.provider"), Pn = Symbol.for("react.context"), hr = Symbol.for("react.forward_ref"), Dr = Symbol.for("react.suspense"), Jr = Symbol.for("react.suspense_list"), zr = Symbol.for("react.memo"), gr = Symbol.for("react.lazy"), aa = Symbol.for("react.scope"), Oo = Symbol.for("react.debug_trace_mode"), Ao = Symbol.for("react.offscreen"), ka = Symbol.for("react.legacy_hidden"), ys = Symbol.for("react.cache"), Qu = Symbol.for("react.tracing_marker"), uo = Symbol.iterator, nd = "@@iterator";
    function Yi(me) {
      if (me === null || typeof me != "object")
        return null;
      var ve = uo && me[uo] || me[nd];
      return typeof ve == "function" ? ve : null;
    }
    var Wr = Object.assign, Ea = 0, Ku, Fu, Ms, Ka, Xu, ja, Ju;
    function el() {
    }
    el.__reactDisabledLog = !0;
    function rd() {
      {
        if (Ea === 0) {
          Ku = console.log, Fu = console.info, Ms = console.warn, Ka = console.error, Xu = console.group, ja = console.groupCollapsed, Ju = console.groupEnd;
          var me = { configurable: !0, enumerable: !0, value: el, writable: !0 };
          Object.defineProperties(console, { info: me, log: me, warn: me, error: me, group: me, groupCollapsed: me, groupEnd: me });
        }
        Ea++;
      }
    }
    function tl() {
      {
        if (Ea--, Ea === 0) {
          var me = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: Wr({}, me, { value: Ku }), info: Wr({}, me, { value: Fu }), warn: Wr({}, me, { value: Ms }), error: Wr({}, me, { value: Ka }), group: Wr({}, me, { value: Xu }), groupCollapsed: Wr({}, me, { value: ja }), groupEnd: Wr({}, me, { value: Ju }) });
        }
        Ea < 0 && xe("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Vi = fe.ReactCurrentDispatcher, gi;
    function ca(me, ve, Ie) {
      {
        if (gi === void 0)
          try {
            throw Error();
          } catch (Fe) {
            var Me = Fe.stack.trim().match(/\n( *(at )?)/);
            gi = Me && Me[1] || "";
          }
        return `
` + gi + me;
      }
    }
    var js = !1, Hi;
    {
      var gl = typeof WeakMap == "function" ? WeakMap : Map;
      Hi = new gl();
    }
    function ru(me, ve) {
      if (!me || js)
        return "";
      {
        var Ie = Hi.get(me);
        if (Ie !== void 0)
          return Ie;
      }
      var Me;
      js = !0;
      var Fe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ze;
      Ze = Vi.current, Vi.current = null, rd();
      try {
        if (ve) {
          var Xe = function() {
            throw Error();
          };
          if (Object.defineProperty(Xe.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Xe, []);
            } catch (yn) {
              Me = yn;
            }
            Reflect.construct(me, [], Xe);
          } else {
            try {
              Xe.call();
            } catch (yn) {
              Me = yn;
            }
            me.call(Xe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (yn) {
            Me = yn;
          }
          me();
        }
      } catch (yn) {
        if (yn && Me && typeof yn.stack == "string") {
          for (var at = yn.stack.split(`
`), pt = Me.stack.split(`
`), wt = at.length - 1, Ct = pt.length - 1; wt >= 1 && Ct >= 0 && at[wt] !== pt[Ct]; )
            Ct--;
          for (; wt >= 1 && Ct >= 0; wt--, Ct--)
            if (at[wt] !== pt[Ct]) {
              if (wt !== 1 || Ct !== 1)
                do
                  if (wt--, Ct--, Ct < 0 || at[wt] !== pt[Ct]) {
                    var Jt = `
` + at[wt].replace(" at new ", " at ");
                    return me.displayName && Jt.includes("<anonymous>") && (Jt = Jt.replace("<anonymous>", me.displayName)), typeof me == "function" && Hi.set(me, Jt), Jt;
                  }
                while (wt >= 1 && Ct >= 0);
              break;
            }
        }
      } finally {
        js = !1, Vi.current = Ze, tl(), Error.prepareStackTrace = Fe;
      }
      var Gt = me ? me.displayName || me.name : "", pn = Gt ? ca(Gt) : "";
      return typeof me == "function" && Hi.set(me, pn), pn;
    }
    function wl(me, ve, Ie) {
      return ru(me, !0);
    }
    function Ds(me, ve, Ie) {
      return ru(me, !1);
    }
    function Ls(me) {
      var ve = me.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function Fs(me, ve, Ie) {
      if (me == null)
        return "";
      if (typeof me == "function")
        return ru(me, Ls(me));
      if (typeof me == "string")
        return ca(me);
      switch (me) {
        case Dr:
          return ca("Suspense");
        case Jr:
          return ca("SuspenseList");
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case hr:
            return Ds(me.render);
          case zr:
            return Fs(me.type, ve, Ie);
          case gr: {
            var Me = me, Fe = Me._payload, Ze = Me._init;
            try {
              return Fs(Ze(Fe), ve, Ie);
            } catch {
            }
          }
        }
      return "";
    }
    function po(me) {
      switch (me._debugOwner && me._debugOwner.type, me._debugSource, me.tag) {
        case ze:
          return ca(me.type);
        case Nt:
          return ca("Lazy");
        case gt:
          return ca("Suspense");
        case on:
          return ca("SuspenseList");
        case $e:
        case Ne:
        case St:
          return Ds(me.type);
        case it:
          return Ds(me.type.render);
        case Re:
          return wl(me.type);
        default:
          return "";
      }
    }
    function ts(me) {
      try {
        var ve = "", Ie = me;
        do
          ve += po(Ie), Ie = Ie.return;
        while (Ie);
        return ve;
      } catch (Me) {
        return `
Error generating stack: ` + Me.message + `
` + Me.stack;
      }
    }
    function fc(me, ve, Ie) {
      var Me = me.displayName;
      if (Me)
        return Me;
      var Fe = ve.displayName || ve.name || "";
      return Fe !== "" ? Ie + "(" + Fe + ")" : Ie;
    }
    function Da(me) {
      return me.displayName || "Context";
    }
    function ho(me) {
      if (me == null)
        return null;
      if (typeof me.tag == "number" && xe("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof me == "function")
        return me.displayName || me.name || null;
      if (typeof me == "string")
        return me;
      switch (me) {
        case oa:
          return "Fragment";
        case _o:
          return "Portal";
        case Rt:
          return "Profiler";
        case Ma:
          return "StrictMode";
        case Dr:
          return "Suspense";
        case Jr:
          return "SuspenseList";
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case Pn:
            var ve = me;
            return Da(ve) + ".Consumer";
          case Cn:
            var Ie = me;
            return Da(Ie._context) + ".Provider";
          case hr:
            return fc(me, me.render, "ForwardRef");
          case zr:
            var Me = me.displayName || null;
            return Me !== null ? Me : ho(me.type) || "Memo";
          case gr: {
            var Fe = me, Ze = Fe._payload, Xe = Fe._init;
            try {
              return ho(Xe(Ze));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function nl(me, ve, Ie) {
      var Me = ve.displayName || ve.name || "";
      return me.displayName || (Me !== "" ? Ie + "(" + Me + ")" : Ie);
    }
    function _l(me) {
      return me.displayName || "Context";
    }
    function Mr(me) {
      var ve = me.tag, Ie = me.type;
      switch (ve) {
        case dn:
          return "Cache";
        case ot:
          var Me = Ie;
          return _l(Me) + ".Consumer";
        case tt:
          var Fe = Ie;
          return _l(Fe._context) + ".Provider";
        case Vt:
          return "DehydratedFragment";
        case it:
          return nl(Ie, Ie.render, "ForwardRef");
        case qe:
          return "Fragment";
        case ze:
          return Ie;
        case Be:
          return "Portal";
        case je:
          return "Root";
        case He:
          return "Text";
        case Nt:
          return ho(Ie);
        case Ye:
          return Ie === Ma ? "StrictMode" : "Mode";
        case _n:
          return "Offscreen";
        case ht:
          return "Profiler";
        case tn:
          return "Scope";
        case gt:
          return "Suspense";
        case on:
          return "SuspenseList";
        case Ht:
          return "TracingMarker";
        case Re:
        case $e:
        case Ft:
        case Ne:
        case At:
        case St:
          if (typeof Ie == "function")
            return Ie.displayName || Ie.name || null;
          if (typeof Ie == "string")
            return Ie;
          break;
      }
      return null;
    }
    var Bs = fe.ReactDebugCurrentFrame, Wo = null, La = !1;
    function Fa() {
      {
        if (Wo === null)
          return null;
        var me = Wo._debugOwner;
        if (me !== null && typeof me < "u")
          return Mr(me);
      }
      return null;
    }
    function zs() {
      return Wo === null ? "" : ts(Wo);
    }
    function Qo() {
      Bs.getCurrentStack = null, Wo = null, La = !1;
    }
    function mo(me) {
      Bs.getCurrentStack = me === null ? null : zs, Wo = me, La = !1;
    }
    function El() {
      return Wo;
    }
    function wi(me) {
      La = me;
    }
    function xa(me) {
      return "" + me;
    }
    function bs(me) {
      switch (typeof me) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return me;
        case "object":
          return Ia(me), me;
        default:
          return "";
      }
    }
    var rl = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 };
    function di(me, ve) {
      rl[ve.type] || ve.onChange || ve.onInput || ve.readOnly || ve.disabled || ve.value == null || xe("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), ve.onChange || ve.readOnly || ve.disabled || ve.checked == null || xe("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function xl(me) {
      var ve = me.type, Ie = me.nodeName;
      return Ie && Ie.toLowerCase() === "input" && (ve === "checkbox" || ve === "radio");
    }
    function fi(me) {
      return me._valueTracker;
    }
    function Us(me) {
      me._valueTracker = null;
    }
    function ou(me) {
      var ve = "";
      return me && (xl(me) ? ve = me.checked ? "true" : "false" : ve = me.value), ve;
    }
    function pi(me) {
      var ve = xl(me) ? "checked" : "value", Ie = Object.getOwnPropertyDescriptor(me.constructor.prototype, ve);
      Ia(me[ve]);
      var Me = "" + me[ve];
      if (!(me.hasOwnProperty(ve) || typeof Ie > "u" || typeof Ie.get != "function" || typeof Ie.set != "function")) {
        var Fe = Ie.get, Ze = Ie.set;
        Object.defineProperty(me, ve, { configurable: !0, get: function() {
          return Fe.call(this);
        }, set: function(at) {
          Ia(at), Me = "" + at, Ze.call(this, at);
        } }), Object.defineProperty(me, ve, { enumerable: Ie.enumerable });
        var Xe = { getValue: function() {
          return Me;
        }, setValue: function(at) {
          Ia(at), Me = "" + at;
        }, stopTracking: function() {
          Us(me), delete me[ve];
        } };
        return Xe;
      }
    }
    function Ei(me) {
      fi(me) || (me._valueTracker = pi(me));
    }
    function au(me) {
      if (!me)
        return !1;
      var ve = fi(me);
      if (!ve)
        return !0;
      var Ie = ve.getValue(), Me = ou(me);
      return Me !== Ie ? (ve.setValue(Me), !0) : !1;
    }
    function vs(me) {
      if (me = me || (typeof document < "u" ? document : void 0), typeof me > "u")
        return null;
      try {
        return me.activeElement || me.body;
      } catch {
        return me.body;
      }
    }
    var ol = !1, Bu = !1, al = !1, Sl = !1;
    function Ge(me) {
      var ve = me.type === "checkbox" || me.type === "radio";
      return ve ? me.checked != null : me.value != null;
    }
    function dt(me, ve) {
      var Ie = me, Me = ve.checked, Fe = Wr({}, ve, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Me ?? Ie._wrapperState.initialChecked });
      return Fe;
    }
    function Ot(me, ve) {
      di("input", ve), ve.checked !== void 0 && ve.defaultChecked !== void 0 && !Bu && (xe("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fa() || "A component", ve.type), Bu = !0), ve.value !== void 0 && ve.defaultValue !== void 0 && !ol && (xe("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fa() || "A component", ve.type), ol = !0);
      var Ie = me, Me = ve.defaultValue == null ? "" : ve.defaultValue;
      Ie._wrapperState = { initialChecked: ve.checked != null ? ve.checked : ve.defaultChecked, initialValue: bs(ve.value != null ? ve.value : Me), controlled: Ge(ve) };
    }
    function $t(me, ve) {
      var Ie = me, Me = ve.checked;
      Me != null && wa(Ie, "checked", Me, !1);
    }
    function Xt(me, ve) {
      var Ie = me;
      {
        var Me = Ge(ve);
        !Ie._wrapperState.controlled && Me && !Sl && (xe("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Sl = !0), Ie._wrapperState.controlled && !Me && !al && (xe("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), al = !0);
      }
      $t(me, ve);
      var Fe = bs(ve.value), Ze = ve.type;
      if (Fe != null)
        Ze === "number" ? (Fe === 0 && Ie.value === "" || Ie.value != Fe) && (Ie.value = xa(Fe)) : Ie.value !== xa(Fe) && (Ie.value = xa(Fe));
      else if (Ze === "submit" || Ze === "reset") {
        Ie.removeAttribute("value");
        return;
      }
      ve.hasOwnProperty("value") ? Zn(Ie, ve.type, Fe) : ve.hasOwnProperty("defaultValue") && Zn(Ie, ve.type, bs(ve.defaultValue)), ve.checked == null && ve.defaultChecked != null && (Ie.defaultChecked = !!ve.defaultChecked);
    }
    function An(me, ve, Ie) {
      var Me = me;
      if (ve.hasOwnProperty("value") || ve.hasOwnProperty("defaultValue")) {
        var Fe = ve.type, Ze = Fe === "submit" || Fe === "reset";
        if (Ze && (ve.value === void 0 || ve.value === null))
          return;
        var Xe = xa(Me._wrapperState.initialValue);
        Ie || Xe !== Me.value && (Me.value = Xe), Me.defaultValue = Xe;
      }
      var at = Me.name;
      at !== "" && (Me.name = ""), Me.defaultChecked = !Me.defaultChecked, Me.defaultChecked = !!Me._wrapperState.initialChecked, at !== "" && (Me.name = at);
    }
    function gn(me, ve) {
      var Ie = me;
      Xt(Ie, ve), In(Ie, ve);
    }
    function In(me, ve) {
      var Ie = ve.name;
      if (ve.type === "radio" && Ie != null) {
        for (var Me = me; Me.parentNode; )
          Me = Me.parentNode;
        va(Ie, "name");
        for (var Fe = Me.querySelectorAll("input[name=" + JSON.stringify("" + Ie) + '][type="radio"]'), Ze = 0; Ze < Fe.length; Ze++) {
          var Xe = Fe[Ze];
          if (!(Xe === me || Xe.form !== me.form)) {
            var at = E0(Xe);
            if (!at)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            au(Xe), Xt(Xe, at);
          }
        }
      }
    }
    function Zn(me, ve, Ie) {
      (ve !== "number" || vs(me.ownerDocument) !== me) && (Ie == null ? me.defaultValue = xa(me._wrapperState.initialValue) : me.defaultValue !== xa(Ie) && (me.defaultValue = xa(Ie)));
    }
    var br = !1, Er = !1, Cr = !1;
    function Ir(me, ve) {
      ve.value == null && (typeof ve.children == "object" && ve.children !== null ? oe.Children.forEach(ve.children, function(Ie) {
        Ie != null && (typeof Ie == "string" || typeof Ie == "number" || Er || (Er = !0, xe("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : ve.dangerouslySetInnerHTML != null && (Cr || (Cr = !0, xe("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), ve.selected != null && !br && (xe("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), br = !0);
    }
    function Vr(me, ve) {
      ve.value != null && me.setAttribute("value", xa(bs(ve.value)));
    }
    var Kr = Array.isArray;
    function No(me) {
      return Kr(me);
    }
    var iu;
    iu = !1;
    function pc() {
      var me = Fa();
      return me ? `

Check the render method of \`` + me + "`." : "";
    }
    var sf = ["value", "defaultValue"];
    function od(me) {
      {
        di("select", me);
        for (var ve = 0; ve < sf.length; ve++) {
          var Ie = sf[ve];
          if (me[Ie] != null) {
            var Me = No(me[Ie]);
            me.multiple && !Me ? xe("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", Ie, pc()) : !me.multiple && Me && xe("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", Ie, pc());
          }
        }
      }
    }
    function su(me, ve, Ie, Me) {
      var Fe = me.options;
      if (ve) {
        for (var Ze = Ie, Xe = {}, at = 0; at < Ze.length; at++)
          Xe["$" + Ze[at]] = !0;
        for (var pt = 0; pt < Fe.length; pt++) {
          var wt = Xe.hasOwnProperty("$" + Fe[pt].value);
          Fe[pt].selected !== wt && (Fe[pt].selected = wt), wt && Me && (Fe[pt].defaultSelected = !0);
        }
      } else {
        for (var Ct = xa(bs(Ie)), Jt = null, Gt = 0; Gt < Fe.length; Gt++) {
          if (Fe[Gt].value === Ct) {
            Fe[Gt].selected = !0, Me && (Fe[Gt].defaultSelected = !0);
            return;
          }
          Jt === null && !Fe[Gt].disabled && (Jt = Fe[Gt]);
        }
        Jt !== null && (Jt.selected = !0);
      }
    }
    function Pl(me, ve) {
      return Wr({}, ve, { value: void 0 });
    }
    function uf(me, ve) {
      var Ie = me;
      od(ve), Ie._wrapperState = { wasMultiple: !!ve.multiple }, ve.value !== void 0 && ve.defaultValue !== void 0 && !iu && (xe("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), iu = !0);
    }
    function n_(me, ve) {
      var Ie = me;
      Ie.multiple = !!ve.multiple;
      var Me = ve.value;
      Me != null ? su(Ie, !!ve.multiple, Me, !1) : ve.defaultValue != null && su(Ie, !!ve.multiple, ve.defaultValue, !0);
    }
    function r_(me, ve) {
      var Ie = me, Me = Ie._wrapperState.wasMultiple;
      Ie._wrapperState.wasMultiple = !!ve.multiple;
      var Fe = ve.value;
      Fe != null ? su(Ie, !!ve.multiple, Fe, !1) : Me !== !!ve.multiple && (ve.defaultValue != null ? su(Ie, !!ve.multiple, ve.defaultValue, !0) : su(Ie, !!ve.multiple, ve.multiple ? [] : "", !1));
    }
    function o_(me, ve) {
      var Ie = me, Me = ve.value;
      Me != null && su(Ie, !!ve.multiple, Me, !1);
    }
    var Gy = !1;
    function Yy(me, ve) {
      var Ie = me;
      if (ve.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var Me = Wr({}, ve, { value: void 0, defaultValue: void 0, children: xa(Ie._wrapperState.initialValue) });
      return Me;
    }
    function Zv(me, ve) {
      var Ie = me;
      di("textarea", ve), ve.value !== void 0 && ve.defaultValue !== void 0 && !Gy && (xe("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fa() || "A component"), Gy = !0);
      var Me = ve.value;
      if (Me == null) {
        var Fe = ve.children, Ze = ve.defaultValue;
        if (Fe != null) {
          xe("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (Ze != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (No(Fe)) {
              if (Fe.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              Fe = Fe[0];
            }
            Ze = Fe;
          }
        }
        Ze == null && (Ze = ""), Me = Ze;
      }
      Ie._wrapperState = { initialValue: bs(Me) };
    }
    function Gv(me, ve) {
      var Ie = me, Me = bs(ve.value), Fe = bs(ve.defaultValue);
      if (Me != null) {
        var Ze = xa(Me);
        Ze !== Ie.value && (Ie.value = Ze), ve.defaultValue == null && Ie.defaultValue !== Ze && (Ie.defaultValue = Ze);
      }
      Fe != null && (Ie.defaultValue = xa(Fe));
    }
    function Yv(me, ve) {
      var Ie = me, Me = Ie.textContent;
      Me === Ie._wrapperState.initialValue && Me !== "" && Me !== null && (Ie.value = Me);
    }
    function Qy(me, ve) {
      Gv(me, ve);
    }
    var Tl = "http://www.w3.org/1999/xhtml", a_ = "http://www.w3.org/1998/Math/MathML", Ky = "http://www.w3.org/2000/svg";
    function am(me) {
      switch (me) {
        case "svg":
          return Ky;
        case "math":
          return a_;
        default:
          return Tl;
      }
    }
    function Xy(me, ve) {
      return me == null || me === Tl ? am(ve) : me === Ky && ve === "foreignObject" ? Tl : me;
    }
    var i_ = function(me) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ve, Ie, Me, Fe) {
        MSApp.execUnsafeLocalFunction(function() {
          return me(ve, Ie, Me, Fe);
        });
      } : me;
    }, im, Qv = i_(function(me, ve) {
      if (me.namespaceURI === Ky && !("innerHTML" in me)) {
        im = im || document.createElement("div"), im.innerHTML = "<svg>" + ve.valueOf().toString() + "</svg>";
        for (var Ie = im.firstChild; me.firstChild; )
          me.removeChild(me.firstChild);
        for (; Ie.firstChild; )
          me.appendChild(Ie.firstChild);
        return;
      }
      me.innerHTML = ve;
    }), gs = 1, kl = 3, Ba = 8, zu = 9, ad = 11, sm = function(me, ve) {
      if (ve) {
        var Ie = me.firstChild;
        if (Ie && Ie === me.lastChild && Ie.nodeType === kl) {
          Ie.nodeValue = ve;
          return;
        }
      }
      me.textContent = ve;
    }, Kv = { animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"], background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"], backgroundPosition: ["backgroundPositionX", "backgroundPositionY"], border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"], borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"], borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"], borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"], borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"], borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"], borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"], borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"], borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"], borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"], borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"], borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"], borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"], borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"], columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"], columns: ["columnCount", "columnWidth"], flex: ["flexBasis", "flexGrow", "flexShrink"], flexFlow: ["flexDirection", "flexWrap"], font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"], fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"], gap: ["columnGap", "rowGap"], grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"], gridColumn: ["gridColumnEnd", "gridColumnStart"], gridColumnGap: ["columnGap"], gridGap: ["columnGap", "rowGap"], gridRow: ["gridRowEnd", "gridRowStart"], gridRowGap: ["rowGap"], gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], listStyle: ["listStyleImage", "listStylePosition", "listStyleType"], margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"], marker: ["markerEnd", "markerMid", "markerStart"], mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"], maskPosition: ["maskPositionX", "maskPositionY"], outline: ["outlineColor", "outlineStyle", "outlineWidth"], overflow: ["overflowX", "overflowY"], padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"], placeContent: ["alignContent", "justifyContent"], placeItems: ["alignItems", "justifyItems"], placeSelf: ["alignSelf", "justifySelf"], textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"], textEmphasis: ["textEmphasisColor", "textEmphasisStyle"], transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"], wordWrap: ["overflowWrap"] }, lf = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 };
    function Xv(me, ve) {
      return me + ve.charAt(0).toUpperCase() + ve.substring(1);
    }
    var Jv = ["Webkit", "ms", "Moz", "O"];
    Object.keys(lf).forEach(function(me) {
      Jv.forEach(function(ve) {
        lf[Xv(ve, me)] = lf[me];
      });
    });
    function um(me, ve, Ie) {
      var Me = ve == null || typeof ve == "boolean" || ve === "";
      return Me ? "" : !Ie && typeof ve == "number" && ve !== 0 && !(lf.hasOwnProperty(me) && lf[me]) ? ve + "px" : (Ro(ve, me), ("" + ve).trim());
    }
    var cf = /([A-Z])/g, s_ = /^ms-/;
    function u_(me) {
      return me.replace(cf, "-$1").toLowerCase().replace(s_, "-ms-");
    }
    var eg = function() {
    };
    {
      var tg = /^(?:webkit|moz|o)[A-Z]/, ng = /^-ms-/, hp = /-(.)/g, df = /;\s*$/, ff = {}, pf = {}, rg = !1, Jy = !1, eb = function(me) {
        return me.replace(hp, function(ve, Ie) {
          return Ie.toUpperCase();
        });
      }, lm = function(me) {
        ff.hasOwnProperty(me) && ff[me] || (ff[me] = !0, xe("Unsupported style property %s. Did you mean %s?", me, eb(me.replace(ng, "ms-"))));
      }, tb = function(me) {
        ff.hasOwnProperty(me) && ff[me] || (ff[me] = !0, xe("Unsupported vendor-prefixed style property %s. Did you mean %s?", me, me.charAt(0).toUpperCase() + me.slice(1)));
      }, og = function(me, ve) {
        pf.hasOwnProperty(ve) && pf[ve] || (pf[ve] = !0, xe(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, me, ve.replace(df, "")));
      }, ag = function(me, ve) {
        rg || (rg = !0, xe("`NaN` is an invalid value for the `%s` css style property.", me));
      }, l_ = function(me, ve) {
        Jy || (Jy = !0, xe("`Infinity` is an invalid value for the `%s` css style property.", me));
      };
      eg = function(me, ve) {
        me.indexOf("-") > -1 ? lm(me) : tg.test(me) ? tb(me) : df.test(ve) && og(me, ve), typeof ve == "number" && (isNaN(ve) ? ag(me, ve) : isFinite(ve) || l_(me, ve));
      };
    }
    var c_ = eg;
    function d_(me) {
      {
        var ve = "", Ie = "";
        for (var Me in me)
          if (me.hasOwnProperty(Me)) {
            var Fe = me[Me];
            if (Fe != null) {
              var Ze = Me.indexOf("--") === 0;
              ve += Ie + (Ze ? Me : u_(Me)) + ":", ve += um(Me, Fe, Ze), Ie = ";";
            }
          }
        return ve || null;
      }
    }
    function ig(me, ve) {
      var Ie = me.style;
      for (var Me in ve)
        if (ve.hasOwnProperty(Me)) {
          var Fe = Me.indexOf("--") === 0;
          Fe || c_(Me, ve[Me]);
          var Ze = um(Me, ve[Me], Fe);
          Me === "float" && (Me = "cssFloat"), Fe ? Ie.setProperty(Me, Ze) : Ie[Me] = Ze;
        }
    }
    function f_(me) {
      return me == null || typeof me == "boolean" || me === "";
    }
    function uu(me) {
      var ve = {};
      for (var Ie in me)
        for (var Me = Kv[Ie] || [Ie], Fe = 0; Fe < Me.length; Fe++)
          ve[Me[Fe]] = Ie;
      return ve;
    }
    function mp(me, ve) {
      {
        if (!ve)
          return;
        var Ie = uu(me), Me = uu(ve), Fe = {};
        for (var Ze in Ie) {
          var Xe = Ie[Ze], at = Me[Ze];
          if (at && Xe !== at) {
            var pt = Xe + "," + at;
            if (Fe[pt])
              continue;
            Fe[pt] = !0, xe("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", f_(me[Xe]) ? "Removing" : "Updating", Xe, at);
          }
        }
      }
    }
    var sg = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, ug = Wr({ menuitem: !0 }, sg), lg = "__html";
    function cm(me, ve) {
      if (ve) {
        if (ug[me] && (ve.children != null || ve.dangerouslySetInnerHTML != null))
          throw new Error(me + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (ve.dangerouslySetInnerHTML != null) {
          if (ve.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof ve.dangerouslySetInnerHTML != "object" || !(lg in ve.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!ve.suppressContentEditableWarning && ve.contentEditable && ve.children != null && xe("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), ve.style != null && typeof ve.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Ol(me, ve) {
      if (me.indexOf("-") === -1)
        return typeof ve.is == "string";
      switch (me) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var dm = { accept: "accept", acceptcharset: "acceptCharset", "accept-charset": "acceptCharset", accesskey: "accessKey", action: "action", allowfullscreen: "allowFullScreen", alt: "alt", as: "as", async: "async", autocapitalize: "autoCapitalize", autocomplete: "autoComplete", autocorrect: "autoCorrect", autofocus: "autoFocus", autoplay: "autoPlay", autosave: "autoSave", capture: "capture", cellpadding: "cellPadding", cellspacing: "cellSpacing", challenge: "challenge", charset: "charSet", checked: "checked", children: "children", cite: "cite", class: "className", classid: "classID", classname: "className", cols: "cols", colspan: "colSpan", content: "content", contenteditable: "contentEditable", contextmenu: "contextMenu", controls: "controls", controlslist: "controlsList", coords: "coords", crossorigin: "crossOrigin", dangerouslysetinnerhtml: "dangerouslySetInnerHTML", data: "data", datetime: "dateTime", default: "default", defaultchecked: "defaultChecked", defaultvalue: "defaultValue", defer: "defer", dir: "dir", disabled: "disabled", disablepictureinpicture: "disablePictureInPicture", disableremoteplayback: "disableRemotePlayback", download: "download", draggable: "draggable", enctype: "encType", enterkeyhint: "enterKeyHint", for: "htmlFor", form: "form", formmethod: "formMethod", formaction: "formAction", formenctype: "formEncType", formnovalidate: "formNoValidate", formtarget: "formTarget", frameborder: "frameBorder", headers: "headers", height: "height", hidden: "hidden", high: "high", href: "href", hreflang: "hrefLang", htmlfor: "htmlFor", httpequiv: "httpEquiv", "http-equiv": "httpEquiv", icon: "icon", id: "id", imagesizes: "imageSizes", imagesrcset: "imageSrcSet", innerhtml: "innerHTML", inputmode: "inputMode", integrity: "integrity", is: "is", itemid: "itemID", itemprop: "itemProp", itemref: "itemRef", itemscope: "itemScope", itemtype: "itemType", keyparams: "keyParams", keytype: "keyType", kind: "kind", label: "label", lang: "lang", list: "list", loop: "loop", low: "low", manifest: "manifest", marginwidth: "marginWidth", marginheight: "marginHeight", max: "max", maxlength: "maxLength", media: "media", mediagroup: "mediaGroup", method: "method", min: "min", minlength: "minLength", multiple: "multiple", muted: "muted", name: "name", nomodule: "noModule", nonce: "nonce", novalidate: "noValidate", open: "open", optimum: "optimum", pattern: "pattern", placeholder: "placeholder", playsinline: "playsInline", poster: "poster", preload: "preload", profile: "profile", radiogroup: "radioGroup", readonly: "readOnly", referrerpolicy: "referrerPolicy", rel: "rel", required: "required", reversed: "reversed", role: "role", rows: "rows", rowspan: "rowSpan", sandbox: "sandbox", scope: "scope", scoped: "scoped", scrolling: "scrolling", seamless: "seamless", selected: "selected", shape: "shape", size: "size", sizes: "sizes", span: "span", spellcheck: "spellCheck", src: "src", srcdoc: "srcDoc", srclang: "srcLang", srcset: "srcSet", start: "start", step: "step", style: "style", summary: "summary", tabindex: "tabIndex", target: "target", title: "title", type: "type", usemap: "useMap", value: "value", width: "width", wmode: "wmode", wrap: "wrap", about: "about", accentheight: "accentHeight", "accent-height": "accentHeight", accumulate: "accumulate", additive: "additive", alignmentbaseline: "alignmentBaseline", "alignment-baseline": "alignmentBaseline", allowreorder: "allowReorder", alphabetic: "alphabetic", amplitude: "amplitude", arabicform: "arabicForm", "arabic-form": "arabicForm", ascent: "ascent", attributename: "attributeName", attributetype: "attributeType", autoreverse: "autoReverse", azimuth: "azimuth", basefrequency: "baseFrequency", baselineshift: "baselineShift", "baseline-shift": "baselineShift", baseprofile: "baseProfile", bbox: "bbox", begin: "begin", bias: "bias", by: "by", calcmode: "calcMode", capheight: "capHeight", "cap-height": "capHeight", clip: "clip", clippath: "clipPath", "clip-path": "clipPath", clippathunits: "clipPathUnits", cliprule: "clipRule", "clip-rule": "clipRule", color: "color", colorinterpolation: "colorInterpolation", "color-interpolation": "colorInterpolation", colorinterpolationfilters: "colorInterpolationFilters", "color-interpolation-filters": "colorInterpolationFilters", colorprofile: "colorProfile", "color-profile": "colorProfile", colorrendering: "colorRendering", "color-rendering": "colorRendering", contentscripttype: "contentScriptType", contentstyletype: "contentStyleType", cursor: "cursor", cx: "cx", cy: "cy", d: "d", datatype: "datatype", decelerate: "decelerate", descent: "descent", diffuseconstant: "diffuseConstant", direction: "direction", display: "display", divisor: "divisor", dominantbaseline: "dominantBaseline", "dominant-baseline": "dominantBaseline", dur: "dur", dx: "dx", dy: "dy", edgemode: "edgeMode", elevation: "elevation", enablebackground: "enableBackground", "enable-background": "enableBackground", end: "end", exponent: "exponent", externalresourcesrequired: "externalResourcesRequired", fill: "fill", fillopacity: "fillOpacity", "fill-opacity": "fillOpacity", fillrule: "fillRule", "fill-rule": "fillRule", filter: "filter", filterres: "filterRes", filterunits: "filterUnits", floodopacity: "floodOpacity", "flood-opacity": "floodOpacity", floodcolor: "floodColor", "flood-color": "floodColor", focusable: "focusable", fontfamily: "fontFamily", "font-family": "fontFamily", fontsize: "fontSize", "font-size": "fontSize", fontsizeadjust: "fontSizeAdjust", "font-size-adjust": "fontSizeAdjust", fontstretch: "fontStretch", "font-stretch": "fontStretch", fontstyle: "fontStyle", "font-style": "fontStyle", fontvariant: "fontVariant", "font-variant": "fontVariant", fontweight: "fontWeight", "font-weight": "fontWeight", format: "format", from: "from", fx: "fx", fy: "fy", g1: "g1", g2: "g2", glyphname: "glyphName", "glyph-name": "glyphName", glyphorientationhorizontal: "glyphOrientationHorizontal", "glyph-orientation-horizontal": "glyphOrientationHorizontal", glyphorientationvertical: "glyphOrientationVertical", "glyph-orientation-vertical": "glyphOrientationVertical", glyphref: "glyphRef", gradienttransform: "gradientTransform", gradientunits: "gradientUnits", hanging: "hanging", horizadvx: "horizAdvX", "horiz-adv-x": "horizAdvX", horizoriginx: "horizOriginX", "horiz-origin-x": "horizOriginX", ideographic: "ideographic", imagerendering: "imageRendering", "image-rendering": "imageRendering", in2: "in2", in: "in", inlist: "inlist", intercept: "intercept", k1: "k1", k2: "k2", k3: "k3", k4: "k4", k: "k", kernelmatrix: "kernelMatrix", kernelunitlength: "kernelUnitLength", kerning: "kerning", keypoints: "keyPoints", keysplines: "keySplines", keytimes: "keyTimes", lengthadjust: "lengthAdjust", letterspacing: "letterSpacing", "letter-spacing": "letterSpacing", lightingcolor: "lightingColor", "lighting-color": "lightingColor", limitingconeangle: "limitingConeAngle", local: "local", markerend: "markerEnd", "marker-end": "markerEnd", markerheight: "markerHeight", markermid: "markerMid", "marker-mid": "markerMid", markerstart: "markerStart", "marker-start": "markerStart", markerunits: "markerUnits", markerwidth: "markerWidth", mask: "mask", maskcontentunits: "maskContentUnits", maskunits: "maskUnits", mathematical: "mathematical", mode: "mode", numoctaves: "numOctaves", offset: "offset", opacity: "opacity", operator: "operator", order: "order", orient: "orient", orientation: "orientation", origin: "origin", overflow: "overflow", overlineposition: "overlinePosition", "overline-position": "overlinePosition", overlinethickness: "overlineThickness", "overline-thickness": "overlineThickness", paintorder: "paintOrder", "paint-order": "paintOrder", panose1: "panose1", "panose-1": "panose1", pathlength: "pathLength", patterncontentunits: "patternContentUnits", patterntransform: "patternTransform", patternunits: "patternUnits", pointerevents: "pointerEvents", "pointer-events": "pointerEvents", points: "points", pointsatx: "pointsAtX", pointsaty: "pointsAtY", pointsatz: "pointsAtZ", prefix: "prefix", preservealpha: "preserveAlpha", preserveaspectratio: "preserveAspectRatio", primitiveunits: "primitiveUnits", property: "property", r: "r", radius: "radius", refx: "refX", refy: "refY", renderingintent: "renderingIntent", "rendering-intent": "renderingIntent", repeatcount: "repeatCount", repeatdur: "repeatDur", requiredextensions: "requiredExtensions", requiredfeatures: "requiredFeatures", resource: "resource", restart: "restart", result: "result", results: "results", rotate: "rotate", rx: "rx", ry: "ry", scale: "scale", security: "security", seed: "seed", shaperendering: "shapeRendering", "shape-rendering": "shapeRendering", slope: "slope", spacing: "spacing", specularconstant: "specularConstant", specularexponent: "specularExponent", speed: "speed", spreadmethod: "spreadMethod", startoffset: "startOffset", stddeviation: "stdDeviation", stemh: "stemh", stemv: "stemv", stitchtiles: "stitchTiles", stopcolor: "stopColor", "stop-color": "stopColor", stopopacity: "stopOpacity", "stop-opacity": "stopOpacity", strikethroughposition: "strikethroughPosition", "strikethrough-position": "strikethroughPosition", strikethroughthickness: "strikethroughThickness", "strikethrough-thickness": "strikethroughThickness", string: "string", stroke: "stroke", strokedasharray: "strokeDasharray", "stroke-dasharray": "strokeDasharray", strokedashoffset: "strokeDashoffset", "stroke-dashoffset": "strokeDashoffset", strokelinecap: "strokeLinecap", "stroke-linecap": "strokeLinecap", strokelinejoin: "strokeLinejoin", "stroke-linejoin": "strokeLinejoin", strokemiterlimit: "strokeMiterlimit", "stroke-miterlimit": "strokeMiterlimit", strokewidth: "strokeWidth", "stroke-width": "strokeWidth", strokeopacity: "strokeOpacity", "stroke-opacity": "strokeOpacity", suppresscontenteditablewarning: "suppressContentEditableWarning", suppresshydrationwarning: "suppressHydrationWarning", surfacescale: "surfaceScale", systemlanguage: "systemLanguage", tablevalues: "tableValues", targetx: "targetX", targety: "targetY", textanchor: "textAnchor", "text-anchor": "textAnchor", textdecoration: "textDecoration", "text-decoration": "textDecoration", textlength: "textLength", textrendering: "textRendering", "text-rendering": "textRendering", to: "to", transform: "transform", typeof: "typeof", u1: "u1", u2: "u2", underlineposition: "underlinePosition", "underline-position": "underlinePosition", underlinethickness: "underlineThickness", "underline-thickness": "underlineThickness", unicode: "unicode", unicodebidi: "unicodeBidi", "unicode-bidi": "unicodeBidi", unicoderange: "unicodeRange", "unicode-range": "unicodeRange", unitsperem: "unitsPerEm", "units-per-em": "unitsPerEm", unselectable: "unselectable", valphabetic: "vAlphabetic", "v-alphabetic": "vAlphabetic", values: "values", vectoreffect: "vectorEffect", "vector-effect": "vectorEffect", version: "version", vertadvy: "vertAdvY", "vert-adv-y": "vertAdvY", vertoriginx: "vertOriginX", "vert-origin-x": "vertOriginX", vertoriginy: "vertOriginY", "vert-origin-y": "vertOriginY", vhanging: "vHanging", "v-hanging": "vHanging", videographic: "vIdeographic", "v-ideographic": "vIdeographic", viewbox: "viewBox", viewtarget: "viewTarget", visibility: "visibility", vmathematical: "vMathematical", "v-mathematical": "vMathematical", vocab: "vocab", widths: "widths", wordspacing: "wordSpacing", "word-spacing": "wordSpacing", writingmode: "writingMode", "writing-mode": "writingMode", x1: "x1", x2: "x2", x: "x", xchannelselector: "xChannelSelector", xheight: "xHeight", "x-height": "xHeight", xlinkactuate: "xlinkActuate", "xlink:actuate": "xlinkActuate", xlinkarcrole: "xlinkArcrole", "xlink:arcrole": "xlinkArcrole", xlinkhref: "xlinkHref", "xlink:href": "xlinkHref", xlinkrole: "xlinkRole", "xlink:role": "xlinkRole", xlinkshow: "xlinkShow", "xlink:show": "xlinkShow", xlinktitle: "xlinkTitle", "xlink:title": "xlinkTitle", xlinktype: "xlinkType", "xlink:type": "xlinkType", xmlbase: "xmlBase", "xml:base": "xmlBase", xmllang: "xmlLang", "xml:lang": "xmlLang", xmlns: "xmlns", "xml:space": "xmlSpace", xmlnsxlink: "xmlnsXlink", "xmlns:xlink": "xmlnsXlink", xmlspace: "xmlSpace", y1: "y1", y2: "y2", y: "y", ychannelselector: "yChannelSelector", z: "z", zoomandpan: "zoomAndPan" }, cg = { "aria-current": 0, "aria-description": 0, "aria-details": 0, "aria-disabled": 0, "aria-hidden": 0, "aria-invalid": 0, "aria-keyshortcuts": 0, "aria-label": 0, "aria-roledescription": 0, "aria-autocomplete": 0, "aria-checked": 0, "aria-expanded": 0, "aria-haspopup": 0, "aria-level": 0, "aria-modal": 0, "aria-multiline": 0, "aria-multiselectable": 0, "aria-orientation": 0, "aria-placeholder": 0, "aria-pressed": 0, "aria-readonly": 0, "aria-required": 0, "aria-selected": 0, "aria-sort": 0, "aria-valuemax": 0, "aria-valuemin": 0, "aria-valuenow": 0, "aria-valuetext": 0, "aria-atomic": 0, "aria-busy": 0, "aria-live": 0, "aria-relevant": 0, "aria-dropeffect": 0, "aria-grabbed": 0, "aria-activedescendant": 0, "aria-colcount": 0, "aria-colindex": 0, "aria-colspan": 0, "aria-controls": 0, "aria-describedby": 0, "aria-errormessage": 0, "aria-flowto": 0, "aria-labelledby": 0, "aria-owns": 0, "aria-posinset": 0, "aria-rowcount": 0, "aria-rowindex": 0, "aria-rowspan": 0, "aria-setsize": 0 }, Uu = {}, nb = new RegExp("^(aria)-[" + jn + "]*$"), yp = new RegExp("^(aria)[A-Z][" + jn + "]*$");
    function rb(me, ve) {
      {
        if (Io.call(Uu, ve) && Uu[ve])
          return !0;
        if (yp.test(ve)) {
          var Ie = "aria-" + ve.slice(4).toLowerCase(), Me = cg.hasOwnProperty(Ie) ? Ie : null;
          if (Me == null)
            return xe("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", ve), Uu[ve] = !0, !0;
          if (ve !== Me)
            return xe("Invalid ARIA attribute `%s`. Did you mean `%s`?", ve, Me), Uu[ve] = !0, !0;
        }
        if (nb.test(ve)) {
          var Fe = ve.toLowerCase(), Ze = cg.hasOwnProperty(Fe) ? Fe : null;
          if (Ze == null)
            return Uu[ve] = !0, !1;
          if (ve !== Ze)
            return xe("Unknown ARIA attribute `%s`. Did you mean `%s`?", ve, Ze), Uu[ve] = !0, !0;
        }
      }
      return !0;
    }
    function dg(me, ve) {
      {
        var Ie = [];
        for (var Me in ve) {
          var Fe = rb(me, Me);
          Fe || Ie.push(Me);
        }
        var Ze = Ie.map(function(Xe) {
          return "`" + Xe + "`";
        }).join(", ");
        Ie.length === 1 ? xe("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ze, me) : Ie.length > 1 && xe("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ze, me);
      }
    }
    function fm(me, ve) {
      Ol(me, ve) || dg(me, ve);
    }
    var id = !1;
    function ob(me, ve) {
      {
        if (me !== "input" && me !== "textarea" && me !== "select")
          return;
        ve != null && ve.value === null && !id && (id = !0, me === "select" && ve.multiple ? xe("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", me) : xe("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", me));
      }
    }
    var ab = function() {
    };
    {
      var hi = {}, ib = /^on./, fg = /^on[^A-Z]/, pg = new RegExp("^(aria)-[" + jn + "]*$"), hg = new RegExp("^(aria)[A-Z][" + jn + "]*$");
      ab = function(me, ve, Ie, Me) {
        if (Io.call(hi, ve) && hi[ve])
          return !0;
        var Fe = ve.toLowerCase();
        if (Fe === "onfocusin" || Fe === "onfocusout")
          return xe("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), hi[ve] = !0, !0;
        if (Me != null) {
          var Ze = Me.registrationNameDependencies, Xe = Me.possibleRegistrationNames;
          if (Ze.hasOwnProperty(ve))
            return !0;
          var at = Xe.hasOwnProperty(Fe) ? Xe[Fe] : null;
          if (at != null)
            return xe("Invalid event handler property `%s`. Did you mean `%s`?", ve, at), hi[ve] = !0, !0;
          if (ib.test(ve))
            return xe("Unknown event handler property `%s`. It will be ignored.", ve), hi[ve] = !0, !0;
        } else if (ib.test(ve))
          return fg.test(ve) && xe("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", ve), hi[ve] = !0, !0;
        if (pg.test(ve) || hg.test(ve))
          return !0;
        if (Fe === "innerhtml")
          return xe("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), hi[ve] = !0, !0;
        if (Fe === "aria")
          return xe("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), hi[ve] = !0, !0;
        if (Fe === "is" && Ie !== null && Ie !== void 0 && typeof Ie != "string")
          return xe("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof Ie), hi[ve] = !0, !0;
        if (typeof Ie == "number" && isNaN(Ie))
          return xe("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", ve), hi[ve] = !0, !0;
        var pt = wo(ve), wt = pt !== null && pt.type === Go;
        if (dm.hasOwnProperty(Fe)) {
          var Ct = dm[Fe];
          if (Ct !== ve)
            return xe("Invalid DOM property `%s`. Did you mean `%s`?", ve, Ct), hi[ve] = !0, !0;
        } else if (!wt && ve !== Fe)
          return xe("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", ve, Fe), hi[ve] = !0, !0;
        return typeof Ie == "boolean" && Ar(ve, Ie, pt, !1) ? (Ie ? xe('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', Ie, ve, ve, Ie, ve) : xe('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', Ie, ve, ve, Ie, ve, ve, ve), hi[ve] = !0, !0) : wt ? !0 : Ar(ve, Ie, pt, !1) ? (hi[ve] = !0, !1) : ((Ie === "false" || Ie === "true") && pt !== null && pt.type === Bo && (xe("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", Ie, ve, Ie === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', ve, Ie), hi[ve] = !0), !0);
      };
    }
    var mg = function(me, ve, Ie) {
      {
        var Me = [];
        for (var Fe in ve) {
          var Ze = ab(me, Fe, ve[Fe], Ie);
          Ze || Me.push(Fe);
        }
        var Xe = Me.map(function(at) {
          return "`" + at + "`";
        }).join(", ");
        Me.length === 1 ? xe("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Xe, me) : Me.length > 1 && xe("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Xe, me);
      }
    };
    function yg(me, ve, Ie) {
      Ol(me, ve) || mg(me, ve, Ie);
    }
    var Al = 1, hf = 2, mf = 4, bg = Al | hf | mf, hc = null;
    function bp(me) {
      hc !== null && xe("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), hc = me;
    }
    function p_() {
      hc === null && xe("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), hc = null;
    }
    function vg(me) {
      return me === hc;
    }
    function pm(me) {
      var ve = me.target || me.srcElement || window;
      return ve.correspondingUseElement && (ve = ve.correspondingUseElement), ve.nodeType === kl ? ve.parentNode : ve;
    }
    var Uo = null, mc = null, Cl = null;
    function yf(me) {
      var ve = Bf(me);
      if (ve) {
        if (typeof Uo != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var Ie = ve.stateNode;
        if (Ie) {
          var Me = E0(Ie);
          Uo(ve.stateNode, ve.type, Me);
        }
      }
    }
    function gg(me) {
      Uo = me;
    }
    function hm(me) {
      mc ? Cl ? Cl.push(me) : Cl = [me] : mc = me;
    }
    function gp() {
      return mc !== null || Cl !== null;
    }
    function wp() {
      if (mc) {
        var me = mc, ve = Cl;
        if (mc = null, Cl = null, yf(me), ve)
          for (var Ie = 0; Ie < ve.length; Ie++)
            yf(ve[Ie]);
      }
    }
    var ud = function(me, ve) {
      return me(ve);
    }, sb = function() {
    }, ub = !1;
    function m_() {
      var me = gp();
      me && (sb(), wp());
    }
    function lb(me, ve, Ie) {
      if (ub)
        return me(ve, Ie);
      ub = !0;
      try {
        return ud(me, ve, Ie);
      } finally {
        ub = !1, m_();
      }
    }
    function mm(me, ve, Ie) {
      ud = me, sb = Ie;
    }
    function ym(me) {
      return me === "button" || me === "input" || me === "select" || me === "textarea";
    }
    function cb(me, ve, Ie) {
      switch (me) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(Ie.disabled && ym(ve));
        default:
          return !1;
      }
    }
    function ld(me, ve) {
      var Ie = me.stateNode;
      if (Ie === null)
        return null;
      var Me = E0(Ie);
      if (Me === null)
        return null;
      var Fe = Me[ve];
      if (cb(ve, me.type, Me))
        return null;
      if (Fe && typeof Fe != "function")
        throw new Error("Expected `" + ve + "` listener to be a function, instead got a value of `" + typeof Fe + "` type.");
      return Fe;
    }
    var _p = !1;
    if (so)
      try {
        var bd = {};
        Object.defineProperty(bd, "passive", { get: function() {
          _p = !0;
        } }), window.addEventListener("test", bd, bd), window.removeEventListener("test", bd, bd);
      } catch {
        _p = !1;
      }
    function wg(me, ve, Ie, Me, Fe, Ze, Xe, at, pt) {
      var wt = Array.prototype.slice.call(arguments, 3);
      try {
        ve.apply(Ie, wt);
      } catch (Ct) {
        this.onError(Ct);
      }
    }
    var db = wg;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var fb = document.createElement("react");
      db = function(me, ve, Ie, Me, Fe, Ze, Xe, at, pt) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var wt = document.createEvent("Event"), Ct = !1, Jt = !0, Gt = window.event, pn = Object.getOwnPropertyDescriptor(window, "event");
        function yn() {
          fb.removeEventListener(rn, Kn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Gt);
        }
        var En = Array.prototype.slice.call(arguments, 3);
        function Kn() {
          Ct = !0, yn(), ve.apply(Ie, En), Jt = !1;
        }
        var vr, Or = !1, co = !1;
        function Xr(wn) {
          if (vr = wn.error, Or = !0, vr === null && wn.colno === 0 && wn.lineno === 0 && (co = !0), wn.defaultPrevented && vr != null && typeof vr == "object")
            try {
              vr._suppressLogging = !0;
            } catch {
            }
        }
        var rn = "react-" + (me || "invokeguardedcallback");
        if (window.addEventListener("error", Xr), fb.addEventListener(rn, Kn, !1), wt.initEvent(rn, !1, !1), fb.dispatchEvent(wt), pn && Object.defineProperty(window, "event", pn), Ct && Jt && (Or ? co && (vr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : vr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(vr)), window.removeEventListener("error", Xr), !Ct)
          return yn(), wg.apply(this, arguments);
      };
    }
    var y_ = db, yc = !1, Vu = null, Ep = !1, bc = null, il = { onError: function(me) {
      yc = !0, Vu = me;
    } };
    function wd(me, ve, Ie, Me, Fe, Ze, Xe, at, pt) {
      yc = !1, Vu = null, y_.apply(il, arguments);
    }
    function Rl(me, ve, Ie, Me, Fe, Ze, Xe, at, pt) {
      if (wd.apply(this, arguments), yc) {
        var wt = hb();
        Ep || (Ep = !0, bc = wt);
      }
    }
    function pb() {
      if (Ep) {
        var me = bc;
        throw Ep = !1, bc = null, me;
      }
    }
    function b_() {
      return yc;
    }
    function hb() {
      if (yc) {
        var me = Vu;
        return yc = !1, Vu = null, me;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function lu(me) {
      return me._reactInternals;
    }
    function xp(me) {
      return me._reactInternals !== void 0;
    }
    function bf(me, ve) {
      me._reactInternals = ve;
    }
    var Sr = 0, vc = 1, Ko = 2, qr = 4, ko = 16, Co = 32, sl = 64, Lr = 128, Sa = 256, ws = 512, cu = 1024, sa = 2048, du = 4096, gc = 8192, Sp = 16384, bm = sa | qr | sl | ws | cu | Sp, _g = 32767, Vs = 32768, mi = 65536, Pp = 131072, mb = 1048576, yb = 2097152, _s = 4194304, wc = 8388608, Es = 16777216, _d = 33554432, vf = qr | cu | 0, xs = Ko | qr | ko | Co | ws | du | gc, Wi = qr | sl | ws | gc, fu = sa | ko, xi = _s | wc | yb, Nl = fe.ReactCurrentOwner;
    function Hs(me) {
      var ve = me, Ie = me;
      if (me.alternate)
        for (; ve.return; )
          ve = ve.return;
      else {
        var Me = ve;
        do
          ve = Me, (ve.flags & (Ko | du)) !== Sr && (Ie = ve.return), Me = ve.return;
        while (Me);
      }
      return ve.tag === je ? Ie : null;
    }
    function bb(me) {
      if (me.tag === gt) {
        var ve = me.memoizedState;
        if (ve === null) {
          var Ie = me.alternate;
          Ie !== null && (ve = Ie.memoizedState);
        }
        if (ve !== null)
          return ve.dehydrated;
      }
      return null;
    }
    function vm(me) {
      return me.tag === je ? me.stateNode.containerInfo : null;
    }
    function vb(me) {
      return Hs(me) === me;
    }
    function Ws(me) {
      {
        var ve = Nl.current;
        if (ve !== null && ve.tag === Re) {
          var Ie = ve, Me = Ie.stateNode;
          Me._warnedAboutRefsInRender || xe("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Mr(Ie) || "A component"), Me._warnedAboutRefsInRender = !0;
        }
      }
      var Fe = lu(me);
      return Fe ? Hs(Fe) === Fe : !1;
    }
    function Ss(me) {
      if (Hs(me) !== me)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Xo(me) {
      var ve = me.alternate;
      if (!ve) {
        var Ie = Hs(me);
        if (Ie === null)
          throw new Error("Unable to find node on an unmounted component.");
        return Ie !== me ? null : me;
      }
      for (var Me = me, Fe = ve; ; ) {
        var Ze = Me.return;
        if (Ze === null)
          break;
        var Xe = Ze.alternate;
        if (Xe === null) {
          var at = Ze.return;
          if (at !== null) {
            Me = Fe = at;
            continue;
          }
          break;
        }
        if (Ze.child === Xe.child) {
          for (var pt = Ze.child; pt; ) {
            if (pt === Me)
              return Ss(Ze), me;
            if (pt === Fe)
              return Ss(Ze), ve;
            pt = pt.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (Me.return !== Fe.return)
          Me = Ze, Fe = Xe;
        else {
          for (var wt = !1, Ct = Ze.child; Ct; ) {
            if (Ct === Me) {
              wt = !0, Me = Ze, Fe = Xe;
              break;
            }
            if (Ct === Fe) {
              wt = !0, Fe = Ze, Me = Xe;
              break;
            }
            Ct = Ct.sibling;
          }
          if (!wt) {
            for (Ct = Xe.child; Ct; ) {
              if (Ct === Me) {
                wt = !0, Me = Xe, Fe = Ze;
                break;
              }
              if (Ct === Fe) {
                wt = !0, Fe = Xe, Me = Ze;
                break;
              }
              Ct = Ct.sibling;
            }
            if (!wt)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (Me.alternate !== Fe)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (Me.tag !== je)
        throw new Error("Unable to find node on an unmounted component.");
      return Me.stateNode.current === Me ? me : ve;
    }
    function pu(me) {
      var ve = Xo(me);
      return ve !== null ? gb(ve) : null;
    }
    function gb(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var ve = me.child; ve !== null; ) {
        var Ie = gb(ve);
        if (Ie !== null)
          return Ie;
        ve = ve.sibling;
      }
      return null;
    }
    function Eg(me) {
      var ve = Xo(me);
      return ve !== null ? gm(ve) : null;
    }
    function gm(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var ve = me.child; ve !== null; ) {
        if (ve.tag !== Be) {
          var Ie = gm(ve);
          if (Ie !== null)
            return Ie;
        }
        ve = ve.sibling;
      }
      return null;
    }
    var wm = ae.unstable_scheduleCallback, xg = ae.unstable_cancelCallback, _m = ae.unstable_shouldYield, Sg = ae.unstable_requestPaint, da = ae.unstable_now, wb = ae.unstable_getCurrentPriorityLevel, Em = ae.unstable_ImmediatePriority, qs = ae.unstable_UserBlockingPriority, ul = ae.unstable_NormalPriority, xm = ae.unstable_LowPriority, Pc = ae.unstable_IdlePriority, _b = ae.unstable_yieldValue, Eb = ae.unstable_setDisableYieldValue, kc = null, yi = null, Gn = null, Oa = !1, Si = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function xb(me) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var ve = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (ve.isDisabled)
        return !0;
      if (!ve.supportsFiber)
        return xe("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        vn && (me = Wr({}, me, { getLaneLabelMap: $c, injectProfilingHooks: Dl })), kc = ve.inject(me), yi = ve;
      } catch (Ie) {
        xe("React instrumentation encountered an error: %s.", Ie);
      }
      return !!ve.checkDCE;
    }
    function Pg(me, ve) {
      if (yi && typeof yi.onScheduleFiberRoot == "function")
        try {
          yi.onScheduleFiberRoot(kc, me, ve);
        } catch (Ie) {
          Oa || (Oa = !0, xe("React instrumentation encountered an error: %s", Ie));
        }
    }
    function Ml(me, ve) {
      if (yi && typeof yi.onCommitFiberRoot == "function")
        try {
          var Ie = (me.current.flags & Lr) === Lr;
          if (Fn) {
            var Me;
            switch (ve) {
              case Os:
                Me = Em;
                break;
              case yu:
                Me = qs;
                break;
              case Pi:
                Me = ul;
                break;
              case ty:
                Me = Pc;
                break;
              default:
                Me = ul;
                break;
            }
            yi.onCommitFiberRoot(kc, me, Me, Ie);
          }
        } catch (Fe) {
          Oa || (Oa = !0, xe("React instrumentation encountered an error: %s", Fe));
        }
    }
    function Ac(me) {
      if (yi && typeof yi.onPostCommitFiberRoot == "function")
        try {
          yi.onPostCommitFiberRoot(kc, me);
        } catch (ve) {
          Oa || (Oa = !0, xe("React instrumentation encountered an error: %s", ve));
        }
    }
    function Sb(me) {
      if (yi && typeof yi.onCommitFiberUnmount == "function")
        try {
          yi.onCommitFiberUnmount(kc, me);
        } catch (ve) {
          Oa || (Oa = !0, xe("React instrumentation encountered an error: %s", ve));
        }
    }
    function Xa(me) {
      if (typeof _b == "function" && (Eb(me), we(me)), yi && typeof yi.setStrictMode == "function")
        try {
          yi.setStrictMode(kc, me);
        } catch (ve) {
          Oa || (Oa = !0, xe("React instrumentation encountered an error: %s", ve));
        }
    }
    function Dl(me) {
      Gn = me;
    }
    function $c() {
      {
        for (var me = /* @__PURE__ */ new Map(), ve = 1, Ie = 0; Ie < Jo; Ie++) {
          var Me = v_(ve);
          me.set(ve, Me), ve *= 2;
        }
        return me;
      }
    }
    function Sm(me) {
      Gn !== null && typeof Gn.markCommitStarted == "function" && Gn.markCommitStarted(me);
    }
    function Pb() {
      Gn !== null && typeof Gn.markCommitStopped == "function" && Gn.markCommitStopped();
    }
    function Ic(me) {
      Gn !== null && typeof Gn.markComponentRenderStarted == "function" && Gn.markComponentRenderStarted(me);
    }
    function Ed() {
      Gn !== null && typeof Gn.markComponentRenderStopped == "function" && Gn.markComponentRenderStopped();
    }
    function Tg(me) {
      Gn !== null && typeof Gn.markComponentPassiveEffectMountStarted == "function" && Gn.markComponentPassiveEffectMountStarted(me);
    }
    function Tb() {
      Gn !== null && typeof Gn.markComponentPassiveEffectMountStopped == "function" && Gn.markComponentPassiveEffectMountStopped();
    }
    function Pm(me) {
      Gn !== null && typeof Gn.markComponentPassiveEffectUnmountStarted == "function" && Gn.markComponentPassiveEffectUnmountStarted(me);
    }
    function kg() {
      Gn !== null && typeof Gn.markComponentPassiveEffectUnmountStopped == "function" && Gn.markComponentPassiveEffectUnmountStopped();
    }
    function Og(me) {
      Gn !== null && typeof Gn.markComponentLayoutEffectMountStarted == "function" && Gn.markComponentLayoutEffectMountStarted(me);
    }
    function Ag() {
      Gn !== null && typeof Gn.markComponentLayoutEffectMountStopped == "function" && Gn.markComponentLayoutEffectMountStopped();
    }
    function Tm(me) {
      Gn !== null && typeof Gn.markComponentLayoutEffectUnmountStarted == "function" && Gn.markComponentLayoutEffectUnmountStarted(me);
    }
    function gf() {
      Gn !== null && typeof Gn.markComponentLayoutEffectUnmountStopped == "function" && Gn.markComponentLayoutEffectUnmountStopped();
    }
    function km(me, ve, Ie) {
      Gn !== null && typeof Gn.markComponentErrored == "function" && Gn.markComponentErrored(me, ve, Ie);
    }
    function Cg(me, ve, Ie) {
      Gn !== null && typeof Gn.markComponentSuspended == "function" && Gn.markComponentSuspended(me, ve, Ie);
    }
    function $g(me) {
      Gn !== null && typeof Gn.markLayoutEffectsStarted == "function" && Gn.markLayoutEffectsStarted(me);
    }
    function wf() {
      Gn !== null && typeof Gn.markLayoutEffectsStopped == "function" && Gn.markLayoutEffectsStopped();
    }
    function Ig(me) {
      Gn !== null && typeof Gn.markPassiveEffectsStarted == "function" && Gn.markPassiveEffectsStarted(me);
    }
    function Tp() {
      Gn !== null && typeof Gn.markPassiveEffectsStopped == "function" && Gn.markPassiveEffectsStopped();
    }
    function Hu(me) {
      Gn !== null && typeof Gn.markRenderStarted == "function" && Gn.markRenderStarted(me);
    }
    function kp() {
      Gn !== null && typeof Gn.markRenderYielded == "function" && Gn.markRenderYielded();
    }
    function _f() {
      Gn !== null && typeof Gn.markRenderStopped == "function" && Gn.markRenderStopped();
    }
    function xd(me) {
      Gn !== null && typeof Gn.markRenderScheduled == "function" && Gn.markRenderScheduled(me);
    }
    function kb(me, ve) {
      Gn !== null && typeof Gn.markForceUpdateScheduled == "function" && Gn.markForceUpdateScheduled(me, ve);
    }
    function Nc(me, ve) {
      Gn !== null && typeof Gn.markStateUpdateScheduled == "function" && Gn.markStateUpdateScheduled(me, ve);
    }
    var Tr = 0, oo = 1, Rr = 2, fa = 8, hu = 16, Om = Math.clz32 ? Math.clz32 : Pd, Am = Math.log, Ob = Math.LN2;
    function Pd(me) {
      var ve = me >>> 0;
      return ve === 0 ? 32 : 31 - (Am(ve) / Ob | 0) | 0;
    }
    var Jo = 31, xn = 0, yo = 0, Nr = 1, ll = 2, Zs = 4, Td = 8, ea = 16, Od = 32, Mc = 4194240, Ad = 64, mu = 128, Ps = 256, Cd = 512, Ap = 1024, Cp = 2048, Cm = 4096, $m = 8192, Im = 16384, Rm = 32768, Nm = 65536, Mm = 131072, jm = 262144, Dm = 524288, $d = 1048576, Lm = 2097152, Id = 130023424, Bl = 4194304, Fm = 8388608, $p = 16777216, Bm = 33554432, zm = 67108864, Ab = Bl, Ef = 134217728, Um = 268435455, xf = 268435456, jc = 536870912, Ts = 1073741824;
    function v_(me) {
      {
        if (me & Nr)
          return "Sync";
        if (me & ll)
          return "InputContinuousHydration";
        if (me & Zs)
          return "InputContinuous";
        if (me & Td)
          return "DefaultHydration";
        if (me & ea)
          return "Default";
        if (me & Od)
          return "TransitionHydration";
        if (me & Mc)
          return "Transition";
        if (me & Id)
          return "Retry";
        if (me & Ef)
          return "SelectiveHydration";
        if (me & xf)
          return "IdleHydration";
        if (me & jc)
          return "Idle";
        if (me & Ts)
          return "Offscreen";
      }
    }
    var Vo = -1, Vm = Ad, Hm = Bl;
    function Sf(me) {
      switch (za(me)) {
        case Nr:
          return Nr;
        case ll:
          return ll;
        case Zs:
          return Zs;
        case Td:
          return Td;
        case ea:
          return ea;
        case Od:
          return Od;
        case Ad:
        case mu:
        case Ps:
        case Cd:
        case Ap:
        case Cp:
        case Cm:
        case $m:
        case Im:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case Dm:
        case $d:
        case Lm:
          return me & Mc;
        case Bl:
        case Fm:
        case $p:
        case Bm:
        case zm:
          return me & Id;
        case Ef:
          return Ef;
        case xf:
          return xf;
        case jc:
          return jc;
        case Ts:
          return Ts;
        default:
          return xe("Should have found matching lanes. This is a bug in React."), me;
      }
    }
    function Ip(me, ve) {
      var Ie = me.pendingLanes;
      if (Ie === xn)
        return xn;
      var Me = xn, Fe = me.suspendedLanes, Ze = me.pingedLanes, Xe = Ie & Um;
      if (Xe !== xn) {
        var at = Xe & ~Fe;
        if (at !== xn)
          Me = Sf(at);
        else {
          var pt = Xe & Ze;
          pt !== xn && (Me = Sf(pt));
        }
      } else {
        var wt = Ie & ~Fe;
        wt !== xn ? Me = Sf(wt) : Ze !== xn && (Me = Sf(Ze));
      }
      if (Me === xn)
        return xn;
      if (ve !== xn && ve !== Me && (ve & Fe) === xn) {
        var Ct = za(Me), Jt = za(ve);
        if (Ct >= Jt || Ct === ea && (Jt & Mc) !== xn)
          return ve;
      }
      (Me & Zs) !== xn && (Me |= Ie & ea);
      var Gt = me.entangledLanes;
      if (Gt !== xn)
        for (var pn = me.entanglements, yn = Me & Gt; yn > 0; ) {
          var En = Dc(yn), Kn = 1 << En;
          Me |= pn[En], yn &= ~Kn;
        }
      return Me;
    }
    function Rg(me, ve) {
      for (var Ie = me.eventTimes, Me = Vo; ve > 0; ) {
        var Fe = Dc(ve), Ze = 1 << Fe, Xe = Ie[Fe];
        Xe > Me && (Me = Xe), ve &= ~Ze;
      }
      return Me;
    }
    function Wm(me, ve) {
      switch (me) {
        case Nr:
        case ll:
        case Zs:
          return ve + 250;
        case Td:
        case ea:
        case Od:
        case Ad:
        case mu:
        case Ps:
        case Cd:
        case Ap:
        case Cp:
        case Cm:
        case $m:
        case Im:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case Dm:
        case $d:
        case Lm:
          return ve + 5e3;
        case Bl:
        case Fm:
        case $p:
        case Bm:
        case zm:
          return Vo;
        case Ef:
        case xf:
        case jc:
        case Ts:
          return Vo;
        default:
          return xe("Should have found matching lanes. This is a bug in React."), Vo;
      }
    }
    function g_(me, ve) {
      for (var Ie = me.pendingLanes, Me = me.suspendedLanes, Fe = me.pingedLanes, Ze = me.expirationTimes, Xe = Ie; Xe > 0; ) {
        var at = Dc(Xe), pt = 1 << at, wt = Ze[at];
        wt === Vo ? ((pt & Me) === xn || (pt & Fe) !== xn) && (Ze[at] = Wm(pt, ve)) : wt <= ve && (me.expiredLanes |= pt), Xe &= ~pt;
      }
    }
    function w_(me) {
      return Sf(me.pendingLanes);
    }
    function Cb(me) {
      var ve = me.pendingLanes & ~Ts;
      return ve !== xn ? ve : ve & Ts ? Ts : xn;
    }
    function Pf(me) {
      return (me & Nr) !== xn;
    }
    function Rp(me) {
      return (me & Um) !== xn;
    }
    function qm(me) {
      return (me & Id) === me;
    }
    function __(me) {
      var ve = Nr | Zs | ea;
      return (me & ve) === xn;
    }
    function Ng(me) {
      return (me & Mc) === me;
    }
    function Np(me, ve) {
      var Ie = ll | Zs | Td | ea;
      return (ve & Ie) !== xn;
    }
    function Mg(me, ve) {
      return (ve & me.expiredLanes) !== xn;
    }
    function $b(me) {
      return (me & Mc) !== xn;
    }
    function Ib() {
      var me = Vm;
      return Vm <<= 1, (Vm & Mc) === xn && (Vm = Ad), me;
    }
    function E_() {
      var me = Hm;
      return Hm <<= 1, (Hm & Id) === xn && (Hm = Bl), me;
    }
    function za(me) {
      return me & -me;
    }
    function ei(me) {
      return za(me);
    }
    function Dc(me) {
      return 31 - Om(me);
    }
    function Gm(me) {
      return Dc(me);
    }
    function ks(me, ve) {
      return (me & ve) !== xn;
    }
    function Rd(me, ve) {
      return (me & ve) === ve;
    }
    function Zr(me, ve) {
      return me | ve;
    }
    function Tf(me, ve) {
      return me & ~ve;
    }
    function Rb(me, ve) {
      return me & ve;
    }
    function Nb(me, ve) {
      return me !== yo && me < ve ? me : ve;
    }
    function Ym(me) {
      for (var ve = [], Ie = 0; Ie < Jo; Ie++)
        ve.push(me);
      return ve;
    }
    function kf(me, ve, Ie) {
      me.pendingLanes |= ve, ve !== jc && (me.suspendedLanes = xn, me.pingedLanes = xn);
      var Me = me.eventTimes, Fe = Gm(ve);
      Me[Fe] = Ie;
    }
    function Mb(me, ve) {
      me.suspendedLanes |= ve, me.pingedLanes &= ~ve;
      for (var Ie = me.expirationTimes, Me = ve; Me > 0; ) {
        var Fe = Dc(Me), Ze = 1 << Fe;
        Ie[Fe] = Vo, Me &= ~Ze;
      }
    }
    function Qm(me, ve, Ie) {
      me.pingedLanes |= me.suspendedLanes & ve;
    }
    function jg(me, ve) {
      var Ie = me.pendingLanes & ~ve;
      me.pendingLanes = ve, me.suspendedLanes = xn, me.pingedLanes = xn, me.expiredLanes &= ve, me.mutableReadLanes &= ve, me.entangledLanes &= ve;
      for (var Me = me.entanglements, Fe = me.eventTimes, Ze = me.expirationTimes, Xe = Ie; Xe > 0; ) {
        var at = Dc(Xe), pt = 1 << at;
        Me[at] = xn, Fe[at] = Vo, Ze[at] = Vo, Xe &= ~pt;
      }
    }
    function Mp(me, ve) {
      for (var Ie = me.entangledLanes |= ve, Me = me.entanglements, Fe = Ie; Fe; ) {
        var Ze = Dc(Fe), Xe = 1 << Ze;
        Xe & ve | Me[Ze] & ve && (Me[Ze] |= ve), Fe &= ~Xe;
      }
    }
    function Km(me, ve) {
      var Ie = za(ve), Me;
      switch (Ie) {
        case Zs:
          Me = ll;
          break;
        case ea:
          Me = Td;
          break;
        case Ad:
        case mu:
        case Ps:
        case Cd:
        case Ap:
        case Cp:
        case Cm:
        case $m:
        case Im:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case Dm:
        case $d:
        case Lm:
        case Bl:
        case Fm:
        case $p:
        case Bm:
        case zm:
          Me = Od;
          break;
        case jc:
          Me = xf;
          break;
        default:
          Me = yo;
          break;
      }
      return (Me & (me.suspendedLanes | ve)) !== yo ? yo : Me;
    }
    function Dg(me, ve, Ie) {
      if (Si)
        for (var Me = me.pendingUpdatersLaneMap; Ie > 0; ) {
          var Fe = Gm(Ie), Ze = 1 << Fe, Xe = Me[Fe];
          Xe.add(ve), Ie &= ~Ze;
        }
    }
    function jb(me, ve) {
      if (Si)
        for (var Ie = me.pendingUpdatersLaneMap, Me = me.memoizedUpdaters; ve > 0; ) {
          var Fe = Gm(ve), Ze = 1 << Fe, Xe = Ie[Fe];
          Xe.size > 0 && (Xe.forEach(function(at) {
            var pt = at.alternate;
            (pt === null || !Me.has(pt)) && Me.add(at);
          }), Xe.clear()), ve &= ~Ze;
        }
    }
    function ey(me, ve) {
      return null;
    }
    var Os = Nr, yu = Zs, Pi = ea, ty = jc, Of = yo;
    function Gs() {
      return Of;
    }
    function ti(me) {
      Of = me;
    }
    function Lg(me, ve) {
      var Ie = Of;
      try {
        return Of = me, ve();
      } finally {
        Of = Ie;
      }
    }
    function jp(me, ve) {
      return me !== 0 && me < ve ? me : ve;
    }
    function qi(me, ve) {
      return me === 0 || me > ve ? me : ve;
    }
    function Db(me, ve) {
      return me !== 0 && me < ve;
    }
    function Fg(me) {
      var ve = za(me);
      return Db(Os, ve) ? Db(yu, ve) ? Rp(ve) ? Pi : ty : yu : Os;
    }
    function Nd(me) {
      var ve = me.current.memoizedState;
      return ve.isDehydrated;
    }
    var Ci;
    function x_(me) {
      Ci = me;
    }
    function sr(me) {
      Ci(me);
    }
    var Lc;
    function Bg(me) {
      Lc = me;
    }
    var Lb;
    function S_(me) {
      Lb = me;
    }
    var Af;
    function ny(me) {
      Af = me;
    }
    var ry;
    function zg(me) {
      ry = me;
    }
    var oy = !1, Dp = [], cl = null, dl = null, ua = null, ns = /* @__PURE__ */ new Map(), bu = /* @__PURE__ */ new Map(), Vl = [], Ug = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset", "submit"];
    function Wu(me) {
      return Ug.indexOf(me) > -1;
    }
    function Vg(me, ve, Ie, Me, Fe) {
      return { blockedOn: me, domEventName: ve, eventSystemFlags: Ie, nativeEvent: Fe, targetContainers: [Me] };
    }
    function qu(me, ve) {
      switch (me) {
        case "focusin":
        case "focusout":
          cl = null;
          break;
        case "dragenter":
        case "dragleave":
          dl = null;
          break;
        case "mouseover":
        case "mouseout":
          ua = null;
          break;
        case "pointerover":
        case "pointerout": {
          var Ie = ve.pointerId;
          ns.delete(Ie);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var Me = ve.pointerId;
          bu.delete(Me);
          break;
        }
      }
    }
    function Lp(me, ve, Ie, Me, Fe, Ze) {
      if (me === null || me.nativeEvent !== Ze) {
        var Xe = Vg(ve, Ie, Me, Fe, Ze);
        if (ve !== null) {
          var at = Bf(ve);
          at !== null && Lc(at);
        }
        return Xe;
      }
      me.eventSystemFlags |= Me;
      var pt = me.targetContainers;
      return Fe !== null && pt.indexOf(Fe) === -1 && pt.push(Fe), me;
    }
    function Hg(me, ve, Ie, Me, Fe) {
      switch (ve) {
        case "focusin": {
          var Ze = Fe;
          return cl = Lp(cl, me, ve, Ie, Me, Ze), !0;
        }
        case "dragenter": {
          var Xe = Fe;
          return dl = Lp(dl, me, ve, Ie, Me, Xe), !0;
        }
        case "mouseover": {
          var at = Fe;
          return ua = Lp(ua, me, ve, Ie, Me, at), !0;
        }
        case "pointerover": {
          var pt = Fe, wt = pt.pointerId;
          return ns.set(wt, Lp(ns.get(wt) || null, me, ve, Ie, Me, pt)), !0;
        }
        case "gotpointercapture": {
          var Ct = Fe, Jt = Ct.pointerId;
          return bu.set(Jt, Lp(bu.get(Jt) || null, me, ve, Ie, Me, Ct)), !0;
        }
      }
      return !1;
    }
    function Fb(me) {
      var ve = Xp(me.target);
      if (ve !== null) {
        var Ie = Hs(ve);
        if (Ie !== null) {
          var Me = Ie.tag;
          if (Me === gt) {
            var Fe = bb(Ie);
            if (Fe !== null) {
              me.blockedOn = Fe, ry(me.priority, function() {
                Lb(Ie);
              });
              return;
            }
          } else if (Me === je) {
            var Ze = Ie.stateNode;
            if (Nd(Ze)) {
              me.blockedOn = vm(Ie);
              return;
            }
          }
        }
      }
      me.blockedOn = null;
    }
    function Wg(me) {
      for (var ve = Af(), Ie = { blockedOn: null, target: me, priority: ve }, Me = 0; Me < Vl.length && Db(ve, Vl[Me].priority); Me++)
        ;
      Vl.splice(Me, 0, Ie), Me === 0 && Fb(Ie);
    }
    function Bp(me) {
      if (me.blockedOn !== null)
        return !1;
      for (var ve = me.targetContainers; ve.length > 0; ) {
        var Ie = ve[0], Me = zp(me.domEventName, me.eventSystemFlags, Ie, me.nativeEvent);
        if (Me === null) {
          var Fe = me.nativeEvent, Ze = new Fe.constructor(Fe.type, Fe);
          bp(Ze), Fe.target.dispatchEvent(Ze), p_();
        } else {
          var Xe = Bf(Me);
          return Xe !== null && Lc(Xe), me.blockedOn = Me, !1;
        }
        ve.shift();
      }
      return !0;
    }
    function qg(me, ve, Ie) {
      Bp(me) && Ie.delete(ve);
    }
    function ay() {
      oy = !1, cl !== null && Bp(cl) && (cl = null), dl !== null && Bp(dl) && (dl = null), ua !== null && Bp(ua) && (ua = null), ns.forEach(qg), bu.forEach(qg);
    }
    function Md(me, ve) {
      me.blockedOn === ve && (me.blockedOn = null, oy || (oy = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, ay)));
    }
    function Gi(me) {
      if (Dp.length > 0) {
        Md(Dp[0], me);
        for (var ve = 1; ve < Dp.length; ve++) {
          var Ie = Dp[ve];
          Ie.blockedOn === me && (Ie.blockedOn = null);
        }
      }
      cl !== null && Md(cl, me), dl !== null && Md(dl, me), ua !== null && Md(ua, me);
      var Me = function(at) {
        return Md(at, me);
      };
      ns.forEach(Me), bu.forEach(Me);
      for (var Fe = 0; Fe < Vl.length; Fe++) {
        var Ze = Vl[Fe];
        Ze.blockedOn === me && (Ze.blockedOn = null);
      }
      for (; Vl.length > 0; ) {
        var Xe = Vl[0];
        if (Xe.blockedOn !== null)
          break;
        Fb(Xe), Xe.blockedOn === null && Vl.shift();
      }
    }
    var lo = fe.ReactCurrentBatchConfig, Ua = !0;
    function Aa(me) {
      Ua = !!me;
    }
    function $i() {
      return Ua;
    }
    function Ys(me, ve, Ie) {
      var Me = $f(ve), Fe;
      switch (Me) {
        case Os:
          Fe = Cf;
          break;
        case yu:
          Fe = ni;
          break;
        case Pi:
        default:
          Fe = jd;
          break;
      }
      return Fe.bind(null, ve, Ie, me);
    }
    function Cf(me, ve, Ie, Me) {
      var Fe = Gs(), Ze = lo.transition;
      lo.transition = null;
      try {
        ti(Os), jd(me, ve, Ie, Me);
      } finally {
        ti(Fe), lo.transition = Ze;
      }
    }
    function ni(me, ve, Ie, Me) {
      var Fe = Gs(), Ze = lo.transition;
      lo.transition = null;
      try {
        ti(yu), jd(me, ve, Ie, Me);
      } finally {
        ti(Fe), lo.transition = Ze;
      }
    }
    function jd(me, ve, Ie, Me) {
      Ua && Ld(me, ve, Ie, Me);
    }
    function Ld(me, ve, Ie, Me) {
      var Fe = zp(me, ve, Ie, Me);
      if (Fe === null) {
        U_(me, ve, Me, Fd, Ie), qu(me, Me);
        return;
      }
      if (Hg(Fe, me, ve, Ie, Me)) {
        Me.stopPropagation();
        return;
      }
      if (qu(me, Me), ve & mf && Wu(me)) {
        for (; Fe !== null; ) {
          var Ze = Bf(Fe);
          Ze !== null && sr(Ze);
          var Xe = zp(me, ve, Ie, Me);
          if (Xe === null && U_(me, ve, Me, Fd, Ie), Xe === Fe)
            break;
          Fe = Xe;
        }
        Fe !== null && Me.stopPropagation();
        return;
      }
      U_(me, ve, Me, null, Ie);
    }
    var Fd = null;
    function zp(me, ve, Ie, Me) {
      Fd = null;
      var Fe = pm(Me), Ze = Xp(Fe);
      if (Ze !== null) {
        var Xe = Hs(Ze);
        if (Xe === null)
          Ze = null;
        else {
          var at = Xe.tag;
          if (at === gt) {
            var pt = bb(Xe);
            if (pt !== null)
              return pt;
            Ze = null;
          } else if (at === je) {
            var wt = Xe.stateNode;
            if (Nd(wt))
              return vm(Xe);
            Ze = null;
          } else
            Xe !== Ze && (Ze = null);
        }
      }
      return Fd = Ze, null;
    }
    function $f(me) {
      switch (me) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Os;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return yu;
        case "message": {
          var ve = wb();
          switch (ve) {
            case Em:
              return Os;
            case qs:
              return yu;
            case ul:
            case xm:
              return Pi;
            case Pc:
              return ty;
            default:
              return Pi;
          }
        }
        default:
          return Pi;
      }
    }
    function As(me, ve, Ie) {
      return me.addEventListener(ve, Ie, !1), Ie;
    }
    function Bb(me, ve, Ie) {
      return me.addEventListener(ve, Ie, !0), Ie;
    }
    function If(me, ve, Ie, Me) {
      return me.addEventListener(ve, Ie, { capture: !0, passive: Me }), Ie;
    }
    function Hl(me, ve, Ie, Me) {
      return me.addEventListener(ve, Ie, { passive: Me }), Ie;
    }
    var Fc = null, Up = null, vu = null;
    function iy(me) {
      return Fc = me, Up = Rf(), !0;
    }
    function Bc() {
      Fc = null, Up = null, vu = null;
    }
    function Vp() {
      if (vu)
        return vu;
      var me, ve = Up, Ie = ve.length, Me, Fe = Rf(), Ze = Fe.length;
      for (me = 0; me < Ie && ve[me] === Fe[me]; me++)
        ;
      var Xe = Ie - me;
      for (Me = 1; Me <= Xe && ve[Ie - Me] === Fe[Ze - Me]; Me++)
        ;
      var at = Me > 1 ? 1 - Me : void 0;
      return vu = Fe.slice(me, at), vu;
    }
    function Rf() {
      return "value" in Fc ? Fc.value : Fc.textContent;
    }
    function Nf(me) {
      var ve, Ie = me.keyCode;
      return "charCode" in me ? (ve = me.charCode, ve === 0 && Ie === 13 && (ve = 13)) : ve = Ie, ve === 10 && (ve = 13), ve >= 32 || ve === 13 ? ve : 0;
    }
    function Bd() {
      return !0;
    }
    function Hp() {
      return !1;
    }
    function Ho(me) {
      function ve(Ie, Me, Fe, Ze, Xe) {
        this._reactName = Ie, this._targetInst = Fe, this.type = Me, this.nativeEvent = Ze, this.target = Xe, this.currentTarget = null;
        for (var at in me)
          if (me.hasOwnProperty(at)) {
            var pt = me[at];
            pt ? this[at] = pt(Ze) : this[at] = Ze[at];
          }
        var wt = Ze.defaultPrevented != null ? Ze.defaultPrevented : Ze.returnValue === !1;
        return wt ? this.isDefaultPrevented = Bd : this.isDefaultPrevented = Hp, this.isPropagationStopped = Hp, this;
      }
      return Wr(ve.prototype, { preventDefault: function() {
        this.defaultPrevented = !0;
        var Ie = this.nativeEvent;
        Ie && (Ie.preventDefault ? Ie.preventDefault() : typeof Ie.returnValue != "unknown" && (Ie.returnValue = !1), this.isDefaultPrevented = Bd);
      }, stopPropagation: function() {
        var Ie = this.nativeEvent;
        Ie && (Ie.stopPropagation ? Ie.stopPropagation() : typeof Ie.cancelBubble != "unknown" && (Ie.cancelBubble = !0), this.isPropagationStopped = Bd);
      }, persist: function() {
      }, isPersistent: Bd }), ve;
    }
    var Qs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(me) {
      return me.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, Ks = Ho(Qs), bi = Wr({}, Qs, { view: 0, detail: 0 }), Zg = Ho(bi), Wp, qp, Zp;
    function zc(me) {
      me !== Zp && (Zp && me.type === "mousemove" ? (Wp = me.screenX - Zp.screenX, qp = me.screenY - Zp.screenY) : (Wp = 0, qp = 0), Zp = me);
    }
    var Gp = Wr({}, bi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Hb, button: 0, buttons: 0, relatedTarget: function(me) {
      return me.relatedTarget === void 0 ? me.fromElement === me.srcElement ? me.toElement : me.fromElement : me.relatedTarget;
    }, movementX: function(me) {
      return "movementX" in me ? me.movementX : (zc(me), Wp);
    }, movementY: function(me) {
      return "movementY" in me ? me.movementY : qp;
    } }), sy = Ho(Gp), zd = Wr({}, Gp, { dataTransfer: 0 }), zb = Ho(zd), Ud = Wr({}, bi, { relatedTarget: 0 }), uy = Ho(Ud), Gg = Wr({}, Qs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ub = Ho(Gg), ly = Wr({}, Qs, { clipboardData: function(me) {
      return "clipboardData" in me ? me.clipboardData : window.clipboardData;
    } }), P_ = Ho(ly), T_ = Wr({}, Qs, { data: 0 }), Vb = Ho(T_), Yg = Vb, Vd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, k_ = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
    function Mf(me) {
      if (me.key) {
        var ve = Vd[me.key] || me.key;
        if (ve !== "Unidentified")
          return ve;
      }
      if (me.type === "keypress") {
        var Ie = Nf(me);
        return Ie === 13 ? "Enter" : String.fromCharCode(Ie);
      }
      return me.type === "keydown" || me.type === "keyup" ? k_[me.keyCode] || "Unidentified" : "";
    }
    var Qg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pa(me) {
      var ve = this, Ie = ve.nativeEvent;
      if (Ie.getModifierState)
        return Ie.getModifierState(me);
      var Me = Qg[me];
      return Me ? !!Ie[Me] : !1;
    }
    function Hb(me) {
      return Pa;
    }
    var Kg = Wr({}, bi, { key: Mf, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Hb, charCode: function(me) {
      return me.type === "keypress" ? Nf(me) : 0;
    }, keyCode: function(me) {
      return me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    }, which: function(me) {
      return me.type === "keypress" ? Nf(me) : me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    } }), O_ = Ho(Kg), A_ = Wr({}, Gp, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Wb = Ho(A_), Xg = Wr({}, bi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Hb }), C_ = Ho(Xg), gu = Wr({}, Qs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), qb = Ho(gu), $_ = Wr({}, Gp, { deltaX: function(me) {
      return "deltaX" in me ? me.deltaX : "wheelDeltaX" in me ? -me.wheelDeltaX : 0;
    }, deltaY: function(me) {
      return "deltaY" in me ? me.deltaY : "wheelDeltaY" in me ? -me.wheelDeltaY : "wheelDelta" in me ? -me.wheelDelta : 0;
    }, deltaZ: 0, deltaMode: 0 }), Uc = Ho($_), cy = [9, 13, 27, 32], Vc = 229, jf = so && "CompositionEvent" in window, Hd = null;
    so && "documentMode" in document && (Hd = document.documentMode);
    var Zb = so && "TextEvent" in window && !Hd, Jg = so && (!jf || Hd && Hd > 8 && Hd <= 11), dy = 32, e0 = String.fromCharCode(dy);
    function t0() {
      ao("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ao("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ao("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ao("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Gb = !1;
    function fy(me) {
      return (me.ctrlKey || me.altKey || me.metaKey) && !(me.ctrlKey && me.altKey);
    }
    function py(me) {
      switch (me) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function n0(me, ve) {
      return me === "keydown" && ve.keyCode === Vc;
    }
    function hy(me, ve) {
      switch (me) {
        case "keyup":
          return cy.indexOf(ve.keyCode) !== -1;
        case "keydown":
          return ve.keyCode !== Vc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function r0(me) {
      var ve = me.detail;
      return typeof ve == "object" && "data" in ve ? ve.data : null;
    }
    function Yb(me) {
      return me.locale === "ko";
    }
    var Hc = !1;
    function my(me, ve, Ie, Me, Fe) {
      var Ze, Xe;
      if (jf ? Ze = py(ve) : Hc ? hy(ve, Me) && (Ze = "onCompositionEnd") : n0(ve, Me) && (Ze = "onCompositionStart"), !Ze)
        return null;
      Jg && !Yb(Me) && (!Hc && Ze === "onCompositionStart" ? Hc = iy(Fe) : Ze === "onCompositionEnd" && Hc && (Xe = Vp()));
      var at = l0(Ie, Ze);
      if (at.length > 0) {
        var pt = new Vb(Ze, ve, null, Me, Fe);
        if (me.push({ event: pt, listeners: at }), Xe)
          pt.data = Xe;
        else {
          var wt = r0(Me);
          wt !== null && (pt.data = wt);
        }
      }
    }
    function Qb(me, ve) {
      switch (me) {
        case "compositionend":
          return r0(ve);
        case "keypress":
          var Ie = ve.which;
          return Ie !== dy ? null : (Gb = !0, e0);
        case "textInput":
          var Me = ve.data;
          return Me === e0 && Gb ? null : Me;
        default:
          return null;
      }
    }
    function yy(me, ve) {
      if (Hc) {
        if (me === "compositionend" || !jf && hy(me, ve)) {
          var Ie = Vp();
          return Bc(), Hc = !1, Ie;
        }
        return null;
      }
      switch (me) {
        case "paste":
          return null;
        case "keypress":
          if (!fy(ve)) {
            if (ve.char && ve.char.length > 1)
              return ve.char;
            if (ve.which)
              return String.fromCharCode(ve.which);
          }
          return null;
        case "compositionend":
          return Jg && !Yb(ve) ? null : ve.data;
        default:
          return null;
      }
    }
    function o0(me, ve, Ie, Me, Fe) {
      var Ze;
      if (Zb ? Ze = Qb(ve, Me) : Ze = yy(ve, Me), !Ze)
        return null;
      var Xe = l0(Ie, "onBeforeInput");
      if (Xe.length > 0) {
        var at = new Yg("onBeforeInput", "beforeinput", null, Me, Fe);
        me.push({ event: at, listeners: Xe }), at.data = Ze;
      }
    }
    function I_(me, ve, Ie, Me, Fe, Ze, Xe) {
      my(me, ve, Ie, Me, Fe), o0(me, ve, Ie, Me, Fe);
    }
    var by = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
    function a0(me) {
      var ve = me && me.nodeName && me.nodeName.toLowerCase();
      return ve === "input" ? !!by[me.type] : ve === "textarea";
    }
    function Yp(me) {
      if (!so)
        return !1;
      var ve = "on" + me, Ie = ve in document;
      if (!Ie) {
        var Me = document.createElement("div");
        Me.setAttribute(ve, "return;"), Ie = typeof Me[ve] == "function";
      }
      return Ie;
    }
    function R_() {
      ao("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Df(me, ve, Ie, Me) {
      hm(Me);
      var Fe = l0(ve, "onChange");
      if (Fe.length > 0) {
        var Ze = new Ks("onChange", "change", null, Ie, Me);
        me.push({ event: Ze, listeners: Fe });
      }
    }
    var Se = null, Ce = null;
    function De(me) {
      var ve = me.nodeName && me.nodeName.toLowerCase();
      return ve === "select" || ve === "input" && me.type === "file";
    }
    function Ue(me) {
      var ve = [];
      Df(ve, Ce, me, pm(me)), lb(Qe, ve);
    }
    function Qe(me) {
      dS(me, 0);
    }
    function et(me) {
      var ve = xy(me);
      if (au(ve))
        return me;
    }
    function bt(me, ve) {
      if (me === "change")
        return ve;
    }
    var It = !1;
    so && (It = Yp("input") && (!document.documentMode || document.documentMode > 9));
    function Ut(me, ve) {
      Se = me, Ce = ve, Se.attachEvent("onpropertychange", Rn);
    }
    function bn() {
      Se && (Se.detachEvent("onpropertychange", Rn), Se = null, Ce = null);
    }
    function Rn(me) {
      me.propertyName === "value" && et(Ce) && Ue(me);
    }
    function Ln(me, ve, Ie) {
      me === "focusin" ? (bn(), Ut(ve, Ie)) : me === "focusout" && bn();
    }
    function Nn(me, ve) {
      if (me === "selectionchange" || me === "keyup" || me === "keydown")
        return et(Ce);
    }
    function er(me) {
      var ve = me.nodeName;
      return ve && ve.toLowerCase() === "input" && (me.type === "checkbox" || me.type === "radio");
    }
    function lr(me, ve) {
      if (me === "click")
        return et(ve);
    }
    function fr(me, ve) {
      if (me === "input" || me === "change")
        return et(ve);
    }
    function Ca(me) {
      var ve = me._wrapperState;
      !ve || !ve.controlled || me.type !== "number" || Zn(me, "number", me.value);
    }
    function nn(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at = Ie ? xy(Ie) : window, pt, wt;
      if (De(at) ? pt = bt : a0(at) ? It ? pt = fr : (pt = Nn, wt = Ln) : er(at) && (pt = lr), pt) {
        var Ct = pt(ve, Ie);
        if (Ct) {
          Df(me, Ct, Me, Fe);
          return;
        }
      }
      wt && wt(ve, at, Ie), ve === "focusout" && Ca(at);
    }
    function Qt() {
      Yr("onMouseEnter", ["mouseout", "mouseover"]), Yr("onMouseLeave", ["mouseout", "mouseover"]), Yr("onPointerEnter", ["pointerout", "pointerover"]), Yr("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function un(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at = ve === "mouseover" || ve === "pointerover", pt = ve === "mouseout" || ve === "pointerout";
      if (at && !vg(Me)) {
        var wt = Me.relatedTarget || Me.fromElement;
        if (wt && (Xp(wt) || cv(wt)))
          return;
      }
      if (!(!pt && !at)) {
        var Ct;
        if (Fe.window === Fe)
          Ct = Fe;
        else {
          var Jt = Fe.ownerDocument;
          Jt ? Ct = Jt.defaultView || Jt.parentWindow : Ct = window;
        }
        var Gt, pn;
        if (pt) {
          var yn = Me.relatedTarget || Me.toElement;
          if (Gt = Ie, pn = yn ? Xp(yn) : null, pn !== null) {
            var En = Hs(pn);
            (pn !== En || pn.tag !== ze && pn.tag !== He) && (pn = null);
          }
        } else
          Gt = null, pn = Ie;
        if (Gt !== pn) {
          var Kn = sy, vr = "onMouseLeave", Or = "onMouseEnter", co = "mouse";
          (ve === "pointerout" || ve === "pointerover") && (Kn = Wb, vr = "onPointerLeave", Or = "onPointerEnter", co = "pointer");
          var Xr = Gt == null ? Ct : xy(Gt), rn = pn == null ? Ct : xy(pn), wn = new Kn(vr, co + "leave", Gt, Me, Fe);
          wn.target = Xr, wn.relatedTarget = rn;
          var an = null, Bn = Xp(Fe);
          if (Bn === Ie) {
            var nr = new Kn(Or, co + "enter", pn, Me, Fe);
            nr.target = rn, nr.relatedTarget = Xr, an = nr;
          }
          kO(me, wn, an, Gt, pn);
        }
      }
    }
    function Vn(me, ve) {
      return me === ve && (me !== 0 || 1 / me === 1 / ve) || me !== me && ve !== ve;
    }
    var Jn = typeof Object.is == "function" ? Object.is : Vn;
    function xr(me, ve) {
      if (Jn(me, ve))
        return !0;
      if (typeof me != "object" || me === null || typeof ve != "object" || ve === null)
        return !1;
      var Ie = Object.keys(me), Me = Object.keys(ve);
      if (Ie.length !== Me.length)
        return !1;
      for (var Fe = 0; Fe < Ie.length; Fe++) {
        var Ze = Ie[Fe];
        if (!Io.call(ve, Ze) || !Jn(me[Ze], ve[Ze]))
          return !1;
      }
      return !0;
    }
    function kr(me) {
      for (; me && me.firstChild; )
        me = me.firstChild;
      return me;
    }
    function Fr(me) {
      for (; me; ) {
        if (me.nextSibling)
          return me.nextSibling;
        me = me.parentNode;
      }
    }
    function ri(me, ve) {
      for (var Ie = kr(me), Me = 0, Fe = 0; Ie; ) {
        if (Ie.nodeType === kl) {
          if (Fe = Me + Ie.textContent.length, Me <= ve && Fe >= ve)
            return { node: Ie, offset: ve - Me };
          Me = Fe;
        }
        Ie = kr(Fr(Ie));
      }
    }
    function Eo(me) {
      var ve = me.ownerDocument, Ie = ve && ve.defaultView || window, Me = Ie.getSelection && Ie.getSelection();
      if (!Me || Me.rangeCount === 0)
        return null;
      var Fe = Me.anchorNode, Ze = Me.anchorOffset, Xe = Me.focusNode, at = Me.focusOffset;
      try {
        Fe.nodeType, Xe.nodeType;
      } catch {
        return null;
      }
      return Wc(me, Fe, Ze, Xe, at);
    }
    function Wc(me, ve, Ie, Me, Fe) {
      var Ze = 0, Xe = -1, at = -1, pt = 0, wt = 0, Ct = me, Jt = null;
      e:
        for (; ; ) {
          for (var Gt = null; Ct === ve && (Ie === 0 || Ct.nodeType === kl) && (Xe = Ze + Ie), Ct === Me && (Fe === 0 || Ct.nodeType === kl) && (at = Ze + Fe), Ct.nodeType === kl && (Ze += Ct.nodeValue.length), (Gt = Ct.firstChild) !== null; )
            Jt = Ct, Ct = Gt;
          for (; ; ) {
            if (Ct === me)
              break e;
            if (Jt === ve && ++pt === Ie && (Xe = Ze), Jt === Me && ++wt === Fe && (at = Ze), (Gt = Ct.nextSibling) !== null)
              break;
            Ct = Jt, Jt = Ct.parentNode;
          }
          Ct = Gt;
        }
      return Xe === -1 || at === -1 ? null : { start: Xe, end: at };
    }
    function N_(me, ve) {
      var Ie = me.ownerDocument || document, Me = Ie && Ie.defaultView || window;
      if (Me.getSelection) {
        var Fe = Me.getSelection(), Ze = me.textContent.length, Xe = Math.min(ve.start, Ze), at = ve.end === void 0 ? Xe : Math.min(ve.end, Ze);
        if (!Fe.extend && Xe > at) {
          var pt = at;
          at = Xe, Xe = pt;
        }
        var wt = ri(me, Xe), Ct = ri(me, at);
        if (wt && Ct) {
          if (Fe.rangeCount === 1 && Fe.anchorNode === wt.node && Fe.anchorOffset === wt.offset && Fe.focusNode === Ct.node && Fe.focusOffset === Ct.offset)
            return;
          var Jt = Ie.createRange();
          Jt.setStart(wt.node, wt.offset), Fe.removeAllRanges(), Xe > at ? (Fe.addRange(Jt), Fe.extend(Ct.node, Ct.offset)) : (Jt.setEnd(Ct.node, Ct.offset), Fe.addRange(Jt));
        }
      }
    }
    function Yx(me) {
      return me && me.nodeType === kl;
    }
    function Qx(me, ve) {
      return !me || !ve ? !1 : me === ve ? !0 : Yx(me) ? !1 : Yx(ve) ? Qx(me, ve.parentNode) : "contains" in me ? me.contains(ve) : me.compareDocumentPosition ? !!(me.compareDocumentPosition(ve) & 16) : !1;
    }
    function lO(me) {
      return me && me.ownerDocument && Qx(me.ownerDocument.documentElement, me);
    }
    function cO(me) {
      try {
        return typeof me.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Kx() {
      for (var me = window, ve = vs(); ve instanceof me.HTMLIFrameElement; ) {
        if (cO(ve))
          me = ve.contentWindow;
        else
          return ve;
        ve = vs(me.document);
      }
      return ve;
    }
    function j_(me) {
      var ve = me && me.nodeName && me.nodeName.toLowerCase();
      return ve && (ve === "input" && (me.type === "text" || me.type === "search" || me.type === "tel" || me.type === "url" || me.type === "password") || ve === "textarea" || me.contentEditable === "true");
    }
    function dO() {
      var me = Kx();
      return { focusedElem: me, selectionRange: j_(me) ? pO(me) : null };
    }
    function fO(me) {
      var ve = Kx(), Ie = me.focusedElem, Me = me.selectionRange;
      if (ve !== Ie && lO(Ie)) {
        Me !== null && j_(Ie) && hO(Ie, Me);
        for (var Fe = [], Ze = Ie; Ze = Ze.parentNode; )
          Ze.nodeType === gs && Fe.push({ element: Ze, left: Ze.scrollLeft, top: Ze.scrollTop });
        typeof Ie.focus == "function" && Ie.focus();
        for (var Xe = 0; Xe < Fe.length; Xe++) {
          var at = Fe[Xe];
          at.element.scrollLeft = at.left, at.element.scrollTop = at.top;
        }
      }
    }
    function pO(me) {
      var ve;
      return "selectionStart" in me ? ve = { start: me.selectionStart, end: me.selectionEnd } : ve = Eo(me), ve || { start: 0, end: 0 };
    }
    function hO(me, ve) {
      var Ie = ve.start, Me = ve.end;
      Me === void 0 && (Me = Ie), "selectionStart" in me ? (me.selectionStart = Ie, me.selectionEnd = Math.min(Me, me.value.length)) : N_(me, ve);
    }
    var mO = so && "documentMode" in document && document.documentMode <= 11;
    function yO() {
      ao("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var vy = null, D_ = null, Kb = null, L_ = !1;
    function bO(me) {
      if ("selectionStart" in me && j_(me))
        return { start: me.selectionStart, end: me.selectionEnd };
      var ve = me.ownerDocument && me.ownerDocument.defaultView || window, Ie = ve.getSelection();
      return { anchorNode: Ie.anchorNode, anchorOffset: Ie.anchorOffset, focusNode: Ie.focusNode, focusOffset: Ie.focusOffset };
    }
    function vO(me) {
      return me.window === me ? me.document : me.nodeType === zu ? me : me.ownerDocument;
    }
    function Xx(me, ve, Ie) {
      var Me = vO(Ie);
      if (!(L_ || vy == null || vy !== vs(Me))) {
        var Fe = bO(vy);
        if (!Kb || !xr(Kb, Fe)) {
          Kb = Fe;
          var Ze = l0(D_, "onSelect");
          if (Ze.length > 0) {
            var Xe = new Ks("onSelect", "select", null, ve, Ie);
            me.push({ event: Xe, listeners: Ze }), Xe.target = vy;
          }
        }
      }
    }
    function gO(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at = Ie ? xy(Ie) : window;
      switch (ve) {
        case "focusin":
          (a0(at) || at.contentEditable === "true") && (vy = at, D_ = Ie, Kb = null);
          break;
        case "focusout":
          vy = null, D_ = null, Kb = null;
          break;
        case "mousedown":
          L_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          L_ = !1, Xx(me, Me, Fe);
          break;
        case "selectionchange":
          if (mO)
            break;
        case "keydown":
        case "keyup":
          Xx(me, Me, Fe);
      }
    }
    function i0(me, ve) {
      var Ie = {};
      return Ie[me.toLowerCase()] = ve.toLowerCase(), Ie["Webkit" + me] = "webkit" + ve, Ie["Moz" + me] = "moz" + ve, Ie;
    }
    var gy = { animationend: i0("Animation", "AnimationEnd"), animationiteration: i0("Animation", "AnimationIteration"), animationstart: i0("Animation", "AnimationStart"), transitionend: i0("Transition", "TransitionEnd") }, F_ = {}, Jx = {};
    so && (Jx = document.createElement("div").style, "AnimationEvent" in window || (delete gy.animationend.animation, delete gy.animationiteration.animation, delete gy.animationstart.animation), "TransitionEvent" in window || delete gy.transitionend.transition);
    function s0(me) {
      if (F_[me])
        return F_[me];
      if (!gy[me])
        return me;
      var ve = gy[me];
      for (var Ie in ve)
        if (ve.hasOwnProperty(Ie) && Ie in Jx)
          return F_[me] = ve[Ie];
      return me;
    }
    var eS = s0("animationend"), tS = s0("animationiteration"), oS = s0("animationstart"), aS = s0("transitionend"), uS = /* @__PURE__ */ new Map(), lS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Lf(me, ve) {
      uS.set(me, ve), ao(ve, [me]);
    }
    function wO() {
      for (var me = 0; me < lS.length; me++) {
        var ve = lS[me], Ie = ve.toLowerCase(), Me = ve[0].toUpperCase() + ve.slice(1);
        Lf(Ie, "on" + Me);
      }
      Lf(eS, "onAnimationEnd"), Lf(tS, "onAnimationIteration"), Lf(oS, "onAnimationStart"), Lf("dblclick", "onDoubleClick"), Lf("focusin", "onFocus"), Lf("focusout", "onBlur"), Lf(aS, "onTransitionEnd");
    }
    function _O(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at = uS.get(ve);
      if (at !== void 0) {
        var pt = Ks, wt = ve;
        switch (ve) {
          case "keypress":
            if (Nf(Me) === 0)
              return;
          case "keydown":
          case "keyup":
            pt = O_;
            break;
          case "focusin":
            wt = "focus", pt = uy;
            break;
          case "focusout":
            wt = "blur", pt = uy;
            break;
          case "beforeblur":
          case "afterblur":
            pt = uy;
            break;
          case "click":
            if (Me.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            pt = sy;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            pt = zb;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            pt = C_;
            break;
          case eS:
          case tS:
          case oS:
            pt = Ub;
            break;
          case aS:
            pt = qb;
            break;
          case "scroll":
            pt = Zg;
            break;
          case "wheel":
            pt = Uc;
            break;
          case "copy":
          case "cut":
          case "paste":
            pt = P_;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            pt = Wb;
            break;
        }
        var Ct = (Ze & mf) !== 0;
        {
          var Jt = !Ct && ve === "scroll", Gt = PO(Ie, at, Me.type, Ct, Jt);
          if (Gt.length > 0) {
            var pn = new pt(at, wt, null, Me, Fe);
            me.push({ event: pn, listeners: Gt });
          }
        }
      }
    }
    wO(), Qt(), R_(), yO(), t0();
    function EO(me, ve, Ie, Me, Fe, Ze, Xe) {
      _O(me, ve, Ie, Me, Fe, Ze);
      var at = (Ze & bg) === 0;
      at && (un(me, ve, Ie, Me, Fe), nn(me, ve, Ie, Me, Fe), gO(me, ve, Ie, Me, Fe), I_(me, ve, Ie, Me, Fe));
    }
    var Xb = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], B_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Xb));
    function cS(me, ve, Ie) {
      var Me = me.type || "unknown-event";
      me.currentTarget = Ie, Rl(Me, ve, void 0, me), me.currentTarget = null;
    }
    function xO(me, ve, Ie) {
      var Me;
      if (Ie)
        for (var Fe = ve.length - 1; Fe >= 0; Fe--) {
          var Ze = ve[Fe], Xe = Ze.instance, at = Ze.currentTarget, pt = Ze.listener;
          if (Xe !== Me && me.isPropagationStopped())
            return;
          cS(me, pt, at), Me = Xe;
        }
      else
        for (var wt = 0; wt < ve.length; wt++) {
          var Ct = ve[wt], Jt = Ct.instance, Gt = Ct.currentTarget, pn = Ct.listener;
          if (Jt !== Me && me.isPropagationStopped())
            return;
          cS(me, pn, Gt), Me = Jt;
        }
    }
    function dS(me, ve) {
      for (var Ie = (ve & mf) !== 0, Me = 0; Me < me.length; Me++) {
        var Fe = me[Me], Ze = Fe.event, Xe = Fe.listeners;
        xO(Ze, Xe, Ie);
      }
      pb();
    }
    function SO(me, ve, Ie, Me, Fe) {
      var Ze = pm(Ie), Xe = [];
      EO(Xe, me, Me, Ie, Ze, ve), dS(Xe, ve);
    }
    function pa(me, ve) {
      B_.has(me) || xe('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', me);
      var Ie = !1, Me = VC(ve), Fe = OO(me, Ie);
      Me.has(Fe) || (fS(ve, me, hf, Ie), Me.add(Fe));
    }
    function z_(me, ve, Ie) {
      B_.has(me) && !ve && xe('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', me);
      var Me = 0;
      ve && (Me |= mf), fS(Ie, me, Me, ve);
    }
    var u0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Jb(me) {
      if (!me[u0]) {
        me[u0] = !0, Un.forEach(function(Ie) {
          Ie !== "selectionchange" && (B_.has(Ie) || z_(Ie, !1, me), z_(Ie, !0, me));
        });
        var ve = me.nodeType === zu ? me : me.ownerDocument;
        ve !== null && (ve[u0] || (ve[u0] = !0, z_("selectionchange", !1, ve)));
      }
    }
    function fS(me, ve, Ie, Me, Fe) {
      var Ze = Ys(me, ve, Ie), Xe = void 0;
      _p && (ve === "touchstart" || ve === "touchmove" || ve === "wheel") && (Xe = !0), me = me, Me ? Xe !== void 0 ? If(me, ve, Ze, Xe) : Bb(me, ve, Ze) : Xe !== void 0 ? Hl(me, ve, Ze, Xe) : As(me, ve, Ze);
    }
    function pS(me, ve) {
      return me === ve || me.nodeType === Ba && me.parentNode === ve;
    }
    function U_(me, ve, Ie, Me, Fe) {
      var Ze = Me;
      if (!(ve & Al) && !(ve & hf)) {
        var Xe = Fe;
        if (Me !== null) {
          var at = Me;
          e:
            for (; ; ) {
              if (at === null)
                return;
              var pt = at.tag;
              if (pt === je || pt === Be) {
                var wt = at.stateNode.containerInfo;
                if (pS(wt, Xe))
                  break;
                if (pt === Be)
                  for (var Ct = at.return; Ct !== null; ) {
                    var Jt = Ct.tag;
                    if (Jt === je || Jt === Be) {
                      var Gt = Ct.stateNode.containerInfo;
                      if (pS(Gt, Xe))
                        return;
                    }
                    Ct = Ct.return;
                  }
                for (; wt !== null; ) {
                  var pn = Xp(wt);
                  if (pn === null)
                    return;
                  var yn = pn.tag;
                  if (yn === ze || yn === He) {
                    at = Ze = pn;
                    continue e;
                  }
                  wt = wt.parentNode;
                }
              }
              at = at.return;
            }
        }
      }
      lb(function() {
        return SO(me, ve, Ie, Ze);
      });
    }
    function ev(me, ve, Ie) {
      return { instance: me, listener: ve, currentTarget: Ie };
    }
    function PO(me, ve, Ie, Me, Fe, Ze) {
      for (var Xe = ve !== null ? ve + "Capture" : null, at = Me ? Xe : ve, pt = [], wt = me, Ct = null; wt !== null; ) {
        var Jt = wt, Gt = Jt.stateNode, pn = Jt.tag;
        if (pn === ze && Gt !== null && (Ct = Gt, at !== null)) {
          var yn = ld(wt, at);
          yn != null && pt.push(ev(wt, yn, Ct));
        }
        if (Fe)
          break;
        wt = wt.return;
      }
      return pt;
    }
    function l0(me, ve) {
      for (var Ie = ve + "Capture", Me = [], Fe = me; Fe !== null; ) {
        var Ze = Fe, Xe = Ze.stateNode, at = Ze.tag;
        if (at === ze && Xe !== null) {
          var pt = Xe, wt = ld(Fe, Ie);
          wt != null && Me.unshift(ev(Fe, wt, pt));
          var Ct = ld(Fe, ve);
          Ct != null && Me.push(ev(Fe, Ct, pt));
        }
        Fe = Fe.return;
      }
      return Me;
    }
    function wy(me) {
      if (me === null)
        return null;
      do
        me = me.return;
      while (me && me.tag !== ze);
      return me || null;
    }
    function TO(me, ve) {
      for (var Ie = me, Me = ve, Fe = 0, Ze = Ie; Ze; Ze = wy(Ze))
        Fe++;
      for (var Xe = 0, at = Me; at; at = wy(at))
        Xe++;
      for (; Fe - Xe > 0; )
        Ie = wy(Ie), Fe--;
      for (; Xe - Fe > 0; )
        Me = wy(Me), Xe--;
      for (var pt = Fe; pt--; ) {
        if (Ie === Me || Me !== null && Ie === Me.alternate)
          return Ie;
        Ie = wy(Ie), Me = wy(Me);
      }
      return null;
    }
    function hS(me, ve, Ie, Me, Fe) {
      for (var Ze = ve._reactName, Xe = [], at = Ie; at !== null && at !== Me; ) {
        var pt = at, wt = pt.alternate, Ct = pt.stateNode, Jt = pt.tag;
        if (wt !== null && wt === Me)
          break;
        if (Jt === ze && Ct !== null) {
          var Gt = Ct;
          if (Fe) {
            var pn = ld(at, Ze);
            pn != null && Xe.unshift(ev(at, pn, Gt));
          } else if (!Fe) {
            var yn = ld(at, Ze);
            yn != null && Xe.push(ev(at, yn, Gt));
          }
        }
        at = at.return;
      }
      Xe.length !== 0 && me.push({ event: ve, listeners: Xe });
    }
    function kO(me, ve, Ie, Me, Fe) {
      var Ze = Me && Fe ? TO(Me, Fe) : null;
      Me !== null && hS(me, ve, Me, Ze, !1), Fe !== null && Ie !== null && hS(me, Ie, Fe, Ze, !0);
    }
    function OO(me, ve) {
      return me + "__" + (ve ? "capture" : "bubble");
    }
    var _u = !1, tv = "dangerouslySetInnerHTML", c0 = "suppressContentEditableWarning", Ff = "suppressHydrationWarning", yS = "autoFocus", Qp = "children", Kp = "style", d0 = "__html", V_, f0, nv, bS, p0, vS, gS;
    V_ = { dialog: !0, webview: !0 }, f0 = function(me, ve) {
      fm(me, ve), ob(me, ve), yg(me, ve, { registrationNameDependencies: ar, possibleRegistrationNames: Zo });
    }, vS = so && !document.documentMode, nv = function(me, ve, Ie) {
      if (!_u) {
        var Me = h0(Ie), Fe = h0(ve);
        Fe !== Me && (_u = !0, xe("Prop `%s` did not match. Server: %s Client: %s", me, JSON.stringify(Fe), JSON.stringify(Me)));
      }
    }, bS = function(me) {
      if (!_u) {
        _u = !0;
        var ve = [];
        me.forEach(function(Ie) {
          ve.push(Ie);
        }), xe("Extra attributes from the server: %s", ve);
      }
    }, p0 = function(me, ve) {
      ve === !1 ? xe("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", me, me, me) : xe("Expected `%s` listener to be a function, instead got a value of `%s` type.", me, typeof ve);
    }, gS = function(me, ve) {
      var Ie = me.namespaceURI === Tl ? me.ownerDocument.createElement(me.tagName) : me.ownerDocument.createElementNS(me.namespaceURI, me.tagName);
      return Ie.innerHTML = ve, Ie.innerHTML;
    };
    var AO = /\r\n?/g, CO = /\u0000|\uFFFD/g;
    function h0(me) {
      la(me);
      var ve = typeof me == "string" ? me : "" + me;
      return ve.replace(AO, `
`).replace(CO, "");
    }
    function m0(me, ve, Ie, Me) {
      var Fe = h0(ve), Ze = h0(me);
      if (Ze !== Fe && (Me && (_u || (_u = !0, xe('Text content did not match. Server: "%s" Client: "%s"', Ze, Fe))), Ie && hn))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function wS(me) {
      return me.nodeType === zu ? me : me.ownerDocument;
    }
    function $O() {
    }
    function y0(me) {
      me.onclick = $O;
    }
    function IO(me, ve, Ie, Me, Fe) {
      for (var Ze in Me)
        if (Me.hasOwnProperty(Ze)) {
          var Xe = Me[Ze];
          if (Ze === Kp)
            Xe && Object.freeze(Xe), ig(ve, Xe);
          else if (Ze === tv) {
            var at = Xe ? Xe[d0] : void 0;
            at != null && Qv(ve, at);
          } else if (Ze === Qp)
            if (typeof Xe == "string") {
              var pt = me !== "textarea" || Xe !== "";
              pt && sm(ve, Xe);
            } else
              typeof Xe == "number" && sm(ve, "" + Xe);
          else
            Ze === c0 || Ze === Ff || Ze === yS || (ar.hasOwnProperty(Ze) ? Xe != null && (typeof Xe != "function" && p0(Ze, Xe), Ze === "onScroll" && pa("scroll", ve)) : Xe != null && wa(ve, Ze, Xe, Fe));
        }
    }
    function RO(me, ve, Ie, Me) {
      for (var Fe = 0; Fe < ve.length; Fe += 2) {
        var Ze = ve[Fe], Xe = ve[Fe + 1];
        Ze === Kp ? ig(me, Xe) : Ze === tv ? Qv(me, Xe) : Ze === Qp ? sm(me, Xe) : wa(me, Ze, Xe, Me);
      }
    }
    function NO(me, ve, Ie, Me) {
      var Fe, Ze = wS(Ie), Xe, at = Me;
      if (at === Tl && (at = am(me)), at === Tl) {
        if (Fe = Ol(me, ve), !Fe && me !== me.toLowerCase() && xe("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", me), me === "script") {
          var pt = Ze.createElement("div");
          pt.innerHTML = "<script><\/script>";
          var wt = pt.firstChild;
          Xe = pt.removeChild(wt);
        } else if (typeof ve.is == "string")
          Xe = Ze.createElement(me, { is: ve.is });
        else if (Xe = Ze.createElement(me), me === "select") {
          var Ct = Xe;
          ve.multiple ? Ct.multiple = !0 : ve.size && (Ct.size = ve.size);
        }
      } else
        Xe = Ze.createElementNS(at, me);
      return at === Tl && !Fe && Object.prototype.toString.call(Xe) === "[object HTMLUnknownElement]" && !Io.call(V_, me) && (V_[me] = !0, xe("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", me)), Xe;
    }
    function MO(me, ve) {
      return wS(ve).createTextNode(me);
    }
    function jO(me, ve, Ie, Me) {
      var Fe = Ol(ve, Ie);
      f0(ve, Ie);
      var Ze;
      switch (ve) {
        case "dialog":
          pa("cancel", me), pa("close", me), Ze = Ie;
          break;
        case "iframe":
        case "object":
        case "embed":
          pa("load", me), Ze = Ie;
          break;
        case "video":
        case "audio":
          for (var Xe = 0; Xe < Xb.length; Xe++)
            pa(Xb[Xe], me);
          Ze = Ie;
          break;
        case "source":
          pa("error", me), Ze = Ie;
          break;
        case "img":
        case "image":
        case "link":
          pa("error", me), pa("load", me), Ze = Ie;
          break;
        case "details":
          pa("toggle", me), Ze = Ie;
          break;
        case "input":
          Ot(me, Ie), Ze = dt(me, Ie), pa("invalid", me);
          break;
        case "option":
          Ir(me, Ie), Ze = Ie;
          break;
        case "select":
          uf(me, Ie), Ze = Pl(me, Ie), pa("invalid", me);
          break;
        case "textarea":
          Zv(me, Ie), Ze = Yy(me, Ie), pa("invalid", me);
          break;
        default:
          Ze = Ie;
      }
      switch (cm(ve, Ze), IO(ve, me, Me, Ze, Fe), ve) {
        case "input":
          Ei(me), An(me, Ie, !1);
          break;
        case "textarea":
          Ei(me), Yv(me);
          break;
        case "option":
          Vr(me, Ie);
          break;
        case "select":
          n_(me, Ie);
          break;
        default:
          typeof Ze.onClick == "function" && y0(me);
          break;
      }
    }
    function DO(me, ve, Ie, Me, Fe) {
      f0(ve, Me);
      var Ze = null, Xe, at;
      switch (ve) {
        case "input":
          Xe = dt(me, Ie), at = dt(me, Me), Ze = [];
          break;
        case "select":
          Xe = Pl(me, Ie), at = Pl(me, Me), Ze = [];
          break;
        case "textarea":
          Xe = Yy(me, Ie), at = Yy(me, Me), Ze = [];
          break;
        default:
          Xe = Ie, at = Me, typeof Xe.onClick != "function" && typeof at.onClick == "function" && y0(me);
          break;
      }
      cm(ve, at);
      var pt, wt, Ct = null;
      for (pt in Xe)
        if (!(at.hasOwnProperty(pt) || !Xe.hasOwnProperty(pt) || Xe[pt] == null))
          if (pt === Kp) {
            var Jt = Xe[pt];
            for (wt in Jt)
              Jt.hasOwnProperty(wt) && (Ct || (Ct = {}), Ct[wt] = "");
          } else
            pt === tv || pt === Qp || pt === c0 || pt === Ff || pt === yS || (ar.hasOwnProperty(pt) ? Ze || (Ze = []) : (Ze = Ze || []).push(pt, null));
      for (pt in at) {
        var Gt = at[pt], pn = Xe == null ? void 0 : Xe[pt];
        if (!(!at.hasOwnProperty(pt) || Gt === pn || Gt == null && pn == null))
          if (pt === Kp)
            if (Gt && Object.freeze(Gt), pn) {
              for (wt in pn)
                pn.hasOwnProperty(wt) && (!Gt || !Gt.hasOwnProperty(wt)) && (Ct || (Ct = {}), Ct[wt] = "");
              for (wt in Gt)
                Gt.hasOwnProperty(wt) && pn[wt] !== Gt[wt] && (Ct || (Ct = {}), Ct[wt] = Gt[wt]);
            } else
              Ct || (Ze || (Ze = []), Ze.push(pt, Ct)), Ct = Gt;
          else if (pt === tv) {
            var yn = Gt ? Gt[d0] : void 0, En = pn ? pn[d0] : void 0;
            yn != null && En !== yn && (Ze = Ze || []).push(pt, yn);
          } else
            pt === Qp ? (typeof Gt == "string" || typeof Gt == "number") && (Ze = Ze || []).push(pt, "" + Gt) : pt === c0 || pt === Ff || (ar.hasOwnProperty(pt) ? (Gt != null && (typeof Gt != "function" && p0(pt, Gt), pt === "onScroll" && pa("scroll", me)), !Ze && pn !== Gt && (Ze = [])) : (Ze = Ze || []).push(pt, Gt));
      }
      return Ct && (mp(Ct, at[Kp]), (Ze = Ze || []).push(Kp, Ct)), Ze;
    }
    function LO(me, ve, Ie, Me, Fe) {
      Ie === "input" && Fe.type === "radio" && Fe.name != null && $t(me, Fe);
      var Ze = Ol(Ie, Me), Xe = Ol(Ie, Fe);
      switch (RO(me, ve, Ze, Xe), Ie) {
        case "input":
          Xt(me, Fe);
          break;
        case "textarea":
          Gv(me, Fe);
          break;
        case "select":
          r_(me, Fe);
          break;
      }
    }
    function FO(me) {
      {
        var ve = me.toLowerCase();
        return dm.hasOwnProperty(ve) && dm[ve] || null;
      }
    }
    function BO(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at, pt;
      switch (at = Ol(ve, Ie), f0(ve, Ie), ve) {
        case "dialog":
          pa("cancel", me), pa("close", me);
          break;
        case "iframe":
        case "object":
        case "embed":
          pa("load", me);
          break;
        case "video":
        case "audio":
          for (var wt = 0; wt < Xb.length; wt++)
            pa(Xb[wt], me);
          break;
        case "source":
          pa("error", me);
          break;
        case "img":
        case "image":
        case "link":
          pa("error", me), pa("load", me);
          break;
        case "details":
          pa("toggle", me);
          break;
        case "input":
          Ot(me, Ie), pa("invalid", me);
          break;
        case "option":
          Ir(me, Ie);
          break;
        case "select":
          uf(me, Ie), pa("invalid", me);
          break;
        case "textarea":
          Zv(me, Ie), pa("invalid", me);
          break;
      }
      cm(ve, Ie);
      {
        pt = /* @__PURE__ */ new Set();
        for (var Ct = me.attributes, Jt = 0; Jt < Ct.length; Jt++) {
          var Gt = Ct[Jt].name.toLowerCase();
          switch (Gt) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              pt.add(Ct[Jt].name);
          }
        }
      }
      var pn = null;
      for (var yn in Ie)
        if (Ie.hasOwnProperty(yn)) {
          var En = Ie[yn];
          if (yn === Qp)
            typeof En == "string" ? me.textContent !== En && (Ie[Ff] !== !0 && m0(me.textContent, En, Ze, Xe), pn = [Qp, En]) : typeof En == "number" && me.textContent !== "" + En && (Ie[Ff] !== !0 && m0(me.textContent, En, Ze, Xe), pn = [Qp, "" + En]);
          else if (ar.hasOwnProperty(yn))
            En != null && (typeof En != "function" && p0(yn, En), yn === "onScroll" && pa("scroll", me));
          else if (Xe && typeof at == "boolean") {
            var Kn = void 0, vr = at && $n ? null : wo(yn);
            if (Ie[Ff] !== !0 && !(yn === c0 || yn === Ff || yn === "value" || yn === "checked" || yn === "selected")) {
              if (yn === tv) {
                var Or = me.innerHTML, co = En ? En[d0] : void 0;
                if (co != null) {
                  var Xr = gS(me, co);
                  Xr !== Or && nv(yn, Or, Xr);
                }
              } else if (yn === Kp) {
                if (pt.delete(yn), vS) {
                  var rn = d_(En);
                  Kn = me.getAttribute("style"), rn !== Kn && nv(yn, Kn, rn);
                }
              } else if (at && !$n)
                pt.delete(yn.toLowerCase()), Kn = ci(me, yn, En), En !== Kn && nv(yn, Kn, En);
              else if (!Wn(yn, vr, at) && !Br(yn, En, vr, at)) {
                var wn = !1;
                if (vr !== null)
                  pt.delete(vr.attributeName), Kn = Ta(me, yn, En, vr);
                else {
                  var an = Me;
                  if (an === Tl && (an = am(ve)), an === Tl)
                    pt.delete(yn.toLowerCase());
                  else {
                    var Bn = FO(yn);
                    Bn !== null && Bn !== yn && (wn = !0, pt.delete(Bn)), pt.delete(yn);
                  }
                  Kn = ci(me, yn, En);
                }
                var nr = $n;
                !nr && En !== Kn && !wn && nv(yn, Kn, En);
              }
            }
          }
        }
      switch (Xe && pt.size > 0 && Ie[Ff] !== !0 && bS(pt), ve) {
        case "input":
          Ei(me), An(me, Ie, !0);
          break;
        case "textarea":
          Ei(me), Yv(me);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof Ie.onClick == "function" && y0(me);
          break;
      }
      return pn;
    }
    function zO(me, ve, Ie) {
      var Me = me.nodeValue !== ve;
      return Me;
    }
    function H_(me, ve) {
      {
        if (_u)
          return;
        _u = !0, xe("Did not expect server HTML to contain a <%s> in <%s>.", ve.nodeName.toLowerCase(), me.nodeName.toLowerCase());
      }
    }
    function W_(me, ve) {
      {
        if (_u)
          return;
        _u = !0, xe('Did not expect server HTML to contain the text node "%s" in <%s>.', ve.nodeValue, me.nodeName.toLowerCase());
      }
    }
    function q_(me, ve, Ie) {
      {
        if (_u)
          return;
        _u = !0, xe("Expected server HTML to contain a matching <%s> in <%s>.", ve, me.nodeName.toLowerCase());
      }
    }
    function Z_(me, ve) {
      {
        if (ve === "" || _u)
          return;
        _u = !0, xe('Expected server HTML to contain a matching text node for "%s" in <%s>.', ve, me.nodeName.toLowerCase());
      }
    }
    function UO(me, ve, Ie) {
      switch (ve) {
        case "input":
          gn(me, Ie);
          return;
        case "textarea":
          Qy(me, Ie);
          return;
        case "select":
          o_(me, Ie);
          return;
      }
    }
    var rv = function() {
    }, ov = function() {
    };
    {
      var VO = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], _S = ["applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title"], HO = _S.concat(["button"]), WO = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], ES = { current: null, formTag: null, aTagInScope: null, buttonTagInScope: null, nobrTagInScope: null, pTagInButtonScope: null, listItemTagAutoclosing: null, dlItemTagAutoclosing: null };
      ov = function(me, ve) {
        var Ie = Wr({}, me || ES), Me = { tag: ve };
        return _S.indexOf(ve) !== -1 && (Ie.aTagInScope = null, Ie.buttonTagInScope = null, Ie.nobrTagInScope = null), HO.indexOf(ve) !== -1 && (Ie.pTagInButtonScope = null), VO.indexOf(ve) !== -1 && ve !== "address" && ve !== "div" && ve !== "p" && (Ie.listItemTagAutoclosing = null, Ie.dlItemTagAutoclosing = null), Ie.current = Me, ve === "form" && (Ie.formTag = Me), ve === "a" && (Ie.aTagInScope = Me), ve === "button" && (Ie.buttonTagInScope = Me), ve === "nobr" && (Ie.nobrTagInScope = Me), ve === "p" && (Ie.pTagInButtonScope = Me), ve === "li" && (Ie.listItemTagAutoclosing = Me), (ve === "dd" || ve === "dt") && (Ie.dlItemTagAutoclosing = Me), Ie;
      };
      var qO = function(me, ve) {
        switch (ve) {
          case "select":
            return me === "option" || me === "optgroup" || me === "#text";
          case "optgroup":
            return me === "option" || me === "#text";
          case "option":
            return me === "#text";
          case "tr":
            return me === "th" || me === "td" || me === "style" || me === "script" || me === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return me === "tr" || me === "style" || me === "script" || me === "template";
          case "colgroup":
            return me === "col" || me === "template";
          case "table":
            return me === "caption" || me === "colgroup" || me === "tbody" || me === "tfoot" || me === "thead" || me === "style" || me === "script" || me === "template";
          case "head":
            return me === "base" || me === "basefont" || me === "bgsound" || me === "link" || me === "meta" || me === "title" || me === "noscript" || me === "noframes" || me === "style" || me === "script" || me === "template";
          case "html":
            return me === "head" || me === "body" || me === "frameset";
          case "frameset":
            return me === "frame";
          case "#document":
            return me === "html";
        }
        switch (me) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ve !== "h1" && ve !== "h2" && ve !== "h3" && ve !== "h4" && ve !== "h5" && ve !== "h6";
          case "rp":
          case "rt":
            return WO.indexOf(ve) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return ve == null;
        }
        return !0;
      }, ZO = function(me, ve) {
        switch (me) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ve.pTagInButtonScope;
          case "form":
            return ve.formTag || ve.pTagInButtonScope;
          case "li":
            return ve.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ve.dlItemTagAutoclosing;
          case "button":
            return ve.buttonTagInScope;
          case "a":
            return ve.aTagInScope;
          case "nobr":
            return ve.nobrTagInScope;
        }
        return null;
      }, xS = {};
      rv = function(me, ve, Ie) {
        Ie = Ie || ES;
        var Me = Ie.current, Fe = Me && Me.tag;
        ve != null && (me != null && xe("validateDOMNesting: when childText is passed, childTag should be null"), me = "#text");
        var Ze = qO(me, Fe) ? null : Me, Xe = Ze ? null : ZO(me, Ie), at = Ze || Xe;
        if (at) {
          var pt = at.tag, wt = !!Ze + "|" + me + "|" + pt;
          if (!xS[wt]) {
            xS[wt] = !0;
            var Ct = me, Jt = "";
            if (me === "#text" ? /\S/.test(ve) ? Ct = "Text nodes" : (Ct = "Whitespace text nodes", Jt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Ct = "<" + me + ">", Ze) {
              var Gt = "";
              pt === "table" && me === "tr" && (Gt += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), xe("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Ct, pt, Jt, Gt);
            } else
              xe("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Ct, pt);
          }
        }
      };
    }
    var b0 = "suppressHydrationWarning", v0 = "$", g0 = "/$", av = "$?", iv = "$!", GO = "style", G_ = null, Y_ = null;
    function YO(me) {
      var ve, Ie, Me = me.nodeType;
      switch (Me) {
        case zu:
        case ad: {
          ve = Me === zu ? "#document" : "#fragment";
          var Fe = me.documentElement;
          Ie = Fe ? Fe.namespaceURI : Xy(null, "");
          break;
        }
        default: {
          var Ze = Me === Ba ? me.parentNode : me, Xe = Ze.namespaceURI || null;
          ve = Ze.tagName, Ie = Xy(Xe, ve);
          break;
        }
      }
      {
        var at = ve.toLowerCase(), pt = ov(null, at);
        return { namespace: Ie, ancestorInfo: pt };
      }
    }
    function QO(me, ve, Ie) {
      {
        var Me = me, Fe = Xy(Me.namespace, ve), Ze = ov(Me.ancestorInfo, ve);
        return { namespace: Fe, ancestorInfo: Ze };
      }
    }
    function KO(me) {
      G_ = $i(), Y_ = dO();
      var ve = null;
      return Aa(!1), ve;
    }
    function XO(me) {
      fO(Y_), Aa(G_), G_ = null, Y_ = null;
    }
    function JO(me, ve, Ie, Me, Fe) {
      var Ze;
      {
        var Xe = Me;
        if (rv(me, null, Xe.ancestorInfo), typeof ve.children == "string" || typeof ve.children == "number") {
          var at = "" + ve.children, pt = ov(Xe.ancestorInfo, me);
          rv(null, at, pt);
        }
        Ze = Xe.namespace;
      }
      var wt = NO(me, ve, Ie, Ze);
      return lv(Fe, wt), r1(wt, ve), wt;
    }
    function eA(me, ve) {
      me.appendChild(ve);
    }
    function sA(me, ve, Ie, Me, Fe) {
      switch (jO(me, ve, Ie, Me), ve) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!Ie.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function uA(me, ve, Ie, Me, Fe, Ze) {
      {
        var Xe = Ze;
        if (typeof Me.children != typeof Ie.children && (typeof Me.children == "string" || typeof Me.children == "number")) {
          var at = "" + Me.children, pt = ov(Xe.ancestorInfo, ve);
          rv(null, at, pt);
        }
      }
      return DO(me, ve, Ie, Me);
    }
    function Q_(me, ve) {
      return me === "textarea" || me === "noscript" || typeof ve.children == "string" || typeof ve.children == "number" || typeof ve.dangerouslySetInnerHTML == "object" && ve.dangerouslySetInnerHTML !== null && ve.dangerouslySetInnerHTML.__html != null;
    }
    function lA(me, ve, Ie, Me) {
      {
        var Fe = Ie;
        rv(null, me, Fe.ancestorInfo);
      }
      var Ze = MO(me, ve);
      return lv(Me, Ze), Ze;
    }
    function yA() {
      var me = window.event;
      return me === void 0 ? Pi : $f(me.type);
    }
    var K_ = typeof setTimeout == "function" ? setTimeout : void 0, _A = typeof clearTimeout == "function" ? clearTimeout : void 0, X_ = -1, SS = typeof Promise == "function" ? Promise : void 0, OA = typeof queueMicrotask == "function" ? queueMicrotask : typeof SS < "u" ? function(me) {
      return SS.resolve(null).then(me).catch($A);
    } : K_;
    function $A(me) {
      setTimeout(function() {
        throw me;
      });
    }
    function RA(me, ve, Ie, Me) {
      switch (ve) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          Ie.autoFocus && me.focus();
          return;
        case "img": {
          Ie.src && (me.src = Ie.src);
          return;
        }
      }
    }
    function BA(me, ve, Ie, Me, Fe, Ze) {
      LO(me, ve, Ie, Me, Fe), r1(me, Fe);
    }
    function PS(me) {
      sm(me, "");
    }
    function qA(me, ve, Ie) {
      me.nodeValue = Ie;
    }
    function eC(me, ve) {
      me.appendChild(ve);
    }
    function tC(me, ve) {
      var Ie;
      me.nodeType === Ba ? (Ie = me.parentNode, Ie.insertBefore(ve, me)) : (Ie = me, Ie.appendChild(ve));
      var Me = me._reactRootContainer;
      Me == null && Ie.onclick === null && y0(Ie);
    }
    function nC(me, ve, Ie) {
      me.insertBefore(ve, Ie);
    }
    function rC(me, ve, Ie) {
      me.nodeType === Ba ? me.parentNode.insertBefore(ve, Ie) : me.insertBefore(ve, Ie);
    }
    function oC(me, ve) {
      me.removeChild(ve);
    }
    function aC(me, ve) {
      me.nodeType === Ba ? me.parentNode.removeChild(ve) : me.removeChild(ve);
    }
    function J_(me, ve) {
      var Ie = ve, Me = 0;
      do {
        var Fe = Ie.nextSibling;
        if (me.removeChild(Ie), Fe && Fe.nodeType === Ba) {
          var Ze = Fe.data;
          if (Ze === g0)
            if (Me === 0) {
              me.removeChild(Fe), Gi(ve);
              return;
            } else
              Me--;
          else
            (Ze === v0 || Ze === av || Ze === iv) && Me++;
        }
        Ie = Fe;
      } while (Ie);
      Gi(ve);
    }
    function iC(me, ve) {
      me.nodeType === Ba ? J_(me.parentNode, ve) : me.nodeType === gs && J_(me, ve), Gi(me);
    }
    function sC(me) {
      me = me;
      var ve = me.style;
      typeof ve.setProperty == "function" ? ve.setProperty("display", "none", "important") : ve.display = "none";
    }
    function uC(me) {
      me.nodeValue = "";
    }
    function lC(me, ve) {
      me = me;
      var Ie = ve[GO], Me = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
      me.style.display = um("display", Me);
    }
    function cC(me, ve) {
      me.nodeValue = ve;
    }
    function dC(me) {
      me.nodeType === gs ? me.textContent = "" : me.nodeType === zu && me.documentElement && me.removeChild(me.documentElement);
    }
    function fC(me, ve, Ie) {
      return me.nodeType !== gs || ve.toLowerCase() !== me.nodeName.toLowerCase() ? null : me;
    }
    function pC(me, ve) {
      return ve === "" || me.nodeType !== kl ? null : me;
    }
    function hC(me) {
      return me.nodeType !== Ba ? null : me;
    }
    function kS(me) {
      return me.data === av;
    }
    function e1(me) {
      return me.data === iv;
    }
    function mC(me) {
      var ve = me.nextSibling && me.nextSibling.dataset, Ie, Me, Fe;
      return ve && (Ie = ve.dgst, Me = ve.msg, Fe = ve.stck), { message: Me, digest: Ie, stack: Fe };
    }
    function yC(me, ve) {
      me._reactRetry = ve;
    }
    function w0(me) {
      for (; me != null; me = me.nextSibling) {
        var ve = me.nodeType;
        if (ve === gs || ve === kl)
          break;
        if (ve === Ba) {
          var Ie = me.data;
          if (Ie === v0 || Ie === iv || Ie === av)
            break;
          if (Ie === g0)
            return null;
        }
      }
      return me;
    }
    function sv(me) {
      return w0(me.nextSibling);
    }
    function bC(me) {
      return w0(me.firstChild);
    }
    function vC(me) {
      return w0(me.firstChild);
    }
    function gC(me) {
      return w0(me.nextSibling);
    }
    function wC(me, ve, Ie, Me, Fe, Ze, Xe) {
      lv(Ze, me), r1(me, Ie);
      var at;
      {
        var pt = Fe;
        at = pt.namespace;
      }
      var wt = (Ze.mode & oo) !== Tr;
      return BO(me, ve, Ie, at, Me, wt, Xe);
    }
    function _C(me, ve, Ie, Me) {
      return lv(Ie, me), Ie.mode & oo, zO(me, ve);
    }
    function EC(me, ve) {
      lv(ve, me);
    }
    function xC(me) {
      for (var ve = me.nextSibling, Ie = 0; ve; ) {
        if (ve.nodeType === Ba) {
          var Me = ve.data;
          if (Me === g0) {
            if (Ie === 0)
              return sv(ve);
            Ie--;
          } else
            (Me === v0 || Me === iv || Me === av) && Ie++;
        }
        ve = ve.nextSibling;
      }
      return null;
    }
    function OS(me) {
      for (var ve = me.previousSibling, Ie = 0; ve; ) {
        if (ve.nodeType === Ba) {
          var Me = ve.data;
          if (Me === v0 || Me === iv || Me === av) {
            if (Ie === 0)
              return ve;
            Ie--;
          } else
            Me === g0 && Ie++;
        }
        ve = ve.previousSibling;
      }
      return null;
    }
    function SC(me) {
      Gi(me);
    }
    function PC(me) {
      Gi(me);
    }
    function TC(me) {
      return me !== "head" && me !== "body";
    }
    function kC(me, ve, Ie, Me) {
      var Fe = !0;
      m0(ve.nodeValue, Ie, Me, Fe);
    }
    function OC(me, ve, Ie, Me, Fe, Ze) {
      if (ve[b0] !== !0) {
        var Xe = !0;
        m0(Me.nodeValue, Fe, Ze, Xe);
      }
    }
    function AC(me, ve) {
      ve.nodeType === gs ? H_(me, ve) : ve.nodeType === Ba || W_(me, ve);
    }
    function CC(me, ve) {
      {
        var Ie = me.parentNode;
        Ie !== null && (ve.nodeType === gs ? H_(Ie, ve) : ve.nodeType === Ba || W_(Ie, ve));
      }
    }
    function $C(me, ve, Ie, Me, Fe) {
      (Fe || ve[b0] !== !0) && (Me.nodeType === gs ? H_(Ie, Me) : Me.nodeType === Ba || W_(Ie, Me));
    }
    function IC(me, ve, Ie) {
      q_(me, ve);
    }
    function RC(me, ve) {
      Z_(me, ve);
    }
    function NC(me, ve, Ie) {
      {
        var Me = me.parentNode;
        Me !== null && q_(Me, ve);
      }
    }
    function MC(me, ve) {
      {
        var Ie = me.parentNode;
        Ie !== null && Z_(Ie, ve);
      }
    }
    function jC(me, ve, Ie, Me, Fe, Ze) {
      (Ze || ve[b0] !== !0) && q_(Ie, Me);
    }
    function DC(me, ve, Ie, Me, Fe) {
      (Fe || ve[b0] !== !0) && Z_(Ie, Me);
    }
    function LC(me) {
      xe("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", me.nodeName.toLowerCase());
    }
    function FC(me) {
      Jb(me);
    }
    var _y = Math.random().toString(36).slice(2), Ey = "__reactFiber$" + _y, t1 = "__reactProps$" + _y, uv = "__reactContainer$" + _y, n1 = "__reactEvents$" + _y, BC = "__reactListeners$" + _y, zC = "__reactHandles$" + _y;
    function UC(me) {
      delete me[Ey], delete me[t1], delete me[n1], delete me[BC], delete me[zC];
    }
    function lv(me, ve) {
      ve[Ey] = me;
    }
    function _0(me, ve) {
      ve[uv] = me;
    }
    function CS(me) {
      me[uv] = null;
    }
    function cv(me) {
      return !!me[uv];
    }
    function Xp(me) {
      var ve = me[Ey];
      if (ve)
        return ve;
      for (var Ie = me.parentNode; Ie; ) {
        if (ve = Ie[uv] || Ie[Ey], ve) {
          var Me = ve.alternate;
          if (ve.child !== null || Me !== null && Me.child !== null)
            for (var Fe = OS(me); Fe !== null; ) {
              var Ze = Fe[Ey];
              if (Ze)
                return Ze;
              Fe = OS(Fe);
            }
          return ve;
        }
        me = Ie, Ie = me.parentNode;
      }
      return null;
    }
    function Bf(me) {
      var ve = me[Ey] || me[uv];
      return ve && (ve.tag === ze || ve.tag === He || ve.tag === gt || ve.tag === je) ? ve : null;
    }
    function xy(me) {
      if (me.tag === ze || me.tag === He)
        return me.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function E0(me) {
      return me[t1] || null;
    }
    function r1(me, ve) {
      me[t1] = ve;
    }
    function VC(me) {
      var ve = me[n1];
      return ve === void 0 && (ve = me[n1] = /* @__PURE__ */ new Set()), ve;
    }
    var $S = {}, IS = fe.ReactDebugCurrentFrame;
    function x0(me) {
      if (me) {
        var ve = me._owner, Ie = Fs(me.type, me._source, ve ? ve.type : null);
        IS.setExtraStackFrame(Ie);
      } else
        IS.setExtraStackFrame(null);
    }
    function Zl(me, ve, Ie, Me, Fe) {
      {
        var Ze = Function.call.bind(Io);
        for (var Xe in me)
          if (Ze(me, Xe)) {
            var at = void 0;
            try {
              if (typeof me[Xe] != "function") {
                var pt = Error((Me || "React class") + ": " + Ie + " type `" + Xe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof me[Xe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              at = me[Xe](ve, Xe, Me, Ie, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (wt) {
              at = wt;
            }
            at && !(at instanceof Error) && (x0(Fe), xe("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Me || "React class", Ie, Xe, typeof at), x0(null)), at instanceof Error && !(at.message in $S) && ($S[at.message] = !0, x0(Fe), xe("Failed %s type: %s", Ie, at.message), x0(null));
          }
      }
    }
    var o1 = [], S0;
    S0 = [];
    var Wd = -1;
    function zf(me) {
      return { current: me };
    }
    function Cs(me, ve) {
      if (Wd < 0) {
        xe("Unexpected pop.");
        return;
      }
      ve !== S0[Wd] && xe("Unexpected Fiber popped."), me.current = o1[Wd], o1[Wd] = null, S0[Wd] = null, Wd--;
    }
    function $s(me, ve, Ie) {
      Wd++, o1[Wd] = me.current, S0[Wd] = Ie, me.current = ve;
    }
    var a1;
    a1 = {};
    var Zu = {};
    Object.freeze(Zu);
    var qd = zf(Zu), qc = zf(!1), i1 = Zu;
    function Sy(me, ve, Ie) {
      return Ie && Zc(ve) ? i1 : qd.current;
    }
    function RS(me, ve, Ie) {
      {
        var Me = me.stateNode;
        Me.__reactInternalMemoizedUnmaskedChildContext = ve, Me.__reactInternalMemoizedMaskedChildContext = Ie;
      }
    }
    function Py(me, ve) {
      {
        var Ie = me.type, Me = Ie.contextTypes;
        if (!Me)
          return Zu;
        var Fe = me.stateNode;
        if (Fe && Fe.__reactInternalMemoizedUnmaskedChildContext === ve)
          return Fe.__reactInternalMemoizedMaskedChildContext;
        var Ze = {};
        for (var Xe in Me)
          Ze[Xe] = ve[Xe];
        {
          var at = Mr(me) || "Unknown";
          Zl(Me, Ze, "context", at);
        }
        return Fe && RS(me, ve, Ze), Ze;
      }
    }
    function O0() {
      return qc.current;
    }
    function Zc(me) {
      {
        var ve = me.childContextTypes;
        return ve != null;
      }
    }
    function C0(me) {
      Cs(qc, me), Cs(qd, me);
    }
    function s1(me) {
      Cs(qc, me), Cs(qd, me);
    }
    function NS(me, ve, Ie) {
      {
        if (qd.current !== Zu)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        $s(qd, ve, me), $s(qc, Ie, me);
      }
    }
    function MS(me, ve, Ie) {
      {
        var Me = me.stateNode, Fe = ve.childContextTypes;
        if (typeof Me.getChildContext != "function") {
          {
            var Ze = Mr(me) || "Unknown";
            a1[Ze] || (a1[Ze] = !0, xe("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", Ze, Ze));
          }
          return Ie;
        }
        var Xe = Me.getChildContext();
        for (var at in Xe)
          if (!(at in Fe))
            throw new Error((Mr(me) || "Unknown") + '.getChildContext(): key "' + at + '" is not defined in childContextTypes.');
        {
          var pt = Mr(me) || "Unknown";
          Zl(Fe, Xe, "child context", pt);
        }
        return Wr({}, Ie, Xe);
      }
    }
    function $0(me) {
      {
        var ve = me.stateNode, Ie = ve && ve.__reactInternalMemoizedMergedChildContext || Zu;
        return i1 = qd.current, $s(qd, Ie, me), $s(qc, qc.current, me), !0;
      }
    }
    function jS(me, ve, Ie) {
      {
        var Me = me.stateNode;
        if (!Me)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (Ie) {
          var Fe = MS(me, ve, i1);
          Me.__reactInternalMemoizedMergedChildContext = Fe, Cs(qc, me), Cs(qd, me), $s(qd, Fe, me), $s(qc, Ie, me);
        } else
          Cs(qc, me), $s(qc, Ie, me);
      }
    }
    function HC(me) {
      {
        if (!vb(me) || me.tag !== Re)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var ve = me;
        do {
          switch (ve.tag) {
            case je:
              return ve.stateNode.context;
            case Re: {
              var Ie = ve.type;
              if (Zc(Ie))
                return ve.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          ve = ve.return;
        } while (ve !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Uf = 0, I0 = 1, Zd = null, u1 = !1, l1 = !1;
    function DS(me) {
      Zd === null ? Zd = [me] : Zd.push(me);
    }
    function WC(me) {
      u1 = !0, DS(me);
    }
    function LS() {
      u1 && Vf();
    }
    function Vf() {
      if (!l1 && Zd !== null) {
        l1 = !0;
        var me = 0, ve = Gs();
        try {
          var Ie = !0, Me = Zd;
          for (ti(Os); me < Me.length; me++) {
            var Fe = Me[me];
            do
              Fe = Fe(Ie);
            while (Fe !== null);
          }
          Zd = null, u1 = !1;
        } catch (Ze) {
          throw Zd !== null && (Zd = Zd.slice(me + 1)), wm(Em, Vf), Ze;
        } finally {
          ti(ve), l1 = !1;
        }
      }
      return null;
    }
    var Ty = [], ky = 0, R0 = null, D0 = 0, fl = [], pl = 0, Jp = null, Gd = 1, Yd = "";
    function qC(me) {
      return ch(), (me.flags & mb) !== Sr;
    }
    function ZC(me) {
      return ch(), D0;
    }
    function GC() {
      var me = Yd, ve = Gd, Ie = ve & ~YC(ve);
      return Ie.toString(32) + me;
    }
    function oh(me, ve) {
      ch(), Ty[ky++] = D0, Ty[ky++] = R0, R0 = me, D0 = ve;
    }
    function FS(me, ve, Ie) {
      ch(), fl[pl++] = Gd, fl[pl++] = Yd, fl[pl++] = Jp, Jp = me;
      var Me = Gd, Fe = Yd, Ze = B0(Me) - 1, Xe = Me & ~(1 << Ze), at = Ie + 1, pt = B0(ve) + Ze;
      if (pt > 30) {
        var wt = Ze - Ze % 5, Ct = (1 << wt) - 1, Jt = (Xe & Ct).toString(32), Gt = Xe >> wt, pn = Ze - wt, yn = B0(ve) + pn, En = at << pn, Kn = En | Gt, vr = Jt + Fe;
        Gd = 1 << yn | Kn, Yd = vr;
      } else {
        var Or = at << Ze, co = Or | Xe, Xr = Fe;
        Gd = 1 << pt | co, Yd = Xr;
      }
    }
    function c1(me) {
      ch();
      var ve = me.return;
      if (ve !== null) {
        var Ie = 1, Me = 0;
        oh(me, Ie), FS(me, Ie, Me);
      }
    }
    function B0(me) {
      return 32 - Om(me);
    }
    function YC(me) {
      return 1 << B0(me) - 1;
    }
    function d1(me) {
      for (; me === R0; )
        R0 = Ty[--ky], Ty[ky] = null, D0 = Ty[--ky], Ty[ky] = null;
      for (; me === Jp; )
        Jp = fl[--pl], fl[pl] = null, Yd = fl[--pl], fl[pl] = null, Gd = fl[--pl], fl[pl] = null;
    }
    function QC() {
      return ch(), Jp !== null ? { id: Gd, overflow: Yd } : null;
    }
    function KC(me, ve) {
      ch(), fl[pl++] = Gd, fl[pl++] = Yd, fl[pl++] = Jp, Gd = ve.id, Yd = ve.overflow, Jp = me;
    }
    function ch() {
      os() || xe("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var rs = null, hl = null, Yl = !1, fh = !1, Hf = null;
    function XC() {
      Yl && xe("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function BS() {
      fh = !0;
    }
    function JC() {
      return fh;
    }
    function x$(me) {
      var ve = me.stateNode.containerInfo;
      return hl = vC(ve), rs = me, Yl = !0, Hf = null, fh = !1, !0;
    }
    function W$(me, ve, Ie) {
      return hl = gC(ve), rs = me, Yl = !0, Hf = null, fh = !1, Ie !== null && KC(me, Ie), !0;
    }
    function US(me, ve) {
      switch (me.tag) {
        case je: {
          AC(me.stateNode.containerInfo, ve);
          break;
        }
        case ze: {
          var Ie = (me.mode & oo) !== Tr;
          $C(me.type, me.memoizedProps, me.stateNode, ve, Ie);
          break;
        }
        case gt: {
          var Me = me.memoizedState;
          Me.dehydrated !== null && CC(Me.dehydrated, ve);
          break;
        }
      }
    }
    function VS(me, ve) {
      US(me, ve);
      var Ie = yM();
      Ie.stateNode = ve, Ie.return = me;
      var Me = me.deletions;
      Me === null ? (me.deletions = [Ie], me.flags |= ko) : Me.push(Ie);
    }
    function f1(me, ve) {
      {
        if (fh)
          return;
        switch (me.tag) {
          case je: {
            var Ie = me.stateNode.containerInfo;
            switch (ve.tag) {
              case ze:
                var Me = ve.type;
                ve.pendingProps, IC(Ie, Me);
                break;
              case He:
                var Fe = ve.pendingProps;
                RC(Ie, Fe);
                break;
            }
            break;
          }
          case ze: {
            var Ze = me.type, Xe = me.memoizedProps, at = me.stateNode;
            switch (ve.tag) {
              case ze: {
                var pt = ve.type, wt = ve.pendingProps, Ct = (me.mode & oo) !== Tr;
                jC(Ze, Xe, at, pt, wt, Ct);
                break;
              }
              case He: {
                var Jt = ve.pendingProps, Gt = (me.mode & oo) !== Tr;
                DC(Ze, Xe, at, Jt, Gt);
                break;
              }
            }
            break;
          }
          case gt: {
            var pn = me.memoizedState, yn = pn.dehydrated;
            if (yn !== null)
              switch (ve.tag) {
                case ze:
                  var En = ve.type;
                  ve.pendingProps, NC(yn, En);
                  break;
                case He:
                  var Kn = ve.pendingProps;
                  MC(yn, Kn);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function HS(me, ve) {
      ve.flags = ve.flags & ~du | Ko, f1(me, ve);
    }
    function ZS(me, ve) {
      switch (me.tag) {
        case ze: {
          var Ie = me.type;
          me.pendingProps;
          var Me = fC(ve, Ie);
          return Me !== null ? (me.stateNode = Me, rs = me, hl = bC(Me), !0) : !1;
        }
        case He: {
          var Fe = me.pendingProps, Ze = pC(ve, Fe);
          return Ze !== null ? (me.stateNode = Ze, rs = me, hl = null, !0) : !1;
        }
        case gt: {
          var Xe = hC(ve);
          if (Xe !== null) {
            var at = { dehydrated: Xe, treeContext: QC(), retryLane: Ts };
            me.memoizedState = at;
            var pt = bM(Xe);
            return pt.return = me, me.child = pt, rs = me, hl = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function p1(me) {
      return (me.mode & oo) !== Tr && (me.flags & Lr) === Sr;
    }
    function h1(me) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function m1(me) {
      if (Yl) {
        var ve = hl;
        if (!ve) {
          p1(me) && (f1(rs, me), h1()), HS(rs, me), Yl = !1, rs = me;
          return;
        }
        var Ie = ve;
        if (!ZS(me, ve)) {
          p1(me) && (f1(rs, me), h1()), ve = sv(Ie);
          var Me = rs;
          if (!ve || !ZS(me, ve)) {
            HS(rs, me), Yl = !1, rs = me;
            return;
          }
          VS(Me, Ie);
        }
      }
    }
    function Z$(me, ve, Ie) {
      var Me = me.stateNode, Fe = !fh, Ze = wC(Me, me.type, me.memoizedProps, ve, Ie, me, Fe);
      return me.updateQueue = Ze, Ze !== null;
    }
    function G$(me) {
      var ve = me.stateNode, Ie = me.memoizedProps, Me = _C(ve, Ie, me);
      if (Me) {
        var Fe = rs;
        if (Fe !== null)
          switch (Fe.tag) {
            case je: {
              var Ze = Fe.stateNode.containerInfo, Xe = (Fe.mode & oo) !== Tr;
              kC(Ze, ve, Ie, Xe);
              break;
            }
            case ze: {
              var at = Fe.type, pt = Fe.memoizedProps, wt = Fe.stateNode, Ct = (Fe.mode & oo) !== Tr;
              OC(at, pt, wt, ve, Ie, Ct);
              break;
            }
          }
      }
      return Me;
    }
    function Y$(me) {
      var ve = me.memoizedState, Ie = ve !== null ? ve.dehydrated : null;
      if (!Ie)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      EC(Ie, me);
    }
    function Q$(me) {
      var ve = me.memoizedState, Ie = ve !== null ? ve.dehydrated : null;
      if (!Ie)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return xC(Ie);
    }
    function YS(me) {
      for (var ve = me.return; ve !== null && ve.tag !== ze && ve.tag !== je && ve.tag !== gt; )
        ve = ve.return;
      rs = ve;
    }
    function V0(me) {
      if (me !== rs)
        return !1;
      if (!Yl)
        return YS(me), Yl = !0, !1;
      if (me.tag !== je && (me.tag !== ze || TC(me.type) && !Q_(me.type, me.memoizedProps))) {
        var ve = hl;
        if (ve)
          if (p1(me))
            QS(me), h1();
          else
            for (; ve; )
              VS(me, ve), ve = sv(ve);
      }
      return YS(me), me.tag === gt ? hl = Q$(me) : hl = rs ? sv(me.stateNode) : null, !0;
    }
    function K$() {
      return Yl && hl !== null;
    }
    function QS(me) {
      for (var ve = hl; ve; )
        US(me, ve), ve = sv(ve);
    }
    function Oy() {
      rs = null, hl = null, Yl = !1, fh = !1;
    }
    function KS() {
      Hf !== null && (u2(Hf), Hf = null);
    }
    function os() {
      return Yl;
    }
    function y1(me) {
      Hf === null ? Hf = [me] : Hf.push(me);
    }
    var X$ = fe.ReactCurrentBatchConfig, J$ = null;
    function tI() {
      return X$.transition;
    }
    var Ql = { recordUnsafeLifecycleWarnings: function(me, ve) {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function(me, ve) {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } };
    {
      var nI = function(me) {
        for (var ve = null, Ie = me; Ie !== null; )
          Ie.mode & fa && (ve = Ie), Ie = Ie.return;
        return ve;
      }, Zh = function(me) {
        var ve = [];
        return me.forEach(function(Ie) {
          ve.push(Ie);
        }), ve.sort().join(", ");
      }, dv = [], fv = [], pv = [], hv = [], mv = [], yv = [], Gh = /* @__PURE__ */ new Set();
      Ql.recordUnsafeLifecycleWarnings = function(me, ve) {
        Gh.has(me.type) || (typeof ve.componentWillMount == "function" && ve.componentWillMount.__suppressDeprecationWarning !== !0 && dv.push(me), me.mode & fa && typeof ve.UNSAFE_componentWillMount == "function" && fv.push(me), typeof ve.componentWillReceiveProps == "function" && ve.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && pv.push(me), me.mode & fa && typeof ve.UNSAFE_componentWillReceiveProps == "function" && hv.push(me), typeof ve.componentWillUpdate == "function" && ve.componentWillUpdate.__suppressDeprecationWarning !== !0 && mv.push(me), me.mode & fa && typeof ve.UNSAFE_componentWillUpdate == "function" && yv.push(me));
      }, Ql.flushPendingUnsafeLifecycleWarnings = function() {
        var me = /* @__PURE__ */ new Set();
        dv.length > 0 && (dv.forEach(function(Gt) {
          me.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), dv = []);
        var ve = /* @__PURE__ */ new Set();
        fv.length > 0 && (fv.forEach(function(Gt) {
          ve.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), fv = []);
        var Ie = /* @__PURE__ */ new Set();
        pv.length > 0 && (pv.forEach(function(Gt) {
          Ie.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), pv = []);
        var Me = /* @__PURE__ */ new Set();
        hv.length > 0 && (hv.forEach(function(Gt) {
          Me.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), hv = []);
        var Fe = /* @__PURE__ */ new Set();
        mv.length > 0 && (mv.forEach(function(Gt) {
          Fe.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), mv = []);
        var Ze = /* @__PURE__ */ new Set();
        if (yv.length > 0 && (yv.forEach(function(Gt) {
          Ze.add(Mr(Gt) || "Component"), Gh.add(Gt.type);
        }), yv = []), ve.size > 0) {
          var Xe = Zh(ve);
          xe(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Xe);
        }
        if (Me.size > 0) {
          var at = Zh(Me);
          xe(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, at);
        }
        if (Ze.size > 0) {
          var pt = Zh(Ze);
          xe(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, pt);
        }
        if (me.size > 0) {
          var wt = Zh(me);
          _e(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, wt);
        }
        if (Ie.size > 0) {
          var Ct = Zh(Ie);
          _e(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ct);
        }
        if (Fe.size > 0) {
          var Jt = Zh(Fe);
          _e(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Jt);
        }
      };
      var H0 = /* @__PURE__ */ new Map(), XS = /* @__PURE__ */ new Set();
      Ql.recordLegacyContextWarning = function(me, ve) {
        var Ie = nI(me);
        if (Ie === null) {
          xe("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!XS.has(me.type)) {
          var Me = H0.get(Ie);
          (me.type.contextTypes != null || me.type.childContextTypes != null || ve !== null && typeof ve.getChildContext == "function") && (Me === void 0 && (Me = [], H0.set(Ie, Me)), Me.push(me));
        }
      }, Ql.flushLegacyContextWarning = function() {
        H0.forEach(function(me, ve) {
          if (me.length !== 0) {
            var Ie = me[0], Me = /* @__PURE__ */ new Set();
            me.forEach(function(Ze) {
              Me.add(Mr(Ze) || "Component"), XS.add(Ze.type);
            });
            var Fe = Zh(Me);
            try {
              mo(Ie), xe(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Fe);
            } finally {
              Qo();
            }
          }
        });
      }, Ql.discardPendingWarnings = function() {
        dv = [], fv = [], pv = [], hv = [], mv = [], yv = [], H0 = /* @__PURE__ */ new Map();
      };
    }
    function Xl(me, ve) {
      if (me && me.defaultProps) {
        var Ie = Wr({}, ve), Me = me.defaultProps;
        for (var Fe in Me)
          Ie[Fe] === void 0 && (Ie[Fe] = Me[Fe]);
        return Ie;
      }
      return ve;
    }
    var b1 = zf(null), v1;
    v1 = {};
    var W0 = null, Ay = null, g1 = null, q0 = !1;
    function Z0() {
      W0 = null, Ay = null, g1 = null, q0 = !1;
    }
    function PP() {
      q0 = !0;
    }
    function kP() {
      q0 = !1;
    }
    function AP(me, ve, Ie) {
      $s(b1, ve._currentValue, me), ve._currentValue = Ie, ve._currentRenderer !== void 0 && ve._currentRenderer !== null && ve._currentRenderer !== v1 && xe("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), ve._currentRenderer = v1;
    }
    function w1(me, ve) {
      var Ie = b1.current;
      Cs(b1, ve), me._currentValue = Ie;
    }
    function _1(me, ve, Ie) {
      for (var Me = me; Me !== null; ) {
        var Fe = Me.alternate;
        if (Rd(Me.childLanes, ve) ? Fe !== null && !Rd(Fe.childLanes, ve) && (Fe.childLanes = Zr(Fe.childLanes, ve)) : (Me.childLanes = Zr(Me.childLanes, ve), Fe !== null && (Fe.childLanes = Zr(Fe.childLanes, ve))), Me === Ie)
          break;
        Me = Me.return;
      }
      Me !== Ie && xe("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function rI(me, ve, Ie) {
      oI(me, ve, Ie);
    }
    function oI(me, ve, Ie) {
      var Me = me.child;
      for (Me !== null && (Me.return = me); Me !== null; ) {
        var Fe = void 0, Ze = Me.dependencies;
        if (Ze !== null) {
          Fe = Me.child;
          for (var Xe = Ze.firstContext; Xe !== null; ) {
            if (Xe.context === ve) {
              if (Me.tag === Re) {
                var at = ei(Ie), pt = Xd(Vo, at);
                pt.tag = Q0;
                var wt = Me.updateQueue;
                if (wt !== null) {
                  var Ct = wt.shared, Jt = Ct.pending;
                  Jt === null ? pt.next = pt : (pt.next = Jt.next, Jt.next = pt), Ct.pending = pt;
                }
              }
              Me.lanes = Zr(Me.lanes, Ie);
              var Gt = Me.alternate;
              Gt !== null && (Gt.lanes = Zr(Gt.lanes, Ie)), _1(Me.return, Ie, me), Ze.lanes = Zr(Ze.lanes, Ie);
              break;
            }
            Xe = Xe.next;
          }
        } else if (Me.tag === tt)
          Fe = Me.type === me.type ? null : Me.child;
        else if (Me.tag === Vt) {
          var pn = Me.return;
          if (pn === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          pn.lanes = Zr(pn.lanes, Ie);
          var yn = pn.alternate;
          yn !== null && (yn.lanes = Zr(yn.lanes, Ie)), _1(pn, Ie, me), Fe = Me.sibling;
        } else
          Fe = Me.child;
        if (Fe !== null)
          Fe.return = Me;
        else
          for (Fe = Me; Fe !== null; ) {
            if (Fe === me) {
              Fe = null;
              break;
            }
            var En = Fe.sibling;
            if (En !== null) {
              En.return = Fe.return, Fe = En;
              break;
            }
            Fe = Fe.return;
          }
        Me = Fe;
      }
    }
    function Cy(me, ve) {
      W0 = me, Ay = null, g1 = null;
      var Ie = me.dependencies;
      if (Ie !== null) {
        var Me = Ie.firstContext;
        Me !== null && (ks(Ie.lanes, ve) && Cv(), Ie.firstContext = null);
      }
    }
    function vi(me) {
      q0 && xe("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var ve = me._currentValue;
      if (g1 !== me) {
        var Ie = { context: me, memoizedValue: ve, next: null };
        if (Ay === null) {
          if (W0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Ay = Ie, W0.dependencies = { lanes: xn, firstContext: Ie };
        } else
          Ay = Ay.next = Ie;
      }
      return ve;
    }
    var Qh = null;
    function E1(me) {
      Qh === null ? Qh = [me] : Qh.push(me);
    }
    function aI() {
      if (Qh !== null) {
        for (var me = 0; me < Qh.length; me++) {
          var ve = Qh[me], Ie = ve.interleaved;
          if (Ie !== null) {
            ve.interleaved = null;
            var Me = Ie.next, Fe = ve.pending;
            if (Fe !== null) {
              var Ze = Fe.next;
              Fe.next = Me, Ie.next = Ze;
            }
            ve.pending = Ie;
          }
        }
        Qh = null;
      }
    }
    function $P(me, ve, Ie, Me) {
      var Fe = ve.interleaved;
      return Fe === null ? (Ie.next = Ie, E1(ve)) : (Ie.next = Fe.next, Fe.next = Ie), ve.interleaved = Ie, Y0(me, Me);
    }
    function iI(me, ve, Ie, Me) {
      var Fe = ve.interleaved;
      Fe === null ? (Ie.next = Ie, E1(ve)) : (Ie.next = Fe.next, Fe.next = Ie), ve.interleaved = Ie;
    }
    function sI(me, ve, Ie, Me) {
      var Fe = ve.interleaved;
      return Fe === null ? (Ie.next = Ie, E1(ve)) : (Ie.next = Fe.next, Fe.next = Ie), ve.interleaved = Ie, Y0(me, Me);
    }
    function Su(me, ve) {
      return Y0(me, ve);
    }
    var uI = Y0;
    function Y0(me, ve) {
      me.lanes = Zr(me.lanes, ve);
      var Ie = me.alternate;
      Ie !== null && (Ie.lanes = Zr(Ie.lanes, ve)), Ie === null && (me.flags & (Ko | du)) !== Sr && _2(me);
      for (var Me = me, Fe = me.return; Fe !== null; )
        Fe.childLanes = Zr(Fe.childLanes, ve), Ie = Fe.alternate, Ie !== null ? Ie.childLanes = Zr(Ie.childLanes, ve) : (Fe.flags & (Ko | du)) !== Sr && _2(me), Me = Fe, Fe = Fe.return;
      if (Me.tag === je) {
        var Ze = Me.stateNode;
        return Ze;
      } else
        return null;
    }
    var IP = 0, NP = 1, Q0 = 2, x1 = 3, K0 = !1, S1, X0;
    S1 = !1, X0 = null;
    function P1(me) {
      var ve = { baseState: me.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: xn }, effects: null };
      me.updateQueue = ve;
    }
    function MP(me, ve) {
      var Ie = ve.updateQueue, Me = me.updateQueue;
      if (Ie === Me) {
        var Fe = { baseState: Me.baseState, firstBaseUpdate: Me.firstBaseUpdate, lastBaseUpdate: Me.lastBaseUpdate, shared: Me.shared, effects: Me.effects };
        ve.updateQueue = Fe;
      }
    }
    function Xd(me, ve) {
      var Ie = { eventTime: me, lane: ve, tag: IP, payload: null, callback: null, next: null };
      return Ie;
    }
    function Wf(me, ve, Ie) {
      var Me = me.updateQueue;
      if (Me === null)
        return null;
      var Fe = Me.shared;
      if (X0 === Fe && !S1 && (xe("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), S1 = !0), ON()) {
        var Ze = Fe.pending;
        return Ze === null ? ve.next = ve : (ve.next = Ze.next, Ze.next = ve), Fe.pending = ve, uI(me, Ie);
      } else
        return sI(me, Fe, ve, Ie);
    }
    function J0(me, ve, Ie) {
      var Me = ve.updateQueue;
      if (Me !== null) {
        var Fe = Me.shared;
        if ($b(Ie)) {
          var Ze = Fe.lanes;
          Ze = Rb(Ze, me.pendingLanes);
          var Xe = Zr(Ze, Ie);
          Fe.lanes = Xe, Mp(me, Xe);
        }
      }
    }
    function T1(me, ve) {
      var Ie = me.updateQueue, Me = me.alternate;
      if (Me !== null) {
        var Fe = Me.updateQueue;
        if (Ie === Fe) {
          var Ze = null, Xe = null, at = Ie.firstBaseUpdate;
          if (at !== null) {
            var pt = at;
            do {
              var wt = { eventTime: pt.eventTime, lane: pt.lane, tag: pt.tag, payload: pt.payload, callback: pt.callback, next: null };
              Xe === null ? Ze = Xe = wt : (Xe.next = wt, Xe = wt), pt = pt.next;
            } while (pt !== null);
            Xe === null ? Ze = Xe = ve : (Xe.next = ve, Xe = ve);
          } else
            Ze = Xe = ve;
          Ie = { baseState: Fe.baseState, firstBaseUpdate: Ze, lastBaseUpdate: Xe, shared: Fe.shared, effects: Fe.effects }, me.updateQueue = Ie;
          return;
        }
      }
      var Ct = Ie.lastBaseUpdate;
      Ct === null ? Ie.firstBaseUpdate = ve : Ct.next = ve, Ie.lastBaseUpdate = ve;
    }
    function lI(me, ve, Ie, Me, Fe, Ze) {
      switch (Ie.tag) {
        case NP: {
          var Xe = Ie.payload;
          if (typeof Xe == "function") {
            PP();
            var at = Xe.call(Ze, Me, Fe);
            {
              if (me.mode & fa) {
                Xa(!0);
                try {
                  Xe.call(Ze, Me, Fe);
                } finally {
                  Xa(!1);
                }
              }
              kP();
            }
            return at;
          }
          return Xe;
        }
        case x1:
          me.flags = me.flags & ~mi | Lr;
        case IP: {
          var pt = Ie.payload, wt;
          if (typeof pt == "function") {
            PP(), wt = pt.call(Ze, Me, Fe);
            {
              if (me.mode & fa) {
                Xa(!0);
                try {
                  pt.call(Ze, Me, Fe);
                } finally {
                  Xa(!1);
                }
              }
              kP();
            }
          } else
            wt = pt;
          return wt == null ? Me : Wr({}, Me, wt);
        }
        case Q0:
          return K0 = !0, Me;
      }
      return Me;
    }
    function ew(me, ve, Ie, Me) {
      var Fe = me.updateQueue;
      K0 = !1, X0 = Fe.shared;
      var Ze = Fe.firstBaseUpdate, Xe = Fe.lastBaseUpdate, at = Fe.shared.pending;
      if (at !== null) {
        Fe.shared.pending = null;
        var pt = at, wt = pt.next;
        pt.next = null, Xe === null ? Ze = wt : Xe.next = wt, Xe = pt;
        var Ct = me.alternate;
        if (Ct !== null) {
          var Jt = Ct.updateQueue, Gt = Jt.lastBaseUpdate;
          Gt !== Xe && (Gt === null ? Jt.firstBaseUpdate = wt : Gt.next = wt, Jt.lastBaseUpdate = pt);
        }
      }
      if (Ze !== null) {
        var pn = Fe.baseState, yn = xn, En = null, Kn = null, vr = null, Or = Ze;
        do {
          var co = Or.lane, Xr = Or.eventTime;
          if (Rd(Me, co)) {
            if (vr !== null) {
              var rn = { eventTime: Xr, lane: yo, tag: Or.tag, payload: Or.payload, callback: Or.callback, next: null };
              vr = vr.next = rn;
            }
            pn = lI(me, Fe, Or, pn, ve, Ie);
            var wn = Or.callback;
            if (wn !== null && Or.lane !== yo) {
              me.flags |= sl;
              var an = Fe.effects;
              an === null ? Fe.effects = [Or] : an.push(Or);
            }
          } else {
            var Bn = { eventTime: Xr, lane: co, tag: Or.tag, payload: Or.payload, callback: Or.callback, next: null };
            vr === null ? (Kn = vr = Bn, En = pn) : vr = vr.next = Bn, yn = Zr(yn, co);
          }
          if (Or = Or.next, Or === null) {
            if (at = Fe.shared.pending, at === null)
              break;
            var nr = at, Xn = nr.next;
            nr.next = null, Or = Xn, Fe.lastBaseUpdate = nr, Fe.shared.pending = null;
          }
        } while (!0);
        vr === null && (En = pn), Fe.baseState = En, Fe.firstBaseUpdate = Kn, Fe.lastBaseUpdate = vr;
        var jr = Fe.shared.interleaved;
        if (jr !== null) {
          var Hr = jr;
          do
            yn = Zr(yn, Hr.lane), Hr = Hr.next;
          while (Hr !== jr);
        } else
          Ze === null && (Fe.shared.lanes = xn);
        zv(yn), me.lanes = yn, me.memoizedState = pn;
      }
      X0 = null;
    }
    function cI(me, ve) {
      if (typeof me != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + me));
      me.call(ve);
    }
    function jP() {
      K0 = !1;
    }
    function tw() {
      return K0;
    }
    function DP(me, ve, Ie) {
      var Me = ve.effects;
      if (ve.effects = null, Me !== null)
        for (var Fe = 0; Fe < Me.length; Fe++) {
          var Ze = Me[Fe], Xe = Ze.callback;
          Xe !== null && (Ze.callback = null, cI(Xe, Ie));
        }
    }
    var k1 = {}, LP = new oe.Component().refs, O1, A1, C1, $1, I1, FP, nw, R1, N1, M1;
    {
      O1 = /* @__PURE__ */ new Set(), A1 = /* @__PURE__ */ new Set(), C1 = /* @__PURE__ */ new Set(), $1 = /* @__PURE__ */ new Set(), R1 = /* @__PURE__ */ new Set(), I1 = /* @__PURE__ */ new Set(), N1 = /* @__PURE__ */ new Set(), M1 = /* @__PURE__ */ new Set();
      var BP = /* @__PURE__ */ new Set();
      nw = function(me, ve) {
        if (!(me === null || typeof me == "function")) {
          var Ie = ve + "_" + me;
          BP.has(Ie) || (BP.add(Ie), xe("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve, me));
        }
      }, FP = function(me, ve) {
        if (ve === void 0) {
          var Ie = ho(me) || "Component";
          I1.has(Ie) || (I1.add(Ie), xe("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", Ie));
        }
      }, Object.defineProperty(k1, "_processChildContext", { enumerable: !1, value: function() {
        throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
      } }), Object.freeze(k1);
    }
    function j1(me, ve, Ie, Me) {
      var Fe = me.memoizedState, Ze = Ie(Me, Fe);
      {
        if (me.mode & fa) {
          Xa(!0);
          try {
            Ze = Ie(Me, Fe);
          } finally {
            Xa(!1);
          }
        }
        FP(ve, Ze);
      }
      var Xe = Ze == null ? Fe : Wr({}, Fe, Ze);
      if (me.memoizedState = Xe, me.lanes === xn) {
        var at = me.updateQueue;
        at.baseState = Xe;
      }
    }
    var D1 = { isMounted: Ws, enqueueSetState: function(me, ve, Ie) {
      var Me = lu(me), Fe = eu(), Ze = Jf(Me), Xe = Xd(Fe, Ze);
      Xe.payload = ve, Ie != null && (nw(Ie, "setState"), Xe.callback = Ie);
      var at = Wf(Me, Xe, Ze);
      at !== null && (Fi(at, Me, Ze, Fe), J0(at, Me, Ze)), Nc(Me, Ze);
    }, enqueueReplaceState: function(me, ve, Ie) {
      var Me = lu(me), Fe = eu(), Ze = Jf(Me), Xe = Xd(Fe, Ze);
      Xe.tag = NP, Xe.payload = ve, Ie != null && (nw(Ie, "replaceState"), Xe.callback = Ie);
      var at = Wf(Me, Xe, Ze);
      at !== null && (Fi(at, Me, Ze, Fe), J0(at, Me, Ze)), Nc(Me, Ze);
    }, enqueueForceUpdate: function(me, ve) {
      var Ie = lu(me), Me = eu(), Fe = Jf(Ie), Ze = Xd(Me, Fe);
      Ze.tag = Q0, ve != null && (nw(ve, "forceUpdate"), Ze.callback = ve);
      var Xe = Wf(Ie, Ze, Fe);
      Xe !== null && (Fi(Xe, Ie, Fe, Me), J0(Xe, Ie, Fe)), kb(Ie, Fe);
    } };
    function zP(me, ve, Ie, Me, Fe, Ze, Xe) {
      var at = me.stateNode;
      if (typeof at.shouldComponentUpdate == "function") {
        var pt = at.shouldComponentUpdate(Me, Ze, Xe);
        {
          if (me.mode & fa) {
            Xa(!0);
            try {
              pt = at.shouldComponentUpdate(Me, Ze, Xe);
            } finally {
              Xa(!1);
            }
          }
          pt === void 0 && xe("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", ho(ve) || "Component");
        }
        return pt;
      }
      return ve.prototype && ve.prototype.isPureReactComponent ? !xr(Ie, Me) || !xr(Fe, Ze) : !0;
    }
    function fI(me, ve, Ie) {
      var Me = me.stateNode;
      {
        var Fe = ho(ve) || "Component", Ze = Me.render;
        Ze || (ve.prototype && typeof ve.prototype.render == "function" ? xe("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", Fe) : xe("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", Fe)), Me.getInitialState && !Me.getInitialState.isReactClassApproved && !Me.state && xe("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", Fe), Me.getDefaultProps && !Me.getDefaultProps.isReactClassApproved && xe("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", Fe), Me.propTypes && xe("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", Fe), Me.contextType && xe("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", Fe), Me.contextTypes && xe("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", Fe), ve.contextType && ve.contextTypes && !N1.has(ve) && (N1.add(ve), xe("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", Fe)), typeof Me.componentShouldUpdate == "function" && xe("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", Fe), ve.prototype && ve.prototype.isPureReactComponent && typeof Me.shouldComponentUpdate < "u" && xe("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ho(ve) || "A pure component"), typeof Me.componentDidUnmount == "function" && xe("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", Fe), typeof Me.componentDidReceiveProps == "function" && xe("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", Fe), typeof Me.componentWillRecieveProps == "function" && xe("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", Fe), typeof Me.UNSAFE_componentWillRecieveProps == "function" && xe("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", Fe);
        var Xe = Me.props !== Ie;
        Me.props !== void 0 && Xe && xe("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", Fe, Fe), Me.defaultProps && xe("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", Fe, Fe), typeof Me.getSnapshotBeforeUpdate == "function" && typeof Me.componentDidUpdate != "function" && !C1.has(ve) && (C1.add(ve), xe("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ho(ve))), typeof Me.getDerivedStateFromProps == "function" && xe("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Fe), typeof Me.getDerivedStateFromError == "function" && xe("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Fe), typeof ve.getSnapshotBeforeUpdate == "function" && xe("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", Fe);
        var at = Me.state;
        at && (typeof at != "object" || No(at)) && xe("%s.state: must be set to an object or null", Fe), typeof Me.getChildContext == "function" && typeof ve.childContextTypes != "object" && xe("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", Fe);
      }
    }
    function UP(me, ve) {
      ve.updater = D1, me.stateNode = ve, bf(ve, me), ve._reactInternalInstance = k1;
    }
    function VP(me, ve, Ie) {
      var Me = !1, Fe = Zu, Ze = Zu, Xe = ve.contextType;
      if ("contextType" in ve) {
        var at = Xe === null || Xe !== void 0 && Xe.$$typeof === Pn && Xe._context === void 0;
        if (!at && !M1.has(ve)) {
          M1.add(ve);
          var pt = "";
          Xe === void 0 ? pt = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Xe != "object" ? pt = " However, it is set to a " + typeof Xe + "." : Xe.$$typeof === Cn ? pt = " Did you accidentally pass the Context.Provider instead?" : Xe._context !== void 0 ? pt = " Did you accidentally pass the Context.Consumer instead?" : pt = " However, it is set to an object with keys {" + Object.keys(Xe).join(", ") + "}.", xe("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ho(ve) || "Component", pt);
        }
      }
      if (typeof Xe == "object" && Xe !== null)
        Ze = vi(Xe);
      else {
        Fe = Sy(me, ve, !0);
        var wt = ve.contextTypes;
        Me = wt != null, Ze = Me ? Py(me, Fe) : Zu;
      }
      var Ct = new ve(Ie, Ze);
      if (me.mode & fa) {
        Xa(!0);
        try {
          Ct = new ve(Ie, Ze);
        } finally {
          Xa(!1);
        }
      }
      var Jt = me.memoizedState = Ct.state !== null && Ct.state !== void 0 ? Ct.state : null;
      UP(me, Ct);
      {
        if (typeof ve.getDerivedStateFromProps == "function" && Jt === null) {
          var Gt = ho(ve) || "Component";
          A1.has(Gt) || (A1.add(Gt), xe("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Gt, Ct.state === null ? "null" : "undefined", Gt));
        }
        if (typeof ve.getDerivedStateFromProps == "function" || typeof Ct.getSnapshotBeforeUpdate == "function") {
          var pn = null, yn = null, En = null;
          if (typeof Ct.componentWillMount == "function" && Ct.componentWillMount.__suppressDeprecationWarning !== !0 ? pn = "componentWillMount" : typeof Ct.UNSAFE_componentWillMount == "function" && (pn = "UNSAFE_componentWillMount"), typeof Ct.componentWillReceiveProps == "function" && Ct.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? yn = "componentWillReceiveProps" : typeof Ct.UNSAFE_componentWillReceiveProps == "function" && (yn = "UNSAFE_componentWillReceiveProps"), typeof Ct.componentWillUpdate == "function" && Ct.componentWillUpdate.__suppressDeprecationWarning !== !0 ? En = "componentWillUpdate" : typeof Ct.UNSAFE_componentWillUpdate == "function" && (En = "UNSAFE_componentWillUpdate"), pn !== null || yn !== null || En !== null) {
            var Kn = ho(ve) || "Component", vr = typeof ve.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            $1.has(Kn) || ($1.add(Kn), xe(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Kn, vr, pn !== null ? `
  ` + pn : "", yn !== null ? `
  ` + yn : "", En !== null ? `
  ` + En : ""));
          }
        }
      }
      return Me && RS(me, Fe, Ze), Ct;
    }
    function pI(me, ve) {
      var Ie = ve.state;
      typeof ve.componentWillMount == "function" && ve.componentWillMount(), typeof ve.UNSAFE_componentWillMount == "function" && ve.UNSAFE_componentWillMount(), Ie !== ve.state && (xe("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Mr(me) || "Component"), D1.enqueueReplaceState(ve, ve.state, null));
    }
    function HP(me, ve, Ie, Me) {
      var Fe = ve.state;
      if (typeof ve.componentWillReceiveProps == "function" && ve.componentWillReceiveProps(Ie, Me), typeof ve.UNSAFE_componentWillReceiveProps == "function" && ve.UNSAFE_componentWillReceiveProps(Ie, Me), ve.state !== Fe) {
        {
          var Ze = Mr(me) || "Component";
          O1.has(Ze) || (O1.add(Ze), xe("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ze));
        }
        D1.enqueueReplaceState(ve, ve.state, null);
      }
    }
    function L1(me, ve, Ie, Me) {
      fI(me, ve, Ie);
      var Fe = me.stateNode;
      Fe.props = Ie, Fe.state = me.memoizedState, Fe.refs = LP, P1(me);
      var Ze = ve.contextType;
      if (typeof Ze == "object" && Ze !== null)
        Fe.context = vi(Ze);
      else {
        var Xe = Sy(me, ve, !0);
        Fe.context = Py(me, Xe);
      }
      {
        if (Fe.state === Ie) {
          var at = ho(ve) || "Component";
          R1.has(at) || (R1.add(at), xe("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", at));
        }
        me.mode & fa && Ql.recordLegacyContextWarning(me, Fe), Ql.recordUnsafeLifecycleWarnings(me, Fe);
      }
      Fe.state = me.memoizedState;
      var pt = ve.getDerivedStateFromProps;
      if (typeof pt == "function" && (j1(me, ve, pt, Ie), Fe.state = me.memoizedState), typeof ve.getDerivedStateFromProps != "function" && typeof Fe.getSnapshotBeforeUpdate != "function" && (typeof Fe.UNSAFE_componentWillMount == "function" || typeof Fe.componentWillMount == "function") && (pI(me, Fe), ew(me, Ie, Fe, Me), Fe.state = me.memoizedState), typeof Fe.componentDidMount == "function") {
        var wt = qr;
        wt |= _s, (me.mode & hu) !== Tr && (wt |= Es), me.flags |= wt;
      }
    }
    function mI(me, ve, Ie, Me) {
      var Fe = me.stateNode, Ze = me.memoizedProps;
      Fe.props = Ze;
      var Xe = Fe.context, at = ve.contextType, pt = Zu;
      if (typeof at == "object" && at !== null)
        pt = vi(at);
      else {
        var wt = Sy(me, ve, !0);
        pt = Py(me, wt);
      }
      var Ct = ve.getDerivedStateFromProps, Jt = typeof Ct == "function" || typeof Fe.getSnapshotBeforeUpdate == "function";
      !Jt && (typeof Fe.UNSAFE_componentWillReceiveProps == "function" || typeof Fe.componentWillReceiveProps == "function") && (Ze !== Ie || Xe !== pt) && HP(me, Fe, Ie, pt), jP();
      var Gt = me.memoizedState, pn = Fe.state = Gt;
      if (ew(me, Ie, Fe, Me), pn = me.memoizedState, Ze === Ie && Gt === pn && !O0() && !tw()) {
        if (typeof Fe.componentDidMount == "function") {
          var yn = qr;
          yn |= _s, (me.mode & hu) !== Tr && (yn |= Es), me.flags |= yn;
        }
        return !1;
      }
      typeof Ct == "function" && (j1(me, ve, Ct, Ie), pn = me.memoizedState);
      var En = tw() || zP(me, ve, Ze, Ie, Gt, pn, pt);
      if (En) {
        if (!Jt && (typeof Fe.UNSAFE_componentWillMount == "function" || typeof Fe.componentWillMount == "function") && (typeof Fe.componentWillMount == "function" && Fe.componentWillMount(), typeof Fe.UNSAFE_componentWillMount == "function" && Fe.UNSAFE_componentWillMount()), typeof Fe.componentDidMount == "function") {
          var Kn = qr;
          Kn |= _s, (me.mode & hu) !== Tr && (Kn |= Es), me.flags |= Kn;
        }
      } else {
        if (typeof Fe.componentDidMount == "function") {
          var vr = qr;
          vr |= _s, (me.mode & hu) !== Tr && (vr |= Es), me.flags |= vr;
        }
        me.memoizedProps = Ie, me.memoizedState = pn;
      }
      return Fe.props = Ie, Fe.state = pn, Fe.context = pt, En;
    }
    function yI(me, ve, Ie, Me, Fe) {
      var Ze = ve.stateNode;
      MP(me, ve);
      var Xe = ve.memoizedProps, at = ve.type === ve.elementType ? Xe : Xl(ve.type, Xe);
      Ze.props = at;
      var pt = ve.pendingProps, wt = Ze.context, Ct = Ie.contextType, Jt = Zu;
      if (typeof Ct == "object" && Ct !== null)
        Jt = vi(Ct);
      else {
        var Gt = Sy(ve, Ie, !0);
        Jt = Py(ve, Gt);
      }
      var pn = Ie.getDerivedStateFromProps, yn = typeof pn == "function" || typeof Ze.getSnapshotBeforeUpdate == "function";
      !yn && (typeof Ze.UNSAFE_componentWillReceiveProps == "function" || typeof Ze.componentWillReceiveProps == "function") && (Xe !== pt || wt !== Jt) && HP(ve, Ze, Me, Jt), jP();
      var En = ve.memoizedState, Kn = Ze.state = En;
      if (ew(ve, Me, Ze, Fe), Kn = ve.memoizedState, Xe === pt && En === Kn && !O0() && !tw() && !Dn)
        return typeof Ze.componentDidUpdate == "function" && (Xe !== me.memoizedProps || En !== me.memoizedState) && (ve.flags |= qr), typeof Ze.getSnapshotBeforeUpdate == "function" && (Xe !== me.memoizedProps || En !== me.memoizedState) && (ve.flags |= cu), !1;
      typeof pn == "function" && (j1(ve, Ie, pn, Me), Kn = ve.memoizedState);
      var vr = tw() || zP(ve, Ie, at, Me, En, Kn, Jt) || Dn;
      return vr ? (!yn && (typeof Ze.UNSAFE_componentWillUpdate == "function" || typeof Ze.componentWillUpdate == "function") && (typeof Ze.componentWillUpdate == "function" && Ze.componentWillUpdate(Me, Kn, Jt), typeof Ze.UNSAFE_componentWillUpdate == "function" && Ze.UNSAFE_componentWillUpdate(Me, Kn, Jt)), typeof Ze.componentDidUpdate == "function" && (ve.flags |= qr), typeof Ze.getSnapshotBeforeUpdate == "function" && (ve.flags |= cu)) : (typeof Ze.componentDidUpdate == "function" && (Xe !== me.memoizedProps || En !== me.memoizedState) && (ve.flags |= qr), typeof Ze.getSnapshotBeforeUpdate == "function" && (Xe !== me.memoizedProps || En !== me.memoizedState) && (ve.flags |= cu), ve.memoizedProps = Me, ve.memoizedState = Kn), Ze.props = Me, Ze.state = Kn, Ze.context = Jt, vr;
    }
    var F1, B1, z1, U1, V1, WP = function(me, ve) {
    };
    F1 = !1, B1 = !1, z1 = {}, U1 = {}, V1 = {}, WP = function(me, ve) {
      if (!(me === null || typeof me != "object") && !(!me._store || me._store.validated || me.key != null)) {
        if (typeof me._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        me._store.validated = !0;
        var Ie = Mr(ve) || "Component";
        U1[Ie] || (U1[Ie] = !0, xe('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function bv(me, ve, Ie) {
      var Me = Ie.ref;
      if (Me !== null && typeof Me != "function" && typeof Me != "object") {
        if ((me.mode & fa || Zt) && !(Ie._owner && Ie._self && Ie._owner.stateNode !== Ie._self)) {
          var Fe = Mr(me) || "Component";
          z1[Fe] || (xe('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Me), z1[Fe] = !0);
        }
        if (Ie._owner) {
          var Ze = Ie._owner, Xe;
          if (Ze) {
            var at = Ze;
            if (at.tag !== Re)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Xe = at.stateNode;
          }
          if (!Xe)
            throw new Error("Missing owner for string ref " + Me + ". This error is likely caused by a bug in React. Please file an issue.");
          var pt = Xe;
          Fo(Me, "ref");
          var wt = "" + Me;
          if (ve !== null && ve.ref !== null && typeof ve.ref == "function" && ve.ref._stringRef === wt)
            return ve.ref;
          var Ct = function(Jt) {
            var Gt = pt.refs;
            Gt === LP && (Gt = pt.refs = {}), Jt === null ? delete Gt[wt] : Gt[wt] = Jt;
          };
          return Ct._stringRef = wt, Ct;
        } else {
          if (typeof Me != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!Ie._owner)
            throw new Error("Element ref was specified as a string (" + Me + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return Me;
    }
    function rw(me, ve) {
      var Ie = Object.prototype.toString.call(ve);
      throw new Error("Objects are not valid as a React child (found: " + (Ie === "[object Object]" ? "object with keys {" + Object.keys(ve).join(", ") + "}" : Ie) + "). If you meant to render a collection of children, use an array instead.");
    }
    function ow(me) {
      {
        var ve = Mr(me) || "Component";
        if (V1[ve])
          return;
        V1[ve] = !0, xe("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function qP(me) {
      var ve = me._payload, Ie = me._init;
      return Ie(ve);
    }
    function ZP(me) {
      function ve(rn, wn) {
        if (me) {
          var an = rn.deletions;
          an === null ? (rn.deletions = [wn], rn.flags |= ko) : an.push(wn);
        }
      }
      function Ie(rn, wn) {
        if (!me)
          return null;
        for (var an = wn; an !== null; )
          ve(rn, an), an = an.sibling;
        return null;
      }
      function Me(rn, wn) {
        for (var an = /* @__PURE__ */ new Map(), Bn = wn; Bn !== null; )
          Bn.key !== null ? an.set(Bn.key, Bn) : an.set(Bn.index, Bn), Bn = Bn.sibling;
        return an;
      }
      function Fe(rn, wn) {
        var an = om(rn, wn);
        return an.index = 0, an.sibling = null, an;
      }
      function Ze(rn, wn, an) {
        if (rn.index = an, !me)
          return rn.flags |= mb, wn;
        var Bn = rn.alternate;
        if (Bn !== null) {
          var nr = Bn.index;
          return nr < wn ? (rn.flags |= Ko, wn) : nr;
        } else
          return rn.flags |= Ko, wn;
      }
      function Xe(rn) {
        return me && rn.alternate === null && (rn.flags |= Ko), rn;
      }
      function at(rn, wn, an, Bn) {
        if (wn === null || wn.tag !== He) {
          var nr = Dx(an, rn.mode, Bn);
          return nr.return = rn, nr;
        } else {
          var Xn = Fe(wn, an);
          return Xn.return = rn, Xn;
        }
      }
      function pt(rn, wn, an, Bn) {
        var nr = an.type;
        if (nr === oa)
          return Ct(rn, wn, an.props.children, Bn, an.key);
        if (wn !== null && (wn.elementType === nr || P2(wn, an) || typeof nr == "object" && nr !== null && nr.$$typeof === gr && qP(nr) === wn.type)) {
          var Xn = Fe(wn, an.props);
          return Xn.ref = bv(rn, wn, an), Xn.return = rn, Xn._debugSource = an._source, Xn._debugOwner = an._owner, Xn;
        }
        var jr = jx(an, rn.mode, Bn);
        return jr.ref = bv(rn, wn, an), jr.return = rn, jr;
      }
      function wt(rn, wn, an, Bn) {
        if (wn === null || wn.tag !== Be || wn.stateNode.containerInfo !== an.containerInfo || wn.stateNode.implementation !== an.implementation) {
          var nr = Lx(an, rn.mode, Bn);
          return nr.return = rn, nr;
        } else {
          var Xn = Fe(wn, an.children || []);
          return Xn.return = rn, Xn;
        }
      }
      function Ct(rn, wn, an, Bn, nr) {
        if (wn === null || wn.tag !== qe) {
          var Xn = tp(an, rn.mode, Bn, nr);
          return Xn.return = rn, Xn;
        } else {
          var jr = Fe(wn, an);
          return jr.return = rn, jr;
        }
      }
      function Jt(rn, wn, an) {
        if (typeof wn == "string" && wn !== "" || typeof wn == "number") {
          var Bn = Dx("" + wn, rn.mode, an);
          return Bn.return = rn, Bn;
        }
        if (typeof wn == "object" && wn !== null) {
          switch (wn.$$typeof) {
            case fo: {
              var nr = jx(wn, rn.mode, an);
              return nr.ref = bv(rn, null, wn), nr.return = rn, nr;
            }
            case _o: {
              var Xn = Lx(wn, rn.mode, an);
              return Xn.return = rn, Xn;
            }
            case gr: {
              var jr = wn._payload, Hr = wn._init;
              return Jt(rn, Hr(jr), an);
            }
          }
          if (No(wn) || Yi(wn)) {
            var Lo = tp(wn, rn.mode, an, null);
            return Lo.return = rn, Lo;
          }
          rw(rn, wn);
        }
        return typeof wn == "function" && ow(rn), null;
      }
      function Gt(rn, wn, an, Bn) {
        var nr = wn !== null ? wn.key : null;
        if (typeof an == "string" && an !== "" || typeof an == "number")
          return nr !== null ? null : at(rn, wn, "" + an, Bn);
        if (typeof an == "object" && an !== null) {
          switch (an.$$typeof) {
            case fo:
              return an.key === nr ? pt(rn, wn, an, Bn) : null;
            case _o:
              return an.key === nr ? wt(rn, wn, an, Bn) : null;
            case gr: {
              var Xn = an._payload, jr = an._init;
              return Gt(rn, wn, jr(Xn), Bn);
            }
          }
          if (No(an) || Yi(an))
            return nr !== null ? null : Ct(rn, wn, an, Bn, null);
          rw(rn, an);
        }
        return typeof an == "function" && ow(rn), null;
      }
      function pn(rn, wn, an, Bn, nr) {
        if (typeof Bn == "string" && Bn !== "" || typeof Bn == "number") {
          var Xn = rn.get(an) || null;
          return at(wn, Xn, "" + Bn, nr);
        }
        if (typeof Bn == "object" && Bn !== null) {
          switch (Bn.$$typeof) {
            case fo: {
              var jr = rn.get(Bn.key === null ? an : Bn.key) || null;
              return pt(wn, jr, Bn, nr);
            }
            case _o: {
              var Hr = rn.get(Bn.key === null ? an : Bn.key) || null;
              return wt(wn, Hr, Bn, nr);
            }
            case gr:
              var Lo = Bn._payload, xo = Bn._init;
              return pn(rn, wn, an, xo(Lo), nr);
          }
          if (No(Bn) || Yi(Bn)) {
            var ii = rn.get(an) || null;
            return Ct(wn, ii, Bn, nr, null);
          }
          rw(wn, Bn);
        }
        return typeof Bn == "function" && ow(wn), null;
      }
      function yn(rn, wn, an) {
        {
          if (typeof rn != "object" || rn === null)
            return wn;
          switch (rn.$$typeof) {
            case fo:
            case _o:
              WP(rn, an);
              var Bn = rn.key;
              if (typeof Bn != "string")
                break;
              if (wn === null) {
                wn = /* @__PURE__ */ new Set(), wn.add(Bn);
                break;
              }
              if (!wn.has(Bn)) {
                wn.add(Bn);
                break;
              }
              xe("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Bn);
              break;
            case gr:
              var nr = rn._payload, Xn = rn._init;
              yn(Xn(nr), wn, an);
              break;
          }
        }
        return wn;
      }
      function En(rn, wn, an, Bn) {
        for (var nr = null, Xn = 0; Xn < an.length; Xn++) {
          var jr = an[Xn];
          nr = yn(jr, nr, rn);
        }
        for (var Hr = null, Lo = null, xo = wn, ii = 0, So = 0, Va = null; xo !== null && So < an.length; So++) {
          xo.index > So ? (Va = xo, xo = null) : Va = xo.sibling;
          var Rs = Gt(rn, xo, an[So], Bn);
          if (Rs === null) {
            xo === null && (xo = Va);
            break;
          }
          me && xo && Rs.alternate === null && ve(rn, xo), ii = Ze(Rs, ii, So), Lo === null ? Hr = Rs : Lo.sibling = Rs, Lo = Rs, xo = Va;
        }
        if (So === an.length) {
          if (Ie(rn, xo), os()) {
            var hs = So;
            oh(rn, hs);
          }
          return Hr;
        }
        if (xo === null) {
          for (; So < an.length; So++) {
            var Yu = Jt(rn, an[So], Bn);
            Yu !== null && (ii = Ze(Yu, ii, So), Lo === null ? Hr = Yu : Lo.sibling = Yu, Lo = Yu);
          }
          if (os()) {
            var tu = So;
            oh(rn, tu);
          }
          return Hr;
        }
        for (var nu = Me(rn, xo); So < an.length; So++) {
          var Ns = pn(nu, rn, So, an[So], Bn);
          Ns !== null && (me && Ns.alternate !== null && nu.delete(Ns.key === null ? So : Ns.key), ii = Ze(Ns, ii, So), Lo === null ? Hr = Ns : Lo.sibling = Ns, Lo = Ns);
        }
        if (me && nu.forEach(function(Zy) {
          return ve(rn, Zy);
        }), os()) {
          var af = So;
          oh(rn, af);
        }
        return Hr;
      }
      function Kn(rn, wn, an, Bn) {
        var nr = Yi(an);
        if (typeof nr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && an[Symbol.toStringTag] === "Generator" && (B1 || xe("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), B1 = !0), an.entries === nr && (F1 || xe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), F1 = !0);
          var Xn = nr.call(an);
          if (Xn)
            for (var jr = null, Hr = Xn.next(); !Hr.done; Hr = Xn.next()) {
              var Lo = Hr.value;
              jr = yn(Lo, jr, rn);
            }
        }
        var xo = nr.call(an);
        if (xo == null)
          throw new Error("An iterable object provided no iterator.");
        for (var ii = null, So = null, Va = wn, Rs = 0, hs = 0, Yu = null, tu = xo.next(); Va !== null && !tu.done; hs++, tu = xo.next()) {
          Va.index > hs ? (Yu = Va, Va = null) : Yu = Va.sibling;
          var nu = Gt(rn, Va, tu.value, Bn);
          if (nu === null) {
            Va === null && (Va = Yu);
            break;
          }
          me && Va && nu.alternate === null && ve(rn, Va), Rs = Ze(nu, Rs, hs), So === null ? ii = nu : So.sibling = nu, So = nu, Va = Yu;
        }
        if (tu.done) {
          if (Ie(rn, Va), os()) {
            var Ns = hs;
            oh(rn, Ns);
          }
          return ii;
        }
        if (Va === null) {
          for (; !tu.done; hs++, tu = xo.next()) {
            var af = Jt(rn, tu.value, Bn);
            af !== null && (Rs = Ze(af, Rs, hs), So === null ? ii = af : So.sibling = af, So = af);
          }
          if (os()) {
            var Zy = hs;
            oh(rn, Zy);
          }
          return ii;
        }
        for (var qv = Me(rn, Va); !tu.done; hs++, tu = xo.next()) {
          var td = pn(qv, rn, hs, tu.value, Bn);
          td !== null && (me && td.alternate !== null && qv.delete(td.key === null ? hs : td.key), Rs = Ze(td, Rs, hs), So === null ? ii = td : So.sibling = td, So = td);
        }
        if (me && qv.forEach(function(GM) {
          return ve(rn, GM);
        }), os()) {
          var ZM = hs;
          oh(rn, ZM);
        }
        return ii;
      }
      function vr(rn, wn, an, Bn) {
        if (wn !== null && wn.tag === He) {
          Ie(rn, wn.sibling);
          var nr = Fe(wn, an);
          return nr.return = rn, nr;
        }
        Ie(rn, wn);
        var Xn = Dx(an, rn.mode, Bn);
        return Xn.return = rn, Xn;
      }
      function Or(rn, wn, an, Bn) {
        for (var nr = an.key, Xn = wn; Xn !== null; ) {
          if (Xn.key === nr) {
            var jr = an.type;
            if (jr === oa) {
              if (Xn.tag === qe) {
                Ie(rn, Xn.sibling);
                var Hr = Fe(Xn, an.props.children);
                return Hr.return = rn, Hr._debugSource = an._source, Hr._debugOwner = an._owner, Hr;
              }
            } else if (Xn.elementType === jr || P2(Xn, an) || typeof jr == "object" && jr !== null && jr.$$typeof === gr && qP(jr) === Xn.type) {
              Ie(rn, Xn.sibling);
              var Lo = Fe(Xn, an.props);
              return Lo.ref = bv(rn, Xn, an), Lo.return = rn, Lo._debugSource = an._source, Lo._debugOwner = an._owner, Lo;
            }
            Ie(rn, Xn);
            break;
          } else
            ve(rn, Xn);
          Xn = Xn.sibling;
        }
        if (an.type === oa) {
          var xo = tp(an.props.children, rn.mode, Bn, an.key);
          return xo.return = rn, xo;
        } else {
          var ii = jx(an, rn.mode, Bn);
          return ii.ref = bv(rn, wn, an), ii.return = rn, ii;
        }
      }
      function co(rn, wn, an, Bn) {
        for (var nr = an.key, Xn = wn; Xn !== null; ) {
          if (Xn.key === nr)
            if (Xn.tag === Be && Xn.stateNode.containerInfo === an.containerInfo && Xn.stateNode.implementation === an.implementation) {
              Ie(rn, Xn.sibling);
              var jr = Fe(Xn, an.children || []);
              return jr.return = rn, jr;
            } else {
              Ie(rn, Xn);
              break;
            }
          else
            ve(rn, Xn);
          Xn = Xn.sibling;
        }
        var Hr = Lx(an, rn.mode, Bn);
        return Hr.return = rn, Hr;
      }
      function Xr(rn, wn, an, Bn) {
        var nr = typeof an == "object" && an !== null && an.type === oa && an.key === null;
        if (nr && (an = an.props.children), typeof an == "object" && an !== null) {
          switch (an.$$typeof) {
            case fo:
              return Xe(Or(rn, wn, an, Bn));
            case _o:
              return Xe(co(rn, wn, an, Bn));
            case gr:
              var Xn = an._payload, jr = an._init;
              return Xr(rn, wn, jr(Xn), Bn);
          }
          if (No(an))
            return En(rn, wn, an, Bn);
          if (Yi(an))
            return Kn(rn, wn, an, Bn);
          rw(rn, an);
        }
        return typeof an == "string" && an !== "" || typeof an == "number" ? Xe(vr(rn, wn, "" + an, Bn)) : (typeof an == "function" && ow(rn), Ie(rn, wn));
      }
      return Xr;
    }
    var $y = ZP(!0), GP = ZP(!1);
    function bI(me, ve) {
      if (me !== null && ve.child !== me.child)
        throw new Error("Resuming work not yet implemented.");
      if (ve.child !== null) {
        var Ie = ve.child, Me = om(Ie, Ie.pendingProps);
        for (ve.child = Me, Me.return = ve; Ie.sibling !== null; )
          Ie = Ie.sibling, Me = Me.sibling = om(Ie, Ie.pendingProps), Me.return = ve;
        Me.sibling = null;
      }
    }
    function vI(me, ve) {
      for (var Ie = me.child; Ie !== null; )
        dM(Ie, ve), Ie = Ie.sibling;
    }
    var vv = {}, qf = zf(vv), gv = zf(vv), aw = zf(vv);
    function iw(me) {
      if (me === vv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return me;
    }
    function YP() {
      var me = iw(aw.current);
      return me;
    }
    function H1(me, ve) {
      $s(aw, ve, me), $s(gv, me, me), $s(qf, vv, me);
      var Ie = YO(ve);
      Cs(qf, me), $s(qf, Ie, me);
    }
    function Iy(me) {
      Cs(qf, me), Cs(gv, me), Cs(aw, me);
    }
    function W1() {
      var me = iw(qf.current);
      return me;
    }
    function QP(me) {
      iw(aw.current);
      var ve = iw(qf.current), Ie = QO(ve, me.type);
      ve !== Ie && ($s(gv, me, me), $s(qf, Ie, me));
    }
    function q1(me) {
      gv.current === me && (Cs(qf, me), Cs(gv, me));
    }
    var gI = 0, KP = 1, XP = 1, wv = 2, Jl = zf(gI);
    function Z1(me, ve) {
      return (me & ve) !== 0;
    }
    function Ry(me) {
      return me & KP;
    }
    function G1(me, ve) {
      return me & KP | ve;
    }
    function wI(me, ve) {
      return me | ve;
    }
    function Zf(me, ve) {
      $s(Jl, ve, me);
    }
    function Ny(me) {
      Cs(Jl, me);
    }
    function _I(me, ve) {
      var Ie = me.memoizedState;
      return Ie !== null ? Ie.dehydrated !== null : (me.memoizedProps, !0);
    }
    function sw(me) {
      for (var ve = me; ve !== null; ) {
        if (ve.tag === gt) {
          var Ie = ve.memoizedState;
          if (Ie !== null) {
            var Me = Ie.dehydrated;
            if (Me === null || kS(Me) || e1(Me))
              return ve;
          }
        } else if (ve.tag === on && ve.memoizedProps.revealOrder !== void 0) {
          var Fe = (ve.flags & Lr) !== Sr;
          if (Fe)
            return ve;
        } else if (ve.child !== null) {
          ve.child.return = ve, ve = ve.child;
          continue;
        }
        if (ve === me)
          return null;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === me)
            return null;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
      return null;
    }
    var Pu = 0, Ii = 1, Gc = 2, Ri = 4, as = 8, Y1 = [];
    function Q1() {
      for (var me = 0; me < Y1.length; me++) {
        var ve = Y1[me];
        ve._workInProgressVersionPrimary = null;
      }
      Y1.length = 0;
    }
    function EI(me, ve) {
      var Ie = ve._getVersion, Me = Ie(ve._source);
      me.mutableSourceEagerHydrationData == null ? me.mutableSourceEagerHydrationData = [ve, Me] : me.mutableSourceEagerHydrationData.push(ve, Me);
    }
    var tr = fe.ReactCurrentDispatcher, _v = fe.ReactCurrentBatchConfig, K1, My;
    K1 = /* @__PURE__ */ new Set();
    var Kh = xn, jo = null, Ni = null, Mi = null, uw = !1, Ev = !1, xv = 0, PI = 0, kI = 25, Sn = null, ml = null, Gf = -1, X1 = !1;
    function $o() {
      {
        var me = Sn;
        ml === null ? ml = [me] : ml.push(me);
      }
    }
    function Yn() {
      {
        var me = Sn;
        ml !== null && (Gf++, ml[Gf] !== me && OI(me));
      }
    }
    function jy(me) {
      me != null && !No(me) && xe("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Sn, typeof me);
    }
    function OI(me) {
      {
        var ve = Mr(jo);
        if (!K1.has(ve) && (K1.add(ve), ml !== null)) {
          for (var Ie = "", Me = 30, Fe = 0; Fe <= Gf; Fe++) {
            for (var Ze = ml[Fe], Xe = Fe === Gf ? me : Ze, at = Fe + 1 + ". " + Ze; at.length < Me; )
              at += " ";
            at += Xe + `
`, Ie += at;
          }
          xe(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, ve, Ie);
        }
      }
    }
    function Is() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function J1(me, ve) {
      if (X1)
        return !1;
      if (ve === null)
        return xe("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Sn), !1;
      me.length !== ve.length && xe(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Sn, "[" + ve.join(", ") + "]", "[" + me.join(", ") + "]");
      for (var Ie = 0; Ie < ve.length && Ie < me.length; Ie++)
        if (!Jn(me[Ie], ve[Ie]))
          return !1;
      return !0;
    }
    function Dy(me, ve, Ie, Me, Fe, Ze) {
      Kh = Ze, jo = ve, ml = me !== null ? me._debugHookTypes : null, Gf = -1, X1 = me !== null && me.type !== ve.type, ve.memoizedState = null, ve.updateQueue = null, ve.lanes = xn, me !== null && me.memoizedState !== null ? tr.current = wT : ml !== null ? tr.current = gT : tr.current = vT;
      var Xe = Ie(Me, Fe);
      if (Ev) {
        var at = 0;
        do {
          if (Ev = !1, xv = 0, at >= kI)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          at += 1, X1 = !1, Ni = null, Mi = null, ve.updateQueue = null, Gf = -1, tr.current = _T, Xe = Ie(Me, Fe);
        } while (Ev);
      }
      tr.current = Ew, ve._debugHookTypes = ml;
      var pt = Ni !== null && Ni.next !== null;
      if (Kh = xn, jo = null, Ni = null, Mi = null, Sn = null, ml = null, Gf = -1, me !== null && (me.flags & xi) !== (ve.flags & xi) && (me.mode & oo) !== Tr && xe("Internal React error: Expected static flag was missing. Please notify the React team."), uw = !1, pt)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Xe;
    }
    function Ly() {
      var me = xv !== 0;
      return xv = 0, me;
    }
    function JP(me, ve, Ie) {
      ve.updateQueue = me.updateQueue, (ve.mode & hu) !== Tr ? ve.flags &= ~(_d | Es | sa | qr) : ve.flags &= ~(sa | qr), me.lanes = Tf(me.lanes, Ie);
    }
    function eT() {
      if (tr.current = Ew, uw) {
        for (var me = jo.memoizedState; me !== null; ) {
          var ve = me.queue;
          ve !== null && (ve.pending = null), me = me.next;
        }
        uw = !1;
      }
      Kh = xn, jo = null, Ni = null, Mi = null, ml = null, Gf = -1, Sn = null, pT = !1, Ev = !1, xv = 0;
    }
    function Yc() {
      var me = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Mi === null ? jo.memoizedState = Mi = me : Mi = Mi.next = me, Mi;
    }
    function yl() {
      var me;
      if (Ni === null) {
        var ve = jo.alternate;
        ve !== null ? me = ve.memoizedState : me = null;
      } else
        me = Ni.next;
      var Ie;
      if (Mi === null ? Ie = jo.memoizedState : Ie = Mi.next, Ie !== null)
        Mi = Ie, Ie = Mi.next, Ni = me;
      else {
        if (me === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ni = me;
        var Me = { memoizedState: Ni.memoizedState, baseState: Ni.baseState, baseQueue: Ni.baseQueue, queue: Ni.queue, next: null };
        Mi === null ? jo.memoizedState = Mi = Me : Mi = Mi.next = Me;
      }
      return Mi;
    }
    function tT() {
      return { lastEffect: null, stores: null };
    }
    function eE(me, ve) {
      return typeof ve == "function" ? ve(me) : ve;
    }
    function tE(me, ve, Ie) {
      var Me = Yc(), Fe;
      Ie !== void 0 ? Fe = Ie(ve) : Fe = ve, Me.memoizedState = Me.baseState = Fe;
      var Ze = { pending: null, interleaved: null, lanes: xn, dispatch: null, lastRenderedReducer: me, lastRenderedState: Fe };
      Me.queue = Ze;
      var Xe = Ze.dispatch = BI.bind(null, jo, Ze);
      return [Me.memoizedState, Xe];
    }
    function nE(me, ve, Ie) {
      var Me = yl(), Fe = Me.queue;
      if (Fe === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Fe.lastRenderedReducer = me;
      var Ze = Ni, Xe = Ze.baseQueue, at = Fe.pending;
      if (at !== null) {
        if (Xe !== null) {
          var pt = Xe.next, wt = at.next;
          Xe.next = wt, at.next = pt;
        }
        Ze.baseQueue !== Xe && xe("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), Ze.baseQueue = Xe = at, Fe.pending = null;
      }
      if (Xe !== null) {
        var Ct = Xe.next, Jt = Ze.baseState, Gt = null, pn = null, yn = null, En = Ct;
        do {
          var Kn = En.lane;
          if (Rd(Kh, Kn)) {
            if (yn !== null) {
              var vr = { lane: yo, action: En.action, hasEagerState: En.hasEagerState, eagerState: En.eagerState, next: null };
              yn = yn.next = vr;
            }
            if (En.hasEagerState)
              Jt = En.eagerState;
            else {
              var Or = En.action;
              Jt = me(Jt, Or);
            }
          } else {
            var co = { lane: Kn, action: En.action, hasEagerState: En.hasEagerState, eagerState: En.eagerState, next: null };
            yn === null ? (pn = yn = co, Gt = Jt) : yn = yn.next = co, jo.lanes = Zr(jo.lanes, Kn), zv(Kn);
          }
          En = En.next;
        } while (En !== null && En !== Ct);
        yn === null ? Gt = Jt : yn.next = pn, Jn(Jt, Me.memoizedState) || Cv(), Me.memoizedState = Jt, Me.baseState = Gt, Me.baseQueue = yn, Fe.lastRenderedState = Jt;
      }
      var Xr = Fe.interleaved;
      if (Xr !== null) {
        var rn = Xr;
        do {
          var wn = rn.lane;
          jo.lanes = Zr(jo.lanes, wn), zv(wn), rn = rn.next;
        } while (rn !== Xr);
      } else
        Xe === null && (Fe.lanes = xn);
      var an = Fe.dispatch;
      return [Me.memoizedState, an];
    }
    function rE(me, ve, Ie) {
      var Me = yl(), Fe = Me.queue;
      if (Fe === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Fe.lastRenderedReducer = me;
      var Ze = Fe.dispatch, Xe = Fe.pending, at = Me.memoizedState;
      if (Xe !== null) {
        Fe.pending = null;
        var pt = Xe.next, wt = pt;
        do {
          var Ct = wt.action;
          at = me(at, Ct), wt = wt.next;
        } while (wt !== pt);
        Jn(at, Me.memoizedState) || Cv(), Me.memoizedState = at, Me.baseQueue === null && (Me.baseState = at), Fe.lastRenderedState = at;
      }
      return [at, Ze];
    }
    function oE(me, ve, Ie) {
      var Me = jo, Fe = Yc(), Ze, Xe = os();
      if (Xe) {
        if (Ie === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        Ze = Ie(), My || Ze !== Ie() && (xe("The result of getServerSnapshot should be cached to avoid an infinite loop"), My = !0);
      } else {
        if (Ze = ve(), !My) {
          var at = ve();
          Jn(Ze, at) || (xe("The result of getSnapshot should be cached to avoid an infinite loop"), My = !0);
        }
        var pt = zw();
        if (pt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Np(pt, Kh) || nT(Me, ve, Ze);
      }
      Fe.memoizedState = Ze;
      var wt = { value: Ze, getSnapshot: ve };
      return Fe.queue = wt, hw(oT.bind(null, Me, wt, me), [me]), Me.flags |= sa, Sv(Ii | as, rT.bind(null, Me, wt, Ze, ve), void 0, null), Ze;
    }
    function lw(me, ve, Ie) {
      var Me = jo, Fe = yl(), Ze = ve();
      if (!My) {
        var Xe = ve();
        Jn(Ze, Xe) || (xe("The result of getSnapshot should be cached to avoid an infinite loop"), My = !0);
      }
      var at = Fe.memoizedState, pt = !Jn(at, Ze);
      pt && (Fe.memoizedState = Ze, Cv());
      var wt = Fe.queue;
      if (Tv(oT.bind(null, Me, wt, me), [me]), wt.getSnapshot !== ve || pt || Mi !== null && Mi.memoizedState.tag & Ii) {
        Me.flags |= sa, Sv(Ii | as, rT.bind(null, Me, wt, Ze, ve), void 0, null);
        var Ct = zw();
        if (Ct === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Np(Ct, Kh) || nT(Me, ve, Ze);
      }
      return Ze;
    }
    function nT(me, ve, Ie) {
      me.flags |= Sp;
      var Me = { getSnapshot: ve, value: Ie }, Fe = jo.updateQueue;
      if (Fe === null)
        Fe = tT(), jo.updateQueue = Fe, Fe.stores = [Me];
      else {
        var Ze = Fe.stores;
        Ze === null ? Fe.stores = [Me] : Ze.push(Me);
      }
    }
    function rT(me, ve, Ie, Me) {
      ve.value = Ie, ve.getSnapshot = Me, aT(ve) && iT(me);
    }
    function oT(me, ve, Ie) {
      var Me = function() {
        aT(ve) && iT(me);
      };
      return Ie(Me);
    }
    function aT(me) {
      var ve = me.getSnapshot, Ie = me.value;
      try {
        var Me = ve();
        return !Jn(Ie, Me);
      } catch {
        return !0;
      }
    }
    function iT(me) {
      var ve = Su(me, Nr);
      ve !== null && Fi(ve, me, Nr, Vo);
    }
    function cw(me) {
      var ve = Yc();
      typeof me == "function" && (me = me()), ve.memoizedState = ve.baseState = me;
      var Ie = { pending: null, interleaved: null, lanes: xn, dispatch: null, lastRenderedReducer: eE, lastRenderedState: me };
      ve.queue = Ie;
      var Me = Ie.dispatch = UI.bind(null, jo, Ie);
      return [ve.memoizedState, Me];
    }
    function aE(me) {
      return nE(eE);
    }
    function iE(me) {
      return rE(eE);
    }
    function Sv(me, ve, Ie, Me) {
      var Fe = { tag: me, create: ve, destroy: Ie, deps: Me, next: null }, Ze = jo.updateQueue;
      if (Ze === null)
        Ze = tT(), jo.updateQueue = Ze, Ze.lastEffect = Fe.next = Fe;
      else {
        var Xe = Ze.lastEffect;
        if (Xe === null)
          Ze.lastEffect = Fe.next = Fe;
        else {
          var at = Xe.next;
          Xe.next = Fe, Fe.next = at, Ze.lastEffect = Fe;
        }
      }
      return Fe;
    }
    function sE(me) {
      var ve = Yc();
      {
        var Ie = { current: me };
        return ve.memoizedState = Ie, Ie;
      }
    }
    function fw(me) {
      var ve = yl();
      return ve.memoizedState;
    }
    function Pv(me, ve, Ie, Me) {
      var Fe = Yc(), Ze = Me === void 0 ? null : Me;
      jo.flags |= me, Fe.memoizedState = Sv(Ii | ve, Ie, void 0, Ze);
    }
    function pw(me, ve, Ie, Me) {
      var Fe = yl(), Ze = Me === void 0 ? null : Me, Xe = void 0;
      if (Ni !== null) {
        var at = Ni.memoizedState;
        if (Xe = at.destroy, Ze !== null) {
          var pt = at.deps;
          if (J1(Ze, pt)) {
            Fe.memoizedState = Sv(ve, Ie, Xe, Ze);
            return;
          }
        }
      }
      jo.flags |= me, Fe.memoizedState = Sv(Ii | ve, Ie, Xe, Ze);
    }
    function hw(me, ve) {
      return (jo.mode & hu) !== Tr ? Pv(_d | sa | wc, as, me, ve) : Pv(sa | wc, as, me, ve);
    }
    function Tv(me, ve) {
      return pw(sa, as, me, ve);
    }
    function uE(me, ve) {
      return Pv(qr, Gc, me, ve);
    }
    function mw(me, ve) {
      return pw(qr, Gc, me, ve);
    }
    function lE(me, ve) {
      var Ie = qr;
      return Ie |= _s, (jo.mode & hu) !== Tr && (Ie |= Es), Pv(Ie, Ri, me, ve);
    }
    function yw(me, ve) {
      return pw(qr, Ri, me, ve);
    }
    function sT(me, ve) {
      if (typeof ve == "function") {
        var Ie = ve, Me = me();
        return Ie(Me), function() {
          Ie(null);
        };
      } else if (ve != null) {
        var Fe = ve;
        Fe.hasOwnProperty("current") || xe("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(Fe).join(", ") + "}");
        var Ze = me();
        return Fe.current = Ze, function() {
          Fe.current = null;
        };
      }
    }
    function cE(me, ve, Ie) {
      typeof ve != "function" && xe("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ve !== null ? typeof ve : "null");
      var Me = Ie != null ? Ie.concat([me]) : null, Fe = qr;
      return Fe |= _s, (jo.mode & hu) !== Tr && (Fe |= Es), Pv(Fe, Ri, sT.bind(null, ve, me), Me);
    }
    function bw(me, ve, Ie) {
      typeof ve != "function" && xe("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ve !== null ? typeof ve : "null");
      var Me = Ie != null ? Ie.concat([me]) : null;
      return pw(qr, Ri, sT.bind(null, ve, me), Me);
    }
    function CI(me, ve) {
    }
    var vw = CI;
    function dE(me, ve) {
      var Ie = Yc(), Me = ve === void 0 ? null : ve;
      return Ie.memoizedState = [me, Me], me;
    }
    function gw(me, ve) {
      var Ie = yl(), Me = ve === void 0 ? null : ve, Fe = Ie.memoizedState;
      if (Fe !== null && Me !== null) {
        var Ze = Fe[1];
        if (J1(Me, Ze))
          return Fe[0];
      }
      return Ie.memoizedState = [me, Me], me;
    }
    function fE(me, ve) {
      var Ie = Yc(), Me = ve === void 0 ? null : ve, Fe = me();
      return Ie.memoizedState = [Fe, Me], Fe;
    }
    function ww(me, ve) {
      var Ie = yl(), Me = ve === void 0 ? null : ve, Fe = Ie.memoizedState;
      if (Fe !== null && Me !== null) {
        var Ze = Fe[1];
        if (J1(Me, Ze))
          return Fe[0];
      }
      var Xe = me();
      return Ie.memoizedState = [Xe, Me], Xe;
    }
    function pE(me) {
      var ve = Yc();
      return ve.memoizedState = me, me;
    }
    function uT(me) {
      var ve = yl(), Ie = Ni, Me = Ie.memoizedState;
      return cT(ve, Me, me);
    }
    function lT(me) {
      var ve = yl();
      if (Ni === null)
        return ve.memoizedState = me, me;
      var Ie = Ni.memoizedState;
      return cT(ve, Ie, me);
    }
    function cT(me, ve, Ie) {
      var Me = !__(Kh);
      if (Me) {
        if (!Jn(Ie, ve)) {
          var Fe = Ib();
          jo.lanes = Zr(jo.lanes, Fe), zv(Fe), me.baseState = !0;
        }
        return ve;
      } else
        return me.baseState && (me.baseState = !1, Cv()), me.memoizedState = Ie, Ie;
    }
    function $I(me, ve, Ie) {
      var Me = Gs();
      ti(jp(Me, yu)), me(!0);
      var Fe = _v.transition;
      _v.transition = {};
      var Ze = _v.transition;
      _v.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        me(!1), ve();
      } finally {
        if (ti(Me), _v.transition = Fe, Fe === null && Ze._updatedFibers) {
          var Xe = Ze._updatedFibers.size;
          Xe > 10 && _e("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ze._updatedFibers.clear();
        }
      }
    }
    function hE() {
      var me = cw(!1), ve = me[0], Ie = me[1], Me = $I.bind(null, Ie), Fe = Yc();
      return Fe.memoizedState = Me, [ve, Me];
    }
    function dT() {
      var me = aE(), ve = me[0], Ie = yl(), Me = Ie.memoizedState;
      return [ve, Me];
    }
    function fT() {
      var me = iE(), ve = me[0], Ie = yl(), Me = Ie.memoizedState;
      return [ve, Me];
    }
    var pT = !1;
    function II() {
      return pT;
    }
    function mE() {
      var me = Yc(), ve = zw(), Ie = ve.identifierPrefix, Me;
      if (os()) {
        var Fe = GC();
        Me = ":" + Ie + "R" + Fe;
        var Ze = xv++;
        Ze > 0 && (Me += "H" + Ze.toString(32)), Me += ":";
      } else {
        var Xe = PI++;
        Me = ":" + Ie + "r" + Xe.toString(32) + ":";
      }
      return me.memoizedState = Me, Me;
    }
    function _w() {
      var me = yl(), ve = me.memoizedState;
      return ve;
    }
    function BI(me, ve, Ie) {
      typeof arguments[3] == "function" && xe("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Me = Jf(me), Fe = { lane: Me, action: Ie, hasEagerState: !1, eagerState: null, next: null };
      if (hT(me))
        mT(ve, Fe);
      else {
        var Ze = $P(me, ve, Fe, Me);
        if (Ze !== null) {
          var Xe = eu();
          Fi(Ze, me, Me, Xe), yT(Ze, ve, Me);
        }
      }
      bT(me, Me);
    }
    function UI(me, ve, Ie) {
      typeof arguments[3] == "function" && xe("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Me = Jf(me), Fe = { lane: Me, action: Ie, hasEagerState: !1, eagerState: null, next: null };
      if (hT(me))
        mT(ve, Fe);
      else {
        var Ze = me.alternate;
        if (me.lanes === xn && (Ze === null || Ze.lanes === xn)) {
          var Xe = ve.lastRenderedReducer;
          if (Xe !== null) {
            var at;
            at = tr.current, tr.current = ec;
            try {
              var pt = ve.lastRenderedState, wt = Xe(pt, Ie);
              if (Fe.hasEagerState = !0, Fe.eagerState = wt, Jn(wt, pt)) {
                iI(me, ve, Fe, Me);
                return;
              }
            } catch {
            } finally {
              tr.current = at;
            }
          }
        }
        var Ct = $P(me, ve, Fe, Me);
        if (Ct !== null) {
          var Jt = eu();
          Fi(Ct, me, Me, Jt), yT(Ct, ve, Me);
        }
      }
      bT(me, Me);
    }
    function hT(me) {
      var ve = me.alternate;
      return me === jo || ve !== null && ve === jo;
    }
    function mT(me, ve) {
      Ev = uw = !0;
      var Ie = me.pending;
      Ie === null ? ve.next = ve : (ve.next = Ie.next, Ie.next = ve), me.pending = ve;
    }
    function yT(me, ve, Ie) {
      if ($b(Ie)) {
        var Me = ve.lanes;
        Me = Rb(Me, me.pendingLanes);
        var Fe = Zr(Me, Ie);
        ve.lanes = Fe, Mp(me, Fe);
      }
    }
    function bT(me, ve, Ie) {
      Nc(me, ve);
    }
    var Ew = { readContext: vi, useCallback: Is, useContext: Is, useEffect: Is, useImperativeHandle: Is, useInsertionEffect: Is, useLayoutEffect: Is, useMemo: Is, useReducer: Is, useRef: Is, useState: Is, useDebugValue: Is, useDeferredValue: Is, useTransition: Is, useMutableSource: Is, useSyncExternalStore: Is, useId: Is, unstable_isNewReconciler: kn }, vT = null, gT = null, wT = null, _T = null, Qc = null, ec = null, xw = null;
    {
      var yE = function() {
        xe("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Ur = function() {
        xe("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      vT = { readContext: function(me) {
        return vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", $o(), jy(ve), dE(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", $o(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", $o(), jy(ve), hw(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", $o(), jy(Ie), cE(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", $o(), jy(ve), uE(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", $o(), jy(ve), lE(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", $o(), jy(ve);
        var Ie = tr.current;
        tr.current = Qc;
        try {
          return fE(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", $o();
        var Me = tr.current;
        tr.current = Qc;
        try {
          return tE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", $o(), sE(me);
      }, useState: function(me) {
        Sn = "useState", $o();
        var ve = tr.current;
        tr.current = Qc;
        try {
          return cw(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", $o(), void 0;
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", $o(), pE(me);
      }, useTransition: function() {
        return Sn = "useTransition", $o(), hE();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", $o(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", $o(), oE(me, ve, Ie);
      }, useId: function() {
        return Sn = "useId", $o(), mE();
      }, unstable_isNewReconciler: kn }, gT = { readContext: function(me) {
        return vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Yn(), dE(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Yn(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Yn(), hw(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Yn(), cE(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Yn(), uE(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Yn(), lE(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Yn();
        var Ie = tr.current;
        tr.current = Qc;
        try {
          return fE(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Yn();
        var Me = tr.current;
        tr.current = Qc;
        try {
          return tE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Yn(), sE(me);
      }, useState: function(me) {
        Sn = "useState", Yn();
        var ve = tr.current;
        tr.current = Qc;
        try {
          return cw(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Yn(), void 0;
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Yn(), pE(me);
      }, useTransition: function() {
        return Sn = "useTransition", Yn(), hE();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Yn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Yn(), oE(me, ve, Ie);
      }, useId: function() {
        return Sn = "useId", Yn(), mE();
      }, unstable_isNewReconciler: kn }, wT = { readContext: function(me) {
        return vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Yn(), gw(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Yn(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Yn(), Tv(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Yn(), bw(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Yn(), mw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Yn(), yw(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Yn();
        var Ie = tr.current;
        tr.current = ec;
        try {
          return ww(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Yn();
        var Me = tr.current;
        tr.current = ec;
        try {
          return nE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Yn(), fw();
      }, useState: function(me) {
        Sn = "useState", Yn();
        var ve = tr.current;
        tr.current = ec;
        try {
          return aE(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Yn(), vw();
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Yn(), uT(me);
      }, useTransition: function() {
        return Sn = "useTransition", Yn(), dT();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Yn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Yn(), lw(me, ve);
      }, useId: function() {
        return Sn = "useId", Yn(), _w();
      }, unstable_isNewReconciler: kn }, _T = { readContext: function(me) {
        return vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Yn(), gw(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Yn(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Yn(), Tv(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Yn(), bw(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Yn(), mw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Yn(), yw(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Yn();
        var Ie = tr.current;
        tr.current = xw;
        try {
          return ww(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Yn();
        var Me = tr.current;
        tr.current = xw;
        try {
          return rE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Yn(), fw();
      }, useState: function(me) {
        Sn = "useState", Yn();
        var ve = tr.current;
        tr.current = xw;
        try {
          return iE(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Yn(), vw();
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Yn(), lT(me);
      }, useTransition: function() {
        return Sn = "useTransition", Yn(), fT();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Yn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Yn(), lw(me, ve);
      }, useId: function() {
        return Sn = "useId", Yn(), _w();
      }, unstable_isNewReconciler: kn }, Qc = { readContext: function(me) {
        return yE(), vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Ur(), $o(), dE(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Ur(), $o(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Ur(), $o(), hw(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Ur(), $o(), cE(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Ur(), $o(), uE(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Ur(), $o(), lE(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Ur(), $o();
        var Ie = tr.current;
        tr.current = Qc;
        try {
          return fE(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Ur(), $o();
        var Me = tr.current;
        tr.current = Qc;
        try {
          return tE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Ur(), $o(), sE(me);
      }, useState: function(me) {
        Sn = "useState", Ur(), $o();
        var ve = tr.current;
        tr.current = Qc;
        try {
          return cw(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Ur(), $o(), void 0;
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Ur(), $o(), pE(me);
      }, useTransition: function() {
        return Sn = "useTransition", Ur(), $o(), hE();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Ur(), $o(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Ur(), $o(), oE(me, ve, Ie);
      }, useId: function() {
        return Sn = "useId", Ur(), $o(), mE();
      }, unstable_isNewReconciler: kn }, ec = { readContext: function(me) {
        return yE(), vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Ur(), Yn(), gw(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Ur(), Yn(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Ur(), Yn(), Tv(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Ur(), Yn(), bw(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Ur(), Yn(), mw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Ur(), Yn(), yw(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Ur(), Yn();
        var Ie = tr.current;
        tr.current = ec;
        try {
          return ww(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Ur(), Yn();
        var Me = tr.current;
        tr.current = ec;
        try {
          return nE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Ur(), Yn(), fw();
      }, useState: function(me) {
        Sn = "useState", Ur(), Yn();
        var ve = tr.current;
        tr.current = ec;
        try {
          return aE(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Ur(), Yn(), vw();
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Ur(), Yn(), uT(me);
      }, useTransition: function() {
        return Sn = "useTransition", Ur(), Yn(), dT();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Ur(), Yn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Ur(), Yn(), lw(me, ve);
      }, useId: function() {
        return Sn = "useId", Ur(), Yn(), _w();
      }, unstable_isNewReconciler: kn }, xw = { readContext: function(me) {
        return yE(), vi(me);
      }, useCallback: function(me, ve) {
        return Sn = "useCallback", Ur(), Yn(), gw(me, ve);
      }, useContext: function(me) {
        return Sn = "useContext", Ur(), Yn(), vi(me);
      }, useEffect: function(me, ve) {
        return Sn = "useEffect", Ur(), Yn(), Tv(me, ve);
      }, useImperativeHandle: function(me, ve, Ie) {
        return Sn = "useImperativeHandle", Ur(), Yn(), bw(me, ve, Ie);
      }, useInsertionEffect: function(me, ve) {
        return Sn = "useInsertionEffect", Ur(), Yn(), mw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return Sn = "useLayoutEffect", Ur(), Yn(), yw(me, ve);
      }, useMemo: function(me, ve) {
        Sn = "useMemo", Ur(), Yn();
        var Ie = tr.current;
        tr.current = ec;
        try {
          return ww(me, ve);
        } finally {
          tr.current = Ie;
        }
      }, useReducer: function(me, ve, Ie) {
        Sn = "useReducer", Ur(), Yn();
        var Me = tr.current;
        tr.current = ec;
        try {
          return rE(me, ve, Ie);
        } finally {
          tr.current = Me;
        }
      }, useRef: function(me) {
        return Sn = "useRef", Ur(), Yn(), fw();
      }, useState: function(me) {
        Sn = "useState", Ur(), Yn();
        var ve = tr.current;
        tr.current = ec;
        try {
          return iE(me);
        } finally {
          tr.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return Sn = "useDebugValue", Ur(), Yn(), vw();
      }, useDeferredValue: function(me) {
        return Sn = "useDeferredValue", Ur(), Yn(), lT(me);
      }, useTransition: function() {
        return Sn = "useTransition", Ur(), Yn(), fT();
      }, useMutableSource: function(me, ve, Ie) {
        return Sn = "useMutableSource", Ur(), Yn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ie) {
        return Sn = "useSyncExternalStore", Ur(), Yn(), lw(me, ve);
      }, useId: function() {
        return Sn = "useId", Ur(), Yn(), _w();
      }, unstable_isNewReconciler: kn };
    }
    var Yf = ae.unstable_now, ET = 0, Sw = -1, kv = -1, Pw = -1, bE = !1, Tw = !1;
    function xT() {
      return bE;
    }
    function VI() {
      Tw = !0;
    }
    function WI() {
      bE = !1, Tw = !1;
    }
    function GI() {
      bE = Tw, Tw = !1;
    }
    function ST() {
      return ET;
    }
    function PT() {
      ET = Yf();
    }
    function vE(me) {
      kv = Yf(), me.actualStartTime < 0 && (me.actualStartTime = Yf());
    }
    function TT(me) {
      kv = -1;
    }
    function kw(me, ve) {
      if (kv >= 0) {
        var Ie = Yf() - kv;
        me.actualDuration += Ie, ve && (me.selfBaseDuration = Ie), kv = -1;
      }
    }
    function Kc(me) {
      if (Sw >= 0) {
        var ve = Yf() - Sw;
        Sw = -1;
        for (var Ie = me.return; Ie !== null; ) {
          switch (Ie.tag) {
            case je:
              var Me = Ie.stateNode;
              Me.effectDuration += ve;
              return;
            case ht:
              var Fe = Ie.stateNode;
              Fe.effectDuration += ve;
              return;
          }
          Ie = Ie.return;
        }
      }
    }
    function gE(me) {
      if (Pw >= 0) {
        var ve = Yf() - Pw;
        Pw = -1;
        for (var Ie = me.return; Ie !== null; ) {
          switch (Ie.tag) {
            case je:
              var Me = Ie.stateNode;
              Me !== null && (Me.passiveEffectDuration += ve);
              return;
            case ht:
              var Fe = Ie.stateNode;
              Fe !== null && (Fe.passiveEffectDuration += ve);
              return;
          }
          Ie = Ie.return;
        }
      }
    }
    function Xc() {
      Sw = Yf();
    }
    function wE() {
      Pw = Yf();
    }
    function _E(me) {
      for (var ve = me.child; ve; )
        me.actualDuration += ve.actualDuration, ve = ve.sibling;
    }
    function Xh(me, ve) {
      return { value: me, source: ve, stack: ts(ve), digest: null };
    }
    function EE(me, ve, Ie) {
      return { value: me, source: null, stack: Ie ?? null, digest: ve ?? null };
    }
    function YI(me, ve) {
      return !0;
    }
    function xE(me, ve) {
      try {
        var Ie = YI(me, ve);
        if (Ie === !1)
          return;
        var Me = ve.value, Fe = ve.source, Ze = ve.stack, Xe = Ze !== null ? Ze : "";
        if (Me != null && Me._suppressLogging) {
          if (me.tag === Re)
            return;
          console.error(Me);
        }
        var at = Fe ? Mr(Fe) : null, pt = at ? "The above error occurred in the <" + at + "> component:" : "The above error occurred in one of your React components:", wt;
        if (me.tag === je)
          wt = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ct = Mr(me) || "Anonymous";
          wt = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ct + ".");
        }
        var Jt = pt + `
` + Xe + `

` + ("" + wt);
        console.error(Jt);
      } catch (Gt) {
        setTimeout(function() {
          throw Gt;
        });
      }
    }
    var QI = typeof WeakMap == "function" ? WeakMap : Map;
    function kT(me, ve, Ie) {
      var Me = Xd(Vo, Ie);
      Me.tag = x1, Me.payload = { element: null };
      var Fe = ve.value;
      return Me.callback = function() {
        WN(Fe), xE(me, ve);
      }, Me;
    }
    function SE(me, ve, Ie) {
      var Me = Xd(Vo, Ie);
      Me.tag = x1;
      var Fe = me.type.getDerivedStateFromError;
      if (typeof Fe == "function") {
        var Ze = ve.value;
        Me.payload = function() {
          return Fe(Ze);
        }, Me.callback = function() {
          T2(me), xE(me, ve);
        };
      }
      var Xe = me.stateNode;
      return Xe !== null && typeof Xe.componentDidCatch == "function" && (Me.callback = function() {
        T2(me), xE(me, ve), typeof Fe != "function" && VN(this);
        var at = ve.value, pt = ve.stack;
        this.componentDidCatch(at, { componentStack: pt !== null ? pt : "" }), typeof Fe != "function" && (ks(me.lanes, Nr) || xe("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Mr(me) || "Unknown"));
      }), Me;
    }
    function OT(me, ve, Ie) {
      var Me = me.pingCache, Fe;
      if (Me === null ? (Me = me.pingCache = new QI(), Fe = /* @__PURE__ */ new Set(), Me.set(ve, Fe)) : (Fe = Me.get(ve), Fe === void 0 && (Fe = /* @__PURE__ */ new Set(), Me.set(ve, Fe))), !Fe.has(Ie)) {
        Fe.add(Ie);
        var Ze = qN.bind(null, me, ve, Ie);
        Si && Uv(me, Ie), ve.then(Ze, Ze);
      }
    }
    function KI(me, ve, Ie, Me) {
      var Fe = me.updateQueue;
      if (Fe === null) {
        var Ze = /* @__PURE__ */ new Set();
        Ze.add(Ie), me.updateQueue = Ze;
      } else
        Fe.add(Ie);
    }
    function XI(me, ve) {
      var Ie = me.tag;
      if ((me.mode & oo) === Tr && (Ie === $e || Ie === it || Ie === St)) {
        var Me = me.alternate;
        Me ? (me.updateQueue = Me.updateQueue, me.memoizedState = Me.memoizedState, me.lanes = Me.lanes) : (me.updateQueue = null, me.memoizedState = null);
      }
    }
    function AT(me) {
      var ve = me;
      do {
        if (ve.tag === gt && _I(ve))
          return ve;
        ve = ve.return;
      } while (ve !== null);
      return null;
    }
    function CT(me, ve, Ie, Me, Fe) {
      if ((me.mode & oo) === Tr) {
        if (me === ve)
          me.flags |= mi;
        else {
          if (me.flags |= Lr, Ie.flags |= Pp, Ie.flags &= ~(bm | Vs), Ie.tag === Re) {
            var Ze = Ie.alternate;
            if (Ze === null)
              Ie.tag = Ft;
            else {
              var Xe = Xd(Vo, Nr);
              Xe.tag = Q0, Wf(Ie, Xe, Nr);
            }
          }
          Ie.lanes = Zr(Ie.lanes, Nr);
        }
        return me;
      }
      return me.flags |= mi, me.lanes = Fe, me;
    }
    function eR(me, ve, Ie, Me, Fe) {
      if (Ie.flags |= Vs, Si && Uv(me, Fe), Me !== null && typeof Me == "object" && typeof Me.then == "function") {
        var Ze = Me;
        XI(Ie), os() && Ie.mode & oo && BS();
        var Xe = AT(ve);
        if (Xe !== null) {
          Xe.flags &= ~Sa, CT(Xe, ve, Ie, me, Fe), Xe.mode & oo && OT(me, Ze, Fe), KI(Xe, me, Ze);
          return;
        } else {
          if (!Pf(Fe)) {
            OT(me, Ze, Fe), xx();
            return;
          }
          var at = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          Me = at;
        }
      } else if (os() && Ie.mode & oo) {
        BS();
        var pt = AT(ve);
        if (pt !== null) {
          (pt.flags & mi) === Sr && (pt.flags |= Sa), CT(pt, ve, Ie, me, Fe), y1(Xh(Me, Ie));
          return;
        }
      }
      Me = Xh(Me, Ie), MN(Me);
      var wt = ve;
      do {
        switch (wt.tag) {
          case je: {
            var Ct = Me;
            wt.flags |= mi;
            var Jt = ei(Fe);
            wt.lanes = Zr(wt.lanes, Jt);
            var Gt = kT(wt, Ct, Jt);
            T1(wt, Gt);
            return;
          }
          case Re:
            var pn = Me, yn = wt.type, En = wt.stateNode;
            if ((wt.flags & Lr) === Sr && (typeof yn.getDerivedStateFromError == "function" || En !== null && typeof En.componentDidCatch == "function" && !b2(En))) {
              wt.flags |= mi;
              var Kn = ei(Fe);
              wt.lanes = Zr(wt.lanes, Kn);
              var vr = SE(wt, pn, Kn);
              T1(wt, vr);
              return;
            }
            break;
        }
        wt = wt.return;
      } while (wt !== null);
    }
    function tR() {
      return null;
    }
    var Ov = fe.ReactCurrentOwner, tc = !1, PE, Av, TE, kE, OE, Jh, AE, Ow;
    PE = {}, Av = {}, TE = {}, kE = {}, OE = {}, Jh = !1, AE = {}, Ow = {};
    function Xs(me, ve, Ie, Me) {
      me === null ? ve.child = GP(ve, null, Ie, Me) : ve.child = $y(ve, me.child, Ie, Me);
    }
    function nR(me, ve, Ie, Me) {
      ve.child = $y(ve, me.child, null, Me), ve.child = $y(ve, null, Ie, Me);
    }
    function $T(me, ve, Ie, Me, Fe) {
      if (ve.type !== ve.elementType) {
        var Ze = Ie.propTypes;
        Ze && Zl(Ze, Me, "prop", ho(Ie));
      }
      var Xe = Ie.render, at = ve.ref, pt, wt;
      Cy(ve, Fe), Ic(ve);
      {
        if (Ov.current = ve, wi(!0), pt = Dy(me, ve, Xe, Me, at, Fe), wt = Ly(), ve.mode & fa) {
          Xa(!0);
          try {
            pt = Dy(me, ve, Xe, Me, at, Fe), wt = Ly();
          } finally {
            Xa(!1);
          }
        }
        wi(!1);
      }
      return Ed(), me !== null && !tc ? (JP(me, ve, Fe), Jd(me, ve, Fe)) : (os() && wt && c1(ve), ve.flags |= vc, Xs(me, ve, pt, Fe), ve.child);
    }
    function IT(me, ve, Ie, Me, Fe) {
      if (me === null) {
        var Ze = Ie.type;
        if (lM(Ze) && Ie.compare === null && Ie.defaultProps === void 0) {
          var Xe = Ze;
          return Xe = qy(Ze), ve.tag = St, ve.type = Xe, IE(ve, Ze), RT(me, ve, Xe, Me, Fe);
        }
        {
          var at = Ze.propTypes;
          at && Zl(at, Me, "prop", ho(Ze));
        }
        var pt = Mx(Ie.type, null, Me, ve, ve.mode, Fe);
        return pt.ref = ve.ref, pt.return = ve, ve.child = pt, pt;
      }
      {
        var wt = Ie.type, Ct = wt.propTypes;
        Ct && Zl(Ct, Me, "prop", ho(wt));
      }
      var Jt = me.child, Gt = LE(me, Fe);
      if (!Gt) {
        var pn = Jt.memoizedProps, yn = Ie.compare;
        if (yn = yn !== null ? yn : xr, yn(pn, Me) && me.ref === ve.ref)
          return Jd(me, ve, Fe);
      }
      ve.flags |= vc;
      var En = om(Jt, Me);
      return En.ref = ve.ref, En.return = ve, ve.child = En, En;
    }
    function RT(me, ve, Ie, Me, Fe) {
      if (ve.type !== ve.elementType) {
        var Ze = ve.elementType;
        if (Ze.$$typeof === gr) {
          var Xe = Ze, at = Xe._payload, pt = Xe._init;
          try {
            Ze = pt(at);
          } catch {
            Ze = null;
          }
          var wt = Ze && Ze.propTypes;
          wt && Zl(wt, Me, "prop", ho(Ze));
        }
      }
      if (me !== null) {
        var Ct = me.memoizedProps;
        if (xr(Ct, Me) && me.ref === ve.ref && ve.type === me.type)
          if (tc = !1, ve.pendingProps = Me = Ct, LE(me, Fe))
            (me.flags & Pp) !== Sr && (tc = !0);
          else
            return ve.lanes = me.lanes, Jd(me, ve, Fe);
      }
      return CE(me, ve, Ie, Me, Fe);
    }
    function NT(me, ve, Ie) {
      var Me = ve.pendingProps, Fe = Me.children, Ze = me !== null ? me.memoizedState : null;
      if (Me.mode === "hidden" || yt)
        if ((ve.mode & oo) === Tr) {
          var Xe = { baseLanes: xn, cachePool: null, transitions: null };
          ve.memoizedState = Xe, Uw(ve, Ie);
        } else if (ks(Ie, Ts)) {
          var at = { baseLanes: xn, cachePool: null, transitions: null };
          ve.memoizedState = at;
          var pt = Ze !== null ? Ze.baseLanes : Ie;
          Uw(ve, pt);
        } else {
          var wt = null, Ct;
          if (Ze !== null) {
            var Jt = Ze.baseLanes;
            Ct = Zr(Jt, Ie);
          } else
            Ct = Ie;
          ve.lanes = ve.childLanes = Ts;
          var Gt = { baseLanes: Ct, cachePool: wt, transitions: null };
          return ve.memoizedState = Gt, ve.updateQueue = null, Uw(ve, Ct), null;
        }
      else {
        var pn;
        Ze !== null ? (pn = Zr(Ze.baseLanes, Ie), ve.memoizedState = null) : pn = Ie, Uw(ve, pn);
      }
      return Xs(me, ve, Fe, Ie), ve.child;
    }
    function rR(me, ve, Ie) {
      var Me = ve.pendingProps;
      return Xs(me, ve, Me, Ie), ve.child;
    }
    function oR(me, ve, Ie) {
      var Me = ve.pendingProps.children;
      return Xs(me, ve, Me, Ie), ve.child;
    }
    function aR(me, ve, Ie) {
      {
        ve.flags |= qr;
        {
          var Me = ve.stateNode;
          Me.effectDuration = 0, Me.passiveEffectDuration = 0;
        }
      }
      var Fe = ve.pendingProps, Ze = Fe.children;
      return Xs(me, ve, Ze, Ie), ve.child;
    }
    function MT(me, ve) {
      var Ie = ve.ref;
      (me === null && Ie !== null || me !== null && me.ref !== Ie) && (ve.flags |= ws, ve.flags |= yb);
    }
    function CE(me, ve, Ie, Me, Fe) {
      if (ve.type !== ve.elementType) {
        var Ze = Ie.propTypes;
        Ze && Zl(Ze, Me, "prop", ho(Ie));
      }
      var Xe;
      {
        var at = Sy(ve, Ie, !0);
        Xe = Py(ve, at);
      }
      var pt, wt;
      Cy(ve, Fe), Ic(ve);
      {
        if (Ov.current = ve, wi(!0), pt = Dy(me, ve, Ie, Me, Xe, Fe), wt = Ly(), ve.mode & fa) {
          Xa(!0);
          try {
            pt = Dy(me, ve, Ie, Me, Xe, Fe), wt = Ly();
          } finally {
            Xa(!1);
          }
        }
        wi(!1);
      }
      return Ed(), me !== null && !tc ? (JP(me, ve, Fe), Jd(me, ve, Fe)) : (os() && wt && c1(ve), ve.flags |= vc, Xs(me, ve, pt, Fe), ve.child);
    }
    function jT(me, ve, Ie, Me, Fe) {
      {
        switch (SM(ve)) {
          case !1: {
            var Ze = ve.stateNode, Xe = ve.type, at = new Xe(ve.memoizedProps, Ze.context), pt = at.state;
            Ze.updater.enqueueSetState(Ze, pt, null);
            break;
          }
          case !0: {
            ve.flags |= Lr, ve.flags |= mi;
            var wt = new Error("Simulated error coming from DevTools"), Ct = ei(Fe);
            ve.lanes = Zr(ve.lanes, Ct);
            var Jt = SE(ve, Xh(wt, ve), Ct);
            T1(ve, Jt);
            break;
          }
        }
        if (ve.type !== ve.elementType) {
          var Gt = Ie.propTypes;
          Gt && Zl(Gt, Me, "prop", ho(Ie));
        }
      }
      var pn;
      Zc(Ie) ? (pn = !0, $0(ve)) : pn = !1, Cy(ve, Fe);
      var yn = ve.stateNode, En;
      yn === null ? (Cw(me, ve), VP(ve, Ie, Me), L1(ve, Ie, Me, Fe), En = !0) : me === null ? En = mI(ve, Ie, Me, Fe) : En = yI(me, ve, Ie, Me, Fe);
      var Kn = $E(me, ve, Ie, En, pn, Fe);
      {
        var vr = ve.stateNode;
        En && vr.props !== Me && (Jh || xe("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Mr(ve) || "a component"), Jh = !0);
      }
      return Kn;
    }
    function $E(me, ve, Ie, Me, Fe, Ze) {
      MT(me, ve);
      var Xe = (ve.flags & Lr) !== Sr;
      if (!Me && !Xe)
        return Fe && jS(ve, Ie, !1), Jd(me, ve, Ze);
      var at = ve.stateNode;
      Ov.current = ve;
      var pt;
      if (Xe && typeof Ie.getDerivedStateFromError != "function")
        pt = null, TT();
      else {
        Ic(ve);
        {
          if (wi(!0), pt = at.render(), ve.mode & fa) {
            Xa(!0);
            try {
              at.render();
            } finally {
              Xa(!1);
            }
          }
          wi(!1);
        }
        Ed();
      }
      return ve.flags |= vc, me !== null && Xe ? nR(me, ve, pt, Ze) : Xs(me, ve, pt, Ze), ve.memoizedState = at.state, Fe && jS(ve, Ie, !0), ve.child;
    }
    function DT(me) {
      var ve = me.stateNode;
      ve.pendingContext ? NS(me, ve.pendingContext, ve.pendingContext !== ve.context) : ve.context && NS(me, ve.context, !1), H1(me, ve.containerInfo);
    }
    function iR(me, ve, Ie) {
      if (DT(ve), me === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var Me = ve.pendingProps, Fe = ve.memoizedState, Ze = Fe.element;
      MP(me, ve), ew(ve, Me, null, Ie);
      var Xe = ve.memoizedState;
      ve.stateNode;
      var at = Xe.element;
      if (Fe.isDehydrated) {
        var pt = { element: at, isDehydrated: !1, cache: Xe.cache, pendingSuspenseBoundaries: Xe.pendingSuspenseBoundaries, transitions: Xe.transitions }, wt = ve.updateQueue;
        if (wt.baseState = pt, ve.memoizedState = pt, ve.flags & Sa) {
          var Ct = Xh(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), ve);
          return LT(me, ve, at, Ie, Ct);
        } else if (at !== Ze) {
          var Jt = Xh(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), ve);
          return LT(me, ve, at, Ie, Jt);
        } else {
          x$(ve);
          var Gt = GP(ve, null, at, Ie);
          ve.child = Gt;
          for (var pn = Gt; pn; )
            pn.flags = pn.flags & ~Ko | du, pn = pn.sibling;
        }
      } else {
        if (Oy(), at === Ze)
          return Jd(me, ve, Ie);
        Xs(me, ve, at, Ie);
      }
      return ve.child;
    }
    function LT(me, ve, Ie, Me, Fe) {
      return Oy(), y1(Fe), ve.flags |= Sa, Xs(me, ve, Ie, Me), ve.child;
    }
    function sR(me, ve, Ie) {
      QP(ve), me === null && m1(ve);
      var Me = ve.type, Fe = ve.pendingProps, Ze = me !== null ? me.memoizedProps : null, Xe = Fe.children, at = Q_(Me, Fe);
      return at ? Xe = null : Ze !== null && Q_(Me, Ze) && (ve.flags |= Co), MT(me, ve), Xs(me, ve, Xe, Ie), ve.child;
    }
    function uR(me, ve) {
      return me === null && m1(ve), null;
    }
    function lR(me, ve, Ie, Me) {
      Cw(me, ve);
      var Fe = ve.pendingProps, Ze = Ie, Xe = Ze._payload, at = Ze._init, pt = at(Xe);
      ve.type = pt;
      var wt = ve.tag = cM(pt), Ct = Xl(pt, Fe), Jt;
      switch (wt) {
        case $e:
          return IE(ve, pt), ve.type = pt = qy(pt), Jt = CE(null, ve, pt, Ct, Me), Jt;
        case Re:
          return ve.type = pt = Ax(pt), Jt = jT(null, ve, pt, Ct, Me), Jt;
        case it:
          return ve.type = pt = Cx(pt), Jt = $T(null, ve, pt, Ct, Me), Jt;
        case At: {
          if (ve.type !== ve.elementType) {
            var Gt = pt.propTypes;
            Gt && Zl(Gt, Ct, "prop", ho(pt));
          }
          return Jt = IT(null, ve, pt, Xl(pt.type, Ct), Me), Jt;
        }
      }
      var pn = "";
      throw pt !== null && typeof pt == "object" && pt.$$typeof === gr && (pn = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + pt + ". " + ("Lazy element type must resolve to a class or function." + pn));
    }
    function cR(me, ve, Ie, Me, Fe) {
      Cw(me, ve), ve.tag = Re;
      var Ze;
      return Zc(Ie) ? (Ze = !0, $0(ve)) : Ze = !1, Cy(ve, Fe), VP(ve, Ie, Me), L1(ve, Ie, Me, Fe), $E(null, ve, Ie, !0, Ze, Fe);
    }
    function dR(me, ve, Ie, Me) {
      Cw(me, ve);
      var Fe = ve.pendingProps, Ze;
      {
        var Xe = Sy(ve, Ie, !1);
        Ze = Py(ve, Xe);
      }
      Cy(ve, Me);
      var at, pt;
      Ic(ve);
      {
        if (Ie.prototype && typeof Ie.prototype.render == "function") {
          var wt = ho(Ie) || "Unknown";
          PE[wt] || (xe("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", wt, wt), PE[wt] = !0);
        }
        ve.mode & fa && Ql.recordLegacyContextWarning(ve, null), wi(!0), Ov.current = ve, at = Dy(null, ve, Ie, Fe, Ze, Me), pt = Ly(), wi(!1);
      }
      if (Ed(), ve.flags |= vc, typeof at == "object" && at !== null && typeof at.render == "function" && at.$$typeof === void 0) {
        var Ct = ho(Ie) || "Unknown";
        Av[Ct] || (xe("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ct, Ct, Ct), Av[Ct] = !0);
      }
      if (typeof at == "object" && at !== null && typeof at.render == "function" && at.$$typeof === void 0) {
        {
          var Jt = ho(Ie) || "Unknown";
          Av[Jt] || (xe("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Jt, Jt, Jt), Av[Jt] = !0);
        }
        ve.tag = Re, ve.memoizedState = null, ve.updateQueue = null;
        var Gt = !1;
        return Zc(Ie) ? (Gt = !0, $0(ve)) : Gt = !1, ve.memoizedState = at.state !== null && at.state !== void 0 ? at.state : null, P1(ve), UP(ve, at), L1(ve, Ie, Fe, Me), $E(null, ve, Ie, !0, Gt, Me);
      } else {
        if (ve.tag = $e, ve.mode & fa) {
          Xa(!0);
          try {
            at = Dy(null, ve, Ie, Fe, Ze, Me), pt = Ly();
          } finally {
            Xa(!1);
          }
        }
        return os() && pt && c1(ve), Xs(null, ve, at, Me), IE(ve, Ie), ve.child;
      }
    }
    function IE(me, ve) {
      {
        if (ve && ve.childContextTypes && xe("%s(...): childContextTypes cannot be defined on a function component.", ve.displayName || ve.name || "Component"), me.ref !== null) {
          var Ie = "", Me = Fa();
          Me && (Ie += `

Check the render method of \`` + Me + "`.");
          var Fe = Me || "", Ze = me._debugSource;
          Ze && (Fe = Ze.fileName + ":" + Ze.lineNumber), OE[Fe] || (OE[Fe] = !0, xe("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", Ie));
        }
        if (typeof ve.getDerivedStateFromProps == "function") {
          var Xe = ho(ve) || "Unknown";
          kE[Xe] || (xe("%s: Function components do not support getDerivedStateFromProps.", Xe), kE[Xe] = !0);
        }
        if (typeof ve.contextType == "object" && ve.contextType !== null) {
          var at = ho(ve) || "Unknown";
          TE[at] || (xe("%s: Function components do not support contextType.", at), TE[at] = !0);
        }
      }
    }
    var RE = { dehydrated: null, treeContext: null, retryLane: yo };
    function NE(me) {
      return { baseLanes: me, cachePool: tR(), transitions: null };
    }
    function fR(me, ve) {
      var Ie = null;
      return { baseLanes: Zr(me.baseLanes, ve), cachePool: Ie, transitions: me.transitions };
    }
    function pR(me, ve, Ie, Me) {
      if (ve !== null) {
        var Fe = ve.memoizedState;
        if (Fe === null)
          return !1;
      }
      return Z1(me, wv);
    }
    function hR(me, ve) {
      return Tf(me.childLanes, ve);
    }
    function FT(me, ve, Ie) {
      var Me = ve.pendingProps;
      PM(ve) && (ve.flags |= Lr);
      var Fe = Jl.current, Ze = !1, Xe = (ve.flags & Lr) !== Sr;
      if (Xe || pR(Fe, me) ? (Ze = !0, ve.flags &= ~Lr) : (me === null || me.memoizedState !== null) && (Fe = wI(Fe, XP)), Fe = Ry(Fe), Zf(ve, Fe), me === null) {
        m1(ve);
        var at = ve.memoizedState;
        if (at !== null) {
          var pt = at.dehydrated;
          if (pt !== null)
            return gR(ve, pt);
        }
        var wt = Me.children, Ct = Me.fallback;
        if (Ze) {
          var Jt = mR(ve, wt, Ct, Ie), Gt = ve.child;
          return Gt.memoizedState = NE(Ie), ve.memoizedState = RE, Jt;
        } else
          return ME(ve, wt);
      } else {
        var pn = me.memoizedState;
        if (pn !== null) {
          var yn = pn.dehydrated;
          if (yn !== null)
            return wR(me, ve, Xe, Me, yn, pn, Ie);
        }
        if (Ze) {
          var En = Me.fallback, Kn = Me.children, vr = bR(me, ve, Kn, En, Ie), Or = ve.child, co = me.child.memoizedState;
          return Or.memoizedState = co === null ? NE(Ie) : fR(co, Ie), Or.childLanes = hR(me, Ie), ve.memoizedState = RE, vr;
        } else {
          var Xr = Me.children, rn = yR(me, ve, Xr, Ie);
          return ve.memoizedState = null, rn;
        }
      }
    }
    function ME(me, ve, Ie) {
      var Me = me.mode, Fe = { mode: "visible", children: ve }, Ze = jE(Fe, Me);
      return Ze.return = me, me.child = Ze, Ze;
    }
    function mR(me, ve, Ie, Me) {
      var Fe = me.mode, Ze = me.child, Xe = { mode: "hidden", children: ve }, at, pt;
      return (Fe & oo) === Tr && Ze !== null ? (at = Ze, at.childLanes = xn, at.pendingProps = Xe, me.mode & Rr && (at.actualDuration = 0, at.actualStartTime = -1, at.selfBaseDuration = 0, at.treeBaseDuration = 0), pt = tp(Ie, Fe, Me, null)) : (at = jE(Xe, Fe), pt = tp(Ie, Fe, Me, null)), at.return = me, pt.return = me, at.sibling = pt, me.child = at, pt;
    }
    function jE(me, ve, Ie) {
      return k2(me, ve, xn, null);
    }
    function BT(me, ve) {
      return om(me, ve);
    }
    function yR(me, ve, Ie, Me) {
      var Fe = me.child, Ze = Fe.sibling, Xe = BT(Fe, { mode: "visible", children: Ie });
      if ((ve.mode & oo) === Tr && (Xe.lanes = Me), Xe.return = ve, Xe.sibling = null, Ze !== null) {
        var at = ve.deletions;
        at === null ? (ve.deletions = [Ze], ve.flags |= ko) : at.push(Ze);
      }
      return ve.child = Xe, Xe;
    }
    function bR(me, ve, Ie, Me, Fe) {
      var Ze = ve.mode, Xe = me.child, at = Xe.sibling, pt = { mode: "hidden", children: Ie }, wt;
      if ((Ze & oo) === Tr && ve.child !== Xe) {
        var Ct = ve.child;
        wt = Ct, wt.childLanes = xn, wt.pendingProps = pt, ve.mode & Rr && (wt.actualDuration = 0, wt.actualStartTime = -1, wt.selfBaseDuration = Xe.selfBaseDuration, wt.treeBaseDuration = Xe.treeBaseDuration), ve.deletions = null;
      } else
        wt = BT(Xe, pt), wt.subtreeFlags = Xe.subtreeFlags & xi;
      var Jt;
      return at !== null ? Jt = om(at, Me) : (Jt = tp(Me, Ze, Fe, null), Jt.flags |= Ko), Jt.return = ve, wt.return = ve, wt.sibling = Jt, ve.child = wt, Jt;
    }
    function Aw(me, ve, Ie, Me) {
      Me !== null && y1(Me), $y(ve, me.child, null, Ie);
      var Fe = ve.pendingProps, Ze = Fe.children, Xe = ME(ve, Ze);
      return Xe.flags |= Ko, ve.memoizedState = null, Xe;
    }
    function vR(me, ve, Ie, Me, Fe) {
      var Ze = ve.mode, Xe = { mode: "visible", children: Ie }, at = jE(Xe, Ze), pt = tp(Me, Ze, Fe, null);
      return pt.flags |= Ko, at.return = ve, pt.return = ve, at.sibling = pt, ve.child = at, (ve.mode & oo) !== Tr && $y(ve, me.child, null, Fe), pt;
    }
    function gR(me, ve, Ie) {
      return (me.mode & oo) === Tr ? (xe("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), me.lanes = Nr) : e1(ve) ? me.lanes = Td : me.lanes = Ts, null;
    }
    function wR(me, ve, Ie, Me, Fe, Ze, Xe) {
      if (Ie)
        if (ve.flags & Sa) {
          ve.flags &= ~Sa;
          var at = EE(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Aw(me, ve, Xe, at);
        } else {
          if (ve.memoizedState !== null)
            return ve.child = me.child, ve.flags |= Lr, null;
          var pt = Me.children, wt = Me.fallback, Ct = vR(me, ve, pt, wt, Xe), Jt = ve.child;
          return Jt.memoizedState = NE(Xe), ve.memoizedState = RE, Ct;
        }
      else {
        if (XC(), (ve.mode & oo) === Tr)
          return Aw(me, ve, Xe, null);
        if (e1(Fe)) {
          var Gt, pn, yn;
          {
            var En = mC(Fe);
            Gt = En.digest, pn = En.message, yn = En.stack;
          }
          var Kn;
          pn ? Kn = new Error(pn) : Kn = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var vr = EE(Kn, Gt, yn);
          return Aw(me, ve, Xe, vr);
        }
        var Or = ks(Xe, me.childLanes);
        if (tc || Or) {
          var co = zw();
          if (co !== null) {
            var Xr = Km(co, Xe);
            if (Xr !== yo && Xr !== Ze.retryLane) {
              Ze.retryLane = Xr;
              var rn = Vo;
              Su(me, Xr), Fi(co, me, Xr, rn);
            }
          }
          xx();
          var wn = EE(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Aw(me, ve, Xe, wn);
        } else if (kS(Fe)) {
          ve.flags |= Lr, ve.child = me.child;
          var an = ZN.bind(null, me);
          return yC(Fe, an), null;
        } else {
          W$(ve, Fe, Ze.treeContext);
          var Bn = Me.children, nr = ME(ve, Bn);
          return nr.flags |= du, nr;
        }
      }
    }
    function zT(me, ve, Ie) {
      me.lanes = Zr(me.lanes, ve);
      var Me = me.alternate;
      Me !== null && (Me.lanes = Zr(Me.lanes, ve)), _1(me.return, ve, Ie);
    }
    function _R(me, ve, Ie) {
      for (var Me = ve; Me !== null; ) {
        if (Me.tag === gt) {
          var Fe = Me.memoizedState;
          Fe !== null && zT(Me, Ie, me);
        } else if (Me.tag === on)
          zT(Me, Ie, me);
        else if (Me.child !== null) {
          Me.child.return = Me, Me = Me.child;
          continue;
        }
        if (Me === me)
          return;
        for (; Me.sibling === null; ) {
          if (Me.return === null || Me.return === me)
            return;
          Me = Me.return;
        }
        Me.sibling.return = Me.return, Me = Me.sibling;
      }
    }
    function ER(me) {
      for (var ve = me, Ie = null; ve !== null; ) {
        var Me = ve.alternate;
        Me !== null && sw(Me) === null && (Ie = ve), ve = ve.sibling;
      }
      return Ie;
    }
    function xR(me) {
      if (me !== void 0 && me !== "forwards" && me !== "backwards" && me !== "together" && !AE[me])
        if (AE[me] = !0, typeof me == "string")
          switch (me.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              xe('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', me, me.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              xe('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', me, me.toLowerCase());
              break;
            }
            default:
              xe('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
              break;
          }
        else
          xe('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
    }
    function SR(me, ve) {
      me !== void 0 && !Ow[me] && (me !== "collapsed" && me !== "hidden" ? (Ow[me] = !0, xe('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', me)) : ve !== "forwards" && ve !== "backwards" && (Ow[me] = !0, xe('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', me)));
    }
    function UT(me, ve) {
      {
        var Ie = No(me), Me = !Ie && typeof Yi(me) == "function";
        if (Ie || Me) {
          var Fe = Ie ? "array" : "iterable";
          return xe("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", Fe, ve, Fe), !1;
        }
      }
      return !0;
    }
    function PR(me, ve) {
      if ((ve === "forwards" || ve === "backwards") && me !== void 0 && me !== null && me !== !1)
        if (No(me)) {
          for (var Ie = 0; Ie < me.length; Ie++)
            if (!UT(me[Ie], Ie))
              return;
        } else {
          var Me = Yi(me);
          if (typeof Me == "function") {
            var Fe = Me.call(me);
            if (Fe)
              for (var Ze = Fe.next(), Xe = 0; !Ze.done; Ze = Fe.next()) {
                if (!UT(Ze.value, Xe))
                  return;
                Xe++;
              }
          } else
            xe('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', ve);
        }
    }
    function DE(me, ve, Ie, Me, Fe) {
      var Ze = me.memoizedState;
      Ze === null ? me.memoizedState = { isBackwards: ve, rendering: null, renderingStartTime: 0, last: Me, tail: Ie, tailMode: Fe } : (Ze.isBackwards = ve, Ze.rendering = null, Ze.renderingStartTime = 0, Ze.last = Me, Ze.tail = Ie, Ze.tailMode = Fe);
    }
    function VT(me, ve, Ie) {
      var Me = ve.pendingProps, Fe = Me.revealOrder, Ze = Me.tail, Xe = Me.children;
      xR(Fe), SR(Ze, Fe), PR(Xe, Fe), Xs(me, ve, Xe, Ie);
      var at = Jl.current, pt = Z1(at, wv);
      if (pt)
        at = G1(at, wv), ve.flags |= Lr;
      else {
        var wt = me !== null && (me.flags & Lr) !== Sr;
        wt && _R(ve, ve.child, Ie), at = Ry(at);
      }
      if (Zf(ve, at), (ve.mode & oo) === Tr)
        ve.memoizedState = null;
      else
        switch (Fe) {
          case "forwards": {
            var Ct = ER(ve.child), Jt;
            Ct === null ? (Jt = ve.child, ve.child = null) : (Jt = Ct.sibling, Ct.sibling = null), DE(ve, !1, Jt, Ct, Ze);
            break;
          }
          case "backwards": {
            var Gt = null, pn = ve.child;
            for (ve.child = null; pn !== null; ) {
              var yn = pn.alternate;
              if (yn !== null && sw(yn) === null) {
                ve.child = pn;
                break;
              }
              var En = pn.sibling;
              pn.sibling = Gt, Gt = pn, pn = En;
            }
            DE(ve, !0, Gt, null, Ze);
            break;
          }
          case "together": {
            DE(ve, !1, null, null, void 0);
            break;
          }
          default:
            ve.memoizedState = null;
        }
      return ve.child;
    }
    function TR(me, ve, Ie) {
      H1(ve, ve.stateNode.containerInfo);
      var Me = ve.pendingProps;
      return me === null ? ve.child = $y(ve, null, Me, Ie) : Xs(me, ve, Me, Ie), ve.child;
    }
    var HT = !1;
    function kR(me, ve, Ie) {
      var Me = ve.type, Fe = Me._context, Ze = ve.pendingProps, Xe = ve.memoizedProps, at = Ze.value;
      {
        "value" in Ze || HT || (HT = !0, xe("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var pt = ve.type.propTypes;
        pt && Zl(pt, Ze, "prop", "Context.Provider");
      }
      if (AP(ve, Fe, at), Xe !== null) {
        var wt = Xe.value;
        if (Jn(wt, at)) {
          if (Xe.children === Ze.children && !O0())
            return Jd(me, ve, Ie);
        } else
          rI(ve, Fe, Ie);
      }
      var Ct = Ze.children;
      return Xs(me, ve, Ct, Ie), ve.child;
    }
    var WT = !1;
    function OR(me, ve, Ie) {
      var Me = ve.type;
      Me._context === void 0 ? Me !== Me.Consumer && (WT || (WT = !0, xe("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : Me = Me._context;
      var Fe = ve.pendingProps, Ze = Fe.children;
      typeof Ze != "function" && xe("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Cy(ve, Ie);
      var Xe = vi(Me);
      Ic(ve);
      var at;
      return Ov.current = ve, wi(!0), at = Ze(Xe), wi(!1), Ed(), ve.flags |= vc, Xs(me, ve, at, Ie), ve.child;
    }
    function Cv() {
      tc = !0;
    }
    function Cw(me, ve) {
      (ve.mode & oo) === Tr && me !== null && (me.alternate = null, ve.alternate = null, ve.flags |= Ko);
    }
    function Jd(me, ve, Ie) {
      return me !== null && (ve.dependencies = me.dependencies), TT(), zv(ve.lanes), ks(Ie, ve.childLanes) ? (bI(me, ve), ve.child) : null;
    }
    function CR(me, ve, Ie) {
      {
        var Me = ve.return;
        if (Me === null)
          throw new Error("Cannot swap the root fiber.");
        if (me.alternate = null, ve.alternate = null, Ie.index = ve.index, Ie.sibling = ve.sibling, Ie.return = ve.return, Ie.ref = ve.ref, ve === Me.child)
          Me.child = Ie;
        else {
          var Fe = Me.child;
          if (Fe === null)
            throw new Error("Expected parent to have a child.");
          for (; Fe.sibling !== ve; )
            if (Fe = Fe.sibling, Fe === null)
              throw new Error("Expected to find the previous sibling.");
          Fe.sibling = Ie;
        }
        var Ze = Me.deletions;
        return Ze === null ? (Me.deletions = [me], Me.flags |= ko) : Ze.push(me), Ie.flags |= Ko, Ie;
      }
    }
    function LE(me, ve) {
      var Ie = me.lanes;
      return !!ks(Ie, ve);
    }
    function $R(me, ve, Ie) {
      switch (ve.tag) {
        case je:
          DT(ve), ve.stateNode, Oy();
          break;
        case ze:
          QP(ve);
          break;
        case Re: {
          var Me = ve.type;
          Zc(Me) && $0(ve);
          break;
        }
        case Be:
          H1(ve, ve.stateNode.containerInfo);
          break;
        case tt: {
          var Fe = ve.memoizedProps.value, Ze = ve.type._context;
          AP(ve, Ze, Fe);
          break;
        }
        case ht:
          {
            var Xe = ks(Ie, ve.childLanes);
            Xe && (ve.flags |= qr);
            {
              var at = ve.stateNode;
              at.effectDuration = 0, at.passiveEffectDuration = 0;
            }
          }
          break;
        case gt: {
          var pt = ve.memoizedState;
          if (pt !== null) {
            if (pt.dehydrated !== null)
              return Zf(ve, Ry(Jl.current)), ve.flags |= Lr, null;
            var wt = ve.child, Ct = wt.childLanes;
            if (ks(Ie, Ct))
              return FT(me, ve, Ie);
            Zf(ve, Ry(Jl.current));
            var Jt = Jd(me, ve, Ie);
            return Jt !== null ? Jt.sibling : null;
          } else
            Zf(ve, Ry(Jl.current));
          break;
        }
        case on: {
          var Gt = (me.flags & Lr) !== Sr, pn = ks(Ie, ve.childLanes);
          if (Gt) {
            if (pn)
              return VT(me, ve, Ie);
            ve.flags |= Lr;
          }
          var yn = ve.memoizedState;
          if (yn !== null && (yn.rendering = null, yn.tail = null, yn.lastEffect = null), Zf(ve, Jl.current), pn)
            break;
          return null;
        }
        case _n:
        case en:
          return ve.lanes = xn, NT(me, ve, Ie);
      }
      return Jd(me, ve, Ie);
    }
    function qT(me, ve, Ie) {
      if (ve._debugNeedsRemount && me !== null)
        return CR(me, ve, Mx(ve.type, ve.key, ve.pendingProps, ve._debugOwner || null, ve.mode, ve.lanes));
      if (me !== null) {
        var Me = me.memoizedProps, Fe = ve.pendingProps;
        if (Me !== Fe || O0() || ve.type !== me.type)
          tc = !0;
        else {
          var Ze = LE(me, Ie);
          if (!Ze && (ve.flags & Lr) === Sr)
            return tc = !1, $R(me, ve, Ie);
          (me.flags & Pp) !== Sr ? tc = !0 : tc = !1;
        }
      } else if (tc = !1, os() && qC(ve)) {
        var Xe = ve.index, at = ZC();
        FS(ve, at, Xe);
      }
      switch (ve.lanes = xn, ve.tag) {
        case Ne:
          return dR(me, ve, ve.type, Ie);
        case Nt: {
          var pt = ve.elementType;
          return lR(me, ve, pt, Ie);
        }
        case $e: {
          var wt = ve.type, Ct = ve.pendingProps, Jt = ve.elementType === wt ? Ct : Xl(wt, Ct);
          return CE(me, ve, wt, Jt, Ie);
        }
        case Re: {
          var Gt = ve.type, pn = ve.pendingProps, yn = ve.elementType === Gt ? pn : Xl(Gt, pn);
          return jT(me, ve, Gt, yn, Ie);
        }
        case je:
          return iR(me, ve, Ie);
        case ze:
          return sR(me, ve, Ie);
        case He:
          return uR(me, ve);
        case gt:
          return FT(me, ve, Ie);
        case Be:
          return TR(me, ve, Ie);
        case it: {
          var En = ve.type, Kn = ve.pendingProps, vr = ve.elementType === En ? Kn : Xl(En, Kn);
          return $T(me, ve, En, vr, Ie);
        }
        case qe:
          return rR(me, ve, Ie);
        case Ye:
          return oR(me, ve, Ie);
        case ht:
          return aR(me, ve, Ie);
        case tt:
          return kR(me, ve, Ie);
        case ot:
          return OR(me, ve, Ie);
        case At: {
          var Or = ve.type, co = ve.pendingProps, Xr = Xl(Or, co);
          if (ve.type !== ve.elementType) {
            var rn = Or.propTypes;
            rn && Zl(rn, Xr, "prop", ho(Or));
          }
          return Xr = Xl(Or.type, Xr), IT(me, ve, Or, Xr, Ie);
        }
        case St:
          return RT(me, ve, ve.type, ve.pendingProps, Ie);
        case Ft: {
          var wn = ve.type, an = ve.pendingProps, Bn = ve.elementType === wn ? an : Xl(wn, an);
          return cR(me, ve, wn, Bn, Ie);
        }
        case on:
          return VT(me, ve, Ie);
        case tn:
          break;
        case _n:
          return NT(me, ve, Ie);
      }
      throw new Error("Unknown unit of work tag (" + ve.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Fy(me) {
      me.flags |= qr;
    }
    function ZT(me) {
      me.flags |= ws, me.flags |= yb;
    }
    var GT, FE, YT, QT;
    GT = function(me, ve, Ie, Me) {
      for (var Fe = ve.child; Fe !== null; ) {
        if (Fe.tag === ze || Fe.tag === He)
          eA(me, Fe.stateNode);
        else if (Fe.tag !== Be && Fe.child !== null) {
          Fe.child.return = Fe, Fe = Fe.child;
          continue;
        }
        if (Fe === ve)
          return;
        for (; Fe.sibling === null; ) {
          if (Fe.return === null || Fe.return === ve)
            return;
          Fe = Fe.return;
        }
        Fe.sibling.return = Fe.return, Fe = Fe.sibling;
      }
    }, FE = function(me, ve) {
    }, YT = function(me, ve, Ie, Me, Fe) {
      var Ze = me.memoizedProps;
      if (Ze !== Me) {
        var Xe = ve.stateNode, at = W1(), pt = uA(Xe, Ie, Ze, Me, Fe, at);
        ve.updateQueue = pt, pt && Fy(ve);
      }
    }, QT = function(me, ve, Ie, Me) {
      Ie !== Me && Fy(ve);
    };
    function $v(me, ve) {
      if (!os())
        switch (me.tailMode) {
          case "hidden": {
            for (var Ie = me.tail, Me = null; Ie !== null; )
              Ie.alternate !== null && (Me = Ie), Ie = Ie.sibling;
            Me === null ? me.tail = null : Me.sibling = null;
            break;
          }
          case "collapsed": {
            for (var Fe = me.tail, Ze = null; Fe !== null; )
              Fe.alternate !== null && (Ze = Fe), Fe = Fe.sibling;
            Ze === null ? !ve && me.tail !== null ? me.tail.sibling = null : me.tail = null : Ze.sibling = null;
            break;
          }
        }
    }
    function is(me) {
      var ve = me.alternate !== null && me.alternate.child === me.child, Ie = xn, Me = Sr;
      if (ve) {
        if ((me.mode & Rr) !== Tr) {
          for (var Fe = me.selfBaseDuration, Ze = me.child; Ze !== null; )
            Ie = Zr(Ie, Zr(Ze.lanes, Ze.childLanes)), Me |= Ze.subtreeFlags & xi, Me |= Ze.flags & xi, Fe += Ze.treeBaseDuration, Ze = Ze.sibling;
          me.treeBaseDuration = Fe;
        } else
          for (var Xe = me.child; Xe !== null; )
            Ie = Zr(Ie, Zr(Xe.lanes, Xe.childLanes)), Me |= Xe.subtreeFlags & xi, Me |= Xe.flags & xi, Xe.return = me, Xe = Xe.sibling;
        me.subtreeFlags |= Me;
      } else {
        if ((me.mode & Rr) !== Tr) {
          for (var at = me.actualDuration, pt = me.selfBaseDuration, wt = me.child; wt !== null; )
            Ie = Zr(Ie, Zr(wt.lanes, wt.childLanes)), Me |= wt.subtreeFlags, Me |= wt.flags, at += wt.actualDuration, pt += wt.treeBaseDuration, wt = wt.sibling;
          me.actualDuration = at, me.treeBaseDuration = pt;
        } else
          for (var Ct = me.child; Ct !== null; )
            Ie = Zr(Ie, Zr(Ct.lanes, Ct.childLanes)), Me |= Ct.subtreeFlags, Me |= Ct.flags, Ct.return = me, Ct = Ct.sibling;
        me.subtreeFlags |= Me;
      }
      return me.childLanes = Ie, ve;
    }
    function IR(me, ve, Ie) {
      if (K$() && (ve.mode & oo) !== Tr && (ve.flags & Lr) === Sr)
        return QS(ve), Oy(), ve.flags |= Sa | Vs | mi, !1;
      var Me = V0(ve);
      if (Ie !== null && Ie.dehydrated !== null)
        if (me === null) {
          if (!Me)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (Y$(ve), is(ve), (ve.mode & Rr) !== Tr) {
            var Fe = Ie !== null;
            if (Fe) {
              var Ze = ve.child;
              Ze !== null && (ve.treeBaseDuration -= Ze.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Oy(), (ve.flags & Lr) === Sr && (ve.memoizedState = null), ve.flags |= qr, is(ve), (ve.mode & Rr) !== Tr) {
            var Xe = Ie !== null;
            if (Xe) {
              var at = ve.child;
              at !== null && (ve.treeBaseDuration -= at.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return KS(), !0;
    }
    function KT(me, ve, Ie) {
      var Me = ve.pendingProps;
      switch (d1(ve), ve.tag) {
        case Ne:
        case Nt:
        case St:
        case $e:
        case it:
        case qe:
        case Ye:
        case ht:
        case ot:
        case At:
          return is(ve), null;
        case Re: {
          var Fe = ve.type;
          return Zc(Fe) && C0(ve), is(ve), null;
        }
        case je: {
          var Ze = ve.stateNode;
          if (Iy(ve), s1(ve), Q1(), Ze.pendingContext && (Ze.context = Ze.pendingContext, Ze.pendingContext = null), me === null || me.child === null) {
            var Xe = V0(ve);
            if (Xe)
              Fy(ve);
            else if (me !== null) {
              var at = me.memoizedState;
              (!at.isDehydrated || (ve.flags & Sa) !== Sr) && (ve.flags |= cu, KS());
            }
          }
          return FE(me, ve), is(ve), null;
        }
        case ze: {
          q1(ve);
          var pt = YP(), wt = ve.type;
          if (me !== null && ve.stateNode != null)
            YT(me, ve, wt, Me, pt), me.ref !== ve.ref && ZT(ve);
          else {
            if (!Me) {
              if (ve.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return is(ve), null;
            }
            var Ct = W1(), Jt = V0(ve);
            if (Jt)
              Z$(ve, pt, Ct) && Fy(ve);
            else {
              var Gt = JO(wt, Me, pt, Ct, ve);
              GT(Gt, ve, !1, !1), ve.stateNode = Gt, sA(Gt, wt, Me, pt) && Fy(ve);
            }
            ve.ref !== null && ZT(ve);
          }
          return is(ve), null;
        }
        case He: {
          var pn = Me;
          if (me && ve.stateNode != null) {
            var yn = me.memoizedProps;
            QT(me, ve, yn, pn);
          } else {
            if (typeof pn != "string" && ve.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var En = YP(), Kn = W1(), vr = V0(ve);
            vr ? G$(ve) && Fy(ve) : ve.stateNode = lA(pn, En, Kn, ve);
          }
          return is(ve), null;
        }
        case gt: {
          Ny(ve);
          var Or = ve.memoizedState;
          if (me === null || me.memoizedState !== null && me.memoizedState.dehydrated !== null) {
            var co = IR(me, ve, Or);
            if (!co)
              return ve.flags & mi ? ve : null;
          }
          if ((ve.flags & Lr) !== Sr)
            return ve.lanes = Ie, (ve.mode & Rr) !== Tr && _E(ve), ve;
          var Xr = Or !== null, rn = me !== null && me.memoizedState !== null;
          if (Xr !== rn && Xr) {
            var wn = ve.child;
            if (wn.flags |= gc, (ve.mode & oo) !== Tr) {
              var an = me === null && (ve.memoizedProps.unstable_avoidThisFallback !== !0 || !jt);
              an || Z1(Jl.current, XP) ? NN() : xx();
            }
          }
          var Bn = ve.updateQueue;
          if (Bn !== null && (ve.flags |= qr), is(ve), (ve.mode & Rr) !== Tr && Xr) {
            var nr = ve.child;
            nr !== null && (ve.treeBaseDuration -= nr.treeBaseDuration);
          }
          return null;
        }
        case Be:
          return Iy(ve), FE(me, ve), me === null && FC(ve.stateNode.containerInfo), is(ve), null;
        case tt:
          var Xn = ve.type._context;
          return w1(Xn, ve), is(ve), null;
        case Ft: {
          var jr = ve.type;
          return Zc(jr) && C0(ve), is(ve), null;
        }
        case on: {
          Ny(ve);
          var Hr = ve.memoizedState;
          if (Hr === null)
            return is(ve), null;
          var Lo = (ve.flags & Lr) !== Sr, xo = Hr.rendering;
          if (xo === null)
            if (Lo)
              $v(Hr, !1);
            else {
              var ii = jN() && (me === null || (me.flags & Lr) === Sr);
              if (!ii)
                for (var So = ve.child; So !== null; ) {
                  var Va = sw(So);
                  if (Va !== null) {
                    Lo = !0, ve.flags |= Lr, $v(Hr, !1);
                    var Rs = Va.updateQueue;
                    return Rs !== null && (ve.updateQueue = Rs, ve.flags |= qr), ve.subtreeFlags = Sr, vI(ve, Ie), Zf(ve, G1(Jl.current, wv)), ve.child;
                  }
                  So = So.sibling;
                }
              Hr.tail !== null && da() > o2() && (ve.flags |= Lr, Lo = !0, $v(Hr, !1), ve.lanes = Ab);
            }
          else {
            if (!Lo) {
              var hs = sw(xo);
              if (hs !== null) {
                ve.flags |= Lr, Lo = !0;
                var Yu = hs.updateQueue;
                if (Yu !== null && (ve.updateQueue = Yu, ve.flags |= qr), $v(Hr, !0), Hr.tail === null && Hr.tailMode === "hidden" && !xo.alternate && !os())
                  return is(ve), null;
              } else
                da() * 2 - Hr.renderingStartTime > o2() && Ie !== Ts && (ve.flags |= Lr, Lo = !0, $v(Hr, !1), ve.lanes = Ab);
            }
            if (Hr.isBackwards)
              xo.sibling = ve.child, ve.child = xo;
            else {
              var tu = Hr.last;
              tu !== null ? tu.sibling = xo : ve.child = xo, Hr.last = xo;
            }
          }
          if (Hr.tail !== null) {
            var nu = Hr.tail;
            Hr.rendering = nu, Hr.tail = nu.sibling, Hr.renderingStartTime = da(), nu.sibling = null;
            var Ns = Jl.current;
            return Lo ? Ns = G1(Ns, wv) : Ns = Ry(Ns), Zf(ve, Ns), nu;
          }
          return is(ve), null;
        }
        case tn:
          break;
        case _n:
        case en: {
          Ex(ve);
          var af = ve.memoizedState, Zy = af !== null;
          if (me !== null) {
            var qv = me.memoizedState, td = qv !== null;
            td !== Zy && !yt && (ve.flags |= gc);
          }
          return !Zy || (ve.mode & oo) === Tr ? is(ve) : ks(ed, Ts) && (is(ve), ve.subtreeFlags & (Ko | qr) && (ve.flags |= gc)), null;
        }
        case dn:
          return null;
        case Ht:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + ve.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function RR(me, ve, Ie) {
      switch (d1(ve), ve.tag) {
        case Re: {
          var Me = ve.type;
          Zc(Me) && C0(ve);
          var Fe = ve.flags;
          return Fe & mi ? (ve.flags = Fe & ~mi | Lr, (ve.mode & Rr) !== Tr && _E(ve), ve) : null;
        }
        case je: {
          ve.stateNode, Iy(ve), s1(ve), Q1();
          var Ze = ve.flags;
          return (Ze & mi) !== Sr && (Ze & Lr) === Sr ? (ve.flags = Ze & ~mi | Lr, ve) : null;
        }
        case ze:
          return q1(ve), null;
        case gt: {
          Ny(ve);
          var Xe = ve.memoizedState;
          if (Xe !== null && Xe.dehydrated !== null) {
            if (ve.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Oy();
          }
          var at = ve.flags;
          return at & mi ? (ve.flags = at & ~mi | Lr, (ve.mode & Rr) !== Tr && _E(ve), ve) : null;
        }
        case on:
          return Ny(ve), null;
        case Be:
          return Iy(ve), null;
        case tt:
          var pt = ve.type._context;
          return w1(pt, ve), null;
        case _n:
        case en:
          return Ex(ve), null;
        case dn:
          return null;
        default:
          return null;
      }
    }
    function XT(me, ve, Ie) {
      switch (d1(ve), ve.tag) {
        case Re: {
          var Me = ve.type.childContextTypes;
          Me != null && C0(ve);
          break;
        }
        case je: {
          ve.stateNode, Iy(ve), s1(ve), Q1();
          break;
        }
        case ze: {
          q1(ve);
          break;
        }
        case Be:
          Iy(ve);
          break;
        case gt:
          Ny(ve);
          break;
        case on:
          Ny(ve);
          break;
        case tt:
          var Fe = ve.type._context;
          w1(Fe, ve);
          break;
        case _n:
        case en:
          Ex(ve);
          break;
      }
    }
    var JT = null;
    JT = /* @__PURE__ */ new Set();
    var $w = !1, ss = !1, NR = typeof WeakSet == "function" ? WeakSet : Set, dr = null, By = null, zy = null;
    function MR(me) {
      wd(null, function() {
        throw me;
      }), hb();
    }
    var jR = function(me, ve) {
      if (ve.props = me.memoizedProps, ve.state = me.memoizedState, me.mode & Rr)
        try {
          Xc(), ve.componentWillUnmount();
        } finally {
          Kc(me);
        }
      else
        ve.componentWillUnmount();
    };
    function wk(me, ve) {
      try {
        Qf(Ri, me);
      } catch (Ie) {
        ta(me, ve, Ie);
      }
    }
    function BE(me, ve, Ie) {
      try {
        jR(me, Ie);
      } catch (Me) {
        ta(me, ve, Me);
      }
    }
    function DR(me, ve, Ie) {
      try {
        Ie.componentDidMount();
      } catch (Me) {
        ta(me, ve, Me);
      }
    }
    function _k(me, ve) {
      try {
        jk(me);
      } catch (Ie) {
        ta(me, ve, Ie);
      }
    }
    function Uy(me, ve) {
      var Ie = me.ref;
      if (Ie !== null)
        if (typeof Ie == "function") {
          var Me;
          try {
            if (Fn && Qn && me.mode & Rr)
              try {
                Xc(), Me = Ie(null);
              } finally {
                Kc(me);
              }
            else
              Me = Ie(null);
          } catch (Fe) {
            ta(me, ve, Fe);
          }
          typeof Me == "function" && xe("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Mr(me));
        } else
          Ie.current = null;
    }
    function Iw(me, ve, Ie) {
      try {
        Ie();
      } catch (Me) {
        ta(me, ve, Me);
      }
    }
    var Ik = !1;
    function LR(me, ve) {
      KO(me.containerInfo), dr = ve, FR();
      var Ie = Ik;
      return Ik = !1, Ie;
    }
    function FR() {
      for (; dr !== null; ) {
        var me = dr, ve = me.child;
        (me.subtreeFlags & vf) !== Sr && ve !== null ? (ve.return = me, dr = ve) : BR();
      }
    }
    function BR() {
      for (; dr !== null; ) {
        var me = dr;
        mo(me);
        try {
          zR(me);
        } catch (Ie) {
          ta(me, me.return, Ie);
        }
        Qo();
        var ve = me.sibling;
        if (ve !== null) {
          ve.return = me.return, dr = ve;
          return;
        }
        dr = me.return;
      }
    }
    function zR(me) {
      var ve = me.alternate, Ie = me.flags;
      if ((Ie & cu) !== Sr) {
        switch (mo(me), me.tag) {
          case $e:
          case it:
          case St:
            break;
          case Re: {
            if (ve !== null) {
              var Me = ve.memoizedProps, Fe = ve.memoizedState, Ze = me.stateNode;
              me.type === me.elementType && !Jh && (Ze.props !== me.memoizedProps && xe("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Mr(me) || "instance"), Ze.state !== me.memoizedState && xe("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Mr(me) || "instance"));
              var Xe = Ze.getSnapshotBeforeUpdate(me.elementType === me.type ? Me : Xl(me.type, Me), Fe);
              {
                var at = JT;
                Xe === void 0 && !at.has(me.type) && (at.add(me.type), xe("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Mr(me)));
              }
              Ze.__reactInternalSnapshotBeforeUpdate = Xe;
            }
            break;
          }
          case je: {
            {
              var pt = me.stateNode;
              dC(pt.containerInfo);
            }
            break;
          }
          case ze:
          case He:
          case Be:
          case Ft:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Qo();
      }
    }
    function nc(me, ve, Ie) {
      var Me = ve.updateQueue, Fe = Me !== null ? Me.lastEffect : null;
      if (Fe !== null) {
        var Ze = Fe.next, Xe = Ze;
        do {
          if ((Xe.tag & me) === me) {
            var at = Xe.destroy;
            Xe.destroy = void 0, at !== void 0 && ((me & as) !== Pu ? Pm(ve) : (me & Ri) !== Pu && Tm(ve), (me & Gc) !== Pu && Vv(!0), Iw(ve, Ie, at), (me & Gc) !== Pu && Vv(!1), (me & as) !== Pu ? kg() : (me & Ri) !== Pu && gf());
          }
          Xe = Xe.next;
        } while (Xe !== Ze);
      }
    }
    function Qf(me, ve) {
      var Ie = ve.updateQueue, Me = Ie !== null ? Ie.lastEffect : null;
      if (Me !== null) {
        var Fe = Me.next, Ze = Fe;
        do {
          if ((Ze.tag & me) === me) {
            (me & as) !== Pu ? Tg(ve) : (me & Ri) !== Pu && Og(ve);
            var Xe = Ze.create;
            (me & Gc) !== Pu && Vv(!0), Ze.destroy = Xe(), (me & Gc) !== Pu && Vv(!1), (me & as) !== Pu ? Tb() : (me & Ri) !== Pu && Ag();
            {
              var at = Ze.destroy;
              if (at !== void 0 && typeof at != "function") {
                var pt = void 0;
                (Ze.tag & Ri) !== Sr ? pt = "useLayoutEffect" : (Ze.tag & Gc) !== Sr ? pt = "useInsertionEffect" : pt = "useEffect";
                var wt = void 0;
                at === null ? wt = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof at.then == "function" ? wt = `

It looks like you wrote ` + pt + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + pt + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : wt = " You returned: " + at, xe("%s must not return anything besides a function, which is used for clean-up.%s", pt, wt);
              }
            }
          }
          Ze = Ze.next;
        } while (Ze !== Fe);
      }
    }
    function UR(me, ve) {
      if ((ve.flags & qr) !== Sr)
        switch (ve.tag) {
          case ht: {
            var Ie = ve.stateNode.passiveEffectDuration, Me = ve.memoizedProps, Fe = Me.id, Ze = Me.onPostCommit, Xe = ST(), at = ve.alternate === null ? "mount" : "update";
            xT() && (at = "nested-update"), typeof Ze == "function" && Ze(Fe, at, Ie, Xe);
            var pt = ve.return;
            e:
              for (; pt !== null; ) {
                switch (pt.tag) {
                  case je:
                    var wt = pt.stateNode;
                    wt.passiveEffectDuration += Ie;
                    break e;
                  case ht:
                    var Ct = pt.stateNode;
                    Ct.passiveEffectDuration += Ie;
                    break e;
                }
                pt = pt.return;
              }
            break;
          }
        }
    }
    function VR(me, ve, Ie, Me) {
      if ((Ie.flags & Wi) !== Sr)
        switch (Ie.tag) {
          case $e:
          case it:
          case St: {
            if (!ss)
              if (Ie.mode & Rr)
                try {
                  Xc(), Qf(Ri | Ii, Ie);
                } finally {
                  Kc(Ie);
                }
              else
                Qf(Ri | Ii, Ie);
            break;
          }
          case Re: {
            var Fe = Ie.stateNode;
            if (Ie.flags & qr && !ss)
              if (ve === null)
                if (Ie.type === Ie.elementType && !Jh && (Fe.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Mr(Ie) || "instance"), Fe.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Mr(Ie) || "instance")), Ie.mode & Rr)
                  try {
                    Xc(), Fe.componentDidMount();
                  } finally {
                    Kc(Ie);
                  }
                else
                  Fe.componentDidMount();
              else {
                var Ze = Ie.elementType === Ie.type ? ve.memoizedProps : Xl(Ie.type, ve.memoizedProps), Xe = ve.memoizedState;
                if (Ie.type === Ie.elementType && !Jh && (Fe.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Mr(Ie) || "instance"), Fe.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Mr(Ie) || "instance")), Ie.mode & Rr)
                  try {
                    Xc(), Fe.componentDidUpdate(Ze, Xe, Fe.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Kc(Ie);
                  }
                else
                  Fe.componentDidUpdate(Ze, Xe, Fe.__reactInternalSnapshotBeforeUpdate);
              }
            var at = Ie.updateQueue;
            at !== null && (Ie.type === Ie.elementType && !Jh && (Fe.props !== Ie.memoizedProps && xe("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Mr(Ie) || "instance"), Fe.state !== Ie.memoizedState && xe("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Mr(Ie) || "instance")), DP(Ie, at, Fe));
            break;
          }
          case je: {
            var pt = Ie.updateQueue;
            if (pt !== null) {
              var wt = null;
              if (Ie.child !== null)
                switch (Ie.child.tag) {
                  case ze:
                    wt = Ie.child.stateNode;
                    break;
                  case Re:
                    wt = Ie.child.stateNode;
                    break;
                }
              DP(Ie, pt, wt);
            }
            break;
          }
          case ze: {
            var Ct = Ie.stateNode;
            if (ve === null && Ie.flags & qr) {
              var Jt = Ie.type, Gt = Ie.memoizedProps;
              RA(Ct, Jt, Gt);
            }
            break;
          }
          case He:
            break;
          case Be:
            break;
          case ht: {
            {
              var pn = Ie.memoizedProps, yn = pn.onCommit, En = pn.onRender, Kn = Ie.stateNode.effectDuration, vr = ST(), Or = ve === null ? "mount" : "update";
              xT() && (Or = "nested-update"), typeof En == "function" && En(Ie.memoizedProps.id, Or, Ie.actualDuration, Ie.treeBaseDuration, Ie.actualStartTime, vr);
              {
                typeof yn == "function" && yn(Ie.memoizedProps.id, Or, Kn, vr), zN(Ie);
                var co = Ie.return;
                e:
                  for (; co !== null; ) {
                    switch (co.tag) {
                      case je:
                        var Xr = co.stateNode;
                        Xr.effectDuration += Kn;
                        break e;
                      case ht:
                        var rn = co.stateNode;
                        rn.effectDuration += Kn;
                        break e;
                    }
                    co = co.return;
                  }
              }
            }
            break;
          }
          case gt: {
            XR(me, Ie);
            break;
          }
          case on:
          case Ft:
          case tn:
          case _n:
          case en:
          case Ht:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ss || Ie.flags & ws && jk(Ie);
    }
    function HR(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          if (me.mode & Rr)
            try {
              Xc(), wk(me, me.return);
            } finally {
              Kc(me);
            }
          else
            wk(me, me.return);
          break;
        }
        case Re: {
          var ve = me.stateNode;
          typeof ve.componentDidMount == "function" && DR(me, me.return, ve), _k(me, me.return);
          break;
        }
        case ze: {
          _k(me, me.return);
          break;
        }
      }
    }
    function WR(me, ve) {
      for (var Ie = null, Me = me; ; ) {
        if (Me.tag === ze) {
          if (Ie === null) {
            Ie = Me;
            try {
              var Fe = Me.stateNode;
              ve ? sC(Fe) : lC(Me.stateNode, Me.memoizedProps);
            } catch (Xe) {
              ta(me, me.return, Xe);
            }
          }
        } else if (Me.tag === He) {
          if (Ie === null)
            try {
              var Ze = Me.stateNode;
              ve ? uC(Ze) : cC(Ze, Me.memoizedProps);
            } catch (Xe) {
              ta(me, me.return, Xe);
            }
        } else if (!((Me.tag === _n || Me.tag === en) && Me.memoizedState !== null && Me !== me) && Me.child !== null) {
          Me.child.return = Me, Me = Me.child;
          continue;
        }
        if (Me === me)
          return;
        for (; Me.sibling === null; ) {
          if (Me.return === null || Me.return === me)
            return;
          Ie === Me && (Ie = null), Me = Me.return;
        }
        Ie === Me && (Ie = null), Me.sibling.return = Me.return, Me = Me.sibling;
      }
    }
    function jk(me) {
      var ve = me.ref;
      if (ve !== null) {
        var Ie = me.stateNode, Me;
        switch (me.tag) {
          case ze:
            Me = Ie;
            break;
          default:
            Me = Ie;
        }
        if (typeof ve == "function") {
          var Fe;
          if (me.mode & Rr)
            try {
              Xc(), Fe = ve(Me);
            } finally {
              Kc(me);
            }
          else
            Fe = ve(Me);
          typeof Fe == "function" && xe("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Mr(me));
        } else
          ve.hasOwnProperty("current") || xe("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Mr(me)), ve.current = Me;
      }
    }
    function qR(me) {
      var ve = me.alternate;
      ve !== null && (ve.return = null), me.return = null;
    }
    function Lk(me) {
      var ve = me.alternate;
      ve !== null && (me.alternate = null, Lk(ve));
      {
        if (me.child = null, me.deletions = null, me.sibling = null, me.tag === ze) {
          var Ie = me.stateNode;
          Ie !== null && UC(Ie);
        }
        me.stateNode = null, me._debugOwner = null, me.return = null, me.dependencies = null, me.memoizedProps = null, me.memoizedState = null, me.pendingProps = null, me.stateNode = null, me.updateQueue = null;
      }
    }
    function ZR(me) {
      for (var ve = me.return; ve !== null; ) {
        if (Bk(ve))
          return ve;
        ve = ve.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Bk(me) {
      return me.tag === ze || me.tag === je || me.tag === Be;
    }
    function zk(me) {
      var ve = me;
      e:
        for (; ; ) {
          for (; ve.sibling === null; ) {
            if (ve.return === null || Bk(ve.return))
              return null;
            ve = ve.return;
          }
          for (ve.sibling.return = ve.return, ve = ve.sibling; ve.tag !== ze && ve.tag !== He && ve.tag !== Vt; ) {
            if (ve.flags & Ko || ve.child === null || ve.tag === Be)
              continue e;
            ve.child.return = ve, ve = ve.child;
          }
          if (!(ve.flags & Ko))
            return ve.stateNode;
        }
    }
    function YR(me) {
      var ve = ZR(me);
      switch (ve.tag) {
        case ze: {
          var Ie = ve.stateNode;
          ve.flags & Co && (PS(Ie), ve.flags &= ~Co);
          var Me = zk(me);
          UE(me, Me, Ie);
          break;
        }
        case je:
        case Be: {
          var Fe = ve.stateNode.containerInfo, Ze = zk(me);
          zE(me, Ze, Fe);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function zE(me, ve, Ie) {
      var Me = me.tag, Fe = Me === ze || Me === He;
      if (Fe) {
        var Ze = me.stateNode;
        ve ? rC(Ie, Ze, ve) : tC(Ie, Ze);
      } else if (Me !== Be) {
        var Xe = me.child;
        if (Xe !== null) {
          zE(Xe, ve, Ie);
          for (var at = Xe.sibling; at !== null; )
            zE(at, ve, Ie), at = at.sibling;
        }
      }
    }
    function UE(me, ve, Ie) {
      var Me = me.tag, Fe = Me === ze || Me === He;
      if (Fe) {
        var Ze = me.stateNode;
        ve ? nC(Ie, Ze, ve) : eC(Ie, Ze);
      } else if (Me !== Be) {
        var Xe = me.child;
        if (Xe !== null) {
          UE(Xe, ve, Ie);
          for (var at = Xe.sibling; at !== null; )
            UE(at, ve, Ie), at = at.sibling;
        }
      }
    }
    var us = null, rc = !1;
    function QR(me, ve, Ie) {
      {
        var Me = ve;
        e:
          for (; Me !== null; ) {
            switch (Me.tag) {
              case ze: {
                us = Me.stateNode, rc = !1;
                break e;
              }
              case je: {
                us = Me.stateNode.containerInfo, rc = !0;
                break e;
              }
              case Be: {
                us = Me.stateNode.containerInfo, rc = !0;
                break e;
              }
            }
            Me = Me.return;
          }
        if (us === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        Vk(me, ve, Ie), us = null, rc = !1;
      }
      qR(Ie);
    }
    function Kf(me, ve, Ie) {
      for (var Me = Ie.child; Me !== null; )
        Vk(me, ve, Me), Me = Me.sibling;
    }
    function Vk(me, ve, Ie) {
      switch (Sb(Ie), Ie.tag) {
        case ze:
          ss || Uy(Ie, ve);
        case He: {
          {
            var Me = us, Fe = rc;
            us = null, Kf(me, ve, Ie), us = Me, rc = Fe, us !== null && (rc ? aC(us, Ie.stateNode) : oC(us, Ie.stateNode));
          }
          return;
        }
        case Vt: {
          us !== null && (rc ? iC(us, Ie.stateNode) : J_(us, Ie.stateNode));
          return;
        }
        case Be: {
          {
            var Ze = us, Xe = rc;
            us = Ie.stateNode.containerInfo, rc = !0, Kf(me, ve, Ie), us = Ze, rc = Xe;
          }
          return;
        }
        case $e:
        case it:
        case At:
        case St: {
          if (!ss) {
            var at = Ie.updateQueue;
            if (at !== null) {
              var pt = at.lastEffect;
              if (pt !== null) {
                var wt = pt.next, Ct = wt;
                do {
                  var Jt = Ct, Gt = Jt.destroy, pn = Jt.tag;
                  Gt !== void 0 && ((pn & Gc) !== Pu ? Iw(Ie, ve, Gt) : (pn & Ri) !== Pu && (Tm(Ie), Ie.mode & Rr ? (Xc(), Iw(Ie, ve, Gt), Kc(Ie)) : Iw(Ie, ve, Gt), gf())), Ct = Ct.next;
                } while (Ct !== wt);
              }
            }
          }
          Kf(me, ve, Ie);
          return;
        }
        case Re: {
          if (!ss) {
            Uy(Ie, ve);
            var yn = Ie.stateNode;
            typeof yn.componentWillUnmount == "function" && BE(Ie, ve, yn);
          }
          Kf(me, ve, Ie);
          return;
        }
        case tn: {
          Kf(me, ve, Ie);
          return;
        }
        case _n: {
          if (Ie.mode & oo) {
            var En = ss;
            ss = En || Ie.memoizedState !== null, Kf(me, ve, Ie), ss = En;
          } else
            Kf(me, ve, Ie);
          break;
        }
        default: {
          Kf(me, ve, Ie);
          return;
        }
      }
    }
    function KR(me) {
      me.memoizedState;
    }
    function XR(me, ve) {
      var Ie = ve.memoizedState;
      if (Ie === null) {
        var Me = ve.alternate;
        if (Me !== null) {
          var Fe = Me.memoizedState;
          if (Fe !== null) {
            var Ze = Fe.dehydrated;
            Ze !== null && PC(Ze);
          }
        }
      }
    }
    function Hk(me) {
      var ve = me.updateQueue;
      if (ve !== null) {
        me.updateQueue = null;
        var Ie = me.stateNode;
        Ie === null && (Ie = me.stateNode = new NR()), ve.forEach(function(Me) {
          var Fe = GN.bind(null, me, Me);
          if (!Ie.has(Me)) {
            if (Ie.add(Me), Si)
              if (By !== null && zy !== null)
                Uv(zy, By);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            Me.then(Fe, Fe);
          }
        });
      }
    }
    function JR(me, ve, Ie) {
      By = Ie, zy = me, mo(ve), qk(ve, me), mo(ve), By = null, zy = null;
    }
    function ac(me, ve, Ie) {
      var Me = ve.deletions;
      if (Me !== null)
        for (var Fe = 0; Fe < Me.length; Fe++) {
          var Ze = Me[Fe];
          try {
            QR(me, ve, Ze);
          } catch (pt) {
            ta(Ze, ve, pt);
          }
        }
      var Xe = El();
      if (ve.subtreeFlags & xs)
        for (var at = ve.child; at !== null; )
          mo(at), qk(at, me), at = at.sibling;
      mo(Xe);
    }
    function qk(me, ve, Ie) {
      var Me = me.alternate, Fe = me.flags;
      switch (me.tag) {
        case $e:
        case it:
        case At:
        case St: {
          if (ac(ve, me), Jc(me), Fe & qr) {
            try {
              nc(Gc | Ii, me, me.return), Qf(Gc | Ii, me);
            } catch (jr) {
              ta(me, me.return, jr);
            }
            if (me.mode & Rr) {
              try {
                Xc(), nc(Ri | Ii, me, me.return);
              } catch (jr) {
                ta(me, me.return, jr);
              }
              Kc(me);
            } else
              try {
                nc(Ri | Ii, me, me.return);
              } catch (jr) {
                ta(me, me.return, jr);
              }
          }
          return;
        }
        case Re: {
          ac(ve, me), Jc(me), Fe & ws && Me !== null && Uy(Me, Me.return);
          return;
        }
        case ze: {
          ac(ve, me), Jc(me), Fe & ws && Me !== null && Uy(Me, Me.return);
          {
            if (me.flags & Co) {
              var Ze = me.stateNode;
              try {
                PS(Ze);
              } catch (jr) {
                ta(me, me.return, jr);
              }
            }
            if (Fe & qr) {
              var Xe = me.stateNode;
              if (Xe != null) {
                var at = me.memoizedProps, pt = Me !== null ? Me.memoizedProps : at, wt = me.type, Ct = me.updateQueue;
                if (me.updateQueue = null, Ct !== null)
                  try {
                    BA(Xe, Ct, wt, pt, at, me);
                  } catch (jr) {
                    ta(me, me.return, jr);
                  }
              }
            }
          }
          return;
        }
        case He: {
          if (ac(ve, me), Jc(me), Fe & qr) {
            if (me.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Jt = me.stateNode, Gt = me.memoizedProps, pn = Me !== null ? Me.memoizedProps : Gt;
            try {
              qA(Jt, pn, Gt);
            } catch (jr) {
              ta(me, me.return, jr);
            }
          }
          return;
        }
        case je: {
          if (ac(ve, me), Jc(me), Fe & qr && Me !== null) {
            var yn = Me.memoizedState;
            if (yn.isDehydrated)
              try {
                SC(ve.containerInfo);
              } catch (jr) {
                ta(me, me.return, jr);
              }
          }
          return;
        }
        case Be: {
          ac(ve, me), Jc(me);
          return;
        }
        case gt: {
          ac(ve, me), Jc(me);
          var En = me.child;
          if (En.flags & gc) {
            var Kn = En.stateNode, vr = En.memoizedState, Or = vr !== null;
            if (Kn.isHidden = Or, Or) {
              var co = En.alternate !== null && En.alternate.memoizedState !== null;
              co || RN();
            }
          }
          if (Fe & qr) {
            try {
              KR(me);
            } catch (jr) {
              ta(me, me.return, jr);
            }
            Hk(me);
          }
          return;
        }
        case _n: {
          var Xr = Me !== null && Me.memoizedState !== null;
          if (me.mode & oo) {
            var rn = ss;
            ss = rn || Xr, ac(ve, me), ss = rn;
          } else
            ac(ve, me);
          if (Jc(me), Fe & gc) {
            var wn = me.stateNode, an = me.memoizedState, Bn = an !== null, nr = me;
            if (wn.isHidden = Bn, Bn && !Xr && (nr.mode & oo) !== Tr) {
              dr = nr;
              for (var Xn = nr.child; Xn !== null; )
                dr = Xn, tN(Xn), Xn = Xn.sibling;
            }
            WR(nr, Bn);
          }
          return;
        }
        case on: {
          ac(ve, me), Jc(me), Fe & qr && Hk(me);
          return;
        }
        case tn:
          return;
        default: {
          ac(ve, me), Jc(me);
          return;
        }
      }
    }
    function Jc(me) {
      var ve = me.flags;
      if (ve & Ko) {
        try {
          YR(me);
        } catch (Ie) {
          ta(me, me.return, Ie);
        }
        me.flags &= ~Ko;
      }
      ve & du && (me.flags &= ~du);
    }
    function eN(me, ve, Ie) {
      By = Ie, zy = ve, dr = me, Gk(me, ve, Ie), By = null, zy = null;
    }
    function Gk(me, ve, Ie) {
      for (var Me = (me.mode & oo) !== Tr; dr !== null; ) {
        var Fe = dr, Ze = Fe.child;
        if (Fe.tag === _n && Me) {
          var Xe = Fe.memoizedState !== null, at = Xe || $w;
          if (at) {
            VE(me, ve, Ie);
            continue;
          } else {
            var pt = Fe.alternate, wt = pt !== null && pt.memoizedState !== null, Ct = wt || ss, Jt = $w, Gt = ss;
            $w = at, ss = Ct, ss && !Gt && (dr = Fe, nN(Fe));
            for (var pn = Ze; pn !== null; )
              dr = pn, Gk(pn, ve, Ie), pn = pn.sibling;
            dr = Fe, $w = Jt, ss = Gt, VE(me, ve, Ie);
            continue;
          }
        }
        (Fe.subtreeFlags & Wi) !== Sr && Ze !== null ? (Ze.return = Fe, dr = Ze) : VE(me, ve, Ie);
      }
    }
    function VE(me, ve, Ie) {
      for (; dr !== null; ) {
        var Me = dr;
        if ((Me.flags & Wi) !== Sr) {
          var Fe = Me.alternate;
          mo(Me);
          try {
            VR(ve, Fe, Me, Ie);
          } catch (Xe) {
            ta(Me, Me.return, Xe);
          }
          Qo();
        }
        if (Me === me) {
          dr = null;
          return;
        }
        var Ze = Me.sibling;
        if (Ze !== null) {
          Ze.return = Me.return, dr = Ze;
          return;
        }
        dr = Me.return;
      }
    }
    function tN(me) {
      for (; dr !== null; ) {
        var ve = dr, Ie = ve.child;
        switch (ve.tag) {
          case $e:
          case it:
          case At:
          case St: {
            if (ve.mode & Rr)
              try {
                Xc(), nc(Ri, ve, ve.return);
              } finally {
                Kc(ve);
              }
            else
              nc(Ri, ve, ve.return);
            break;
          }
          case Re: {
            Uy(ve, ve.return);
            var Me = ve.stateNode;
            typeof Me.componentWillUnmount == "function" && BE(ve, ve.return, Me);
            break;
          }
          case ze: {
            Uy(ve, ve.return);
            break;
          }
          case _n: {
            var Fe = ve.memoizedState !== null;
            if (Fe) {
              Qk(me);
              continue;
            }
            break;
          }
        }
        Ie !== null ? (Ie.return = ve, dr = Ie) : Qk(me);
      }
    }
    function Qk(me) {
      for (; dr !== null; ) {
        var ve = dr;
        if (ve === me) {
          dr = null;
          return;
        }
        var Ie = ve.sibling;
        if (Ie !== null) {
          Ie.return = ve.return, dr = Ie;
          return;
        }
        dr = ve.return;
      }
    }
    function nN(me) {
      for (; dr !== null; ) {
        var ve = dr, Ie = ve.child;
        if (ve.tag === _n) {
          var Me = ve.memoizedState !== null;
          if (Me) {
            Kk(me);
            continue;
          }
        }
        Ie !== null ? (Ie.return = ve, dr = Ie) : Kk(me);
      }
    }
    function Kk(me) {
      for (; dr !== null; ) {
        var ve = dr;
        mo(ve);
        try {
          HR(ve);
        } catch (Me) {
          ta(ve, ve.return, Me);
        }
        if (Qo(), ve === me) {
          dr = null;
          return;
        }
        var Ie = ve.sibling;
        if (Ie !== null) {
          Ie.return = ve.return, dr = Ie;
          return;
        }
        dr = ve.return;
      }
    }
    function rN(me, ve, Ie, Me) {
      dr = ve, oN(ve, me, Ie, Me);
    }
    function oN(me, ve, Ie, Me) {
      for (; dr !== null; ) {
        var Fe = dr, Ze = Fe.child;
        (Fe.subtreeFlags & fu) !== Sr && Ze !== null ? (Ze.return = Fe, dr = Ze) : aN(me, ve, Ie, Me);
      }
    }
    function aN(me, ve, Ie, Me) {
      for (; dr !== null; ) {
        var Fe = dr;
        if ((Fe.flags & sa) !== Sr) {
          mo(Fe);
          try {
            iN(ve, Fe, Ie, Me);
          } catch (Xe) {
            ta(Fe, Fe.return, Xe);
          }
          Qo();
        }
        if (Fe === me) {
          dr = null;
          return;
        }
        var Ze = Fe.sibling;
        if (Ze !== null) {
          Ze.return = Fe.return, dr = Ze;
          return;
        }
        dr = Fe.return;
      }
    }
    function iN(me, ve, Ie, Me) {
      switch (ve.tag) {
        case $e:
        case it:
        case St: {
          if (ve.mode & Rr) {
            wE();
            try {
              Qf(as | Ii, ve);
            } finally {
              gE(ve);
            }
          } else
            Qf(as | Ii, ve);
          break;
        }
      }
    }
    function sN(me) {
      dr = me, uN();
    }
    function uN() {
      for (; dr !== null; ) {
        var me = dr, ve = me.child;
        if ((dr.flags & ko) !== Sr) {
          var Ie = me.deletions;
          if (Ie !== null) {
            for (var Me = 0; Me < Ie.length; Me++) {
              var Fe = Ie[Me];
              dr = Fe, dN(Fe, me);
            }
            {
              var Ze = me.alternate;
              if (Ze !== null) {
                var Xe = Ze.child;
                if (Xe !== null) {
                  Ze.child = null;
                  do {
                    var at = Xe.sibling;
                    Xe.sibling = null, Xe = at;
                  } while (Xe !== null);
                }
              }
            }
            dr = me;
          }
        }
        (me.subtreeFlags & fu) !== Sr && ve !== null ? (ve.return = me, dr = ve) : lN();
      }
    }
    function lN() {
      for (; dr !== null; ) {
        var me = dr;
        (me.flags & sa) !== Sr && (mo(me), cN(me), Qo());
        var ve = me.sibling;
        if (ve !== null) {
          ve.return = me.return, dr = ve;
          return;
        }
        dr = me.return;
      }
    }
    function cN(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          me.mode & Rr ? (wE(), nc(as | Ii, me, me.return), gE(me)) : nc(as | Ii, me, me.return);
          break;
        }
      }
    }
    function dN(me, ve) {
      for (; dr !== null; ) {
        var Ie = dr;
        mo(Ie), pN(Ie, ve), Qo();
        var Me = Ie.child;
        Me !== null ? (Me.return = Ie, dr = Me) : fN(me);
      }
    }
    function fN(me) {
      for (; dr !== null; ) {
        var ve = dr, Ie = ve.sibling, Me = ve.return;
        if (Lk(ve), ve === me) {
          dr = null;
          return;
        }
        if (Ie !== null) {
          Ie.return = Me, dr = Ie;
          return;
        }
        dr = Me;
      }
    }
    function pN(me, ve) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          me.mode & Rr ? (wE(), nc(as, me, ve), gE(me)) : nc(as, me, ve);
          break;
        }
      }
    }
    function hN(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          try {
            Qf(Ri | Ii, me);
          } catch (Ie) {
            ta(me, me.return, Ie);
          }
          break;
        }
        case Re: {
          var ve = me.stateNode;
          try {
            ve.componentDidMount();
          } catch (Ie) {
            ta(me, me.return, Ie);
          }
          break;
        }
      }
    }
    function mN(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          try {
            Qf(as | Ii, me);
          } catch (ve) {
            ta(me, me.return, ve);
          }
          break;
        }
      }
    }
    function yN(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St: {
          try {
            nc(Ri | Ii, me, me.return);
          } catch (Ie) {
            ta(me, me.return, Ie);
          }
          break;
        }
        case Re: {
          var ve = me.stateNode;
          typeof ve.componentWillUnmount == "function" && BE(me, me.return, ve);
          break;
        }
      }
    }
    function bN(me) {
      switch (me.tag) {
        case $e:
        case it:
        case St:
          try {
            nc(as | Ii, me, me.return);
          } catch (ve) {
            ta(me, me.return, ve);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Iv = Symbol.for;
      Iv("selector.component"), Iv("selector.has_pseudo_class"), Iv("selector.role"), Iv("selector.test_id"), Iv("selector.text");
    }
    var vN = [];
    function gN() {
      vN.forEach(function(me) {
        return me();
      });
    }
    var wN = fe.ReactCurrentActQueue;
    function _N(me) {
      {
        var ve = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, Ie = typeof jest < "u";
        return Ie && ve !== !1;
      }
    }
    function Jk() {
      {
        var me = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !me && wN.current !== null && xe("The current testing environment is not configured to support act(...)"), me;
      }
    }
    var EN = Math.ceil, HE = fe.ReactCurrentDispatcher, WE = fe.ReactCurrentOwner, ls = fe.ReactCurrentBatchConfig, ic = fe.ReactCurrentActQueue, ji = 0, e2 = 1, cs = 2, bl = 4, ef = 0, Rv = 1, em = 2, Rw = 3, Nv = 4, t2 = 5, qE = 6, bo = ji, Js = null, $a = null, Di = xn, ed = xn, ZE = zf(xn), Li = ef, Mv = null, Nw = xn, jv = xn, Mw = xn, Dv = null, $u = null, GE = 0, n2 = 500, r2 = 1 / 0, xN = 500, tf = null;
    function Lv() {
      r2 = da() + xN;
    }
    function o2() {
      return r2;
    }
    var jw = !1, YE = null, Vy = null, tm = !1, Xf = null, Fv = xn, QE = [], KE = null, SN = 50, Bv = 0, XE = null, JE = !1, Dw = !1, PN = 50, Hy = 0, Lw = null, Fw = Vo, Bw = xn, a2 = !1;
    function zw() {
      return Js;
    }
    function eu() {
      return (bo & (cs | bl)) !== ji ? da() : (Fw !== Vo || (Fw = da()), Fw);
    }
    function Jf(me) {
      var ve = me.mode;
      if ((ve & oo) === Tr)
        return Nr;
      if ((bo & cs) !== ji && Di !== xn)
        return ei(Di);
      var Ie = tI() !== J$;
      if (Ie) {
        if (ls.transition !== null) {
          var Me = ls.transition;
          Me._updatedFibers || (Me._updatedFibers = /* @__PURE__ */ new Set()), Me._updatedFibers.add(me);
        }
        return Bw === yo && (Bw = Ib()), Bw;
      }
      var Fe = Gs();
      if (Fe !== yo)
        return Fe;
      var Ze = yA();
      return Ze;
    }
    function TN(me) {
      var ve = me.mode;
      return (ve & oo) === Tr ? Nr : E_();
    }
    function Fi(me, ve, Ie, Me) {
      QN(), a2 && xe("useInsertionEffect must not schedule updates."), JE && (Dw = !0), kf(me, Ie, Me), (bo & cs) !== xn && me === Js ? JN(ve) : (Si && Dg(me, ve, Ie), eM(ve), me === Js && ((bo & cs) === ji && (jv = Zr(jv, Ie)), Li === Nv && ep(me, Di)), Iu(me, Me), Ie === Nr && bo === ji && (ve.mode & oo) === Tr && !ic.isBatchingLegacy && (Lv(), LS()));
    }
    function kN(me, ve, Ie) {
      var Me = me.current;
      Me.lanes = ve, kf(me, ve, Ie), Iu(me, Ie);
    }
    function ON(me) {
      return (bo & cs) !== ji;
    }
    function Iu(me, ve) {
      var Ie = me.callbackNode;
      g_(me, ve);
      var Me = Ip(me, me === Js ? Di : xn);
      if (Me === xn) {
        Ie !== null && x2(Ie), me.callbackNode = null, me.callbackPriority = yo;
        return;
      }
      var Fe = za(Me), Ze = me.callbackPriority;
      if (Ze === Fe && !(ic.current !== null && Ie !== kx)) {
        Ie == null && Ze !== Nr && xe("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      Ie != null && x2(Ie);
      var Xe;
      if (Fe === Nr)
        me.tag === Uf ? (ic.isBatchingLegacy !== null && (ic.didScheduleLegacyUpdate = !0), WC(c2.bind(null, me))) : DS(c2.bind(null, me)), ic.current !== null ? ic.current.push(Vf) : OA(function() {
          (bo & (cs | bl)) === ji && Vf();
        }), Xe = null;
      else {
        var at;
        switch (Fg(Me)) {
          case Os:
            at = Em;
            break;
          case yu:
            at = qs;
            break;
          case Pi:
            at = ul;
            break;
          case ty:
            at = Pc;
            break;
          default:
            at = ul;
            break;
        }
        Xe = Ox(at, i2.bind(null, me));
      }
      me.callbackPriority = Fe, me.callbackNode = Xe;
    }
    function i2(me, ve) {
      if (WI(), Fw = Vo, Bw = xn, (bo & (cs | bl)) !== ji)
        throw new Error("Should not already be working.");
      var Ie = me.callbackNode, Me = rf();
      if (Me && me.callbackNode !== Ie)
        return null;
      var Fe = Ip(me, me === Js ? Di : xn);
      if (Fe === xn)
        return null;
      var Ze = !Np(me, Fe) && !Mg(me, Fe) && !ve, Xe = Ze ? LN(me, Fe) : Vw(me, Fe);
      if (Xe !== ef) {
        if (Xe === em) {
          var at = Cb(me);
          at !== xn && (Fe = at, Xe = wx(me, at));
        }
        if (Xe === Rv) {
          var pt = Mv;
          throw nm(me, xn), ep(me, Fe), Iu(me, da()), pt;
        }
        if (Xe === qE)
          ep(me, Fe);
        else {
          var wt = !Np(me, Fe), Ct = me.current.alternate;
          if (wt && !CN(Ct)) {
            if (Xe = Vw(me, Fe), Xe === em) {
              var Jt = Cb(me);
              Jt !== xn && (Fe = Jt, Xe = wx(me, Jt));
            }
            if (Xe === Rv) {
              var Gt = Mv;
              throw nm(me, xn), ep(me, Fe), Iu(me, da()), Gt;
            }
          }
          me.finishedWork = Ct, me.finishedLanes = Fe, AN(me, Xe, Fe);
        }
      }
      return Iu(me, da()), me.callbackNode === Ie ? i2.bind(null, me) : null;
    }
    function wx(me, ve) {
      var Ie = Dv;
      if (Nd(me)) {
        var Me = nm(me, ve);
        Me.flags |= Sa, LC(me.containerInfo);
      }
      var Fe = Vw(me, ve);
      if (Fe !== em) {
        var Ze = $u;
        $u = Ie, Ze !== null && u2(Ze);
      }
      return Fe;
    }
    function u2(me) {
      $u === null ? $u = me : $u.push.apply($u, me);
    }
    function AN(me, ve, Ie) {
      switch (ve) {
        case ef:
        case Rv:
          throw new Error("Root did not complete. This is a bug in React.");
        case em: {
          rm(me, $u, tf);
          break;
        }
        case Rw: {
          if (ep(me, Ie), qm(Ie) && !S2()) {
            var Me = GE + n2 - da();
            if (Me > 10) {
              var Fe = Ip(me, xn);
              if (Fe !== xn)
                break;
              var Ze = me.suspendedLanes;
              if (!Rd(Ze, Ie)) {
                eu(), Qm(me, Ze);
                break;
              }
              me.timeoutHandle = K_(rm.bind(null, me, $u, tf), Me);
              break;
            }
          }
          rm(me, $u, tf);
          break;
        }
        case Nv: {
          if (ep(me, Ie), Ng(Ie))
            break;
          if (!S2()) {
            var Xe = Rg(me, Ie), at = Xe, pt = da() - at, wt = YN(pt) - pt;
            if (wt > 10) {
              me.timeoutHandle = K_(rm.bind(null, me, $u, tf), wt);
              break;
            }
          }
          rm(me, $u, tf);
          break;
        }
        case t2: {
          rm(me, $u, tf);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function CN(me) {
      for (var ve = me; ; ) {
        if (ve.flags & Sp) {
          var Ie = ve.updateQueue;
          if (Ie !== null) {
            var Me = Ie.stores;
            if (Me !== null)
              for (var Fe = 0; Fe < Me.length; Fe++) {
                var Ze = Me[Fe], Xe = Ze.getSnapshot, at = Ze.value;
                try {
                  if (!Jn(Xe(), at))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var pt = ve.child;
        if (ve.subtreeFlags & Sp && pt !== null) {
          pt.return = ve, ve = pt;
          continue;
        }
        if (ve === me)
          return !0;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === me)
            return !0;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
      return !0;
    }
    function ep(me, ve) {
      ve = Tf(ve, Mw), ve = Tf(ve, jv), Mb(me, ve);
    }
    function c2(me) {
      if (GI(), (bo & (cs | bl)) !== ji)
        throw new Error("Should not already be working.");
      rf();
      var ve = Ip(me, xn);
      if (!ks(ve, Nr))
        return Iu(me, da()), null;
      var Ie = Vw(me, ve);
      if (me.tag !== Uf && Ie === em) {
        var Me = Cb(me);
        Me !== xn && (ve = Me, Ie = wx(me, Me));
      }
      if (Ie === Rv) {
        var Fe = Mv;
        throw nm(me, xn), ep(me, ve), Iu(me, da()), Fe;
      }
      if (Ie === qE)
        throw new Error("Root did not complete. This is a bug in React.");
      var Ze = me.current.alternate;
      return me.finishedWork = Ze, me.finishedLanes = ve, rm(me, $u, tf), Iu(me, da()), null;
    }
    function $N(me, ve) {
      ve !== xn && (Mp(me, Zr(ve, Nr)), Iu(me, da()), (bo & (cs | bl)) === ji && (Lv(), Vf()));
    }
    function _x(me, ve) {
      var Ie = bo;
      bo |= e2;
      try {
        return me(ve);
      } finally {
        bo = Ie, bo === ji && !ic.isBatchingLegacy && (Lv(), LS());
      }
    }
    function IN(me, ve, Ie, Me, Fe) {
      var Ze = Gs(), Xe = ls.transition;
      try {
        return ls.transition = null, ti(Os), me(ve, Ie, Me, Fe);
      } finally {
        ti(Ze), ls.transition = Xe, bo === ji && Lv();
      }
    }
    function nf(me) {
      Xf !== null && Xf.tag === Uf && (bo & (cs | bl)) === ji && rf();
      var ve = bo;
      bo |= e2;
      var Ie = ls.transition, Me = Gs();
      try {
        return ls.transition = null, ti(Os), me ? me() : void 0;
      } finally {
        ti(Me), ls.transition = Ie, bo = ve, (bo & (cs | bl)) === ji && Vf();
      }
    }
    function d2() {
      return (bo & (cs | bl)) !== ji;
    }
    function Uw(me, ve) {
      $s(ZE, ed, me), ed = Zr(ed, ve);
    }
    function Ex(me) {
      ed = ZE.current, Cs(ZE, me);
    }
    function nm(me, ve) {
      me.finishedWork = null, me.finishedLanes = xn;
      var Ie = me.timeoutHandle;
      if (Ie !== X_ && (me.timeoutHandle = X_, _A(Ie)), $a !== null)
        for (var Me = $a.return; Me !== null; ) {
          var Fe = Me.alternate;
          XT(Fe, Me), Me = Me.return;
        }
      Js = me;
      var Ze = om(me.current, null);
      return $a = Ze, Di = ed = ve, Li = ef, Mv = null, Nw = xn, jv = xn, Mw = xn, Dv = null, $u = null, aI(), Ql.discardPendingWarnings(), Ze;
    }
    function f2(me, ve) {
      do {
        var Ie = $a;
        try {
          if (Z0(), eT(), Qo(), WE.current = null, Ie === null || Ie.return === null) {
            Li = Rv, Mv = ve, $a = null;
            return;
          }
          if (Fn && Ie.mode & Rr && kw(Ie, !0), vn)
            if (Ed(), ve !== null && typeof ve == "object" && typeof ve.then == "function") {
              var Me = ve;
              Cg(Ie, Me, Di);
            } else
              km(Ie, ve, Di);
          eR(me, Ie.return, Ie, ve, Di), y2(Ie);
        } catch (Fe) {
          ve = Fe, $a === Ie && Ie !== null ? (Ie = Ie.return, $a = Ie) : Ie = $a;
          continue;
        }
        return;
      } while (!0);
    }
    function p2() {
      var me = HE.current;
      return HE.current = Ew, me === null ? Ew : me;
    }
    function h2(me) {
      HE.current = me;
    }
    function RN() {
      GE = da();
    }
    function zv(me) {
      Nw = Zr(me, Nw);
    }
    function NN() {
      Li === ef && (Li = Rw);
    }
    function xx() {
      (Li === ef || Li === Rw || Li === em) && (Li = Nv), Js !== null && (Rp(Nw) || Rp(jv)) && ep(Js, Di);
    }
    function MN(me) {
      Li !== Nv && (Li = em), Dv === null ? Dv = [me] : Dv.push(me);
    }
    function jN() {
      return Li === ef;
    }
    function Vw(me, ve) {
      var Ie = bo;
      bo |= cs;
      var Me = p2();
      if (Js !== me || Di !== ve) {
        if (Si) {
          var Fe = me.memoizedUpdaters;
          Fe.size > 0 && (Uv(me, Di), Fe.clear()), jb(me, ve);
        }
        tf = ey(), nm(me, ve);
      }
      Hu(ve);
      do
        try {
          DN();
          break;
        } catch (Ze) {
          f2(me, Ze);
        }
      while (!0);
      if (Z0(), bo = Ie, h2(Me), $a !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return _f(), Js = null, Di = xn, Li;
    }
    function DN() {
      for (; $a !== null; )
        m2($a);
    }
    function LN(me, ve) {
      var Ie = bo;
      bo |= cs;
      var Me = p2();
      if (Js !== me || Di !== ve) {
        if (Si) {
          var Fe = me.memoizedUpdaters;
          Fe.size > 0 && (Uv(me, Di), Fe.clear()), jb(me, ve);
        }
        tf = ey(), Lv(), nm(me, ve);
      }
      Hu(ve);
      do
        try {
          FN();
          break;
        } catch (Ze) {
          f2(me, Ze);
        }
      while (!0);
      return Z0(), h2(Me), bo = Ie, $a !== null ? (kp(), ef) : (_f(), Js = null, Di = xn, Li);
    }
    function FN() {
      for (; $a !== null && !_m(); )
        m2($a);
    }
    function m2(me) {
      var ve = me.alternate;
      mo(me);
      var Ie;
      (me.mode & Rr) !== Tr ? (vE(me), Ie = Px(ve, me, ed), kw(me, !0)) : Ie = Px(ve, me, ed), Qo(), me.memoizedProps = me.pendingProps, Ie === null ? y2(me) : $a = Ie, WE.current = null;
    }
    function y2(me) {
      var ve = me;
      do {
        var Ie = ve.alternate, Me = ve.return;
        if ((ve.flags & Vs) === Sr) {
          mo(ve);
          var Fe = void 0;
          if ((ve.mode & Rr) === Tr ? Fe = KT(Ie, ve, ed) : (vE(ve), Fe = KT(Ie, ve, ed), kw(ve, !1)), Qo(), Fe !== null) {
            $a = Fe;
            return;
          }
        } else {
          var Ze = RR(Ie, ve);
          if (Ze !== null) {
            Ze.flags &= _g, $a = Ze;
            return;
          }
          if ((ve.mode & Rr) !== Tr) {
            kw(ve, !1);
            for (var Xe = ve.actualDuration, at = ve.child; at !== null; )
              Xe += at.actualDuration, at = at.sibling;
            ve.actualDuration = Xe;
          }
          if (Me !== null)
            Me.flags |= Vs, Me.subtreeFlags = Sr, Me.deletions = null;
          else {
            Li = qE, $a = null;
            return;
          }
        }
        var pt = ve.sibling;
        if (pt !== null) {
          $a = pt;
          return;
        }
        ve = Me, $a = ve;
      } while (ve !== null);
      Li === ef && (Li = t2);
    }
    function rm(me, ve, Ie) {
      var Me = Gs(), Fe = ls.transition;
      try {
        ls.transition = null, ti(Os), BN(me, ve, Ie, Me);
      } finally {
        ls.transition = Fe, ti(Me);
      }
      return null;
    }
    function BN(me, ve, Ie, Me) {
      do
        rf();
      while (Xf !== null);
      if (KN(), (bo & (cs | bl)) !== ji)
        throw new Error("Should not already be working.");
      var Fe = me.finishedWork, Ze = me.finishedLanes;
      if (Sm(Ze), Fe === null)
        return Pb(), null;
      if (Ze === xn && xe("root.finishedLanes should not be empty during a commit. This is a bug in React."), me.finishedWork = null, me.finishedLanes = xn, Fe === me.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      me.callbackNode = null, me.callbackPriority = yo;
      var Xe = Zr(Fe.lanes, Fe.childLanes);
      jg(me, Xe), me === Js && (Js = null, $a = null, Di = xn), ((Fe.subtreeFlags & fu) !== Sr || (Fe.flags & fu) !== Sr) && (tm || (tm = !0, KE = Ie, Ox(ul, function() {
        return rf(), null;
      })));
      var at = (Fe.subtreeFlags & (vf | xs | Wi | fu)) !== Sr, pt = (Fe.flags & (vf | xs | Wi | fu)) !== Sr;
      if (at || pt) {
        var wt = ls.transition;
        ls.transition = null;
        var Ct = Gs();
        ti(Os);
        var Jt = bo;
        bo |= bl, WE.current = null, LR(me, Fe), PT(), JR(me, Fe, Ze), XO(me.containerInfo), me.current = Fe, $g(Ze), eN(Fe, me, Ze), wf(), Sg(), bo = Jt, ti(Ct), ls.transition = wt;
      } else
        me.current = Fe, PT();
      var Gt = tm;
      if (tm ? (tm = !1, Xf = me, Fv = Ze) : (Hy = 0, Lw = null), Xe = me.pendingLanes, Xe === xn && (Vy = null), Gt || w2(me.current, !1), Ml(Fe.stateNode, Me), Si && me.memoizedUpdaters.clear(), gN(), Iu(me, da()), ve !== null)
        for (var pn = me.onRecoverableError, yn = 0; yn < ve.length; yn++) {
          var En = ve[yn], Kn = En.stack, vr = En.digest;
          pn(En.value, { componentStack: Kn, digest: vr });
        }
      if (jw) {
        jw = !1;
        var Or = YE;
        throw YE = null, Or;
      }
      return ks(Fv, Nr) && me.tag !== Uf && rf(), Xe = me.pendingLanes, ks(Xe, Nr) ? (VI(), me === XE ? Bv++ : (Bv = 0, XE = me)) : Bv = 0, Vf(), Pb(), null;
    }
    function rf() {
      if (Xf !== null) {
        var me = Fg(Fv), ve = qi(Pi, me), Ie = ls.transition, Me = Gs();
        try {
          return ls.transition = null, ti(ve), UN();
        } finally {
          ti(Me), ls.transition = Ie;
        }
      }
      return !1;
    }
    function zN(me) {
      QE.push(me), tm || (tm = !0, Ox(ul, function() {
        return rf(), null;
      }));
    }
    function UN() {
      if (Xf === null)
        return !1;
      var me = KE;
      KE = null;
      var ve = Xf, Ie = Fv;
      if (Xf = null, Fv = xn, (bo & (cs | bl)) !== ji)
        throw new Error("Cannot flush passive effects while already rendering.");
      JE = !0, Dw = !1, Ig(Ie);
      var Me = bo;
      bo |= bl, sN(ve.current), rN(ve, ve.current, Ie, me);
      {
        var Fe = QE;
        QE = [];
        for (var Ze = 0; Ze < Fe.length; Ze++) {
          var Xe = Fe[Ze];
          UR(ve, Xe);
        }
      }
      Tp(), w2(ve.current, !0), bo = Me, Vf(), Dw ? ve === Lw ? Hy++ : (Hy = 0, Lw = ve) : Hy = 0, JE = !1, Dw = !1, Ac(ve);
      {
        var at = ve.current.stateNode;
        at.effectDuration = 0, at.passiveEffectDuration = 0;
      }
      return !0;
    }
    function b2(me) {
      return Vy !== null && Vy.has(me);
    }
    function VN(me) {
      Vy === null ? Vy = /* @__PURE__ */ new Set([me]) : Vy.add(me);
    }
    function HN(me) {
      jw || (jw = !0, YE = me);
    }
    var WN = HN;
    function v2(me, ve, Ie) {
      var Me = Xh(Ie, ve), Fe = kT(me, Me, Nr), Ze = Wf(me, Fe, Nr), Xe = eu();
      Ze !== null && (kf(Ze, Nr, Xe), Iu(Ze, Xe));
    }
    function ta(me, ve, Ie) {
      if (MR(Ie), Vv(!1), me.tag === je) {
        v2(me, me, Ie);
        return;
      }
      var Me = null;
      for (Me = ve; Me !== null; ) {
        if (Me.tag === je) {
          v2(Me, me, Ie);
          return;
        } else if (Me.tag === Re) {
          var Fe = Me.type, Ze = Me.stateNode;
          if (typeof Fe.getDerivedStateFromError == "function" || typeof Ze.componentDidCatch == "function" && !b2(Ze)) {
            var Xe = Xh(Ie, me), at = SE(Me, Xe, Nr), pt = Wf(Me, at, Nr), wt = eu();
            pt !== null && (kf(pt, Nr, wt), Iu(pt, wt));
            return;
          }
        }
        Me = Me.return;
      }
      xe(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, Ie);
    }
    function qN(me, ve, Ie) {
      var Me = me.pingCache;
      Me !== null && Me.delete(ve);
      var Fe = eu();
      Qm(me, Ie), tM(me), Js === me && Rd(Di, Ie) && (Li === Nv || Li === Rw && qm(Di) && da() - GE < n2 ? nm(me, xn) : Mw = Zr(Mw, Ie)), Iu(me, Fe);
    }
    function g2(me, ve) {
      ve === yo && (ve = TN(me));
      var Ie = eu(), Me = Su(me, ve);
      Me !== null && (kf(Me, ve, Ie), Iu(Me, Ie));
    }
    function ZN(me) {
      var ve = me.memoizedState, Ie = yo;
      ve !== null && (Ie = ve.retryLane), g2(me, Ie);
    }
    function GN(me, ve) {
      var Ie = yo, Me;
      switch (me.tag) {
        case gt:
          Me = me.stateNode;
          var Fe = me.memoizedState;
          Fe !== null && (Ie = Fe.retryLane);
          break;
        case on:
          Me = me.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      Me !== null && Me.delete(ve), g2(me, Ie);
    }
    function YN(me) {
      return me < 120 ? 120 : me < 480 ? 480 : me < 1080 ? 1080 : me < 1920 ? 1920 : me < 3e3 ? 3e3 : me < 4320 ? 4320 : EN(me / 1960) * 1960;
    }
    function QN() {
      if (Bv > SN)
        throw Bv = 0, XE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Hy > PN && (Hy = 0, Lw = null, xe("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function KN() {
      Ql.flushLegacyContextWarning(), Ql.flushPendingUnsafeLifecycleWarnings();
    }
    function w2(me, ve) {
      mo(me), Hw(me, Es, yN), ve && Hw(me, _d, bN), Hw(me, Es, hN), ve && Hw(me, _d, mN), Qo();
    }
    function Hw(me, ve, Ie) {
      for (var Me = me, Fe = null; Me !== null; ) {
        var Ze = Me.subtreeFlags & ve;
        Me !== Fe && Me.child !== null && Ze !== Sr ? Me = Me.child : ((Me.flags & ve) !== Sr && Ie(Me), Me.sibling !== null ? Me = Me.sibling : Me = Fe = Me.return);
      }
    }
    var Ww = null;
    function _2(me) {
      {
        if ((bo & cs) !== ji || !(me.mode & oo))
          return;
        var ve = me.tag;
        if (ve !== Ne && ve !== je && ve !== Re && ve !== $e && ve !== it && ve !== At && ve !== St)
          return;
        var Ie = Mr(me) || "ReactComponent";
        if (Ww !== null) {
          if (Ww.has(Ie))
            return;
          Ww.add(Ie);
        } else
          Ww = /* @__PURE__ */ new Set([Ie]);
        var Me = Wo;
        try {
          mo(me), xe("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          Me ? mo(me) : Qo();
        }
      }
    }
    var Px;
    {
      var XN = null;
      Px = function(me, ve, Ie) {
        var Me = O2(XN, ve);
        try {
          return qT(me, ve, Ie);
        } catch (Ze) {
          if (JC() || Ze !== null && typeof Ze == "object" && typeof Ze.then == "function")
            throw Ze;
          if (Z0(), eT(), XT(me, ve), O2(ve, Me), ve.mode & Rr && vE(ve), wd(null, qT, null, me, ve, Ie), b_()) {
            var Fe = hb();
            typeof Fe == "object" && Fe !== null && Fe._suppressLogging && typeof Ze == "object" && Ze !== null && !Ze._suppressLogging && (Ze._suppressLogging = !0);
          }
          throw Ze;
        }
      };
    }
    var E2 = !1, Tx;
    Tx = /* @__PURE__ */ new Set();
    function JN(me) {
      if (La && !II())
        switch (me.tag) {
          case $e:
          case it:
          case St: {
            var ve = $a && Mr($a) || "Unknown", Ie = ve;
            if (!Tx.has(Ie)) {
              Tx.add(Ie);
              var Me = Mr(me) || "Unknown";
              xe("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", Me, ve, ve);
            }
            break;
          }
          case Re: {
            E2 || (xe("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), E2 = !0);
            break;
          }
        }
    }
    function Uv(me, ve) {
      if (Si) {
        var Ie = me.memoizedUpdaters;
        Ie.forEach(function(Me) {
          Dg(me, Me, ve);
        });
      }
    }
    var kx = {};
    function Ox(me, ve) {
      {
        var Ie = ic.current;
        return Ie !== null ? (Ie.push(ve), kx) : wm(me, ve);
      }
    }
    function x2(me) {
      if (me !== kx)
        return xg(me);
    }
    function S2() {
      return ic.current !== null;
    }
    function eM(me) {
      {
        if (me.mode & oo) {
          if (!Jk())
            return;
        } else if (!_N() || bo !== ji || me.tag !== $e && me.tag !== it && me.tag !== St)
          return;
        if (ic.current === null) {
          var ve = Wo;
          try {
            mo(me), xe(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Mr(me));
          } finally {
            ve ? mo(me) : Qo();
          }
        }
      }
    }
    function tM(me) {
      me.tag !== Uf && Jk() && ic.current === null && xe(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Vv(me) {
      a2 = me;
    }
    var vl = null, Wy = null, nM = function(me) {
      vl = me;
    };
    function qy(me) {
      {
        if (vl === null)
          return me;
        var ve = vl(me);
        return ve === void 0 ? me : ve.current;
      }
    }
    function Ax(me) {
      return qy(me);
    }
    function Cx(me) {
      {
        if (vl === null)
          return me;
        var ve = vl(me);
        if (ve === void 0) {
          if (me != null && typeof me.render == "function") {
            var Ie = qy(me.render);
            if (me.render !== Ie) {
              var Me = { $$typeof: hr, render: Ie };
              return me.displayName !== void 0 && (Me.displayName = me.displayName), Me;
            }
          }
          return me;
        }
        return ve.current;
      }
    }
    function P2(me, ve) {
      {
        if (vl === null)
          return !1;
        var Ie = me.elementType, Me = ve.type, Fe = !1, Ze = typeof Me == "object" && Me !== null ? Me.$$typeof : null;
        switch (me.tag) {
          case Re: {
            typeof Me == "function" && (Fe = !0);
            break;
          }
          case $e: {
            (typeof Me == "function" || Ze === gr) && (Fe = !0);
            break;
          }
          case it: {
            (Ze === hr || Ze === gr) && (Fe = !0);
            break;
          }
          case At:
          case St: {
            (Ze === zr || Ze === gr) && (Fe = !0);
            break;
          }
          default:
            return !1;
        }
        if (Fe) {
          var Xe = vl(Ie);
          if (Xe !== void 0 && Xe === vl(Me))
            return !0;
        }
        return !1;
      }
    }
    function T2(me) {
      {
        if (vl === null || typeof WeakSet != "function")
          return;
        Wy === null && (Wy = /* @__PURE__ */ new WeakSet()), Wy.add(me);
      }
    }
    var rM = function(me, ve) {
      {
        if (vl === null)
          return;
        var Ie = ve.staleFamilies, Me = ve.updatedFamilies;
        rf(), nf(function() {
          $x(me.current, Me, Ie);
        });
      }
    }, oM = function(me, ve) {
      {
        if (me.context !== Zu)
          return;
        rf(), nf(function() {
          Hv(ve, me, null, null);
        });
      }
    };
    function $x(me, ve, Ie) {
      {
        var Me = me.alternate, Fe = me.child, Ze = me.sibling, Xe = me.tag, at = me.type, pt = null;
        switch (Xe) {
          case $e:
          case St:
          case Re:
            pt = at;
            break;
          case it:
            pt = at.render;
            break;
        }
        if (vl === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var wt = !1, Ct = !1;
        if (pt !== null) {
          var Jt = vl(pt);
          Jt !== void 0 && (Ie.has(Jt) ? Ct = !0 : ve.has(Jt) && (Xe === Re ? Ct = !0 : wt = !0));
        }
        if (Wy !== null && (Wy.has(me) || Me !== null && Wy.has(Me)) && (Ct = !0), Ct && (me._debugNeedsRemount = !0), Ct || wt) {
          var Gt = Su(me, Nr);
          Gt !== null && Fi(Gt, me, Nr, Vo);
        }
        Fe !== null && !Ct && $x(Fe, ve, Ie), Ze !== null && $x(Ze, ve, Ie);
      }
    }
    var aM = function(me, ve) {
      {
        var Ie = /* @__PURE__ */ new Set(), Me = new Set(ve.map(function(Fe) {
          return Fe.current;
        }));
        return Ix(me.current, Me, Ie), Ie;
      }
    };
    function Ix(me, ve, Ie) {
      {
        var Me = me.child, Fe = me.sibling, Ze = me.tag, Xe = me.type, at = null;
        switch (Ze) {
          case $e:
          case St:
          case Re:
            at = Xe;
            break;
          case it:
            at = Xe.render;
            break;
        }
        var pt = !1;
        at !== null && ve.has(at) && (pt = !0), pt ? iM(me, Ie) : Me !== null && Ix(Me, ve, Ie), Fe !== null && Ix(Fe, ve, Ie);
      }
    }
    function iM(me, ve) {
      {
        var Ie = sM(me, ve);
        if (Ie)
          return;
        for (var Me = me; ; ) {
          switch (Me.tag) {
            case ze:
              ve.add(Me.stateNode);
              return;
            case Be:
              ve.add(Me.stateNode.containerInfo);
              return;
            case je:
              ve.add(Me.stateNode.containerInfo);
              return;
          }
          if (Me.return === null)
            throw new Error("Expected to reach root first.");
          Me = Me.return;
        }
      }
    }
    function sM(me, ve) {
      for (var Ie = me, Me = !1; ; ) {
        if (Ie.tag === ze)
          Me = !0, ve.add(Ie.stateNode);
        else if (Ie.child !== null) {
          Ie.child.return = Ie, Ie = Ie.child;
          continue;
        }
        if (Ie === me)
          return Me;
        for (; Ie.sibling === null; ) {
          if (Ie.return === null || Ie.return === me)
            return Me;
          Ie = Ie.return;
        }
        Ie.sibling.return = Ie.return, Ie = Ie.sibling;
      }
      return !1;
    }
    var Rx;
    {
      Rx = !1;
      try {
        var KM = Object.preventExtensions({});
      } catch {
        Rx = !0;
      }
    }
    function uM(me, ve, Ie, Me) {
      this.tag = me, this.key = Ie, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = ve, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = Me, this.flags = Sr, this.subtreeFlags = Sr, this.deletions = null, this.lanes = xn, this.childLanes = xn, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Rx && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Gu = function(me, ve, Ie, Me) {
      return new uM(me, ve, Ie, Me);
    };
    function Nx(me) {
      var ve = me.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function lM(me) {
      return typeof me == "function" && !Nx(me) && me.defaultProps === void 0;
    }
    function cM(me) {
      if (typeof me == "function")
        return Nx(me) ? Re : $e;
      if (me != null) {
        var ve = me.$$typeof;
        if (ve === hr)
          return it;
        if (ve === zr)
          return At;
      }
      return Ne;
    }
    function om(me, ve) {
      var Ie = me.alternate;
      Ie === null ? (Ie = Gu(me.tag, ve, me.key, me.mode), Ie.elementType = me.elementType, Ie.type = me.type, Ie.stateNode = me.stateNode, Ie._debugSource = me._debugSource, Ie._debugOwner = me._debugOwner, Ie._debugHookTypes = me._debugHookTypes, Ie.alternate = me, me.alternate = Ie) : (Ie.pendingProps = ve, Ie.type = me.type, Ie.flags = Sr, Ie.subtreeFlags = Sr, Ie.deletions = null, Ie.actualDuration = 0, Ie.actualStartTime = -1), Ie.flags = me.flags & xi, Ie.childLanes = me.childLanes, Ie.lanes = me.lanes, Ie.child = me.child, Ie.memoizedProps = me.memoizedProps, Ie.memoizedState = me.memoizedState, Ie.updateQueue = me.updateQueue;
      var Me = me.dependencies;
      switch (Ie.dependencies = Me === null ? null : { lanes: Me.lanes, firstContext: Me.firstContext }, Ie.sibling = me.sibling, Ie.index = me.index, Ie.ref = me.ref, Ie.selfBaseDuration = me.selfBaseDuration, Ie.treeBaseDuration = me.treeBaseDuration, Ie._debugNeedsRemount = me._debugNeedsRemount, Ie.tag) {
        case Ne:
        case $e:
        case St:
          Ie.type = qy(me.type);
          break;
        case Re:
          Ie.type = Ax(me.type);
          break;
        case it:
          Ie.type = Cx(me.type);
          break;
      }
      return Ie;
    }
    function dM(me, ve) {
      me.flags &= xi | Ko;
      var Ie = me.alternate;
      if (Ie === null)
        me.childLanes = xn, me.lanes = ve, me.child = null, me.subtreeFlags = Sr, me.memoizedProps = null, me.memoizedState = null, me.updateQueue = null, me.dependencies = null, me.stateNode = null, me.selfBaseDuration = 0, me.treeBaseDuration = 0;
      else {
        me.childLanes = Ie.childLanes, me.lanes = Ie.lanes, me.child = Ie.child, me.subtreeFlags = Sr, me.deletions = null, me.memoizedProps = Ie.memoizedProps, me.memoizedState = Ie.memoizedState, me.updateQueue = Ie.updateQueue, me.type = Ie.type;
        var Me = Ie.dependencies;
        me.dependencies = Me === null ? null : { lanes: Me.lanes, firstContext: Me.firstContext }, me.selfBaseDuration = Ie.selfBaseDuration, me.treeBaseDuration = Ie.treeBaseDuration;
      }
      return me;
    }
    function fM(me, ve, Ie) {
      var Me;
      return me === I0 ? (Me = oo, ve === !0 && (Me |= fa, Me |= hu)) : Me = Tr, Si && (Me |= Rr), Gu(je, null, null, Me);
    }
    function Mx(me, ve, Ie, Me, Fe, Ze) {
      var Xe = Ne, at = me;
      if (typeof me == "function")
        Nx(me) ? (Xe = Re, at = Ax(at)) : at = qy(at);
      else if (typeof me == "string")
        Xe = ze;
      else
        e:
          switch (me) {
            case oa:
              return tp(Ie.children, Fe, Ze, ve);
            case Ma:
              Xe = Ye, Fe |= fa, (Fe & oo) !== Tr && (Fe |= hu);
              break;
            case Rt:
              return pM(Ie, Fe, Ze, ve);
            case Dr:
              return hM(Ie, Fe, Ze, ve);
            case Jr:
              return mM(Ie, Fe, Ze, ve);
            case Ao:
              return k2(Ie, Fe, Ze, ve);
            case ka:
            case aa:
            case ys:
            case Qu:
            case Oo:
            default: {
              if (typeof me == "object" && me !== null)
                switch (me.$$typeof) {
                  case Cn:
                    Xe = tt;
                    break e;
                  case Pn:
                    Xe = ot;
                    break e;
                  case hr:
                    Xe = it, at = Cx(at);
                    break e;
                  case zr:
                    Xe = At;
                    break e;
                  case gr:
                    Xe = Nt, at = null;
                    break e;
                }
              var pt = "";
              {
                (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (pt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var wt = Me ? Mr(Me) : null;
                wt && (pt += `

Check the render method of \`` + wt + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (me == null ? me : typeof me) + "." + pt));
            }
          }
      var Ct = Gu(Xe, Ie, ve, Fe);
      return Ct.elementType = me, Ct.type = at, Ct.lanes = Ze, Ct._debugOwner = Me, Ct;
    }
    function jx(me, ve, Ie) {
      var Me = null;
      Me = me._owner;
      var Fe = me.type, Ze = me.key, Xe = me.props, at = Mx(Fe, Ze, Xe, Me, ve, Ie);
      return at._debugSource = me._source, at._debugOwner = me._owner, at;
    }
    function tp(me, ve, Ie, Me) {
      var Fe = Gu(qe, me, Me, ve);
      return Fe.lanes = Ie, Fe;
    }
    function pM(me, ve, Ie, Me) {
      typeof me.id != "string" && xe('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof me.id);
      var Fe = Gu(ht, me, Me, ve | Rr);
      return Fe.elementType = Rt, Fe.lanes = Ie, Fe.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, Fe;
    }
    function hM(me, ve, Ie, Me) {
      var Fe = Gu(gt, me, Me, ve);
      return Fe.elementType = Dr, Fe.lanes = Ie, Fe;
    }
    function mM(me, ve, Ie, Me) {
      var Fe = Gu(on, me, Me, ve);
      return Fe.elementType = Jr, Fe.lanes = Ie, Fe;
    }
    function k2(me, ve, Ie, Me) {
      var Fe = Gu(_n, me, Me, ve);
      Fe.elementType = Ao, Fe.lanes = Ie;
      var Ze = { isHidden: !1 };
      return Fe.stateNode = Ze, Fe;
    }
    function Dx(me, ve, Ie) {
      var Me = Gu(He, me, null, ve);
      return Me.lanes = Ie, Me;
    }
    function yM() {
      var me = Gu(ze, null, null, Tr);
      return me.elementType = "DELETED", me;
    }
    function bM(me) {
      var ve = Gu(Vt, null, null, Tr);
      return ve.stateNode = me, ve;
    }
    function Lx(me, ve, Ie) {
      var Me = me.children !== null ? me.children : [], Fe = Gu(Be, Me, me.key, ve);
      return Fe.lanes = Ie, Fe.stateNode = { containerInfo: me.containerInfo, pendingChildren: null, implementation: me.implementation }, Fe;
    }
    function O2(me, ve) {
      return me === null && (me = Gu(Ne, null, null, Tr)), me.tag = ve.tag, me.key = ve.key, me.elementType = ve.elementType, me.type = ve.type, me.stateNode = ve.stateNode, me.return = ve.return, me.child = ve.child, me.sibling = ve.sibling, me.index = ve.index, me.ref = ve.ref, me.pendingProps = ve.pendingProps, me.memoizedProps = ve.memoizedProps, me.updateQueue = ve.updateQueue, me.memoizedState = ve.memoizedState, me.dependencies = ve.dependencies, me.mode = ve.mode, me.flags = ve.flags, me.subtreeFlags = ve.subtreeFlags, me.deletions = ve.deletions, me.lanes = ve.lanes, me.childLanes = ve.childLanes, me.alternate = ve.alternate, me.actualDuration = ve.actualDuration, me.actualStartTime = ve.actualStartTime, me.selfBaseDuration = ve.selfBaseDuration, me.treeBaseDuration = ve.treeBaseDuration, me._debugSource = ve._debugSource, me._debugOwner = ve._debugOwner, me._debugNeedsRemount = ve._debugNeedsRemount, me._debugHookTypes = ve._debugHookTypes, me;
    }
    function vM(me, ve, Ie, Me, Fe) {
      this.tag = ve, this.containerInfo = me, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = X_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = yo, this.eventTimes = Ym(xn), this.expirationTimes = Ym(Vo), this.pendingLanes = xn, this.suspendedLanes = xn, this.pingedLanes = xn, this.expiredLanes = xn, this.mutableReadLanes = xn, this.finishedLanes = xn, this.entangledLanes = xn, this.entanglements = Ym(xn), this.identifierPrefix = Me, this.onRecoverableError = Fe, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var Ze = this.pendingUpdatersLaneMap = [], Xe = 0; Xe < Jo; Xe++)
          Ze.push(/* @__PURE__ */ new Set());
      }
      switch (ve) {
        case I0:
          this._debugRootType = Ie ? "hydrateRoot()" : "createRoot()";
          break;
        case Uf:
          this._debugRootType = Ie ? "hydrate()" : "render()";
          break;
      }
    }
    function A2(me, ve, Ie, Me, Fe, Ze, Xe, at, pt, wt) {
      var Ct = new vM(me, ve, Ie, at, pt), Jt = fM(ve, Ze);
      Ct.current = Jt, Jt.stateNode = Ct;
      {
        var Gt = { element: Me, isDehydrated: Ie, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        Jt.memoizedState = Gt;
      }
      return P1(Jt), Ct;
    }
    var Fx = "18.2.0";
    function gM(me, ve, Ie) {
      var Me = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return go(Me), { $$typeof: _o, key: Me == null ? null : "" + Me, children: me, containerInfo: ve, implementation: Ie };
    }
    var Bx, zx;
    Bx = !1, zx = {};
    function C2(me) {
      if (!me)
        return Zu;
      var ve = lu(me), Ie = HC(ve);
      if (ve.tag === Re) {
        var Me = ve.type;
        if (Zc(Me))
          return MS(ve, Me, Ie);
      }
      return Ie;
    }
    function wM(me, ve) {
      {
        var Ie = lu(me);
        if (Ie === void 0) {
          if (typeof me.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var Me = Object.keys(me).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + Me);
        }
        var Fe = pu(Ie);
        if (Fe === null)
          return null;
        if (Fe.mode & fa) {
          var Ze = Mr(Ie) || "Component";
          if (!zx[Ze]) {
            zx[Ze] = !0;
            var Xe = Wo;
            try {
              mo(Fe), Ie.mode & fa ? xe("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ve, ve, Ze) : xe("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ve, ve, Ze);
            } finally {
              Xe ? mo(Xe) : Qo();
            }
          }
        }
        return Fe.stateNode;
      }
    }
    function $2(me, ve, Ie, Me, Fe, Ze, Xe, at) {
      var pt = !1, wt = null;
      return A2(me, ve, pt, wt, Ie, Me, Fe, Ze, Xe);
    }
    function I2(me, ve, Ie, Me, Fe, Ze, Xe, at, pt, wt) {
      var Ct = !0, Jt = A2(Ie, Me, Ct, me, Fe, Ze, Xe, at, pt);
      Jt.context = C2(null);
      var Gt = Jt.current, pn = eu(), yn = Jf(Gt), En = Xd(pn, yn);
      return En.callback = ve ?? null, Wf(Gt, En, yn), kN(Jt, yn, pn), Jt;
    }
    function Hv(me, ve, Ie, Me) {
      Pg(ve, me);
      var Fe = ve.current, Ze = eu(), Xe = Jf(Fe);
      xd(Xe);
      var at = C2(Ie);
      ve.context === null ? ve.context = at : ve.pendingContext = at, La && Wo !== null && !Bx && (Bx = !0, xe(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Mr(Wo) || "Unknown"));
      var pt = Xd(Ze, Xe);
      pt.payload = { element: me }, Me = Me === void 0 ? null : Me, Me !== null && (typeof Me != "function" && xe("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", Me), pt.callback = Me);
      var wt = Wf(Fe, pt, Xe);
      return wt !== null && (Fi(wt, Fe, Xe, Ze), J0(wt, Fe, Xe)), Xe;
    }
    function qw(me) {
      var ve = me.current;
      if (!ve.child)
        return null;
      switch (ve.child.tag) {
        case ze:
          return ve.child.stateNode;
        default:
          return ve.child.stateNode;
      }
    }
    function _M(me) {
      switch (me.tag) {
        case je: {
          var ve = me.stateNode;
          if (Nd(ve)) {
            var Ie = w_(ve);
            $N(ve, Ie);
          }
          break;
        }
        case gt: {
          nf(function() {
            var Fe = Su(me, Nr);
            if (Fe !== null) {
              var Ze = eu();
              Fi(Fe, me, Nr, Ze);
            }
          });
          var Me = Nr;
          Ux(me, Me);
          break;
        }
      }
    }
    function R2(me, ve) {
      var Ie = me.memoizedState;
      Ie !== null && Ie.dehydrated !== null && (Ie.retryLane = Nb(Ie.retryLane, ve));
    }
    function Ux(me, ve) {
      R2(me, ve);
      var Ie = me.alternate;
      Ie && R2(Ie, ve);
    }
    function EM(me) {
      if (me.tag === gt) {
        var ve = Ef, Ie = Su(me, ve);
        if (Ie !== null) {
          var Me = eu();
          Fi(Ie, me, ve, Me);
        }
        Ux(me, ve);
      }
    }
    function xM(me) {
      if (me.tag === gt) {
        var ve = Jf(me), Ie = Su(me, ve);
        if (Ie !== null) {
          var Me = eu();
          Fi(Ie, me, ve, Me);
        }
        Ux(me, ve);
      }
    }
    function N2(me) {
      var ve = Eg(me);
      return ve === null ? null : ve.stateNode;
    }
    var M2 = function(me) {
      return null;
    };
    function SM(me) {
      return M2(me);
    }
    var j2 = function(me) {
      return !1;
    };
    function PM(me) {
      return j2(me);
    }
    var D2 = null, L2 = null, F2 = null, B2 = null, z2 = null, U2 = null, V2 = null, H2 = null, W2 = null;
    {
      var q2 = function(me, ve, Ie) {
        var Me = ve[Ie], Fe = No(me) ? me.slice() : Wr({}, me);
        return Ie + 1 === ve.length ? (No(Fe) ? Fe.splice(Me, 1) : delete Fe[Me], Fe) : (Fe[Me] = q2(me[Me], ve, Ie + 1), Fe);
      }, Z2 = function(me, ve) {
        return q2(me, ve, 0);
      }, G2 = function(me, ve, Ie, Me) {
        var Fe = ve[Me], Ze = No(me) ? me.slice() : Wr({}, me);
        if (Me + 1 === ve.length) {
          var Xe = Ie[Me];
          Ze[Xe] = Ze[Fe], No(Ze) ? Ze.splice(Fe, 1) : delete Ze[Fe];
        } else
          Ze[Fe] = G2(me[Fe], ve, Ie, Me + 1);
        return Ze;
      }, Y2 = function(me, ve, Ie) {
        if (ve.length !== Ie.length) {
          _e("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var Me = 0; Me < Ie.length - 1; Me++)
            if (ve[Me] !== Ie[Me]) {
              _e("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return G2(me, ve, Ie, 0);
      }, Q2 = function(me, ve, Ie, Me) {
        if (Ie >= ve.length)
          return Me;
        var Fe = ve[Ie], Ze = No(me) ? me.slice() : Wr({}, me);
        return Ze[Fe] = Q2(me[Fe], ve, Ie + 1, Me), Ze;
      }, K2 = function(me, ve, Ie) {
        return Q2(me, ve, 0, Ie);
      }, Vx = function(me, ve) {
        for (var Ie = me.memoizedState; Ie !== null && ve > 0; )
          Ie = Ie.next, ve--;
        return Ie;
      };
      D2 = function(me, ve, Ie, Me) {
        var Fe = Vx(me, ve);
        if (Fe !== null) {
          var Ze = K2(Fe.memoizedState, Ie, Me);
          Fe.memoizedState = Ze, Fe.baseState = Ze, me.memoizedProps = Wr({}, me.memoizedProps);
          var Xe = Su(me, Nr);
          Xe !== null && Fi(Xe, me, Nr, Vo);
        }
      }, L2 = function(me, ve, Ie) {
        var Me = Vx(me, ve);
        if (Me !== null) {
          var Fe = Z2(Me.memoizedState, Ie);
          Me.memoizedState = Fe, Me.baseState = Fe, me.memoizedProps = Wr({}, me.memoizedProps);
          var Ze = Su(me, Nr);
          Ze !== null && Fi(Ze, me, Nr, Vo);
        }
      }, F2 = function(me, ve, Ie, Me) {
        var Fe = Vx(me, ve);
        if (Fe !== null) {
          var Ze = Y2(Fe.memoizedState, Ie, Me);
          Fe.memoizedState = Ze, Fe.baseState = Ze, me.memoizedProps = Wr({}, me.memoizedProps);
          var Xe = Su(me, Nr);
          Xe !== null && Fi(Xe, me, Nr, Vo);
        }
      }, B2 = function(me, ve, Ie) {
        me.pendingProps = K2(me.memoizedProps, ve, Ie), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Me = Su(me, Nr);
        Me !== null && Fi(Me, me, Nr, Vo);
      }, z2 = function(me, ve) {
        me.pendingProps = Z2(me.memoizedProps, ve), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Ie = Su(me, Nr);
        Ie !== null && Fi(Ie, me, Nr, Vo);
      }, U2 = function(me, ve, Ie) {
        me.pendingProps = Y2(me.memoizedProps, ve, Ie), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Me = Su(me, Nr);
        Me !== null && Fi(Me, me, Nr, Vo);
      }, V2 = function(me) {
        var ve = Su(me, Nr);
        ve !== null && Fi(ve, me, Nr, Vo);
      }, H2 = function(me) {
        M2 = me;
      }, W2 = function(me) {
        j2 = me;
      };
    }
    function TM(me) {
      var ve = pu(me);
      return ve === null ? null : ve.stateNode;
    }
    function kM(me) {
      return null;
    }
    function OM() {
      return Wo;
    }
    function AM(me) {
      var ve = me.findFiberByHostInstance, Ie = fe.ReactCurrentDispatcher;
      return xb({ bundleType: me.bundleType, version: me.version, rendererPackageName: me.rendererPackageName, rendererConfig: me.rendererConfig, overrideHookState: D2, overrideHookStateDeletePath: L2, overrideHookStateRenamePath: F2, overrideProps: B2, overridePropsDeletePath: z2, overridePropsRenamePath: U2, setErrorHandler: H2, setSuspenseHandler: W2, scheduleUpdate: V2, currentDispatcherRef: Ie, findHostInstanceByFiber: TM, findFiberByHostInstance: ve || kM, findHostInstancesForRefresh: aM, scheduleRefresh: rM, scheduleRoot: oM, setRefreshHandler: nM, getCurrentFiber: OM, reconcilerVersion: Fx });
    }
    var X2 = typeof reportError == "function" ? reportError : function(me) {
      console.error(me);
    };
    function Hx(me) {
      this._internalRoot = me;
    }
    Yw.prototype.render = Hx.prototype.render = function(me) {
      var ve = this._internalRoot;
      if (ve === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? xe("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : e_(arguments[1]) ? xe("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && xe("You passed a second argument to root.render(...) but it only accepts one argument.");
        var Ie = ve.containerInfo;
        if (Ie.nodeType !== Ba) {
          var Me = N2(ve.current);
          Me && Me.parentNode !== Ie && xe("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Hv(me, ve, null, null);
    }, Yw.prototype.unmount = Hx.prototype.unmount = function() {
      typeof arguments[0] == "function" && xe("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var me = this._internalRoot;
      if (me !== null) {
        this._internalRoot = null;
        var ve = me.containerInfo;
        d2() && xe("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), nf(function() {
          Hv(null, me, null, null);
        }), CS(ve);
      }
    };
    function CM(me, ve) {
      if (!e_(me))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      J2(me);
      var Ie = !1, Me = !1, Fe = "", Ze = X2;
      ve != null && (ve.hydrate ? _e("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof ve == "object" && ve !== null && ve.$$typeof === fo && xe(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), ve.unstable_strictMode === !0 && (Ie = !0), ve.identifierPrefix !== void 0 && (Fe = ve.identifierPrefix), ve.onRecoverableError !== void 0 && (Ze = ve.onRecoverableError), ve.transitionCallbacks !== void 0 && ve.transitionCallbacks);
      var Xe = $2(me, I0, null, Ie, Me, Fe, Ze);
      _0(Xe.current, me);
      var at = me.nodeType === Ba ? me.parentNode : me;
      return Jb(at), new Hx(Xe);
    }
    function Yw(me) {
      this._internalRoot = me;
    }
    function $M(me) {
      me && Wg(me);
    }
    Yw.prototype.unstable_scheduleHydration = $M;
    function IM(me, ve, Ie) {
      if (!e_(me))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      J2(me), ve === void 0 && xe("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var Me = Ie ?? null, Fe = Ie != null && Ie.hydratedSources || null, Ze = !1, Xe = !1, at = "", pt = X2;
      Ie != null && (Ie.unstable_strictMode === !0 && (Ze = !0), Ie.identifierPrefix !== void 0 && (at = Ie.identifierPrefix), Ie.onRecoverableError !== void 0 && (pt = Ie.onRecoverableError));
      var wt = I2(ve, null, me, I0, Me, Ze, Xe, at, pt);
      if (_0(wt.current, me), Jb(me), Fe)
        for (var Ct = 0; Ct < Fe.length; Ct++) {
          var Jt = Fe[Ct];
          EI(wt, Jt);
        }
      return new Yw(wt);
    }
    function e_(me) {
      return !!(me && (me.nodeType === gs || me.nodeType === zu || me.nodeType === ad || !Mn));
    }
    function Wv(me) {
      return !!(me && (me.nodeType === gs || me.nodeType === zu || me.nodeType === ad || me.nodeType === Ba && me.nodeValue === " react-mount-point-unstable "));
    }
    function J2(me) {
      me.nodeType === gs && me.tagName && me.tagName.toUpperCase() === "BODY" && xe("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), cv(me) && (me._reactRootContainer ? xe("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : xe("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var RM = fe.ReactCurrentOwner, eO;
    eO = function(me) {
      if (me._reactRootContainer && me.nodeType !== Ba) {
        var ve = N2(me._reactRootContainer.current);
        ve && ve.parentNode !== me && xe("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var Ie = !!me._reactRootContainer, Me = Wx(me), Fe = !!(Me && Bf(Me));
      Fe && !Ie && xe("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), me.nodeType === gs && me.tagName && me.tagName.toUpperCase() === "BODY" && xe("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function Wx(me) {
      return me ? me.nodeType === zu ? me.documentElement : me.firstChild : null;
    }
    function tO() {
    }
    function NM(me, ve, Ie, Me, Fe) {
      if (Fe) {
        if (typeof Me == "function") {
          var Ze = Me;
          Me = function() {
            var Gt = qw(Xe);
            Ze.call(Gt);
          };
        }
        var Xe = I2(ve, Me, me, Uf, null, !1, !1, "", tO);
        me._reactRootContainer = Xe, _0(Xe.current, me);
        var at = me.nodeType === Ba ? me.parentNode : me;
        return Jb(at), nf(), Xe;
      } else {
        for (var pt; pt = me.lastChild; )
          me.removeChild(pt);
        if (typeof Me == "function") {
          var wt = Me;
          Me = function() {
            var Gt = qw(Ct);
            wt.call(Gt);
          };
        }
        var Ct = $2(me, Uf, null, !1, !1, "", tO);
        me._reactRootContainer = Ct, _0(Ct.current, me);
        var Jt = me.nodeType === Ba ? me.parentNode : me;
        return Jb(Jt), nf(function() {
          Hv(ve, Ct, Ie, Me);
        }), Ct;
      }
    }
    function MM(me, ve) {
      me !== null && typeof me != "function" && xe("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve, me);
    }
    function t_(me, ve, Ie, Me, Fe) {
      eO(Ie), MM(Fe === void 0 ? null : Fe, "render");
      var Ze = Ie._reactRootContainer, Xe;
      if (!Ze)
        Xe = NM(Ie, ve, me, Fe, Me);
      else {
        if (Xe = Ze, typeof Fe == "function") {
          var at = Fe;
          Fe = function() {
            var pt = qw(Xe);
            at.call(pt);
          };
        }
        Hv(ve, Xe, me, Fe);
      }
      return qw(Xe);
    }
    function jM(me) {
      {
        var ve = RM.current;
        if (ve !== null && ve.stateNode !== null) {
          var Ie = ve.stateNode._warnedAboutRefsInRender;
          Ie || xe("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ho(ve.type) || "A component"), ve.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return me == null ? null : me.nodeType === gs ? me : wM(me, "findDOMNode");
    }
    function DM(me, ve, Ie) {
      if (xe("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wv(ve))
        throw new Error("Target container is not a DOM element.");
      {
        var Me = cv(ve) && ve._reactRootContainer === void 0;
        Me && xe("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return t_(null, me, ve, !0, Ie);
    }
    function LM(me, ve, Ie) {
      if (xe("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wv(ve))
        throw new Error("Target container is not a DOM element.");
      {
        var Me = cv(ve) && ve._reactRootContainer === void 0;
        Me && xe("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return t_(null, me, ve, !1, Ie);
    }
    function FM(me, ve, Ie, Me) {
      if (xe("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Wv(Ie))
        throw new Error("Target container is not a DOM element.");
      if (me == null || !xp(me))
        throw new Error("parentComponent must be a valid React Component");
      return t_(me, ve, Ie, !1, Me);
    }
    function BM(me) {
      if (!Wv(me))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var ve = cv(me) && me._reactRootContainer === void 0;
        ve && xe("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (me._reactRootContainer) {
        {
          var Ie = Wx(me), Me = Ie && !Bf(Ie);
          Me && xe("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return nf(function() {
          t_(null, null, me, !1, function() {
            me._reactRootContainer = null, CS(me);
          });
        }), !0;
      } else {
        {
          var Fe = Wx(me), Ze = !!(Fe && Bf(Fe)), Xe = me.nodeType === gs && Wv(me.parentNode) && !!me.parentNode._reactRootContainer;
          Ze && xe("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", Xe ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    x_(_M), Bg(EM), S_(xM), ny(Gs), zg(Lg), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && xe("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), gg(UO), mm(_x, IN, nf);
    function zM(me, ve) {
      var Ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!e_(ve))
        throw new Error("Target container is not a DOM element.");
      return gM(me, ve, null, Ie);
    }
    function UM(me, ve, Ie, Me) {
      return FM(me, ve, Ie, Me);
    }
    var qx = { usingClientEntryPoint: !1, Events: [Bf, xy, E0, hm, wp, _x] };
    function VM(me, ve) {
      return qx.usingClientEntryPoint || xe('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), CM(me, ve);
    }
    function HM(me, ve, Ie) {
      return qx.usingClientEntryPoint || xe('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), IM(me, ve, Ie);
    }
    function WM(me) {
      return d2() && xe("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), nf(me);
    }
    var qM = AM({ findFiberByHostInstance: Xp, bundleType: 1, version: Fx, rendererPackageName: "react-dom" });
    if (!qM && so && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var nO = window.location.protocol;
      /^(https?|file):$/.test(nO) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (nO === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qx, ne.createPortal = zM, ne.createRoot = VM, ne.findDOMNode = jM, ne.flushSync = WM, ne.hydrate = DM, ne.hydrateRoot = HM, ne.render = LM, ne.unmountComponentAtNode = BM, ne.unstable_batchedUpdates = _x, ne.unstable_renderSubtreeIntoContainer = UM, ne.version = Fx, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), gz = M((ne, oe) => {
  function ae() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ae);
      } catch (fe) {
        console.error(fe);
      }
    }
  }
  process.env.NODE_ENV === "production" ? (ae(), oe.exports = mz()) : oe.exports = hz();
}), bz = M((ne) => {
  var oe = gz();
  process.env.NODE_ENV === "production" ? (ne.createRoot = oe.createRoot, ne.hydrateRoot = oe.hydrateRoot) : (ae = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ne.createRoot = function(fe, ye) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.createRoot(fe, ye);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  }, ne.hydrateRoot = function(fe, ye, we) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.hydrateRoot(fe, ye, we);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  });
  var ae;
});
function Xm(ne, { insertAt: oe } = {}) {
  if (!ne || typeof document > "u")
    return;
  let ae = document.head || document.getElementsByTagName("head")[0], fe = document.createElement("style");
  fe.type = "text/css", oe === "top" && ae.firstChild ? ae.insertBefore(fe, ae.firstChild) : ae.appendChild(fe), fe.styleSheet ? fe.styleSheet.cssText = ne : fe.appendChild(document.createTextNode(ne));
}
var ek = Y(() => {
}), Sz = Y(() => {
  ek(), Xm(`#mud-dev-tools{all:initial}#mud-dev-tools *,#mud-dev-tools :before,#mud-dev-tools :after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}#mud-dev-tools :before,#mud-dev-tools :after{--tw-content: ""}#mud-dev-tools{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}#mud-dev-tools{margin:0;line-height:inherit}#mud-dev-tools hr{height:0;color:inherit;border-top-width:1px}#mud-dev-tools abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6{font-size:inherit;font-weight:inherit}#mud-dev-tools a{color:inherit;text-decoration:inherit}#mud-dev-tools b,#mud-dev-tools strong{font-weight:bolder}#mud-dev-tools code,#mud-dev-tools kbd,#mud-dev-tools samp,#mud-dev-tools pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}#mud-dev-tools small{font-size:80%}#mud-dev-tools sub,#mud-dev-tools sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#mud-dev-tools sub{bottom:-.25em}#mud-dev-tools sup{top:-.5em}#mud-dev-tools table{text-indent:0;border-color:inherit;border-collapse:collapse}#mud-dev-tools button,#mud-dev-tools input,#mud-dev-tools optgroup,#mud-dev-tools select,#mud-dev-tools textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}#mud-dev-tools button,#mud-dev-tools select{text-transform:none}#mud-dev-tools button,#mud-dev-tools [type=button],#mud-dev-tools [type=reset],#mud-dev-tools [type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}#mud-dev-tools :-moz-focusring{outline:auto}#mud-dev-tools :-moz-ui-invalid{box-shadow:none}#mud-dev-tools progress{vertical-align:baseline}#mud-dev-tools ::-webkit-inner-spin-button,#mud-dev-tools ::-webkit-outer-spin-button{height:auto}#mud-dev-tools [type=search]{-webkit-appearance:textfield;outline-offset:-2px}#mud-dev-tools ::-webkit-search-decoration{-webkit-appearance:none}#mud-dev-tools ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}#mud-dev-tools summary{display:list-item}#mud-dev-tools blockquote,#mud-dev-tools dl,#mud-dev-tools dd,#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6,#mud-dev-tools hr,#mud-dev-tools figure,#mud-dev-tools p,#mud-dev-tools pre{margin:0}#mud-dev-tools fieldset{margin:0;padding:0}#mud-dev-tools legend{padding:0}#mud-dev-tools ol,#mud-dev-tools ul,#mud-dev-tools menu{list-style:none;margin:0;padding:0}#mud-dev-tools textarea{resize:vertical}#mud-dev-tools input::-moz-placeholder,#mud-dev-tools textarea::-moz-placeholder{opacity:1;color:#9ca3af}#mud-dev-tools input::placeholder,#mud-dev-tools textarea::placeholder{opacity:1;color:#9ca3af}#mud-dev-tools button,#mud-dev-tools [role=button]{cursor:pointer}#mud-dev-tools :disabled{cursor:default}#mud-dev-tools img,#mud-dev-tools svg,#mud-dev-tools video,#mud-dev-tools canvas,#mud-dev-tools audio,#mud-dev-tools iframe,#mud-dev-tools embed,#mud-dev-tools object{display:block;vertical-align:middle}#mud-dev-tools img,#mud-dev-tools video{max-width:100%;height:auto}#mud-dev-tools [hidden]{display:none}
`);
}), _z = Y(() => {
  ek(), Xm(`*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }#mud-dev-tools :is(.pointer-events-none){pointer-events:none}#mud-dev-tools :is(.pointer-events-auto){pointer-events:auto}#mud-dev-tools :is(.fixed){position:fixed}#mud-dev-tools :is(.absolute){position:absolute}#mud-dev-tools :is(.relative){position:relative}#mud-dev-tools :is(.sticky){position:sticky}#mud-dev-tools :is(.inset-0){inset:0}#mud-dev-tools :is(.bottom-0){bottom:0}#mud-dev-tools :is(.left-0){left:0}#mud-dev-tools :is(.right-0){right:0}#mud-dev-tools :is(.right-full){right:100%}#mud-dev-tools :is(.top-0){top:0}#mud-dev-tools :is(.top-1){top:.25rem}#mud-dev-tools :is(.z-10){z-index:10}#mud-dev-tools :is(.z-20){z-index:20}#mud-dev-tools :is(.m-2){margin:.5rem}#mud-dev-tools :is(.-mx-1){margin-left:-.25rem;margin-right:-.25rem}#mud-dev-tools :is(.block){display:block}#mud-dev-tools :is(.flex){display:flex}#mud-dev-tools :is(.inline-flex){display:inline-flex}#mud-dev-tools :is(.\\!table){display:table!important}#mud-dev-tools :is(.table){display:table}#mud-dev-tools :is(.grid){display:grid}#mud-dev-tools :is(.hidden){display:none}#mud-dev-tools :is(.h-4){height:1rem}#mud-dev-tools :is(.h-\\[1em\\]){height:1em}#mud-dev-tools :is(.h-full){height:100%}#mud-dev-tools :is(.w-2\\/12){width:16.666667%}#mud-dev-tools :is(.w-3\\/12){width:25%}#mud-dev-tools :is(.w-4){width:1rem}#mud-dev-tools :is(.w-\\[1em\\]){width:1em}#mud-dev-tools :is(.w-full){width:100%}#mud-dev-tools :is(.min-w-max){min-width:max-content}#mud-dev-tools :is(.max-w-screen-sm){max-width:640px}#mud-dev-tools :is(.flex-1){flex:1 1 0%}#mud-dev-tools :is(.flex-none){flex:none}#mud-dev-tools :is(.flex-grow){flex-grow:1}#mud-dev-tools :is(.table-fixed){table-layout:fixed}#mud-dev-tools :is(.translate-x-0){--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}#mud-dev-tools :is(.translate-x-full){--tw-translate-x: 100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}#mud-dev-tools :is(.animate-spin){animation:spin 1s linear infinite}#mud-dev-tools :is(.cursor-default){cursor:default}#mud-dev-tools :is(.cursor-pointer){cursor:pointer}#mud-dev-tools :is(.select-none){-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.grid-cols-\\[max-content\\,1fr\\]){grid-template-columns:max-content 1fr}#mud-dev-tools :is(.flex-col){flex-direction:column}#mud-dev-tools :is(.flex-col-reverse){flex-direction:column-reverse}#mud-dev-tools :is(.items-start){align-items:flex-start}#mud-dev-tools :is(.items-end){align-items:flex-end}#mud-dev-tools :is(.items-center){align-items:center}#mud-dev-tools :is(.justify-center){justify-content:center}#mud-dev-tools :is(.gap-1){gap:.25rem}#mud-dev-tools :is(.gap-2){gap:.5rem}#mud-dev-tools :is(.gap-x-4){column-gap:1rem}#mud-dev-tools :is(.space-y-1 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-2 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-4 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-6 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-8 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(2rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(2rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.overflow-auto){overflow:auto}#mud-dev-tools :is(.overflow-hidden){overflow:hidden}#mud-dev-tools :is(.text-ellipsis){text-overflow:ellipsis}#mud-dev-tools :is(.whitespace-nowrap){white-space:nowrap}#mud-dev-tools :is(.whitespace-pre){white-space:pre}#mud-dev-tools :is(.rounded){border-radius:.25rem}#mud-dev-tools :is(.border-2){border-width:2px}#mud-dev-tools :is(.border-dashed){border-style:dashed}#mud-dev-tools :is(.border-transparent){border-color:transparent}#mud-dev-tools :is(.border-white\\/10){border-color:#ffffff1a}#mud-dev-tools :is(.border-white\\/20){border-color:#fff3}#mud-dev-tools :is(.bg-gray-500\\/10){background-color:#6b72801a}#mud-dev-tools :is(.bg-red-800){--tw-bg-opacity: 1;background-color:rgb(153 27 27 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-red-900\\/50){background-color:#7f1d1d80}#mud-dev-tools :is(.bg-slate-600){--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-700){--tw-bg-opacity: 1;background-color:rgb(51 65 85 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-800){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-900){--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-white\\/5){background-color:#ffffff0d}#mud-dev-tools :is(.p-1){padding:.25rem}#mud-dev-tools :is(.p-2){padding:.5rem}#mud-dev-tools :is(.p-4){padding:1rem}#mud-dev-tools :is(.p-6){padding:1.5rem}#mud-dev-tools :is(.px-1){padding-left:.25rem;padding-right:.25rem}#mud-dev-tools :is(.px-1\\.5){padding-left:.375rem;padding-right:.375rem}#mud-dev-tools :is(.px-2){padding-left:.5rem;padding-right:.5rem}#mud-dev-tools :is(.px-3){padding-left:.75rem;padding-right:.75rem}#mud-dev-tools :is(.py-0){padding-top:0;padding-bottom:0}#mud-dev-tools :is(.py-0\\.5){padding-top:.125rem;padding-bottom:.125rem}#mud-dev-tools :is(.py-1){padding-top:.25rem;padding-bottom:.25rem}#mud-dev-tools :is(.py-1\\.5){padding-top:.375rem;padding-bottom:.375rem}#mud-dev-tools :is(.py-2){padding-top:.5rem;padding-bottom:.5rem}#mud-dev-tools :is(.pb-0){padding-bottom:0}#mud-dev-tools :is(.pb-0\\.5){padding-bottom:.125rem}#mud-dev-tools :is(.pb-1){padding-bottom:.25rem}#mud-dev-tools :is(.pt-1){padding-top:.25rem}#mud-dev-tools :is(.pt-1\\.5){padding-top:.375rem}#mud-dev-tools :is(.text-left){text-align:left}#mud-dev-tools :is(.text-right){text-align:right}#mud-dev-tools :is(.font-mono){font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}#mud-dev-tools :is(.text-sm){font-size:.875rem;line-height:1.25rem}#mud-dev-tools :is(.text-xs){font-size:.75rem;line-height:1rem}#mud-dev-tools :is(.font-bold){font-weight:700}#mud-dev-tools :is(.font-medium){font-weight:500}#mud-dev-tools :is(.font-normal){font-weight:400}#mud-dev-tools :is(.font-semibold){font-weight:600}#mud-dev-tools :is(.uppercase){text-transform:uppercase}#mud-dev-tools :is(.leading-none){line-height:1}#mud-dev-tools :is(.tracking-\\[-1ch\\]){letter-spacing:-1ch}#mud-dev-tools :is(.text-amber-200\\/80){color:#fde68acc}#mud-dev-tools :is(.text-cyan-500){--tw-text-opacity: 1;color:rgb(6 182 212 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-gray-500){--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-green-500){--tw-text-opacity: 1;color:rgb(34 197 94 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-red-500){--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-transparent){color:transparent}#mud-dev-tools :is(.text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-white\\/20){color:#fff3}#mud-dev-tools :is(.text-white\\/40){color:#fff6}#mud-dev-tools :is(.text-white\\/60){color:#fff9}#mud-dev-tools :is(.text-white\\/80){color:#fffc}#mud-dev-tools :is(.underline){text-decoration-line:underline}#mud-dev-tools :is(.opacity-0){opacity:0}#mud-dev-tools :is(.opacity-100){opacity:1}#mud-dev-tools :is(.opacity-25){opacity:.25}#mud-dev-tools :is(.opacity-60){opacity:.6}#mud-dev-tools :is(.opacity-75){opacity:.75}#mud-dev-tools :is(.shadow-lg){--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}#mud-dev-tools :is(.filter){filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}#mud-dev-tools :is(.transition){transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}#mud-dev-tools :is(.duration-500){transition-duration:.5s}#mud-dev-tools :is(.after\\:select-none):after{content:var(--tw-content);-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.after\\:content-\\[\\'\\2026\\'\\]):after{--tw-content: "\\2026";content:var(--tw-content)}#mud-dev-tools :is(.hover\\:bg-blue-700:hover){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:bg-blue-800:hover){--tw-bg-opacity: 1;background-color:rgb(30 64 175 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:text-white:hover){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.hover\\:text-white\\/60:hover){color:#fff9}#mud-dev-tools :is(.hover\\:underline:hover){text-decoration-line:underline}#mud-dev-tools :is(.hover\\:opacity-100:hover){opacity:1}#mud-dev-tools :is(.group:hover .group-hover\\:border-blue-700){--tw-border-opacity: 1;border-color:rgb(29 78 216 / var(--tw-border-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:bg-blue-700){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.peer:hover ~ .peer-hover\\:opacity-60){opacity:.6}
`);
});
function wz() {
  for (var ne = 0, oe, ae, fe = ""; ne < arguments.length; )
    (oe = arguments[ne++]) && (ae = xz(oe)) && (fe && (fe += " "), fe += ae);
  return fe;
}
function xz(ne) {
  if (typeof ne == "string")
    return ne;
  for (var oe, ae = "", fe = 0; fe < ne.length; fe++)
    ne[fe] && (oe = xz(ne[fe])) && (ae && (ae += " "), ae += oe);
  return ae;
}
var Ez = Y(() => {
});
function Oz(ne) {
  var oe = BZ(ne), ae = ne.conflictingClassGroups, fe = ne.conflictingClassGroupModifiers, ye = fe === void 0 ? {} : fe;
  function we(xe) {
    var Oe = xe.split(rk);
    return Oe[0] === "" && Oe.length !== 1 && Oe.shift(), Tz(Oe, oe) || IZ(xe);
  }
  function _e(xe, Oe) {
    var $e = ae[xe] || [];
    return Oe && ye[xe] ? [].concat($e, ye[xe]) : $e;
  }
  return { getClassGroupId: we, getConflictingClassGroupIds: _e };
}
function Tz(ne, oe) {
  var _e;
  if (ne.length === 0)
    return oe.classGroupId;
  var ae = ne[0], fe = oe.nextPart.get(ae), ye = fe ? Tz(ne.slice(1), fe) : void 0;
  if (ye)
    return ye;
  if (oe.validators.length !== 0) {
    var we = ne.join(rk);
    return (_e = oe.validators.find(function(xe) {
      var Oe = xe.validator;
      return Oe(we);
    })) == null ? void 0 : _e.classGroupId;
  }
}
function IZ(ne) {
  if (Cz.test(ne)) {
    var oe = Cz.exec(ne)[1], ae = oe == null ? void 0 : oe.substring(0, oe.indexOf(":"));
    if (ae)
      return "arbitrary.." + ae;
  }
}
function BZ(ne) {
  var oe = ne.theme, ae = ne.prefix, fe = { nextPart: /* @__PURE__ */ new Map(), validators: [] }, ye = VZ(Object.entries(ne.classGroups), ae);
  return ye.forEach(function(we) {
    var _e = we[0], xe = we[1];
    tk(xe, fe, _e, oe);
  }), fe;
}
function tk(ne, oe, ae, fe) {
  ne.forEach(function(ye) {
    if (typeof ye == "string") {
      var we = ye === "" ? oe : Rz(oe, ye);
      we.classGroupId = ae;
      return;
    }
    if (typeof ye == "function") {
      if (HZ(ye)) {
        tk(ye(fe), oe, ae, fe);
        return;
      }
      oe.validators.push({ validator: ye, classGroupId: ae });
      return;
    }
    Object.entries(ye).forEach(function(_e) {
      var xe = _e[0], Oe = _e[1];
      tk(Oe, Rz(oe, xe), ae, fe);
    });
  });
}
function Rz(ne, oe) {
  var ae = ne;
  return oe.split(rk).forEach(function(fe) {
    ae.nextPart.has(fe) || ae.nextPart.set(fe, { nextPart: /* @__PURE__ */ new Map(), validators: [] }), ae = ae.nextPart.get(fe);
  }), ae;
}
function HZ(ne) {
  return ne.isThemeGetter;
}
function VZ(ne, oe) {
  return oe ? ne.map(function(ae) {
    var fe = ae[0], ye = ae[1], we = ye.map(function(_e) {
      return typeof _e == "string" ? oe + _e : typeof _e == "object" ? Object.fromEntries(Object.entries(_e).map(function(xe) {
        var Oe = xe[0], $e = xe[1];
        return [oe + Oe, $e];
      })) : _e;
    });
    return [fe, we];
  }) : ne;
}
var rk, Cz, kz = Y(() => {
  rk = "-", Cz = /^\[(.+)\]$/;
});
function Az(ne) {
  if (ne < 1)
    return { get: function() {
    }, set: function() {
    } };
  var oe = 0, ae = /* @__PURE__ */ new Map(), fe = /* @__PURE__ */ new Map();
  function ye(we, _e) {
    ae.set(we, _e), oe++, oe > ne && (oe = 0, fe = ae, ae = /* @__PURE__ */ new Map());
  }
  return { get: function(we) {
    var _e = ae.get(we);
    if (_e !== void 0)
      return _e;
    if ((_e = fe.get(we)) !== void 0)
      return ye(we, _e), _e;
  }, set: function(we, _e) {
    ae.has(we) ? ae.set(we, _e) : ye(we, _e);
  } };
}
var Pz = Y(() => {
});
function Mz(ne) {
  var oe = ne.separator || ":", ae = oe.length === 1, fe = oe[0], ye = oe.length;
  return function(we) {
    for (var _e = [], xe = 0, Oe = 0, $e, Re = 0; Re < we.length; Re++) {
      var Ne = we[Re];
      if (xe === 0) {
        if (Ne === fe && (ae || we.slice(Re, Re + ye) === oe)) {
          _e.push(we.slice(Oe, Re)), Oe = Re + ye;
          continue;
        }
        if (Ne === "/") {
          $e = Re;
          continue;
        }
      }
      Ne === "[" ? xe++ : Ne === "]" && xe--;
    }
    var je = _e.length === 0 ? we : we.substring(Oe), Be = je.startsWith(nk), ze = Be ? je.substring(1) : je, He = $e && $e > Oe ? $e - Oe : void 0;
    return { modifiers: _e, hasImportantModifier: Be, baseClassName: ze, maybePostfixModifierPosition: He };
  };
}
function Dz(ne) {
  if (ne.length <= 1)
    return ne;
  var oe = [], ae = [];
  return ne.forEach(function(fe) {
    var ye = fe[0] === "[";
    ye ? (oe.push.apply(oe, ae.sort().concat([fe])), ae = []) : ae.push(fe);
  }), oe.push.apply(oe, ae.sort()), oe;
}
var nk, ik = Y(() => {
  nk = "!";
});
function Nz(ne) {
  return { cache: Az(ne.cacheSize), splitModifiers: Mz(ne), ...Oz(ne) };
}
var Lz = Y(() => {
  kz(), Pz(), ik();
});
function jz(ne, oe) {
  var ae = oe.splitModifiers, fe = oe.getClassGroupId, ye = oe.getConflictingClassGroupIds, we = /* @__PURE__ */ new Set();
  return ne.trim().split($Z).map(function(_e) {
    var xe = ae(_e), Oe = xe.modifiers, $e = xe.hasImportantModifier, Re = xe.baseClassName, Ne = xe.maybePostfixModifierPosition, je = fe(Ne ? Re.substring(0, Ne) : Re), Be = !!Ne;
    if (!je) {
      if (!Ne)
        return { isTailwindClass: !1, originalClassName: _e };
      if (je = fe(Re), !je)
        return { isTailwindClass: !1, originalClassName: _e };
      Be = !1;
    }
    var ze = Dz(Oe).join(":"), He = $e ? ze + nk : ze;
    return { isTailwindClass: !0, modifierId: He, classGroupId: je, originalClassName: _e, hasPostfixModifier: Be };
  }).reverse().filter(function(_e) {
    if (!_e.isTailwindClass)
      return !0;
    var xe = _e.modifierId, Oe = _e.classGroupId, $e = _e.hasPostfixModifier, Re = xe + Oe;
    return we.has(Re) ? !1 : (we.add(Re), ye(Oe, $e).forEach(function(Ne) {
      return we.add(xe + Ne);
    }), !0);
  }).reverse().map(function(_e) {
    return _e.originalClassName;
  }).join(" ");
}
var $Z, Uz = Y(() => {
  ik(), $Z = /\s+/;
});
function Fz() {
  for (var ne = arguments.length, oe = new Array(ne), ae = 0; ae < ne; ae++)
    oe[ae] = arguments[ae];
  var fe, ye, we, _e = xe;
  function xe($e) {
    var Re = oe[0], Ne = oe.slice(1), je = Ne.reduce(function(Be, ze) {
      return ze(Be);
    }, Re());
    return fe = Nz(je), ye = fe.cache.get, we = fe.cache.set, _e = Oe, Oe($e);
  }
  function Oe($e) {
    var Re = ye($e);
    if (Re)
      return Re;
    var Ne = jz($e, fe);
    return we($e, Ne), Ne;
  }
  return function() {
    return _e(wz.apply(null, arguments));
  };
}
var zz = Y(() => {
  Lz(), Uz(), Ez();
});
function Wt(ne) {
  var oe = function(ae) {
    return ae[ne] || [];
  };
  return oe.isThemeGetter = !0, oe;
}
var qz = Y(() => {
});
function ma(ne) {
  return Ll(ne) || YZ.has(ne) || WZ.test(ne) || wu(ne);
}
function wu(ne) {
  return oc(ne, "length", XZ);
}
function Hz(ne) {
  return oc(ne, "size", Gz);
}
function Vz(ne) {
  return oc(ne, "position", Gz);
}
function $z(ne) {
  return oc(ne, "url", JZ);
}
function Jm(ne) {
  return oc(ne, "number", Ll);
}
function Ll(ne) {
  return !Number.isNaN(Number(ne));
}
function Wz(ne) {
  return ne.endsWith("%") && Ll(ne.slice(0, -1));
}
function sd(ne) {
  return Iz(ne) || oc(ne, "number", Iz);
}
function yr(ne) {
  return Bz.test(ne);
}
function cd() {
  return !0;
}
function xu(ne) {
  return GZ.test(ne);
}
function Yz(ne) {
  return oc(ne, "", ZZ);
}
function oc(ne, oe, ae) {
  var fe = Bz.exec(ne);
  return fe ? fe[1] ? fe[1] === oe : ae(fe[2]) : !1;
}
function XZ(ne) {
  return QZ.test(ne);
}
function Gz() {
  return !1;
}
function JZ(ne) {
  return ne.startsWith("url(");
}
function Iz(ne) {
  return Number.isInteger(Number(ne));
}
function ZZ(ne) {
  return KZ.test(ne);
}
var Bz, WZ, YZ, GZ, QZ, KZ, Qz = Y(() => {
  Bz = /^\[(?:([a-z-]+):)?(.+)\]$/i, WZ = /^\d+\/\d+$/, YZ = /* @__PURE__ */ new Set(["px", "full", "screen"]), GZ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, QZ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))/, KZ = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
});
function Kz() {
  var ne = Wt("colors"), oe = Wt("spacing"), ae = Wt("blur"), fe = Wt("brightness"), ye = Wt("borderColor"), we = Wt("borderRadius"), _e = Wt("borderSpacing"), xe = Wt("borderWidth"), Oe = Wt("contrast"), $e = Wt("grayscale"), Re = Wt("hueRotate"), Ne = Wt("invert"), je = Wt("gap"), Be = Wt("gradientColorStops"), ze = Wt("gradientColorStopPositions"), He = Wt("inset"), qe = Wt("margin"), Ye = Wt("opacity"), ot = Wt("padding"), tt = Wt("saturate"), it = Wt("scale"), ht = Wt("sepia"), gt = Wt("skew"), At = Wt("space"), St = Wt("translate"), Nt = function() {
    return ["auto", "contain", "none"];
  }, Ft = function() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  }, Vt = function() {
    return ["auto", oe];
  }, on = function() {
    return ["", ma];
  }, tn = function() {
    return ["auto", Ll, yr];
  }, _n = function() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  }, en = function() {
    return ["solid", "dashed", "dotted", "double", "none"];
  }, dn = function() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  }, Ht = function() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  }, hn = function() {
    return ["", "0", yr];
  }, kn = function() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  }, Dn = function() {
    return [Ll, Jm];
  }, yt = function() {
    return [Ll, yr];
  };
  return { cacheSize: 500, theme: { colors: [cd], spacing: [ma], blur: ["none", "", xu, wu], brightness: Dn(), borderColor: [ne], borderRadius: ["none", "", "full", xu, wu], borderSpacing: [oe], borderWidth: on(), contrast: Dn(), grayscale: hn(), hueRotate: yt(), invert: hn(), gap: [oe], gradientColorStops: [ne], gradientColorStopPositions: [Wz, wu], inset: Vt(), margin: Vt(), opacity: Dn(), padding: [oe], saturate: Dn(), scale: Dn(), sepia: hn(), skew: yt(), space: [oe], translate: [oe] }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", yr] }], container: ["container"], columns: [{ columns: [xu] }], "break-after": [{ "break-after": kn() }], "break-before": [{ "break-before": kn() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none"] }], clear: [{ clear: ["left", "right", "both", "none"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [].concat(_n(), [yr]) }], overflow: [{ overflow: Ft() }], "overflow-x": [{ "overflow-x": Ft() }], "overflow-y": [{ "overflow-y": Ft() }], overscroll: [{ overscroll: Nt() }], "overscroll-x": [{ "overscroll-x": Nt() }], "overscroll-y": [{ "overscroll-y": Nt() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [He] }], "inset-x": [{ "inset-x": [He] }], "inset-y": [{ "inset-y": [He] }], start: [{ start: [He] }], end: [{ end: [He] }], top: [{ top: [He] }], right: [{ right: [He] }], bottom: [{ bottom: [He] }], left: [{ left: [He] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", sd] }], basis: [{ basis: [oe] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", yr] }], grow: [{ grow: hn() }], shrink: [{ shrink: hn() }], order: [{ order: ["first", "last", "none", sd] }], "grid-cols": [{ "grid-cols": [cd] }], "col-start-end": [{ col: ["auto", { span: [sd] }, yr] }], "col-start": [{ "col-start": tn() }], "col-end": [{ "col-end": tn() }], "grid-rows": [{ "grid-rows": [cd] }], "row-start-end": [{ row: ["auto", { span: [sd] }, yr] }], "row-start": [{ "row-start": tn() }], "row-end": [{ "row-end": tn() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", yr] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", yr] }], gap: [{ gap: [je] }], "gap-x": [{ "gap-x": [je] }], "gap-y": [{ "gap-y": [je] }], "justify-content": [{ justify: ["normal"].concat(Ht()) }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal"].concat(Ht(), ["baseline"]) }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [].concat(Ht(), ["baseline"]) }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [ot] }], px: [{ px: [ot] }], py: [{ py: [ot] }], ps: [{ ps: [ot] }], pe: [{ pe: [ot] }], pt: [{ pt: [ot] }], pr: [{ pr: [ot] }], pb: [{ pb: [ot] }], pl: [{ pl: [ot] }], m: [{ m: [qe] }], mx: [{ mx: [qe] }], my: [{ my: [qe] }], ms: [{ ms: [qe] }], me: [{ me: [qe] }], mt: [{ mt: [qe] }], mr: [{ mr: [qe] }], mb: [{ mb: [qe] }], ml: [{ ml: [qe] }], "space-x": [{ "space-x": [At] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [At] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", oe] }], "min-w": [{ "min-w": ["min", "max", "fit", ma] }], "max-w": [{ "max-w": ["0", "none", "full", "min", "max", "fit", "prose", { screen: [xu] }, xu, wu] }], h: [{ h: [oe, "auto", "min", "max", "fit"] }], "min-h": [{ "min-h": ["min", "max", "fit", ma] }], "max-h": [{ "max-h": [oe, "min", "max", "fit"] }], "font-size": [{ text: ["base", xu, wu] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Jm] }], "font-family": [{ font: [cd] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", wu] }], "line-clamp": [{ "line-clamp": ["none", Ll, Jm] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ma] }], "list-image": [{ "list-image": ["none", yr] }], "list-style-type": [{ list: ["none", "disc", "decimal", yr] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [ne] }], "placeholder-opacity": [{ "placeholder-opacity": [Ye] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [ne] }], "text-opacity": [{ "text-opacity": [Ye] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [].concat(en(), ["wavy"]) }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", ma] }], "underline-offset": [{ "underline-offset": ["auto", ma] }], "text-decoration-color": [{ decoration: [ne] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], indent: [{ indent: [oe] }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", wu] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", yr] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [Ye] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [].concat(_n(), [Vz]) }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Hz] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, $z] }], "bg-color": [{ bg: [ne] }], "gradient-from-pos": [{ from: [ze] }], "gradient-via-pos": [{ via: [ze] }], "gradient-to-pos": [{ to: [ze] }], "gradient-from": [{ from: [Be] }], "gradient-via": [{ via: [Be] }], "gradient-to": [{ to: [Be] }], rounded: [{ rounded: [we] }], "rounded-s": [{ "rounded-s": [we] }], "rounded-e": [{ "rounded-e": [we] }], "rounded-t": [{ "rounded-t": [we] }], "rounded-r": [{ "rounded-r": [we] }], "rounded-b": [{ "rounded-b": [we] }], "rounded-l": [{ "rounded-l": [we] }], "rounded-ss": [{ "rounded-ss": [we] }], "rounded-se": [{ "rounded-se": [we] }], "rounded-ee": [{ "rounded-ee": [we] }], "rounded-es": [{ "rounded-es": [we] }], "rounded-tl": [{ "rounded-tl": [we] }], "rounded-tr": [{ "rounded-tr": [we] }], "rounded-br": [{ "rounded-br": [we] }], "rounded-bl": [{ "rounded-bl": [we] }], "border-w": [{ border: [xe] }], "border-w-x": [{ "border-x": [xe] }], "border-w-y": [{ "border-y": [xe] }], "border-w-s": [{ "border-s": [xe] }], "border-w-e": [{ "border-e": [xe] }], "border-w-t": [{ "border-t": [xe] }], "border-w-r": [{ "border-r": [xe] }], "border-w-b": [{ "border-b": [xe] }], "border-w-l": [{ "border-l": [xe] }], "border-opacity": [{ "border-opacity": [Ye] }], "border-style": [{ border: [].concat(en(), ["hidden"]) }], "divide-x": [{ "divide-x": [xe] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [xe] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [Ye] }], "divide-style": [{ divide: en() }], "border-color": [{ border: [ye] }], "border-color-x": [{ "border-x": [ye] }], "border-color-y": [{ "border-y": [ye] }], "border-color-t": [{ "border-t": [ye] }], "border-color-r": [{ "border-r": [ye] }], "border-color-b": [{ "border-b": [ye] }], "border-color-l": [{ "border-l": [ye] }], "divide-color": [{ divide: [ye] }], "outline-style": [{ outline: [""].concat(en()) }], "outline-offset": [{ "outline-offset": [ma] }], "outline-w": [{ outline: [ma] }], "outline-color": [{ outline: [ne] }], "ring-w": [{ ring: on() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [ne] }], "ring-opacity": [{ "ring-opacity": [Ye] }], "ring-offset-w": [{ "ring-offset": [ma] }], "ring-offset-color": [{ "ring-offset": [ne] }], shadow: [{ shadow: ["", "inner", "none", xu, Yz] }], "shadow-color": [{ shadow: [cd] }], opacity: [{ opacity: [Ye] }], "mix-blend": [{ "mix-blend": dn() }], "bg-blend": [{ "bg-blend": dn() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [ae] }], brightness: [{ brightness: [fe] }], contrast: [{ contrast: [Oe] }], "drop-shadow": [{ "drop-shadow": ["", "none", xu, yr] }], grayscale: [{ grayscale: [$e] }], "hue-rotate": [{ "hue-rotate": [Re] }], invert: [{ invert: [Ne] }], saturate: [{ saturate: [tt] }], sepia: [{ sepia: [ht] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [ae] }], "backdrop-brightness": [{ "backdrop-brightness": [fe] }], "backdrop-contrast": [{ "backdrop-contrast": [Oe] }], "backdrop-grayscale": [{ "backdrop-grayscale": [$e] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [Re] }], "backdrop-invert": [{ "backdrop-invert": [Ne] }], "backdrop-opacity": [{ "backdrop-opacity": [Ye] }], "backdrop-saturate": [{ "backdrop-saturate": [tt] }], "backdrop-sepia": [{ "backdrop-sepia": [ht] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [_e] }], "border-spacing-x": [{ "border-spacing-x": [_e] }], "border-spacing-y": [{ "border-spacing-y": [_e] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", yr] }], duration: [{ duration: yt() }], ease: [{ ease: ["linear", "in", "out", "in-out", yr] }], delay: [{ delay: yt() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", yr] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [it] }], "scale-x": [{ "scale-x": [it] }], "scale-y": [{ "scale-y": [it] }], rotate: [{ rotate: [sd, yr] }], "translate-x": [{ "translate-x": [St] }], "translate-y": [{ "translate-y": [St] }], "skew-x": [{ "skew-x": [gt] }], "skew-y": [{ "skew-y": [gt] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", yr] }], accent: [{ accent: ["auto", ne] }], appearance: ["appearance-none"], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", yr] }], "caret-color": [{ caret: [ne] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": [oe] }], "scroll-mx": [{ "scroll-mx": [oe] }], "scroll-my": [{ "scroll-my": [oe] }], "scroll-ms": [{ "scroll-ms": [oe] }], "scroll-me": [{ "scroll-me": [oe] }], "scroll-mt": [{ "scroll-mt": [oe] }], "scroll-mr": [{ "scroll-mr": [oe] }], "scroll-mb": [{ "scroll-mb": [oe] }], "scroll-ml": [{ "scroll-ml": [oe] }], "scroll-p": [{ "scroll-p": [oe] }], "scroll-px": [{ "scroll-px": [oe] }], "scroll-py": [{ "scroll-py": [oe] }], "scroll-ps": [{ "scroll-ps": [oe] }], "scroll-pe": [{ "scroll-pe": [oe] }], "scroll-pt": [{ "scroll-pt": [oe] }], "scroll-pr": [{ "scroll-pr": [oe] }], "scroll-pb": [{ "scroll-pb": [oe] }], "scroll-pl": [{ "scroll-pl": [oe] }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "pinch-zoom", "manipulation", { pan: ["x", "left", "right", "y", "up", "down"] }] }], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", yr] }], fill: [{ fill: [ne, "none"] }], "stroke-w": [{ stroke: [ma, Jm] }], stroke: [{ stroke: [ne, "none"] }], sr: ["sr-only", "not-sr-only"] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } };
}
var Xz = Y(() => {
  qz(), Qz();
}), Pr, Jz = Y(() => {
  zz(), Xz(), Pr = Fz(Kz);
}), uc = Y(() => {
  Jz();
});
function Tt() {
  return Tt = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, Tt.apply(this, arguments);
}
function fq(ne) {
  ne === void 0 && (ne = {});
  let { initialEntries: oe = ["/"], initialIndex: ae, v5Compat: fe = !1 } = ne, ye;
  ye = oe.map((je, Be) => Re(je, typeof je == "string" ? null : je.state, Be === 0 ? "default" : void 0));
  let we = Oe(ae ?? ye.length - 1), _e = pr.Pop, xe = null;
  function Oe(je) {
    return Math.min(Math.max(je, 0), ye.length - 1);
  }
  function $e() {
    return ye[we];
  }
  function Re(je, Be, ze) {
    Be === void 0 && (Be = null);
    let He = uk(ye ? $e().pathname : "/", je, Be, ze);
    return ln(He.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(je)), He;
  }
  function Ne(je) {
    return typeof je == "string" ? je : Mo(je);
  }
  return { get index() {
    return we;
  }, get action() {
    return _e;
  }, get location() {
    return $e();
  }, createHref: Ne, createURL(je) {
    return new URL(Ne(je), "http://localhost");
  }, encodeLocation(je) {
    let Be = typeof je == "string" ? Qi(je) : je;
    return { pathname: Be.pathname || "", search: Be.search || "", hash: Be.hash || "" };
  }, push(je, Be) {
    _e = pr.Push;
    let ze = Re(je, Be);
    we += 1, ye.splice(we, ye.length, ze), fe && xe && xe({ action: _e, location: ze, delta: 1 });
  }, replace(je, Be) {
    _e = pr.Replace;
    let ze = Re(je, Be);
    ye[we] = ze, fe && xe && xe({ action: _e, location: ze, delta: 0 });
  }, go(je) {
    _e = pr.Pop;
    let Be = Oe(we + je), ze = ye[Be];
    we = Be, xe && xe({ action: _e, location: ze, delta: je });
  }, listen(je) {
    return xe = je, () => {
      xe = null;
    };
  } };
}
function Te(ne, oe) {
  if (ne === !1 || ne === null || typeof ne > "u")
    throw new Error(oe);
}
function ln(ne, oe) {
  if (!ne) {
    typeof console < "u" && console.warn(oe);
    try {
      throw new Error(oe);
    } catch {
    }
  }
}
function eee() {
  return Math.random().toString(36).substr(2, 8);
}
function uk(ne, oe, ae, fe) {
  return ae === void 0 && (ae = null), Tt({ pathname: typeof ne == "string" ? ne : ne.pathname, search: "", hash: "" }, typeof oe == "string" ? Qi(oe) : oe, { state: ae, key: oe && oe.key || fe || eee() });
}
function Mo(ne) {
  let { pathname: oe = "/", search: ae = "", hash: fe = "" } = ne;
  return ae && ae !== "?" && (oe += ae.charAt(0) === "?" ? ae : "?" + ae), fe && fe !== "#" && (oe += fe.charAt(0) === "#" ? fe : "#" + fe), oe;
}
function Qi(ne) {
  let oe = {};
  if (ne) {
    let ae = ne.indexOf("#");
    ae >= 0 && (oe.hash = ne.substr(ae), ne = ne.substr(0, ae));
    let fe = ne.indexOf("?");
    fe >= 0 && (oe.search = ne.substr(fe), ne = ne.substr(0, fe)), ne && (oe.pathname = ne);
  }
  return oe;
}
function ree(ne) {
  return ne.index === !0;
}
function dq(ne, oe, ae, fe) {
  return ae === void 0 && (ae = []), fe === void 0 && (fe = {}), ne.map((ye, we) => {
    let _e = [...ae, we], xe = typeof ye.id == "string" ? ye.id : _e.join("-");
    if (Te(ye.index !== !0 || !ye.children, "Cannot specify children on an index route"), Te(!fe[xe], 'Found a route id collision on id "' + xe + `".  Route id's must be globally unique within Data Router usages`), ree(ye)) {
      let Oe = Tt({}, ye, oe(ye), { id: xe });
      return fe[xe] = Oe, Oe;
    } else {
      let Oe = Tt({}, ye, oe(ye), { id: xe, children: void 0 });
      return fe[xe] = Oe, ye.children && (Oe.children = dq(ye.children, oe, _e, fe)), Oe;
    }
  });
}
function Cu(ne, oe, ae) {
  ae === void 0 && (ae = "/");
  let fe = typeof oe == "string" ? Qi(oe) : oe, ye = Ru(fe.pathname || "/", ae);
  if (ye == null)
    return null;
  let we = pq(ne);
  nee(we);
  let _e = null;
  for (let xe = 0; _e == null && xe < we.length; ++xe)
    _e = dee(we[xe], vee(ye));
  return _e;
}
function pq(ne, oe, ae, fe) {
  oe === void 0 && (oe = []), ae === void 0 && (ae = []), fe === void 0 && (fe = "");
  let ye = (we, _e, xe) => {
    let Oe = { relativePath: xe === void 0 ? we.path || "" : xe, caseSensitive: we.caseSensitive === !0, childrenIndex: _e, route: we };
    Oe.relativePath.startsWith("/") && (Te(Oe.relativePath.startsWith(fe), 'Absolute route path "' + Oe.relativePath + '" nested under path ' + ('"' + fe + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), Oe.relativePath = Oe.relativePath.slice(fe.length));
    let $e = ha([fe, Oe.relativePath]), Re = ae.concat(Oe);
    we.children && we.children.length > 0 && (Te(we.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + $e + '".')), pq(we.children, oe, Re, $e)), !(we.path == null && !we.index) && oe.push({ path: $e, score: cee($e, we.index), routesMeta: Re });
  };
  return ne.forEach((we, _e) => {
    var xe;
    if (we.path === "" || !((xe = we.path) != null && xe.includes("?")))
      ye(we, _e);
    else
      for (let Oe of vq(we.path))
        ye(we, _e, Oe);
  }), oe;
}
function vq(ne) {
  let oe = ne.split("/");
  if (oe.length === 0)
    return [];
  let [ae, ...fe] = oe, ye = ae.endsWith("?"), we = ae.replace(/\?$/, "");
  if (fe.length === 0)
    return ye ? [we, ""] : [we];
  let _e = vq(fe.join("/")), xe = [];
  return xe.push(..._e.map((Oe) => Oe === "" ? we : [we, Oe].join("/"))), ye && xe.push(..._e), xe.map((Oe) => ne.startsWith("/") && Oe === "" ? "/" : Oe);
}
function nee(ne) {
  ne.sort((oe, ae) => oe.score !== ae.score ? ae.score - oe.score : fee(oe.routesMeta.map((fe) => fe.childrenIndex), ae.routesMeta.map((fe) => fe.childrenIndex)));
}
function cee(ne, oe) {
  let ae = ne.split("/"), fe = ae.length;
  return ae.some(Zz) && (fe += see), oe && (fe += oee), ae.filter((ye) => !Zz(ye)).reduce((ye, we) => ye + (iee.test(we) ? aee : we === "" ? uee : lee), fe);
}
function fee(ne, oe) {
  return ne.length === oe.length && ne.slice(0, -1).every((ae, fe) => ae === oe[fe]) ? ne[ne.length - 1] - oe[oe.length - 1] : 0;
}
function dee(ne, oe) {
  let { routesMeta: ae } = ne, fe = {}, ye = "/", we = [];
  for (let _e = 0; _e < ae.length; ++_e) {
    let xe = ae[_e], Oe = _e === ae.length - 1, $e = ye === "/" ? oe : oe.slice(ye.length) || "/", Re = T0({ path: xe.relativePath, caseSensitive: xe.caseSensitive, end: Oe }, $e);
    if (!Re)
      return null;
    Object.assign(fe, Re.params);
    let Ne = xe.route;
    we.push({ params: fe, pathname: ha([ye, Re.pathname]), pathnameBase: yee(ha([ye, Re.pathnameBase])), route: Ne }), Re.pathnameBase !== "/" && (ye = ha([ye, Re.pathnameBase]));
  }
  return we;
}
function T0(ne, oe) {
  typeof ne == "string" && (ne = { path: ne, caseSensitive: !1, end: !0 });
  let [ae, fe] = pee(ne.path, ne.caseSensitive, ne.end), ye = oe.match(ae);
  if (!ye)
    return null;
  let we = ye[0], _e = we.replace(/(.)\/+$/, "$1"), xe = ye.slice(1);
  return { params: fe.reduce((Oe, $e, Re) => {
    if ($e === "*") {
      let Ne = xe[Re] || "";
      _e = we.slice(0, we.length - Ne.length).replace(/(.)\/+$/, "$1");
    }
    return Oe[$e] = mee(xe[Re] || "", $e), Oe;
  }, {}), pathname: we, pathnameBase: _e, pattern: ne };
}
function pee(ne, oe, ae) {
  oe === void 0 && (oe = !1), ae === void 0 && (ae = !0), ln(ne === "*" || !ne.endsWith("*") || ne.endsWith("/*"), 'Route path "' + ne + '" will be treated as if it were ' + ('"' + ne.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + ne.replace(/\*$/, "/*") + '".'));
  let fe = [], ye = "^" + ne.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (we, _e) => (fe.push(_e), "/([^\\/]+)"));
  return ne.endsWith("*") ? (fe.push("*"), ye += ne === "*" || ne === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : ae ? ye += "\\/*$" : ne !== "" && ne !== "/" && (ye += "(?:(?=\\/|$))"), [new RegExp(ye, oe ? void 0 : "i"), fe];
}
function vee(ne) {
  try {
    return decodeURI(ne);
  } catch (oe) {
    return ln(!1, 'The URL path "' + ne + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + oe + ").")), ne;
  }
}
function mee(ne, oe) {
  try {
    return decodeURIComponent(ne);
  } catch (ae) {
    return ln(!1, 'The value for the URL param "' + oe + '" will not be decoded because' + (' the string "' + ne + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + ae + ").")), ne;
  }
}
function Ru(ne, oe) {
  if (oe === "/")
    return ne;
  if (!ne.toLowerCase().startsWith(oe.toLowerCase()))
    return null;
  let ae = oe.endsWith("/") ? oe.length - 1 : oe.length, fe = ne.charAt(ae);
  return fe && fe !== "/" ? null : ne.slice(ae) || "/";
}
function ck(ne, oe) {
  oe === void 0 && (oe = "/");
  let { pathname: ae, search: fe = "", hash: ye = "" } = typeof ne == "string" ? Qi(ne) : ne;
  return { pathname: ae ? ae.startsWith("/") ? ae : hee(ae, oe) : oe, search: gee(fe), hash: bee(ye) };
}
function hee(ne, oe) {
  let ae = oe.replace(/\/+$/, "").split("/");
  return ne.split("/").forEach((fe) => {
    fe === ".." ? ae.length > 1 && ae.pop() : fe !== "." && ae.push(fe);
  }), ae.length > 1 ? ae.join("/") : "/";
}
function ak(ne, oe, ae, fe) {
  return "Cannot include a '" + ne + "' character in a manually specified " + ("`to." + oe + "` field [" + JSON.stringify(fe) + "].  Please separate it out to the ") + ("`to." + ae + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function nh(ne) {
  return ne.filter((oe, ae) => ae === 0 || oe.route.path && oe.route.path.length > 0);
}
function k0(ne, oe, ae, fe) {
  fe === void 0 && (fe = !1);
  let ye;
  typeof ne == "string" ? ye = Qi(ne) : (ye = Tt({}, ne), Te(!ye.pathname || !ye.pathname.includes("?"), ak("?", "pathname", "search", ye)), Te(!ye.pathname || !ye.pathname.includes("#"), ak("#", "pathname", "hash", ye)), Te(!ye.search || !ye.search.includes("#"), ak("#", "search", "hash", ye)));
  let we = ne === "" || ye.pathname === "", _e = we ? "/" : ye.pathname, xe;
  if (fe || _e == null)
    xe = ae;
  else {
    let Ne = oe.length - 1;
    if (_e.startsWith("..")) {
      let je = _e.split("/");
      for (; je[0] === ".."; )
        je.shift(), Ne -= 1;
      ye.pathname = je.join("/");
    }
    xe = Ne >= 0 ? oe[Ne] : "/";
  }
  let Oe = ck(ye, xe), $e = _e && _e !== "/" && _e.endsWith("/"), Re = (we || _e === ".") && ae.endsWith("/");
  return !Oe.pathname.endsWith("/") && ($e || Re) && (Oe.pathname += "/"), Oe;
}
function ih(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.internal == "boolean" && "data" in ne;
}
function fk(ne) {
  Te(ne.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let oe;
  if (ne.mapRouteProperties)
    oe = ne.mapRouteProperties;
  else if (ne.detectErrorBoundary) {
    let Bt = ne.detectErrorBoundary;
    oe = (Kt) => ({ hasErrorBoundary: Bt(Kt) });
  } else
    oe = Oee;
  let ae = {}, fe = dq(ne.routes, oe, void 0, ae), ye, we = ne.basename || "/", _e = Tt({ v7_normalizeFormMethod: !1, v7_prependBasename: !1 }, ne.future), xe = null, Oe = /* @__PURE__ */ new Set(), $e = null, Re = null, Ne = null, je = ne.hydrationData != null, Be = Cu(fe, ne.history.location, we), ze = null;
  if (Be == null) {
    let Bt = Wa(404, { pathname: ne.history.location.pathname }), { matches: Kt, route: mn } = uq(fe);
    Be = Kt, ze = { [mn.id]: Bt };
  }
  let He = !Be.some((Bt) => Bt.route.lazy) && (!Be.some((Bt) => Bt.route.loader) || ne.hydrationData != null), qe, Ye = { historyAction: ne.history.action, location: ne.history.location, matches: Be, initialized: He, navigation: ok, restoreScrollPosition: ne.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: ne.hydrationData && ne.hydrationData.loaderData || {}, actionData: ne.hydrationData && ne.hydrationData.actionData || null, errors: ne.hydrationData && ne.hydrationData.errors || ze, fetchers: /* @__PURE__ */ new Map(), blockers: /* @__PURE__ */ new Map() }, ot = pr.Pop, tt = !1, it, ht = !1, gt = !1, At = [], St = [], Nt = /* @__PURE__ */ new Map(), Ft = 0, Vt = -1, on = /* @__PURE__ */ new Map(), tn = /* @__PURE__ */ new Set(), _n = /* @__PURE__ */ new Map(), en = /* @__PURE__ */ new Map(), dn = /* @__PURE__ */ new Map(), Ht = !1;
  function hn() {
    return xe = ne.history.listen((Bt) => {
      let { action: Kt, location: mn, delta: jn } = Bt;
      if (Ht) {
        Ht = !1;
        return;
      }
      ln(dn.size === 0 || jn != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let zn = Ia({ currentLocation: Ye.location, nextLocation: mn, historyAction: Kt });
      if (zn && jn != null) {
        Ht = !0, ne.history.go(jn * -1), la(zn, { state: "blocked", location: mn, proceed() {
          la(zn, { state: "proceeding", proceed: void 0, reset: void 0, location: mn }), ne.history.go(jn);
        }, reset() {
          Ro(zn), yt({ blockers: new Map(qe.state.blockers) });
        } });
        return;
      }
      return Zt(Kt, mn);
    }), Ye.initialized || Zt(pr.Pop, Ye.location), qe;
  }
  function kn() {
    xe && xe(), Oe.clear(), it && it.abort(), Ye.fetchers.forEach((Bt, Kt) => Po(Kt)), Ye.blockers.forEach((Bt, Kt) => Ro(Kt));
  }
  function Dn(Bt) {
    return Oe.add(Bt), () => Oe.delete(Bt);
  }
  function yt(Bt) {
    Ye = Tt({}, Ye, Bt), Oe.forEach((Kt) => Kt(Ye));
  }
  function jt(Bt, Kt) {
    var mn, jn;
    let zn = Ye.actionData != null && Ye.navigation.formMethod != null && Eu(Ye.navigation.formMethod) && Ye.navigation.state === "loading" && ((mn = Bt.state) == null ? void 0 : mn._isRedirect) !== !0, qn;
    Kt.actionData ? Object.keys(Kt.actionData).length > 0 ? qn = Kt.actionData : qn = null : zn ? qn = Ye.actionData : qn = null;
    let rr = Kt.loaderData ? oq(Ye.loaderData, Kt.loaderData, Kt.matches || [], Kt.errors) : Ye.loaderData;
    for (let [Wn] of dn)
      Ro(Wn);
    let or = tt === !0 || Ye.navigation.formMethod != null && Eu(Ye.navigation.formMethod) && ((jn = Bt.state) == null ? void 0 : jn._isRedirect) !== !0;
    ye && (fe = ye, ye = void 0), yt(Tt({}, Kt, { actionData: qn, loaderData: rr, historyAction: ot, location: Bt, initialized: !0, navigation: ok, revalidation: "idle", restoreScrollPosition: Bo(Bt, Kt.matches || Ye.matches), preventScrollReset: or, blockers: new Map(Ye.blockers) })), ht || ot === pr.Pop || (ot === pr.Push ? ne.history.push(Bt, Bt.state) : ot === pr.Replace && ne.history.replace(Bt, Bt.state)), ot = pr.Pop, tt = !1, ht = !1, gt = !1, At = [], St = [];
  }
  async function Mn(Bt, Kt) {
    if (typeof Bt == "number") {
      ne.history.go(Bt);
      return;
    }
    let mn = lk(Ye.location, Ye.matches, we, _e.v7_prependBasename, Bt, Kt == null ? void 0 : Kt.fromRouteId, Kt == null ? void 0 : Kt.relative), { path: jn, submission: zn, error: qn } = tq(_e.v7_normalizeFormMethod, !1, mn, Kt), rr = Ye.location, or = uk(Ye.location, jn, Kt && Kt.state);
    or = Tt({}, or, ne.history.encodeLocation(or));
    let Wn = Kt && Kt.replace != null ? Kt.replace : void 0, Ar = pr.Push;
    Wn === !0 ? Ar = pr.Replace : Wn === !1 || zn != null && Eu(zn.formMethod) && zn.formAction === Ye.location.pathname + Ye.location.search && (Ar = pr.Replace);
    let Br = Kt && "preventScrollReset" in Kt ? Kt.preventScrollReset === !0 : void 0, wo = Ia({ currentLocation: rr, nextLocation: or, historyAction: Ar });
    if (wo) {
      la(wo, { state: "blocked", location: or, proceed() {
        la(wo, { state: "proceeding", proceed: void 0, reset: void 0, location: or }), Mn(Bt, Kt);
      }, reset() {
        Ro(wo), yt({ blockers: new Map(Ye.blockers) });
      } });
      return;
    }
    return await Zt(Ar, or, { submission: zn, pendingError: qn, preventScrollReset: Br, replace: Kt && Kt.replace });
  }
  function $n() {
    if (so(), yt({ revalidation: "loading" }), Ye.navigation.state !== "submitting") {
      if (Ye.navigation.state === "idle") {
        Zt(Ye.historyAction, Ye.location, { startUninterruptedRevalidation: !0 });
        return;
      }
      Zt(ot || Ye.historyAction, Ye.navigation.location, { overrideNavigation: Ye.navigation });
    }
  }
  async function Zt(Bt, Kt, mn) {
    it && it.abort(), it = null, ot = Bt, ht = (mn && mn.startUninterruptedRevalidation) === !0, Ra(Ye.location, Ye.matches), tt = (mn && mn.preventScrollReset) === !0;
    let jn = ye || fe, zn = mn && mn.overrideNavigation, qn = Cu(jn, Kt, we);
    if (!qn) {
      let wr = Wa(404, { pathname: Kt.pathname }), { matches: _r, route: To } = uq(jn);
      Go(), jt(Kt, { matches: _r, loaderData: {}, errors: { [To.id]: wr } });
      return;
    }
    if (Mee(Ye.location, Kt) && !(mn && mn.submission && Eu(mn.submission.formMethod))) {
      jt(Kt, { matches: qn });
      return;
    }
    it = new AbortController();
    let rr = eh(ne.history, Kt, it.signal, mn && mn.submission), or, Wn;
    if (mn && mn.pendingError)
      Wn = { [fd(qn).route.id]: mn.pendingError };
    else if (mn && mn.submission && Eu(mn.submission.formMethod)) {
      let wr = await vn(rr, Kt, mn.submission, qn, { replace: mn.replace });
      if (wr.shortCircuited)
        return;
      or = wr.pendingActionData, Wn = wr.pendingActionError, zn = Tt({ state: "loading", location: Kt }, mn.submission), rr = new Request(rr.url, { signal: rr.signal });
    }
    let { shortCircuited: Ar, loaderData: Br, errors: wo } = await Fn(rr, Kt, qn, zn, mn && mn.submission, mn && mn.fetcherSubmission, mn && mn.replace, or, Wn);
    Ar || (it = null, jt(Kt, Tt({ matches: qn }, or ? { actionData: or } : {}, { loaderData: Br, errors: wo })));
  }
  async function vn(Bt, Kt, mn, jn, zn) {
    so();
    let qn = Tt({ state: "submitting", location: Kt }, mn);
    yt({ navigation: qn });
    let rr, or = sk(jn, Kt);
    if (!or.route.action && !or.route.lazy)
      rr = { type: Gr.error, error: Wa(405, { method: Bt.method, pathname: Kt.pathname, routeId: or.route.id }) };
    else if (rr = await Zm("action", Bt, or, jn, ae, oe, we), Bt.signal.aborted)
      return { shortCircuited: !0 };
    if (dd(rr)) {
      let Wn;
      return zn && zn.replace != null ? Wn = zn.replace : Wn = rr.location === Ye.location.pathname + Ye.location.search, await ao(Ye, rr, { submission: mn, replace: Wn }), { shortCircuited: !0 };
    }
    if (th(rr)) {
      let Wn = fd(jn, or.route.id);
      return (zn && zn.replace) !== !0 && (ot = pr.Push), { pendingActionData: {}, pendingActionError: { [Wn.route.id]: rr.error } };
    }
    if (lc(rr))
      throw Wa(400, { type: "defer-action" });
    return { pendingActionData: { [or.route.id]: rr.data } };
  }
  async function Fn(Bt, Kt, mn, jn, zn, qn, rr, or, Wn) {
    let Ar = jn;
    Ar || (Ar = Tt({ state: "loading", location: Kt, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, zn));
    let Br = zn || qn ? zn || qn : Ar.formMethod && Ar.formAction && Ar.formData && Ar.formEncType ? { formMethod: Ar.formMethod, formAction: Ar.formAction, formData: Ar.formData, formEncType: Ar.formEncType } : void 0, wo = ye || fe, [wr, _r] = rq(ne.history, Ye, mn, Br, Kt, gt, At, St, _n, wo, we, or, Wn);
    if (Go((fo) => !(mn && mn.some((_o) => _o.route.id === fo)) || wr && wr.some((_o) => _o.route.id === fo)), wr.length === 0 && _r.length === 0) {
      let fo = va();
      return jt(Kt, Tt({ matches: mn, loaderData: {}, errors: Wn || null }, or ? { actionData: or } : {}, fo ? { fetchers: new Map(Ye.fetchers) } : {})), { shortCircuited: !0 };
    }
    if (!ht) {
      _r.forEach((_o) => {
        let oa = Ye.fetchers.get(_o.key), Ma = { state: "loading", data: oa && oa.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        Ye.fetchers.set(_o.key, Ma);
      });
      let fo = or || Ye.actionData;
      yt(Tt({ navigation: Ar }, fo ? Object.keys(fo).length === 0 ? { actionData: null } : { actionData: fo } : {}, _r.length > 0 ? { fetchers: new Map(Ye.fetchers) } : {}));
    }
    Vt = ++Ft, _r.forEach((fo) => {
      fo.controller && Nt.set(fo.key, fo.controller);
    });
    let To = () => _r.forEach((fo) => vo(fo.key));
    it && it.signal.addEventListener("abort", To);
    let { results: Ha, loaderResults: Bi, fetcherResults: Ui } = await Yr(Ye.matches, mn, wr, _r, Bt);
    if (Bt.signal.aborted)
      return { shortCircuited: !0 };
    it && it.signal.removeEventListener("abort", To), _r.forEach((fo) => Nt.delete(fo.key));
    let qa = lq(Ha);
    if (qa)
      return await ao(Ye, qa, { replace: rr }), { shortCircuited: !0 };
    let { loaderData: si, errors: ra } = aq(Ye, mn, wr, Bi, Wn, _r, Ui, en);
    en.forEach((fo, _o) => {
      fo.subscribe((oa) => {
        (oa || fo.done) && en.delete(_o);
      });
    });
    let Ta = va(), ci = go(Vt), wa = Ta || ci || _r.length > 0;
    return Tt({ loaderData: si, errors: ra }, wa ? { fetchers: new Map(Ye.fetchers) } : {});
  }
  function Qn(Bt) {
    return Ye.fetchers.get(Bt) || Cee;
  }
  function Un(Bt, Kt, mn, jn) {
    if (Ree)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    Nt.has(Bt) && vo(Bt);
    let zn = ye || fe, qn = lk(Ye.location, Ye.matches, we, _e.v7_prependBasename, mn, Kt, jn == null ? void 0 : jn.relative), rr = Cu(zn, qn, we);
    if (!rr) {
      Io(Bt, Kt, Wa(404, { pathname: qn }));
      return;
    }
    let { path: or, submission: Wn } = tq(_e.v7_normalizeFormMethod, !0, qn, jn), Ar = sk(rr, or);
    if (tt = (jn && jn.preventScrollReset) === !0, Wn && Eu(Wn.formMethod)) {
      ar(Bt, Kt, or, Ar, rr, Wn);
      return;
    }
    _n.set(Bt, { routeId: Kt, path: or }), Zo(Bt, Kt, or, Ar, rr, Wn);
  }
  async function ar(Bt, Kt, mn, jn, zn, qn) {
    if (so(), _n.delete(Bt), !jn.route.action && !jn.route.lazy) {
      let Rt = Wa(405, { method: qn.formMethod, pathname: mn, routeId: Kt });
      Io(Bt, Kt, Rt);
      return;
    }
    let rr = Ye.fetchers.get(Bt), or = Tt({ state: "submitting" }, qn, { data: rr && rr.data, " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Bt, or), yt({ fetchers: new Map(Ye.fetchers) });
    let Wn = new AbortController(), Ar = eh(ne.history, mn, Wn.signal, qn);
    Nt.set(Bt, Wn);
    let Br = await Zm("action", Ar, jn, zn, ae, oe, we);
    if (Ar.signal.aborted) {
      Nt.get(Bt) === Wn && Nt.delete(Bt);
      return;
    }
    if (dd(Br)) {
      Nt.delete(Bt), tn.add(Bt);
      let Rt = Tt({ state: "loading" }, qn, { data: void 0, " _hasFetcherDoneAnything ": !0 });
      return Ye.fetchers.set(Bt, Rt), yt({ fetchers: new Map(Ye.fetchers) }), ao(Ye, Br, { submission: qn, isFetchActionRedirect: !0 });
    }
    if (th(Br)) {
      Io(Bt, Kt, Br.error);
      return;
    }
    if (lc(Br))
      throw Wa(400, { type: "defer-action" });
    let wo = Ye.navigation.location || Ye.location, wr = eh(ne.history, wo, Wn.signal), _r = ye || fe, To = Ye.navigation.state !== "idle" ? Cu(_r, Ye.navigation.location, we) : Ye.matches;
    Te(To, "Didn't find any matches after fetcher action");
    let Ha = ++Ft;
    on.set(Bt, Ha);
    let Bi = Tt({ state: "loading", data: Br.data }, qn, { " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Bt, Bi);
    let [Ui, qa] = rq(ne.history, Ye, To, qn, wo, gt, At, St, _n, _r, we, { [jn.route.id]: Br.data }, void 0);
    qa.filter((Rt) => Rt.key !== Bt).forEach((Rt) => {
      let Cn = Rt.key, Pn = Ye.fetchers.get(Cn), hr = { state: "loading", data: Pn && Pn.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      Ye.fetchers.set(Cn, hr), Rt.controller && Nt.set(Cn, Rt.controller);
    }), yt({ fetchers: new Map(Ye.fetchers) });
    let si = () => qa.forEach((Rt) => vo(Rt.key));
    Wn.signal.addEventListener("abort", si);
    let { results: ra, loaderResults: Ta, fetcherResults: ci } = await Yr(Ye.matches, To, Ui, qa, wr);
    if (Wn.signal.aborted)
      return;
    Wn.signal.removeEventListener("abort", si), on.delete(Bt), Nt.delete(Bt), qa.forEach((Rt) => Nt.delete(Rt.key));
    let wa = lq(ra);
    if (wa)
      return ao(Ye, wa);
    let { loaderData: fo, errors: _o } = aq(Ye, Ye.matches, Ui, Ta, void 0, qa, ci, en), oa = { state: "idle", data: Br.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    Ye.fetchers.set(Bt, oa);
    let Ma = go(Ha);
    Ye.navigation.state === "loading" && Ha > Vt ? (Te(ot, "Expected pending action"), it && it.abort(), jt(Ye.navigation.location, { matches: To, loaderData: fo, errors: _o, fetchers: new Map(Ye.fetchers) })) : (yt(Tt({ errors: _o, loaderData: oq(Ye.loaderData, fo, To, _o) }, Ma ? { fetchers: new Map(Ye.fetchers) } : {})), gt = !1);
  }
  async function Zo(Bt, Kt, mn, jn, zn, qn) {
    let rr = Ye.fetchers.get(Bt), or = Tt({ state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, qn, { data: rr && rr.data, " _hasFetcherDoneAnything ": !0 });
    Ye.fetchers.set(Bt, or), yt({ fetchers: new Map(Ye.fetchers) });
    let Wn = new AbortController(), Ar = eh(ne.history, mn, Wn.signal);
    Nt.set(Bt, Wn);
    let Br = await Zm("loader", Ar, jn, zn, ae, oe, we);
    if (lc(Br) && (Br = await _q(Br, Ar.signal, !0) || Br), Nt.get(Bt) === Wn && Nt.delete(Bt), Ar.signal.aborted)
      return;
    if (dd(Br)) {
      tn.add(Bt), await ao(Ye, Br);
      return;
    }
    if (th(Br)) {
      let wr = fd(Ye.matches, Kt);
      Ye.fetchers.delete(Bt), yt({ fetchers: new Map(Ye.fetchers), errors: { [wr.route.id]: Br.error } });
      return;
    }
    Te(!lc(Br), "Unhandled fetcher deferred data");
    let wo = { state: "idle", data: Br.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    Ye.fetchers.set(Bt, wo), yt({ fetchers: new Map(Ye.fetchers) });
  }
  async function ao(Bt, Kt, mn) {
    var jn;
    let { submission: zn, replace: qn, isFetchActionRedirect: rr } = mn === void 0 ? {} : mn;
    Kt.revalidate && (gt = !0);
    let or = uk(Bt.location, Kt.location, Tt({ _isRedirect: !0 }, rr ? { _isFetchActionRedirect: !0 } : {}));
    if (Te(or, "Expected a location on the redirect navigation"), hq.test(Kt.location) && yq && typeof ((jn = window) == null ? void 0 : jn.location) < "u") {
      let _r = ne.history.createURL(Kt.location), To = Ru(_r.pathname, we) == null;
      if (window.location.origin !== _r.origin || To) {
        qn ? window.location.replace(Kt.location) : window.location.assign(Kt.location);
        return;
      }
    }
    it = null;
    let Wn = qn === !0 ? pr.Replace : pr.Push, { formMethod: Ar, formAction: Br, formEncType: wo, formData: wr } = Bt.navigation;
    !zn && Ar && Br && wr && wo && (zn = { formMethod: Ar, formAction: Br, formEncType: wo, formData: wr }), Eee.has(Kt.status) && zn && Eu(zn.formMethod) ? await Zt(Wn, or, { submission: Tt({}, zn, { formAction: Kt.location }), preventScrollReset: tt }) : rr ? await Zt(Wn, or, { overrideNavigation: { state: "loading", location: or, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, fetcherSubmission: zn, preventScrollReset: tt }) : await Zt(Wn, or, { overrideNavigation: { state: "loading", location: or, formMethod: zn ? zn.formMethod : void 0, formAction: zn ? zn.formAction : void 0, formEncType: zn ? zn.formEncType : void 0, formData: zn ? zn.formData : void 0 }, preventScrollReset: tt });
  }
  async function Yr(Bt, Kt, mn, jn, zn) {
    let qn = await Promise.all([...mn.map((Wn) => Zm("loader", zn, Wn, Kt, ae, oe, we)), ...jn.map((Wn) => Wn.matches && Wn.match && Wn.controller ? Zm("loader", eh(ne.history, Wn.path, Wn.controller.signal), Wn.match, Wn.matches, ae, oe, we) : { type: Gr.error, error: Wa(404, { pathname: Wn.path }) })]), rr = qn.slice(0, mn.length), or = qn.slice(mn.length);
    return await Promise.all([sq(Bt, mn, rr, rr.map(() => zn.signal), !1, Ye.loaderData), sq(Bt, jn.map((Wn) => Wn.match), or, jn.map((Wn) => Wn.controller ? Wn.controller.signal : null), !0)]), { results: qn, loaderResults: rr, fetcherResults: or };
  }
  function so() {
    gt = !0, At.push(...Go()), _n.forEach((Bt, Kt) => {
      Nt.has(Kt) && (St.push(Kt), vo(Kt));
    });
  }
  function Io(Bt, Kt, mn) {
    let jn = fd(Ye.matches, Kt);
    Po(Bt), yt({ errors: { [jn.route.id]: mn }, fetchers: new Map(Ye.fetchers) });
  }
  function Po(Bt) {
    Nt.has(Bt) && vo(Bt), _n.delete(Bt), on.delete(Bt), tn.delete(Bt), Ye.fetchers.delete(Bt);
  }
  function vo(Bt) {
    let Kt = Nt.get(Bt);
    Te(Kt, "Expected fetch controller: " + Bt), Kt.abort(), Nt.delete(Bt);
  }
  function na(Bt) {
    for (let Kt of Bt) {
      let mn = { state: "idle", data: Qn(Kt).data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      Ye.fetchers.set(Kt, mn);
    }
  }
  function va() {
    let Bt = [], Kt = !1;
    for (let mn of tn) {
      let jn = Ye.fetchers.get(mn);
      Te(jn, "Expected fetcher: " + mn), jn.state === "loading" && (tn.delete(mn), Bt.push(mn), Kt = !0);
    }
    return na(Bt), Kt;
  }
  function go(Bt) {
    let Kt = [];
    for (let [mn, jn] of on)
      if (jn < Bt) {
        let zn = Ye.fetchers.get(mn);
        Te(zn, "Expected fetcher: " + mn), zn.state === "loading" && (vo(mn), on.delete(mn), Kt.push(mn));
      }
    return na(Kt), Kt.length > 0;
  }
  function Fo(Bt, Kt) {
    let mn = Ye.blockers.get(Bt) || eq;
    return dn.get(Bt) !== Kt && dn.set(Bt, Kt), mn;
  }
  function Ro(Bt) {
    Ye.blockers.delete(Bt), dn.delete(Bt);
  }
  function la(Bt, Kt) {
    let mn = Ye.blockers.get(Bt) || eq;
    Te(mn.state === "unblocked" && Kt.state === "blocked" || mn.state === "blocked" && Kt.state === "blocked" || mn.state === "blocked" && Kt.state === "proceeding" || mn.state === "blocked" && Kt.state === "unblocked" || mn.state === "proceeding" && Kt.state === "unblocked", "Invalid blocker state transition: " + mn.state + " -> " + Kt.state), Ye.blockers.set(Bt, Kt), yt({ blockers: new Map(Ye.blockers) });
  }
  function Ia(Bt) {
    let { currentLocation: Kt, nextLocation: mn, historyAction: jn } = Bt;
    if (dn.size === 0)
      return;
    dn.size > 1 && ln(!1, "A router only supports one blocker at a time");
    let zn = Array.from(dn.entries()), [qn, rr] = zn[zn.length - 1], or = Ye.blockers.get(qn);
    if (!(or && or.state === "proceeding") && rr({ currentLocation: Kt, nextLocation: mn, historyAction: jn }))
      return qn;
  }
  function Go(Bt) {
    let Kt = [];
    return en.forEach((mn, jn) => {
      (!Bt || Bt(jn)) && (mn.cancel(), Kt.push(jn), en.delete(jn));
    }), Kt;
  }
  function Yo(Bt, Kt, mn) {
    if ($e = Bt, Ne = Kt, Re = mn || ((jn) => jn.key), !je && Ye.navigation === ok) {
      je = !0;
      let jn = Bo(Ye.location, Ye.matches);
      jn != null && yt({ restoreScrollPosition: jn });
    }
    return () => {
      $e = null, Ne = null, Re = null;
    };
  }
  function Ra(Bt, Kt) {
    if ($e && Re && Ne) {
      let mn = Kt.map((zn) => cq(zn, Ye.loaderData)), jn = Re(Bt, mn) || Bt.key;
      $e[jn] = Ne();
    }
  }
  function Bo(Bt, Kt) {
    if ($e && Re && Ne) {
      let mn = Kt.map((qn) => cq(qn, Ye.loaderData)), jn = Re(Bt, mn) || Bt.key, zn = $e[jn];
      if (typeof zn == "number")
        return zn;
    }
    return null;
  }
  function Na(Bt) {
    ye = Bt;
  }
  return qe = { get basename() {
    return we;
  }, get state() {
    return Ye;
  }, get routes() {
    return fe;
  }, initialize: hn, subscribe: Dn, enableScrollRestoration: Yo, navigate: Mn, fetch: Un, revalidate: $n, createHref: (Bt) => ne.history.createHref(Bt), encodeLocation: (Bt) => ne.history.encodeLocation(Bt), getFetcher: Qn, deleteFetcher: Po, dispose: kn, getBlocker: Fo, deleteBlocker: Ro, _internalFetchControllers: Nt, _internalActiveDeferreds: en, _internalSetRoutes: Na }, qe;
}
function Tee(ne) {
  return ne != null && "formData" in ne;
}
function lk(ne, oe, ae, fe, ye, we, _e) {
  let xe, Oe;
  if (we != null && _e !== "path") {
    xe = [];
    for (let Re of oe)
      if (xe.push(Re), Re.route.id === we) {
        Oe = Re;
        break;
      }
  } else
    xe = oe, Oe = oe[oe.length - 1];
  let $e = k0(ye || ".", nh(xe).map((Re) => Re.pathnameBase), ne.pathname, _e === "path");
  return ye == null && ($e.search = ne.search, $e.hash = ne.hash), (ye == null || ye === "" || ye === ".") && Oe && Oe.route.index && !dk($e.search) && ($e.search = $e.search ? $e.search.replace(/^\?/, "?index&") : "?index"), fe && ae !== "/" && ($e.pathname = $e.pathname === "/" ? ae : ha([ae, $e.pathname])), Mo($e);
}
function tq(ne, oe, ae, fe) {
  if (!fe || !Tee(fe))
    return { path: ae };
  if (fe.formMethod && !Lee(fe.formMethod))
    return { path: ae, error: Wa(405, { method: fe.formMethod }) };
  let ye;
  if (fe.formData) {
    let xe = fe.formMethod || "get";
    if (ye = { formMethod: ne ? xe.toUpperCase() : xe.toLowerCase(), formAction: Sq(ae), formEncType: fe && fe.formEncType || "application/x-www-form-urlencoded", formData: fe.formData }, Eu(ye.formMethod))
      return { path: ae, submission: ye };
  }
  let we = Qi(ae), _e = bq(fe.formData);
  return oe && we.search && dk(we.search) && _e.append("index", ""), we.search = "?" + _e, { path: Mo(we), submission: ye };
}
function kee(ne, oe) {
  let ae = ne;
  if (oe) {
    let fe = ne.findIndex((ye) => ye.route.id === oe);
    fe >= 0 && (ae = ne.slice(0, fe));
  }
  return ae;
}
function rq(ne, oe, ae, fe, ye, we, _e, xe, Oe, $e, Re, Ne, je) {
  let Be = je ? Object.values(je)[0] : Ne ? Object.values(Ne)[0] : void 0, ze = ne.createURL(oe.location), He = ne.createURL(ye), qe = je ? Object.keys(je)[0] : void 0, Ye = kee(ae, qe).filter((tt, it) => {
    if (tt.route.lazy)
      return !0;
    if (tt.route.loader == null)
      return !1;
    if (Aee(oe.loaderData, oe.matches[it], tt) || _e.some((At) => At === tt.route.id))
      return !0;
    let ht = oe.matches[it], gt = tt;
    return nq(tt, Tt({ currentUrl: ze, currentParams: ht.params, nextUrl: He, nextParams: gt.params }, fe, { actionResult: Be, defaultShouldRevalidate: we || ze.toString() === He.toString() || ze.search !== He.search || gq(ht, gt) }));
  }), ot = [];
  return Oe.forEach((tt, it) => {
    if (!ae.some((At) => At.route.id === tt.routeId))
      return;
    let ht = Cu($e, tt.path, Re);
    if (!ht) {
      ot.push({ key: it, routeId: tt.routeId, path: tt.path, matches: null, match: null, controller: null });
      return;
    }
    let gt = sk(ht, tt.path);
    if (xe.includes(it)) {
      ot.push({ key: it, routeId: tt.routeId, path: tt.path, matches: ht, match: gt, controller: new AbortController() });
      return;
    }
    nq(gt, Tt({ currentUrl: ze, currentParams: oe.matches[oe.matches.length - 1].params, nextUrl: He, nextParams: ae[ae.length - 1].params }, fe, { actionResult: Be, defaultShouldRevalidate: we })) && ot.push({ key: it, routeId: tt.routeId, path: tt.path, matches: ht, match: gt, controller: new AbortController() });
  }), [Ye, ot];
}
function Aee(ne, oe, ae) {
  let fe = !oe || ae.route.id !== oe.route.id, ye = ne[ae.route.id] === void 0;
  return fe || ye;
}
function gq(ne, oe) {
  let ae = ne.route.path;
  return ne.pathname !== oe.pathname || ae != null && ae.endsWith("*") && ne.params["*"] !== oe.params["*"];
}
function nq(ne, oe) {
  if (ne.route.shouldRevalidate) {
    let ae = ne.route.shouldRevalidate(oe);
    if (typeof ae == "boolean")
      return ae;
  }
  return oe.defaultShouldRevalidate;
}
async function iq(ne, oe, ae) {
  if (!ne.lazy)
    return;
  let fe = await ne.lazy();
  if (!ne.lazy)
    return;
  let ye = ae[ne.id];
  Te(ye, "No route found in manifest");
  let we = {};
  for (let _e in fe) {
    let xe = ye[_e] !== void 0 && _e !== "hasErrorBoundary";
    ln(!xe, 'Route "' + ye.id + '" has a static property "' + _e + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + _e + '" will be ignored.')), !xe && !tee.has(_e) && (we[_e] = fe[_e]);
  }
  Object.assign(ye, we), Object.assign(ye, Tt({}, oe(ye), { lazy: void 0 }));
}
async function Zm(ne, oe, ae, fe, ye, we, _e, xe, Oe, $e) {
  xe === void 0 && (xe = !1), Oe === void 0 && (Oe = !1);
  let Re, Ne, je, Be = (qe) => {
    let Ye, ot = new Promise((tt, it) => Ye = it);
    return je = () => Ye(), oe.signal.addEventListener("abort", je), Promise.race([qe({ request: oe, params: ae.params, context: $e }), ot]);
  };
  try {
    let qe = ae.route[ne];
    if (ae.route.lazy)
      if (qe)
        Ne = (await Promise.all([Be(qe), iq(ae.route, we, ye)]))[0];
      else if (await iq(ae.route, we, ye), qe = ae.route[ne], qe)
        Ne = await Be(qe);
      else if (ne === "action") {
        let Ye = new URL(oe.url), ot = Ye.pathname + Ye.search;
        throw Wa(405, { method: oe.method, pathname: ot, routeId: ae.route.id });
      } else
        return { type: Gr.data, data: void 0 };
    else if (qe)
      Ne = await Be(qe);
    else {
      let Ye = new URL(oe.url), ot = Ye.pathname + Ye.search;
      throw Wa(404, { pathname: ot });
    }
    Te(Ne !== void 0, "You defined " + (ne === "action" ? "an action" : "a loader") + " for route " + ('"' + ae.route.id + "\" but didn't return anything from your `" + ne + "` ") + "function. Please return a value or `null`.");
  } catch (qe) {
    Re = Gr.error, Ne = qe;
  } finally {
    je && oe.signal.removeEventListener("abort", je);
  }
  if (Nee(Ne)) {
    let qe = Ne.status;
    if (xee.has(qe)) {
      let tt = Ne.headers.get("Location");
      if (Te(tt, "Redirects returned/thrown from loaders/actions must have a Location header"), !hq.test(tt))
        tt = lk(new URL(oe.url), fe.slice(0, fe.indexOf(ae) + 1), _e, !0, tt);
      else if (!xe) {
        let it = new URL(oe.url), ht = tt.startsWith("//") ? new URL(it.protocol + tt) : new URL(tt), gt = Ru(ht.pathname, _e) != null;
        ht.origin === it.origin && gt && (tt = ht.pathname + ht.search + ht.hash);
      }
      if (xe)
        throw Ne.headers.set("Location", tt), Ne;
      return { type: Gr.redirect, status: qe, location: tt, revalidate: Ne.headers.get("X-Remix-Revalidate") !== null };
    }
    if (Oe)
      throw { type: Re || Gr.data, response: Ne };
    let Ye, ot = Ne.headers.get("Content-Type");
    return ot && /\bapplication\/json\b/.test(ot) ? Ye = await Ne.json() : Ye = await Ne.text(), Re === Gr.error ? { type: Re, error: new rh(qe, Ne.statusText, Ye), headers: Ne.headers } : { type: Gr.data, data: Ye, statusCode: Ne.status, headers: Ne.headers };
  }
  if (Re === Gr.error)
    return { type: Re, error: Ne };
  if (Dee(Ne)) {
    var ze, He;
    return { type: Gr.deferred, deferredData: Ne, statusCode: (ze = Ne.init) == null ? void 0 : ze.status, headers: ((He = Ne.init) == null ? void 0 : He.headers) && new Headers(Ne.init.headers) };
  }
  return { type: Gr.data, data: Ne };
}
function eh(ne, oe, ae, fe) {
  let ye = ne.createURL(Sq(oe)).toString(), we = { signal: ae };
  if (fe && Eu(fe.formMethod)) {
    let { formMethod: _e, formEncType: xe, formData: Oe } = fe;
    we.method = _e.toUpperCase(), we.body = xe === "application/x-www-form-urlencoded" ? bq(Oe) : Oe;
  }
  return new Request(ye, we);
}
function bq(ne) {
  let oe = new URLSearchParams();
  for (let [ae, fe] of ne.entries())
    oe.append(ae, fe instanceof File ? fe.name : fe);
  return oe;
}
function Pee(ne, oe, ae, fe, ye) {
  let we = {}, _e = null, xe, Oe = !1, $e = {};
  return ae.forEach((Re, Ne) => {
    let je = oe[Ne].route.id;
    if (Te(!dd(Re), "Cannot handle redirect results in processLoaderData"), th(Re)) {
      let Be = fd(ne, je), ze = Re.error;
      fe && (ze = Object.values(fe)[0], fe = void 0), _e = _e || {}, _e[Be.route.id] == null && (_e[Be.route.id] = ze), we[je] = void 0, Oe || (Oe = !0, xe = ih(Re.error) ? Re.error.status : 500), Re.headers && ($e[je] = Re.headers);
    } else
      lc(Re) ? (ye.set(je, Re.deferredData), we[je] = Re.deferredData.data) : we[je] = Re.data, Re.statusCode != null && Re.statusCode !== 200 && !Oe && (xe = Re.statusCode), Re.headers && ($e[je] = Re.headers);
  }), fe && (_e = fe, we[Object.keys(fe)[0]] = void 0), { loaderData: we, errors: _e, statusCode: xe || 200, loaderHeaders: $e };
}
function aq(ne, oe, ae, fe, ye, we, _e, xe) {
  let { loaderData: Oe, errors: $e } = Pee(oe, ae, fe, ye, xe);
  for (let Re = 0; Re < we.length; Re++) {
    let { key: Ne, match: je, controller: Be } = we[Re];
    Te(_e !== void 0 && _e[Re] !== void 0, "Did not find corresponding fetcher result");
    let ze = _e[Re];
    if (!(Be && Be.signal.aborted))
      if (th(ze)) {
        let He = fd(ne.matches, je == null ? void 0 : je.route.id);
        $e && $e[He.route.id] || ($e = Tt({}, $e, { [He.route.id]: ze.error })), ne.fetchers.delete(Ne);
      } else if (dd(ze))
        Te(!1, "Unhandled fetcher revalidation redirect");
      else if (lc(ze))
        Te(!1, "Unhandled fetcher deferred data");
      else {
        let He = { state: "idle", data: ze.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        ne.fetchers.set(Ne, He);
      }
  }
  return { loaderData: Oe, errors: $e };
}
function oq(ne, oe, ae, fe) {
  let ye = Tt({}, oe);
  for (let we of ae) {
    let _e = we.route.id;
    if (oe.hasOwnProperty(_e) ? oe[_e] !== void 0 && (ye[_e] = oe[_e]) : ne[_e] !== void 0 && we.route.loader && (ye[_e] = ne[_e]), fe && fe.hasOwnProperty(_e))
      break;
  }
  return ye;
}
function fd(ne, oe) {
  return (oe ? ne.slice(0, ne.findIndex((ae) => ae.route.id === oe) + 1) : [...ne]).reverse().find((ae) => ae.route.hasErrorBoundary === !0) || ne[0];
}
function uq(ne) {
  let oe = ne.find((ae) => ae.index || !ae.path || ae.path === "/") || { id: "__shim-error-route__" };
  return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: oe }], route: oe };
}
function Wa(ne, oe) {
  let { pathname: ae, routeId: fe, method: ye, type: we } = oe === void 0 ? {} : oe, _e = "Unknown Server Error", xe = "Unknown @remix-run/router error";
  return ne === 400 ? (_e = "Bad Request", ye && ae && fe ? xe = "You made a " + ye + ' request to "' + ae + '" but ' + ('did not provide a `loader` for route "' + fe + '", ') + "so there is no way to handle the request." : we === "defer-action" && (xe = "defer() is not supported in actions")) : ne === 403 ? (_e = "Forbidden", xe = 'Route "' + fe + '" does not match URL "' + ae + '"') : ne === 404 ? (_e = "Not Found", xe = 'No route matches URL "' + ae + '"') : ne === 405 && (_e = "Method Not Allowed", ye && ae && fe ? xe = "You made a " + ye.toUpperCase() + ' request to "' + ae + '" but ' + ('did not provide an `action` for route "' + fe + '", ') + "so there is no way to handle the request." : ye && (xe = 'Invalid request method "' + ye.toUpperCase() + '"')), new rh(ne || 500, _e, new Error(xe), !0);
}
function lq(ne) {
  for (let oe = ne.length - 1; oe >= 0; oe--) {
    let ae = ne[oe];
    if (dd(ae))
      return ae;
  }
}
function Sq(ne) {
  let oe = typeof ne == "string" ? Qi(ne) : ne;
  return Mo(Tt({}, oe, { hash: "" }));
}
function Mee(ne, oe) {
  return ne.pathname === oe.pathname && ne.search === oe.search && ne.hash !== oe.hash;
}
function lc(ne) {
  return ne.type === Gr.deferred;
}
function th(ne) {
  return ne.type === Gr.error;
}
function dd(ne) {
  return (ne && ne.type) === Gr.redirect;
}
function Dee(ne) {
  let oe = ne;
  return oe && typeof oe == "object" && typeof oe.data == "object" && typeof oe.subscribe == "function" && typeof oe.cancel == "function" && typeof oe.resolveData == "function";
}
function Nee(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.headers == "object" && typeof ne.body < "u";
}
function Lee(ne) {
  return wee.has(ne.toLowerCase());
}
function Eu(ne) {
  return See.has(ne.toLowerCase());
}
async function sq(ne, oe, ae, fe, ye, we) {
  for (let _e = 0; _e < ae.length; _e++) {
    let xe = ae[_e], Oe = oe[_e];
    if (!Oe)
      continue;
    let $e = ne.find((Ne) => Ne.route.id === Oe.route.id), Re = $e != null && !gq($e, Oe) && (we && we[Oe.route.id]) !== void 0;
    if (lc(xe) && (ye || Re)) {
      let Ne = fe[_e];
      Te(Ne, "Expected an AbortSignal for revalidating fetcher deferred result"), await _q(xe, Ne, ye).then((je) => {
        je && (ae[_e] = je || ae[_e]);
      });
    }
  }
}
async function _q(ne, oe, ae) {
  if (ae === void 0 && (ae = !1), !await ne.deferredData.resolveData(oe)) {
    if (ae)
      try {
        return { type: Gr.data, data: ne.deferredData.unwrappedData };
      } catch (fe) {
        return { type: Gr.error, error: fe };
      }
    return { type: Gr.data, data: ne.deferredData.data };
  }
}
function dk(ne) {
  return new URLSearchParams(ne).getAll("index").some((oe) => oe === "");
}
function cq(ne, oe) {
  let { route: ae, pathname: fe, params: ye } = ne;
  return { id: ae.id, pathname: fe, params: ye, data: oe[ae.id], handle: ae.handle };
}
function sk(ne, oe) {
  let ae = typeof oe == "string" ? Qi(oe).search : oe.search;
  if (ne[ne.length - 1].route.index && dk(ae || ""))
    return ne[ne.length - 1];
  let fe = nh(ne);
  return fe[fe.length - 1];
}
var pr, Gr, tee, iee, aee, oee, uee, lee, see, Zz, ha, yee, gee, bee, rh, mq, See, _ee, wee, xee, Eee, ok, Cee, eq, hq, yq, Ree, Oee, A0 = Y(() => {
  (function(ne) {
    ne.Pop = "POP", ne.Push = "PUSH", ne.Replace = "REPLACE";
  })(pr || (pr = {})), function(ne) {
    ne.data = "data", ne.deferred = "deferred", ne.redirect = "redirect", ne.error = "error";
  }(Gr || (Gr = {})), tee = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]), iee = /^:\w+$/, aee = 3, oee = 2, uee = 1, lee = 10, see = -2, Zz = (ne) => ne === "*", ha = (ne) => ne.join("/").replace(/\/\/+/g, "/"), yee = (ne) => ne.replace(/\/+$/, "").replace(/^\/*/, "/"), gee = (ne) => !ne || ne === "?" ? "" : ne.startsWith("?") ? ne : "?" + ne, bee = (ne) => !ne || ne === "#" ? "" : ne.startsWith("#") ? ne : "#" + ne, rh = class {
    constructor(ne, oe, ae, fe) {
      fe === void 0 && (fe = !1), this.status = ne, this.statusText = oe || "", this.internal = fe, ae instanceof Error ? (this.data = ae.toString(), this.error = ae) : this.data = ae;
    }
  }, mq = ["post", "put", "patch", "delete"], See = new Set(mq), _ee = ["get", ...mq], wee = new Set(_ee), xee = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Eee = /* @__PURE__ */ new Set([307, 308]), ok = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Cee = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, eq = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, hq = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, yq = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ree = !yq, Oee = (ne) => ({ hasErrorBoundary: !!ne.hasErrorBoundary });
});
function ah() {
  return ah = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, ah.apply(this, arguments);
}
function hk(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe;
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useHref() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: fe, navigator: ye } = se.useContext(ya), { hash: we, pathname: _e, search: xe } = Fl(ne, { relative: ae }), Oe = _e;
  return fe !== "/" && (Oe = _e === "/" ? fe : ha([fe, _e])), ye.createHref({ pathname: Oe, search: xe, hash: we });
}
function md() {
  return se.useContext(vd) != null;
}
function Ya() {
  return md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useLocation() may be used only in the context of a <Router> component.") : Te(!1)), se.useContext(vd).location;
}
function Rq(ne) {
  se.useContext(ya).static || se.useLayoutEffect(ne);
}
function Ou() {
  return se.useContext(Ul) != null ? Kee() : Iee();
}
function Iee() {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useNavigate() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: ne, navigator: oe } = se.useContext(ya), { matches: ae } = se.useContext(ga), { pathname: fe } = Ya(), ye = JSON.stringify(nh(ae).map((_e) => _e.pathnameBase)), we = se.useRef(!1);
  return Rq(() => {
    we.current = !0;
  }), se.useCallback(function(_e, xe) {
    if (xe === void 0 && (xe = {}), process.env.NODE_ENV !== "production" && ln(we.current, Cq), !we.current)
      return;
    if (typeof _e == "number") {
      oe.go(_e);
      return;
    }
    let Oe = k0(_e, JSON.parse(ye), fe, xe.relative === "path");
    ne !== "/" && (Oe.pathname = Oe.pathname === "/" ? ne : ha([ne, Oe.pathname])), (xe.replace ? oe.replace : oe.push)(Oe, xe.state, xe);
  }, [ne, oe, ye, fe]);
}
function Oq(ne) {
  let oe = se.useContext(ga).outlet;
  return oe && se.createElement(Bee.Provider, { value: ne }, oe);
}
function Tu() {
  let { matches: ne } = se.useContext(ga), oe = ne[ne.length - 1];
  return oe ? oe.params : {};
}
function Fl(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { matches: fe } = se.useContext(ga), { pathname: ye } = Ya(), we = JSON.stringify(nh(fe).map((_e) => _e.pathnameBase));
  return se.useMemo(() => k0(ne, JSON.parse(we), ye, ae === "path"), [ne, we, ye, ae]);
}
function Hee(ne, oe, ae) {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useRoutes() may be used only in the context of a <Router> component.") : Te(!1));
  let { navigator: fe } = se.useContext(ya), { matches: ye } = se.useContext(ga), we = ye[ye.length - 1], _e = we ? we.params : {}, xe = we ? we.pathname : "/", Oe = we ? we.pathnameBase : "/", $e = we && we.route;
  if (process.env.NODE_ENV !== "production") {
    let Ye = $e && $e.path || "";
    Xee(xe, !$e || Ye.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + xe + '" (under <Route path="' + Ye + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + Ye + '"> to <Route ') + ('path="' + (Ye === "/" ? "*" : Ye + "/*") + '">.'));
  }
  let Re = Ya(), Ne;
  if (oe) {
    var je;
    let Ye = typeof oe == "string" ? Qi(oe) : oe;
    Oe === "/" || (je = Ye.pathname) != null && je.startsWith(Oe) || (process.env.NODE_ENV !== "production" ? Te(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + Oe + '" ') + ('but pathname "' + Ye.pathname + '" was given in the `location` prop.')) : Te(!1)), Ne = Ye;
  } else
    Ne = Re;
  let Be = Ne.pathname || "/", ze = Oe === "/" ? Be : Be.slice(Oe.length) || "/", He = Cu(ne, { pathname: ze });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && ln($e || He != null, 'No routes matched location "' + Ne.pathname + Ne.search + Ne.hash + '" '), process.env.NODE_ENV !== "production" && ln(He == null || He[He.length - 1].route.element !== void 0 || He[He.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + Ne.pathname + Ne.search + Ne.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let qe = Yee(He && He.map((Ye) => Object.assign({}, Ye, { params: Object.assign({}, _e, Ye.params), pathname: ha([Oe, fe.encodeLocation ? fe.encodeLocation(Ye.pathname).pathname : Ye.pathname]), pathnameBase: Ye.pathnameBase === "/" ? Oe : ha([Oe, fe.encodeLocation ? fe.encodeLocation(Ye.pathnameBase).pathname : Ye.pathnameBase]) })), ye, ae);
  return oe && qe ? se.createElement(vd.Provider, { value: { location: ah({ pathname: "/", search: "", hash: "", state: null, key: "default" }, Ne), navigationType: pr.Pop } }, qe) : qe;
}
function Vee() {
  let ne = P0(), oe = ih(ne) ? ne.status + " " + ne.statusText : ne instanceof Error ? ne.message : JSON.stringify(ne), ae = ne instanceof Error ? ne.stack : null, fe = "rgba(200,200,200, 0.5)", ye = { padding: "0.5rem", backgroundColor: fe }, we = { padding: "2px 4px", backgroundColor: fe }, _e = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", ne), _e = se.createElement(se.Fragment, null, se.createElement("p", null, " Hey developer "), se.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", se.createElement("code", { style: we }, "ErrorBoundary"), " or", " ", se.createElement("code", { style: we }, "errorElement"), " prop on your route."))), se.createElement(se.Fragment, null, se.createElement("h2", null, "Unexpected Application Error!"), se.createElement("h3", { style: { fontStyle: "italic" } }, oe), ae ? se.createElement("pre", { style: ye }, ae) : null, _e);
}
function Wee(ne) {
  let { routeContext: oe, match: ae, children: fe } = ne, ye = se.useContext(Ul);
  return ye && ye.static && ye.staticContext && (ae.route.errorElement || ae.route.ErrorBoundary) && (ye.staticContext._deepestRenderedBoundaryId = ae.route.id), se.createElement(ga.Provider, { value: oe }, fe);
}
function Yee(ne, oe, ae) {
  var fe;
  if (oe === void 0 && (oe = []), ae === void 0 && (ae = null), ne == null) {
    var ye;
    if ((ye = ae) != null && ye.errors)
      ne = ae.matches;
    else
      return null;
  }
  let we = ne, _e = (fe = ae) == null ? void 0 : fe.errors;
  if (_e != null) {
    let xe = we.findIndex((Oe) => Oe.route.id && (_e == null ? void 0 : _e[Oe.route.id]));
    xe >= 0 || (process.env.NODE_ENV !== "production" ? Te(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(_e).join(",")) : Te(!1)), we = we.slice(0, Math.min(we.length, xe + 1));
  }
  return we.reduceRight((xe, Oe, $e) => {
    let Re = Oe.route.id ? _e == null ? void 0 : _e[Oe.route.id] : null, Ne = null;
    ae && (Ne = Oe.route.errorElement || $ee);
    let je = oe.concat(we.slice(0, $e + 1)), Be = () => {
      let ze;
      return Re ? ze = Ne : Oe.route.element ? ze = Oe.route.element : ze = xe, se.createElement(Wee, { match: Oe, routeContext: { outlet: xe, matches: je }, children: ze });
    };
    return ae && (Oe.route.ErrorBoundary || Oe.route.errorElement || $e === 0) ? se.createElement(pk, { location: ae.location, revalidation: ae.revalidation, component: Ne, error: Re, children: Be(), routeContext: { outlet: null, matches: je } }) : Be();
  }, null);
}
function yk(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Gee(ne) {
  let oe = se.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function gk(ne) {
  let oe = se.useContext(sc);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function Qee(ne) {
  let oe = se.useContext(ga);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function bk(ne) {
  let oe = Qee(ne), ae = oe.matches[oe.matches.length - 1];
  return ae.route.id || (process.env.NODE_ENV !== "production" ? Te(!1, ne + ' can only be used on routes that contain a unique "id"') : Te(!1)), ae.route.id;
}
function Sk() {
  return bk(jl.UseRouteId);
}
function P0() {
  var ne;
  let oe = se.useContext(mk), ae = gk(jl.UseRouteError), fe = bk(jl.UseRouteError);
  return oe || ((ne = ae.errors) == null ? void 0 : ne[fe]);
}
function Kee() {
  let { router: ne } = Gee(vk.UseNavigateStable), oe = bk(jl.UseNavigateStable), ae = se.useRef(!1);
  return Rq(() => {
    ae.current = !0;
  }), se.useCallback(function(fe, ye) {
    ye === void 0 && (ye = {}), process.env.NODE_ENV !== "production" && ln(ae.current, Cq), ae.current && (typeof fe == "number" ? ne.navigate(fe) : ne.navigate(fe, ah({ fromRouteId: oe }, ye)));
  }, [ne, oe]);
}
function Xee(ne, oe, ae) {
  !oe && !wq[ne] && (wq[ne] = !0, process.env.NODE_ENV !== "production" && ln(!1, ae));
}
function xk(ne) {
  let { fallbackElement: oe, router: ae } = ne, [fe, ye] = se.useState(ae.state);
  se.useLayoutEffect(() => ae.subscribe(ye), [ae, ye]);
  let we = se.useMemo(() => ({ createHref: ae.createHref, encodeLocation: ae.encodeLocation, go: (Oe) => ae.navigate(Oe), push: (Oe, $e, Re) => ae.navigate(Oe, { state: $e, preventScrollReset: Re == null ? void 0 : Re.preventScrollReset }), replace: (Oe, $e, Re) => ae.navigate(Oe, { replace: !0, state: $e, preventScrollReset: Re == null ? void 0 : Re.preventScrollReset }) }), [ae]), _e = ae.basename || "/", xe = se.useMemo(() => ({ router: ae, navigator: we, static: !1, basename: _e }), [ae, we, _e]);
  return se.createElement(se.Fragment, null, se.createElement(Ul.Provider, { value: xe }, se.createElement(sc.Provider, { value: fe }, se.createElement(M0, { basename: ae.basename, location: ae.state.location, navigationType: ae.state.historyAction, navigator: we }, ae.state.initialized ? se.createElement(Jee, { routes: ae.routes, state: fe }) : oe))), null);
}
function Jee(ne) {
  let { routes: oe, state: ae } = ne;
  return Hee(oe, void 0, ae);
}
function cc(ne) {
  return Oq(ne.context);
}
function Ga(ne) {
  process.env.NODE_ENV !== "production" ? Te(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : Te(!1);
}
function M0(ne) {
  let { basename: oe = "/", children: ae = null, location: fe, navigationType: ye = pr.Pop, navigator: we, static: _e = !1 } = ne;
  md() && (process.env.NODE_ENV !== "production" ? Te(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Te(!1));
  let xe = oe.replace(/^\/*/, "/"), Oe = se.useMemo(() => ({ basename: xe, navigator: we, static: _e }), [xe, we, _e]);
  typeof fe == "string" && (fe = Qi(fe));
  let { pathname: $e = "/", search: Re = "", hash: Ne = "", state: je = null, key: Be = "default" } = fe, ze = se.useMemo(() => {
    let He = Ru($e, xe);
    return He == null ? null : { location: { pathname: He, search: Re, hash: Ne, state: je, key: Be }, navigationType: ye };
  }, [xe, $e, Re, Ne, je, Be, ye]);
  return process.env.NODE_ENV !== "production" && ln(ze != null, '<Router basename="' + xe + '"> is not able to match the URL ' + ('"' + $e + Re + Ne + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), ze == null ? null : se.createElement(ya.Provider, { value: Oe }, se.createElement(vd.Provider, { children: ae, value: ze }));
}
function pd(ne, oe) {
  oe === void 0 && (oe = []);
  let ae = [];
  return se.Children.forEach(ne, (fe, ye) => {
    if (!se.isValidElement(fe))
      return;
    let we = [...oe, ye];
    if (fe.type === se.Fragment) {
      ae.push.apply(ae, pd(fe.props.children, we));
      return;
    }
    fe.type !== Ga && (process.env.NODE_ENV !== "production" ? Te(!1, "[" + (typeof fe.type == "string" ? fe.type : fe.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : Te(!1)), !fe.props.index || !fe.props.children || (process.env.NODE_ENV !== "production" ? Te(!1, "An index route cannot have child routes.") : Te(!1));
    let _e = { id: fe.props.id || we.join("-"), caseSensitive: fe.props.caseSensitive, element: fe.props.element, Component: fe.props.Component, index: fe.props.index, path: fe.props.path, loader: fe.props.loader, action: fe.props.action, errorElement: fe.props.errorElement, ErrorBoundary: fe.props.ErrorBoundary, hasErrorBoundary: fe.props.ErrorBoundary != null || fe.props.errorElement != null, shouldRevalidate: fe.props.shouldRevalidate, handle: fe.props.handle, lazy: fe.props.lazy };
    fe.props.children && (_e.children = pd(fe.props.children, we)), ae.push(_e);
  }), ae;
}
function Tq(ne) {
  let oe = { hasErrorBoundary: ne.ErrorBoundary != null || ne.errorElement != null };
  return ne.Component && (process.env.NODE_ENV !== "production" && ne.element && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(oe, { element: se.createElement(ne.Component), Component: void 0 })), ne.ErrorBoundary && (process.env.NODE_ENV !== "production" && ne.errorElement && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(oe, { errorElement: se.createElement(ne.ErrorBoundary), ErrorBoundary: void 0 })), oe;
}
function Ek(ne, oe) {
  return fk({ basename: oe == null ? void 0 : oe.basename, future: ah({}, oe == null ? void 0 : oe.future, { v7_prependBasename: !0 }), history: fq({ initialEntries: oe == null ? void 0 : oe.initialEntries, initialIndex: oe == null ? void 0 : oe.initialIndex }), hydrationData: oe == null ? void 0 : oe.hydrationData, routes: ne, mapRouteProperties: Tq }).initialize();
}
var se, Ul, sc, qee, ya, vd, ga, mk, Cq, Bee, $ee, pk, vk, jl, wq, xq, Ck = Y(() => {
  se = le(ir()), A0(), A0(), Ul = se.createContext(null), process.env.NODE_ENV !== "production" && (Ul.displayName = "DataRouter"), sc = se.createContext(null), process.env.NODE_ENV !== "production" && (sc.displayName = "DataRouterState"), qee = se.createContext(null), process.env.NODE_ENV !== "production" && (qee.displayName = "Await"), ya = se.createContext(null), process.env.NODE_ENV !== "production" && (ya.displayName = "Navigation"), vd = se.createContext(null), process.env.NODE_ENV !== "production" && (vd.displayName = "Location"), ga = se.createContext({ outlet: null, matches: [] }), process.env.NODE_ENV !== "production" && (ga.displayName = "Route"), mk = se.createContext(null), process.env.NODE_ENV !== "production" && (mk.displayName = "RouteError"), Cq = "You should call navigate() in a React.useEffect(), not when your component is first rendered.", Bee = se.createContext(null), $ee = se.createElement(Vee, null), pk = class extends se.Component {
    constructor(ne) {
      super(ne), this.state = { location: ne.location, revalidation: ne.revalidation, error: ne.error };
    }
    static getDerivedStateFromError(ne) {
      return { error: ne };
    }
    static getDerivedStateFromProps(ne, oe) {
      return oe.location !== ne.location || oe.revalidation !== "idle" && ne.revalidation === "idle" ? { error: ne.error, location: ne.location, revalidation: ne.revalidation } : { error: ne.error || oe.error, location: oe.location, revalidation: ne.revalidation || oe.revalidation };
    }
    componentDidCatch(ne, oe) {
      console.error("React Router caught the following error during render", ne, oe);
    }
    render() {
      return this.state.error ? se.createElement(ga.Provider, { value: this.props.routeContext }, se.createElement(mk.Provider, { value: this.state.error, children: this.props.component })) : this.props.children;
    }
  }, function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate";
  }(vk || (vk = {})), function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseLoaderData = "useLoaderData", ne.UseActionData = "useActionData", ne.UseRouteError = "useRouteError", ne.UseNavigation = "useNavigation", ne.UseRouteLoaderData = "useRouteLoaderData", ne.UseMatches = "useMatches", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate", ne.UseRouteId = "useRouteId";
  }(jl || (jl = {})), wq = {}, function(ne) {
    ne[ne.pending = 0] = "pending", ne[ne.success = 1] = "success", ne[ne.error = 2] = "error";
  }(xq || (xq = {})), new Promise(() => {
  });
});
function zl() {
  return zl = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, zl.apply(this, arguments);
}
function Tk(ne, oe) {
  if (ne == null)
    return {};
  var ae = {}, fe = Object.keys(ne), ye, we;
  for (we = 0; we < fe.length; we++)
    ye = fe[we], !(oe.indexOf(ye) >= 0) && (ae[ye] = ne[ye]);
  return ae;
}
function j0(ne) {
  return ne != null && typeof ne.tagName == "string";
}
function ete(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "button";
}
function tte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "form";
}
function rte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "input";
}
function nte(ne) {
  return !!(ne.metaKey || ne.altKey || ne.ctrlKey || ne.shiftKey);
}
function ite(ne, oe) {
  return ne.button === 0 && (!oe || oe === "_self") && !nte(ne);
}
function ate(ne, oe, ae) {
  let fe, ye = null, we, _e;
  if (tte(ne)) {
    let xe = oe.submissionTrigger;
    if (oe.action)
      ye = oe.action;
    else {
      let Oe = ne.getAttribute("action");
      ye = Oe ? Ru(Oe, ae) : null;
    }
    fe = oe.method || ne.getAttribute("method") || N0, we = oe.encType || ne.getAttribute("enctype") || Rk, _e = new FormData(ne), xe && xe.name && _e.append(xe.name, xe.value);
  } else if (ete(ne) || rte(ne) && (ne.type === "submit" || ne.type === "image")) {
    let xe = ne.form;
    if (xe == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    if (oe.action)
      ye = oe.action;
    else {
      let Oe = ne.getAttribute("formaction") || xe.getAttribute("action");
      ye = Oe ? Ru(Oe, ae) : null;
    }
    fe = oe.method || ne.getAttribute("formmethod") || xe.getAttribute("method") || N0, we = oe.encType || ne.getAttribute("formenctype") || xe.getAttribute("enctype") || Rk, _e = new FormData(xe), ne.name && _e.append(ne.name, ne.value);
  } else {
    if (j0(ne))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    if (fe = oe.method || N0, ye = oe.action || null, we = oe.encType || Rk, ne instanceof FormData)
      _e = ne;
    else if (_e = new FormData(), ne instanceof URLSearchParams)
      for (let [xe, Oe] of ne)
        _e.append(xe, Oe);
    else if (ne != null)
      for (let xe of Object.keys(ne))
        _e.append(xe, ne[xe]);
  }
  return { action: ye, method: fe.toLowerCase(), encType: we, formData: _e };
}
function Mq(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Dq(ne) {
  let oe = ft.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, Mq(ne)) : Te(!1)), oe;
}
function hte(ne, oe) {
  let { target: ae, replace: fe, state: ye, preventScrollReset: we, relative: _e } = oe === void 0 ? {} : oe, xe = Ou(), Oe = Ya(), $e = Fl(ne, { relative: _e });
  return ft.useCallback((Re) => {
    if (ite(Re, ae)) {
      Re.preventDefault();
      let Ne = fe !== void 0 ? fe : Mo(Oe) === Mo($e);
      xe(ne, { replace: Ne, state: ye, preventScrollReset: we, relative: _e });
    }
  }, [Oe, xe, $e, fe, ye, ae, ne, we, _e]);
}
function yte(ne, oe) {
  let { router: ae } = Dq(L0.UseSubmitImpl), { basename: fe } = ft.useContext(ya), ye = Sk();
  return ft.useCallback(function(we, _e) {
    if (_e === void 0 && (_e = {}), typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let { action: xe, method: Oe, encType: $e, formData: Re } = ate(we, _e, fe), Ne = { preventScrollReset: _e.preventScrollReset, formData: Re, formMethod: Oe, formEncType: $e };
    ne ? (oe == null && (process.env.NODE_ENV !== "production" ? Te(!1, "No routeId available for useFetcher()") : Te(!1)), ae.fetch(ne, oe, xe, Ne)) : ae.navigate(xe, zl({}, Ne, { replace: _e.replace, fromRouteId: ye }));
  }, [ae, fe, ne, oe, ye]);
}
function gte(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { basename: fe } = ft.useContext(ya), ye = ft.useContext(ga);
  ye || (process.env.NODE_ENV !== "production" ? Te(!1, "useFormAction must be used inside a RouteContext") : Te(!1));
  let [we] = ye.matches.slice(-1), _e = zl({}, Fl(ne || ".", { relative: ae })), xe = Ya();
  if (ne == null && (_e.search = xe.search, _e.hash = xe.hash, we.route.index)) {
    let Oe = new URLSearchParams(_e.search);
    Oe.delete("index"), _e.search = Oe.toString() ? "?" + Oe.toString() : "";
  }
  return (!ne || ne === ".") && we.route.index && (_e.search = _e.search ? _e.search.replace(/^\?/, "?index&") : "?index"), fe !== "/" && (_e.pathname = _e.pathname === "/" ? fe : ha([fe, _e.pathname])), Mo(_e);
}
var ft, N0, Rk, ote, ute, lte, cte, fte, Aq, dte, pte, Pq, L0, Ok, Do = Y(() => {
  ft = le(ir()), Ck(), Ck(), A0(), N0 = "get", Rk = "application/x-www-form-urlencoded", ote = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], ute = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], lte = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"], process.env.NODE_ENV, cte = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", fte = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Aq = ft.forwardRef(function(ne, oe) {
    let { onClick: ae, relative: fe, reloadDocument: ye, replace: we, state: _e, target: xe, to: Oe, preventScrollReset: $e } = ne, Re = Tk(ne, ote), { basename: Ne } = ft.useContext(ya), je, Be = !1;
    if (typeof Oe == "string" && fte.test(Oe) && (je = Oe, cte))
      try {
        let Ye = new URL(window.location.href), ot = Oe.startsWith("//") ? new URL(Ye.protocol + Oe) : new URL(Oe), tt = Ru(ot.pathname, Ne);
        ot.origin === Ye.origin && tt != null ? Oe = tt + ot.search + ot.hash : Be = !0;
      } catch {
        process.env.NODE_ENV !== "production" && ln(!1, '<Link to="' + Oe + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
      }
    let ze = hk(Oe, { relative: fe }), He = hte(Oe, { replace: we, state: _e, target: xe, preventScrollReset: $e, relative: fe });
    function qe(Ye) {
      ae && ae(Ye), Ye.defaultPrevented || He(Ye);
    }
    return ft.createElement("a", zl({}, Re, { href: je || ze, onClick: Be || ye ? ae : qe, ref: oe, target: xe }));
  }), process.env.NODE_ENV !== "production" && (Aq.displayName = "Link"), dte = ft.forwardRef(function(ne, oe) {
    let { "aria-current": ae = "page", caseSensitive: fe = !1, className: ye = "", end: we = !1, style: _e, to: xe, children: Oe } = ne, $e = Tk(ne, ute), Re = Fl(xe, { relative: $e.relative }), Ne = Ya(), je = ft.useContext(sc), { navigator: Be } = ft.useContext(ya), ze = Be.encodeLocation ? Be.encodeLocation(Re).pathname : Re.pathname, He = Ne.pathname, qe = je && je.navigation && je.navigation.location ? je.navigation.location.pathname : null;
    fe || (He = He.toLowerCase(), qe = qe ? qe.toLowerCase() : null, ze = ze.toLowerCase());
    let Ye = He === ze || !we && He.startsWith(ze) && He.charAt(ze.length) === "/", ot = qe != null && (qe === ze || !we && qe.startsWith(ze) && qe.charAt(ze.length) === "/"), tt = Ye ? ae : void 0, it;
    typeof ye == "function" ? it = ye({ isActive: Ye, isPending: ot }) : it = [ye, Ye ? "active" : null, ot ? "pending" : null].filter(Boolean).join(" ");
    let ht = typeof _e == "function" ? _e({ isActive: Ye, isPending: ot }) : _e;
    return ft.createElement(Aq, zl({}, $e, { "aria-current": tt, className: it, ref: oe, style: ht, to: xe }), typeof Oe == "function" ? Oe({ isActive: Ye, isPending: ot }) : Oe);
  }), process.env.NODE_ENV !== "production" && (dte.displayName = "NavLink"), pte = ft.forwardRef((ne, oe) => ft.createElement(Pq, zl({}, ne, { ref: oe }))), process.env.NODE_ENV !== "production" && (pte.displayName = "Form"), Pq = ft.forwardRef((ne, oe) => {
    let { reloadDocument: ae, replace: fe, method: ye = N0, action: we, onSubmit: _e, fetcherKey: xe, routeId: Oe, relative: $e, preventScrollReset: Re } = ne, Ne = Tk(ne, lte), je = yte(xe, Oe), Be = ye.toLowerCase() === "get" ? "get" : "post", ze = gte(we, { relative: $e });
    return ft.createElement("form", zl({ ref: oe, method: Be, action: ze, onSubmit: ae ? _e : (He) => {
      if (_e && _e(He), He.defaultPrevented)
        return;
      He.preventDefault();
      let qe = He.nativeEvent.submitter, Ye = (qe == null ? void 0 : qe.getAttribute("formmethod")) || ye;
      je(qe || He.currentTarget, { method: Ye, replace: fe, relative: $e, preventScrollReset: Re });
    } }, Ne));
  }), process.env.NODE_ENV !== "production" && (Pq.displayName = "FormImpl"), process.env.NODE_ENV, function(ne) {
    ne.UseScrollRestoration = "useScrollRestoration", ne.UseSubmitImpl = "useSubmitImpl", ne.UseFetcher = "useFetcher";
  }(L0 || (L0 = {})), function(ne) {
    ne.UseFetchers = "useFetchers", ne.UseScrollRestoration = "useScrollRestoration";
  }(Ok || (Ok = {}));
});
function sn({ to: ne, className: oe, type: ae, onClick: fe, ...ye }) {
  let we = Ou(), _e = Fl(ne), xe = Ya(), Oe = _e.pathname, $e = xe.pathname, Re = $e === Oe || $e.startsWith(Oe) && $e.charAt(Oe.length) === "/";
  return (0, Nq.jsx)("button", { type: ae || "button", className: typeof oe == "function" ? oe({ isActive: Re }) : oe, onClick: (Ne) => {
    we(ne), fe == null || fe(Ne);
  }, ...ye });
}
var Nq, ql = Y(() => {
  Do(), Nq = le(ke(), 1);
}), Lq = {};
Uj(Lq, { DevToolsProvider: () => _te, useDevToolsContext: () => zt });
var Qa, jq, kk, _te, zt, ai = Y(() => {
  Qa = le(ir(), 1), jq = le(ke(), 1), kk = (0, Qa.createContext)(null), _te = ({ children: ne, value: oe }) => {
    if ((0, Qa.useContext)(kk))
      throw new Error("DevToolsProvider can only be used once");
    let [ae, fe] = (0, Qa.useState)([]);
    (0, Qa.useEffect)(() => {
      let _e = oe.write$.subscribe((xe) => {
        fe((Oe) => [...Oe, xe]);
      });
      return () => _e.unsubscribe();
    }, [oe.write$]);
    let [ye, we] = (0, Qa.useState)([]);
    return (0, Qa.useEffect)(() => {
      let _e = oe.storedBlockLogs$.subscribe(({ logs: xe }) => {
        we((Oe) => [...Oe, ...xe]);
      });
      return () => _e.unsubscribe();
    }, [oe.storedBlockLogs$]), (0, jq.jsx)(kk.Provider, { value: { ...oe, writes: ae, storedLogs: ye }, children: ne });
  }, zt = () => {
    let ne = (0, Qa.useContext)(kk);
    if (!ne)
      throw new Error("Must be used within a DevToolsProvider");
    return ne;
  };
});
function Uq() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Ki.jsxs)(Ki.Fragment, { children: [(0, Ki.jsxs)("div", { className: "flex-none bg-slate-900 text-white/60 font-medium", children: [(0, Ki.jsx)(sn, { to: "/", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Summary" }), (0, Ki.jsx)(sn, { to: "/actions", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Actions" }), (0, Ki.jsx)(sn, { to: "/events", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Store log" }), oe ? (0, Ki.jsx)(sn, { to: "/tables", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Tables" }) : null, ne ? (0, Ki.jsx)(sn, { to: "/components", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Components" }) : null] }), (0, Ki.jsx)("div", { className: "flex-1 overflow-auto", children: (0, Ki.jsx)(cc, {}) })] });
}
var Ki, Fq = Y(() => {
  uc(), Do(), ql(), ai(), Ki = le(ke(), 1);
});
function U0({ error: ne }) {
  return (0, zq.jsx)("div", { className: "font-mono text-xs whitespace-pre overflow-auto bg-red-900/50 text-white p-4 rounded", children: ne instanceof Error ? ne.stack : String(ne) });
}
var zq, Ak = Y(() => {
  zq = le(ke(), 1);
});
function qq() {
  let ne = P0();
  return (0, hd.jsxs)("div", { className: "p-6 space-y-6", children: [(0, hd.jsxs)("p", { children: ["Whoops, something broke! Please", " ", (0, hd.jsx)("a", { href: `https://github.com/latticexyz/mud/issues/new?${new URLSearchParams({ body: `
**Steps to reproduce**

1. Go to 
2. Click on 
3. Scroll down to 
4. See error

**Expected behavior**

A clear and concise description of what you expected to happen.

**Error**
\`\`\`
${ne instanceof Error ? ne.stack : String(ne)}
\`\`\`
` })}`, target: "_blank", className: "text-white underline", children: "report the issue" }), " ", "so we can look into it."] }), (0, hd.jsx)(U0, { error: ne })] });
}
var hd, Iq = Y(() => {
  Do(), Ak(), hd = le(ke(), 1);
});
function Bq({ type: ne }) {
  switch (ne) {
    case "Store_SetRecord":
      return (0, F0.jsx)("span", { className: "text-green-500 font-bold", children: "=" });
    case "Store_SpliceStaticData":
    case "Store_SpliceDynamicData":
      return (0, F0.jsx)("span", { className: "text-cyan-500 font-bold", children: "+" });
    case "Store_DeleteRecord":
      return (0, F0.jsx)("span", { className: "text-red-500 font-bold", children: "-" });
    default:
      return u$4(ne, `Unexpected event type: ${ne}`);
  }
}
var F0, Hq = Y(() => {
  F0 = le(ke(), 1);
});
function z0({ logs: ne }) {
  return (0, cn.jsxs)("table", { className: "w-full table-fixed -mx-1", children: [(0, cn.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-amber-200/80 text-left", children: (0, cn.jsxs)("tr", { children: [(0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "block" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "table" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "key" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-[1em]" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs", children: "value" })] }) }), (0, cn.jsx)("tbody", { className: "font-mono text-xs", children: ne.map((oe) => {
    var we;
    let ae = _$4(oe.args.tableId), { namespace: fe, name: ye } = ae;
    return (0, cn.jsxs)("tr", { className: "hover:bg-blue-800", children: [(0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis text-white/40", children: (we = oe.blockNumber) == null ? void 0 : we.toString() }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: i$6(ae) }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: oe.args.keyTuple.join(",") }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap", children: (0, cn.jsx)(Bq, { type: oe.eventName }) }), (0, cn.jsxs)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: [oe.eventName === "Store_SetRecord" ? JSON.stringify({ staticData: oe.args.staticData, encodedLengths: oe.args.encodedLengths, dynamicData: oe.args.dynamicData }) : null, oe.eventName === "Store_SpliceStaticData" ? JSON.stringify({ start: oe.args.start, data: oe.args.data }) : null, oe.eventName === "Store_SpliceDynamicData" ? JSON.stringify({ start: oe.args.start, deleteCount: oe.args.deleteCount, encodedLengths: oe.args.encodedLengths, data: oe.args.data }) : null] })] }, oe.blockHash != null && oe.logIndex != null ? `${oe.blockHash}:${oe.logIndex}` : `${fe}:${ye}:${oe.args.keyTuple.join(",")}`);
  }) })] });
}
var cn, Pk = Y(() => {
  Hq(), cn = le(ke(), 1);
});
function Vq() {
  let { storedLogs: ne } = zt(), oe = (0, yd.useRef)(null), ae = (0, yd.useRef)(!1), fe = (0, yd.useRef)("auto");
  return (0, yd.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, Mk.jsx)("div", { ref: oe, className: "px-2 pb-1", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: (0, Mk.jsx)(z0, { logs: ne }) });
}
var yd, Mk, $q = Y(() => {
  yd = le(ir(), 1), ai(), Pk(), Mk = le(ke(), 1);
}), Dk = M((ne, oe) => {
  oe.exports = function ae(fe, ye) {
    if (fe === ye)
      return !0;
    if (fe && ye && typeof fe == "object" && typeof ye == "object") {
      if (fe.constructor !== ye.constructor)
        return !1;
      var we, _e, xe;
      if (Array.isArray(fe)) {
        if (we = fe.length, we != ye.length)
          return !1;
        for (_e = we; _e-- !== 0; )
          if (!ae(fe[_e], ye[_e]))
            return !1;
        return !0;
      }
      if (fe.constructor === RegExp)
        return fe.source === ye.source && fe.flags === ye.flags;
      if (fe.valueOf !== Object.prototype.valueOf)
        return fe.valueOf() === ye.valueOf();
      if (fe.toString !== Object.prototype.toString)
        return fe.toString() === ye.toString();
      if (xe = Object.keys(fe), we = xe.length, we !== Object.keys(ye).length)
        return !1;
      for (_e = we; _e-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(ye, xe[_e]))
          return !1;
      for (_e = we; _e-- !== 0; ) {
        var Oe = xe[_e];
        if (!ae(fe[Oe], ye[Oe]))
          return !1;
      }
      return !0;
    }
    return fe !== fe && ye !== ye;
  };
}), Mt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isFunction = void 0;
  function oe(ae) {
    return typeof ae == "function";
  }
  ne.isFunction = oe;
}), Il = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createErrorClass = void 0;
  function oe(ae) {
    var fe = function(we) {
      Error.call(we), we.stack = new Error().stack;
    }, ye = ae(fe);
    return ye.prototype = Object.create(Error.prototype), ye.prototype.constructor = ye, ye;
  }
  ne.createErrorClass = oe;
}), Nk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.UnsubscriptionError = void 0;
  var oe = Il();
  ne.UnsubscriptionError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.message = fe ? fe.length + ` errors occurred during unsubscription:
` + fe.map(function(ye, we) {
        return we + 1 + ") " + ye.toString();
      }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = fe;
    };
  });
}), ku = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.arrRemove = void 0;
  function oe(ae, fe) {
    if (ae) {
      var ye = ae.indexOf(fe);
      0 <= ye && ae.splice(ye, 1);
    }
  }
  ne.arrRemove = oe;
}), Oi = M((ne) => {
  var oe = ne && ne.__values || function(Re) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, je = Ne && Re[Ne], Be = 0;
    if (je)
      return je.call(Re);
    if (Re && typeof Re.length == "number")
      return { next: function() {
        return Re && Be >= Re.length && (Re = void 0), { value: Re && Re[Be++], done: !Re };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }, ae = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, fe = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isSubscription = ne.EMPTY_SUBSCRIPTION = ne.Subscription = void 0;
  var ye = Mt(), we = Nk(), _e = ku(), xe = function() {
    function Re(Ne) {
      this.initialTeardown = Ne, this.closed = !1, this._parentage = null, this._finalizers = null;
    }
    return Re.prototype.unsubscribe = function() {
      var Ne, je, Be, ze, He;
      if (!this.closed) {
        this.closed = !0;
        var qe = this._parentage;
        if (qe)
          if (this._parentage = null, Array.isArray(qe))
            try {
              for (var Ye = oe(qe), ot = Ye.next(); !ot.done; ot = Ye.next()) {
                var tt = ot.value;
                tt.remove(this);
              }
            } catch (Nt) {
              Ne = { error: Nt };
            } finally {
              try {
                ot && !ot.done && (je = Ye.return) && je.call(Ye);
              } finally {
                if (Ne)
                  throw Ne.error;
              }
            }
          else
            qe.remove(this);
        var it = this.initialTeardown;
        if (ye.isFunction(it))
          try {
            it();
          } catch (Nt) {
            He = Nt instanceof we.UnsubscriptionError ? Nt.errors : [Nt];
          }
        var ht = this._finalizers;
        if (ht) {
          this._finalizers = null;
          try {
            for (var gt = oe(ht), At = gt.next(); !At.done; At = gt.next()) {
              var St = At.value;
              try {
                $e(St);
              } catch (Nt) {
                He = He ?? [], Nt instanceof we.UnsubscriptionError ? He = fe(fe([], ae(He)), ae(Nt.errors)) : He.push(Nt);
              }
            }
          } catch (Nt) {
            Be = { error: Nt };
          } finally {
            try {
              At && !At.done && (ze = gt.return) && ze.call(gt);
            } finally {
              if (Be)
                throw Be.error;
            }
          }
        }
        if (He)
          throw new we.UnsubscriptionError(He);
      }
    }, Re.prototype.add = function(Ne) {
      var je;
      if (Ne && Ne !== this)
        if (this.closed)
          $e(Ne);
        else {
          if (Ne instanceof Re) {
            if (Ne.closed || Ne._hasParent(this))
              return;
            Ne._addParent(this);
          }
          (this._finalizers = (je = this._finalizers) !== null && je !== void 0 ? je : []).push(Ne);
        }
    }, Re.prototype._hasParent = function(Ne) {
      var je = this._parentage;
      return je === Ne || Array.isArray(je) && je.includes(Ne);
    }, Re.prototype._addParent = function(Ne) {
      var je = this._parentage;
      this._parentage = Array.isArray(je) ? (je.push(Ne), je) : je ? [je, Ne] : Ne;
    }, Re.prototype._removeParent = function(Ne) {
      var je = this._parentage;
      je === Ne ? this._parentage = null : Array.isArray(je) && _e.arrRemove(je, Ne);
    }, Re.prototype.remove = function(Ne) {
      var je = this._finalizers;
      je && _e.arrRemove(je, Ne), Ne instanceof Re && Ne._removeParent(this);
    }, Re.EMPTY = function() {
      var Ne = new Re();
      return Ne.closed = !0, Ne;
    }(), Re;
  }();
  ne.Subscription = xe, ne.EMPTY_SUBSCRIPTION = xe.EMPTY;
  function Oe(Re) {
    return Re instanceof xe || Re && "closed" in Re && ye.isFunction(Re.remove) && ye.isFunction(Re.add) && ye.isFunction(Re.unsubscribe);
  }
  ne.isSubscription = Oe;
  function $e(Re) {
    ye.isFunction(Re) ? Re() : Re.unsubscribe();
  }
}), gd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.config = void 0, ne.config = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 };
}), Uk = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var we = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!we)
      return fe;
    var _e = we.call(fe), xe, Oe = [], $e;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(xe = _e.next()).done; )
        Oe.push(xe.value);
    } catch (Re) {
      $e = { error: Re };
    } finally {
      try {
        xe && !xe.done && (we = _e.return) && we.call(_e);
      } finally {
        if ($e)
          throw $e.error;
      }
    }
    return Oe;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var we = 0, _e = ye.length, xe = fe.length; we < _e; we++, xe++)
      fe[xe] = ye[we];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutProvider = void 0, ne.timeoutProvider = { setTimeout: function(fe, ye) {
    for (var we = [], _e = 2; _e < arguments.length; _e++)
      we[_e - 2] = arguments[_e];
    var xe = ne.timeoutProvider.delegate;
    return xe != null && xe.setTimeout ? xe.setTimeout.apply(xe, ae([fe, ye], oe(we))) : setTimeout.apply(void 0, ae([fe, ye], oe(we)));
  }, clearTimeout: function(fe) {
    var ye = ne.timeoutProvider.delegate;
    return ((ye == null ? void 0 : ye.clearTimeout) || clearTimeout)(fe);
  }, delegate: void 0 };
}), Fk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reportUnhandledError = void 0;
  var oe = gd(), ae = Uk();
  function fe(ye) {
    ae.timeoutProvider.setTimeout(function() {
      var we = oe.config.onUnhandledError;
      if (we)
        we(ye);
      else
        throw ye;
    });
  }
  ne.reportUnhandledError = fe;
}), On = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.noop = void 0;
  function oe() {
  }
  ne.noop = oe;
}), eI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createNotification = ne.nextNotification = ne.errorNotification = ne.COMPLETE_NOTIFICATION = void 0, ne.COMPLETE_NOTIFICATION = function() {
    return fe("C", void 0, void 0);
  }();
  function oe(ye) {
    return fe("E", void 0, ye);
  }
  ne.errorNotification = oe;
  function ae(ye) {
    return fe("N", ye, void 0);
  }
  ne.nextNotification = ae;
  function fe(ye, we, _e) {
    return { kind: ye, value: we, error: _e };
  }
  ne.createNotification = fe;
}), G0 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.captureError = ne.errorContext = void 0;
  var oe = gd(), ae = null;
  function fe(we) {
    if (oe.config.useDeprecatedSynchronousErrorHandling) {
      var _e = !ae;
      if (_e && (ae = { errorThrown: !1, error: null }), we(), _e) {
        var xe = ae, Oe = xe.errorThrown, $e = xe.error;
        if (ae = null, Oe)
          throw $e;
      }
    } else
      we();
  }
  ne.errorContext = fe;
  function ye(we) {
    oe.config.useDeprecatedSynchronousErrorHandling && ae && (ae.errorThrown = !0, ae.error = we);
  }
  ne.captureError = ye;
}), Sd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ot = function(tt, it) {
      return ot = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ht, gt) {
        ht.__proto__ = gt;
      } || function(ht, gt) {
        for (var At in gt)
          Object.prototype.hasOwnProperty.call(gt, At) && (ht[At] = gt[At]);
      }, ot(tt, it);
    };
    return function(tt, it) {
      if (typeof it != "function" && it !== null)
        throw new TypeError("Class extends value " + String(it) + " is not a constructor or null");
      ot(tt, it);
      function ht() {
        this.constructor = tt;
      }
      tt.prototype = it === null ? Object.create(it) : (ht.prototype = it.prototype, new ht());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EMPTY_OBSERVER = ne.SafeSubscriber = ne.Subscriber = void 0;
  var ae = Mt(), fe = Oi(), ye = gd(), we = Fk(), _e = On(), xe = eI(), Oe = Uk(), $e = G0(), Re = function(ot) {
    oe(tt, ot);
    function tt(it) {
      var ht = ot.call(this) || this;
      return ht.isStopped = !1, it ? (ht.destination = it, fe.isSubscription(it) && it.add(ht)) : ht.destination = ne.EMPTY_OBSERVER, ht;
    }
    return tt.create = function(it, ht, gt) {
      return new ze(it, ht, gt);
    }, tt.prototype.next = function(it) {
      this.isStopped ? Ye(xe.nextNotification(it), this) : this._next(it);
    }, tt.prototype.error = function(it) {
      this.isStopped ? Ye(xe.errorNotification(it), this) : (this.isStopped = !0, this._error(it));
    }, tt.prototype.complete = function() {
      this.isStopped ? Ye(xe.COMPLETE_NOTIFICATION, this) : (this.isStopped = !0, this._complete());
    }, tt.prototype.unsubscribe = function() {
      this.closed || (this.isStopped = !0, ot.prototype.unsubscribe.call(this), this.destination = null);
    }, tt.prototype._next = function(it) {
      this.destination.next(it);
    }, tt.prototype._error = function(it) {
      try {
        this.destination.error(it);
      } finally {
        this.unsubscribe();
      }
    }, tt.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    }, tt;
  }(fe.Subscription);
  ne.Subscriber = Re;
  var Ne = Function.prototype.bind;
  function je(ot, tt) {
    return Ne.call(ot, tt);
  }
  var Be = function() {
    function ot(tt) {
      this.partialObserver = tt;
    }
    return ot.prototype.next = function(tt) {
      var it = this.partialObserver;
      if (it.next)
        try {
          it.next(tt);
        } catch (ht) {
          He(ht);
        }
    }, ot.prototype.error = function(tt) {
      var it = this.partialObserver;
      if (it.error)
        try {
          it.error(tt);
        } catch (ht) {
          He(ht);
        }
      else
        He(tt);
    }, ot.prototype.complete = function() {
      var tt = this.partialObserver;
      if (tt.complete)
        try {
          tt.complete();
        } catch (it) {
          He(it);
        }
    }, ot;
  }(), ze = function(ot) {
    oe(tt, ot);
    function tt(it, ht, gt) {
      var At = ot.call(this) || this, St;
      if (ae.isFunction(it) || !it)
        St = { next: it ?? void 0, error: ht ?? void 0, complete: gt ?? void 0 };
      else {
        var Nt;
        At && ye.config.useDeprecatedNextContext ? (Nt = Object.create(it), Nt.unsubscribe = function() {
          return At.unsubscribe();
        }, St = { next: it.next && je(it.next, Nt), error: it.error && je(it.error, Nt), complete: it.complete && je(it.complete, Nt) }) : St = it;
      }
      return At.destination = new Be(St), At;
    }
    return tt;
  }(Re);
  ne.SafeSubscriber = ze;
  function He(ot) {
    ye.config.useDeprecatedSynchronousErrorHandling ? $e.captureError(ot) : we.reportUnhandledError(ot);
  }
  function qe(ot) {
    throw ot;
  }
  function Ye(ot, tt) {
    var it = ye.config.onStoppedNotification;
    it && Oe.timeoutProvider.setTimeout(function() {
      return it(ot, tt);
    });
  }
  ne.EMPTY_OBSERVER = { closed: !0, next: _e.noop, error: qe, complete: _e.noop };
}), uh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observable = void 0, ne.observable = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable";
  }();
}), Hn = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.identity = void 0;
  function oe(ae) {
    return ae;
  }
  ne.identity = oe;
}), lh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pipeFromArray = ne.pipe = void 0;
  var oe = Hn();
  function ae() {
    for (var ye = [], we = 0; we < arguments.length; we++)
      ye[we] = arguments[we];
    return fe(ye);
  }
  ne.pipe = ae;
  function fe(ye) {
    return ye.length === 0 ? oe.identity : ye.length === 1 ? ye[0] : function(we) {
      return ye.reduce(function(_e, xe) {
        return xe(_e);
      }, we);
    };
  }
  ne.pipeFromArray = fe;
}), qt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Observable = void 0;
  var oe = Sd(), ae = Oi(), fe = uh(), ye = lh(), we = gd(), _e = Mt(), xe = G0(), Oe = function() {
    function je(Be) {
      Be && (this._subscribe = Be);
    }
    return je.prototype.lift = function(Be) {
      var ze = new je();
      return ze.source = this, ze.operator = Be, ze;
    }, je.prototype.subscribe = function(Be, ze, He) {
      var qe = this, Ye = Ne(Be) ? Be : new oe.SafeSubscriber(Be, ze, He);
      return xe.errorContext(function() {
        var ot = qe, tt = ot.operator, it = ot.source;
        Ye.add(tt ? tt.call(Ye, it) : it ? qe._subscribe(Ye) : qe._trySubscribe(Ye));
      }), Ye;
    }, je.prototype._trySubscribe = function(Be) {
      try {
        return this._subscribe(Be);
      } catch (ze) {
        Be.error(ze);
      }
    }, je.prototype.forEach = function(Be, ze) {
      var He = this;
      return ze = $e(ze), new ze(function(qe, Ye) {
        var ot = new oe.SafeSubscriber({ next: function(tt) {
          try {
            Be(tt);
          } catch (it) {
            Ye(it), ot.unsubscribe();
          }
        }, error: Ye, complete: qe });
        He.subscribe(ot);
      });
    }, je.prototype._subscribe = function(Be) {
      var ze;
      return (ze = this.source) === null || ze === void 0 ? void 0 : ze.subscribe(Be);
    }, je.prototype[fe.observable] = function() {
      return this;
    }, je.prototype.pipe = function() {
      for (var Be = [], ze = 0; ze < arguments.length; ze++)
        Be[ze] = arguments[ze];
      return ye.pipeFromArray(Be)(this);
    }, je.prototype.toPromise = function(Be) {
      var ze = this;
      return Be = $e(Be), new Be(function(He, qe) {
        var Ye;
        ze.subscribe(function(ot) {
          return Ye = ot;
        }, function(ot) {
          return qe(ot);
        }, function() {
          return He(Ye);
        });
      });
    }, je.create = function(Be) {
      return new je(Be);
    }, je;
  }();
  ne.Observable = Oe;
  function $e(je) {
    var Be;
    return (Be = je ?? we.config.Promise) !== null && Be !== void 0 ? Be : Promise;
  }
  function Re(je) {
    return je && _e.isFunction(je.next) && _e.isFunction(je.error) && _e.isFunction(je.complete);
  }
  function Ne(je) {
    return je && je instanceof oe.Subscriber || Re(je) && ae.isSubscription(je);
  }
}), he = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.operate = ne.hasLift = void 0;
  var oe = Mt();
  function ae(ye) {
    return oe.isFunction(ye == null ? void 0 : ye.lift);
  }
  ne.hasLift = ae;
  function fe(ye) {
    return function(we) {
      if (ae(we))
        return we.lift(function(_e) {
          try {
            return ye(_e, this);
          } catch (xe) {
            this.error(xe);
          }
        });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  ne.operate = fe;
}), Ae = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var we = function(_e, xe) {
      return we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Re in $e)
          Object.prototype.hasOwnProperty.call($e, Re) && (Oe[Re] = $e[Re]);
      }, we(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      we(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.OperatorSubscriber = ne.createOperatorSubscriber = void 0;
  var ae = Sd();
  function fe(we, _e, xe, Oe, $e) {
    return new ye(we, _e, xe, Oe, $e);
  }
  ne.createOperatorSubscriber = fe;
  var ye = function(we) {
    oe(_e, we);
    function _e(xe, Oe, $e, Re, Ne, je) {
      var Be = we.call(this, xe) || this;
      return Be.onFinalize = Ne, Be.shouldUnsubscribe = je, Be._next = Oe ? function(ze) {
        try {
          Oe(ze);
        } catch (He) {
          xe.error(He);
        }
      } : we.prototype._next, Be._error = Re ? function(ze) {
        try {
          Re(ze);
        } catch (He) {
          xe.error(He);
        } finally {
          this.unsubscribe();
        }
      } : we.prototype._error, Be._complete = $e ? function() {
        try {
          $e();
        } catch (ze) {
          xe.error(ze);
        } finally {
          this.unsubscribe();
        }
      } : we.prototype._complete, Be;
    }
    return _e.prototype.unsubscribe = function() {
      var xe;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var Oe = this.closed;
        we.prototype.unsubscribe.call(this), !Oe && ((xe = this.onFinalize) === null || xe === void 0 || xe.call(this));
      }
    }, _e;
  }(ae.Subscriber);
  ne.OperatorSubscriber = ye;
}), $k = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.refCount = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, we) {
      var _e = null;
      ye._refCount++;
      var xe = ae.createOperatorSubscriber(we, void 0, void 0, void 0, function() {
        if (!ye || ye._refCount <= 0 || 0 < --ye._refCount) {
          _e = null;
          return;
        }
        var Oe = ye._connection, $e = _e;
        _e = null, Oe && (!$e || Oe === $e) && Oe.unsubscribe(), we.unsubscribe();
      });
      ye.subscribe(xe), xe.closed || (_e = ye.connect());
    });
  }
  ne.refCount = fe;
}), sh = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var Oe = function($e, Re) {
      return Oe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ne, je) {
        Ne.__proto__ = je;
      } || function(Ne, je) {
        for (var Be in je)
          Object.prototype.hasOwnProperty.call(je, Be) && (Ne[Be] = je[Be]);
      }, Oe($e, Re);
    };
    return function($e, Re) {
      if (typeof Re != "function" && Re !== null)
        throw new TypeError("Class extends value " + String(Re) + " is not a constructor or null");
      Oe($e, Re);
      function Ne() {
        this.constructor = $e;
      }
      $e.prototype = Re === null ? Object.create(Re) : (Ne.prototype = Re.prototype, new Ne());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ConnectableObservable = void 0;
  var ae = qt(), fe = Oi(), ye = $k(), we = Ae(), _e = he(), xe = function(Oe) {
    oe($e, Oe);
    function $e(Re, Ne) {
      var je = Oe.call(this) || this;
      return je.source = Re, je.subjectFactory = Ne, je._subject = null, je._refCount = 0, je._connection = null, _e.hasLift(Re) && (je.lift = Re.lift), je;
    }
    return $e.prototype._subscribe = function(Re) {
      return this.getSubject().subscribe(Re);
    }, $e.prototype.getSubject = function() {
      var Re = this._subject;
      return (!Re || Re.isStopped) && (this._subject = this.subjectFactory()), this._subject;
    }, $e.prototype._teardown = function() {
      this._refCount = 0;
      var Re = this._connection;
      this._subject = this._connection = null, Re == null || Re.unsubscribe();
    }, $e.prototype.connect = function() {
      var Re = this, Ne = this._connection;
      if (!Ne) {
        Ne = this._connection = new fe.Subscription();
        var je = this.getSubject();
        Ne.add(this.source.subscribe(we.createOperatorSubscriber(je, void 0, function() {
          Re._teardown(), je.complete();
        }, function(Be) {
          Re._teardown(), je.error(Be);
        }, function() {
          return Re._teardown();
        }))), Ne.closed && (this._connection = null, Ne = fe.Subscription.EMPTY);
      }
      return Ne;
    }, $e.prototype.refCount = function() {
      return ye.refCount()(this);
    }, $e;
  }(ae.Observable);
  ne.ConnectableObservable = xe;
}), dI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.performanceTimestampProvider = void 0, ne.performanceTimestampProvider = { now: function() {
    return (ne.performanceTimestampProvider.delegate || performance).now();
  }, delegate: void 0 };
}), Wk = M((ne) => {
  var oe = ne && ne.__read || function(ye, we) {
    var _e = typeof Symbol == "function" && ye[Symbol.iterator];
    if (!_e)
      return ye;
    var xe = _e.call(ye), Oe, $e = [], Re;
    try {
      for (; (we === void 0 || we-- > 0) && !(Oe = xe.next()).done; )
        $e.push(Oe.value);
    } catch (Ne) {
      Re = { error: Ne };
    } finally {
      try {
        Oe && !Oe.done && (_e = xe.return) && _e.call(xe);
      } finally {
        if (Re)
          throw Re.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ye, we) {
    for (var _e = 0, xe = we.length, Oe = ye.length; _e < xe; _e++, Oe++)
      ye[Oe] = we[_e];
    return ye;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrameProvider = void 0;
  var fe = Oi();
  ne.animationFrameProvider = { schedule: function(ye) {
    var we = requestAnimationFrame, _e = cancelAnimationFrame, xe = ne.animationFrameProvider.delegate;
    xe && (we = xe.requestAnimationFrame, _e = xe.cancelAnimationFrame);
    var Oe = we(function($e) {
      _e = void 0, ye($e);
    });
    return new fe.Subscription(function() {
      return _e == null ? void 0 : _e(Oe);
    });
  }, requestAnimationFrame: function() {
    for (var ye = [], we = 0; we < arguments.length; we++)
      ye[we] = arguments[we];
    var _e = ne.animationFrameProvider.delegate;
    return ((_e == null ? void 0 : _e.requestAnimationFrame) || requestAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, cancelAnimationFrame: function() {
    for (var ye = [], we = 0; we < arguments.length; we++)
      ye[we] = arguments[we];
    var _e = ne.animationFrameProvider.delegate;
    return ((_e == null ? void 0 : _e.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, delegate: void 0 };
}), hI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrames = void 0;
  var oe = qt(), ae = Oi(), fe = dI(), ye = Wk();
  function we(Oe) {
    return Oe ? _e(Oe) : xe;
  }
  ne.animationFrames = we;
  function _e(Oe) {
    var $e = ye.animationFrameProvider.schedule;
    return new oe.Observable(function(Re) {
      var Ne = new ae.Subscription(), je = Oe || fe.performanceTimestampProvider, Be = je.now(), ze = function(He) {
        var qe = je.now();
        Re.next({ timestamp: Oe ? qe : He, elapsed: qe - Be }), Re.closed || Ne.add($e(ze));
      };
      return Ne.add($e(ze)), Ne;
    });
  }
  var xe = _e();
}), Yk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ObjectUnsubscribedError = void 0;
  var oe = Il();
  ne.ObjectUnsubscribedError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
    };
  });
}), Tn = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var Re = function(Ne, je) {
      return Re = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Be, ze) {
        Be.__proto__ = ze;
      } || function(Be, ze) {
        for (var He in ze)
          Object.prototype.hasOwnProperty.call(ze, He) && (Be[He] = ze[He]);
      }, Re(Ne, je);
    };
    return function(Ne, je) {
      if (typeof je != "function" && je !== null)
        throw new TypeError("Class extends value " + String(je) + " is not a constructor or null");
      Re(Ne, je);
      function Be() {
        this.constructor = Ne;
      }
      Ne.prototype = je === null ? Object.create(je) : (Be.prototype = je.prototype, new Be());
    };
  }(), ae = ne && ne.__values || function(Re) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, je = Ne && Re[Ne], Be = 0;
    if (je)
      return je.call(Re);
    if (Re && typeof Re.length == "number")
      return { next: function() {
        return Re && Be >= Re.length && (Re = void 0), { value: Re && Re[Be++], done: !Re };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnonymousSubject = ne.Subject = void 0;
  var fe = qt(), ye = Oi(), we = Yk(), _e = ku(), xe = G0(), Oe = function(Re) {
    oe(Ne, Re);
    function Ne() {
      var je = Re.call(this) || this;
      return je.closed = !1, je.currentObservers = null, je.observers = [], je.isStopped = !1, je.hasError = !1, je.thrownError = null, je;
    }
    return Ne.prototype.lift = function(je) {
      var Be = new $e(this, this);
      return Be.operator = je, Be;
    }, Ne.prototype._throwIfClosed = function() {
      if (this.closed)
        throw new we.ObjectUnsubscribedError();
    }, Ne.prototype.next = function(je) {
      var Be = this;
      xe.errorContext(function() {
        var ze, He;
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.currentObservers || (Be.currentObservers = Array.from(Be.observers));
          try {
            for (var qe = ae(Be.currentObservers), Ye = qe.next(); !Ye.done; Ye = qe.next()) {
              var ot = Ye.value;
              ot.next(je);
            }
          } catch (tt) {
            ze = { error: tt };
          } finally {
            try {
              Ye && !Ye.done && (He = qe.return) && He.call(qe);
            } finally {
              if (ze)
                throw ze.error;
            }
          }
        }
      });
    }, Ne.prototype.error = function(je) {
      var Be = this;
      xe.errorContext(function() {
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.hasError = Be.isStopped = !0, Be.thrownError = je;
          for (var ze = Be.observers; ze.length; )
            ze.shift().error(je);
        }
      });
    }, Ne.prototype.complete = function() {
      var je = this;
      xe.errorContext(function() {
        if (je._throwIfClosed(), !je.isStopped) {
          je.isStopped = !0;
          for (var Be = je.observers; Be.length; )
            Be.shift().complete();
        }
      });
    }, Ne.prototype.unsubscribe = function() {
      this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
    }, Object.defineProperty(Ne.prototype, "observed", { get: function() {
      var je;
      return ((je = this.observers) === null || je === void 0 ? void 0 : je.length) > 0;
    }, enumerable: !1, configurable: !0 }), Ne.prototype._trySubscribe = function(je) {
      return this._throwIfClosed(), Re.prototype._trySubscribe.call(this, je);
    }, Ne.prototype._subscribe = function(je) {
      return this._throwIfClosed(), this._checkFinalizedStatuses(je), this._innerSubscribe(je);
    }, Ne.prototype._innerSubscribe = function(je) {
      var Be = this, ze = this, He = ze.hasError, qe = ze.isStopped, Ye = ze.observers;
      return He || qe ? ye.EMPTY_SUBSCRIPTION : (this.currentObservers = null, Ye.push(je), new ye.Subscription(function() {
        Be.currentObservers = null, _e.arrRemove(Ye, je);
      }));
    }, Ne.prototype._checkFinalizedStatuses = function(je) {
      var Be = this, ze = Be.hasError, He = Be.thrownError, qe = Be.isStopped;
      ze ? je.error(He) : qe && je.complete();
    }, Ne.prototype.asObservable = function() {
      var je = new fe.Observable();
      return je.source = this, je;
    }, Ne.create = function(je, Be) {
      return new $e(je, Be);
    }, Ne;
  }(fe.Observable);
  ne.Subject = Oe;
  var $e = function(Re) {
    oe(Ne, Re);
    function Ne(je, Be) {
      var ze = Re.call(this) || this;
      return ze.destination = je, ze.source = Be, ze;
    }
    return Ne.prototype.next = function(je) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.next) === null || ze === void 0 || ze.call(Be, je);
    }, Ne.prototype.error = function(je) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.error) === null || ze === void 0 || ze.call(Be, je);
    }, Ne.prototype.complete = function() {
      var je, Be;
      (Be = (je = this.destination) === null || je === void 0 ? void 0 : je.complete) === null || Be === void 0 || Be.call(je);
    }, Ne.prototype._subscribe = function(je) {
      var Be, ze;
      return (ze = (Be = this.source) === null || Be === void 0 ? void 0 : Be.subscribe(je)) !== null && ze !== void 0 ? ze : ye.EMPTY_SUBSCRIPTION;
    }, Ne;
  }(Oe);
  ne.AnonymousSubject = $e;
}), Xk = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.BehaviorSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(we, ye);
    function we(_e) {
      var xe = ye.call(this) || this;
      return xe._value = _e, xe;
    }
    return Object.defineProperty(we.prototype, "value", { get: function() {
      return this.getValue();
    }, enumerable: !1, configurable: !0 }), we.prototype._subscribe = function(_e) {
      var xe = ye.prototype._subscribe.call(this, _e);
      return !xe.closed && _e.next(this._value), xe;
    }, we.prototype.getValue = function() {
      var _e = this, xe = _e.hasError, Oe = _e.thrownError, $e = _e._value;
      if (xe)
        throw Oe;
      return this._throwIfClosed(), $e;
    }, we.prototype.next = function(_e) {
      ye.prototype.next.call(this, this._value = _e);
    }, we;
  }(ae.Subject);
  ne.BehaviorSubject = fe;
}), rS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dateTimestampProvider = void 0, ne.dateTimestampProvider = { now: function() {
    return (ne.dateTimestampProvider.delegate || Date).now();
  }, delegate: void 0 };
}), nS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var we = function(_e, xe) {
      return we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Re in $e)
          Object.prototype.hasOwnProperty.call($e, Re) && (Oe[Re] = $e[Re]);
      }, we(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      we(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ReplaySubject = void 0;
  var ae = Tn(), fe = rS(), ye = function(we) {
    oe(_e, we);
    function _e(xe, Oe, $e) {
      xe === void 0 && (xe = 1 / 0), Oe === void 0 && (Oe = 1 / 0), $e === void 0 && ($e = fe.dateTimestampProvider);
      var Re = we.call(this) || this;
      return Re._bufferSize = xe, Re._windowTime = Oe, Re._timestampProvider = $e, Re._buffer = [], Re._infiniteTimeWindow = !0, Re._infiniteTimeWindow = Oe === 1 / 0, Re._bufferSize = Math.max(1, xe), Re._windowTime = Math.max(1, Oe), Re;
    }
    return _e.prototype.next = function(xe) {
      var Oe = this, $e = Oe.isStopped, Re = Oe._buffer, Ne = Oe._infiniteTimeWindow, je = Oe._timestampProvider, Be = Oe._windowTime;
      $e || (Re.push(xe), !Ne && Re.push(je.now() + Be)), this._trimBuffer(), we.prototype.next.call(this, xe);
    }, _e.prototype._subscribe = function(xe) {
      this._throwIfClosed(), this._trimBuffer();
      for (var Oe = this._innerSubscribe(xe), $e = this, Re = $e._infiniteTimeWindow, Ne = $e._buffer, je = Ne.slice(), Be = 0; Be < je.length && !xe.closed; Be += Re ? 1 : 2)
        xe.next(je[Be]);
      return this._checkFinalizedStatuses(xe), Oe;
    }, _e.prototype._trimBuffer = function() {
      var xe = this, Oe = xe._bufferSize, $e = xe._timestampProvider, Re = xe._buffer, Ne = xe._infiniteTimeWindow, je = (Ne ? 1 : 2) * Oe;
      if (Oe < 1 / 0 && je < Re.length && Re.splice(0, Re.length - je), !Ne) {
        for (var Be = $e.now(), ze = 0, He = 1; He < Re.length && Re[He] <= Be; He += 2)
          ze = He;
        ze && Re.splice(0, ze + 1);
      }
    }, _e;
  }(ae.Subject);
  ne.ReplaySubject = ye;
}), iS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(we, ye);
    function we() {
      var _e = ye !== null && ye.apply(this, arguments) || this;
      return _e._value = null, _e._hasValue = !1, _e._isComplete = !1, _e;
    }
    return we.prototype._checkFinalizedStatuses = function(_e) {
      var xe = this, Oe = xe.hasError, $e = xe._hasValue, Re = xe._value, Ne = xe.thrownError, je = xe.isStopped, Be = xe._isComplete;
      Oe ? _e.error(Ne) : (je || Be) && ($e && _e.next(Re), _e.complete());
    }, we.prototype.next = function(_e) {
      this.isStopped || (this._value = _e, this._hasValue = !0);
    }, we.prototype.complete = function() {
      var _e = this, xe = _e._hasValue, Oe = _e._value, $e = _e._isComplete;
      $e || (this._isComplete = !0, xe && ye.prototype.next.call(this, Oe), ye.prototype.complete.call(this));
    }, we;
  }(ae.Subject);
  ne.AsyncSubject = fe;
}), SI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Action = void 0;
  var ae = Oi(), fe = function(ye) {
    oe(we, ye);
    function we(_e, xe) {
      return ye.call(this) || this;
    }
    return we.prototype.schedule = function(_e, xe) {
      return this;
    }, we;
  }(ae.Subscription);
  ne.Action = fe;
}), xI = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var we = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!we)
      return fe;
    var _e = we.call(fe), xe, Oe = [], $e;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(xe = _e.next()).done; )
        Oe.push(xe.value);
    } catch (Re) {
      $e = { error: Re };
    } finally {
      try {
        xe && !xe.done && (we = _e.return) && we.call(_e);
      } finally {
        if ($e)
          throw $e.error;
      }
    }
    return Oe;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var we = 0, _e = ye.length, xe = fe.length; we < _e; we++, xe++)
      fe[xe] = ye[we];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.intervalProvider = void 0, ne.intervalProvider = { setInterval: function(fe, ye) {
    for (var we = [], _e = 2; _e < arguments.length; _e++)
      we[_e - 2] = arguments[_e];
    var xe = ne.intervalProvider.delegate;
    return xe != null && xe.setInterval ? xe.setInterval.apply(xe, ae([fe, ye], oe(we))) : setInterval.apply(void 0, ae([fe, ye], oe(we)));
  }, clearInterval: function(fe) {
    var ye = ne.intervalProvider.delegate;
    return ((ye == null ? void 0 : ye.clearInterval) || clearInterval)(fe);
  }, delegate: void 0 };
}), kd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var _e = function(xe, Oe) {
      return _e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function($e, Re) {
        $e.__proto__ = Re;
      } || function($e, Re) {
        for (var Ne in Re)
          Object.prototype.hasOwnProperty.call(Re, Ne) && ($e[Ne] = Re[Ne]);
      }, _e(xe, Oe);
    };
    return function(xe, Oe) {
      if (typeof Oe != "function" && Oe !== null)
        throw new TypeError("Class extends value " + String(Oe) + " is not a constructor or null");
      _e(xe, Oe);
      function $e() {
        this.constructor = xe;
      }
      xe.prototype = Oe === null ? Object.create(Oe) : ($e.prototype = Oe.prototype, new $e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncAction = void 0;
  var ae = SI(), fe = xI(), ye = ku(), we = function(_e) {
    oe(xe, _e);
    function xe(Oe, $e) {
      var Re = _e.call(this, Oe, $e) || this;
      return Re.scheduler = Oe, Re.work = $e, Re.pending = !1, Re;
    }
    return xe.prototype.schedule = function(Oe, $e) {
      if ($e === void 0 && ($e = 0), this.closed)
        return this;
      this.state = Oe;
      var Re = this.id, Ne = this.scheduler;
      return Re != null && (this.id = this.recycleAsyncId(Ne, Re, $e)), this.pending = !0, this.delay = $e, this.id = this.id || this.requestAsyncId(Ne, this.id, $e), this;
    }, xe.prototype.requestAsyncId = function(Oe, $e, Re) {
      return Re === void 0 && (Re = 0), fe.intervalProvider.setInterval(Oe.flush.bind(Oe, this), Re);
    }, xe.prototype.recycleAsyncId = function(Oe, $e, Re) {
      if (Re === void 0 && (Re = 0), Re != null && this.delay === Re && this.pending === !1)
        return $e;
      fe.intervalProvider.clearInterval($e);
    }, xe.prototype.execute = function(Oe, $e) {
      if (this.closed)
        return new Error("executing a cancelled action");
      this.pending = !1;
      var Re = this._execute(Oe, $e);
      if (Re)
        return Re;
      this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
    }, xe.prototype._execute = function(Oe, $e) {
      var Re = !1, Ne;
      try {
        this.work(Oe);
      } catch (je) {
        Re = !0, Ne = je || new Error("Scheduled action threw falsy error");
      }
      if (Re)
        return this.unsubscribe(), Ne;
    }, xe.prototype.unsubscribe = function() {
      if (!this.closed) {
        var Oe = this, $e = Oe.id, Re = Oe.scheduler, Ne = Re.actions;
        this.work = this.state = this.scheduler = null, this.pending = !1, ye.arrRemove(Ne, this), $e != null && (this.id = this.recycleAsyncId(Re, $e, null)), this.delay = null, _e.prototype.unsubscribe.call(this);
      }
    }, xe;
  }(ae.Action);
  ne.AsyncAction = we;
}), RI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TestTools = ne.Immediate = void 0;
  var oe = 1, ae, fe = {};
  function ye(we) {
    return we in fe ? (delete fe[we], !0) : !1;
  }
  ne.Immediate = { setImmediate: function(we) {
    var _e = oe++;
    return fe[_e] = !0, ae || (ae = Promise.resolve()), ae.then(function() {
      return ye(_e) && we();
    }), _e;
  }, clearImmediate: function(we) {
    ye(we);
  } }, ne.TestTools = { pending: function() {
    return Object.keys(fe).length;
  } };
}), TI = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Re, Ne = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Re = $e.next()).done; )
        Ne.push(Re.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Re && !Re.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Re = _e.length; Oe < $e; Oe++, Re++)
      _e[Re] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.immediateProvider = void 0;
  var fe = RI(), ye = fe.Immediate.setImmediate, we = fe.Immediate.clearImmediate;
  ne.immediateProvider = { setImmediate: function() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    var Oe = ne.immediateProvider.delegate;
    return ((Oe == null ? void 0 : Oe.setImmediate) || ye).apply(void 0, ae([], oe(_e)));
  }, clearImmediate: function(_e) {
    var xe = ne.immediateProvider.delegate;
    return ((xe == null ? void 0 : xe.clearImmediate) || we)(_e);
  }, delegate: void 0 };
}), AI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var we = function(_e, xe) {
      return we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Re in $e)
          Object.prototype.hasOwnProperty.call($e, Re) && (Oe[Re] = $e[Re]);
      }, we(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      we(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapAction = void 0;
  var ae = kd(), fe = TI(), ye = function(we) {
    oe(_e, we);
    function _e(xe, Oe) {
      var $e = we.call(this, xe, Oe) || this;
      return $e.scheduler = xe, $e.work = Oe, $e;
    }
    return _e.prototype.requestAsyncId = function(xe, Oe, $e) {
      return $e === void 0 && ($e = 0), $e !== null && $e > 0 ? we.prototype.requestAsyncId.call(this, xe, Oe, $e) : (xe.actions.push(this), xe._scheduled || (xe._scheduled = fe.immediateProvider.setImmediate(xe.flush.bind(xe, void 0))));
    }, _e.prototype.recycleAsyncId = function(xe, Oe, $e) {
      if ($e === void 0 && ($e = 0), $e != null && $e > 0 || $e == null && this.delay > 0)
        return we.prototype.recycleAsyncId.call(this, xe, Oe, $e);
      xe.actions.some(function(Re) {
        return Re.id === Oe;
      }) || (fe.immediateProvider.clearImmediate(Oe), xe._scheduled = void 0);
    }, _e;
  }(ae.AsyncAction);
  ne.AsapAction = ye;
}), Zk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Scheduler = void 0;
  var oe = rS(), ae = function() {
    function fe(ye, we) {
      we === void 0 && (we = fe.now), this.schedulerActionCtor = ye, this.now = we;
    }
    return fe.prototype.schedule = function(ye, we, _e) {
      return we === void 0 && (we = 0), new this.schedulerActionCtor(this, ye).schedule(_e, we);
    }, fe.now = oe.dateTimestampProvider.now, fe;
  }();
  ne.Scheduler = ae;
}), Dd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncScheduler = void 0;
  var ae = Zk(), fe = function(ye) {
    oe(we, ye);
    function we(_e, xe) {
      xe === void 0 && (xe = ae.Scheduler.now);
      var Oe = ye.call(this, _e, xe) || this;
      return Oe.actions = [], Oe._active = !1, Oe._scheduled = void 0, Oe;
    }
    return we.prototype.flush = function(_e) {
      var xe = this.actions;
      if (this._active) {
        xe.push(_e);
        return;
      }
      var Oe;
      this._active = !0;
      do
        if (Oe = _e.execute(_e.state, _e.delay))
          break;
      while (_e = xe.shift());
      if (this._active = !1, Oe) {
        for (; _e = xe.shift(); )
          _e.unsubscribe();
        throw Oe;
      }
    }, we;
  }(ae.Scheduler);
  ne.AsyncScheduler = fe;
}), MI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(we, ye);
    function we() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return we.prototype.flush = function(_e) {
      this._active = !0;
      var xe = this._scheduled;
      this._scheduled = void 0;
      var Oe = this.actions, $e;
      _e = _e || Oe.shift();
      do
        if ($e = _e.execute(_e.state, _e.delay))
          break;
      while ((_e = Oe[0]) && _e.id === xe && Oe.shift());
      if (this._active = !1, $e) {
        for (; (_e = Oe[0]) && _e.id === xe && Oe.shift(); )
          _e.unsubscribe();
        throw $e;
      }
    }, we;
  }(ae.AsyncScheduler);
  ne.AsapScheduler = fe;
}), DI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.asap = ne.asapScheduler = void 0;
  var oe = AI(), ae = MI();
  ne.asapScheduler = new ae.AsapScheduler(oe.AsapAction), ne.asap = ne.asapScheduler;
}), Ti = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.async = ne.asyncScheduler = void 0;
  var oe = kd(), ae = Dd();
  ne.asyncScheduler = new ae.AsyncScheduler(oe.AsyncAction), ne.async = ne.asyncScheduler;
}), NI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueAction = void 0;
  var ae = kd(), fe = function(ye) {
    oe(we, ye);
    function we(_e, xe) {
      var Oe = ye.call(this, _e, xe) || this;
      return Oe.scheduler = _e, Oe.work = xe, Oe;
    }
    return we.prototype.schedule = function(_e, xe) {
      return xe === void 0 && (xe = 0), xe > 0 ? ye.prototype.schedule.call(this, _e, xe) : (this.delay = xe, this.state = _e, this.scheduler.flush(this), this);
    }, we.prototype.execute = function(_e, xe) {
      return xe > 0 || this.closed ? ye.prototype.execute.call(this, _e, xe) : this._execute(_e, xe);
    }, we.prototype.requestAsyncId = function(_e, xe, Oe) {
      return Oe === void 0 && (Oe = 0), Oe != null && Oe > 0 || Oe == null && this.delay > 0 ? ye.prototype.requestAsyncId.call(this, _e, xe, Oe) : _e.flush(this);
    }, we;
  }(ae.AsyncAction);
  ne.QueueAction = fe;
}), LI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(we, ye);
    function we() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return we;
  }(ae.AsyncScheduler);
  ne.QueueScheduler = fe;
}), jI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.queue = ne.queueScheduler = void 0;
  var oe = NI(), ae = LI();
  ne.queueScheduler = new ae.QueueScheduler(oe.QueueAction), ne.queue = ne.queueScheduler;
}), FI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var we = function(_e, xe) {
      return we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Oe, $e) {
        Oe.__proto__ = $e;
      } || function(Oe, $e) {
        for (var Re in $e)
          Object.prototype.hasOwnProperty.call($e, Re) && (Oe[Re] = $e[Re]);
      }, we(_e, xe);
    };
    return function(_e, xe) {
      if (typeof xe != "function" && xe !== null)
        throw new TypeError("Class extends value " + String(xe) + " is not a constructor or null");
      we(_e, xe);
      function Oe() {
        this.constructor = _e;
      }
      _e.prototype = xe === null ? Object.create(xe) : (Oe.prototype = xe.prototype, new Oe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameAction = void 0;
  var ae = kd(), fe = Wk(), ye = function(we) {
    oe(_e, we);
    function _e(xe, Oe) {
      var $e = we.call(this, xe, Oe) || this;
      return $e.scheduler = xe, $e.work = Oe, $e;
    }
    return _e.prototype.requestAsyncId = function(xe, Oe, $e) {
      return $e === void 0 && ($e = 0), $e !== null && $e > 0 ? we.prototype.requestAsyncId.call(this, xe, Oe, $e) : (xe.actions.push(this), xe._scheduled || (xe._scheduled = fe.animationFrameProvider.requestAnimationFrame(function() {
        return xe.flush(void 0);
      })));
    }, _e.prototype.recycleAsyncId = function(xe, Oe, $e) {
      if ($e === void 0 && ($e = 0), $e != null && $e > 0 || $e == null && this.delay > 0)
        return we.prototype.recycleAsyncId.call(this, xe, Oe, $e);
      xe.actions.some(function(Re) {
        return Re.id === Oe;
      }) || (fe.animationFrameProvider.cancelAnimationFrame(Oe), xe._scheduled = void 0);
    }, _e;
  }(ae.AsyncAction);
  ne.AnimationFrameAction = ye;
}), zI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(we, _e) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(xe, Oe) {
        xe.__proto__ = Oe;
      } || function(xe, Oe) {
        for (var $e in Oe)
          Object.prototype.hasOwnProperty.call(Oe, $e) && (xe[$e] = Oe[$e]);
      }, ye(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ye(we, _e);
      function xe() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (xe.prototype = _e.prototype, new xe());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(we, ye);
    function we() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return we.prototype.flush = function(_e) {
      this._active = !0;
      var xe = this._scheduled;
      this._scheduled = void 0;
      var Oe = this.actions, $e;
      _e = _e || Oe.shift();
      do
        if ($e = _e.execute(_e.state, _e.delay))
          break;
      while ((_e = Oe[0]) && _e.id === xe && Oe.shift());
      if (this._active = !1, $e) {
        for (; (_e = Oe[0]) && _e.id === xe && Oe.shift(); )
          _e.unsubscribe();
        throw $e;
      }
    }, we;
  }(ae.AsyncScheduler);
  ne.AnimationFrameScheduler = fe;
}), qI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrame = ne.animationFrameScheduler = void 0;
  var oe = FI(), ae = zI();
  ne.animationFrameScheduler = new ae.AnimationFrameScheduler(oe.AnimationFrameAction), ne.animationFrame = ne.animationFrameScheduler;
}), HI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var xe = function(Oe, $e) {
      return xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Re, Ne) {
        Re.__proto__ = Ne;
      } || function(Re, Ne) {
        for (var je in Ne)
          Object.prototype.hasOwnProperty.call(Ne, je) && (Re[je] = Ne[je]);
      }, xe(Oe, $e);
    };
    return function(Oe, $e) {
      if (typeof $e != "function" && $e !== null)
        throw new TypeError("Class extends value " + String($e) + " is not a constructor or null");
      xe(Oe, $e);
      function Re() {
        this.constructor = Oe;
      }
      Oe.prototype = $e === null ? Object.create($e) : (Re.prototype = $e.prototype, new Re());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.VirtualAction = ne.VirtualTimeScheduler = void 0;
  var ae = kd(), fe = Oi(), ye = Dd(), we = function(xe) {
    oe(Oe, xe);
    function Oe($e, Re) {
      $e === void 0 && ($e = _e), Re === void 0 && (Re = 1 / 0);
      var Ne = xe.call(this, $e, function() {
        return Ne.frame;
      }) || this;
      return Ne.maxFrames = Re, Ne.frame = 0, Ne.index = -1, Ne;
    }
    return Oe.prototype.flush = function() {
      for (var $e = this, Re = $e.actions, Ne = $e.maxFrames, je, Be; (Be = Re[0]) && Be.delay <= Ne && (Re.shift(), this.frame = Be.delay, !(je = Be.execute(Be.state, Be.delay))); )
        ;
      if (je) {
        for (; Be = Re.shift(); )
          Be.unsubscribe();
        throw je;
      }
    }, Oe.frameTimeFactor = 10, Oe;
  }(ye.AsyncScheduler);
  ne.VirtualTimeScheduler = we;
  var _e = function(xe) {
    oe(Oe, xe);
    function Oe($e, Re, Ne) {
      Ne === void 0 && (Ne = $e.index += 1);
      var je = xe.call(this, $e, Re) || this;
      return je.scheduler = $e, je.work = Re, je.index = Ne, je.active = !0, je.index = $e.index = Ne, je;
    }
    return Oe.prototype.schedule = function($e, Re) {
      if (Re === void 0 && (Re = 0), Number.isFinite(Re)) {
        if (!this.id)
          return xe.prototype.schedule.call(this, $e, Re);
        this.active = !1;
        var Ne = new Oe(this.scheduler, this.work);
        return this.add(Ne), Ne.schedule($e, Re);
      } else
        return fe.Subscription.EMPTY;
    }, Oe.prototype.requestAsyncId = function($e, Re, Ne) {
      Ne === void 0 && (Ne = 0), this.delay = $e.frame + Ne;
      var je = $e.actions;
      return je.push(this), je.sort(Oe.sortActions), !0;
    }, Oe.prototype.recycleAsyncId = function($e, Re, Ne) {
    }, Oe.prototype._execute = function($e, Re) {
      if (this.active === !0)
        return xe.prototype._execute.call(this, $e, Re);
    }, Oe.sortActions = function($e, Re) {
      return $e.delay === Re.delay ? $e.index === Re.index ? 0 : $e.index > Re.index ? 1 : -1 : $e.delay > Re.delay ? 1 : -1;
    }, Oe;
  }(ae.AsyncAction);
  ne.VirtualAction = _e;
}), ba = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.empty = ne.EMPTY = void 0;
  var oe = qt();
  ne.EMPTY = new oe.Observable(function(ye) {
    return ye.complete();
  });
  function ae(ye) {
    return ye ? fe(ye) : ne.EMPTY;
  }
  ne.empty = ae;
  function fe(ye) {
    return new oe.Observable(function(we) {
      return ye.schedule(function() {
        return we.complete();
      });
    });
  }
}), dh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isScheduler = void 0;
  var oe = Mt();
  function ae(fe) {
    return fe && oe.isFunction(fe.schedule);
  }
  ne.isScheduler = ae;
}), ki = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.popNumber = ne.popScheduler = ne.popResultSelector = void 0;
  var oe = Mt(), ae = dh();
  function fe(xe) {
    return xe[xe.length - 1];
  }
  function ye(xe) {
    return oe.isFunction(fe(xe)) ? xe.pop() : void 0;
  }
  ne.popResultSelector = ye;
  function we(xe) {
    return ae.isScheduler(fe(xe)) ? xe.pop() : void 0;
  }
  ne.popScheduler = we;
  function _e(xe, Oe) {
    return typeof fe(xe) == "number" ? xe.pop() : Oe;
  }
  ne.popNumber = _e;
}), sS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isArrayLike = void 0, ne.isArrayLike = function(oe) {
    return oe && typeof oe.length == "number" && typeof oe != "function";
  };
}), tA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isPromise = void 0;
  var oe = Mt();
  function ae(fe) {
    return oe.isFunction(fe == null ? void 0 : fe.then);
  }
  ne.isPromise = ae;
}), rA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isInteropObservable = void 0;
  var oe = uh(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye[oe.observable]);
  }
  ne.isInteropObservable = fe;
}), nA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isAsyncIterable = void 0;
  var oe = Mt();
  function ae(fe) {
    return Symbol.asyncIterator && oe.isFunction(fe == null ? void 0 : fe[Symbol.asyncIterator]);
  }
  ne.isAsyncIterable = ae;
}), iA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createInvalidObservableTypeError = void 0;
  function oe(ae) {
    return new TypeError("You provided " + (ae !== null && typeof ae == "object" ? "an invalid object" : "'" + ae + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  ne.createInvalidObservableTypeError = oe;
}), aA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iterator = ne.getSymbolIterator = void 0;
  function oe() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
  }
  ne.getSymbolIterator = oe, ne.iterator = oe();
}), oA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isIterable = void 0;
  var oe = aA(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye == null ? void 0 : ye[oe.iterator]);
  }
  ne.isIterable = fe;
}), mS = M((ne) => {
  var oe = ne && ne.__generator || function(xe, Oe) {
    var $e = { label: 0, sent: function() {
      if (je[0] & 1)
        throw je[1];
      return je[1];
    }, trys: [], ops: [] }, Re, Ne, je, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(qe) {
      return function(Ye) {
        return He([qe, Ye]);
      };
    }
    function He(qe) {
      if (Re)
        throw new TypeError("Generator is already executing.");
      for (; $e; )
        try {
          if (Re = 1, Ne && (je = qe[0] & 2 ? Ne.return : qe[0] ? Ne.throw || ((je = Ne.return) && je.call(Ne), 0) : Ne.next) && !(je = je.call(Ne, qe[1])).done)
            return je;
          switch (Ne = 0, je && (qe = [qe[0] & 2, je.value]), qe[0]) {
            case 0:
            case 1:
              je = qe;
              break;
            case 4:
              return $e.label++, { value: qe[1], done: !1 };
            case 5:
              $e.label++, Ne = qe[1], qe = [0];
              continue;
            case 7:
              qe = $e.ops.pop(), $e.trys.pop();
              continue;
            default:
              if (je = $e.trys, !(je = je.length > 0 && je[je.length - 1]) && (qe[0] === 6 || qe[0] === 2)) {
                $e = 0;
                continue;
              }
              if (qe[0] === 3 && (!je || qe[1] > je[0] && qe[1] < je[3])) {
                $e.label = qe[1];
                break;
              }
              if (qe[0] === 6 && $e.label < je[1]) {
                $e.label = je[1], je = qe;
                break;
              }
              if (je && $e.label < je[2]) {
                $e.label = je[2], $e.ops.push(qe);
                break;
              }
              je[2] && $e.ops.pop(), $e.trys.pop();
              continue;
          }
          qe = Oe.call(xe, $e);
        } catch (Ye) {
          qe = [6, Ye], Ne = 0;
        } finally {
          Re = je = 0;
        }
      if (qe[0] & 5)
        throw qe[1];
      return { value: qe[0] ? qe[1] : void 0, done: !0 };
    }
  }, ae = ne && ne.__await || function(xe) {
    return this instanceof ae ? (this.v = xe, this) : new ae(xe);
  }, fe = ne && ne.__asyncGenerator || function(xe, Oe, $e) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var Re = $e.apply(xe, Oe || []), Ne, je = [];
    return Ne = {}, Be("next"), Be("throw"), Be("return"), Ne[Symbol.asyncIterator] = function() {
      return this;
    }, Ne;
    function Be(tt) {
      Re[tt] && (Ne[tt] = function(it) {
        return new Promise(function(ht, gt) {
          je.push([tt, it, ht, gt]) > 1 || ze(tt, it);
        });
      });
    }
    function ze(tt, it) {
      try {
        He(Re[tt](it));
      } catch (ht) {
        ot(je[0][3], ht);
      }
    }
    function He(tt) {
      tt.value instanceof ae ? Promise.resolve(tt.value.v).then(qe, Ye) : ot(je[0][2], tt);
    }
    function qe(tt) {
      ze("next", tt);
    }
    function Ye(tt) {
      ze("throw", tt);
    }
    function ot(tt, it) {
      tt(it), je.shift(), je.length && ze(je[0][0], je[0][1]);
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isReadableStreamLike = ne.readableStreamLikeToAsyncGenerator = void 0;
  var ye = Mt();
  function we(xe) {
    return fe(this, arguments, function() {
      var Oe, $e, Re, Ne;
      return oe(this, function(je) {
        switch (je.label) {
          case 0:
            Oe = xe.getReader(), je.label = 1;
          case 1:
            je.trys.push([1, , 9, 10]), je.label = 2;
          case 2:
            return [4, ae(Oe.read())];
          case 3:
            return $e = je.sent(), Re = $e.value, Ne = $e.done, Ne ? [4, ae(void 0)] : [3, 5];
          case 4:
            return [2, je.sent()];
          case 5:
            return [4, ae(Re)];
          case 6:
            return [4, je.sent()];
          case 7:
            return je.sent(), [3, 2];
          case 8:
            return [3, 10];
          case 9:
            return Oe.releaseLock(), [7];
          case 10:
            return [2];
        }
      });
    });
  }
  ne.readableStreamLikeToAsyncGenerator = we;
  function _e(xe) {
    return ye.isFunction(xe == null ? void 0 : xe.getReader);
  }
  ne.isReadableStreamLike = _e;
}), _t = M((ne) => {
  var oe = ne && ne.__awaiter || function(St, Nt, Ft, Vt) {
    function on(tn) {
      return tn instanceof Ft ? tn : new Ft(function(_n) {
        _n(tn);
      });
    }
    return new (Ft || (Ft = Promise))(function(tn, _n) {
      function en(hn) {
        try {
          Ht(Vt.next(hn));
        } catch (kn) {
          _n(kn);
        }
      }
      function dn(hn) {
        try {
          Ht(Vt.throw(hn));
        } catch (kn) {
          _n(kn);
        }
      }
      function Ht(hn) {
        hn.done ? tn(hn.value) : on(hn.value).then(en, dn);
      }
      Ht((Vt = Vt.apply(St, Nt || [])).next());
    });
  }, ae = ne && ne.__generator || function(St, Nt) {
    var Ft = { label: 0, sent: function() {
      if (tn[0] & 1)
        throw tn[1];
      return tn[1];
    }, trys: [], ops: [] }, Vt, on, tn, _n;
    return _n = { next: en(0), throw: en(1), return: en(2) }, typeof Symbol == "function" && (_n[Symbol.iterator] = function() {
      return this;
    }), _n;
    function en(Ht) {
      return function(hn) {
        return dn([Ht, hn]);
      };
    }
    function dn(Ht) {
      if (Vt)
        throw new TypeError("Generator is already executing.");
      for (; Ft; )
        try {
          if (Vt = 1, on && (tn = Ht[0] & 2 ? on.return : Ht[0] ? on.throw || ((tn = on.return) && tn.call(on), 0) : on.next) && !(tn = tn.call(on, Ht[1])).done)
            return tn;
          switch (on = 0, tn && (Ht = [Ht[0] & 2, tn.value]), Ht[0]) {
            case 0:
            case 1:
              tn = Ht;
              break;
            case 4:
              return Ft.label++, { value: Ht[1], done: !1 };
            case 5:
              Ft.label++, on = Ht[1], Ht = [0];
              continue;
            case 7:
              Ht = Ft.ops.pop(), Ft.trys.pop();
              continue;
            default:
              if (tn = Ft.trys, !(tn = tn.length > 0 && tn[tn.length - 1]) && (Ht[0] === 6 || Ht[0] === 2)) {
                Ft = 0;
                continue;
              }
              if (Ht[0] === 3 && (!tn || Ht[1] > tn[0] && Ht[1] < tn[3])) {
                Ft.label = Ht[1];
                break;
              }
              if (Ht[0] === 6 && Ft.label < tn[1]) {
                Ft.label = tn[1], tn = Ht;
                break;
              }
              if (tn && Ft.label < tn[2]) {
                Ft.label = tn[2], Ft.ops.push(Ht);
                break;
              }
              tn[2] && Ft.ops.pop(), Ft.trys.pop();
              continue;
          }
          Ht = Nt.call(St, Ft);
        } catch (hn) {
          Ht = [6, hn], on = 0;
        } finally {
          Vt = tn = 0;
        }
      if (Ht[0] & 5)
        throw Ht[1];
      return { value: Ht[0] ? Ht[1] : void 0, done: !0 };
    }
  }, fe = ne && ne.__asyncValues || function(St) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var Nt = St[Symbol.asyncIterator], Ft;
    return Nt ? Nt.call(St) : (St = typeof ye == "function" ? ye(St) : St[Symbol.iterator](), Ft = {}, Vt("next"), Vt("throw"), Vt("return"), Ft[Symbol.asyncIterator] = function() {
      return this;
    }, Ft);
    function Vt(tn) {
      Ft[tn] = St[tn] && function(_n) {
        return new Promise(function(en, dn) {
          _n = St[tn](_n), on(en, dn, _n.done, _n.value);
        });
      };
    }
    function on(tn, _n, en, dn) {
      Promise.resolve(dn).then(function(Ht) {
        tn({ value: Ht, done: en });
      }, _n);
    }
  }, ye = ne && ne.__values || function(St) {
    var Nt = typeof Symbol == "function" && Symbol.iterator, Ft = Nt && St[Nt], Vt = 0;
    if (Ft)
      return Ft.call(St);
    if (St && typeof St.length == "number")
      return { next: function() {
        return St && Vt >= St.length && (St = void 0), { value: St && St[Vt++], done: !St };
      } };
    throw new TypeError(Nt ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromReadableStreamLike = ne.fromAsyncIterable = ne.fromIterable = ne.fromPromise = ne.fromArrayLike = ne.fromInteropObservable = ne.innerFrom = void 0;
  var we = sS(), _e = tA(), xe = qt(), Oe = rA(), $e = nA(), Re = iA(), Ne = oA(), je = mS(), Be = Mt(), ze = Fk(), He = uh();
  function qe(St) {
    if (St instanceof xe.Observable)
      return St;
    if (St != null) {
      if (Oe.isInteropObservable(St))
        return Ye(St);
      if (we.isArrayLike(St))
        return ot(St);
      if (_e.isPromise(St))
        return tt(St);
      if ($e.isAsyncIterable(St))
        return ht(St);
      if (Ne.isIterable(St))
        return it(St);
      if (je.isReadableStreamLike(St))
        return gt(St);
    }
    throw Re.createInvalidObservableTypeError(St);
  }
  ne.innerFrom = qe;
  function Ye(St) {
    return new xe.Observable(function(Nt) {
      var Ft = St[He.observable]();
      if (Be.isFunction(Ft.subscribe))
        return Ft.subscribe(Nt);
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  ne.fromInteropObservable = Ye;
  function ot(St) {
    return new xe.Observable(function(Nt) {
      for (var Ft = 0; Ft < St.length && !Nt.closed; Ft++)
        Nt.next(St[Ft]);
      Nt.complete();
    });
  }
  ne.fromArrayLike = ot;
  function tt(St) {
    return new xe.Observable(function(Nt) {
      St.then(function(Ft) {
        Nt.closed || (Nt.next(Ft), Nt.complete());
      }, function(Ft) {
        return Nt.error(Ft);
      }).then(null, ze.reportUnhandledError);
    });
  }
  ne.fromPromise = tt;
  function it(St) {
    return new xe.Observable(function(Nt) {
      var Ft, Vt;
      try {
        for (var on = ye(St), tn = on.next(); !tn.done; tn = on.next()) {
          var _n = tn.value;
          if (Nt.next(_n), Nt.closed)
            return;
        }
      } catch (en) {
        Ft = { error: en };
      } finally {
        try {
          tn && !tn.done && (Vt = on.return) && Vt.call(on);
        } finally {
          if (Ft)
            throw Ft.error;
        }
      }
      Nt.complete();
    });
  }
  ne.fromIterable = it;
  function ht(St) {
    return new xe.Observable(function(Nt) {
      At(St, Nt).catch(function(Ft) {
        return Nt.error(Ft);
      });
    });
  }
  ne.fromAsyncIterable = ht;
  function gt(St) {
    return ht(je.readableStreamLikeToAsyncGenerator(St));
  }
  ne.fromReadableStreamLike = gt;
  function At(St, Nt) {
    var Ft, Vt, on, tn;
    return oe(this, void 0, void 0, function() {
      var _n, en;
      return ae(this, function(dn) {
        switch (dn.label) {
          case 0:
            dn.trys.push([0, 5, 6, 11]), Ft = fe(St), dn.label = 1;
          case 1:
            return [4, Ft.next()];
          case 2:
            if (Vt = dn.sent(), !!Vt.done)
              return [3, 4];
            if (_n = Vt.value, Nt.next(_n), Nt.closed)
              return [2];
            dn.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return en = dn.sent(), on = { error: en }, [3, 11];
          case 6:
            return dn.trys.push([6, , 9, 10]), Vt && !Vt.done && (tn = Ft.return) ? [4, tn.call(Ft)] : [3, 8];
          case 7:
            dn.sent(), dn.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (on)
              throw on.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return Nt.complete(), [2];
        }
      });
    });
  }
}), Au = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.executeSchedule = void 0;
  function oe(ae, fe, ye, we, _e) {
    we === void 0 && (we = 0), _e === void 0 && (_e = !1);
    var xe = fe.schedule(function() {
      ye(), _e ? ae.add(this.schedule(null, we)) : this.unsubscribe();
    }, we);
    if (ae.add(xe), !_e)
      return xe;
  }
  ne.executeSchedule = oe;
}), ph = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeOn = void 0;
  var oe = Au(), ae = he(), fe = Ae();
  function ye(we, _e) {
    return _e === void 0 && (_e = 0), ae.operate(function(xe, Oe) {
      xe.subscribe(fe.createOperatorSubscriber(Oe, function($e) {
        return oe.executeSchedule(Oe, we, function() {
          return Oe.next($e);
        }, _e);
      }, function() {
        return oe.executeSchedule(Oe, we, function() {
          return Oe.complete();
        }, _e);
      }, function($e) {
        return oe.executeSchedule(Oe, we, function() {
          return Oe.error($e);
        }, _e);
      }));
    });
  }
  ne.observeOn = ye;
}), vh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.subscribeOn = void 0;
  var oe = he();
  function ae(fe, ye) {
    return ye === void 0 && (ye = 0), oe.operate(function(we, _e) {
      _e.add(fe.schedule(function() {
        return we.subscribe(_e);
      }, ye));
    });
  }
  ne.subscribeOn = ae;
}), JI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleObservable = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(we, _e) {
    return oe.innerFrom(we).pipe(fe.subscribeOn(_e), ae.observeOn(_e));
  }
  ne.scheduleObservable = ye;
}), ZI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.schedulePromise = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(we, _e) {
    return oe.innerFrom(we).pipe(fe.subscribeOn(_e), ae.observeOn(_e));
  }
  ne.schedulePromise = ye;
}), e3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleArray = void 0;
  var oe = qt();
  function ae(fe, ye) {
    return new oe.Observable(function(we) {
      var _e = 0;
      return ye.schedule(function() {
        _e === fe.length ? we.complete() : (we.next(fe[_e++]), we.closed || this.schedule());
      });
    });
  }
  ne.scheduleArray = ae;
}), cA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleIterable = void 0;
  var oe = qt(), ae = aA(), fe = Mt(), ye = Au();
  function we(_e, xe) {
    return new oe.Observable(function(Oe) {
      var $e;
      return ye.executeSchedule(Oe, xe, function() {
        $e = _e[ae.iterator](), ye.executeSchedule(Oe, xe, function() {
          var Re, Ne, je;
          try {
            Re = $e.next(), Ne = Re.value, je = Re.done;
          } catch (Be) {
            Oe.error(Be);
            return;
          }
          je ? Oe.complete() : Oe.next(Ne);
        }, 0, !0);
      }), function() {
        return fe.isFunction($e == null ? void 0 : $e.return) && $e.return();
      };
    });
  }
  ne.scheduleIterable = we;
}), fA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleAsyncIterable = void 0;
  var oe = qt(), ae = Au();
  function fe(ye, we) {
    if (!ye)
      throw new Error("Iterable cannot be null");
    return new oe.Observable(function(_e) {
      ae.executeSchedule(_e, we, function() {
        var xe = ye[Symbol.asyncIterator]();
        ae.executeSchedule(_e, we, function() {
          xe.next().then(function(Oe) {
            Oe.done ? _e.complete() : _e.next(Oe.value);
          });
        }, 0, !0);
      });
    });
  }
  ne.scheduleAsyncIterable = fe;
}), n3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleReadableStreamLike = void 0;
  var oe = fA(), ae = mS();
  function fe(ye, we) {
    return oe.scheduleAsyncIterable(ae.readableStreamLikeToAsyncGenerator(ye), we);
  }
  ne.scheduleReadableStreamLike = fe;
}), dA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduled = void 0;
  var oe = JI(), ae = ZI(), fe = e3(), ye = cA(), we = fA(), _e = rA(), xe = tA(), Oe = sS(), $e = oA(), Re = nA(), Ne = iA(), je = mS(), Be = n3();
  function ze(He, qe) {
    if (He != null) {
      if (_e.isInteropObservable(He))
        return oe.scheduleObservable(He, qe);
      if (Oe.isArrayLike(He))
        return fe.scheduleArray(He, qe);
      if (xe.isPromise(He))
        return ae.schedulePromise(He, qe);
      if (Re.isAsyncIterable(He))
        return we.scheduleAsyncIterable(He, qe);
      if ($e.isIterable(He))
        return ye.scheduleIterable(He, qe);
      if (je.isReadableStreamLike(He))
        return Be.scheduleReadableStreamLike(He, qe);
    }
    throw Ne.createInvalidObservableTypeError(He);
  }
  ne.scheduled = ze;
}), Ja = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.from = void 0;
  var oe = dA(), ae = _t();
  function fe(ye, we) {
    return we ? oe.scheduled(ye, we) : ae.innerFrom(ye);
  }
  ne.from = fe;
}), TS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.of = void 0;
  var oe = ki(), ae = Ja();
  function fe() {
    for (var ye = [], we = 0; we < arguments.length; we++)
      ye[we] = arguments[we];
    var _e = oe.popScheduler(ye);
    return ae.from(ye, _e);
  }
  ne.of = fe;
}), pA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwError = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye, we) {
    var _e = ae.isFunction(ye) ? ye : function() {
      return ye;
    }, xe = function(Oe) {
      return Oe.error(_e());
    };
    return new oe.Observable(we ? function(Oe) {
      return we.schedule(xe, 0, Oe);
    } : xe);
  }
  ne.throwError = fe;
}), AS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeNotification = ne.Notification = ne.NotificationKind = void 0;
  var oe = ba(), ae = TS(), fe = pA(), ye = Mt();
  (function(xe) {
    xe.NEXT = "N", xe.ERROR = "E", xe.COMPLETE = "C";
  })(ne.NotificationKind || (ne.NotificationKind = {}));
  var we = function() {
    function xe(Oe, $e, Re) {
      this.kind = Oe, this.value = $e, this.error = Re, this.hasValue = Oe === "N";
    }
    return xe.prototype.observe = function(Oe) {
      return _e(this, Oe);
    }, xe.prototype.do = function(Oe, $e, Re) {
      var Ne = this, je = Ne.kind, Be = Ne.value, ze = Ne.error;
      return je === "N" ? Oe == null ? void 0 : Oe(Be) : je === "E" ? $e == null ? void 0 : $e(ze) : Re == null ? void 0 : Re();
    }, xe.prototype.accept = function(Oe, $e, Re) {
      var Ne;
      return ye.isFunction((Ne = Oe) === null || Ne === void 0 ? void 0 : Ne.next) ? this.observe(Oe) : this.do(Oe, $e, Re);
    }, xe.prototype.toObservable = function() {
      var Oe = this, $e = Oe.kind, Re = Oe.value, Ne = Oe.error, je = $e === "N" ? ae.of(Re) : $e === "E" ? fe.throwError(function() {
        return Ne;
      }) : $e === "C" ? oe.EMPTY : 0;
      if (!je)
        throw new TypeError("Unexpected notification kind " + $e);
      return je;
    }, xe.createNext = function(Oe) {
      return new xe("N", Oe);
    }, xe.createError = function(Oe) {
      return new xe("E", void 0, Oe);
    }, xe.createComplete = function() {
      return xe.completeNotification;
    }, xe.completeNotification = new xe("C"), xe;
  }();
  ne.Notification = we;
  function _e(xe, Oe) {
    var $e, Re, Ne, je = xe, Be = je.kind, ze = je.value, He = je.error;
    if (typeof Be != "string")
      throw new TypeError('Invalid notification, missing "kind"');
    Be === "N" ? ($e = Oe.next) === null || $e === void 0 || $e.call(Oe, ze) : Be === "E" ? (Re = Oe.error) === null || Re === void 0 || Re.call(Oe, He) : (Ne = Oe.complete) === null || Ne === void 0 || Ne.call(Oe);
  }
  ne.observeNotification = _e;
}), o3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isObservable = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye) {
    return !!ye && (ye instanceof oe.Observable || ae.isFunction(ye.lift) && ae.isFunction(ye.subscribe));
  }
  ne.isObservable = fe;
}), $l = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EmptyError = void 0;
  var oe = Il();
  ne.EmptyError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "EmptyError", this.message = "no elements in sequence";
    };
  });
}), u3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.lastValueFrom = void 0;
  var oe = $l();
  function ae(fe, ye) {
    var we = typeof ye == "object";
    return new Promise(function(_e, xe) {
      var Oe = !1, $e;
      fe.subscribe({ next: function(Re) {
        $e = Re, Oe = !0;
      }, error: xe, complete: function() {
        Oe ? _e($e) : we ? _e(ye.defaultValue) : xe(new oe.EmptyError());
      } });
    });
  }
  ne.lastValueFrom = ae;
}), l3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.firstValueFrom = void 0;
  var oe = $l(), ae = Sd();
  function fe(ye, we) {
    var _e = typeof we == "object";
    return new Promise(function(xe, Oe) {
      var $e = new ae.SafeSubscriber({ next: function(Re) {
        xe(Re), $e.unsubscribe();
      }, error: Oe, complete: function() {
        _e ? xe(we.defaultValue) : Oe(new oe.EmptyError());
      } });
      ye.subscribe($e);
    });
  }
  ne.firstValueFrom = fe;
}), vA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ArgumentOutOfRangeError = void 0;
  var oe = Il();
  ne.ArgumentOutOfRangeError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ArgumentOutOfRangeError", this.message = "argument out of range";
    };
  });
}), mA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.NotFoundError = void 0;
  var oe = Il();
  ne.NotFoundError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "NotFoundError", this.message = fe;
    };
  });
}), hA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.SequenceError = void 0;
  var oe = Il();
  ne.SequenceError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "SequenceError", this.message = fe;
    };
  });
}), zS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isValidDate = void 0;
  function oe(ae) {
    return ae instanceof Date && !isNaN(ae);
  }
  ne.isValidDate = oe;
}), qS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeout = ne.TimeoutError = void 0;
  var oe = Ti(), ae = zS(), fe = he(), ye = _t(), we = Il(), _e = Ae(), xe = Au();
  ne.TimeoutError = we.createErrorClass(function(Re) {
    return function(Ne) {
      Ne === void 0 && (Ne = null), Re(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = Ne;
    };
  });
  function Oe(Re, Ne) {
    var je = ae.isValidDate(Re) ? { first: Re } : typeof Re == "number" ? { each: Re } : Re, Be = je.first, ze = je.each, He = je.with, qe = He === void 0 ? $e : He, Ye = je.scheduler, ot = Ye === void 0 ? Ne ?? oe.asyncScheduler : Ye, tt = je.meta, it = tt === void 0 ? null : tt;
    if (Be == null && ze == null)
      throw new TypeError("No timeout provided.");
    return fe.operate(function(ht, gt) {
      var At, St, Nt = null, Ft = 0, Vt = function(on) {
        St = xe.executeSchedule(gt, ot, function() {
          try {
            At.unsubscribe(), ye.innerFrom(qe({ meta: it, lastValue: Nt, seen: Ft })).subscribe(gt);
          } catch (tn) {
            gt.error(tn);
          }
        }, on);
      };
      At = ht.subscribe(_e.createOperatorSubscriber(gt, function(on) {
        St == null || St.unsubscribe(), Ft++, gt.next(Nt = on), ze > 0 && Vt(ze);
      }, void 0, void 0, function() {
        St != null && St.closed || (St == null || St.unsubscribe()), Nt = null;
      })), !Ft && Vt(Be != null ? typeof Be == "number" ? Be : +Be - ot.now() : ze);
    });
  }
  ne.timeout = Oe;
  function $e(Re) {
    throw new ne.TimeoutError(Re);
  }
}), Wl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.map = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, we) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        xe.next(ye.call(we, $e, Oe++));
      }));
    });
  }
  ne.map = fe;
}), Gl = M((ne) => {
  var oe = ne && ne.__read || function(xe, Oe) {
    var $e = typeof Symbol == "function" && xe[Symbol.iterator];
    if (!$e)
      return xe;
    var Re = $e.call(xe), Ne, je = [], Be;
    try {
      for (; (Oe === void 0 || Oe-- > 0) && !(Ne = Re.next()).done; )
        je.push(Ne.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Ne && !Ne.done && ($e = Re.return) && $e.call(Re);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return je;
  }, ae = ne && ne.__spreadArray || function(xe, Oe) {
    for (var $e = 0, Re = Oe.length, Ne = xe.length; $e < Re; $e++, Ne++)
      xe[Ne] = Oe[$e];
    return xe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapOneOrManyArgs = void 0;
  var fe = Wl(), ye = Array.isArray;
  function we(xe, Oe) {
    return ye(Oe) ? xe.apply(void 0, ae([], oe(Oe))) : xe(Oe);
  }
  function _e(xe) {
    return fe.map(function(Oe) {
      return we(xe, Oe);
    });
  }
  ne.mapOneOrManyArgs = _e;
}), gA = M((ne) => {
  var oe = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallbackInternals = void 0;
  var fe = dh(), ye = qt(), we = vh(), _e = Gl(), xe = ph(), Oe = iS();
  function $e(Re, Ne, je, Be) {
    if (je)
      if (fe.isScheduler(je))
        Be = je;
      else
        return function() {
          for (var ze = [], He = 0; He < arguments.length; He++)
            ze[He] = arguments[He];
          return $e(Re, Ne, Be).apply(this, ze).pipe(_e.mapOneOrManyArgs(je));
        };
    return Be ? function() {
      for (var ze = [], He = 0; He < arguments.length; He++)
        ze[He] = arguments[He];
      return $e(Re, Ne).apply(this, ze).pipe(we.subscribeOn(Be), xe.observeOn(Be));
    } : function() {
      for (var ze = this, He = [], qe = 0; qe < arguments.length; qe++)
        He[qe] = arguments[qe];
      var Ye = new Oe.AsyncSubject(), ot = !0;
      return new ye.Observable(function(tt) {
        var it = Ye.subscribe(tt);
        if (ot) {
          ot = !1;
          var ht = !1, gt = !1;
          Ne.apply(ze, ae(ae([], oe(He)), [function() {
            for (var At = [], St = 0; St < arguments.length; St++)
              At[St] = arguments[St];
            if (Re) {
              var Nt = At.shift();
              if (Nt != null) {
                Ye.error(Nt);
                return;
              }
            }
            Ye.next(1 < At.length ? At : At[0]), gt = !0, ht && Ye.complete();
          }])), gt && Ye.complete(), ht = !0;
        }
        return it;
      });
    };
  }
  ne.bindCallbackInternals = $e;
}), c3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallback = void 0;
  var oe = gA();
  function ae(fe, ye, we) {
    return oe.bindCallbackInternals(!1, fe, ye, we);
  }
  ne.bindCallback = ae;
}), f3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindNodeCallback = void 0;
  var oe = gA();
  function ae(fe, ye, we) {
    return oe.bindCallbackInternals(!0, fe, ye, we);
  }
  ne.bindNodeCallback = ae;
}), bA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsArgArrayOrObject = void 0;
  var oe = Array.isArray, ae = Object.getPrototypeOf, fe = Object.prototype, ye = Object.keys;
  function we(xe) {
    if (xe.length === 1) {
      var Oe = xe[0];
      if (oe(Oe))
        return { args: Oe, keys: null };
      if (_e(Oe)) {
        var $e = ye(Oe);
        return { args: $e.map(function(Re) {
          return Oe[Re];
        }), keys: $e };
      }
    }
    return { args: xe, keys: null };
  }
  ne.argsArgArrayOrObject = we;
  function _e(xe) {
    return xe && typeof xe == "object" && ae(xe) === fe;
  }
}), SA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createObject = void 0;
  function oe(ae, fe) {
    return ae.reduce(function(ye, we, _e) {
      return ye[we] = fe[_e], ye;
    }, {});
  }
  ne.createObject = oe;
}), WS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestInit = ne.combineLatest = void 0;
  var oe = qt(), ae = bA(), fe = Ja(), ye = Hn(), we = Gl(), _e = ki(), xe = SA(), Oe = Ae(), $e = Au();
  function Re() {
    for (var Be = [], ze = 0; ze < arguments.length; ze++)
      Be[ze] = arguments[ze];
    var He = _e.popScheduler(Be), qe = _e.popResultSelector(Be), Ye = ae.argsArgArrayOrObject(Be), ot = Ye.args, tt = Ye.keys;
    if (ot.length === 0)
      return fe.from([], He);
    var it = new oe.Observable(Ne(ot, He, tt ? function(ht) {
      return xe.createObject(tt, ht);
    } : ye.identity));
    return qe ? it.pipe(we.mapOneOrManyArgs(qe)) : it;
  }
  ne.combineLatest = Re;
  function Ne(Be, ze, He) {
    return He === void 0 && (He = ye.identity), function(qe) {
      je(ze, function() {
        for (var Ye = Be.length, ot = new Array(Ye), tt = Ye, it = Ye, ht = function(At) {
          je(ze, function() {
            var St = fe.from(Be[At], ze), Nt = !1;
            St.subscribe(Oe.createOperatorSubscriber(qe, function(Ft) {
              ot[At] = Ft, Nt || (Nt = !0, it--), it || qe.next(He(ot.slice()));
            }, function() {
              --tt || qe.complete();
            }));
          }, qe);
        }, gt = 0; gt < Ye; gt++)
          ht(gt);
      }, qe);
    };
  }
  ne.combineLatestInit = Ne;
  function je(Be, ze, He) {
    Be ? $e.executeSchedule(He, Be, ze) : ze();
  }
}), GS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeInternals = void 0;
  var oe = _t(), ae = Au(), fe = Ae();
  function ye(we, _e, xe, Oe, $e, Re, Ne, je) {
    var Be = [], ze = 0, He = 0, qe = !1, Ye = function() {
      qe && !Be.length && !ze && _e.complete();
    }, ot = function(it) {
      return ze < Oe ? tt(it) : Be.push(it);
    }, tt = function(it) {
      Re && _e.next(it), ze++;
      var ht = !1;
      oe.innerFrom(xe(it, He++)).subscribe(fe.createOperatorSubscriber(_e, function(gt) {
        $e == null || $e(gt), Re ? ot(gt) : _e.next(gt);
      }, function() {
        ht = !0;
      }, void 0, function() {
        if (ht)
          try {
            ze--;
            for (var gt = function() {
              var At = Be.shift();
              Ne ? ae.executeSchedule(_e, Ne, function() {
                return tt(At);
              }) : tt(At);
            }; Be.length && ze < Oe; )
              gt();
            Ye();
          } catch (At) {
            _e.error(At);
          }
      }));
    };
    return we.subscribe(fe.createOperatorSubscriber(_e, ot, function() {
      qe = !0, Ye();
    })), function() {
      je == null || je();
    };
  }
  ne.mergeInternals = ye;
}), Mu = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = GS(), we = Mt();
  function _e(xe, Oe, $e) {
    return $e === void 0 && ($e = 1 / 0), we.isFunction(Oe) ? _e(function(Re, Ne) {
      return oe.map(function(je, Be) {
        return Oe(Re, je, Ne, Be);
      })(ae.innerFrom(xe(Re, Ne)));
    }, $e) : (typeof Oe == "number" && ($e = Oe), fe.operate(function(Re, Ne) {
      return ye.mergeInternals(Re, Ne, xe, $e);
    }));
  }
  ne.mergeMap = _e;
}), mh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeAll = void 0;
  var oe = Mu(), ae = Hn();
  function fe(ye) {
    return ye === void 0 && (ye = 1 / 0), oe.mergeMap(ae.identity, ye);
  }
  ne.mergeAll = fe;
}), JS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatAll = void 0;
  var oe = mh();
  function ae() {
    return oe.mergeAll(1);
  }
  ne.concatAll = ae;
}), hh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var oe = JS(), ae = ki(), fe = Ja();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return oe.concatAll()(fe.from(we, ae.popScheduler(we)));
  }
  ne.concat = ye;
}), yh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defer = void 0;
  var oe = qt(), ae = _t();
  function fe(ye) {
    return new oe.Observable(function(we) {
      ae.innerFrom(ye()).subscribe(we);
    });
  }
  ne.defer = fe;
}), b3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connectable = void 0;
  var oe = Tn(), ae = qt(), fe = yh(), ye = { connector: function() {
    return new oe.Subject();
  }, resetOnDisconnect: !0 };
  function we(_e, xe) {
    xe === void 0 && (xe = ye);
    var Oe = null, $e = xe.connector, Re = xe.resetOnDisconnect, Ne = Re === void 0 ? !0 : Re, je = $e(), Be = new ae.Observable(function(ze) {
      return je.subscribe(ze);
    });
    return Be.connect = function() {
      return (!Oe || Oe.closed) && (Oe = fe.defer(function() {
        return _e;
      }).subscribe(je), Ne && Oe.add(function() {
        return je = $e();
      })), Oe;
    }, Be;
  }
  ne.connectable = we;
}), S3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.forkJoin = void 0;
  var oe = qt(), ae = bA(), fe = _t(), ye = ki(), we = Ae(), _e = Gl(), xe = SA();
  function Oe() {
    for (var $e = [], Re = 0; Re < arguments.length; Re++)
      $e[Re] = arguments[Re];
    var Ne = ye.popResultSelector($e), je = ae.argsArgArrayOrObject($e), Be = je.args, ze = je.keys, He = new oe.Observable(function(qe) {
      var Ye = Be.length;
      if (!Ye) {
        qe.complete();
        return;
      }
      for (var ot = new Array(Ye), tt = Ye, it = Ye, ht = function(At) {
        var St = !1;
        fe.innerFrom(Be[At]).subscribe(we.createOperatorSubscriber(qe, function(Nt) {
          St || (St = !0, it--), ot[At] = Nt;
        }, function() {
          return tt--;
        }, void 0, function() {
          (!tt || !St) && (it || qe.next(ze ? xe.createObject(ze, ot) : ot), qe.complete());
        }));
      }, gt = 0; gt < Ye; gt++)
        ht(gt);
    });
    return Ne ? He.pipe(_e.mapOneOrManyArgs(Ne)) : He;
  }
  ne.forkJoin = Oe;
}), w3 = M((ne) => {
  var oe = ne && ne.__read || function(qe, Ye) {
    var ot = typeof Symbol == "function" && qe[Symbol.iterator];
    if (!ot)
      return qe;
    var tt = ot.call(qe), it, ht = [], gt;
    try {
      for (; (Ye === void 0 || Ye-- > 0) && !(it = tt.next()).done; )
        ht.push(it.value);
    } catch (At) {
      gt = { error: At };
    } finally {
      try {
        it && !it.done && (ot = tt.return) && ot.call(tt);
      } finally {
        if (gt)
          throw gt.error;
      }
    }
    return ht;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEvent = void 0;
  var ae = _t(), fe = qt(), ye = Mu(), we = sS(), _e = Mt(), xe = Gl(), Oe = ["addListener", "removeListener"], $e = ["addEventListener", "removeEventListener"], Re = ["on", "off"];
  function Ne(qe, Ye, ot, tt) {
    if (_e.isFunction(ot) && (tt = ot, ot = void 0), tt)
      return Ne(qe, Ye, ot).pipe(xe.mapOneOrManyArgs(tt));
    var it = oe(He(qe) ? $e.map(function(At) {
      return function(St) {
        return qe[At](Ye, St, ot);
      };
    }) : Be(qe) ? Oe.map(je(qe, Ye)) : ze(qe) ? Re.map(je(qe, Ye)) : [], 2), ht = it[0], gt = it[1];
    if (!ht && we.isArrayLike(qe))
      return ye.mergeMap(function(At) {
        return Ne(At, Ye, ot);
      })(ae.innerFrom(qe));
    if (!ht)
      throw new TypeError("Invalid event target");
    return new fe.Observable(function(At) {
      var St = function() {
        for (var Nt = [], Ft = 0; Ft < arguments.length; Ft++)
          Nt[Ft] = arguments[Ft];
        return At.next(1 < Nt.length ? Nt : Nt[0]);
      };
      return ht(St), function() {
        return gt(St);
      };
    });
  }
  ne.fromEvent = Ne;
  function je(qe, Ye) {
    return function(ot) {
      return function(tt) {
        return qe[ot](Ye, tt);
      };
    };
  }
  function Be(qe) {
    return _e.isFunction(qe.addListener) && _e.isFunction(qe.removeListener);
  }
  function ze(qe) {
    return _e.isFunction(qe.on) && _e.isFunction(qe.off);
  }
  function He(qe) {
    return _e.isFunction(qe.addEventListener) && _e.isFunction(qe.removeEventListener);
  }
}), E3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEventPattern = void 0;
  var oe = qt(), ae = Mt(), fe = Gl();
  function ye(we, _e, xe) {
    return xe ? ye(we, _e).pipe(fe.mapOneOrManyArgs(xe)) : new oe.Observable(function(Oe) {
      var $e = function() {
        for (var Ne = [], je = 0; je < arguments.length; je++)
          Ne[je] = arguments[je];
        return Oe.next(Ne.length === 1 ? Ne[0] : Ne);
      }, Re = we($e);
      return ae.isFunction(_e) ? function() {
        return _e($e, Re);
      } : void 0;
    });
  }
  ne.fromEventPattern = ye;
}), R3 = M((ne) => {
  var oe = ne && ne.__generator || function(xe, Oe) {
    var $e = { label: 0, sent: function() {
      if (je[0] & 1)
        throw je[1];
      return je[1];
    }, trys: [], ops: [] }, Re, Ne, je, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(qe) {
      return function(Ye) {
        return He([qe, Ye]);
      };
    }
    function He(qe) {
      if (Re)
        throw new TypeError("Generator is already executing.");
      for (; $e; )
        try {
          if (Re = 1, Ne && (je = qe[0] & 2 ? Ne.return : qe[0] ? Ne.throw || ((je = Ne.return) && je.call(Ne), 0) : Ne.next) && !(je = je.call(Ne, qe[1])).done)
            return je;
          switch (Ne = 0, je && (qe = [qe[0] & 2, je.value]), qe[0]) {
            case 0:
            case 1:
              je = qe;
              break;
            case 4:
              return $e.label++, { value: qe[1], done: !1 };
            case 5:
              $e.label++, Ne = qe[1], qe = [0];
              continue;
            case 7:
              qe = $e.ops.pop(), $e.trys.pop();
              continue;
            default:
              if (je = $e.trys, !(je = je.length > 0 && je[je.length - 1]) && (qe[0] === 6 || qe[0] === 2)) {
                $e = 0;
                continue;
              }
              if (qe[0] === 3 && (!je || qe[1] > je[0] && qe[1] < je[3])) {
                $e.label = qe[1];
                break;
              }
              if (qe[0] === 6 && $e.label < je[1]) {
                $e.label = je[1], je = qe;
                break;
              }
              if (je && $e.label < je[2]) {
                $e.label = je[2], $e.ops.push(qe);
                break;
              }
              je[2] && $e.ops.pop(), $e.trys.pop();
              continue;
          }
          qe = Oe.call(xe, $e);
        } catch (Ye) {
          qe = [6, Ye], Ne = 0;
        } finally {
          Re = je = 0;
        }
      if (qe[0] & 5)
        throw qe[1];
      return { value: qe[0] ? qe[1] : void 0, done: !0 };
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.generate = void 0;
  var ae = Hn(), fe = dh(), ye = yh(), we = cA();
  function _e(xe, Oe, $e, Re, Ne) {
    var je, Be, ze, He;
    arguments.length === 1 ? (je = xe, He = je.initialState, Oe = je.condition, $e = je.iterate, Be = je.resultSelector, ze = Be === void 0 ? ae.identity : Be, Ne = je.scheduler) : (He = xe, !Re || fe.isScheduler(Re) ? (ze = ae.identity, Ne = Re) : ze = Re);
    function qe() {
      var Ye;
      return oe(this, function(ot) {
        switch (ot.label) {
          case 0:
            Ye = He, ot.label = 1;
          case 1:
            return !Oe || Oe(Ye) ? [4, ze(Ye)] : [3, 4];
          case 2:
            ot.sent(), ot.label = 3;
          case 3:
            return Ye = $e(Ye), [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return ye.defer(Ne ? function() {
      return we.scheduleIterable(qe(), Ne);
    } : qe);
  }
  ne.generate = _e;
}), O3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iif = void 0;
  var oe = yh();
  function ae(fe, ye, we) {
    return oe.defer(function() {
      return fe() ? ye : we;
    });
  }
  ne.iif = ae;
}), Kl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timer = void 0;
  var oe = qt(), ae = Ti(), fe = dh(), ye = zS();
  function we(_e, xe, Oe) {
    _e === void 0 && (_e = 0), Oe === void 0 && (Oe = ae.async);
    var $e = -1;
    return xe != null && (fe.isScheduler(xe) ? Oe = xe : $e = xe), new oe.Observable(function(Re) {
      var Ne = ye.isValidDate(_e) ? +_e - Oe.now() : _e;
      Ne < 0 && (Ne = 0);
      var je = 0;
      return Oe.schedule(function() {
        Re.closed || (Re.next(je++), 0 <= $e ? this.schedule(void 0, $e) : Re.complete());
      }, Ne);
    });
  }
  ne.timer = we;
}), wA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = void 0;
  var oe = Ti(), ae = Kl();
  function fe(ye, we) {
    return ye === void 0 && (ye = 0), we === void 0 && (we = oe.asyncScheduler), ye < 0 && (ye = 0), ae.timer(ye, ye, we);
  }
  ne.interval = fe;
}), k3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var oe = mh(), ae = _t(), fe = ba(), ye = ki(), we = Ja();
  function _e() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    var $e = ye.popScheduler(xe), Re = ye.popNumber(xe, 1 / 0), Ne = xe;
    return Ne.length ? Ne.length === 1 ? ae.innerFrom(Ne[0]) : oe.mergeAll(Re)(we.from(Ne, $e)) : fe.EMPTY;
  }
  ne.merge = _e;
}), xA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.never = ne.NEVER = void 0;
  var oe = qt(), ae = On();
  ne.NEVER = new oe.Observable(ae.noop);
  function fe() {
    return ne.NEVER;
  }
  ne.never = fe;
}), Sc = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsOrArgArray = void 0;
  var oe = Array.isArray;
  function ae(fe) {
    return fe.length === 1 && oe(fe[0]) ? fe[0] : fe;
  }
  ne.argsOrArgArray = ae;
}), P3 = M((ne) => {
  var oe = ne && ne.__read || function($e, Re) {
    var Ne = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Ne)
      return $e;
    var je = Ne.call($e), Be, ze = [], He;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(Be = je.next()).done; )
        ze.push(Be.value);
    } catch (qe) {
      He = { error: qe };
    } finally {
      try {
        Be && !Be.done && (Ne = je.return) && Ne.call(je);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function($e, Re) {
    for (var Ne = 0, je = Re.length, Be = $e.length; Ne < je; Ne++, Be++)
      $e[Be] = Re[Ne];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var fe = he(), ye = _t(), we = Sc(), _e = Ae(), xe = On();
  function Oe() {
    for (var $e = [], Re = 0; Re < arguments.length; Re++)
      $e[Re] = arguments[Re];
    var Ne = we.argsOrArgArray($e);
    return fe.operate(function(je, Be) {
      var ze = ae([je], oe(Ne)), He = function() {
        if (!Be.closed)
          if (ze.length > 0) {
            var qe = void 0;
            try {
              qe = ye.innerFrom(ze.shift());
            } catch {
              He();
              return;
            }
            var Ye = _e.createOperatorSubscriber(Be, void 0, xe.noop, xe.noop);
            qe.subscribe(Ye), Ye.add(He);
          } else
            Be.complete();
      };
      He();
    });
  }
  ne.onErrorResumeNext = Oe;
}), M3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var oe = ba(), ae = P3(), fe = Sc();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return ae.onErrorResumeNext(fe.argsOrArgArray(we))(oe.EMPTY);
  }
  ne.onErrorResumeNext = ye;
}), D3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairs = void 0;
  var oe = Ja();
  function ae(fe, ye) {
    return oe.from(Object.entries(fe), ye);
  }
  ne.pairs = ae;
}), N3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.not = void 0;
  function oe(ae, fe) {
    return function(ye, we) {
      return !ae.call(fe, ye, we);
    };
  }
  ne.not = oe;
}), _c = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.filter = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, we) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        return ye.call(we, $e, Oe++) && xe.next($e);
      }));
    });
  }
  ne.filter = fe;
}), U3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.partition = void 0;
  var oe = N3(), ae = _c(), fe = _t();
  function ye(we, _e, xe) {
    return [ae.filter(_e, xe)(fe.innerFrom(we)), ae.filter(oe.not(_e, xe))(fe.innerFrom(we))];
  }
  ne.partition = ye;
}), EA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceInit = ne.race = void 0;
  var oe = qt(), ae = _t(), fe = Sc(), ye = Ae();
  function we() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    return xe = fe.argsOrArgArray(xe), xe.length === 1 ? ae.innerFrom(xe[0]) : new oe.Observable(_e(xe));
  }
  ne.race = we;
  function _e(xe) {
    return function(Oe) {
      for (var $e = [], Re = function(je) {
        $e.push(ae.innerFrom(xe[je]).subscribe(ye.createOperatorSubscriber(Oe, function(Be) {
          if ($e) {
            for (var ze = 0; ze < $e.length; ze++)
              ze !== je && $e[ze].unsubscribe();
            $e = null;
          }
          Oe.next(Be);
        })));
      }, Ne = 0; $e && !Oe.closed && Ne < xe.length; Ne++)
        Re(Ne);
    };
  }
  ne.raceInit = _e;
}), q3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.range = void 0;
  var oe = qt(), ae = ba();
  function fe(ye, we, _e) {
    if (we == null && (we = ye, ye = 0), we <= 0)
      return ae.EMPTY;
    var xe = we + ye;
    return new oe.Observable(_e ? function(Oe) {
      var $e = ye;
      return _e.schedule(function() {
        $e < xe ? (Oe.next($e++), this.schedule()) : Oe.complete();
      });
    } : function(Oe) {
      for (var $e = ye; $e < xe && !Oe.closed; )
        Oe.next($e++);
      Oe.complete();
    });
  }
  ne.range = fe;
}), I3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.using = void 0;
  var oe = qt(), ae = _t(), fe = ba();
  function ye(we, _e) {
    return new oe.Observable(function(xe) {
      var Oe = we(), $e = _e(Oe), Re = $e ? ae.innerFrom($e) : fe.EMPTY;
      return Re.subscribe(xe), function() {
        Oe && Oe.unsubscribe();
      };
    });
  }
  ne.using = ye;
}), h_ = M((ne) => {
  var oe = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = qt(), ye = _t(), we = Sc(), _e = ba(), xe = Ae(), Oe = ki();
  function $e() {
    for (var Re = [], Ne = 0; Ne < arguments.length; Ne++)
      Re[Ne] = arguments[Ne];
    var je = Oe.popResultSelector(Re), Be = we.argsOrArgArray(Re);
    return Be.length ? new fe.Observable(function(ze) {
      var He = Be.map(function() {
        return [];
      }), qe = Be.map(function() {
        return !1;
      });
      ze.add(function() {
        He = qe = null;
      });
      for (var Ye = function(tt) {
        ye.innerFrom(Be[tt]).subscribe(xe.createOperatorSubscriber(ze, function(it) {
          if (He[tt].push(it), He.every(function(gt) {
            return gt.length;
          })) {
            var ht = He.map(function(gt) {
              return gt.shift();
            });
            ze.next(je ? je.apply(void 0, ae([], oe(ht))) : ht), He.some(function(gt, At) {
              return !gt.length && qe[At];
            }) && ze.complete();
          }
        }, function() {
          qe[tt] = !0, !He[tt].length && ze.complete();
        }));
      }, ot = 0; !ze.closed && ot < Be.length; ot++)
        Ye(ot);
      return function() {
        He = qe = null;
      };
    }) : _e.EMPTY;
  }
  ne.zip = $e;
}), H3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 });
}), CA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.audit = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye(we) {
    return oe.operate(function(_e, xe) {
      var Oe = !1, $e = null, Re = null, Ne = !1, je = function() {
        if (Re == null || Re.unsubscribe(), Re = null, Oe) {
          Oe = !1;
          var ze = $e;
          $e = null, xe.next(ze);
        }
        Ne && xe.complete();
      }, Be = function() {
        Re = null, Ne && xe.complete();
      };
      _e.subscribe(fe.createOperatorSubscriber(xe, function(ze) {
        Oe = !0, $e = ze, Re || ae.innerFrom(we(ze)).subscribe(Re = fe.createOperatorSubscriber(xe, je, Be));
      }, function() {
        Ne = !0, (!Oe || !Re || Re.closed) && xe.complete();
      }));
    });
  }
  ne.audit = ye;
}), $3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.auditTime = void 0;
  var oe = Ti(), ae = CA(), fe = Kl();
  function ye(we, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.audit(function() {
      return fe.timer(we, _e);
    });
  }
  ne.auditTime = ye;
}), Y3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.buffer = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(we) {
    return oe.operate(function(_e, xe) {
      var Oe = [];
      return _e.subscribe(fe.createOperatorSubscriber(xe, function($e) {
        return Oe.push($e);
      }, function() {
        xe.next(Oe), xe.complete();
      })), we.subscribe(fe.createOperatorSubscriber(xe, function() {
        var $e = Oe;
        Oe = [], xe.next($e);
      }, ae.noop)), function() {
        Oe = null;
      };
    });
  }
  ne.buffer = ye;
}), G3 = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferCount = void 0;
  var ae = he(), fe = Ae(), ye = ku();
  function we(_e, xe) {
    return xe === void 0 && (xe = null), xe = xe ?? _e, ae.operate(function(Oe, $e) {
      var Re = [], Ne = 0;
      Oe.subscribe(fe.createOperatorSubscriber($e, function(je) {
        var Be, ze, He, qe, Ye = null;
        Ne++ % xe === 0 && Re.push([]);
        try {
          for (var ot = oe(Re), tt = ot.next(); !tt.done; tt = ot.next()) {
            var it = tt.value;
            it.push(je), _e <= it.length && (Ye = Ye ?? [], Ye.push(it));
          }
        } catch (At) {
          Be = { error: At };
        } finally {
          try {
            tt && !tt.done && (ze = ot.return) && ze.call(ot);
          } finally {
            if (Be)
              throw Be.error;
          }
        }
        if (Ye)
          try {
            for (var ht = oe(Ye), gt = ht.next(); !gt.done; gt = ht.next()) {
              var it = gt.value;
              ye.arrRemove(Re, it), $e.next(it);
            }
          } catch (At) {
            He = { error: At };
          } finally {
            try {
              gt && !gt.done && (qe = ht.return) && qe.call(ht);
            } finally {
              if (He)
                throw He.error;
            }
          }
      }, function() {
        var je, Be;
        try {
          for (var ze = oe(Re), He = ze.next(); !He.done; He = ze.next()) {
            var qe = He.value;
            $e.next(qe);
          }
        } catch (Ye) {
          je = { error: Ye };
        } finally {
          try {
            He && !He.done && (Be = ze.return) && Be.call(ze);
          } finally {
            if (je)
              throw je.error;
          }
        }
        $e.complete();
      }, void 0, function() {
        Re = null;
      }));
    });
  }
  ne.bufferCount = we;
}), K3 = M((ne) => {
  var oe = ne && ne.__values || function(Re) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, je = Ne && Re[Ne], Be = 0;
    if (je)
      return je.call(Re);
    if (Re && typeof Re.length == "number")
      return { next: function() {
        return Re && Be >= Re.length && (Re = void 0), { value: Re && Re[Be++], done: !Re };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferTime = void 0;
  var ae = Oi(), fe = he(), ye = Ae(), we = ku(), _e = Ti(), xe = ki(), Oe = Au();
  function $e(Re) {
    for (var Ne, je, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Ne = xe.popScheduler(Be)) !== null && Ne !== void 0 ? Ne : _e.asyncScheduler, qe = (je = Be[0]) !== null && je !== void 0 ? je : null, Ye = Be[1] || 1 / 0;
    return fe.operate(function(ot, tt) {
      var it = [], ht = !1, gt = function(Nt) {
        var Ft = Nt.buffer, Vt = Nt.subs;
        Vt.unsubscribe(), we.arrRemove(it, Nt), tt.next(Ft), ht && At();
      }, At = function() {
        if (it) {
          var Nt = new ae.Subscription();
          tt.add(Nt);
          var Ft = [], Vt = { buffer: Ft, subs: Nt };
          it.push(Vt), Oe.executeSchedule(Nt, He, function() {
            return gt(Vt);
          }, Re);
        }
      };
      qe !== null && qe >= 0 ? Oe.executeSchedule(tt, He, At, qe, !0) : ht = !0, At();
      var St = ye.createOperatorSubscriber(tt, function(Nt) {
        var Ft, Vt, on = it.slice();
        try {
          for (var tn = oe(on), _n = tn.next(); !_n.done; _n = tn.next()) {
            var en = _n.value, dn = en.buffer;
            dn.push(Nt), Ye <= dn.length && gt(en);
          }
        } catch (Ht) {
          Ft = { error: Ht };
        } finally {
          try {
            _n && !_n.done && (Vt = tn.return) && Vt.call(tn);
          } finally {
            if (Ft)
              throw Ft.error;
          }
        }
      }, function() {
        for (; it != null && it.length; )
          tt.next(it.shift().buffer);
        St == null || St.unsubscribe(), tt.complete(), tt.unsubscribe();
      }, void 0, function() {
        return it = null;
      });
      ot.subscribe(St);
    });
  }
  ne.bufferTime = $e;
}), Z3 = M((ne) => {
  var oe = ne && ne.__values || function($e) {
    var Re = typeof Symbol == "function" && Symbol.iterator, Ne = Re && $e[Re], je = 0;
    if (Ne)
      return Ne.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && je >= $e.length && ($e = void 0), { value: $e && $e[je++], done: !$e };
      } };
    throw new TypeError(Re ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferToggle = void 0;
  var ae = Oi(), fe = he(), ye = _t(), we = Ae(), _e = On(), xe = ku();
  function Oe($e, Re) {
    return fe.operate(function(Ne, je) {
      var Be = [];
      ye.innerFrom($e).subscribe(we.createOperatorSubscriber(je, function(ze) {
        var He = [];
        Be.push(He);
        var qe = new ae.Subscription(), Ye = function() {
          xe.arrRemove(Be, He), je.next(He), qe.unsubscribe();
        };
        qe.add(ye.innerFrom(Re(ze)).subscribe(we.createOperatorSubscriber(je, Ye, _e.noop)));
      }, _e.noop)), Ne.subscribe(we.createOperatorSubscriber(je, function(ze) {
        var He, qe;
        try {
          for (var Ye = oe(Be), ot = Ye.next(); !ot.done; ot = Ye.next()) {
            var tt = ot.value;
            tt.push(ze);
          }
        } catch (it) {
          He = { error: it };
        } finally {
          try {
            ot && !ot.done && (qe = Ye.return) && qe.call(Ye);
          } finally {
            if (He)
              throw He.error;
          }
        }
      }, function() {
        for (; Be.length > 0; )
          je.next(Be.shift());
        je.complete();
      }));
    });
  }
  ne.bufferToggle = Oe;
}), tB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferWhen = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function we(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = null, Re = null, Ne = function() {
        Re == null || Re.unsubscribe();
        var je = $e;
        $e = [], je && Oe.next(je), ye.innerFrom(_e()).subscribe(Re = fe.createOperatorSubscriber(Oe, Ne, ae.noop));
      };
      Ne(), xe.subscribe(fe.createOperatorSubscriber(Oe, function(je) {
        return $e == null ? void 0 : $e.push(je);
      }, function() {
        $e && Oe.next($e), Oe.complete();
      }, void 0, function() {
        return $e = Re = null;
      }));
    });
  }
  ne.bufferWhen = we;
}), nB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.catchError = void 0;
  var oe = _t(), ae = Ae(), fe = he();
  function ye(we) {
    return fe.operate(function(_e, xe) {
      var Oe = null, $e = !1, Re;
      Oe = _e.subscribe(ae.createOperatorSubscriber(xe, void 0, void 0, function(Ne) {
        Re = oe.innerFrom(we(Ne, ye(we)(_e))), Oe ? (Oe.unsubscribe(), Oe = null, Re.subscribe(xe)) : $e = !0;
      })), $e && (Oe.unsubscribe(), Oe = null, Re.subscribe(xe));
    });
  }
  ne.catchError = ye;
}), TA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scanInternals = void 0;
  var oe = Ae();
  function ae(fe, ye, we, _e, xe) {
    return function(Oe, $e) {
      var Re = we, Ne = ye, je = 0;
      Oe.subscribe(oe.createOperatorSubscriber($e, function(Be) {
        var ze = je++;
        Ne = Re ? fe(Ne, Be, ze) : (Re = !0, Be), _e && $e.next(Ne);
      }, xe && function() {
        Re && $e.next(Ne), $e.complete();
      }));
    };
  }
  ne.scanInternals = ae;
}), Qd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reduce = void 0;
  var oe = TA(), ae = he();
  function fe(ye, we) {
    return ae.operate(oe.scanInternals(ye, we, arguments.length >= 2, !1, !0));
  }
  ne.reduce = fe;
}), kA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.toArray = void 0;
  var oe = Qd(), ae = he(), fe = function(we, _e) {
    return we.push(_e), we;
  };
  function ye() {
    return ae.operate(function(we, _e) {
      oe.reduce(fe, [])(we).subscribe(_e);
    });
  }
  ne.toArray = ye;
}), AA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.joinAllInternals = void 0;
  var oe = Hn(), ae = Gl(), fe = lh(), ye = Mu(), we = kA();
  function _e(xe, Oe) {
    return fe.pipe(we.toArray(), ye.mergeMap(function($e) {
      return xe($e);
    }), Oe ? ae.mapOneOrManyArgs(Oe) : oe.identity);
  }
  ne.joinAllInternals = _e;
}), PA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestAll = void 0;
  var oe = WS(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.combineLatest, ye);
  }
  ne.combineLatestAll = fe;
}), iB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineAll = void 0;
  var oe = PA();
  ne.combineAll = oe.combineLatestAll;
}), lB = M((ne) => {
  var oe = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatest = void 0;
  var fe = WS(), ye = he(), we = Sc(), _e = Gl(), xe = lh(), Oe = ki();
  function $e() {
    for (var Re = [], Ne = 0; Ne < arguments.length; Ne++)
      Re[Ne] = arguments[Ne];
    var je = Oe.popResultSelector(Re);
    return je ? xe.pipe($e.apply(void 0, ae([], oe(Re))), _e.mapOneOrManyArgs(je)) : ye.operate(function(Be, ze) {
      fe.combineLatestInit(ae([Be], oe(we.argsOrArgArray(Re))))(ze);
    });
  }
  ne.combineLatest = $e;
}), sB = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var xe = typeof Symbol == "function" && we[Symbol.iterator];
    if (!xe)
      return we;
    var Oe = xe.call(we), $e, Re = [], Ne;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Re.push($e.value);
    } catch (je) {
      Ne = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var xe = 0, Oe = _e.length, $e = we.length; xe < Oe; xe++, $e++)
      we[$e] = _e[xe];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestWith = void 0;
  var fe = lB();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return fe.combineLatest.apply(void 0, ae([], oe(we)));
  }
  ne.combineLatestWith = ye;
}), MA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMap = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, we) {
    return ae.isFunction(we) ? oe.mergeMap(ye, we, 1) : oe.mergeMap(ye, 1);
  }
  ne.concatMap = fe;
}), dB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMapTo = void 0;
  var oe = MA(), ae = Mt();
  function fe(ye, we) {
    return ae.isFunction(we) ? oe.concatMap(function() {
      return ye;
    }, we) : oe.concatMap(function() {
      return ye;
    });
  }
  ne.concatMapTo = fe;
}), pB = M((ne) => {
  var oe = ne && ne.__read || function(Oe, $e) {
    var Re = typeof Symbol == "function" && Oe[Symbol.iterator];
    if (!Re)
      return Oe;
    var Ne = Re.call(Oe), je, Be = [], ze;
    try {
      for (; ($e === void 0 || $e-- > 0) && !(je = Ne.next()).done; )
        Be.push(je.value);
    } catch (He) {
      ze = { error: He };
    } finally {
      try {
        je && !je.done && (Re = Ne.return) && Re.call(Ne);
      } finally {
        if (ze)
          throw ze.error;
      }
    }
    return Be;
  }, ae = ne && ne.__spreadArray || function(Oe, $e) {
    for (var Re = 0, Ne = $e.length, je = Oe.length; Re < Ne; Re++, je++)
      Oe[je] = $e[Re];
    return Oe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var fe = he(), ye = JS(), we = ki(), _e = Ja();
  function xe() {
    for (var Oe = [], $e = 0; $e < arguments.length; $e++)
      Oe[$e] = arguments[$e];
    var Re = we.popScheduler(Oe);
    return fe.operate(function(Ne, je) {
      ye.concatAll()(_e.from(ae([Ne], oe(Oe)), Re)).subscribe(je);
    });
  }
  ne.concat = xe;
}), vB = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var xe = typeof Symbol == "function" && we[Symbol.iterator];
    if (!xe)
      return we;
    var Oe = xe.call(we), $e, Re = [], Ne;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Re.push($e.value);
    } catch (je) {
      Ne = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var xe = 0, Oe = _e.length, $e = we.length; xe < Oe; xe++, $e++)
      we[$e] = _e[xe];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatWith = void 0;
  var fe = pB();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return fe.concat.apply(void 0, ae([], oe(we)));
  }
  ne.concatWith = ye;
}), mB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromSubscribable = void 0;
  var oe = qt();
  function ae(fe) {
    return new oe.Observable(function(ye) {
      return fe.subscribe(ye);
    });
  }
  ne.fromSubscribable = ae;
}), M_ = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connect = void 0;
  var oe = Tn(), ae = Ja(), fe = he(), ye = mB(), we = { connector: function() {
    return new oe.Subject();
  } };
  function _e(xe, Oe) {
    Oe === void 0 && (Oe = we);
    var $e = Oe.connector;
    return fe.operate(function(Re, Ne) {
      var je = $e();
      ae.from(xe(ye.fromSubscribable(je))).subscribe(Ne), Ne.add(Re.subscribe(je));
    });
  }
  ne.connect = _e;
}), hB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.count = void 0;
  var oe = Qd();
  function ae(fe) {
    return oe.reduce(function(ye, we, _e) {
      return !fe || fe(we, _e) ? ye + 1 : ye;
    }, 0);
  }
  ne.count = ae;
}), gB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounce = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function we(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = !1, Re = null, Ne = null, je = function() {
        if (Ne == null || Ne.unsubscribe(), Ne = null, $e) {
          $e = !1;
          var Be = Re;
          Re = null, Oe.next(Be);
        }
      };
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        Ne == null || Ne.unsubscribe(), $e = !0, Re = Be, Ne = fe.createOperatorSubscriber(Oe, je, ae.noop), ye.innerFrom(_e(Be)).subscribe(Ne);
      }, function() {
        je(), Oe.complete();
      }, void 0, function() {
        Re = Ne = null;
      }));
    });
  }
  ne.debounce = we;
}), bB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounceTime = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(we, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.operate(function(xe, Oe) {
      var $e = null, Re = null, Ne = null, je = function() {
        if ($e) {
          $e.unsubscribe(), $e = null;
          var ze = Re;
          Re = null, Oe.next(ze);
        }
      };
      function Be() {
        var ze = Ne + we, He = _e.now();
        if (He < ze) {
          $e = this.schedule(void 0, ze - He), Oe.add($e);
          return;
        }
        je();
      }
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(ze) {
        Re = ze, Ne = _e.now(), $e || ($e = _e.schedule(Be, we), Oe.add($e));
      }, function() {
        je(), Oe.complete();
      }, void 0, function() {
        Re = $e = null;
      }));
    });
  }
  ne.debounceTime = ye;
}), gh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defaultIfEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(we, _e) {
      var xe = !1;
      we.subscribe(ae.createOperatorSubscriber(_e, function(Oe) {
        xe = !0, _e.next(Oe);
      }, function() {
        xe || _e.next(ye), _e.complete();
      }));
    });
  }
  ne.defaultIfEmpty = fe;
}), Kd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.take = void 0;
  var oe = ba(), ae = he(), fe = Ae();
  function ye(we) {
    return we <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(fe.createOperatorSubscriber(xe, function($e) {
        ++Oe <= we && (xe.next($e), we <= Oe && xe.complete());
      }));
    });
  }
  ne.take = ye;
}), DA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ignoreElements = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye() {
    return oe.operate(function(we, _e) {
      we.subscribe(ae.createOperatorSubscriber(_e, fe.noop));
    });
  }
  ne.ignoreElements = ye;
}), NA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapTo = void 0;
  var oe = Wl();
  function ae(fe) {
    return oe.map(function() {
      return fe;
    });
  }
  ne.mapTo = ae;
}), LA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delayWhen = void 0;
  var oe = hh(), ae = Kd(), fe = DA(), ye = NA(), we = Mu();
  function _e(xe, Oe) {
    return Oe ? function($e) {
      return oe.concat(Oe.pipe(ae.take(1), fe.ignoreElements()), $e.pipe(_e(xe)));
    } : we.mergeMap(function($e, Re) {
      return xe($e, Re).pipe(ae.take(1), ye.mapTo($e));
    });
  }
  ne.delayWhen = _e;
}), wB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delay = void 0;
  var oe = Ti(), ae = LA(), fe = Kl();
  function ye(we, _e) {
    _e === void 0 && (_e = oe.asyncScheduler);
    var xe = fe.timer(we, _e);
    return ae.delayWhen(function() {
      return xe;
    });
  }
  ne.delay = ye;
}), xB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dematerialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(we, _e) {
      we.subscribe(fe.createOperatorSubscriber(_e, function(xe) {
        return oe.observeNotification(xe, _e);
      }));
    });
  }
  ne.dematerialize = ye;
}), CB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinct = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye(we, _e) {
    return oe.operate(function(xe, Oe) {
      var $e = /* @__PURE__ */ new Set();
      xe.subscribe(ae.createOperatorSubscriber(Oe, function(Re) {
        var Ne = we ? we(Re) : Re;
        $e.has(Ne) || ($e.add(Ne), Oe.next(Re));
      })), _e == null || _e.subscribe(ae.createOperatorSubscriber(Oe, function() {
        return $e.clear();
      }, fe.noop));
    });
  }
  ne.distinct = ye;
}), jA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilChanged = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(_e, xe) {
    return xe === void 0 && (xe = oe.identity), _e = _e ?? we, ae.operate(function(Oe, $e) {
      var Re, Ne = !0;
      Oe.subscribe(fe.createOperatorSubscriber($e, function(je) {
        var Be = xe(je);
        (Ne || !_e(Re, Be)) && (Ne = !1, Re = Be, $e.next(je));
      }));
    });
  }
  ne.distinctUntilChanged = ye;
  function we(_e, xe) {
    return _e === xe;
  }
}), RB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilKeyChanged = void 0;
  var oe = jA();
  function ae(fe, ye) {
    return oe.distinctUntilChanged(function(we, _e) {
      return ye ? ye(we[fe], _e[fe]) : we[fe] === _e[fe];
    });
  }
  ne.distinctUntilKeyChanged = ae;
}), bh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwIfEmpty = void 0;
  var oe = $l(), ae = he(), fe = Ae();
  function ye(_e) {
    return _e === void 0 && (_e = we), ae.operate(function(xe, Oe) {
      var $e = !1;
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Re) {
        $e = !0, Oe.next(Re);
      }, function() {
        return $e ? Oe.complete() : Oe.error(_e());
      }));
    });
  }
  ne.throwIfEmpty = ye;
  function we() {
    return new oe.EmptyError();
  }
}), TB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.elementAt = void 0;
  var oe = vA(), ae = _c(), fe = bh(), ye = gh(), we = Kd();
  function _e(xe, Oe) {
    if (xe < 0)
      throw new oe.ArgumentOutOfRangeError();
    var $e = arguments.length >= 2;
    return function(Re) {
      return Re.pipe(ae.filter(function(Ne, je) {
        return je === xe;
      }), we.take(1), $e ? ye.defaultIfEmpty(Oe) : fe.throwIfEmpty(function() {
        return new oe.ArgumentOutOfRangeError();
      }));
    };
  }
  ne.elementAt = _e;
}), kB = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Re, Ne = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Re = $e.next()).done; )
        Ne.push(Re.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Re && !Re.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Re = _e.length; Oe < $e; Oe++, Re++)
      _e[Re] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.endWith = void 0;
  var fe = hh(), ye = TS();
  function we() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    return function(Oe) {
      return fe.concat(Oe, ye.of.apply(void 0, ae([], oe(_e))));
    };
  }
  ne.endWith = we;
}), AB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.every = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, we) {
    return oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        ye.call(we, $e, Oe++, _e) || (xe.next(!1), xe.complete());
      }, function() {
        xe.next(!0), xe.complete();
      }));
    });
  }
  ne.every = fe;
}), UA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustAll = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye() {
    return oe.operate(function(we, _e) {
      var xe = !1, Oe = null;
      we.subscribe(fe.createOperatorSubscriber(_e, function($e) {
        Oe || (Oe = ae.innerFrom($e).subscribe(fe.createOperatorSubscriber(_e, void 0, function() {
          Oe = null, xe && _e.complete();
        })));
      }, function() {
        xe = !0, !Oe && _e.complete();
      }));
    });
  }
  ne.exhaustAll = ye;
}), MB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaust = void 0;
  var oe = UA();
  ne.exhaust = oe.exhaustAll;
}), jB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = Ae();
  function we(_e, xe) {
    return xe ? function(Oe) {
      return Oe.pipe(we(function($e, Re) {
        return ae.innerFrom(_e($e, Re)).pipe(oe.map(function(Ne, je) {
          return xe($e, Ne, Re, je);
        }));
      }));
    } : fe.operate(function(Oe, $e) {
      var Re = 0, Ne = null, je = !1;
      Oe.subscribe(ye.createOperatorSubscriber($e, function(Be) {
        Ne || (Ne = ye.createOperatorSubscriber($e, void 0, function() {
          Ne = null, je && $e.complete();
        }), ae.innerFrom(_e(Be, Re++)).subscribe(Ne));
      }, function() {
        je = !0, !Ne && $e.complete();
      }));
    });
  }
  ne.exhaustMap = we;
}), UB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.expand = void 0;
  var oe = he(), ae = GS();
  function fe(ye, we, _e) {
    return we === void 0 && (we = 1 / 0), we = (we || 0) < 1 ? 1 / 0 : we, oe.operate(function(xe, Oe) {
      return ae.mergeInternals(xe, Oe, ye, we, void 0, !0, _e);
    });
  }
  ne.expand = fe;
}), FB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.finalize = void 0;
  var oe = he();
  function ae(fe) {
    return oe.operate(function(ye, we) {
      try {
        ye.subscribe(we);
      } finally {
        we.add(fe);
      }
    });
  }
  ne.finalize = ae;
}), FA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createFind = ne.find = void 0;
  var oe = he(), ae = Ae();
  function fe(we, _e) {
    return oe.operate(ye(we, _e, "value"));
  }
  ne.find = fe;
  function ye(we, _e, xe) {
    var Oe = xe === "index";
    return function($e, Re) {
      var Ne = 0;
      $e.subscribe(ae.createOperatorSubscriber(Re, function(je) {
        var Be = Ne++;
        we.call(_e, je, Be, $e) && (Re.next(Oe ? Be : je), Re.complete());
      }, function() {
        Re.next(Oe ? -1 : void 0), Re.complete();
      }));
    };
  }
  ne.createFind = ye;
}), qB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.findIndex = void 0;
  var oe = he(), ae = FA();
  function fe(ye, we) {
    return oe.operate(ae.createFind(ye, we, "index"));
  }
  ne.findIndex = fe;
}), IB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.first = void 0;
  var oe = $l(), ae = _c(), fe = Kd(), ye = gh(), we = bh(), _e = Hn();
  function xe(Oe, $e) {
    var Re = arguments.length >= 2;
    return function(Ne) {
      return Ne.pipe(Oe ? ae.filter(function(je, Be) {
        return Oe(je, Be, Ne);
      }) : _e.identity, fe.take(1), Re ? ye.defaultIfEmpty($e) : we.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.first = xe;
}), HB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.groupBy = void 0;
  var oe = qt(), ae = _t(), fe = Tn(), ye = he(), we = Ae();
  function _e(xe, Oe, $e, Re) {
    return ye.operate(function(Ne, je) {
      var Be;
      !Oe || typeof Oe == "function" ? Be = Oe : ($e = Oe.duration, Be = Oe.element, Re = Oe.connector);
      var ze = /* @__PURE__ */ new Map(), He = function(ht) {
        ze.forEach(ht), ht(je);
      }, qe = function(ht) {
        return He(function(gt) {
          return gt.error(ht);
        });
      }, Ye = 0, ot = !1, tt = new we.OperatorSubscriber(je, function(ht) {
        try {
          var gt = xe(ht), At = ze.get(gt);
          if (!At) {
            ze.set(gt, At = Re ? Re() : new fe.Subject());
            var St = it(gt, At);
            if (je.next(St), $e) {
              var Nt = we.createOperatorSubscriber(At, function() {
                At.complete(), Nt == null || Nt.unsubscribe();
              }, void 0, void 0, function() {
                return ze.delete(gt);
              });
              tt.add(ae.innerFrom($e(St)).subscribe(Nt));
            }
          }
          At.next(Be ? Be(ht) : ht);
        } catch (Ft) {
          qe(Ft);
        }
      }, function() {
        return He(function(ht) {
          return ht.complete();
        });
      }, qe, function() {
        return ze.clear();
      }, function() {
        return ot = !0, Ye === 0;
      });
      Ne.subscribe(tt);
      function it(ht, gt) {
        var At = new oe.Observable(function(St) {
          Ye++;
          var Nt = gt.subscribe(St);
          return function() {
            Nt.unsubscribe(), --Ye === 0 && ot && tt.unsubscribe();
          };
        });
        return At.key = ht, At;
      }
    });
  }
  ne.groupBy = _e;
}), VB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, we) {
      ye.subscribe(ae.createOperatorSubscriber(we, function() {
        we.next(!1), we.complete();
      }, function() {
        we.next(!0), we.complete();
      }));
    });
  }
  ne.isEmpty = fe;
}), zA = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeLast = void 0;
  var ae = ba(), fe = he(), ye = Ae();
  function we(_e) {
    return _e <= 0 ? function() {
      return ae.EMPTY;
    } : fe.operate(function(xe, Oe) {
      var $e = [];
      xe.subscribe(ye.createOperatorSubscriber(Oe, function(Re) {
        $e.push(Re), _e < $e.length && $e.shift();
      }, function() {
        var Re, Ne;
        try {
          for (var je = oe($e), Be = je.next(); !Be.done; Be = je.next()) {
            var ze = Be.value;
            Oe.next(ze);
          }
        } catch (He) {
          Re = { error: He };
        } finally {
          try {
            Be && !Be.done && (Ne = je.return) && Ne.call(je);
          } finally {
            if (Re)
              throw Re.error;
          }
        }
        Oe.complete();
      }, void 0, function() {
        $e = null;
      }));
    });
  }
  ne.takeLast = we;
}), $B = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.last = void 0;
  var oe = $l(), ae = _c(), fe = zA(), ye = bh(), we = gh(), _e = Hn();
  function xe(Oe, $e) {
    var Re = arguments.length >= 2;
    return function(Ne) {
      return Ne.pipe(Oe ? ae.filter(function(je, Be) {
        return Oe(je, Be, Ne);
      }) : _e.identity, fe.takeLast(1), Re ? we.defaultIfEmpty($e) : ye.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.last = xe;
}), WB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.materialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(we, _e) {
      we.subscribe(fe.createOperatorSubscriber(_e, function(xe) {
        _e.next(oe.Notification.createNext(xe));
      }, function() {
        _e.next(oe.Notification.createComplete()), _e.complete();
      }, function(xe) {
        _e.next(oe.Notification.createError(xe)), _e.complete();
      }));
    });
  }
  ne.materialize = ye;
}), YB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.max = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(we, _e) {
      return ye(we, _e) > 0 ? we : _e;
    } : function(we, _e) {
      return we > _e ? we : _e;
    });
  }
  ne.max = fe;
}), GB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.flatMap = void 0;
  var oe = Mu();
  ne.flatMap = oe.mergeMap;
}), KB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMapTo = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, we, _e) {
    return _e === void 0 && (_e = 1 / 0), ae.isFunction(we) ? oe.mergeMap(function() {
      return ye;
    }, we, _e) : (typeof we == "number" && (_e = we), oe.mergeMap(function() {
      return ye;
    }, _e));
  }
  ne.mergeMapTo = fe;
}), XB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeScan = void 0;
  var oe = he(), ae = GS();
  function fe(ye, we, _e) {
    return _e === void 0 && (_e = 1 / 0), oe.operate(function(xe, Oe) {
      var $e = we;
      return ae.mergeInternals(xe, Oe, function(Re, Ne) {
        return ye($e, Re, Ne);
      }, _e, function(Re) {
        $e = Re;
      }, !1, void 0, function() {
        return $e = null;
      });
    });
  }
  ne.mergeScan = fe;
}), ZB = M((ne) => {
  var oe = ne && ne.__read || function($e, Re) {
    var Ne = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Ne)
      return $e;
    var je = Ne.call($e), Be, ze = [], He;
    try {
      for (; (Re === void 0 || Re-- > 0) && !(Be = je.next()).done; )
        ze.push(Be.value);
    } catch (qe) {
      He = { error: qe };
    } finally {
      try {
        Be && !Be.done && (Ne = je.return) && Ne.call(je);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function($e, Re) {
    for (var Ne = 0, je = Re.length, Be = $e.length; Ne < je; Ne++, Be++)
      $e[Be] = Re[Ne];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var fe = he(), ye = Sc(), we = mh(), _e = ki(), xe = Ja();
  function Oe() {
    for (var $e = [], Re = 0; Re < arguments.length; Re++)
      $e[Re] = arguments[Re];
    var Ne = _e.popScheduler($e), je = _e.popNumber($e, 1 / 0);
    return $e = ye.argsOrArgArray($e), fe.operate(function(Be, ze) {
      we.mergeAll(je)(xe.from(ae([Be], oe($e)), Ne)).subscribe(ze);
    });
  }
  ne.merge = Oe;
}), eH = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var xe = typeof Symbol == "function" && we[Symbol.iterator];
    if (!xe)
      return we;
    var Oe = xe.call(we), $e, Re = [], Ne;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Re.push($e.value);
    } catch (je) {
      Ne = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var xe = 0, Oe = _e.length, $e = we.length; xe < Oe; xe++, $e++)
      we[$e] = _e[xe];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeWith = void 0;
  var fe = ZB();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return fe.merge.apply(void 0, ae([], oe(we)));
  }
  ne.mergeWith = ye;
}), tH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.min = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(we, _e) {
      return ye(we, _e) < 0 ? we : _e;
    } : function(we, _e) {
      return we < _e ? we : _e;
    });
  }
  ne.min = fe;
}), dw = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.multicast = void 0;
  var oe = sh(), ae = Mt(), fe = M_();
  function ye(we, _e) {
    var xe = ae.isFunction(we) ? we : function() {
      return we;
    };
    return ae.isFunction(_e) ? fe.connect(_e, { connector: xe }) : function(Oe) {
      return new oe.ConnectableObservable(Oe, xe);
    };
  }
  ne.multicast = ye;
}), nH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairwise = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, we) {
      var _e, xe = !1;
      ye.subscribe(ae.createOperatorSubscriber(we, function(Oe) {
        var $e = _e;
        _e = Oe, xe && we.next([$e, Oe]), xe = !0;
      }));
    });
  }
  ne.pairwise = fe;
}), iH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pluck = void 0;
  var oe = Wl();
  function ae() {
    for (var fe = [], ye = 0; ye < arguments.length; ye++)
      fe[ye] = arguments[ye];
    var we = fe.length;
    if (we === 0)
      throw new Error("list of properties cannot be empty.");
    return oe.map(function(_e) {
      for (var xe = _e, Oe = 0; Oe < we; Oe++) {
        var $e = xe == null ? void 0 : xe[fe[Oe]];
        if (typeof $e < "u")
          xe = $e;
        else
          return;
      }
      return xe;
    });
  }
  ne.pluck = ae;
}), aH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publish = void 0;
  var oe = Tn(), ae = dw(), fe = M_();
  function ye(we) {
    return we ? function(_e) {
      return fe.connect(we)(_e);
    } : function(_e) {
      return ae.multicast(new oe.Subject())(_e);
    };
  }
  ne.publish = ye;
}), oH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishBehavior = void 0;
  var oe = Xk(), ae = sh();
  function fe(ye) {
    return function(we) {
      var _e = new oe.BehaviorSubject(ye);
      return new ae.ConnectableObservable(we, function() {
        return _e;
      });
    };
  }
  ne.publishBehavior = fe;
}), uH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishLast = void 0;
  var oe = iS(), ae = sh();
  function fe() {
    return function(ye) {
      var we = new oe.AsyncSubject();
      return new ae.ConnectableObservable(ye, function() {
        return we;
      });
    };
  }
  ne.publishLast = fe;
}), sH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishReplay = void 0;
  var oe = nS(), ae = dw(), fe = Mt();
  function ye(we, _e, xe, Oe) {
    xe && !fe.isFunction(xe) && (Oe = xe);
    var $e = fe.isFunction(xe) ? xe : void 0;
    return function(Re) {
      return ae.multicast(new oe.ReplaySubject(we, _e, Oe), $e)(Re);
    };
  }
  ne.publishReplay = ye;
}), cH = M((ne) => {
  var oe = ne && ne.__read || function(xe, Oe) {
    var $e = typeof Symbol == "function" && xe[Symbol.iterator];
    if (!$e)
      return xe;
    var Re = $e.call(xe), Ne, je = [], Be;
    try {
      for (; (Oe === void 0 || Oe-- > 0) && !(Ne = Re.next()).done; )
        je.push(Ne.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Ne && !Ne.done && ($e = Re.return) && $e.call(Re);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return je;
  }, ae = ne && ne.__spreadArray || function(xe, Oe) {
    for (var $e = 0, Re = Oe.length, Ne = xe.length; $e < Re; $e++, Ne++)
      xe[Ne] = Oe[$e];
    return xe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceWith = void 0;
  var fe = EA(), ye = he(), we = Hn();
  function _e() {
    for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
      xe[Oe] = arguments[Oe];
    return xe.length ? ye.operate(function($e, Re) {
      fe.raceInit(ae([$e], oe(xe)))(Re);
    }) : we.identity;
  }
  ne.raceWith = _e;
}), dH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeat = void 0;
  var oe = ba(), ae = he(), fe = Ae(), ye = _t(), we = Kl();
  function _e(xe) {
    var Oe, $e = 1 / 0, Re;
    return xe != null && (typeof xe == "object" ? (Oe = xe.count, $e = Oe === void 0 ? 1 / 0 : Oe, Re = xe.delay) : $e = xe), $e <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(Ne, je) {
      var Be = 0, ze, He = function() {
        if (ze == null || ze.unsubscribe(), ze = null, Re != null) {
          var Ye = typeof Re == "number" ? we.timer(Re) : ye.innerFrom(Re(Be)), ot = fe.createOperatorSubscriber(je, function() {
            ot.unsubscribe(), qe();
          });
          Ye.subscribe(ot);
        } else
          qe();
      }, qe = function() {
        var Ye = !1;
        ze = Ne.subscribe(fe.createOperatorSubscriber(je, void 0, function() {
          ++Be < $e ? ze ? He() : Ye = !0 : je.complete();
        })), Ye && He();
      };
      qe();
    });
  }
  ne.repeat = _e;
}), vH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeatWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(we) {
    return ae.operate(function(_e, xe) {
      var Oe, $e = !1, Re, Ne = !1, je = !1, Be = function() {
        return je && Ne && (xe.complete(), !0);
      }, ze = function() {
        return Re || (Re = new oe.Subject(), we(Re).subscribe(fe.createOperatorSubscriber(xe, function() {
          Oe ? He() : $e = !0;
        }, function() {
          Ne = !0, Be();
        }))), Re;
      }, He = function() {
        je = !1, Oe = _e.subscribe(fe.createOperatorSubscriber(xe, void 0, function() {
          je = !0, !Be() && ze().next();
        })), $e && (Oe.unsubscribe(), Oe = null, $e = !1, He());
      };
      He();
    });
  }
  ne.repeatWhen = ye;
}), hH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retry = void 0;
  var oe = he(), ae = Ae(), fe = Hn(), ye = Kl(), we = _t();
  function _e(xe) {
    xe === void 0 && (xe = 1 / 0);
    var Oe;
    xe && typeof xe == "object" ? Oe = xe : Oe = { count: xe };
    var $e = Oe.count, Re = $e === void 0 ? 1 / 0 : $e, Ne = Oe.delay, je = Oe.resetOnSuccess, Be = je === void 0 ? !1 : je;
    return Re <= 0 ? fe.identity : oe.operate(function(ze, He) {
      var qe = 0, Ye, ot = function() {
        var tt = !1;
        Ye = ze.subscribe(ae.createOperatorSubscriber(He, function(it) {
          Be && (qe = 0), He.next(it);
        }, void 0, function(it) {
          if (qe++ < Re) {
            var ht = function() {
              Ye ? (Ye.unsubscribe(), Ye = null, ot()) : tt = !0;
            };
            if (Ne != null) {
              var gt = typeof Ne == "number" ? ye.timer(Ne) : we.innerFrom(Ne(it, qe)), At = ae.createOperatorSubscriber(He, function() {
                At.unsubscribe(), ht();
              }, function() {
                He.complete();
              });
              gt.subscribe(At);
            } else
              ht();
          } else
            He.error(it);
        })), tt && (Ye.unsubscribe(), Ye = null, ot());
      };
      ot();
    });
  }
  ne.retry = _e;
}), gH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retryWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(we) {
    return ae.operate(function(_e, xe) {
      var Oe, $e = !1, Re, Ne = function() {
        Oe = _e.subscribe(fe.createOperatorSubscriber(xe, void 0, void 0, function(je) {
          Re || (Re = new oe.Subject(), we(Re).subscribe(fe.createOperatorSubscriber(xe, function() {
            return Oe ? Ne() : $e = !0;
          }))), Re && Re.next(je);
        })), $e && (Oe.unsubscribe(), Oe = null, $e = !1, Ne());
      };
      Ne();
    });
  }
  ne.retryWhen = ye;
}), IA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sample = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(we) {
    return oe.operate(function(_e, xe) {
      var Oe = !1, $e = null;
      _e.subscribe(fe.createOperatorSubscriber(xe, function(Re) {
        Oe = !0, $e = Re;
      })), we.subscribe(fe.createOperatorSubscriber(xe, function() {
        if (Oe) {
          Oe = !1;
          var Re = $e;
          $e = null, xe.next(Re);
        }
      }, ae.noop));
    });
  }
  ne.sample = ye;
}), SH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sampleTime = void 0;
  var oe = Ti(), ae = IA(), fe = wA();
  function ye(we, _e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.sample(fe.interval(we, _e));
  }
  ne.sampleTime = ye;
}), _H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scan = void 0;
  var oe = he(), ae = TA();
  function fe(ye, we) {
    return oe.operate(ae.scanInternals(ye, we, arguments.length >= 2, !0));
  }
  ne.scan = fe;
}), xH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sequenceEqual = void 0;
  var oe = he(), ae = Ae();
  function fe(we, _e) {
    return _e === void 0 && (_e = function(xe, Oe) {
      return xe === Oe;
    }), oe.operate(function(xe, Oe) {
      var $e = ye(), Re = ye(), Ne = function(Be) {
        Oe.next(Be), Oe.complete();
      }, je = function(Be, ze) {
        var He = ae.createOperatorSubscriber(Oe, function(qe) {
          var Ye = ze.buffer, ot = ze.complete;
          Ye.length === 0 ? ot ? Ne(!1) : Be.buffer.push(qe) : !_e(qe, Ye.shift()) && Ne(!1);
        }, function() {
          Be.complete = !0;
          var qe = ze.complete, Ye = ze.buffer;
          qe && Ne(Ye.length === 0), He == null || He.unsubscribe();
        });
        return He;
      };
      xe.subscribe(je($e, Re)), we.subscribe(je(Re, $e));
    });
  }
  ne.sequenceEqual = fe;
  function ye() {
    return { buffer: [], complete: !1 };
  }
}), HA = M((ne) => {
  var oe = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.share = void 0;
  var fe = Ja(), ye = Kd(), we = Tn(), _e = Sd(), xe = he();
  function Oe(Re) {
    Re === void 0 && (Re = {});
    var Ne = Re.connector, je = Ne === void 0 ? function() {
      return new we.Subject();
    } : Ne, Be = Re.resetOnError, ze = Be === void 0 ? !0 : Be, He = Re.resetOnComplete, qe = He === void 0 ? !0 : He, Ye = Re.resetOnRefCountZero, ot = Ye === void 0 ? !0 : Ye;
    return function(tt) {
      var it = null, ht = null, gt = null, At = 0, St = !1, Nt = !1, Ft = function() {
        ht == null || ht.unsubscribe(), ht = null;
      }, Vt = function() {
        Ft(), it = gt = null, St = Nt = !1;
      }, on = function() {
        var tn = it;
        Vt(), tn == null || tn.unsubscribe();
      };
      return xe.operate(function(tn, _n) {
        At++, !Nt && !St && Ft();
        var en = gt = gt ?? je();
        _n.add(function() {
          At--, At === 0 && !Nt && !St && (ht = $e(on, ot));
        }), en.subscribe(_n), it || (it = new _e.SafeSubscriber({ next: function(dn) {
          return en.next(dn);
        }, error: function(dn) {
          Nt = !0, Ft(), ht = $e(Vt, ze, dn), en.error(dn);
        }, complete: function() {
          St = !0, Ft(), ht = $e(Vt, qe), en.complete();
        } }), fe.from(tn).subscribe(it));
      })(tt);
    };
  }
  ne.share = Oe;
  function $e(Re, Ne) {
    for (var je = [], Be = 2; Be < arguments.length; Be++)
      je[Be - 2] = arguments[Be];
    return Ne === !0 ? (Re(), null) : Ne === !1 ? null : Ne.apply(void 0, ae([], oe(je))).pipe(ye.take(1)).subscribe(function() {
      return Re();
    });
  }
}), EH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.shareReplay = void 0;
  var oe = nS(), ae = HA();
  function fe(ye, we, _e) {
    var xe, Oe, $e, Re, Ne = !1;
    return ye && typeof ye == "object" ? (xe = ye.bufferSize, Re = xe === void 0 ? 1 / 0 : xe, Oe = ye.windowTime, we = Oe === void 0 ? 1 / 0 : Oe, $e = ye.refCount, Ne = $e === void 0 ? !1 : $e, _e = ye.scheduler) : Re = ye ?? 1 / 0, ae.share({ connector: function() {
      return new oe.ReplaySubject(Re, we, _e);
    }, resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: Ne });
  }
  ne.shareReplay = fe;
}), CH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.single = void 0;
  var oe = $l(), ae = hA(), fe = mA(), ye = he(), we = Ae();
  function _e(xe) {
    return ye.operate(function(Oe, $e) {
      var Re = !1, Ne, je = !1, Be = 0;
      Oe.subscribe(we.createOperatorSubscriber($e, function(ze) {
        je = !0, (!xe || xe(ze, Be++, Oe)) && (Re && $e.error(new ae.SequenceError("Too many matching values")), Re = !0, Ne = ze);
      }, function() {
        Re ? ($e.next(Ne), $e.complete()) : $e.error(je ? new fe.NotFoundError("No matching values") : new oe.EmptyError());
      }));
    });
  }
  ne.single = _e;
}), RH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skip = void 0;
  var oe = _c();
  function ae(fe) {
    return oe.filter(function(ye, we) {
      return fe <= we;
    });
  }
  ne.skip = ae;
}), OH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipLast = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(we) {
    return we <= 0 ? oe.identity : ae.operate(function(_e, xe) {
      var Oe = new Array(we), $e = 0;
      return _e.subscribe(fe.createOperatorSubscriber(xe, function(Re) {
        var Ne = $e++;
        if (Ne < we)
          Oe[Ne] = Re;
        else {
          var je = Ne % we, Be = Oe[je];
          Oe[je] = Re, xe.next(Be);
        }
      })), function() {
        Oe = null;
      };
    });
  }
  ne.skipLast = ye;
}), kH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function we(_e) {
    return oe.operate(function(xe, Oe) {
      var $e = !1, Re = ae.createOperatorSubscriber(Oe, function() {
        Re == null || Re.unsubscribe(), $e = !0;
      }, ye.noop);
      fe.innerFrom(_e).subscribe(Re), xe.subscribe(ae.createOperatorSubscriber(Oe, function(Ne) {
        return $e && Oe.next(Ne);
      }));
    });
  }
  ne.skipUntil = we;
}), AH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(we, _e) {
      var xe = !1, Oe = 0;
      we.subscribe(ae.createOperatorSubscriber(_e, function($e) {
        return (xe || (xe = !ye($e, Oe++))) && _e.next($e);
      }));
    });
  }
  ne.skipWhile = fe;
}), MH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.startWith = void 0;
  var oe = hh(), ae = ki(), fe = he();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    var xe = ae.popScheduler(we);
    return fe.operate(function(Oe, $e) {
      (xe ? oe.concat(we, Oe, xe) : oe.concat(we, Oe)).subscribe($e);
    });
  }
  ne.startWith = ye;
}), Sh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMap = void 0;
  var oe = _t(), ae = he(), fe = Ae();
  function ye(we, _e) {
    return ae.operate(function(xe, Oe) {
      var $e = null, Re = 0, Ne = !1, je = function() {
        return Ne && !$e && Oe.complete();
      };
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        $e == null || $e.unsubscribe();
        var ze = 0, He = Re++;
        oe.innerFrom(we(Be, He)).subscribe($e = fe.createOperatorSubscriber(Oe, function(qe) {
          return Oe.next(_e ? _e(Be, qe, He, ze++) : qe);
        }, function() {
          $e = null, je();
        }));
      }, function() {
        Ne = !0, je();
      }));
    });
  }
  ne.switchMap = ye;
}), NH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchAll = void 0;
  var oe = Sh(), ae = Hn();
  function fe() {
    return oe.switchMap(ae.identity);
  }
  ne.switchAll = fe;
}), jH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMapTo = void 0;
  var oe = Sh(), ae = Mt();
  function fe(ye, we) {
    return ae.isFunction(we) ? oe.switchMap(function() {
      return ye;
    }, we) : oe.switchMap(function() {
      return ye;
    });
  }
  ne.switchMapTo = fe;
}), UH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchScan = void 0;
  var oe = Sh(), ae = he();
  function fe(ye, we) {
    return ae.operate(function(_e, xe) {
      var Oe = we;
      return oe.switchMap(function($e, Re) {
        return ye(Oe, $e, Re);
      }, function($e, Re) {
        return Oe = Re, Re;
      })(_e).subscribe(xe), function() {
        Oe = null;
      };
    });
  }
  ne.switchScan = fe;
}), FH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function we(_e) {
    return oe.operate(function(xe, Oe) {
      fe.innerFrom(_e).subscribe(ae.createOperatorSubscriber(Oe, function() {
        return Oe.complete();
      }, ye.noop)), !Oe.closed && xe.subscribe(Oe);
    });
  }
  ne.takeUntil = we;
}), zH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, we) {
    return we === void 0 && (we = !1), oe.operate(function(_e, xe) {
      var Oe = 0;
      _e.subscribe(ae.createOperatorSubscriber(xe, function($e) {
        var Re = ye($e, Oe++);
        (Re || we) && xe.next($e), !Re && xe.complete();
      }));
    });
  }
  ne.takeWhile = fe;
}), qH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.tap = void 0;
  var oe = Mt(), ae = he(), fe = Ae(), ye = Hn();
  function we(_e, xe, Oe) {
    var $e = oe.isFunction(_e) || xe || Oe ? { next: _e, error: xe, complete: Oe } : _e;
    return $e ? ae.operate(function(Re, Ne) {
      var je;
      (je = $e.subscribe) === null || je === void 0 || je.call($e);
      var Be = !0;
      Re.subscribe(fe.createOperatorSubscriber(Ne, function(ze) {
        var He;
        (He = $e.next) === null || He === void 0 || He.call($e, ze), Ne.next(ze);
      }, function() {
        var ze;
        Be = !1, (ze = $e.complete) === null || ze === void 0 || ze.call($e), Ne.complete();
      }, function(ze) {
        var He;
        Be = !1, (He = $e.error) === null || He === void 0 || He.call($e, ze), Ne.error(ze);
      }, function() {
        var ze, He;
        Be && ((ze = $e.unsubscribe) === null || ze === void 0 || ze.call($e)), (He = $e.finalize) === null || He === void 0 || He.call($e);
      }));
    }) : ye.identity;
  }
  ne.tap = we;
}), VA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttle = ne.defaultThrottleConfig = void 0;
  var oe = he(), ae = Ae(), fe = _t();
  ne.defaultThrottleConfig = { leading: !0, trailing: !1 };
  function ye(we, _e) {
    return _e === void 0 && (_e = ne.defaultThrottleConfig), oe.operate(function(xe, Oe) {
      var $e = _e.leading, Re = _e.trailing, Ne = !1, je = null, Be = null, ze = !1, He = function() {
        Be == null || Be.unsubscribe(), Be = null, Re && (ot(), ze && Oe.complete());
      }, qe = function() {
        Be = null, ze && Oe.complete();
      }, Ye = function(tt) {
        return Be = fe.innerFrom(we(tt)).subscribe(ae.createOperatorSubscriber(Oe, He, qe));
      }, ot = function() {
        if (Ne) {
          Ne = !1;
          var tt = je;
          je = null, Oe.next(tt), !ze && Ye(tt);
        }
      };
      xe.subscribe(ae.createOperatorSubscriber(Oe, function(tt) {
        Ne = !0, je = tt, !(Be && !Be.closed) && ($e ? ot() : Ye(tt));
      }, function() {
        ze = !0, !(Re && Ne && Be && !Be.closed) && Oe.complete();
      }));
    });
  }
  ne.throttle = ye;
}), HH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttleTime = void 0;
  var oe = Ti(), ae = VA(), fe = Kl();
  function ye(we, _e, xe) {
    _e === void 0 && (_e = oe.asyncScheduler), xe === void 0 && (xe = ae.defaultThrottleConfig);
    var Oe = fe.timer(we, _e);
    return ae.throttle(function() {
      return Oe;
    }, xe);
  }
  ne.throttleTime = ye;
}), $H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TimeInterval = ne.timeInterval = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(_e) {
    return _e === void 0 && (_e = oe.asyncScheduler), ae.operate(function(xe, Oe) {
      var $e = _e.now();
      xe.subscribe(fe.createOperatorSubscriber(Oe, function(Re) {
        var Ne = _e.now(), je = Ne - $e;
        $e = Ne, Oe.next(new we(Re, je));
      }));
    });
  }
  ne.timeInterval = ye;
  var we = function() {
    function _e(xe, Oe) {
      this.value = xe, this.interval = Oe;
    }
    return _e;
  }();
  ne.TimeInterval = we;
}), WH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutWith = void 0;
  var oe = Ti(), ae = zS(), fe = qS();
  function ye(we, _e, xe) {
    var Oe, $e, Re;
    if (xe = xe ?? oe.async, ae.isValidDate(we) ? Oe = we : typeof we == "number" && ($e = we), _e)
      Re = function() {
        return _e;
      };
    else
      throw new TypeError("No observable provided to switch to");
    if (Oe == null && $e == null)
      throw new TypeError("No timeout provided.");
    return fe.timeout({ first: Oe, each: $e, scheduler: xe, with: Re });
  }
  ne.timeoutWith = ye;
}), YH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timestamp = void 0;
  var oe = rS(), ae = Wl();
  function fe(ye) {
    return ye === void 0 && (ye = oe.dateTimestampProvider), ae.map(function(we) {
      return { value: we, timestamp: ye.now() };
    });
  }
  ne.timestamp = fe;
}), KH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.window = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = On();
  function we(_e) {
    return ae.operate(function(xe, Oe) {
      var $e = new oe.Subject();
      Oe.next($e.asObservable());
      var Re = function(Ne) {
        $e.error(Ne), Oe.error(Ne);
      };
      return xe.subscribe(fe.createOperatorSubscriber(Oe, function(Ne) {
        return $e == null ? void 0 : $e.next(Ne);
      }, function() {
        $e.complete(), Oe.complete();
      }, Re)), _e.subscribe(fe.createOperatorSubscriber(Oe, function() {
        $e.complete(), Oe.next($e = new oe.Subject());
      }, ye.noop, Re)), function() {
        $e == null || $e.unsubscribe(), $e = null;
      };
    });
  }
  ne.window = we;
}), JH = M((ne) => {
  var oe = ne && ne.__values || function(_e) {
    var xe = typeof Symbol == "function" && Symbol.iterator, Oe = xe && _e[xe], $e = 0;
    if (Oe)
      return Oe.call(_e);
    if (_e && typeof _e.length == "number")
      return { next: function() {
        return _e && $e >= _e.length && (_e = void 0), { value: _e && _e[$e++], done: !_e };
      } };
    throw new TypeError(xe ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowCount = void 0;
  var ae = Tn(), fe = he(), ye = Ae();
  function we(_e, xe) {
    xe === void 0 && (xe = 0);
    var Oe = xe > 0 ? xe : _e;
    return fe.operate(function($e, Re) {
      var Ne = [new ae.Subject()], je = 0;
      Re.next(Ne[0].asObservable()), $e.subscribe(ye.createOperatorSubscriber(Re, function(Be) {
        var ze, He;
        try {
          for (var qe = oe(Ne), Ye = qe.next(); !Ye.done; Ye = qe.next()) {
            var ot = Ye.value;
            ot.next(Be);
          }
        } catch (ht) {
          ze = { error: ht };
        } finally {
          try {
            Ye && !Ye.done && (He = qe.return) && He.call(qe);
          } finally {
            if (ze)
              throw ze.error;
          }
        }
        var tt = je - _e + 1;
        if (tt >= 0 && tt % Oe === 0 && Ne.shift().complete(), ++je % Oe === 0) {
          var it = new ae.Subject();
          Ne.push(it), Re.next(it.asObservable());
        }
      }, function() {
        for (; Ne.length > 0; )
          Ne.shift().complete();
        Re.complete();
      }, function(Be) {
        for (; Ne.length > 0; )
          Ne.shift().error(Be);
        Re.error(Be);
      }, function() {
        Ne = null;
      }));
    });
  }
  ne.windowCount = we;
}), e4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowTime = void 0;
  var oe = Tn(), ae = Ti(), fe = Oi(), ye = he(), we = Ae(), _e = ku(), xe = ki(), Oe = Au();
  function $e(Re) {
    for (var Ne, je, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Ne = xe.popScheduler(Be)) !== null && Ne !== void 0 ? Ne : ae.asyncScheduler, qe = (je = Be[0]) !== null && je !== void 0 ? je : null, Ye = Be[1] || 1 / 0;
    return ye.operate(function(ot, tt) {
      var it = [], ht = !1, gt = function(Ft) {
        var Vt = Ft.window, on = Ft.subs;
        Vt.complete(), on.unsubscribe(), _e.arrRemove(it, Ft), ht && At();
      }, At = function() {
        if (it) {
          var Ft = new fe.Subscription();
          tt.add(Ft);
          var Vt = new oe.Subject(), on = { window: Vt, subs: Ft, seen: 0 };
          it.push(on), tt.next(Vt.asObservable()), Oe.executeSchedule(Ft, He, function() {
            return gt(on);
          }, Re);
        }
      };
      qe !== null && qe >= 0 ? Oe.executeSchedule(tt, He, At, qe, !0) : ht = !0, At();
      var St = function(Ft) {
        return it.slice().forEach(Ft);
      }, Nt = function(Ft) {
        St(function(Vt) {
          var on = Vt.window;
          return Ft(on);
        }), Ft(tt), tt.unsubscribe();
      };
      return ot.subscribe(we.createOperatorSubscriber(tt, function(Ft) {
        St(function(Vt) {
          Vt.window.next(Ft), Ye <= ++Vt.seen && gt(Vt);
        });
      }, function() {
        return Nt(function(Ft) {
          return Ft.complete();
        });
      }, function(Ft) {
        return Nt(function(Vt) {
          return Vt.error(Ft);
        });
      })), function() {
        it = null;
      };
    });
  }
  ne.windowTime = $e;
}), n4 = M((ne) => {
  var oe = ne && ne.__values || function(Re) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, je = Ne && Re[Ne], Be = 0;
    if (je)
      return je.call(Re);
    if (Re && typeof Re.length == "number")
      return { next: function() {
        return Re && Be >= Re.length && (Re = void 0), { value: Re && Re[Be++], done: !Re };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowToggle = void 0;
  var ae = Tn(), fe = Oi(), ye = he(), we = _t(), _e = Ae(), xe = On(), Oe = ku();
  function $e(Re, Ne) {
    return ye.operate(function(je, Be) {
      var ze = [], He = function(qe) {
        for (; 0 < ze.length; )
          ze.shift().error(qe);
        Be.error(qe);
      };
      we.innerFrom(Re).subscribe(_e.createOperatorSubscriber(Be, function(qe) {
        var Ye = new ae.Subject();
        ze.push(Ye);
        var ot = new fe.Subscription(), tt = function() {
          Oe.arrRemove(ze, Ye), Ye.complete(), ot.unsubscribe();
        }, it;
        try {
          it = we.innerFrom(Ne(qe));
        } catch (ht) {
          He(ht);
          return;
        }
        Be.next(Ye.asObservable()), ot.add(it.subscribe(_e.createOperatorSubscriber(Be, tt, xe.noop, He)));
      }, xe.noop)), je.subscribe(_e.createOperatorSubscriber(Be, function(qe) {
        var Ye, ot, tt = ze.slice();
        try {
          for (var it = oe(tt), ht = it.next(); !ht.done; ht = it.next()) {
            var gt = ht.value;
            gt.next(qe);
          }
        } catch (At) {
          Ye = { error: At };
        } finally {
          try {
            ht && !ht.done && (ot = it.return) && ot.call(it);
          } finally {
            if (Ye)
              throw Ye.error;
          }
        }
      }, function() {
        for (; 0 < ze.length; )
          ze.shift().complete();
        Be.complete();
      }, He, function() {
        for (; 0 < ze.length; )
          ze.shift().unsubscribe();
      }));
    });
  }
  ne.windowToggle = $e;
}), a4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = _t();
  function we(_e) {
    return ae.operate(function(xe, Oe) {
      var $e, Re, Ne = function(Be) {
        $e.error(Be), Oe.error(Be);
      }, je = function() {
        Re == null || Re.unsubscribe(), $e == null || $e.complete(), $e = new oe.Subject(), Oe.next($e.asObservable());
        var Be;
        try {
          Be = ye.innerFrom(_e());
        } catch (ze) {
          Ne(ze);
          return;
        }
        Be.subscribe(Re = fe.createOperatorSubscriber(Oe, je, je, Ne));
      };
      je(), xe.subscribe(fe.createOperatorSubscriber(Oe, function(Be) {
        return $e.next(Be);
      }, function() {
        $e.complete(), Oe.complete();
      }, Ne, function() {
        Re == null || Re.unsubscribe(), $e = null;
      }));
    });
  }
  ne.windowWhen = we;
}), s4 = M((ne) => {
  var oe = ne && ne.__read || function(Re, Ne) {
    var je = typeof Symbol == "function" && Re[Symbol.iterator];
    if (!je)
      return Re;
    var Be = je.call(Re), ze, He = [], qe;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (Ye) {
      qe = { error: Ye };
    } finally {
      try {
        ze && !ze.done && (je = Be.return) && je.call(Be);
      } finally {
        if (qe)
          throw qe.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function(Re, Ne) {
    for (var je = 0, Be = Ne.length, ze = Re.length; je < Be; je++, ze++)
      Re[ze] = Ne[je];
    return Re;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.withLatestFrom = void 0;
  var fe = he(), ye = Ae(), we = _t(), _e = Hn(), xe = On(), Oe = ki();
  function $e() {
    for (var Re = [], Ne = 0; Ne < arguments.length; Ne++)
      Re[Ne] = arguments[Ne];
    var je = Oe.popResultSelector(Re);
    return fe.operate(function(Be, ze) {
      for (var He = Re.length, qe = new Array(He), Ye = Re.map(function() {
        return !1;
      }), ot = !1, tt = function(ht) {
        we.innerFrom(Re[ht]).subscribe(ye.createOperatorSubscriber(ze, function(gt) {
          qe[ht] = gt, !ot && !Ye[ht] && (Ye[ht] = !0, (ot = Ye.every(_e.identity)) && (Ye = null));
        }, xe.noop));
      }, it = 0; it < He; it++)
        tt(it);
      Be.subscribe(ye.createOperatorSubscriber(ze, function(ht) {
        if (ot) {
          var gt = ae([ht], oe(qe));
          ze.next(je ? je.apply(void 0, ae([], oe(gt))) : gt);
        }
      }));
    });
  }
  ne.withLatestFrom = $e;
}), c4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipAll = void 0;
  var oe = h_(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.zip, ye);
  }
  ne.zipAll = fe;
}), f4 = M((ne) => {
  var oe = ne && ne.__read || function(_e, xe) {
    var Oe = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Oe)
      return _e;
    var $e = Oe.call(_e), Re, Ne = [], je;
    try {
      for (; (xe === void 0 || xe-- > 0) && !(Re = $e.next()).done; )
        Ne.push(Re.value);
    } catch (Be) {
      je = { error: Be };
    } finally {
      try {
        Re && !Re.done && (Oe = $e.return) && Oe.call($e);
      } finally {
        if (je)
          throw je.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(_e, xe) {
    for (var Oe = 0, $e = xe.length, Re = _e.length; Oe < $e; Oe++, Re++)
      _e[Re] = xe[Oe];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = h_(), ye = he();
  function we() {
    for (var _e = [], xe = 0; xe < arguments.length; xe++)
      _e[xe] = arguments[xe];
    return ye.operate(function(Oe, $e) {
      fe.zip.apply(void 0, ae([Oe], oe(_e))).subscribe($e);
    });
  }
  ne.zip = we;
}), d4 = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var xe = typeof Symbol == "function" && we[Symbol.iterator];
    if (!xe)
      return we;
    var Oe = xe.call(we), $e, Re = [], Ne;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Oe.next()).done; )
        Re.push($e.value);
    } catch (je) {
      Ne = { error: je };
    } finally {
      try {
        $e && !$e.done && (xe = Oe.return) && xe.call(Oe);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return Re;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var xe = 0, Oe = _e.length, $e = we.length; xe < Oe; xe++, $e++)
      we[$e] = _e[xe];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipWith = void 0;
  var fe = f4();
  function ye() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return fe.zip.apply(void 0, ae([], oe(we)));
  }
  ne.zipWith = ye;
}), WA = M((ne) => {
  var oe = ne && ne.__createBinding || (Object.create ? function(Ot, $t, Xt, An) {
    An === void 0 && (An = Xt), Object.defineProperty(Ot, An, { enumerable: !0, get: function() {
      return $t[Xt];
    } });
  } : function(Ot, $t, Xt, An) {
    An === void 0 && (An = Xt), Ot[An] = $t[Xt];
  }), ae = ne && ne.__exportStar || function(Ot, $t) {
    for (var Xt in Ot)
      Xt !== "default" && !Object.prototype.hasOwnProperty.call($t, Xt) && oe($t, Ot, Xt);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = ne.iif = ne.generate = ne.fromEventPattern = ne.fromEvent = ne.from = ne.forkJoin = ne.empty = ne.defer = ne.connectable = ne.concat = ne.combineLatest = ne.bindNodeCallback = ne.bindCallback = ne.UnsubscriptionError = ne.TimeoutError = ne.SequenceError = ne.ObjectUnsubscribedError = ne.NotFoundError = ne.EmptyError = ne.ArgumentOutOfRangeError = ne.firstValueFrom = ne.lastValueFrom = ne.isObservable = ne.identity = ne.noop = ne.pipe = ne.NotificationKind = ne.Notification = ne.Subscriber = ne.Subscription = ne.Scheduler = ne.VirtualAction = ne.VirtualTimeScheduler = ne.animationFrameScheduler = ne.animationFrame = ne.queueScheduler = ne.queue = ne.asyncScheduler = ne.async = ne.asapScheduler = ne.asap = ne.AsyncSubject = ne.ReplaySubject = ne.BehaviorSubject = ne.Subject = ne.animationFrames = ne.observable = ne.ConnectableObservable = ne.Observable = void 0, ne.filter = ne.expand = ne.exhaustMap = ne.exhaustAll = ne.exhaust = ne.every = ne.endWith = ne.elementAt = ne.distinctUntilKeyChanged = ne.distinctUntilChanged = ne.distinct = ne.dematerialize = ne.delayWhen = ne.delay = ne.defaultIfEmpty = ne.debounceTime = ne.debounce = ne.count = ne.connect = ne.concatWith = ne.concatMapTo = ne.concatMap = ne.concatAll = ne.combineLatestWith = ne.combineLatestAll = ne.combineAll = ne.catchError = ne.bufferWhen = ne.bufferToggle = ne.bufferTime = ne.bufferCount = ne.buffer = ne.auditTime = ne.audit = ne.config = ne.NEVER = ne.EMPTY = ne.scheduled = ne.zip = ne.using = ne.timer = ne.throwError = ne.range = ne.race = ne.partition = ne.pairs = ne.onErrorResumeNext = ne.of = ne.never = ne.merge = void 0, ne.switchMapTo = ne.switchMap = ne.switchAll = ne.subscribeOn = ne.startWith = ne.skipWhile = ne.skipUntil = ne.skipLast = ne.skip = ne.single = ne.shareReplay = ne.share = ne.sequenceEqual = ne.scan = ne.sampleTime = ne.sample = ne.refCount = ne.retryWhen = ne.retry = ne.repeatWhen = ne.repeat = ne.reduce = ne.raceWith = ne.publishReplay = ne.publishLast = ne.publishBehavior = ne.publish = ne.pluck = ne.pairwise = ne.observeOn = ne.multicast = ne.min = ne.mergeWith = ne.mergeScan = ne.mergeMapTo = ne.mergeMap = ne.flatMap = ne.mergeAll = ne.max = ne.materialize = ne.mapTo = ne.map = ne.last = ne.isEmpty = ne.ignoreElements = ne.groupBy = ne.first = ne.findIndex = ne.find = ne.finalize = void 0, ne.zipWith = ne.zipAll = ne.withLatestFrom = ne.windowWhen = ne.windowToggle = ne.windowTime = ne.windowCount = ne.window = ne.toArray = ne.timestamp = ne.timeoutWith = ne.timeout = ne.timeInterval = ne.throwIfEmpty = ne.throttleTime = ne.throttle = ne.tap = ne.takeWhile = ne.takeUntil = ne.takeLast = ne.take = ne.switchScan = void 0;
  var fe = qt();
  Object.defineProperty(ne, "Observable", { enumerable: !0, get: function() {
    return fe.Observable;
  } });
  var ye = sh();
  Object.defineProperty(ne, "ConnectableObservable", { enumerable: !0, get: function() {
    return ye.ConnectableObservable;
  } });
  var we = uh();
  Object.defineProperty(ne, "observable", { enumerable: !0, get: function() {
    return we.observable;
  } });
  var _e = hI();
  Object.defineProperty(ne, "animationFrames", { enumerable: !0, get: function() {
    return _e.animationFrames;
  } });
  var xe = Tn();
  Object.defineProperty(ne, "Subject", { enumerable: !0, get: function() {
    return xe.Subject;
  } });
  var Oe = Xk();
  Object.defineProperty(ne, "BehaviorSubject", { enumerable: !0, get: function() {
    return Oe.BehaviorSubject;
  } });
  var $e = nS();
  Object.defineProperty(ne, "ReplaySubject", { enumerable: !0, get: function() {
    return $e.ReplaySubject;
  } });
  var Re = iS();
  Object.defineProperty(ne, "AsyncSubject", { enumerable: !0, get: function() {
    return Re.AsyncSubject;
  } });
  var Ne = DI();
  Object.defineProperty(ne, "asap", { enumerable: !0, get: function() {
    return Ne.asap;
  } }), Object.defineProperty(ne, "asapScheduler", { enumerable: !0, get: function() {
    return Ne.asapScheduler;
  } });
  var je = Ti();
  Object.defineProperty(ne, "async", { enumerable: !0, get: function() {
    return je.async;
  } }), Object.defineProperty(ne, "asyncScheduler", { enumerable: !0, get: function() {
    return je.asyncScheduler;
  } });
  var Be = jI();
  Object.defineProperty(ne, "queue", { enumerable: !0, get: function() {
    return Be.queue;
  } }), Object.defineProperty(ne, "queueScheduler", { enumerable: !0, get: function() {
    return Be.queueScheduler;
  } });
  var ze = qI();
  Object.defineProperty(ne, "animationFrame", { enumerable: !0, get: function() {
    return ze.animationFrame;
  } }), Object.defineProperty(ne, "animationFrameScheduler", { enumerable: !0, get: function() {
    return ze.animationFrameScheduler;
  } });
  var He = HI();
  Object.defineProperty(ne, "VirtualTimeScheduler", { enumerable: !0, get: function() {
    return He.VirtualTimeScheduler;
  } }), Object.defineProperty(ne, "VirtualAction", { enumerable: !0, get: function() {
    return He.VirtualAction;
  } });
  var qe = Zk();
  Object.defineProperty(ne, "Scheduler", { enumerable: !0, get: function() {
    return qe.Scheduler;
  } });
  var Ye = Oi();
  Object.defineProperty(ne, "Subscription", { enumerable: !0, get: function() {
    return Ye.Subscription;
  } });
  var ot = Sd();
  Object.defineProperty(ne, "Subscriber", { enumerable: !0, get: function() {
    return ot.Subscriber;
  } });
  var tt = AS();
  Object.defineProperty(ne, "Notification", { enumerable: !0, get: function() {
    return tt.Notification;
  } }), Object.defineProperty(ne, "NotificationKind", { enumerable: !0, get: function() {
    return tt.NotificationKind;
  } });
  var it = lh();
  Object.defineProperty(ne, "pipe", { enumerable: !0, get: function() {
    return it.pipe;
  } });
  var ht = On();
  Object.defineProperty(ne, "noop", { enumerable: !0, get: function() {
    return ht.noop;
  } });
  var gt = Hn();
  Object.defineProperty(ne, "identity", { enumerable: !0, get: function() {
    return gt.identity;
  } });
  var At = o3();
  Object.defineProperty(ne, "isObservable", { enumerable: !0, get: function() {
    return At.isObservable;
  } });
  var St = u3();
  Object.defineProperty(ne, "lastValueFrom", { enumerable: !0, get: function() {
    return St.lastValueFrom;
  } });
  var Nt = l3();
  Object.defineProperty(ne, "firstValueFrom", { enumerable: !0, get: function() {
    return Nt.firstValueFrom;
  } });
  var Ft = vA();
  Object.defineProperty(ne, "ArgumentOutOfRangeError", { enumerable: !0, get: function() {
    return Ft.ArgumentOutOfRangeError;
  } });
  var Vt = $l();
  Object.defineProperty(ne, "EmptyError", { enumerable: !0, get: function() {
    return Vt.EmptyError;
  } });
  var on = mA();
  Object.defineProperty(ne, "NotFoundError", { enumerable: !0, get: function() {
    return on.NotFoundError;
  } });
  var tn = Yk();
  Object.defineProperty(ne, "ObjectUnsubscribedError", { enumerable: !0, get: function() {
    return tn.ObjectUnsubscribedError;
  } });
  var _n = hA();
  Object.defineProperty(ne, "SequenceError", { enumerable: !0, get: function() {
    return _n.SequenceError;
  } });
  var en = qS();
  Object.defineProperty(ne, "TimeoutError", { enumerable: !0, get: function() {
    return en.TimeoutError;
  } });
  var dn = Nk();
  Object.defineProperty(ne, "UnsubscriptionError", { enumerable: !0, get: function() {
    return dn.UnsubscriptionError;
  } });
  var Ht = c3();
  Object.defineProperty(ne, "bindCallback", { enumerable: !0, get: function() {
    return Ht.bindCallback;
  } });
  var hn = f3();
  Object.defineProperty(ne, "bindNodeCallback", { enumerable: !0, get: function() {
    return hn.bindNodeCallback;
  } });
  var kn = WS();
  Object.defineProperty(ne, "combineLatest", { enumerable: !0, get: function() {
    return kn.combineLatest;
  } });
  var Dn = hh();
  Object.defineProperty(ne, "concat", { enumerable: !0, get: function() {
    return Dn.concat;
  } });
  var yt = b3();
  Object.defineProperty(ne, "connectable", { enumerable: !0, get: function() {
    return yt.connectable;
  } });
  var jt = yh();
  Object.defineProperty(ne, "defer", { enumerable: !0, get: function() {
    return jt.defer;
  } });
  var Mn = ba();
  Object.defineProperty(ne, "empty", { enumerable: !0, get: function() {
    return Mn.empty;
  } });
  var $n = S3();
  Object.defineProperty(ne, "forkJoin", { enumerable: !0, get: function() {
    return $n.forkJoin;
  } });
  var Zt = Ja();
  Object.defineProperty(ne, "from", { enumerable: !0, get: function() {
    return Zt.from;
  } });
  var vn = w3();
  Object.defineProperty(ne, "fromEvent", { enumerable: !0, get: function() {
    return vn.fromEvent;
  } });
  var Fn = E3();
  Object.defineProperty(ne, "fromEventPattern", { enumerable: !0, get: function() {
    return Fn.fromEventPattern;
  } });
  var Qn = R3();
  Object.defineProperty(ne, "generate", { enumerable: !0, get: function() {
    return Qn.generate;
  } });
  var Un = O3();
  Object.defineProperty(ne, "iif", { enumerable: !0, get: function() {
    return Un.iif;
  } });
  var ar = wA();
  Object.defineProperty(ne, "interval", { enumerable: !0, get: function() {
    return ar.interval;
  } });
  var Zo = k3();
  Object.defineProperty(ne, "merge", { enumerable: !0, get: function() {
    return Zo.merge;
  } });
  var ao = xA();
  Object.defineProperty(ne, "never", { enumerable: !0, get: function() {
    return ao.never;
  } });
  var Yr = TS();
  Object.defineProperty(ne, "of", { enumerable: !0, get: function() {
    return Yr.of;
  } });
  var so = M3();
  Object.defineProperty(ne, "onErrorResumeNext", { enumerable: !0, get: function() {
    return so.onErrorResumeNext;
  } });
  var Io = D3();
  Object.defineProperty(ne, "pairs", { enumerable: !0, get: function() {
    return Io.pairs;
  } });
  var Po = U3();
  Object.defineProperty(ne, "partition", { enumerable: !0, get: function() {
    return Po.partition;
  } });
  var vo = EA();
  Object.defineProperty(ne, "race", { enumerable: !0, get: function() {
    return vo.race;
  } });
  var na = q3();
  Object.defineProperty(ne, "range", { enumerable: !0, get: function() {
    return na.range;
  } });
  var va = pA();
  Object.defineProperty(ne, "throwError", { enumerable: !0, get: function() {
    return va.throwError;
  } });
  var go = Kl();
  Object.defineProperty(ne, "timer", { enumerable: !0, get: function() {
    return go.timer;
  } });
  var Fo = I3();
  Object.defineProperty(ne, "using", { enumerable: !0, get: function() {
    return Fo.using;
  } });
  var Ro = h_();
  Object.defineProperty(ne, "zip", { enumerable: !0, get: function() {
    return Ro.zip;
  } });
  var la = dA();
  Object.defineProperty(ne, "scheduled", { enumerable: !0, get: function() {
    return la.scheduled;
  } });
  var Ia = ba();
  Object.defineProperty(ne, "EMPTY", { enumerable: !0, get: function() {
    return Ia.EMPTY;
  } });
  var Go = xA();
  Object.defineProperty(ne, "NEVER", { enumerable: !0, get: function() {
    return Go.NEVER;
  } }), ae(H3(), ne);
  var Yo = gd();
  Object.defineProperty(ne, "config", { enumerable: !0, get: function() {
    return Yo.config;
  } });
  var Ra = CA();
  Object.defineProperty(ne, "audit", { enumerable: !0, get: function() {
    return Ra.audit;
  } });
  var Bo = $3();
  Object.defineProperty(ne, "auditTime", { enumerable: !0, get: function() {
    return Bo.auditTime;
  } });
  var Na = Y3();
  Object.defineProperty(ne, "buffer", { enumerable: !0, get: function() {
    return Na.buffer;
  } });
  var Bt = G3();
  Object.defineProperty(ne, "bufferCount", { enumerable: !0, get: function() {
    return Bt.bufferCount;
  } });
  var Kt = K3();
  Object.defineProperty(ne, "bufferTime", { enumerable: !0, get: function() {
    return Kt.bufferTime;
  } });
  var mn = Z3();
  Object.defineProperty(ne, "bufferToggle", { enumerable: !0, get: function() {
    return mn.bufferToggle;
  } });
  var jn = tB();
  Object.defineProperty(ne, "bufferWhen", { enumerable: !0, get: function() {
    return jn.bufferWhen;
  } });
  var zn = nB();
  Object.defineProperty(ne, "catchError", { enumerable: !0, get: function() {
    return zn.catchError;
  } });
  var qn = iB();
  Object.defineProperty(ne, "combineAll", { enumerable: !0, get: function() {
    return qn.combineAll;
  } });
  var rr = PA();
  Object.defineProperty(ne, "combineLatestAll", { enumerable: !0, get: function() {
    return rr.combineLatestAll;
  } });
  var or = sB();
  Object.defineProperty(ne, "combineLatestWith", { enumerable: !0, get: function() {
    return or.combineLatestWith;
  } });
  var Wn = JS();
  Object.defineProperty(ne, "concatAll", { enumerable: !0, get: function() {
    return Wn.concatAll;
  } });
  var Ar = MA();
  Object.defineProperty(ne, "concatMap", { enumerable: !0, get: function() {
    return Ar.concatMap;
  } });
  var Br = dB();
  Object.defineProperty(ne, "concatMapTo", { enumerable: !0, get: function() {
    return Br.concatMapTo;
  } });
  var wo = vB();
  Object.defineProperty(ne, "concatWith", { enumerable: !0, get: function() {
    return wo.concatWith;
  } });
  var wr = M_();
  Object.defineProperty(ne, "connect", { enumerable: !0, get: function() {
    return wr.connect;
  } });
  var _r = hB();
  Object.defineProperty(ne, "count", { enumerable: !0, get: function() {
    return _r.count;
  } });
  var To = gB();
  Object.defineProperty(ne, "debounce", { enumerable: !0, get: function() {
    return To.debounce;
  } });
  var Ha = bB();
  Object.defineProperty(ne, "debounceTime", { enumerable: !0, get: function() {
    return Ha.debounceTime;
  } });
  var Bi = gh();
  Object.defineProperty(ne, "defaultIfEmpty", { enumerable: !0, get: function() {
    return Bi.defaultIfEmpty;
  } });
  var Ui = wB();
  Object.defineProperty(ne, "delay", { enumerable: !0, get: function() {
    return Ui.delay;
  } });
  var qa = LA();
  Object.defineProperty(ne, "delayWhen", { enumerable: !0, get: function() {
    return qa.delayWhen;
  } });
  var si = xB();
  Object.defineProperty(ne, "dematerialize", { enumerable: !0, get: function() {
    return si.dematerialize;
  } });
  var ra = CB();
  Object.defineProperty(ne, "distinct", { enumerable: !0, get: function() {
    return ra.distinct;
  } });
  var Ta = jA();
  Object.defineProperty(ne, "distinctUntilChanged", { enumerable: !0, get: function() {
    return Ta.distinctUntilChanged;
  } });
  var ci = RB();
  Object.defineProperty(ne, "distinctUntilKeyChanged", { enumerable: !0, get: function() {
    return ci.distinctUntilKeyChanged;
  } });
  var wa = TB();
  Object.defineProperty(ne, "elementAt", { enumerable: !0, get: function() {
    return wa.elementAt;
  } });
  var fo = kB();
  Object.defineProperty(ne, "endWith", { enumerable: !0, get: function() {
    return fo.endWith;
  } });
  var _o = AB();
  Object.defineProperty(ne, "every", { enumerable: !0, get: function() {
    return _o.every;
  } });
  var oa = MB();
  Object.defineProperty(ne, "exhaust", { enumerable: !0, get: function() {
    return oa.exhaust;
  } });
  var Ma = UA();
  Object.defineProperty(ne, "exhaustAll", { enumerable: !0, get: function() {
    return Ma.exhaustAll;
  } });
  var Rt = jB();
  Object.defineProperty(ne, "exhaustMap", { enumerable: !0, get: function() {
    return Rt.exhaustMap;
  } });
  var Cn = UB();
  Object.defineProperty(ne, "expand", { enumerable: !0, get: function() {
    return Cn.expand;
  } });
  var Pn = _c();
  Object.defineProperty(ne, "filter", { enumerable: !0, get: function() {
    return Pn.filter;
  } });
  var hr = FB();
  Object.defineProperty(ne, "finalize", { enumerable: !0, get: function() {
    return hr.finalize;
  } });
  var Dr = FA();
  Object.defineProperty(ne, "find", { enumerable: !0, get: function() {
    return Dr.find;
  } });
  var Jr = qB();
  Object.defineProperty(ne, "findIndex", { enumerable: !0, get: function() {
    return Jr.findIndex;
  } });
  var zr = IB();
  Object.defineProperty(ne, "first", { enumerable: !0, get: function() {
    return zr.first;
  } });
  var gr = HB();
  Object.defineProperty(ne, "groupBy", { enumerable: !0, get: function() {
    return gr.groupBy;
  } });
  var aa = DA();
  Object.defineProperty(ne, "ignoreElements", { enumerable: !0, get: function() {
    return aa.ignoreElements;
  } });
  var Oo = VB();
  Object.defineProperty(ne, "isEmpty", { enumerable: !0, get: function() {
    return Oo.isEmpty;
  } });
  var Ao = $B();
  Object.defineProperty(ne, "last", { enumerable: !0, get: function() {
    return Ao.last;
  } });
  var ka = Wl();
  Object.defineProperty(ne, "map", { enumerable: !0, get: function() {
    return ka.map;
  } });
  var ys = NA();
  Object.defineProperty(ne, "mapTo", { enumerable: !0, get: function() {
    return ys.mapTo;
  } });
  var Qu = WB();
  Object.defineProperty(ne, "materialize", { enumerable: !0, get: function() {
    return Qu.materialize;
  } });
  var uo = YB();
  Object.defineProperty(ne, "max", { enumerable: !0, get: function() {
    return uo.max;
  } });
  var nd = mh();
  Object.defineProperty(ne, "mergeAll", { enumerable: !0, get: function() {
    return nd.mergeAll;
  } });
  var Yi = GB();
  Object.defineProperty(ne, "flatMap", { enumerable: !0, get: function() {
    return Yi.flatMap;
  } });
  var Wr = Mu();
  Object.defineProperty(ne, "mergeMap", { enumerable: !0, get: function() {
    return Wr.mergeMap;
  } });
  var Ea = KB();
  Object.defineProperty(ne, "mergeMapTo", { enumerable: !0, get: function() {
    return Ea.mergeMapTo;
  } });
  var Ku = XB();
  Object.defineProperty(ne, "mergeScan", { enumerable: !0, get: function() {
    return Ku.mergeScan;
  } });
  var Fu = eH();
  Object.defineProperty(ne, "mergeWith", { enumerable: !0, get: function() {
    return Fu.mergeWith;
  } });
  var Ms = tH();
  Object.defineProperty(ne, "min", { enumerable: !0, get: function() {
    return Ms.min;
  } });
  var Ka = dw();
  Object.defineProperty(ne, "multicast", { enumerable: !0, get: function() {
    return Ka.multicast;
  } });
  var Xu = ph();
  Object.defineProperty(ne, "observeOn", { enumerable: !0, get: function() {
    return Xu.observeOn;
  } });
  var ja = nH();
  Object.defineProperty(ne, "pairwise", { enumerable: !0, get: function() {
    return ja.pairwise;
  } });
  var Ju = iH();
  Object.defineProperty(ne, "pluck", { enumerable: !0, get: function() {
    return Ju.pluck;
  } });
  var el = aH();
  Object.defineProperty(ne, "publish", { enumerable: !0, get: function() {
    return el.publish;
  } });
  var rd = oH();
  Object.defineProperty(ne, "publishBehavior", { enumerable: !0, get: function() {
    return rd.publishBehavior;
  } });
  var tl = uH();
  Object.defineProperty(ne, "publishLast", { enumerable: !0, get: function() {
    return tl.publishLast;
  } });
  var Vi = sH();
  Object.defineProperty(ne, "publishReplay", { enumerable: !0, get: function() {
    return Vi.publishReplay;
  } });
  var gi = cH();
  Object.defineProperty(ne, "raceWith", { enumerable: !0, get: function() {
    return gi.raceWith;
  } });
  var ca = Qd();
  Object.defineProperty(ne, "reduce", { enumerable: !0, get: function() {
    return ca.reduce;
  } });
  var js = dH();
  Object.defineProperty(ne, "repeat", { enumerable: !0, get: function() {
    return js.repeat;
  } });
  var Hi = vH();
  Object.defineProperty(ne, "repeatWhen", { enumerable: !0, get: function() {
    return Hi.repeatWhen;
  } });
  var gl = hH();
  Object.defineProperty(ne, "retry", { enumerable: !0, get: function() {
    return gl.retry;
  } });
  var ru = gH();
  Object.defineProperty(ne, "retryWhen", { enumerable: !0, get: function() {
    return ru.retryWhen;
  } });
  var wl = $k();
  Object.defineProperty(ne, "refCount", { enumerable: !0, get: function() {
    return wl.refCount;
  } });
  var Ds = IA();
  Object.defineProperty(ne, "sample", { enumerable: !0, get: function() {
    return Ds.sample;
  } });
  var Ls = SH();
  Object.defineProperty(ne, "sampleTime", { enumerable: !0, get: function() {
    return Ls.sampleTime;
  } });
  var Fs = _H();
  Object.defineProperty(ne, "scan", { enumerable: !0, get: function() {
    return Fs.scan;
  } });
  var po = xH();
  Object.defineProperty(ne, "sequenceEqual", { enumerable: !0, get: function() {
    return po.sequenceEqual;
  } });
  var ts = HA();
  Object.defineProperty(ne, "share", { enumerable: !0, get: function() {
    return ts.share;
  } });
  var fc = EH();
  Object.defineProperty(ne, "shareReplay", { enumerable: !0, get: function() {
    return fc.shareReplay;
  } });
  var Da = CH();
  Object.defineProperty(ne, "single", { enumerable: !0, get: function() {
    return Da.single;
  } });
  var ho = RH();
  Object.defineProperty(ne, "skip", { enumerable: !0, get: function() {
    return ho.skip;
  } });
  var nl = OH();
  Object.defineProperty(ne, "skipLast", { enumerable: !0, get: function() {
    return nl.skipLast;
  } });
  var _l = kH();
  Object.defineProperty(ne, "skipUntil", { enumerable: !0, get: function() {
    return _l.skipUntil;
  } });
  var Mr = AH();
  Object.defineProperty(ne, "skipWhile", { enumerable: !0, get: function() {
    return Mr.skipWhile;
  } });
  var Bs = MH();
  Object.defineProperty(ne, "startWith", { enumerable: !0, get: function() {
    return Bs.startWith;
  } });
  var Wo = vh();
  Object.defineProperty(ne, "subscribeOn", { enumerable: !0, get: function() {
    return Wo.subscribeOn;
  } });
  var La = NH();
  Object.defineProperty(ne, "switchAll", { enumerable: !0, get: function() {
    return La.switchAll;
  } });
  var Fa = Sh();
  Object.defineProperty(ne, "switchMap", { enumerable: !0, get: function() {
    return Fa.switchMap;
  } });
  var zs = jH();
  Object.defineProperty(ne, "switchMapTo", { enumerable: !0, get: function() {
    return zs.switchMapTo;
  } });
  var Qo = UH();
  Object.defineProperty(ne, "switchScan", { enumerable: !0, get: function() {
    return Qo.switchScan;
  } });
  var mo = Kd();
  Object.defineProperty(ne, "take", { enumerable: !0, get: function() {
    return mo.take;
  } });
  var El = zA();
  Object.defineProperty(ne, "takeLast", { enumerable: !0, get: function() {
    return El.takeLast;
  } });
  var wi = FH();
  Object.defineProperty(ne, "takeUntil", { enumerable: !0, get: function() {
    return wi.takeUntil;
  } });
  var xa = zH();
  Object.defineProperty(ne, "takeWhile", { enumerable: !0, get: function() {
    return xa.takeWhile;
  } });
  var bs = qH();
  Object.defineProperty(ne, "tap", { enumerable: !0, get: function() {
    return bs.tap;
  } });
  var rl = VA();
  Object.defineProperty(ne, "throttle", { enumerable: !0, get: function() {
    return rl.throttle;
  } });
  var di = HH();
  Object.defineProperty(ne, "throttleTime", { enumerable: !0, get: function() {
    return di.throttleTime;
  } });
  var xl = bh();
  Object.defineProperty(ne, "throwIfEmpty", { enumerable: !0, get: function() {
    return xl.throwIfEmpty;
  } });
  var fi = $H();
  Object.defineProperty(ne, "timeInterval", { enumerable: !0, get: function() {
    return fi.timeInterval;
  } });
  var Us = qS();
  Object.defineProperty(ne, "timeout", { enumerable: !0, get: function() {
    return Us.timeout;
  } });
  var ou = WH();
  Object.defineProperty(ne, "timeoutWith", { enumerable: !0, get: function() {
    return ou.timeoutWith;
  } });
  var pi = YH();
  Object.defineProperty(ne, "timestamp", { enumerable: !0, get: function() {
    return pi.timestamp;
  } });
  var Ei = kA();
  Object.defineProperty(ne, "toArray", { enumerable: !0, get: function() {
    return Ei.toArray;
  } });
  var au = KH();
  Object.defineProperty(ne, "window", { enumerable: !0, get: function() {
    return au.window;
  } });
  var vs = JH();
  Object.defineProperty(ne, "windowCount", { enumerable: !0, get: function() {
    return vs.windowCount;
  } });
  var ol = e4();
  Object.defineProperty(ne, "windowTime", { enumerable: !0, get: function() {
    return ol.windowTime;
  } });
  var Bu = n4();
  Object.defineProperty(ne, "windowToggle", { enumerable: !0, get: function() {
    return Bu.windowToggle;
  } });
  var al = a4();
  Object.defineProperty(ne, "windowWhen", { enumerable: !0, get: function() {
    return al.windowWhen;
  } });
  var Sl = s4();
  Object.defineProperty(ne, "withLatestFrom", { enumerable: !0, get: function() {
    return Sl.withLatestFrom;
  } });
  var Ge = c4();
  Object.defineProperty(ne, "zipAll", { enumerable: !0, get: function() {
    return Ge.zipAll;
  } });
  var dt = d4();
  Object.defineProperty(ne, "zipWith", { enumerable: !0, get: function() {
    return dt.zipWith;
  } });
});
function Kw(ne, oe) {
  let ae = (oe == null ? void 0 : oe.updateOnValueChange) ?? !0, fe = Nge(ne), ye = (0, rp.useMemo)(() => f$2(fe, { runOnInit: !0 }), [fe]), [we, _e] = (0, rp.useState)([...ye.matching]);
  return (0, rp.useEffect)(() => {
    _e([...ye.matching]);
    let xe = ye.update$.pipe((0, Qw.map)(() => [...ye.matching]));
    ae || (xe = xe.pipe((0, Qw.distinctUntilChanged)(($e, Re) => (0, _4.default)($e, Re))));
    let Oe = xe.subscribe(($e) => _e($e));
    return () => Oe.unsubscribe();
  }, [ye, ae]), we;
}
function w4(ne, oe) {
  let [ae, fe] = (0, Xw.useState)(oe);
  return (0, Xw.useEffect)(() => {
    let ye = ne.subscribe(fe);
    return () => ye.unsubscribe();
  }, [ne]), ae;
}
function _h(ne) {
  let oe = (0, xc.useRef)(ne), [ae, fe] = (0, xc.useState)(ne == null ? { status: "idle" } : { status: "pending" });
  return (0, xc.useEffect)(() => {
    ne !== oe.current && (oe.current = ne, fe(ne == null ? { status: "idle" } : { status: "pending" }));
  }, [ne]), (0, xc.useEffect)(() => {
    ne != null && Promise.allSettled([ne]).then(([ye]) => {
      ne === oe.current && fe(ye);
    });
  }, [ne]), ae;
}
var rp, Gw, S4, _4, Qw, Xw, xc, Nge, wh = Y(() => {
  le(ir(), 1), rp = le(ir(), 1), Gw = le(ir(), 1), S4 = le(Dk(), 1), _4 = le(Dk(), 1), Qw = le(WA(), 1), Xw = le(ir(), 1), xc = le(ir(), 1), Nge = (ne) => {
    let [oe, ae] = (0, Gw.useState)(ne);
    return (0, Gw.useEffect)(() => {
      (0, S4.default)(ne, oe) || ae(ne);
    }, [ne]), oe;
  };
});
function E4() {
  var ye, we;
  let { publicClient: ne, worldAddress: oe, latestBlock$: ae } = zt(), fe = w4(ae.pipe((0, x4.map)((_e) => _e.number)));
  return (0, Za.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Chain" }), (0, Za.jsxs)("dd", { className: "text-sm", children: [(ye = ne.chain) == null ? void 0 : ye.id, " (", (we = ne.chain) == null ? void 0 : we.name, ")"] }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Block number" }), (0, Za.jsx)("dd", { className: "text-sm", children: fe == null ? void 0 : fe.toString() }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "RPC" }), (0, Za.jsx)("dd", { className: "text-sm text-green-500", children: "Connected " }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "World" }), (0, Za.jsx)("dd", { className: "text-sm", children: oe })] });
}
var x4, Za, C4 = Y(() => {
  wh(), ai(), x4 = le(WA(), 1), Za = le(ke(), 1);
});
function R4(ne, oe) {
  var ae;
  return (ae = ne.exec(oe)) == null ? void 0 : ae.groups;
}
var O4 = Y(() => {
});
function Jw(ne) {
  let oe = ne.type;
  if (T4.test(ne.type) && "components" in ne) {
    oe = "(";
    let ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      let we = ne.components[ye];
      oe += Jw(we), ye < ae - 1 && (oe += ", ");
    }
    let fe = R4(T4, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, Jw({ ...ne, type: oe });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
var T4, k4 = Y(() => {
  O4(), T4 = /^tuple(?<array>(\[(\d*)\])*)$/;
});
function np(ne) {
  let oe = "", ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    let ye = ne[fe];
    oe += Jw(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
var A4 = Y(() => {
  k4();
});
function YA(ne) {
  return ne.type === "function" ? `function ${ne.name}(${np(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${np(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${np(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${np(ne.inputs)})` : ne.type === "constructor" ? `constructor(${np(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
var P4 = Y(() => {
  A4();
}), M4 = Y(() => {
  P4();
});
function ip(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new Eh(ne.type);
  return `${ne.name}(${xh(ne.inputs, { includeName: oe })})`;
}
function xh(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => Lge(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function Lge(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${xh(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
var Zw = Y(() => {
  ap();
});
function eo(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
var op = Y(() => {
});
function oi(ne) {
  return eo(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
var Ch = Y(() => {
  op();
}), D4, N4 = Y(() => {
  D4 = "2.9.20";
}), L4, j4 = Y(() => {
  N4(), L4 = () => `viem@${D4}`;
});
function U4(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? U4(ne.cause, oe) : oe ? null : ne;
}
var kt, Ec = Y(() => {
  j4(), kt = class extends Error {
    constructor(ne, oe = {}) {
      var ye;
      super(), Object.defineProperty(this, "details", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "docsPath", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "metaMessages", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shortMessage", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "ViemError" }), Object.defineProperty(this, "version", { enumerable: !0, configurable: !0, writable: !0, value: L4() });
      let ae = oe.cause instanceof kt ? oe.cause.details : (ye = oe.cause) != null && ye.message ? oe.cause.message : oe.details, fe = oe.cause instanceof kt && oe.cause.docsPath || oe.docsPath;
      this.message = [ne || "An error occurred.", "", ...oe.metaMessages ? [...oe.metaMessages, ""] : [], ...fe ? [`Docs: https://viem.sh${fe}${oe.docsSlug ? `#${oe.docsSlug}` : ""}`] : [], ...ae ? [`Details: ${ae}`] : [], `Version: ${this.version}`].join(`
`), oe.cause && (this.cause = oe.cause), this.details = ae, this.docsPath = fe, this.metaMessages = oe.metaMessages, this.shortMessage = ne;
    }
    walk(ne) {
      return U4(this, ne);
    }
  };
}), Cc, Rh, Oh, Rc, Th, up, kh, Ah, Eh, ap = Y(() => {
  Zw(), Ec(), Cc = class extends kt {
    constructor({ data: ne, params: oe, size: ae }) {
      super([`Data size of ${ae} bytes is too small for given parameters.`].join(`
`), { metaMessages: [`Params: (${xh(oe, { includeName: !0 })})`, `Data:   ${ne} (${ae} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingDataSizeTooSmallError" }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.data = ne, this.params = oe, this.size = ae;
    }
  }, Rh = class extends kt {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingZeroDataError" });
    }
  }, Oh = class extends kt {
    constructor({ docsPath: ne }) {
      super("Cannot extract event signature from empty topics.", { docsPath: ne }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureEmptyTopicsError" });
    }
  }, Rc = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded event signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureNotFoundError" });
    }
  }, Th = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded function signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiFunctionSignatureNotFoundError" });
    }
  }, up = class extends kt {
    constructor({ abiItem: ne, data: oe, params: ae, size: fe }) {
      super([`Data size of ${fe} bytes is too small for non-indexed event parameters.`].join(`
`), { metaMessages: [`Params: (${xh(ae, { includeName: !0 })})`, `Data:   ${oe} (${fe} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogDataMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne, this.data = oe, this.params = ae, this.size = fe;
    }
  }, kh = class extends kt {
    constructor({ abiItem: ne, param: oe }) {
      super([`Expected a topic for indexed event parameter${oe.name ? ` "${oe.name}"` : ""} on event "${ip(ne, { includeName: !0 })}".`].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne;
    }
  }, Ah = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Type "${ne}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidAbiDecodingType" });
    }
  }, Eh = class extends kt {
    constructor(ne) {
      super([`"${ne}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidDefinitionTypeError" });
    }
  };
}), Ph, Mh, GA = Y(() => {
  Ec(), Ph = class extends kt {
    constructor({ offset: ne, position: oe, size: ae }) {
      super(`Slice ${oe === "start" ? "starting" : "ending"} at offset "${ne}" is out-of-bounds (size: ${ae}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SliceOffsetOutOfBoundsError" });
    }
  }, Mh = class extends kt {
    constructor({ size: ne, targetSize: oe, type: ae }) {
      super(`${ae.charAt(0).toUpperCase()}${ae.slice(1).toLowerCase()} size (${ne}) exceeds padding size (${oe}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeExceedsPaddingSizeError" });
    }
  };
});
function fs(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? jge(ne, { dir: oe, size: ae }) : Uge(ne, { dir: oe, size: ae });
}
function jge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  let fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new Mh({ size: Math.ceil(fe.length / 2), targetSize: ae, type: "hex" });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function Uge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new Mh({ size: ne.length, targetSize: ae, type: "bytes" });
  let fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    let we = oe === "right";
    fe[we ? ye : ae - ye - 1] = ne[we ? ye : ne.length - ye - 1];
  }
  return fe;
}
var QA = Y(() => {
  GA();
}), ex, tx, rx, nx = Y(() => {
  Ec(), ex = class extends kt {
    constructor({ max: ne, min: oe, signed: ae, size: fe, value: ye }) {
      super(`Number "${ye}" is not in safe ${fe ? `${fe * 8}-bit ${ae ? "signed" : "unsigned"} ` : ""}integer range ${ne ? `(${oe} to ${ne})` : `(above ${oe})`}`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "IntegerOutOfRangeError" });
    }
  }, tx = class extends kt {
    constructor(ne) {
      super(`Bytes value "${ne}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidBytesBooleanError" });
    }
  }, rx = class extends kt {
    constructor({ givenSize: ne, maxSize: oe }) {
      super(`Size cannot exceed ${oe} bytes. Given size: ${ne} bytes.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeOverflowError" });
    }
  };
});
function Dh(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
var KA = Y(() => {
});
function Xi(ne, { size: oe }) {
  if (oi(ne) > oe)
    throw new rx({ givenSize: oi(ne), maxSize: oe });
}
function XA(ne, oe = {}) {
  let { signed: ae } = oe;
  oe.size && Xi(ne, { size: oe.size });
  let fe = BigInt(ne);
  if (!ae)
    return fe;
  let ye = (ne.length - 2) / 2, we = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= we ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function Nh(ne, oe = {}) {
  return Number(XA(ne, oe));
}
var Lh = Y(() => {
  nx(), Ch();
});
function F4(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? xt(ne, oe) : typeof ne == "string" ? Ige(ne, oe) : typeof ne == "boolean" ? zge(ne, oe) : _a(ne, oe);
}
function zge(ne, oe = {}) {
  let ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function _a(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += Fge[ne[ye]];
  let fe = `0x${ae}`;
  return typeof oe.size == "number" ? (Xi(fe, { size: oe.size }), fs(fe, { dir: "right", size: oe.size })) : fe;
}
function xt(ne, oe = {}) {
  let { signed: ae, size: fe } = oe, ye = BigInt(ne), we;
  fe ? ae ? we = (1n << BigInt(fe) * 8n - 1n) - 1n : we = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (we = BigInt(Number.MAX_SAFE_INTEGER));
  let _e = typeof we == "bigint" && ae ? -we - 1n : 0;
  if (we && ye > we || ye < _e) {
    let Oe = typeof ne == "bigint" ? "n" : "";
    throw new ex({ max: we ? `${we}${Oe}` : void 0, min: `${_e}${Oe}`, signed: ae, size: fe, value: `${ne}${Oe}` });
  }
  let xe = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? fs(xe, { size: fe }) : xe;
}
function Ige(ne, oe = {}) {
  let ae = qge.encode(ne);
  return _a(ae, oe);
}
var Fge, qge, ui = Y(() => {
  nx(), QA(), Lh(), Fge = Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0")), qge = new TextEncoder();
});
function ix(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? Vge(ne, oe) : typeof ne == "boolean" ? Hge(ne, oe) : eo(ne) ? ax(ne, oe) : JA(ne, oe);
}
function Hge(ne, oe = {}) {
  let ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function z4(ne) {
  if (ne >= Du.zero && ne <= Du.nine)
    return ne - Du.zero;
  if (ne >= Du.A && ne <= Du.F)
    return ne - (Du.A - 10);
  if (ne >= Du.a && ne <= Du.f)
    return ne - (Du.a - 10);
}
function ax(ne, oe = {}) {
  let ae = ne;
  oe.size && (Xi(ae, { size: oe.size }), ae = fs(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  let ye = fe.length / 2, we = new Uint8Array(ye);
  for (let _e = 0, xe = 0; _e < ye; _e++) {
    let Oe = z4(fe.charCodeAt(xe++)), $e = z4(fe.charCodeAt(xe++));
    if (Oe === void 0 || $e === void 0)
      throw new kt(`Invalid byte sequence ("${fe[xe - 2]}${fe[xe - 1]}" in "${fe}").`);
    we[_e] = Oe * 16 + $e;
  }
  return we;
}
function Vge(ne, oe) {
  let ae = xt(ne, oe);
  return ax(ae);
}
function JA(ne, oe = {}) {
  let ae = Bge.encode(ne);
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { dir: "right", size: oe.size })) : ae;
}
var Bge, Du, jh = Y(() => {
  Ec(), op(), QA(), Lh(), ui(), Bge = new TextEncoder(), Du = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
});
function ZA(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function eP(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function tP(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function q4(ne, oe) {
  eP(ne);
  let ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
var I4 = Y(() => {
});
function $ge(ne, oe = !1) {
  return oe ? { h: Number(ne & ox), l: Number(ne >> B4 & ox) } : { h: Number(ne >> B4 & ox) | 0, l: Number(ne & ox) | 0 };
}
function H4(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    let { h: we, l: _e } = $ge(ne[ye], oe);
    [ae[ye], fe[ye]] = [we, _e];
  }
  return [ae, fe];
}
var ox, B4, V4, $4, W4, Y4, G4 = Y(() => {
  ox = BigInt(4294967295), B4 = BigInt(32), V4 = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, $4 = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, W4 = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, Y4 = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae;
});
function Gge(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function lx(ne) {
  if (typeof ne == "string" && (ne = Gge(ne)), !Wge(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function K4(ne) {
  let oe = (fe) => ne().update(lx(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function X4(ne) {
  let oe = (fe, ye) => ne(ye).update(lx(fe)).digest(), ae = ne({});
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = (fe) => ne(fe), oe;
}
var Wge, Q4, Yge, ux, J4 = Y(() => {
  if (Wge = (ne) => ne instanceof Uint8Array, Q4 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), Yge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !Yge)
    throw new Error("Non little-endian hardware is not supported");
  ux = class {
    clone() {
      return this._cloneInto();
    }
  };
});
function rbe(ne, oe = 24) {
  let ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let _e = 0; _e < 10; _e++)
      ae[_e] = ne[_e] ^ ne[_e + 10] ^ ne[_e + 20] ^ ne[_e + 30] ^ ne[_e + 40];
    for (let _e = 0; _e < 10; _e += 2) {
      let xe = (_e + 8) % 10, Oe = (_e + 2) % 10, $e = ae[Oe], Re = ae[Oe + 1], Ne = Z4($e, Re, 1) ^ ae[xe], je = eV($e, Re, 1) ^ ae[xe + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[_e + Be] ^= Ne, ne[_e + Be + 1] ^= je;
    }
    let ye = ne[2], we = ne[3];
    for (let _e = 0; _e < 24; _e++) {
      let xe = rV[_e], Oe = Z4(ye, we, xe), $e = eV(ye, we, xe), Re = tV[_e];
      ye = ne[Re], we = ne[Re + 1], ne[Re] = Oe, ne[Re + 1] = $e;
    }
    for (let _e = 0; _e < 50; _e += 10) {
      for (let xe = 0; xe < 10; xe++)
        ae[xe] = ne[_e + xe];
      for (let xe = 0; xe < 10; xe++)
        ne[_e + xe] ^= ~ae[(xe + 2) % 10] & ae[(xe + 4) % 10];
    }
    ne[0] ^= ebe[fe], ne[1] ^= tbe[fe];
  }
  ae.fill(0);
}
var tV, rV, nV, Qge, Uh, Kge, Xge, Jge, Zge, ebe, tbe, Z4, eV, lp, ds, iV, aV, oV = Y(() => {
  I4(), G4(), J4(), [tV, rV, nV] = [[], [], []], Qge = BigInt(0), Uh = BigInt(1), Kge = BigInt(2), Xge = BigInt(7), Jge = BigInt(256), Zge = BigInt(113);
  for (let ne = 0, oe = Uh, ae = 1, fe = 0; ne < 24; ne++) {
    [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], tV.push(2 * (5 * fe + ae)), rV.push((ne + 1) * (ne + 2) / 2 % 64);
    let ye = Qge;
    for (let we = 0; we < 7; we++)
      oe = (oe << Uh ^ (oe >> Xge) * Zge) % Jge, oe & Kge && (ye ^= Uh << (Uh << BigInt(we)) - Uh);
    nV.push(ye);
  }
  [ebe, tbe] = H4(nV, !0), Z4 = (ne, oe, ae) => ae > 32 ? W4(ne, oe, ae) : V4(ne, oe, ae), eV = (ne, oe, ae) => ae > 32 ? Y4(ne, oe, ae) : $4(ne, oe, ae), lp = class extends ux {
    constructor(ne, oe, ae, fe = !1, ye = 24) {
      if (super(), this.blockLen = ne, this.suffix = oe, this.outputLen = ae, this.enableXOF = fe, this.rounds = ye, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ZA(ae), 0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = Q4(this.state);
    }
    keccak() {
      rbe(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
    }
    update(ne) {
      tP(this);
      let { blockLen: oe, state: ae } = this;
      ne = lx(ne);
      let fe = ne.length;
      for (let ye = 0; ye < fe; ) {
        let we = Math.min(oe - this.pos, fe - ye);
        for (let _e = 0; _e < we; _e++)
          ae[this.pos++] ^= ne[ye++];
        this.pos === oe && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = !0;
      let { state: ne, suffix: oe, pos: ae, blockLen: fe } = this;
      ne[ae] ^= oe, oe & 128 && ae === fe - 1 && this.keccak(), ne[fe - 1] ^= 128, this.keccak();
    }
    writeInto(ne) {
      tP(this, !1), eP(ne), this.finish();
      let oe = this.state, { blockLen: ae } = this;
      for (let fe = 0, ye = ne.length; fe < ye; ) {
        this.posOut >= ae && this.keccak();
        let we = Math.min(ae - this.posOut, ye - fe);
        ne.set(oe.subarray(this.posOut, this.posOut + we), fe), this.posOut += we, fe += we;
      }
      return ne;
    }
    xofInto(ne) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(ne);
    }
    xof(ne) {
      return ZA(ne), this.xofInto(new Uint8Array(ne));
    }
    digestInto(ne) {
      if (q4(ne, this), this.finished)
        throw new Error("digest() was already called");
      return this.writeInto(ne), this.destroy(), ne;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = !0, this.state.fill(0);
    }
    _cloneInto(ne) {
      let { blockLen: oe, suffix: ae, outputLen: fe, rounds: ye, enableXOF: we } = this;
      return ne || (ne = new lp(oe, ae, fe, we, ye)), ne.state32.set(this.state32), ne.pos = this.pos, ne.posOut = this.posOut, ne.finished = this.finished, ne.rounds = ye, ne.suffix = ae, ne.outputLen = fe, ne.enableXOF = we, ne.destroyed = this.destroyed, ne;
    }
  }, ds = (ne, oe, ae) => K4(() => new lp(oe, ne, ae)), ds(6, 144, 224 / 8), ds(6, 136, 256 / 8), ds(6, 104, 384 / 8), ds(6, 72, 512 / 8), ds(1, 144, 224 / 8), iV = ds(1, 136, 256 / 8), ds(1, 104, 384 / 8), ds(1, 72, 512 / 8), aV = (ne, oe, ae) => X4((fe = {}) => new lp(oe, ne, fe.dkLen === void 0 ? ae : fe.dkLen, !0)), aV(31, 168, 128 / 8), aV(31, 136, 256 / 8);
});
function sx(ne, oe) {
  let ae = oe || "hex", fe = iV(eo(ne, { strict: !1 }) ? ix(ne) : ne);
  return ae === "bytes" ? fe : F4(fe);
}
var rP = Y(() => {
  oV(), op(), jh(), ui();
});
function uV(ne) {
  return nbe(ne);
}
var nbe, lV = Y(() => {
  jh(), rP(), nbe = (ne) => sx(ix(ne));
});
function sV(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", we = !1;
  for (let _e = 0; _e < ne.length; _e++) {
    let xe = ne[_e];
    if (["(", ")", ","].includes(xe) && (oe = !0), xe === "(" && fe++, xe === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (xe === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += xe, xe === ")") {
          we = !0;
          break;
        }
        continue;
      }
      if (xe === " ") {
        ne[_e - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += xe, ae += xe;
    }
  }
  if (!we)
    throw new kt("Unable to normalize signature.");
  return ye;
}
var cV = Y(() => {
  Ec();
}), fV, dV = Y(() => {
  M4(), cV(), fV = (ne) => {
    let oe = (() => typeof ne == "string" ? ne : YA(ne))();
    return sV(oe);
  };
});
function cx(ne) {
  return uV(fV(ne));
}
var nP = Y(() => {
  lV(), dV();
}), pV, vV = Y(() => {
  nP(), pV = cx;
});
function mV(ne, oe) {
  let ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = sx(JA(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let we = 0; we < 40; we += 2)
    fe[we >> 1] >> 4 >= 8 && ye[we] && (ye[we] = ye[we].toUpperCase()), (fe[we >> 1] & 15) >= 8 && ye[we + 1] && (ye[we + 1] = ye[we + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
var hV = Y(() => {
  jh(), rP();
});
function Fh(ne, oe, ae, { strict: fe } = {}) {
  return eo(ne, { strict: !1 }) ? ibe(ne, oe, ae, { strict: fe }) : iP(ne, oe, ae, { strict: fe });
}
function yV(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > oi(ne) - 1)
    throw new Ph({ offset: oe, position: "start", size: oi(ne) });
}
function gV(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && oi(ne) !== ae - oe)
    throw new Ph({ offset: ae, position: "end", size: oi(ne) });
}
function iP(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = ne.slice(oe, ae);
  return fe && gV(ye, oe, ae), ye;
}
function ibe(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && gV(ye, oe, ae), ye;
}
var fx = Y(() => {
  GA(), op(), Ch();
});
function aP(ne) {
  let oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? [oe[2] ? Number(oe[2]) : null, oe[1]] : void 0;
}
var bV = Y(() => {
}), SV, _V = Y(() => {
  fx(), nP(), SV = (ne) => Fh(cx(ne), 0, 4);
}), zh, sp, dx, oP = Y(() => {
  Ec(), zh = class extends kt {
    constructor({ offset: ne }) {
      super(`Offset \`${ne}\` cannot be negative.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "NegativeOffsetError" });
    }
  }, sp = class extends kt {
    constructor({ length: ne, position: oe }) {
      super(`Position \`${oe}\` is out of bounds (\`0 < position < ${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "PositionOutOfBoundsError" });
    }
  }, dx = class extends kt {
    constructor({ count: ne, limit: oe }) {
      super(`Recursive read limit of \`${oe}\` exceeded (recursive read count: \`${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "RecursiveReadLimitExceededError" });
    }
  };
});
function wV(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  let ae = Object.create(abe);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
var abe, xV = Y(() => {
  oP(), abe = { bytes: new Uint8Array(), dataView: new DataView(new ArrayBuffer(0)), position: 0, positionReadCount: /* @__PURE__ */ new Map(), recursiveReadCount: 0, recursiveReadLimit: 1 / 0, assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new dx({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit });
  }, assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new sp({ length: this.bytes.length, position: ne });
  }, decrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  }, getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  }, incrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  }, inspectByte(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectBytes(ne, oe) {
    let ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  }, inspectUint8(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectUint16(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  }, inspectUint24(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  }, inspectUint32(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  }, pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  }, pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  }, pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  }, pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  }, readByte() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectByte();
    return this.position++, ne;
  }, readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    let ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  }, readUint8() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint8();
    return this.position += 1, ne;
  }, readUint16() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint16();
    return this.position += 2, ne;
  }, readUint24() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint24();
    return this.position += 3, ne;
  }, readUint32() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint32();
    return this.position += 4, ne;
  }, get remaining() {
    return this.bytes.length - this.position;
  }, setPosition(ne) {
    let oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  }, _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    let ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  } };
});
function EV(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return XA(ae, oe);
}
function CV(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae)), ae.length > 1 || ae[0] > 1)
    throw new tx(ae);
  return !!ae[0];
}
function zo(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return Nh(ae, oe);
}
function RV(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
var OV = Y(() => {
  nx(), KA(), Lh(), ui();
});
function Ih(ne, oe) {
  let ae = typeof oe == "string" ? ax(oe) : oe, fe = wV(ae);
  if (oi(ae) === 0 && ne.length > 0)
    throw new Rh();
  if (oi(oe) && oi(oe) < 32)
    throw new Cc({ data: typeof oe == "string" ? oe : _a(oe), params: ne, size: oi(oe) });
  let ye = 0, we = [];
  for (let _e = 0; _e < ne.length; ++_e) {
    let xe = ne[_e];
    fe.setPosition(ye);
    let [Oe, $e] = cp(fe, xe, { staticPosition: 0 });
    ye += $e, we.push(Oe);
  }
  return we;
}
function cp(ne, oe, { staticPosition: ae }) {
  let fe = aP(oe.type);
  if (fe) {
    let [ye, we] = fe;
    return ube(ne, { ...oe, type: we }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return fbe(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return obe(ne);
  if (oe.type === "bool")
    return lbe(ne);
  if (oe.type.startsWith("bytes"))
    return sbe(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return cbe(ne, oe);
  if (oe.type === "string")
    return dbe(ne, { staticPosition: ae });
  throw new Ah(oe.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
function obe(ne) {
  let oe = ne.readBytes(32);
  return [mV(_a(iP(oe, -20))), 32];
}
function ube(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    let _e = zo(ne.readBytes(uP)), xe = fe + _e, Oe = xe + TV;
    ne.setPosition(xe);
    let $e = zo(ne.readBytes(TV)), Re = qh(oe), Ne = 0, je = [];
    for (let Be = 0; Be < $e; ++Be) {
      ne.setPosition(Oe + (Re ? Be * 32 : Ne));
      let [ze, He] = cp(ne, oe, { staticPosition: Oe });
      Ne += He, je.push(ze);
    }
    return ne.setPosition(fe + 32), [je, 32];
  }
  if (qh(oe)) {
    let _e = zo(ne.readBytes(uP)), xe = fe + _e, Oe = [];
    for (let $e = 0; $e < ae; ++$e) {
      ne.setPosition(xe + $e * 32);
      let [Re] = cp(ne, oe, { staticPosition: xe });
      Oe.push(Re);
    }
    return ne.setPosition(fe + 32), [Oe, 32];
  }
  let ye = 0, we = [];
  for (let _e = 0; _e < ae; ++_e) {
    let [xe, Oe] = cp(ne, oe, { staticPosition: fe + ye });
    ye += Oe, we.push(xe);
  }
  return [we, ye];
}
function lbe(ne) {
  return [CV(ne.readBytes(32), { size: 32 }), 32];
}
function sbe(ne, oe, { staticPosition: ae }) {
  let [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    let we = zo(ne.readBytes(32));
    ne.setPosition(ae + we);
    let _e = zo(ne.readBytes(32));
    if (_e === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    let xe = ne.readBytes(_e);
    return ne.setPosition(ae + 32), [_a(xe), 32];
  }
  return [_a(ne.readBytes(parseInt(ye), 32)), 32];
}
function cbe(ne, oe) {
  let ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [fe > 48 ? EV(ye, { signed: ae }) : zo(ye, { signed: ae }), 32];
}
function fbe(ne, oe, { staticPosition: ae }) {
  let fe = oe.components.length === 0 || oe.components.some(({ name: _e }) => !_e), ye = fe ? [] : {}, we = 0;
  if (qh(oe)) {
    let _e = zo(ne.readBytes(uP)), xe = ae + _e;
    for (let Oe = 0; Oe < oe.components.length; ++Oe) {
      let $e = oe.components[Oe];
      ne.setPosition(xe + we);
      let [Re, Ne] = cp(ne, $e, { staticPosition: xe });
      we += Ne, ye[fe ? Oe : $e == null ? void 0 : $e.name] = Re;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let _e = 0; _e < oe.components.length; ++_e) {
    let xe = oe.components[_e], [Oe, $e] = cp(ne, xe, { staticPosition: ae });
    ye[fe ? _e : xe == null ? void 0 : xe.name] = Oe, we += $e;
  }
  return [ye, we];
}
function dbe(ne, { staticPosition: oe }) {
  let ae = zo(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  let ye = zo(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  let we = ne.readBytes(ye, 32), _e = RV(Dh(we));
  return ne.setPosition(oe + 32), [_e, 32];
}
function qh(ne) {
  var fe;
  let { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(qh);
  let ae = aP(ne.type);
  return !!(ae && qh({ ...ne, type: ae[1] }));
}
var TV, uP, lP = Y(() => {
  ap(), hV(), xV(), Ch(), fx(), KA(), OV(), jh(), ui(), bV(), TV = 32, uP = 32;
}), kV, AV = Y(() => {
  kV = { gwei: 9, wei: 18 };
});
function sP(ne, oe) {
  let ae = ne.toString(), fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, we] = [ae.slice(0, ae.length - oe), ae.slice(ae.length - oe)];
  return we = we.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${we ? `.${we}` : ""}`;
}
var PV = Y(() => {
});
function MV(ne, { format: oe }) {
  if (!oe)
    return {};
  let ae = {};
  function fe(we) {
    let _e = Object.keys(we);
    for (let xe of _e)
      xe in ne && (ae[xe] = ne[xe]), we[xe] && typeof we[xe] == "object" && !Array.isArray(we[xe]) && fe(we[xe]);
  }
  let ye = oe(ne || {});
  return fe(ye), ae;
}
var DV = Y(() => {
});
function NV(ne) {
  let oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => _a(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = xt(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = xt(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = xt(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = xt(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = xt(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = xt(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = pbe[ne.type]), typeof ne.value < "u" && (oe.value = xt(ne.value)), oe;
}
var pbe, LV = Y(() => {
  ui(), pbe = { legacy: "0x0", eip2930: "0x1", eip1559: "0x2", eip4844: "0x3" };
});
function cP(ne) {
  let { abi: oe, data: ae, strict: fe, topics: ye } = ne, we = fe ?? !0, [_e, ...xe] = ye;
  if (!_e)
    throw new Oh({ docsPath: jV });
  let Oe = oe.find((He) => He.type === "event" && _e === pV(ip(He)));
  if (!(Oe && "name" in Oe) || Oe.type !== "event")
    throw new Rc(_e, { docsPath: jV });
  let { name: $e, inputs: Re } = Oe, Ne = Re == null ? void 0 : Re.some((He) => !("name" in He && He.name)), je = Ne ? [] : {}, Be = Re.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    let qe = Be[He], Ye = xe[He];
    if (!Ye)
      throw new kh({ abiItem: Oe, param: qe });
    je[Ne ? He : qe.name || He] = vbe({ param: qe, value: Ye });
  }
  let ze = Re.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        let He = Ih(ze, ae);
        if (He)
          if (Ne)
            je = [...je, ...He];
          else
            for (let qe = 0; qe < ze.length; qe++)
              je[ze[qe].name] = He[qe];
      } catch (He) {
        if (we)
          throw He instanceof Cc || He instanceof sp ? new up({ abiItem: Oe, data: ae, params: ze, size: oi(ae) }) : He;
      }
    else if (we)
      throw new up({ abiItem: Oe, data: "0x", params: ze, size: 0 });
  }
  return { eventName: $e, args: Object.values(je).length > 0 ? je : void 0 };
}
function vbe({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (Ih([ne], oe) || [])[0];
}
var jV, UV = Y(() => {
  ap(), Ch(), vV(), oP(), lP(), Zw(), jV = "/docs/contract/decodeEventLog";
});
function Bh(ne) {
  let { abi: oe, data: ae } = ne, fe = Fh(ae, 0, 4), ye = oe.find((we) => we.type === "function" && fe === SV(ip(we)));
  if (!ye)
    throw new Th(fe, { docsPath: "/docs/contract/decodeFunctionData" });
  return { functionName: ye.name, args: "inputs" in ye && ye.inputs && ye.inputs.length > 0 ? Ih(ye.inputs, Fh(ae, 4)) : void 0 };
}
var FV = Y(() => {
  ap(), fx(), _V(), lP(), Zw();
});
function zV(ne, oe) {
  let [ae, fe = "0"] = ne.split("."), ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    let [we, _e, xe] = [fe.slice(0, oe - 1), fe.slice(oe - 1, oe), fe.slice(oe)], Oe = Math.round(+`${_e}.${xe}`);
    Oe > 9 ? fe = `${BigInt(we) + BigInt(1)}0`.padStart(we.length + 1, "0") : fe = `${we}${Oe}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
var qV = Y(() => {
});
function fP(ne, oe = "wei") {
  return zV(ne, kV[oe]);
}
var IV = Y(() => {
  AV(), qV();
});
async function BV(ne, { hash: oe }) {
  await ne.request({ method: `${ne.mode}_dropTransaction`, params: [oe] });
}
var HV = Y(() => {
});
async function VV(ne) {
  return ne.request({ method: `${ne.mode}_dumpState` });
}
var $V = Y(() => {
});
async function WV(ne) {
  return ne.mode === "ganache" ? await ne.request({ method: "eth_mining" }) : await ne.request({ method: `${ne.mode}_getAutomine` });
}
var YV = Y(() => {
});
async function GV(ne) {
  return await ne.request({ method: "txpool_content" });
}
var QV = Y(() => {
});
async function KV(ne) {
  let { pending: oe, queued: ae } = await ne.request({ method: "txpool_status" });
  return { pending: Nh(oe), queued: Nh(ae) };
}
var XV = Y(() => {
  Lh();
});
async function JV(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_impersonateAccount`, params: [oe] });
}
var ZV = Y(() => {
});
async function e5(ne, { seconds: oe }) {
  return await ne.request({ method: "evm_increaseTime", params: [xt(oe)] });
}
var t5 = Y(() => {
  ui();
});
async function r5(ne) {
  return await ne.request({ method: "txpool_inspect" });
}
var n5 = Y(() => {
});
async function i5(ne, { state: oe }) {
  await ne.request({ method: `${ne.mode}_loadState`, params: [oe] });
}
var a5 = Y(() => {
});
async function o5(ne, { blocks: oe, interval: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_mine", params: [{ blocks: xt(oe) }] }) : await ne.request({ method: `${ne.mode}_mine`, params: [xt(oe), xt(ae || 0)] });
}
var u5 = Y(() => {
  ui();
});
async function l5(ne) {
  await ne.request({ method: `${ne.mode}_removeBlockTimestampInterval` });
}
var s5 = Y(() => {
});
async function c5(ne, { blockNumber: oe, jsonRpcUrl: ae } = {}) {
  await ne.request({ method: `${ne.mode}_reset`, params: [{ forking: { blockNumber: Number(oe), jsonRpcUrl: ae } }] });
}
var f5 = Y(() => {
});
async function d5(ne, { id: oe }) {
  await ne.request({ method: "evm_revert", params: [oe] });
}
var p5 = Y(() => {
});
async function v5(ne, oe) {
  var He, qe, Ye;
  let { accessList: ae, data: fe, from: ye, gas: we, gasPrice: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, nonce: $e, to: Re, value: Ne, ...je } = oe, Be = (Ye = (qe = (He = ne.chain) == null ? void 0 : He.formatters) == null ? void 0 : qe.transactionRequest) == null ? void 0 : Ye.format, ze = (Be || NV)({ ...MV(je, { format: Be }), accessList: ae, data: fe, from: ye, gas: we, gasPrice: _e, maxFeePerGas: xe, maxPriorityFeePerGas: Oe, nonce: $e, to: Re, value: Ne });
  return await ne.request({ method: "eth_sendUnsignedTransaction", params: [ze] });
}
var m5 = Y(() => {
  DV(), LV();
});
async function h5(ne, oe) {
  ne.mode === "ganache" ? oe ? await ne.request({ method: "miner_start" }) : await ne.request({ method: "miner_stop" }) : await ne.request({ method: "evm_setAutomine", params: [oe] });
}
var y5 = Y(() => {
});
async function g5(ne, { address: oe, value: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_setAccountBalance", params: [oe, xt(ae)] }) : await ne.request({ method: `${ne.mode}_setBalance`, params: [oe, xt(ae)] });
}
var b5 = Y(() => {
  ui();
});
async function S5(ne, { gasLimit: oe }) {
  await ne.request({ method: "evm_setBlockGasLimit", params: [xt(oe)] });
}
var _5 = Y(() => {
  ui();
});
async function w5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: `${ne.mode}_setBlockTimestampInterval`, params: [ae] });
}
var x5 = Y(() => {
});
async function E5(ne, { address: oe, bytecode: ae }) {
  await ne.request({ method: `${ne.mode}_setCode`, params: [oe, ae] });
}
var C5 = Y(() => {
});
async function R5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_setCoinbase`, params: [oe] });
}
var O5 = Y(() => {
});
async function T5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: "evm_setIntervalMining", params: [ae] });
}
var k5 = Y(() => {
});
async function A5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setLoggingEnabled`, params: [oe] });
}
var P5 = Y(() => {
});
async function M5(ne, { gasPrice: oe }) {
  await ne.request({ method: `${ne.mode}_setMinGasPrice`, params: [xt(oe)] });
}
var D5 = Y(() => {
  ui();
});
async function N5(ne, { baseFeePerGas: oe }) {
  await ne.request({ method: `${ne.mode}_setNextBlockBaseFeePerGas`, params: [xt(oe)] });
}
var L5 = Y(() => {
  ui();
});
async function j5(ne, { timestamp: oe }) {
  await ne.request({ method: "evm_setNextBlockTimestamp", params: [xt(oe)] });
}
var U5 = Y(() => {
  ui();
});
async function F5(ne, { address: oe, nonce: ae }) {
  await ne.request({ method: `${ne.mode}_setNonce`, params: [oe, xt(ae)] });
}
var z5 = Y(() => {
  ui();
});
async function q5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setRpcUrl`, params: [oe] });
}
var I5 = Y(() => {
});
async function B5(ne, { address: oe, index: ae, value: fe }) {
  await ne.request({ method: `${ne.mode}_setStorageAt`, params: [oe, typeof ae == "number" ? xt(ae) : ae, fe] });
}
var H5 = Y(() => {
  ui();
});
async function V5(ne) {
  return await ne.request({ method: "evm_snapshot" });
}
var $5 = Y(() => {
});
async function W5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_stopImpersonatingAccount`, params: [oe] });
}
var Y5 = Y(() => {
});
function dP({ mode: ne }) {
  return (oe) => {
    let ae = oe.extend(() => ({ mode: ne }));
    return { dropTransaction: (fe) => BV(ae, fe), dumpState: () => VV(ae), getAutomine: () => WV(ae), getTxpoolContent: () => GV(ae), getTxpoolStatus: () => KV(ae), impersonateAccount: (fe) => JV(ae, fe), increaseTime: (fe) => e5(ae, fe), inspectTxpool: () => r5(ae), loadState: (fe) => i5(ae, fe), mine: (fe) => o5(ae, fe), removeBlockTimestampInterval: () => l5(ae), reset: (fe) => c5(ae, fe), revert: (fe) => d5(ae, fe), sendUnsignedTransaction: (fe) => v5(ae, fe), setAutomine: (fe) => h5(ae, fe), setBalance: (fe) => g5(ae, fe), setBlockGasLimit: (fe) => S5(ae, fe), setBlockTimestampInterval: (fe) => w5(ae, fe), setCode: (fe) => E5(ae, fe), setCoinbase: (fe) => R5(ae, fe), setIntervalMining: (fe) => T5(ae, fe), setLoggingEnabled: (fe) => A5(ae, fe), setMinGasPrice: (fe) => M5(ae, fe), setNextBlockBaseFeePerGas: (fe) => N5(ae, fe), setNextBlockTimestamp: (fe) => j5(ae, fe), setNonce: (fe) => F5(ae, fe), setRpcUrl: (fe) => q5(ae, fe), setStorageAt: (fe) => B5(ae, fe), snapshot: () => V5(ae), stopImpersonatingAccount: (fe) => W5(ae, fe) };
  };
}
var G5 = Y(() => {
  HV(), $V(), YV(), QV(), XV(), ZV(), t5(), n5(), a5(), u5(), s5(), f5(), p5(), m5(), y5(), b5(), _5(), x5(), C5(), O5(), k5(), P5(), D5(), L5(), U5(), z5(), I5(), H5(), $5(), Y5();
}), Hh = Y(() => {
  G5(), ap(), UV(), FV(), PV(), op(), IV();
});
function Q5() {
  var _e;
  let { publicClient: ne, walletClient: oe } = zt(), ae = (_e = oe == null ? void 0 : oe.account) == null ? void 0 : _e.address, fe = ne.chain.id === 31337 ? ne.extend(dP({ mode: "anvil" })) : null, [ye, we] = (0, px.useState)(null);
  return (0, px.useEffect)(() => {
    if (!ne || !oe)
      return we(null);
    let xe = oe.account;
    if (!xe)
      return we(null);
    let Oe = async () => {
      let Re = await ne.getBalance({ address: xe.address });
      we(Re);
    };
    Oe();
    let $e = setInterval(Oe, ne.pollingInterval);
    return () => clearInterval($e);
  }, [ne, oe]), (0, Nu.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Address" }), (0, Nu.jsx)("dd", { className: "text-sm", children: ae }), (0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Balance" }), (0, Nu.jsxs)("dd", { className: "text-sm flex items-center gap-2", title: ye ? ye.toString() : void 0, children: [ne && ye != null ? (0, Nu.jsxs)("span", { children: [sP(ye, ne.chain.nativeCurrency.decimals).replace(/(\.\d{4})\d+$/, "$1"), " ", ne.chain.nativeCurrency.symbol] }) : null, ae && fe ? (0, Nu.jsx)("button", { type: "button", className: "text-xs px-1.5 py-0.5 bg-slate-700 hover:bg-blue-700 hover:text-white rounded", onClick: () => fe.setBalance({ address: ae, value: fP("1") + (ye ?? 0n) }), children: "top up" }) : null] })] });
}
var px, Nu, K5 = Y(() => {
  px = le(ir(), 1), Hh(), ai(), Nu = le(ke(), 1);
});
function X5() {
  let { storedLogs: ne } = zt();
  return (0, Oc.jsxs)(Oc.Fragment, { children: [(0, Oc.jsx)(z0, { logs: ne.slice(-10) }), (0, Oc.jsx)(sn, { to: "/events", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] });
}
var Oc, J5 = Y(() => {
  ql(), ai(), Pk(), Oc = le(ke(), 1);
});
function pP({ className: ne }) {
  return (0, Vh.jsxs)("svg", { className: Pr("animate-spin w-[1em] h-[1em]", ne), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [(0, Vh.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), (0, Vh.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] });
}
var Vh, Z5 = Y(() => {
  uc(), Vh = le(ke(), 1);
});
function e$(ne) {
  return ne.replace(/^(0x[0-9A-F]{3})[0-9A-F]+([0-9A-F]{4})$/i, "$1$2");
}
var t$ = Y(() => {
});
function $h(ne) {
  return JSON.stringify(ne, (oe, ae) => typeof ae == "bigint" ? ae.toString() : ae);
}
var vP = Y(() => {
});
function vx(ne, oe) {
  return mP[oe.id] || (mP[oe.id] = oe.result.then((ae) => ne.getTransaction({ hash: ae }))), mP[oe.id];
}
var mP, hP = Y(() => {
  mP = {};
});
function mx(ne, oe) {
  return yP[oe.id] || (yP[oe.id] = oe.result.then((ae) => ne.waitForTransactionReceipt({ hash: ae }))), yP[oe.id];
}
var yP, gP = Y(() => {
  yP = {};
});
function r$(ne, oe, ae) {
  if (!bP[ae.id]) {
    let fe = vx(ne, ae), ye = mx(ne, ae);
    bP[ae.id] = Promise.all([fe, ye]).then(([we, _e]) => {
      let { functionName: xe, args: Oe } = Bh({ abi: oe, data: we.input });
      return ne.simulateContract({ account: we.from, address: we.to, abi: oe, functionName: xe, args: Oe, blockNumber: _e.blockNumber - 1n, value: we.value });
    });
  }
  return bP[ae.id];
}
var bP, n$ = Y(() => {
  Hh(), hP(), gP(), bP = {};
});
function hx({ write: ne }) {
  var Ye, ot, tt;
  let { publicClient: oe, worldAbi: ae } = zt(), fe = (Ye = oe.chain.blockExplorers) == null ? void 0 : Ye.default.url, ye = _h(ne.result), we = vx(oe, ne), _e = mx(oe, ne), xe = r$(oe, ae, ne), Oe = _h(we), $e = _h(_e), Re = _h(xe), Ne = ye.status === "pending" || $e.status === "pending", je = ye.status === "rejected" || $e.status === "fulfilled" && $e.value.status === "reverted", Be = Re.status === "fulfilled" ? Re.value.result : null, ze = ae && $e.status === "fulfilled" ? $e.value.logs.map((it) => {
    try {
      return cP({ abi: ae, ...it });
    } catch (ht) {
      if (ht instanceof Rc)
        return;
      throw ht;
    }
  }).filter(b$7) : null, He = ne.request.functionName, qe = ne.request.args;
  if (He === "call" || He === "callFrom") {
    let it = (tt = (ot = ne.request) == null ? void 0 : ot.args) != null && tt.length ? ne.request.args[ne.request.args.length - 1] : "0x", ht = Bh({ abi: ae, data: it });
    He = ht.functionName, qe = ht.args;
  }
  return (0, nt.jsxs)("details", { onToggle: (it) => {
    it.currentTarget.open && (console.log("transaction", Oe), console.log("transaction receipt", $e), console.log("transaction result", Re));
  }, children: [(0, nt.jsxs)("summary", { className: Pr("px-2 py-1 rounded flex items-center gap-2 border-2 border-transparent border-dashed cursor-pointer", Ne ? "border-white/20 cursor-default" : je ? "bg-red-800" : "bg-slate-700"), children: [(0, nt.jsxs)("div", { className: "flex-1 font-mono text-white whitespace-nowrap overflow-hidden text-ellipsis", children: [He, "(", qe == null ? void 0 : qe.map((it) => $h(it)).join(", "), ")", " ", ne.request.functionName !== He ? (0, nt.jsxs)("span", { className: "text-xs text-white/40", children: ["via ", ne.request.functionName] }) : null] }), $e.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/block/${$e.value.blockNumber.toString()}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: $e.value.blockNumber.toString(), children: ["block ", $e.value.blockNumber.toString()] }) : null, ye.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/tx/${ye.value}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: ye.value, children: ["tx ", e$(ye.value)] }) : null, (0, nt.jsx)("div", { className: "flex-none inline-flex w-4 h-4 justify-center items-center font-bold", children: Ne ? (0, nt.jsx)(pP, {}) : je ? (0, nt.jsx)(nt.Fragment, { children: "" }) : (0, nt.jsx)(nt.Fragment, { children: "" }) })] }), (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Result" }), Re.status === "fulfilled" ? (0, nt.jsx)("div", { className: "font-mono", children: $h(Be) }) : Re.status === "rejected" ? (0, nt.jsx)(U0, { error: Re.reason }) : (0, nt.jsx)(pP, {})] }), ze != null && ze.length ? (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Store events" }), (0, nt.jsxs)("table", { className: "w-full table-fixed", children: [(0, nt.jsx)("thead", { className: "bg-slate-800 text-amber-200/80 text-left", children: (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "table" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-[1em]" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "key" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs", children: "value" })] }) }), (0, nt.jsx)("tbody", { className: "font-mono text-xs", children: ze.map(({ eventName: it, args: ht }, gt) => {
    let At = _$4(ht.tableId);
    return (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: i$6(At) }), (0, nt.jsxs)("td", { className: "whitespace-nowrap", children: [it === "Store_SetRecord" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "=" }) : null, it === "Store_SpliceStaticData" || it === "Store_SpliceDynamicData" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "+" }) : null, it === "Store_DeleteRecord" ? (0, nt.jsx)("span", { className: "text-red-500 font-bold", children: "-" }) : null] }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: d$1(ht.keyTuple) }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: ht.data })] }, gt);
  }) })] })] }) : null] });
}
var nt, SP = Y(() => {
  Hh(), uc(), Z5(), wh(), t$(), vP(), hP(), gP(), n$(), Ak(), ai(), nt = le(ke(), 1);
});
function i$() {
  let { writes: ne } = zt();
  return (0, to.jsx)(to.Fragment, { children: ne.length ? (0, to.jsxs)(to.Fragment, { children: [(0, to.jsx)("div", { className: "space-y-1", children: ne.slice(-5).map((oe) => (0, to.jsx)(hx, { write: oe }, oe.id)) }), (0, to.jsx)(sn, { to: "/actions", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] }) : (0, to.jsx)("div", { children: "Waiting for transactions" }) });
}
var to, a$ = Y(() => {
  ql(), ai(), SP(), to = le(ke(), 1);
});
function fp() {
  let { useStore: ne } = zt();
  if (!ne)
    throw new Error("Missing useStore");
  let [oe, ae] = (0, yx.useState)(ne.getState().tables);
  return (0, yx.useEffect)(() => ne.subscribe((fe) => {
    fe.tables !== oe && ae(fe.tables);
  }), [ne, oe]), Object.values(oe);
}
var yx, gx = Y(() => {
  ai(), yx = le(ir(), 1);
});
function o$() {
  let ne = fp();
  return (0, _P.jsx)("div", { className: "flex flex-col gap-1 items-start", children: ne.map((oe) => (0, _P.jsx)(sn, { to: `/tables/${oe.tableId}`, className: "font-mono text-xs hover:text-white", children: i$6(oe) }, oe.tableId)) });
}
var _P, u$ = Y(() => {
  ql(), gx(), _P = le(ke(), 1);
});
function Lu(ne) {
  var oe, ae;
  return String(((oe = ne.metadata) == null ? void 0 : oe.tableName) ?? ((ae = ne.metadata) == null ? void 0 : ae.componentName) ?? ne.id);
}
var wP = Y(() => {
});
function l$({ world: ne }) {
  let oe = [...ne.components].sort((ae, fe) => Lu(ae).localeCompare(Lu(fe)));
  return (0, ju.jsx)(ju.Fragment, { children: oe.length ? (0, ju.jsx)(ju.Fragment, { children: (0, ju.jsx)("div", { className: "flex flex-col gap-1 items-start", children: oe.map((ae) => (0, ju.jsx)(sn, { to: `/components/${ae.id}`, className: "font-mono text-xs hover:text-white", children: Lu(ae) }, ae.id)) }) }) : (0, ju.jsx)("div", { children: "Waiting for components" }) });
}
var ju, s$ = Y(() => {
  ql(), wP(), ju = le(ke(), 1);
}), xP, c$ = Y(() => {
  xP = { name: "@latticexyz/dev-tools", version: "2.1.0", description: "MUD developer tools", repository: { type: "git", url: "https://github.com/latticexyz/mud.git", directory: "packages/dev-tools" }, license: "MIT", type: "module", exports: { ".": "./dist/index.js" }, typesVersions: { "*": { index: ["./dist/index.d.ts"] } }, files: ["dist"], scripts: { build: "pnpm run build:js", "build:js": "tsup", clean: "pnpm run clean:js", "clean:js": "rimraf dist", dev: "tsup --watch", test: "tsc --noEmit", "test:ci": "pnpm run test" }, dependencies: { "@latticexyz/common": "workspace:*", "@latticexyz/react": "workspace:*", "@latticexyz/recs": "workspace:*", "@latticexyz/schema-type": "workspace:*", "@latticexyz/store": "workspace:*", "@latticexyz/store-sync": "workspace:*", "@latticexyz/utils": "workspace:*", "@latticexyz/world": "workspace:*", react: "^18.2.0", "react-dom": "^18.2.0", "react-router-dom": "^6.11.0", rxjs: "7.5.5", "tailwind-merge": "^1.12.0", "use-local-storage-state": "^18.3.2", viem: "2.9.20", zustand: "^4.3.7" }, devDependencies: { "@types/react": "18.2.22", "@types/react-dom": "18.2.7", "@types/ws": "^8.5.4", autoprefixer: "^10.4.14", postcss: "^8.4.23", tailwindcss: "^3.3.2", tsup: "^6.7.0", vitest: "0.34.6" }, peerDependencies: { "@latticexyz/common": "2.x", "@latticexyz/recs": "2.x", "@latticexyz/store": "2.x", "@latticexyz/store-sync": "2.x", "@latticexyz/utils": "2.x", "@latticexyz/world": "2.x" }, publishConfig: { access: "public" } };
});
function f$() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Dt.jsxs)("div", { className: "h-full flex flex-col", children: [(0, Dt.jsxs)("div", { className: "flex-grow p-6 space-y-8 relative", children: [(0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Network" }), (0, Dt.jsx)(E4, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Account" }), (0, Dt.jsx)(Q5, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent actions" }), (0, Dt.jsx)(i$, {})] }), (0, Dt.jsxs)("div", { className: "space-y-1", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent store events" }), (0, Dt.jsx)(X5, {})] }), oe ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Tables" }), (0, Dt.jsx)(o$, {})] }) : null, ne ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Components" }), (0, Dt.jsx)(l$, { world: ne })] }) : null] }), (0, Dt.jsxs)("div", { className: "p-2 text-right font-mono text-xs leading-none text-white/20", children: ["MUD ", _be ? (0, Dt.jsxs)(Dt.Fragment, { children: ["v", xP.version] }) : (0, Dt.jsx)(Dt.Fragment, { children: "linked" })] })] });
}
var Dt, _be, d$ = Y(() => {
  C4(), K5(), J5(), a$(), u$(), s$(), c$(), ai(), Dt = le(ke(), 1), _be = Object.entries(xP.dependencies).some(([ne, oe]) => ne.startsWith("@latticexyz/") && oe.startsWith("link:"));
});
function p$() {
  let { writes: ne } = zt(), oe = (0, dp.useRef)(null), ae = (0, dp.useRef)(!1), fe = (0, dp.useRef)("auto");
  return (0, dp.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, pp.jsx)("div", { ref: oe, className: "p-4 space-y-2", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: ne.length ? ne.map((ye) => (0, pp.jsx)(hx, { write: ye }, ye.id)) : (0, pp.jsx)(pp.Fragment, { children: "Waiting for transactions" }) });
}
var dp, pp, v$ = Y(() => {
  dp = le(ir(), 1), SP(), ai(), pp = le(ke(), 1);
});
function m$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let oe = [...ne.components].sort((_e, xe) => Lu(_e).localeCompare(Lu(xe))), { id: ae } = Tu(), fe = oe.find((_e) => _e.id === ae) ?? oe[0], ye = (0, Wh.useRef)(null), we = Ou();
  return (0, Wh.useEffect)(() => {
    ae !== fe.id && we(fe.id);
  }, [ae, fe.id]), (0, Wh.useEffect)(() => {
    let _e = (xe) => {
      ye.current && (xe.target instanceof Node && ye.current.contains(xe.target) || (ye.current.open = !1));
    };
    return window.addEventListener("click", _e), () => window.removeEventListener("click", _e);
  }), (0, fn.jsxs)("div", { className: "p-6 space-y-4", children: [oe.length ? (0, fn.jsxs)("div", { className: "space-y-2", children: [(0, fn.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Component" }), (0, fn.jsxs)("details", { ref: ye, className: "pointer-events-none select-none", children: [(0, fn.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, fn.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [fe ? (0, fn.jsx)("span", { className: "font-mono", children: Lu(fe) }) : (0, fn.jsx)("span", { children: "Pick a component" }), (0, fn.jsx)("span", { className: "text-white/40 text-xs", children: "" })] }) }), (0, fn.jsx)("div", { className: "relative", children: (0, fn.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: oe.map((_e) => (0, fn.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", _e === fe ? "bg-slate-600" : null), to: _e.id, onClick: () => {
    ye.current && (ye.current.open = !1);
  }, children: Lu(_e) }, _e.id)) }) })] })] }) : (0, fn.jsx)(fn.Fragment, { children: "Waiting for components" }), (0, fn.jsx)(cc, {})] });
}
var Wh, fn, h$ = Y(() => {
  Do(), ql(), Wh = le(ir(), 1), uc(), ai(), wP(), fn = le(ke(), 1);
});
function y$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, ro.jsxs)("table", { className: "w-full -mx-1", children: [(0, ro.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, ro.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [(0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: "entity" }), Object.keys(ne.schema).map((ae) => (0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, ro.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = de(ne, ae);
    return (0, ro.jsxs)("tr", { children: [(0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ae }), Object.keys(ne.schema).map((ye) => {
      let we = fe[ye];
      return (0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ne.schema[ye] === P$3.T ? $h(we) : Array.isArray(we) ? we.map(String).join(", ") : String(we) }, ye);
    })] }, ae);
  }) })] });
}
var ro, g$ = Y(() => {
  wh(), vP(), ro = le(ke(), 1);
});
function b$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, no.jsxs)("table", { className: "w-full -mx-1", children: [(0, no.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, no.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [Object.keys(ne.metadata.keySchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae)), Object.keys(ne.metadata.valueSchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, no.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = vt(ne.metadata.keySchema, ae), ye = de(ne, ae);
    return (0, no.jsxs)("tr", { children: [Object.keys(ne.metadata.keySchema).map((we) => (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: String(fe[we]) }, we)), Object.keys(ne.metadata.valueSchema).map((we) => {
      let _e = ye[we];
      return (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: Array.isArray(_e) ? _e.map(String).join(", ") : String(_e) }, we);
    })] }, ae);
  }) })] });
}
var no, S$ = Y(() => {
  wh(), no = le(ke(), 1);
});
function _$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let { id: oe } = Tu(), ae = ne.components.find((fe) => fe.id === oe);
  return ae ? Pt(ae) ? (0, EP.jsx)(b$, { component: ae }, ae.id) : (0, EP.jsx)(y$, { component: ae }, ae.id) : null;
}
var EP, w$ = Y(() => {
  Do(), ai(), g$(), S$(), EP = le(ke(), 1);
});
function E$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((we) => we.tableId === oe) ?? ne[0], fe = (0, Yh.useRef)(null), ye = Ou();
  return (0, Yh.useEffect)(() => {
    oe !== ae.tableId && ye(ae.tableId);
  }, [oe, ae.tableId]), (0, Yh.useEffect)(() => {
    let we = (_e) => {
      fe.current && (_e.target instanceof Node && fe.current.contains(_e.target) || (fe.current.open = !1));
    };
    return window.addEventListener("click", we), () => window.removeEventListener("click", we);
  }), (0, li.jsxs)("div", { className: "p-6 space-y-4", children: [(0, li.jsxs)("div", { className: "space-y-2", children: [(0, li.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Table" }), (0, li.jsxs)("details", { ref: fe, className: "pointer-events-none select-none", children: [(0, li.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, li.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [ae ? (0, li.jsx)("span", { className: "font-mono", children: i$6(ae) }) : (0, li.jsx)("span", { children: "Pick a table" }), (0, li.jsx)("span", { className: "text-white/40 text-xs", children: "" })] }) }), (0, li.jsx)("div", { className: "relative", children: (0, li.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: ne.map((we) => (0, li.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", we === ae ? "bg-slate-600" : null), to: we.tableId, onClick: () => {
    fe.current && (fe.current.open = !1);
  }, children: i$6(we) }, we.tableId)) }) })] })] }), (0, li.jsx)(cc, {})] });
}
var Yh, li, C$ = Y(() => {
  Do(), ql(), Yh = le(ir(), 1), uc(), gx(), li = le(ke(), 1);
});
function R$(ne) {
  let { useStore: oe } = zt();
  if (!oe)
    throw new Error("Missing useStore");
  let [ae, fe] = (0, bx.useState)(oe.getState().getRecords(ne));
  return (0, bx.useEffect)(() => oe.subscribe(() => {
    let ye = oe.getState().getRecords(ne);
    ye !== ae && fe(ye);
  }), [oe, ae]), Object.values(ae);
}
var bx, O$ = Y(() => {
  ai(), bx = le(ir(), 1);
});
function T$({ hex: ne }) {
  return ne.length <= 10 ? (0, vp.jsx)("span", { children: ne }) : (0, vp.jsxs)("span", { children: [(0, vp.jsx)("span", { className: "after:content-[''] after:select-none", children: ne.slice(0, 6) }), (0, vp.jsx)("span", { className: "tracking-[-1ch] text-transparent", children: ne.slice(6, -4) }), ne.slice(-4)] });
}
var vp, k$ = Y(() => {
  vp = le(ke(), 1);
});
function CP({ value: ne }) {
  return Array.isArray(ne) ? ne.map((oe, ae) => (0, ps.jsxs)(A$.default.Fragment, { children: [ae > 0 ? ", " : null, (0, ps.jsx)(CP, { value: oe })] }, JSON.stringify({ i: ae, value: ne }))) : eo(ne) ? (0, ps.jsx)(T$, { hex: ne }) : (0, ps.jsx)(ps.Fragment, { children: String(ne) });
}
var A$, ps, P$ = Y(() => {
  A$ = le(ir(), 1), Hh(), k$(), ps = le(ke(), 1);
});
function M$({ table: ne }) {
  let oe = R$(ne);
  return (0, qo.jsxs)("table", { className: "w-full -mx-1", children: [(0, qo.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, qo.jsx)("tr", { className: "text-amber-200/80 font-mono", children: Object.keys(ne.schema).map((ae) => (0, qo.jsx)("th", { className: "px-1.5 pt-1.5 font-normal", children: ae }, ae)) }) }), (0, qo.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => (0, qo.jsx)("tr", { children: Object.keys(ne.schema).map((fe) => (0, qo.jsx)("td", { className: "px-1.5 whitespace-nowrap overflow-hidden text-ellipsis", children: (0, qo.jsx)(CP, { value: ae.fields[fe] }) }, fe)) }, ae.id)) })] });
}
var qo, D$ = Y(() => {
  O$(), P$(), qo = le(ke(), 1);
});
function N$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((fe) => fe.tableId === oe);
  return ae ? (0, L$.jsx)(M$, { table: ae }, ae.tableId) : null;
}
var L$, j$ = Y(() => {
  Do(), D$(), gx(), L$ = le(ke(), 1);
}), Qr, U$, F$ = Y(() => {
  Do(), Fq(), Iq(), $q(), d$(), v$(), h$(), w$(), C$(), j$(), Qr = le(ke(), 1), U$ = Ek(pd((0, Qr.jsxs)(Ga, { path: "/", element: (0, Qr.jsx)(Uq, {}), errorElement: (0, Qr.jsx)(qq, {}), children: [(0, Qr.jsx)(Ga, { index: !0, element: (0, Qr.jsx)(f$, {}) }), (0, Qr.jsx)(Ga, { path: "actions", element: (0, Qr.jsx)(p$, {}) }), (0, Qr.jsx)(Ga, { path: "events", element: (0, Qr.jsx)(Vq, {}) }), (0, Qr.jsx)(Ga, { path: "tables", element: (0, Qr.jsx)(E$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(N$, {}) }) }), (0, Qr.jsx)(Ga, { path: "components", element: (0, Qr.jsx)(m$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(_$, {}) }) })] })));
});
function TP(ne, oe) {
  if (Ai.useSyncExternalStore === void 0)
    throw new TypeError('You are using React 17 or below. Install with "npm install use-local-storage-state@17".');
  let [ae] = (0, Ai.useState)(oe == null ? void 0 : oe.defaultValue);
  if (typeof window > "u")
    return [ae, () => {
    }, { isPersistent: !0, removeItem: () => {
    } }];
  let fe = oe == null ? void 0 : oe.serializer;
  return kbe(ne, ae, oe == null ? void 0 : oe.storageSync, fe == null ? void 0 : fe.parse, fe == null ? void 0 : fe.stringify);
}
function kbe(ne, oe, ae = !0, fe = Abe, ye = JSON.stringify) {
  if (!Tc.has(ne) && oe !== void 0 && localStorage.getItem(ne) === null)
    try {
      localStorage.setItem(ne, ye(oe));
    } catch {
    }
  let we = (0, Ai.useRef)({ item: null, parsed: oe }), _e = (0, Ai.useSyncExternalStore)((0, Ai.useCallback)((Oe) => {
    let $e = (Re) => {
      ne === Re && Oe();
    };
    return OP.add($e), () => {
      OP.delete($e);
    };
  }, [ne]), () => {
    let Oe = localStorage.getItem(ne);
    if (Tc.has(ne))
      we.current = { item: Oe, parsed: Tc.get(ne) };
    else if (Oe !== we.current.item) {
      let $e;
      try {
        $e = Oe === null ? oe : fe(Oe);
      } catch {
        $e = oe;
      }
      we.current = { item: Oe, parsed: $e };
    }
    return we.current.parsed;
  }, () => oe), xe = (0, Ai.useCallback)((Oe) => {
    let $e = Oe instanceof Function ? Oe(we.current.parsed) : Oe;
    try {
      localStorage.setItem(ne, ye($e)), Tc.delete(ne);
    } catch {
      Tc.set(ne, $e);
    }
    RP(ne);
  }, [ne, ye]);
  return (0, Ai.useEffect)(() => {
    if (!ae)
      return;
    let Oe = ($e) => {
      $e.storageArea === localStorage && $e.key === ne && RP(ne);
    };
    return window.addEventListener("storage", Oe), () => window.removeEventListener("storage", Oe);
  }, [ne, ae]), (0, Ai.useMemo)(() => [_e, xe, { isPersistent: _e === oe || !Tc.has(ne), removeItem() {
    Tc.delete(ne), localStorage.removeItem(ne), RP(ne);
  } }], [ne, xe, _e, oe]);
}
function RP(ne) {
  for (let oe of [...OP])
    oe(ne);
}
function Abe(ne) {
  return ne === "undefined" ? void 0 : JSON.parse(ne);
}
var Ai, Tc, OP, z$ = Y(() => {
  Ai = le(ir()), Tc = /* @__PURE__ */ new Map(), OP = /* @__PURE__ */ new Set();
}), q$, I$ = Y(() => {
  z$(), q$ = TP;
}), H$ = {};
Uj(H$, { App: () => Pbe });
function Pbe() {
  let [ne, oe] = q$("mud-dev-tools-shown", { defaultValue: !0 });
  return (0, B$.useEffect)(() => {
    let ae = (fe) => {
      fe.key === "`" && oe(!ne);
    };
    return window.addEventListener("keypress", ae), () => window.removeEventListener("keypress", ae);
  }), (0, io.jsx)("div", { className: "fixed inset-0 pointer-events-none", children: (0, io.jsxs)("div", { className: Pr("pointer-events-auto w-full max-w-screen-sm h-full absolute right-0", "transition duration-500", ne ? "translate-x-0" : "translate-x-full"), children: [(0, io.jsxs)("div", { className: "absolute bottom-0 right-full min-w-max flex flex-col-reverse items-end justify-center m-2 text-gray-500", children: [(0, io.jsx)("button", { type: "button", className: "peer text-sm p-2 rounded leading-none transition opacity-60 hover:opacity-100", onClick: () => oe(!ne), children: (0, io.jsxs)("span", { className: "whitespace-nowrap font-medium", children: [ne ? "" : "", " MUD Dev Tools"] }) }), (0, io.jsxs)("span", { className: "transition opacity-0 peer-hover:opacity-60 px-2 text-xs flex items-center justify-center gap-2", children: ["Keyboard shortcut", (0, io.jsx)("code", { className: "bg-gray-500/10 p-1 rounded text-mono text-xs leading-none", children: "`" })] })] }), (0, io.jsx)("div", { className: Pr("w-full h-full bg-slate-800 text-white/80 text-sm flex flex-col", "transition duration-500", ne ? "opacity-100" : "opacity-0"), children: (0, io.jsx)(xk, { router: U$ }) })] }) });
}
var B$, io, V$ = Y(() => {
  Sz(), _z(), B$ = le(ir(), 1), uc(), F$(), Do(), I$(), io = le(ke(), 1);
}), Sx = le(ke(), 1), $$ = "mud-dev-tools";
async function Mbe(ne) {
  if (typeof window > "u") {
    console.warn("MUD dev-tools should only be used in browser bundles");
    return;
  }
  if (document.getElementById($$)) {
    console.warn("MUD dev-tools is already mounted");
    return;
  }
  try {
    let oe = await Promise.resolve().then(() => le(ir(), 1)), ae = await Promise.resolve().then(() => le(bz(), 1)), { App: fe } = await Promise.resolve().then(() => (V$(), H$)), { DevToolsProvider: ye } = await Promise.resolve().then(() => (ai(), Lq)), we = document.createElement("div");
    we.id = $$, we.style.position = "relative", we.style.zIndex = "999999";
    let _e = ae.createRoot(we);
    return _e.render((0, Sx.jsx)(oe.StrictMode, { children: (0, Sx.jsx)(ye, { value: ne, children: (0, Sx.jsx)(fe, {}) }) })), document.body.appendChild(we), () => {
      _e.unmount(), we.remove();
    };
  } catch (oe) {
    console.error("Failed to mount MUD dev-tools", oe);
  }
}
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.6.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
class MudLib {
  constructor() {
    dc(this, "increment");
  }
  async setup() {
    const {
      components: oe,
      systemCalls: {
        spawnPlayer: ae,
        spawnCapital: fe,
        marchArmy: ye,
        attack: we,
        garrison: _e,
        buyInfantry: xe,
        buyCavalryA: Oe,
        buyCavalryB: $e,
        buyCavalryC: Re,
        stakeTokenB: Ne,
        stakeTokenC: je,
        unStakeTokenB: Be,
        unStakeTokenC: ze,
        farming: He,
        setMerkleRoot: qe,
        claim: Ye,
        swapA2B: ot,
        swapA2C: tt,
        withdrawToken: it
      },
      network: ht
    } = await setup(), gt = await ht.publicClient.getBlockNumber();
    this.spawnPlayer = ae, this.spawnCapital = fe, this.marchArmy = ye, this.attack = we, this.garrison = _e, this.buyInfantry = xe, this.buyCavalryA = Oe, this.buyCavalryB = $e, this.buyCavalryC = Re, this.stakeTokenB = Ne, this.stakeTokenC = je, this.unStakeTokenB = Be, this.unStakeTokenC = ze, this.farming = He, this.setMerkleRoot = qe, this.claim = Ye, this.swapA2B = ot, this.swapA2C = tt, this.withdrawToken = it, Mbe({
      config: mudConfig,
      publicClient: ht.publicClient,
      walletClient: ht.walletClient,
      latestBlock$: ht.latestBlock$,
      storedBlockLogs$: ht.storedBlockLogs$,
      worldAddress: ht.worldContract.address,
      worldAbi: ht.worldContract.abi,
      write$: ht.write$,
      // tables:mudConfig.tables
      useStore: ht.useStore
    }), this.network = ht, oe.Player.update$.subscribe((St) => {
      console.log("Player updated", St), this.player_updated({
        entity: St.entity,
        value: St.value
      });
    }), oe.PlayerDetail.update$.subscribe((St) => {
      console.log("PlayerDetails updated", St), this.player_detail_updated({
        entity: St.entity,
        value: St.value
      });
    }), oe.Land.update$.subscribe((St) => {
      console.log("Land updated", St), this.land_updated({
        entity: St.entity,
        value: St.value
      });
    }), oe.Capital.update$.subscribe((St) => {
      console.log("Capital updated", St), this.capital_updated({
        entity: St.entity,
        value: St.value
      });
    }), oe.Army.update$.subscribe((St) => {
      console.log("Army updated", St), this.army_updated({
        entity: St.entity,
        value: St.value
      });
    }), oe.BattleReport.update$.subscribe((St) => {
      console.log("BattleReport updated", St), this.battle_report_updated({
        entity: St.entity,
        value: St.value
      });
    });
    let At = !1;
    ht.storedBlockLogs$.subscribe((St) => {
      !At && St.blockNumber >= gt && (console.log("all catch up"), At = !0, this.all_catch_up({}));
    });
  }
  // To be overwritten by Godot callback
  player_updated(oe) {
  }
  player_detail_updated(oe) {
  }
  land_updated(oe) {
  }
  capital_updated(oe) {
  }
  army_updated(oe) {
  }
  battle_report_updated(oe) {
  }
  stored_block_logs(oe) {
  }
  setup_block(oe) {
  }
  all_catch_up(oe) {
  }
}
window.mud = new MudLib();
export {
  BaseError$1 as B,
  HttpRequestError as H,
  InvalidAddressError as I,
  concat$1 as a,
  isHex$1 as b,
  call as c,
  decodeErrorResult as d,
  encodeAbiParameters as e,
  getUrl$1 as g,
  isAddress as i,
  stringify as s
};
