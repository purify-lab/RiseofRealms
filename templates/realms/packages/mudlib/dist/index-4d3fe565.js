var WM = Object.defineProperty;
var GM = (ne, oe, ae) => oe in ne ? WM(ne, oe, { enumerable: !0, configurable: !0, writable: !0, value: ae }) : ne[oe] = ae;
var Tl = (ne, oe, ae) => (GM(ne, typeof oe != "symbol" ? oe + "" : oe, ae), ae);
function createClientComponents({ components: ne }) {
  return {
    ...ne
    // add your client components or overrides here
  };
}
function createSystemCalls({ tables: ne, worldContract: oe, waitForTransaction: ae }) {
  return {
    spawnPlayer: async () => {
      const ht = await oe.write.spawnPlayer([]);
      await ae(ht);
    },
    marchArmy: async (ht, wt, gt, It, Nt, Ft) => {
      const on = await oe.write.march([ht, wt, gt, It, Nt, Ft]);
      await ae(on);
    },
    attack: async (ht) => {
      const wt = await oe.write.attack([ht]);
      await ae(wt);
    },
    garrison: async (ht, wt, gt, It, Nt) => {
      const Ft = await oe.write.garrison([ht, wt, gt, It, Nt]);
      await ae(Ft);
    },
    buyInfantry: async (ht) => {
      console.log("worldContract", oe);
      const wt = await oe.write.buyInfantry([ht]);
      await ae(wt);
    },
    buyCavalryA: async (ht) => {
      const wt = await oe.write.buyCavalryA([ht]);
      await ae(wt);
    },
    buyCavalryB: async (ht) => {
      const wt = await oe.write.buyCavalryB([ht]);
      await ae(wt);
    },
    buyCavalryC: async (ht) => {
      const wt = await oe.write.buyCavalryC([ht]);
      await ae(wt);
    },
    spawnCapital: async (ht) => {
      const wt = await oe.write.spawnCapital([ht], {
        value: 5e14
        //ethers.utils.parseEther("0.5"),
      });
      await ae(wt);
    },
    stakeTokenB: async (ht) => {
      const wt = await oe.write.stakeTokenB([ht]);
      await ae(wt);
    },
    stakeTokenC: async (ht) => {
      const wt = await oe.write.stakeTokenC([ht]);
      await ae(wt);
    },
    unStakeTokenB: async (ht, wt) => {
      const gt = await oe.write.unStakeTokenB([ht, wt]);
      await ae(gt);
    },
    unStakeTokenC: async (ht, wt) => {
      const gt = await oe.write.unStakeTokenC([ht, wt]);
      await ae(gt);
    },
    farming: async (ht) => {
      const wt = await oe.write.farming([ht]);
      await ae(wt);
    },
    setMerkleRoot: async (ht) => {
      const wt = await oe.write.setMerkleRoot([ht]);
      await ae(wt);
    },
    claim: async (ht, wt) => {
      const gt = await oe.write.claim([ht, wt]);
      await ae(gt);
    },
    swapA2B: async (ht) => {
      const wt = await oe.write.swapA2B([ht]);
      await ae(wt);
    },
    swapA2C: async (ht) => {
      const wt = await oe.write.swapA2C([ht]);
      await ae(wt);
    },
    withdrawToken: async (ht, wt) => {
      const gt = await oe.write.withdrawToken([ht, wt]);
      await ae(gt);
    }
  };
}
const version$1 = "1.0.0";
let BaseError$1 = class qE extends Error {
  constructor(oe, ae = {}) {
    var we;
    const fe = ae.cause instanceof qE ? ae.cause.details : (we = ae.cause) != null && we.message ? ae.cause.message : ae.details, ye = ae.cause instanceof qE && ae.cause.docsPath || ae.docsPath, ge = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [`Docs: https://abitype.dev${ye}`] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: abitype@${version$1}`
    ].join(`
`);
    super(ge), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
};
function execTyped(ne, oe) {
  const ae = ne.exec(oe);
  return ae == null ? void 0 : ae.groups;
}
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex$1 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, isTupleRegex = /^\(.+?\).*?$/, tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(ne) {
  let oe = ne.type;
  if (tupleRegex.test(ne.type) && "components" in ne) {
    oe = "(";
    const ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      const ge = ne.components[ye];
      oe += formatAbiParameter(ge), ye < ae - 1 && (oe += ", ");
    }
    const fe = execTyped(tupleRegex, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, formatAbiParameter({
      ...ne,
      type: oe
    });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
function formatAbiParameters(ne) {
  let oe = "";
  const ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    const ye = ne[fe];
    oe += formatAbiParameter(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
function formatAbiItem$1(ne) {
  return ne.type === "function" ? `function ${ne.name}(${formatAbiParameters(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${formatAbiParameters(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${formatAbiParameters(ne.inputs)})` : ne.type === "constructor" ? `constructor(${formatAbiParameters(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(ne) {
  return errorSignatureRegex.test(ne);
}
function execErrorSignature(ne) {
  return execTyped(errorSignatureRegex, ne);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(ne) {
  return eventSignatureRegex.test(ne);
}
function execEventSignature(ne) {
  return execTyped(eventSignatureRegex, ne);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(ne) {
  return functionSignatureRegex.test(ne);
}
function execFunctionSignature(ne) {
  return execTyped(functionSignatureRegex, ne);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(ne) {
  return structSignatureRegex.test(ne);
}
function execStructSignature(ne) {
  return execTyped(structSignatureRegex, ne);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(ne) {
  return constructorSignatureRegex.test(ne);
}
function execConstructorSignature(ne) {
  return execTyped(constructorSignatureRegex, ne);
}
const fallbackSignatureRegex = /^fallback\(\)$/;
function isFallbackSignature(ne) {
  return fallbackSignatureRegex.test(ne);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(ne) {
  return receiveSignatureRegex.test(ne);
}
const modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]), eventModifiers = /* @__PURE__ */ new Set(["indexed"]), functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class UnknownTypeError extends BaseError$1 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${oe}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError$1 {
  constructor({ type: oe }) {
    super("Unknown type.", {
      metaMessages: [`Type "${oe}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidAbiParametersError extends BaseError$1 {
  constructor({ params: oe }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(oe, null, 2)})`,
      docsPath: "/api/human#parseabiparameters-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiParametersError"
    });
  }
}
class InvalidParameterError extends BaseError$1 {
  constructor({ param: oe }) {
    super("Invalid ABI parameter.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError$1 {
  constructor({ param: oe, name: ae }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `"${ae}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError$1 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError$1 {
  constructor({ param: oe, type: ae, modifier: fe }) {
    super("Invalid ABI parameter.", {
      details: oe,
      metaMessages: [
        `Modifier "${fe}" not allowed${ae ? ` in "${ae}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${fe}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError$1 {
  constructor({ abiParameter: oe }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(oe, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError$1 {
  constructor({ signature: oe, type: ae }) {
    super(`Invalid ${ae} signature.`, {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError$1 {
  constructor({ signature: oe }) {
    super("Unknown signature.", {
      details: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError$1 {
  constructor({ signature: oe }) {
    super("Invalid struct signature.", {
      details: oe,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError$1 {
  constructor({ type: oe }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${oe}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError$1 {
  constructor({ current: oe, depth: ae }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${oe.trim()}" has too many ${ae > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${ae}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(ne, oe) {
  return oe ? `${oe}:${ne}` : ne;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function parseSignature(ne, oe = {}) {
  if (isFunctionSignature(ne)) {
    const ae = execFunctionSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "function" });
    const fe = splitParameters(ae.parameters), ye = [], ge = fe.length;
    for (let _e = 0; _e < ge; _e++)
      ye.push(parseAbiParameter(fe[_e], {
        modifiers: functionModifiers,
        structs: oe,
        type: "function"
      }));
    const we = [];
    if (ae.returns) {
      const _e = splitParameters(ae.returns), Se = _e.length;
      for (let Ie = 0; Ie < Se; Ie++)
        we.push(parseAbiParameter(_e[Ie], {
          modifiers: functionModifiers,
          structs: oe,
          type: "function"
        }));
    }
    return {
      name: ae.name,
      type: "function",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye,
      outputs: we
    };
  }
  if (isEventSignature(ne)) {
    const ae = execEventSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "event" });
    const fe = splitParameters(ae.parameters), ye = [], ge = fe.length;
    for (let we = 0; we < ge; we++)
      ye.push(parseAbiParameter(fe[we], {
        modifiers: eventModifiers,
        structs: oe,
        type: "event"
      }));
    return { name: ae.name, type: "event", inputs: ye };
  }
  if (isErrorSignature(ne)) {
    const ae = execErrorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "error" });
    const fe = splitParameters(ae.parameters), ye = [], ge = fe.length;
    for (let we = 0; we < ge; we++)
      ye.push(parseAbiParameter(fe[we], { structs: oe, type: "error" }));
    return { name: ae.name, type: "error", inputs: ye };
  }
  if (isConstructorSignature(ne)) {
    const ae = execConstructorSignature(ne);
    if (!ae)
      throw new InvalidSignatureError({ signature: ne, type: "constructor" });
    const fe = splitParameters(ae.parameters), ye = [], ge = fe.length;
    for (let we = 0; we < ge; we++)
      ye.push(parseAbiParameter(fe[we], { structs: oe, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: ae.stateMutability ?? "nonpayable",
      inputs: ye
    };
  }
  if (isFallbackSignature(ne))
    return { type: "fallback" };
  if (isReceiveSignature(ne))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: ne });
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(ne, oe) {
  var Ne, Me;
  const ae = getParameterCacheKey(ne, oe == null ? void 0 : oe.type);
  if (parameterCache.has(ae))
    return parameterCache.get(ae);
  const fe = isTupleRegex.test(ne), ye = execTyped(fe ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, ne);
  if (!ye)
    throw new InvalidParameterError({ param: ne });
  if (ye.name && isSolidityKeyword(ye.name))
    throw new SolidityProtectedKeywordError({ param: ne, name: ye.name });
  const ge = ye.name ? { name: ye.name } : {}, we = ye.modifier === "indexed" ? { indexed: !0 } : {}, _e = (oe == null ? void 0 : oe.structs) ?? {};
  let Se, Ie = {};
  if (fe) {
    Se = "tuple";
    const Be = splitParameters(ye.type), ze = [], He = Be.length;
    for (let Ze = 0; Ze < He; Ze++)
      ze.push(parseAbiParameter(Be[Ze], { structs: _e }));
    Ie = { components: ze };
  } else if (ye.type in _e)
    Se = "tuple", Ie = { components: _e[ye.type] };
  else if (dynamicIntegerRegex.test(ye.type))
    Se = `${ye.type}256`;
  else if (Se = ye.type, (oe == null ? void 0 : oe.type) !== "struct" && !isSolidityType(Se))
    throw new UnknownSolidityTypeError({ type: Se });
  if (ye.modifier) {
    if (!((Me = (Ne = oe == null ? void 0 : oe.modifiers) == null ? void 0 : Ne.has) != null && Me.call(Ne, ye.modifier)))
      throw new InvalidModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
    if (functionModifiers.has(ye.modifier) && !isValidDataLocation(Se, !!ye.array))
      throw new InvalidFunctionModifierError({
        param: ne,
        type: oe == null ? void 0 : oe.type,
        modifier: ye.modifier
      });
  }
  const $e = {
    type: `${Se}${ye.array ?? ""}`,
    ...ge,
    ...we,
    ...Ie
  };
  return parameterCache.set(ae, $e), $e;
}
function splitParameters(ne, oe = [], ae = "", fe = 0) {
  const ye = ne.trim().length;
  for (let ge = 0; ge < ye; ge++) {
    const we = ne[ge], _e = ne.slice(ge + 1);
    switch (we) {
      case ",":
        return fe === 0 ? splitParameters(_e, [...oe, ae.trim()]) : splitParameters(_e, oe, `${ae}${we}`, fe);
      case "(":
        return splitParameters(_e, oe, `${ae}${we}`, fe + 1);
      case ")":
        return splitParameters(_e, oe, `${ae}${we}`, fe - 1);
      default:
        return splitParameters(_e, oe, `${ae}${we}`, fe);
    }
  }
  if (ae === "")
    return oe;
  if (fe !== 0)
    throw new InvalidParenthesisError({ current: ae, depth: fe });
  return oe.push(ae.trim()), oe;
}
function isSolidityType(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || bytesRegex$1.test(ne) || integerRegex$1.test(ne);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(ne) {
  return ne === "address" || ne === "bool" || ne === "function" || ne === "string" || ne === "tuple" || bytesRegex$1.test(ne) || integerRegex$1.test(ne) || protectedKeywordsRegex.test(ne);
}
function isValidDataLocation(ne, oe) {
  return oe || ne === "bytes" || ne === "string" || ne === "tuple";
}
function parseStructs(ne) {
  const oe = {}, ae = ne.length;
  for (let we = 0; we < ae; we++) {
    const _e = ne[we];
    if (!isStructSignature(_e))
      continue;
    const Se = execStructSignature(_e);
    if (!Se)
      throw new InvalidSignatureError({ signature: _e, type: "struct" });
    const Ie = Se.properties.split(";"), $e = [], Ne = Ie.length;
    for (let Me = 0; Me < Ne; Me++) {
      const ze = Ie[Me].trim();
      if (!ze)
        continue;
      const He = parseAbiParameter(ze, {
        type: "struct"
      });
      $e.push(He);
    }
    if (!$e.length)
      throw new InvalidStructSignatureError({ signature: _e });
    oe[Se.name] = $e;
  }
  const fe = {}, ye = Object.entries(oe), ge = ye.length;
  for (let we = 0; we < ge; we++) {
    const [_e, Se] = ye[we];
    fe[_e] = resolveStructs(Se, oe);
  }
  return fe;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(ne, oe, ae = /* @__PURE__ */ new Set()) {
  const fe = [], ye = ne.length;
  for (let ge = 0; ge < ye; ge++) {
    const we = ne[ge];
    if (isTupleRegex.test(we.type))
      fe.push(we);
    else {
      const Se = execTyped(typeWithoutTupleRegex, we.type);
      if (!(Se != null && Se.type))
        throw new InvalidAbiTypeParameterError({ abiParameter: we });
      const { array: Ie, type: $e } = Se;
      if ($e in oe) {
        if (ae.has($e))
          throw new CircularReferenceError({ type: $e });
        fe.push({
          ...we,
          type: `tuple${Ie ?? ""}`,
          components: resolveStructs(oe[$e] ?? [], oe, /* @__PURE__ */ new Set([...ae, $e]))
        });
      } else if (isSolidityType($e))
        fe.push(we);
      else
        throw new UnknownTypeError({ type: $e });
    }
  }
  return fe;
}
function parseAbi(ne) {
  const oe = parseStructs(ne), ae = [], fe = ne.length;
  for (let ye = 0; ye < fe; ye++) {
    const ge = ne[ye];
    isStructSignature(ge) || ae.push(parseSignature(ge, oe));
  }
  return ae;
}
function parseAbiParameters(ne) {
  const oe = [];
  if (typeof ne == "string") {
    const ae = splitParameters(ne), fe = ae.length;
    for (let ye = 0; ye < fe; ye++)
      oe.push(parseAbiParameter(ae[ye], { modifiers }));
  } else {
    const ae = parseStructs(ne), fe = ne.length;
    for (let ye = 0; ye < fe; ye++) {
      const ge = ne[ye];
      if (isStructSignature(ge))
        continue;
      const we = splitParameters(ge), _e = we.length;
      for (let Se = 0; Se < _e; Se++)
        oe.push(parseAbiParameter(we[Se], { modifiers, structs: ae }));
    }
  }
  if (oe.length === 0)
    throw new InvalidAbiParametersError({ params: ne });
  return oe;
}
function getAction(ne, oe, ae) {
  return (fe) => {
    var ye, ge;
    return ((ye = ne[oe.name]) == null ? void 0 : ye.call(ne, fe)) ?? ((ge = ne[ae]) == null ? void 0 : ge.call(ne, fe)) ?? oe(ne, fe);
  };
}
function formatAbiItem(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new InvalidDefinitionTypeError(ne.type);
  return `${ne.name}(${formatAbiParams(ne.inputs, { includeName: oe })})`;
}
function formatAbiParams(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => formatAbiParam(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function formatAbiParam(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${formatAbiParams(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
function isHex(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
function size$1(ne) {
  return isHex(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
const version = "2.9.20", getContractAddress = (ne) => ne, getUrl$1 = (ne) => ne, getVersion = () => `viem@${version}`;
class BaseError extends Error {
  constructor(oe, ae = {}) {
    var ge;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion()
    });
    const fe = ae.cause instanceof BaseError ? ae.cause.details : (ge = ae.cause) != null && ge.message ? ae.cause.message : ae.details, ye = ae.cause instanceof BaseError && ae.cause.docsPath || ae.docsPath;
    this.message = [
      oe || "An error occurred.",
      "",
      ...ae.metaMessages ? [...ae.metaMessages, ""] : [],
      ...ye ? [
        `Docs: https://viem.sh${ye}${ae.docsSlug ? `#${ae.docsSlug}` : ""}`
      ] : [],
      ...fe ? [`Details: ${fe}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ae.cause && (this.cause = ae.cause), this.details = fe, this.docsPath = ye, this.metaMessages = ae.metaMessages, this.shortMessage = oe;
  }
  walk(oe) {
    return walk(this, oe);
  }
}
function walk(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? walk(ne.cause, oe) : oe ? null : ne;
}
class AbiConstructorNotFoundError extends BaseError {
  constructor({ docsPath: oe }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError {
  constructor({ docsPath: oe }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError {
  constructor({ data: oe, params: ae, size: fe }) {
    super([`Data size of ${fe} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(ae, { includeName: !0 })})`,
        `Data:   ${oe} (${fe} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe, this.params = ae, this.size = fe;
  }
}
class AbiDecodingZeroDataError extends BaseError {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor({ expectedLength: oe, givenLength: ae, type: fe }) {
    super([
      `ABI encoding array length mismatch for type ${fe}.`,
      `Expected length: ${oe}`,
      `Given length: ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor({ expectedSize: oe, value: ae }) {
    super(`Size of bytes "${ae}" (bytes${size$1(ae)}) does not match expected size (bytes${oe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError {
  constructor({ expectedLength: oe, givenLength: ae }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${oe}`,
      `Given length (values): ${ae}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded error signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = oe;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError {
  constructor({ docsPath: oe }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError {
  constructor(oe, { docsPath: ae }) {
    super([
      `Encoded event signature "${oe}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${oe}.`
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Event ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError {
  constructor(oe, { docsPath: ae } = {}) {
    super([
      `Function ${oe ? `"${oe}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError {
  constructor(oe, { docsPath: ae }) {
    super([
      `Function "${oe}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ae
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError {
  constructor(oe, ae) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${oe.type}\` in \`${formatAbiItem(oe.abiItem)}\`, and`,
        `\`${ae.type}\` in \`${formatAbiItem(ae.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError {
  constructor({ expectedSize: oe, givenSize: ae }) {
    super(`Expected bytes${oe}, got bytes${ae}.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError {
  constructor({ abiItem: oe, data: ae, params: fe, size: ye }) {
    super([
      `Data size of ${ye} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(fe, { includeName: !0 })})`,
        `Data:   ${ae} (${ye} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe, this.data = ae, this.params = fe, this.size = ye;
  }
}
class DecodeLogTopicsMismatch extends BaseError {
  constructor({ abiItem: oe, param: ae }) {
    super([
      `Expected a topic for indexed event parameter${ae.name ? ` "${ae.name}"` : ""} on event "${formatAbiItem(oe, { includeName: !0 })}".`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogTopicsMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = oe;
  }
}
class InvalidAbiEncodingTypeError extends BaseError {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError {
  constructor(oe, { docsPath: ae }) {
    super([
      `Type "${oe}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ae }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError {
  constructor(oe) {
    super([`Value "${oe}" is not a valid array.`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError {
  constructor(oe) {
    super([
      `"${oe}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidDefinitionTypeError"
    });
  }
}
class UnsupportedPackedAbiType extends BaseError {
  constructor(oe) {
    super(`Type "${oe}" is not supported for packed encoding.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedPackedAbiType"
    });
  }
}
class FilterTypeNotSupportedError extends BaseError {
  constructor(oe) {
    super(`Filter type "${oe}" is not supported.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FilterTypeNotSupportedError"
    });
  }
}
class SliceOffsetOutOfBoundsError extends BaseError {
  constructor({ offset: oe, position: ae, size: fe }) {
    super(`Slice ${ae === "start" ? "starting" : "ending"} at offset "${oe}" is out-of-bounds (size: ${fe}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} size (${oe}) exceeds padding size (${ae}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
class InvalidBytesLengthError extends BaseError {
  constructor({ size: oe, targetSize: ae, type: fe }) {
    super(`${fe.charAt(0).toUpperCase()}${fe.slice(1).toLowerCase()} is expected to be ${ae} ${fe} long, but is ${oe} ${fe} long.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesLengthError"
    });
  }
}
function pad(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? padHex(ne, { dir: oe, size: ae }) : padBytes(ne, { dir: oe, size: ae });
}
function padHex(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  const fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(fe.length / 2),
      targetSize: ae,
      type: "hex"
    });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function padBytes(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new SizeExceedsPaddingSizeError({
      size: ne.length,
      targetSize: ae,
      type: "bytes"
    });
  const fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    const ge = oe === "right";
    fe[ge ? ye : ae - ye - 1] = ne[ge ? ye : ne.length - ye - 1];
  }
  return fe;
}
class IntegerOutOfRangeError extends BaseError {
  constructor({ max: oe, min: ae, signed: fe, size: ye, value: ge }) {
    super(`Number "${ge}" is not in safe ${ye ? `${ye * 8}-bit ${fe ? "signed" : "unsigned"} ` : ""}integer range ${oe ? `(${ae} to ${oe})` : `(above ${ae})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    });
  }
}
class InvalidBytesBooleanError extends BaseError {
  constructor(oe) {
    super(`Bytes value "${oe}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError {
  constructor(oe) {
    super(`Hex value "${oe}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidHexBooleanError"
    });
  }
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize: oe, maxSize: ae }) {
    super(`Size cannot exceed ${ae} bytes. Given size: ${oe} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
}
function trim(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
function assertSize(ne, { size: oe }) {
  if (size$1(ne) > oe)
    throw new SizeOverflowError({
      givenSize: size$1(ne),
      maxSize: oe
    });
}
function hexToBigInt(ne, oe = {}) {
  const { signed: ae } = oe;
  oe.size && assertSize(ne, { size: oe.size });
  const fe = BigInt(ne);
  if (!ae)
    return fe;
  const ye = (ne.length - 2) / 2, ge = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= ge ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function hexToBool(ne, oe = {}) {
  let ae = ne;
  if (oe.size && (assertSize(ae, { size: oe.size }), ae = trim(ae)), trim(ae) === "0x00")
    return !1;
  if (trim(ae) === "0x01")
    return !0;
  throw new InvalidHexBooleanError(ae);
}
function hexToNumber$1(ne, oe = {}) {
  return Number(hexToBigInt(ne, oe));
}
function hexToString(ne, oe = {}) {
  let ae = hexToBytes$1(ne);
  return oe.size && (assertSize(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function toHex(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToHex(ne, oe) : typeof ne == "string" ? stringToHex(ne, oe) : typeof ne == "boolean" ? boolToHex(ne, oe) : bytesToHex$1(ne, oe);
}
function boolToHex(ne, oe = {}) {
  const ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (assertSize(ae, { size: oe.size }), pad(ae, { size: oe.size })) : ae;
}
function bytesToHex$1(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += hexes$1[ne[ye]];
  const fe = `0x${ae}`;
  return typeof oe.size == "number" ? (assertSize(fe, { size: oe.size }), pad(fe, { dir: "right", size: oe.size })) : fe;
}
function numberToHex(ne, oe = {}) {
  const { signed: ae, size: fe } = oe, ye = BigInt(ne);
  let ge;
  fe ? ae ? ge = (1n << BigInt(fe) * 8n - 1n) - 1n : ge = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (ge = BigInt(Number.MAX_SAFE_INTEGER));
  const we = typeof ge == "bigint" && ae ? -ge - 1n : 0;
  if (ge && ye > ge || ye < we) {
    const Se = typeof ne == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: ge ? `${ge}${Se}` : void 0,
      min: `${we}${Se}`,
      signed: ae,
      size: fe,
      value: `${ne}${Se}`
    });
  }
  const _e = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? pad(_e, { size: fe }) : _e;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function stringToHex(ne, oe = {}) {
  const ae = encoder$1.encode(ne);
  return bytesToHex$1(ae, oe);
}
const encoder = /* @__PURE__ */ new TextEncoder();
function toBytes$1(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? numberToBytes(ne, oe) : typeof ne == "boolean" ? boolToBytes(ne, oe) : isHex(ne) ? hexToBytes$1(ne, oe) : stringToBytes(ne, oe);
}
function boolToBytes(ne, oe = {}) {
  const ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (assertSize(ae, { size: oe.size }), pad(ae, { size: oe.size })) : ae;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(ne) {
  if (ne >= charCodeMap.zero && ne <= charCodeMap.nine)
    return ne - charCodeMap.zero;
  if (ne >= charCodeMap.A && ne <= charCodeMap.F)
    return ne - (charCodeMap.A - 10);
  if (ne >= charCodeMap.a && ne <= charCodeMap.f)
    return ne - (charCodeMap.a - 10);
}
function hexToBytes$1(ne, oe = {}) {
  let ae = ne;
  oe.size && (assertSize(ae, { size: oe.size }), ae = pad(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  const ye = fe.length / 2, ge = new Uint8Array(ye);
  for (let we = 0, _e = 0; we < ye; we++) {
    const Se = charCodeToBase16(fe.charCodeAt(_e++)), Ie = charCodeToBase16(fe.charCodeAt(_e++));
    if (Se === void 0 || Ie === void 0)
      throw new BaseError(`Invalid byte sequence ("${fe[_e - 2]}${fe[_e - 1]}" in "${fe}").`);
    ge[we] = Se * 16 + Ie;
  }
  return ge;
}
function numberToBytes(ne, oe) {
  const ae = numberToHex(ne, oe);
  return hexToBytes$1(ae);
}
function stringToBytes(ne, oe = {}) {
  const ae = encoder.encode(ne);
  return typeof oe.size == "number" ? (assertSize(ae, { size: oe.size }), pad(ae, { dir: "right", size: oe.size })) : ae;
}
function number(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function bytes(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function hash$1(ne) {
  if (typeof ne != "function" || typeof ne.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(ne.outputLen), number(ne.blockLen);
}
function exists(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(ne, oe) {
  bytes(ne);
  const ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(ne, oe = !1) {
  return oe ? { h: Number(ne & U32_MASK64), l: Number(ne >> _32n & U32_MASK64) } : { h: Number(ne >> _32n & U32_MASK64) | 0, l: Number(ne & U32_MASK64) | 0 };
}
function split(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    const { h: ge, l: we } = fromBig(ne[ye], oe);
    [ae[ye], fe[ye]] = [ge, we];
  }
  return [ae, fe];
}
const rotlSH = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, rotlSL = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, rotlBH = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, rotlBL = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae, crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (ne) => ne instanceof Uint8Array, u32 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), createView = (ne) => new DataView(ne.buffer, ne.byteOffset, ne.byteLength), rotr = (ne, oe) => ne << 32 - oe | ne >>> oe, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function toBytes(ne) {
  if (typeof ne == "string" && (ne = utf8ToBytes$1(ne)), !u8a$1(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function concatBytes$2(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a$1(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(ne) {
  const oe = (fe) => ne().update(toBytes(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function randomBytes(ne = 32) {
  if (crypto && typeof crypto.getRandomValues == "function")
    return crypto.getRandomValues(new Uint8Array(ne));
  throw new Error("crypto.getRandomValues must be defined");
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$4 = /* @__PURE__ */ BigInt(0), _1n$5 = /* @__PURE__ */ BigInt(1), _2n$3 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let ne = 0, oe = _1n$5, ae = 1, fe = 0; ne < 24; ne++) {
  [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], SHA3_PI.push(2 * (5 * fe + ae)), SHA3_ROTL.push((ne + 1) * (ne + 2) / 2 % 64);
  let ye = _0n$4;
  for (let ge = 0; ge < 7; ge++)
    oe = (oe << _1n$5 ^ (oe >> _7n) * _0x71n) % _256n, oe & _2n$3 && (ye ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(ge)) - _1n$5);
  _SHA3_IOTA.push(ye);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, !0), rotlH = (ne, oe, ae) => ae > 32 ? rotlBH(ne, oe, ae) : rotlSH(ne, oe, ae), rotlL = (ne, oe, ae) => ae > 32 ? rotlBL(ne, oe, ae) : rotlSL(ne, oe, ae);
function keccakP(ne, oe = 24) {
  const ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let we = 0; we < 10; we++)
      ae[we] = ne[we] ^ ne[we + 10] ^ ne[we + 20] ^ ne[we + 30] ^ ne[we + 40];
    for (let we = 0; we < 10; we += 2) {
      const _e = (we + 8) % 10, Se = (we + 2) % 10, Ie = ae[Se], $e = ae[Se + 1], Ne = rotlH(Ie, $e, 1) ^ ae[_e], Me = rotlL(Ie, $e, 1) ^ ae[_e + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[we + Be] ^= Ne, ne[we + Be + 1] ^= Me;
    }
    let ye = ne[2], ge = ne[3];
    for (let we = 0; we < 24; we++) {
      const _e = SHA3_ROTL[we], Se = rotlH(ye, ge, _e), Ie = rotlL(ye, ge, _e), $e = SHA3_PI[we];
      ye = ne[$e], ge = ne[$e + 1], ne[$e] = Se, ne[$e + 1] = Ie;
    }
    for (let we = 0; we < 50; we += 10) {
      for (let _e = 0; _e < 10; _e++)
        ae[_e] = ne[we + _e];
      for (let _e = 0; _e < 10; _e++)
        ne[we + _e] ^= ~ae[(_e + 2) % 10] & ae[(_e + 4) % 10];
    }
    ne[0] ^= SHA3_IOTA_H[fe], ne[1] ^= SHA3_IOTA_L[fe];
  }
  ae.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(oe, ae, fe, ye = !1, ge = 24) {
    if (super(), this.blockLen = oe, this.suffix = ae, this.outputLen = fe, this.enableXOF = ye, this.rounds = ge, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number(fe), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(oe) {
    exists(this);
    const { blockLen: ae, state: fe } = this;
    oe = toBytes(oe);
    const ye = oe.length;
    for (let ge = 0; ge < ye; ) {
      const we = Math.min(ae - this.pos, ye - ge);
      for (let _e = 0; _e < we; _e++)
        fe[this.pos++] ^= oe[ge++];
      this.pos === ae && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: oe, suffix: ae, pos: fe, blockLen: ye } = this;
    oe[fe] ^= ae, ae & 128 && fe === ye - 1 && this.keccak(), oe[ye - 1] ^= 128, this.keccak();
  }
  writeInto(oe) {
    exists(this, !1), bytes(oe), this.finish();
    const ae = this.state, { blockLen: fe } = this;
    for (let ye = 0, ge = oe.length; ye < ge; ) {
      this.posOut >= fe && this.keccak();
      const we = Math.min(fe - this.posOut, ge - ye);
      oe.set(ae.subarray(this.posOut, this.posOut + we), ye), this.posOut += we, ye += we;
    }
    return oe;
  }
  xofInto(oe) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(oe);
  }
  xof(oe) {
    return number(oe), this.xofInto(new Uint8Array(oe));
  }
  digestInto(oe) {
    if (output(oe, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(oe), this.destroy(), oe;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(oe) {
    const { blockLen: ae, suffix: fe, outputLen: ye, rounds: ge, enableXOF: we } = this;
    return oe || (oe = new Keccak(ae, fe, ye, we, ge)), oe.state32.set(this.state32), oe.pos = this.pos, oe.posOut = this.posOut, oe.finished = this.finished, oe.rounds = ge, oe.suffix = fe, oe.outputLen = ye, oe.enableXOF = we, oe.destroyed = this.destroyed, oe;
  }
}
const gen = (ne, oe, ae) => wrapConstructor(() => new Keccak(oe, ne, ae)), keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256(ne, oe) {
  const ae = oe || "hex", fe = keccak_256(isHex(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex(fe);
}
const hash = (ne) => keccak256(toBytes$1(ne));
function hashSignature(ne) {
  return hash(ne);
}
function normalizeSignature(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", ge = !1;
  for (let we = 0; we < ne.length; we++) {
    const _e = ne[we];
    if (["(", ")", ","].includes(_e) && (oe = !0), _e === "(" && fe++, _e === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (_e === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += _e, _e === ")") {
          ge = !0;
          break;
        }
        continue;
      }
      if (_e === " ") {
        ne[we - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += _e, ae += _e;
    }
  }
  if (!ge)
    throw new BaseError("Unable to normalize signature.");
  return ye;
}
const toSignature = (ne) => {
  const oe = (() => typeof ne == "string" ? ne : formatAbiItem$1(ne))();
  return normalizeSignature(oe);
};
function toSignatureHash(ne) {
  return hashSignature(toSignature(ne));
}
const toEventSelector = toSignatureHash;
class InvalidAddressError extends BaseError {
  constructor({ address: oe }) {
    super(`Address "${oe}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(oe) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = oe;
  }
  set(oe, ae) {
    return super.set(oe, ae), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
}
function checksumAddress(ne, oe) {
  const ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = keccak256(stringToBytes(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let ge = 0; ge < 40; ge += 2)
    fe[ge >> 1] >> 4 >= 8 && ye[ge] && (ye[ge] = ye[ge].toUpperCase()), (fe[ge >> 1] & 15) >= 8 && ye[ge + 1] && (ye[ge + 1] = ye[ge + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
function getAddress(ne, oe) {
  if (!isAddress(ne, { strict: !1 }))
    throw new InvalidAddressError({ address: ne });
  return checksumAddress(ne, oe);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/, isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(ne, oe) {
  const { strict: ae = !0 } = oe ?? {};
  if (isAddressCache.has(ne))
    return isAddressCache.get(ne);
  const fe = (() => addressRegex.test(ne) ? ne.toLowerCase() === ne ? !0 : ae ? checksumAddress(ne) === ne : !0 : !1)();
  return isAddressCache.set(ne, fe), fe;
}
function concat$1(ne) {
  return typeof ne[0] == "string" ? concatHex(ne) : concatBytes$1(ne);
}
function concatBytes$1(ne) {
  let oe = 0;
  for (const ye of ne)
    oe += ye.length;
  const ae = new Uint8Array(oe);
  let fe = 0;
  for (const ye of ne)
    ae.set(ye, fe), fe += ye.length;
  return ae;
}
function concatHex(ne) {
  return `0x${ne.reduce((oe, ae) => oe + ae.replace("0x", ""), "")}`;
}
function slice(ne, oe, ae, { strict: fe } = {}) {
  return isHex(ne, { strict: !1 }) ? sliceHex(ne, oe, ae, {
    strict: fe
  }) : sliceBytes(ne, oe, ae, {
    strict: fe
  });
}
function assertStartOffset(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > size$1(ne) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: oe,
      position: "start",
      size: size$1(ne)
    });
}
function assertEndOffset(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && size$1(ne) !== ae - oe)
    throw new SliceOffsetOutOfBoundsError({
      offset: ae,
      position: "end",
      size: size$1(ne)
    });
}
function sliceBytes(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = ne.slice(oe, ae);
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function sliceHex(ne, oe, ae, { strict: fe } = {}) {
  assertStartOffset(ne, oe);
  const ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && assertEndOffset(ye, oe, ae), ye;
}
function encodeAbiParameters(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = prepareParams({
    params: ne,
    values: oe
  }), fe = encodeParams(ae);
  return fe.length === 0 ? "0x" : fe;
}
function prepareParams({ params: ne, values: oe }) {
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++)
    ae.push(prepareParam({ param: ne[fe], value: oe[fe] }));
  return ae;
}
function prepareParam({ param: ne, value: oe }) {
  const ae = getArrayComponents(ne.type);
  if (ae) {
    const [fe, ye] = ae;
    return encodeArray(oe, { length: fe, param: { ...ne, type: ye } });
  }
  if (ne.type === "tuple")
    return encodeTuple(oe, {
      param: ne
    });
  if (ne.type === "address")
    return encodeAddress(oe);
  if (ne.type === "bool")
    return encodeBool(oe);
  if (ne.type.startsWith("uint") || ne.type.startsWith("int")) {
    const fe = ne.type.startsWith("int");
    return encodeNumber(oe, { signed: fe });
  }
  if (ne.type.startsWith("bytes"))
    return encodeBytes(oe, { param: ne });
  if (ne.type === "string")
    return encodeString(oe);
  throw new InvalidAbiEncodingTypeError(ne.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(ne) {
  let oe = 0;
  for (let ge = 0; ge < ne.length; ge++) {
    const { dynamic: we, encoded: _e } = ne[ge];
    we ? oe += 32 : oe += size$1(_e);
  }
  const ae = [], fe = [];
  let ye = 0;
  for (let ge = 0; ge < ne.length; ge++) {
    const { dynamic: we, encoded: _e } = ne[ge];
    we ? (ae.push(numberToHex(oe + ye, { size: 32 })), fe.push(_e), ye += size$1(_e)) : ae.push(_e);
  }
  return concat$1([...ae, ...fe]);
}
function encodeAddress(ne) {
  if (!isAddress(ne))
    throw new InvalidAddressError({ address: ne });
  return { dynamic: !1, encoded: padHex(ne.toLowerCase()) };
}
function encodeArray(ne, { length: oe, param: ae }) {
  const fe = oe === null;
  if (!Array.isArray(ne))
    throw new InvalidArrayError(ne);
  if (!fe && ne.length !== oe)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: oe,
      givenLength: ne.length,
      type: `${ae.type}[${oe}]`
    });
  let ye = !1;
  const ge = [];
  for (let we = 0; we < ne.length; we++) {
    const _e = prepareParam({ param: ae, value: ne[we] });
    _e.dynamic && (ye = !0), ge.push(_e);
  }
  if (fe || ye) {
    const we = encodeParams(ge);
    if (fe) {
      const _e = numberToHex(ge.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: ge.length > 0 ? concat$1([_e, we]) : _e
      };
    }
    if (ye)
      return { dynamic: !0, encoded: we };
  }
  return {
    dynamic: !1,
    encoded: concat$1(ge.map(({ encoded: we }) => we))
  };
}
function encodeBytes(ne, { param: oe }) {
  const [, ae] = oe.type.split("bytes"), fe = size$1(ne);
  if (!ae) {
    let ye = ne;
    return fe % 32 !== 0 && (ye = padHex(ye, {
      dir: "right",
      size: Math.ceil((ne.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: concat$1([padHex(numberToHex(fe, { size: 32 })), ye])
    };
  }
  if (fe !== parseInt(ae))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(ae),
      value: ne
    });
  return { dynamic: !1, encoded: padHex(ne, { dir: "right" }) };
}
function encodeBool(ne) {
  if (typeof ne != "boolean")
    throw new BaseError(`Invalid boolean value: "${ne}" (type: ${typeof ne}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: padHex(boolToHex(ne)) };
}
function encodeNumber(ne, { signed: oe }) {
  return {
    dynamic: !1,
    encoded: numberToHex(ne, {
      size: 32,
      signed: oe
    })
  };
}
function encodeString(ne) {
  const oe = stringToHex(ne), ae = Math.ceil(size$1(oe) / 32), fe = [];
  for (let ye = 0; ye < ae; ye++)
    fe.push(padHex(slice(oe, ye * 32, (ye + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: concat$1([
      padHex(numberToHex(size$1(oe), { size: 32 })),
      ...fe
    ])
  };
}
function encodeTuple(ne, { param: oe }) {
  let ae = !1;
  const fe = [];
  for (let ye = 0; ye < oe.components.length; ye++) {
    const ge = oe.components[ye], we = Array.isArray(ne) ? ye : ge.name, _e = prepareParam({
      param: ge,
      value: ne[we]
    });
    fe.push(_e), _e.dynamic && (ae = !0);
  }
  return {
    dynamic: ae,
    encoded: ae ? encodeParams(fe) : concat$1(fe.map(({ encoded: ye }) => ye))
  };
}
function getArrayComponents(ne) {
  const oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? (
    // Return `null` if the array is dynamic.
    [oe[2] ? Number(oe[2]) : null, oe[1]]
  ) : void 0;
}
const toFunctionSelector = (ne) => slice(toSignatureHash(ne), 0, 4);
function getAbiItem(ne) {
  const { abi: oe, args: ae = [], name: fe } = ne, ye = isHex(fe, { strict: !1 }), ge = oe.filter((_e) => ye ? _e.type === "function" ? toFunctionSelector(_e) === fe : _e.type === "event" ? toEventSelector(_e) === fe : !1 : "name" in _e && _e.name === fe);
  if (ge.length === 0)
    return;
  if (ge.length === 1)
    return ge[0];
  let we;
  for (const _e of ge) {
    if (!("inputs" in _e))
      continue;
    if (!ae || ae.length === 0) {
      if (!_e.inputs || _e.inputs.length === 0)
        return _e;
      continue;
    }
    if (!_e.inputs || _e.inputs.length === 0 || _e.inputs.length !== ae.length)
      continue;
    if (ae.every((Ie, $e) => {
      const Ne = "inputs" in _e && _e.inputs[$e];
      return Ne ? isArgOfType(Ie, Ne) : !1;
    })) {
      if (we && "inputs" in we && we.inputs) {
        const Ie = getAmbiguousTypes(_e.inputs, we.inputs, ae);
        if (Ie)
          throw new AbiItemAmbiguityError({
            abiItem: _e,
            type: Ie[0]
          }, {
            abiItem: we,
            type: Ie[1]
          });
      }
      we = _e;
    }
  }
  return we || ge[0];
}
function isArgOfType(ne, oe) {
  const ae = typeof ne, fe = oe.type;
  switch (fe) {
    case "address":
      return isAddress(ne, { strict: !1 });
    case "bool":
      return ae === "boolean";
    case "function":
      return ae === "string";
    case "string":
      return ae === "string";
    default:
      return fe === "tuple" && "components" in oe ? Object.values(oe.components).every((ye, ge) => isArgOfType(Object.values(ne)[ge], ye)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(fe) ? ae === "number" || ae === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(fe) ? ae === "string" || ne instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(fe) ? Array.isArray(ne) && ne.every((ye) => isArgOfType(ye, {
        ...oe,
        // Pop off `[]` or `[M]` from end of type
        type: fe.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function getAmbiguousTypes(ne, oe, ae) {
  for (const fe in ne) {
    const ye = ne[fe], ge = oe[fe];
    if (ye.type === "tuple" && ge.type === "tuple" && "components" in ye && "components" in ge)
      return getAmbiguousTypes(ye.components, ge.components, ae[fe]);
    const we = [ye.type, ge.type];
    if ((() => we.includes("address") && we.includes("bytes20") ? !0 : we.includes("address") && we.includes("string") ? isAddress(ae[fe], { strict: !1 }) : we.includes("address") && we.includes("bytes") ? isAddress(ae[fe], { strict: !1 }) : !1)())
      return we;
  }
}
const docsPath$4 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(ne) {
  var Se;
  const { abi: oe, eventName: ae, args: fe } = ne;
  let ye = oe[0];
  if (ae) {
    const Ie = getAbiItem({ abi: oe, name: ae });
    if (!Ie)
      throw new AbiEventNotFoundError(ae, { docsPath: docsPath$4 });
    ye = Ie;
  }
  if (ye.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$4 });
  const ge = formatAbiItem(ye), we = toEventSelector(ge);
  let _e = [];
  if (fe && "inputs" in ye) {
    const Ie = (Se = ye.inputs) == null ? void 0 : Se.filter((Ne) => "indexed" in Ne && Ne.indexed), $e = Array.isArray(fe) ? fe : Object.values(fe).length > 0 ? (Ie == null ? void 0 : Ie.map((Ne) => fe[Ne.name])) ?? [] : [];
    $e.length > 0 && (_e = (Ie == null ? void 0 : Ie.map((Ne, Me) => Array.isArray($e[Me]) ? $e[Me].map((Be, ze) => encodeArg({ param: Ne, value: $e[Me][ze] })) : $e[Me] ? encodeArg({ param: Ne, value: $e[Me] }) : null)) ?? []);
  }
  return [we, ..._e];
}
function encodeArg({ param: ne, value: oe }) {
  if (ne.type === "string" || ne.type === "bytes")
    return keccak256(toBytes$1(oe));
  if (ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(ne.type);
  return encodeAbiParameters([ne], [oe]);
}
function createFilterRequestScope(ne, { method: oe }) {
  var fe, ye;
  const ae = {};
  return ne.transport.type === "fallback" && ((ye = (fe = ne.transport).onResponse) == null || ye.call(fe, ({ method: ge, response: we, status: _e, transport: Se }) => {
    _e === "success" && oe === ge && (ae[we] = Se.request);
  })), (ge) => ae[ge] || ne.request;
}
async function createContractEventFilter(ne, oe) {
  const { address: ae, abi: fe, args: ye, eventName: ge, fromBlock: we, strict: _e, toBlock: Se } = oe, Ie = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  }), $e = ge ? encodeEventTopics({
    abi: fe,
    args: ye,
    eventName: ge
  }) : void 0, Ne = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: ae,
        fromBlock: typeof we == "bigint" ? numberToHex(we) : we,
        toBlock: typeof Se == "bigint" ? numberToHex(Se) : Se,
        topics: $e
      }
    ]
  });
  return {
    abi: fe,
    args: ye,
    eventName: ge,
    id: Ne,
    request: Ie(Ne),
    strict: !!_e,
    type: "event"
  };
}
function parseAccount(ne) {
  return typeof ne == "string" ? { address: ne, type: "json-rpc" } : ne;
}
const docsPath$3 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(ne) {
  const { abi: oe, args: ae, functionName: fe } = ne;
  let ye = oe[0];
  if (fe) {
    const ge = getAbiItem({
      abi: oe,
      args: ae,
      name: fe
    });
    if (!ge)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$3 });
    ye = ge;
  }
  if (ye.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  return {
    abi: [ye],
    functionName: toFunctionSelector(formatAbiItem(ye))
  };
}
function encodeFunctionData(ne) {
  const { args: oe } = ne, { abi: ae, functionName: fe } = (() => {
    var _e;
    return ne.abi.length === 1 && ((_e = ne.functionName) != null && _e.startsWith("0x")) ? ne : prepareEncodeFunctionData(ne);
  })(), ye = ae[0], ge = fe, we = "inputs" in ye && ye.inputs ? encodeAbiParameters(ye.inputs, oe ?? []) : void 0;
  return concatHex([ge, we ?? "0x"]);
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class NegativeOffsetError extends BaseError {
  constructor({ offset: oe }) {
    super(`Offset \`${oe}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError {
  constructor({ length: oe, position: ae }) {
    super(`Position \`${ae}\` is out of bounds (\`0 < position < ${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError {
  constructor({ count: oe, limit: ae }) {
    super(`Recursive read limit of \`${ae}\` exceeded (recursive read count: \`${oe}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: 1 / 0,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: ne
      });
  },
  decrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  },
  getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  },
  incrementPosition(ne) {
    if (ne < 0)
      throw new NegativeOffsetError({ offset: ne });
    const oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  },
  inspectByte(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectBytes(ne, oe) {
    const ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  },
  inspectUint8(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  },
  inspectUint16(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  },
  inspectUint24(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  },
  inspectUint32(ne) {
    const oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  },
  pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  },
  pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  },
  pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  },
  pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  },
  pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectByte();
    return this.position++, ne;
  },
  readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    const ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint8();
    return this.position += 1, ne;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint16();
    return this.position += 2, ne;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint24();
    return this.position += 3, ne;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const ne = this.inspectUint32();
    return this.position += 4, ne;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(ne) {
    const oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  },
  _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    const ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  }
};
function createCursor(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  const ae = Object.create(staticCursor);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
function bytesToBigInt(ne, oe = {}) {
  typeof oe.size < "u" && assertSize(ne, { size: oe.size });
  const ae = bytesToHex$1(ne, oe);
  return hexToBigInt(ae, oe);
}
function bytesToBool(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (assertSize(ae, { size: oe.size }), ae = trim(ae)), ae.length > 1 || ae[0] > 1)
    throw new InvalidBytesBooleanError(ae);
  return !!ae[0];
}
function bytesToNumber(ne, oe = {}) {
  typeof oe.size < "u" && assertSize(ne, { size: oe.size });
  const ae = bytesToHex$1(ne, oe);
  return hexToNumber$1(ae, oe);
}
function bytesToString(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (assertSize(ae, { size: oe.size }), ae = trim(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
function decodeAbiParameters(ne, oe) {
  const ae = typeof oe == "string" ? hexToBytes$1(oe) : oe, fe = createCursor(ae);
  if (size$1(ae) === 0 && ne.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$1(oe) && size$1(oe) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof oe == "string" ? oe : bytesToHex$1(oe),
      params: ne,
      size: size$1(oe)
    });
  let ye = 0;
  const ge = [];
  for (let we = 0; we < ne.length; ++we) {
    const _e = ne[we];
    fe.setPosition(ye);
    const [Se, Ie] = decodeParameter(fe, _e, {
      staticPosition: 0
    });
    ye += Ie, ge.push(Se);
  }
  return ge;
}
function decodeParameter(ne, oe, { staticPosition: ae }) {
  const fe = getArrayComponents(oe.type);
  if (fe) {
    const [ye, ge] = fe;
    return decodeArray(ne, { ...oe, type: ge }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return decodeTuple(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return decodeAddress(ne);
  if (oe.type === "bool")
    return decodeBool(ne);
  if (oe.type.startsWith("bytes"))
    return decodeBytes(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return decodeNumber(ne, oe);
  if (oe.type === "string")
    return decodeString(ne, { staticPosition: ae });
  throw new InvalidAbiDecodingTypeError(oe.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32, sizeOfOffset = 32;
function decodeAddress(ne) {
  const oe = ne.readBytes(32);
  return [checksumAddress(bytesToHex$1(sliceBytes(oe, -20))), 32];
}
function decodeArray(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    const we = bytesToNumber(ne.readBytes(sizeOfOffset)), _e = fe + we, Se = _e + sizeOfLength;
    ne.setPosition(_e);
    const Ie = bytesToNumber(ne.readBytes(sizeOfLength)), $e = hasDynamicChild(oe);
    let Ne = 0;
    const Me = [];
    for (let Be = 0; Be < Ie; ++Be) {
      ne.setPosition(Se + ($e ? Be * 32 : Ne));
      const [ze, He] = decodeParameter(ne, oe, {
        staticPosition: Se
      });
      Ne += He, Me.push(ze);
    }
    return ne.setPosition(fe + 32), [Me, 32];
  }
  if (hasDynamicChild(oe)) {
    const we = bytesToNumber(ne.readBytes(sizeOfOffset)), _e = fe + we, Se = [];
    for (let Ie = 0; Ie < ae; ++Ie) {
      ne.setPosition(_e + Ie * 32);
      const [$e] = decodeParameter(ne, oe, {
        staticPosition: _e
      });
      Se.push($e);
    }
    return ne.setPosition(fe + 32), [Se, 32];
  }
  let ye = 0;
  const ge = [];
  for (let we = 0; we < ae; ++we) {
    const [_e, Se] = decodeParameter(ne, oe, {
      staticPosition: fe + ye
    });
    ye += Se, ge.push(_e);
  }
  return [ge, ye];
}
function decodeBool(ne) {
  return [bytesToBool(ne.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(ne, oe, { staticPosition: ae }) {
  const [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    const we = bytesToNumber(ne.readBytes(32));
    ne.setPosition(ae + we);
    const _e = bytesToNumber(ne.readBytes(32));
    if (_e === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    const Se = ne.readBytes(_e);
    return ne.setPosition(ae + 32), [bytesToHex$1(Se), 32];
  }
  return [bytesToHex$1(ne.readBytes(parseInt(ye), 32)), 32];
}
function decodeNumber(ne, oe) {
  const ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [
    fe > 48 ? bytesToBigInt(ye, { signed: ae }) : bytesToNumber(ye, { signed: ae }),
    32
  ];
}
function decodeTuple(ne, oe, { staticPosition: ae }) {
  const fe = oe.components.length === 0 || oe.components.some(({ name: we }) => !we), ye = fe ? [] : {};
  let ge = 0;
  if (hasDynamicChild(oe)) {
    const we = bytesToNumber(ne.readBytes(sizeOfOffset)), _e = ae + we;
    for (let Se = 0; Se < oe.components.length; ++Se) {
      const Ie = oe.components[Se];
      ne.setPosition(_e + ge);
      const [$e, Ne] = decodeParameter(ne, Ie, {
        staticPosition: _e
      });
      ge += Ne, ye[fe ? Se : Ie == null ? void 0 : Ie.name] = $e;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let we = 0; we < oe.components.length; ++we) {
    const _e = oe.components[we], [Se, Ie] = decodeParameter(ne, _e, {
      staticPosition: ae
    });
    ye[fe ? we : _e == null ? void 0 : _e.name] = Se, ge += Ie;
  }
  return [ye, ge];
}
function decodeString(ne, { staticPosition: oe }) {
  const ae = bytesToNumber(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  const ye = bytesToNumber(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  const ge = ne.readBytes(ye, 32), we = bytesToString(trim(ge));
  return ne.setPosition(oe + 32), [we, 32];
}
function hasDynamicChild(ne) {
  var fe;
  const { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(hasDynamicChild);
  const ae = getArrayComponents(ne.type);
  return !!(ae && hasDynamicChild({ ...ne, type: ae[1] }));
}
function decodeErrorResult(ne) {
  const { abi: oe, data: ae } = ne, fe = slice(ae, 0, 4);
  if (fe === "0x")
    throw new AbiDecodingZeroDataError();
  const ge = [...oe || [], solidityError, solidityPanic].find((we) => we.type === "error" && fe === toFunctionSelector(formatAbiItem(we)));
  if (!ge)
    throw new AbiErrorSignatureNotFoundError(fe, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: ge,
    args: "inputs" in ge && ge.inputs && ge.inputs.length > 0 ? decodeAbiParameters(ge.inputs, slice(ae, 4)) : void 0,
    errorName: ge.name
  };
}
const stringify = (ne, oe, ae) => JSON.stringify(ne, (fe, ye) => {
  const ge = typeof ye == "bigint" ? ye.toString() : ye;
  return typeof oe == "function" ? oe(fe, ge) : ge;
}, ae);
function formatAbiItemWithArgs({ abiItem: ne, args: oe, includeFunctionName: ae = !0, includeName: fe = !1 }) {
  if ("name" in ne && "inputs" in ne && ne.inputs)
    return `${ae ? ne.name : ""}(${ne.inputs.map((ye, ge) => `${fe && ye.name ? `${ye.name}: ` : ""}${typeof oe[ge] == "object" ? stringify(oe[ge]) : oe[ge]}`).join(", ")})`;
}
const etherUnits = {
  gwei: 9,
  wei: 18
}, gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits(ne, oe) {
  let ae = ne.toString();
  const fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, ge] = [
    ae.slice(0, ae.length - oe),
    ae.slice(ae.length - oe)
  ];
  return ge = ge.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${ge ? `.${ge}` : ""}`;
}
function formatEther(ne, oe = "wei") {
  return formatUnits(ne, etherUnits[oe]);
}
function formatGwei(ne, oe = "wei") {
  return formatUnits(ne, gweiUnits[oe]);
}
class AccountStateConflictError extends BaseError {
  constructor({ address: oe }) {
    super(`State for account "${oe}" is set multiple times.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError {
  constructor() {
    super("state and stateDiff are set on the same account."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(ne) {
  return ne.reduce((oe, { slot: ae, value: fe }) => `${oe}        ${ae}: ${fe}
`, "");
}
function prettyStateOverride(ne) {
  return ne.reduce((oe, { address: ae, ...fe }) => {
    let ye = `${oe}    ${ae}:
`;
    return fe.nonce && (ye += `      nonce: ${fe.nonce}
`), fe.balance && (ye += `      balance: ${fe.balance}
`), fe.code && (ye += `      code: ${fe.code}
`), fe.state && (ye += `      state:
`, ye += prettyStateMapping(fe.state)), fe.stateDiff && (ye += `      stateDiff:
`, ye += prettyStateMapping(fe.stateDiff)), ye;
  }, `  State Override:
`).slice(0, -1);
}
function prettyPrint(ne) {
  const oe = Object.entries(ne).map(([fe, ye]) => ye === void 0 || ye === !1 ? null : [fe, ye]).filter(Boolean), ae = oe.reduce((fe, [ye]) => Math.max(fe, ye.length), 0);
  return oe.map(([fe, ye]) => `  ${`${fe}:`.padEnd(ae + 1)}  ${ye}`).join(`
`);
}
class FeeConflictError extends BaseError {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeConflictError"
    });
  }
}
class InvalidLegacyVError extends BaseError {
  constructor({ v: oe }) {
    super(`Invalid \`v\` value "${oe}". Expected 27 or 28.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidLegacyVError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError {
  constructor({ transaction: oe }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(oe),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class InvalidStorageKeySizeError extends BaseError {
  constructor({ storageKey: oe }) {
    super(`Size for storage key "${oe}" is invalid. Expected 32 bytes. Got ${Math.floor((oe.length - 2) / 2)} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStorageKeySizeError"
    });
  }
}
class TransactionExecutionError extends BaseError {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ge, gas: we, gasPrice: _e, maxFeePerGas: Se, maxPriorityFeePerGas: Ie, nonce: $e, to: Ne, value: Me }) {
    var ze;
    const Be = prettyPrint({
      chain: ye && `${ye == null ? void 0 : ye.name} (id: ${ye == null ? void 0 : ye.id})`,
      from: ae == null ? void 0 : ae.address,
      to: Ne,
      value: typeof Me < "u" && `${formatEther(Me)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: ge,
      gas: we,
      gasPrice: typeof _e < "u" && `${formatGwei(_e)} gwei`,
      maxFeePerGas: typeof Se < "u" && `${formatGwei(Se)} gwei`,
      maxPriorityFeePerGas: typeof Ie < "u" && `${formatGwei(Ie)} gwei`,
      nonce: $e
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Request Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionExecutionError"
    }), this.cause = oe;
  }
}
class TransactionNotFoundError extends BaseError {
  constructor({ blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: ge }) {
    let we = "Transaction";
    fe && ge !== void 0 && (we = `Transaction at block time "${fe}" at index "${ge}"`), oe && ge !== void 0 && (we = `Transaction at block hash "${oe}" at index "${ge}"`), ae && ge !== void 0 && (we = `Transaction at block number "${ae}" at index "${ge}"`), ye && (we = `Transaction with hash "${ye}"`), super(`${we} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError {
  constructor({ hash: oe }) {
    super(`Transaction receipt with hash "${oe}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError {
  constructor({ hash: oe }) {
    super(`Timed out while waiting for transaction with hash "${oe}" to be confirmed.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
class CallExecutionError extends BaseError {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ge, gas: we, gasPrice: _e, maxFeePerGas: Se, maxPriorityFeePerGas: Ie, nonce: $e, to: Ne, value: Me, stateOverride: Be }) {
    var Ze;
    const ze = ae ? parseAccount(ae) : void 0;
    let He = prettyPrint({
      from: ze == null ? void 0 : ze.address,
      to: Ne,
      value: typeof Me < "u" && `${formatEther(Me)} ${((Ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : Ze.symbol) || "ETH"}`,
      data: ge,
      gas: we,
      gasPrice: typeof _e < "u" && `${formatGwei(_e)} gwei`,
      maxFeePerGas: typeof Se < "u" && `${formatGwei(Se)} gwei`,
      maxPriorityFeePerGas: typeof Ie < "u" && `${formatGwei(Ie)} gwei`,
      nonce: $e
    });
    Be && (He += `
${prettyStateOverride(Be)}`), super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Raw Call Arguments:",
        He
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CallExecutionError"
    }), this.cause = oe;
  }
}
class ContractFunctionExecutionError extends BaseError {
  constructor(oe, { abi: ae, args: fe, contractAddress: ye, docsPath: ge, functionName: we, sender: _e }) {
    const Se = getAbiItem({ abi: ae, args: fe, name: we }), Ie = Se ? formatAbiItemWithArgs({
      abiItem: Se,
      args: fe,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, $e = Se ? formatAbiItem(Se, { includeName: !0 }) : void 0, Ne = prettyPrint({
      address: ye && getContractAddress(ye),
      function: $e,
      args: Ie && Ie !== "()" && `${[...Array((we == null ? void 0 : we.length) ?? 0).keys()].map(() => " ").join("")}${Ie}`,
      sender: _e
    });
    super(oe.shortMessage || `An unknown error occurred while executing the contract function "${we}".`, {
      cause: oe,
      docsPath: ge,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Contract Call:",
        Ne
      ].filter(Boolean)
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionExecutionError"
    }), this.abi = ae, this.args = fe, this.cause = oe, this.contractAddress = ye, this.functionName = we, this.sender = _e;
  }
}
class ContractFunctionRevertedError extends BaseError {
  constructor({ abi: oe, data: ae, functionName: fe, message: ye }) {
    let ge, we, _e, Se;
    if (ae && ae !== "0x")
      try {
        we = decodeErrorResult({ abi: oe, data: ae });
        const { abiItem: $e, errorName: Ne, args: Me } = we;
        if (Ne === "Error")
          Se = Me[0];
        else if (Ne === "Panic") {
          const [Be] = Me;
          Se = panicReasons[Be];
        } else {
          const Be = $e ? formatAbiItem($e, { includeName: !0 }) : void 0, ze = $e && Me ? formatAbiItemWithArgs({
            abiItem: $e,
            args: Me,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          _e = [
            Be ? `Error: ${Be}` : "",
            ze && ze !== "()" ? `       ${[...Array((Ne == null ? void 0 : Ne.length) ?? 0).keys()].map(() => " ").join("")}${ze}` : ""
          ];
        }
      } catch ($e) {
        ge = $e;
      }
    else
      ye && (Se = ye);
    let Ie;
    ge instanceof AbiErrorSignatureNotFoundError && (Ie = ge.signature, _e = [
      `Unable to decode signature "${Ie}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${Ie}.`
    ]), super(Se && Se !== "execution reverted" || Ie ? [
      `The contract function "${fe}" reverted with the following ${Ie ? "signature" : "reason"}:`,
      Se || Ie
    ].join(`
`) : `The contract function "${fe}" reverted.`, {
      cause: ge,
      metaMessages: _e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = we, this.reason = Se, this.signature = Ie;
  }
}
class ContractFunctionZeroDataError extends BaseError {
  constructor({ functionName: oe }) {
    super(`The contract function "${oe}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${oe}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class RawContractError extends BaseError {
  constructor({ data: oe, message: ae }) {
    super(ae || ""), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RawContractError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe;
  }
}
class HttpRequestError extends BaseError {
  constructor({ body: oe, details: ae, headers: fe, status: ye, url: ge }) {
    super("HTTP request failed.", {
      details: ae,
      metaMessages: [
        ye && `Status: ${ye}`,
        `URL: ${getUrl$1(ge)}`,
        oe && `Request body: ${stringify(oe)}`
      ].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = oe, this.headers = fe, this.status = ye, this.url = ge;
  }
}
class WebSocketRequestError extends BaseError {
  constructor({ body: oe, details: ae, url: fe }) {
    super("WebSocket request failed.", {
      details: ae,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WebSocketRequestError"
    });
  }
}
class RpcRequestError extends BaseError {
  constructor({ body: oe, error: ae, url: fe }) {
    super("RPC Request failed.", {
      cause: ae,
      details: ae.message,
      metaMessages: [`URL: ${getUrl$1(fe)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = ae.code;
  }
}
let TimeoutError$1 = class extends BaseError {
  constructor({ body: oe, url: ae }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl$1(ae)}`, `Request body: ${stringify(oe)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TimeoutError"
    });
  }
};
const unknownErrorCode = -1;
class RpcError extends BaseError {
  constructor(oe, { code: ae, docsPath: fe, metaMessages: ye, shortMessage: ge }) {
    super(ge, {
      cause: oe,
      docsPath: fe,
      metaMessages: ye || (oe == null ? void 0 : oe.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = oe.name, this.code = oe instanceof RpcRequestError ? oe.code : ae ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(oe, ae) {
    super(oe, ae), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = ae.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(oe) {
    super(oe, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(oe) {
    super(oe, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(oe) {
    super(oe, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    });
  }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(ne, { abi: oe, address: ae, args: fe, docsPath: ye, functionName: ge, sender: we }) {
  const { code: _e, data: Se, message: Ie, shortMessage: $e } = ne instanceof RawContractError ? ne : ne instanceof BaseError ? ne.walk((Me) => "data" in Me) || ne.walk() : {}, Ne = (() => ne instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({ functionName: ge }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(_e) && (Se || Ie || $e) ? new ContractFunctionRevertedError({
    abi: oe,
    data: typeof Se == "object" ? Se.data : Se,
    functionName: ge,
    message: $e ?? Ie
  }) : ne)();
  return new ContractFunctionExecutionError(Ne, {
    abi: oe,
    args: fe,
    contractAddress: ae,
    docsPath: ye,
    functionName: ge,
    sender: we
  });
}
class EstimateGasExecutionError extends BaseError {
  constructor(oe, { account: ae, docsPath: fe, chain: ye, data: ge, gas: we, gasPrice: _e, maxFeePerGas: Se, maxPriorityFeePerGas: Ie, nonce: $e, to: Ne, value: Me }) {
    var ze;
    const Be = prettyPrint({
      from: ae == null ? void 0 : ae.address,
      to: Ne,
      value: typeof Me < "u" && `${formatEther(Me)} ${((ze = ye == null ? void 0 : ye.nativeCurrency) == null ? void 0 : ze.symbol) || "ETH"}`,
      data: ge,
      gas: we,
      gasPrice: typeof _e < "u" && `${formatGwei(_e)} gwei`,
      maxFeePerGas: typeof Se < "u" && `${formatGwei(Se)} gwei`,
      maxPriorityFeePerGas: typeof Ie < "u" && `${formatGwei(Ie)} gwei`,
      nonce: $e
    });
    super(oe.shortMessage, {
      cause: oe,
      docsPath: fe,
      metaMessages: [
        ...oe.metaMessages ? [...oe.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        Be
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EstimateGasExecutionError"
    }), this.cause = oe;
  }
}
class ExecutionRevertedError extends BaseError {
  constructor({ cause: oe, message: ae } = {}) {
    var ye;
    const fe = (ye = ae == null ? void 0 : ae.replace("execution reverted: ", "")) == null ? void 0 : ye.replace("execution reverted", "");
    super(`Execution reverted ${fe ? `with reason: ${fe}` : "for an unknown reason"}.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError {
  constructor({ cause: oe, maxFeePerGas: ae } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ae ? ` = ${formatGwei(ae)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is higher than the next one expected.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError {
  constructor({ cause: oe, nonce: ae } = {}) {
    super([
      `Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError {
  constructor({ cause: oe, nonce: ae } = {}) {
    super(`Nonce provided for the transaction ${ae ? `(${ae}) ` : ""}exceeds the maximum allowed nonce.`, { cause: oe }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError {
  constructor({ cause: oe } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: oe,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError {
  constructor({ cause: oe, gas: ae } = {}) {
    super(`The amount of gas ${ae ? `(${ae}) ` : ""}provided for the transaction is too low.`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError {
  constructor({ cause: oe }) {
    super("The transaction type is not supported for this chain.", {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError {
  constructor({ cause: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${ae ? ` = ${formatGwei(ae)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${fe ? ` = ${formatGwei(fe)} gwei` : ""}).`
    ].join(`
`), {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError {
  constructor({ cause: oe }) {
    super(`An error occurred while executing: ${oe == null ? void 0 : oe.shortMessage}`, {
      cause: oe
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownNodeError"
    });
  }
}
function getNodeError(ne, oe) {
  const ae = (ne.details || "").toLowerCase(), fe = ne instanceof BaseError ? ne.walk((ye) => ye.code === ExecutionRevertedError.code) : ne;
  return fe instanceof BaseError ? new ExecutionRevertedError({
    cause: ne,
    message: fe.details
  }) : ExecutionRevertedError.nodeMessage.test(ae) ? new ExecutionRevertedError({
    cause: ne,
    message: ne.details
  }) : FeeCapTooHighError.nodeMessage.test(ae) ? new FeeCapTooHighError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : FeeCapTooLowError.nodeMessage.test(ae) ? new FeeCapTooLowError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas
  }) : NonceTooHighError.nodeMessage.test(ae) ? new NonceTooHighError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceTooLowError.nodeMessage.test(ae) ? new NonceTooLowError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : NonceMaxValueError.nodeMessage.test(ae) ? new NonceMaxValueError({ cause: ne, nonce: oe == null ? void 0 : oe.nonce }) : InsufficientFundsError.nodeMessage.test(ae) ? new InsufficientFundsError({ cause: ne }) : IntrinsicGasTooHighError.nodeMessage.test(ae) ? new IntrinsicGasTooHighError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : IntrinsicGasTooLowError.nodeMessage.test(ae) ? new IntrinsicGasTooLowError({ cause: ne, gas: oe == null ? void 0 : oe.gas }) : TransactionTypeNotSupportedError.nodeMessage.test(ae) ? new TransactionTypeNotSupportedError({ cause: ne }) : TipAboveFeeCapError.nodeMessage.test(ae) ? new TipAboveFeeCapError({
    cause: ne,
    maxFeePerGas: oe == null ? void 0 : oe.maxFeePerGas,
    maxPriorityFeePerGas: oe == null ? void 0 : oe.maxPriorityFeePerGas
  }) : new UnknownNodeError({
    cause: ne
  });
}
function getEstimateGasError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new EstimateGasExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
function extract(ne, { format: oe }) {
  if (!oe)
    return {};
  const ae = {};
  function fe(ge) {
    const we = Object.keys(ge);
    for (const _e of we)
      _e in ne && (ae[_e] = ne[_e]), ge[_e] && typeof ge[_e] == "object" && !Array.isArray(ge[_e]) && fe(ge[_e]);
  }
  const ye = oe(ne || {});
  return fe(ye), ae;
}
function defineFormatter(ne, oe) {
  return ({ exclude: ae, format: fe }) => ({
    exclude: ae,
    format: (ye) => {
      const ge = oe(ye);
      if (ae)
        for (const we of ae)
          delete ge[we];
      return {
        ...ge,
        ...fe(ye)
      };
    },
    type: ne
  });
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3"
};
function formatTransactionRequest(ne) {
  const oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => bytesToHex$1(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = numberToHex(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = numberToHex(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = numberToHex(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = numberToHex(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = numberToHex(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = numberToHex(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = rpcTransactionType[ne.type]), typeof ne.value < "u" && (oe.value = numberToHex(ne.value)), oe;
}
function assertRequest(ne) {
  const { account: oe, gasPrice: ae, maxFeePerGas: fe, maxPriorityFeePerGas: ye, to: ge } = ne, we = oe ? parseAccount(oe) : void 0;
  if (we && !isAddress(we.address))
    throw new InvalidAddressError({ address: we.address });
  if (ge && !isAddress(ge))
    throw new InvalidAddressError({ address: ge });
  if (typeof ae < "u" && (typeof fe < "u" || typeof ye < "u"))
    throw new FeeConflictError();
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ye && fe && ye > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ye });
}
class BaseFeeScalarError extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas: oe }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(oe)} gwei).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class BlockNotFoundError extends BaseError {
  constructor({ blockHash: oe, blockNumber: ae }) {
    let fe = "Block";
    oe && (fe = `Block at hash "${oe}"`), ae && (fe = `Block at number "${ae}"`), super(`${fe} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlockNotFoundError"
    });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(ne) {
  const oe = {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    chainId: ne.chainId ? hexToNumber$1(ne.chainId) : void 0,
    gas: ne.gas ? BigInt(ne.gas) : void 0,
    gasPrice: ne.gasPrice ? BigInt(ne.gasPrice) : void 0,
    maxFeePerBlobGas: ne.maxFeePerBlobGas ? BigInt(ne.maxFeePerBlobGas) : void 0,
    maxFeePerGas: ne.maxFeePerGas ? BigInt(ne.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: ne.maxPriorityFeePerGas ? BigInt(ne.maxPriorityFeePerGas) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    type: ne.type ? transactionType[ne.type] : void 0,
    typeHex: ne.type ? ne.type : void 0,
    value: ne.value ? BigInt(ne.value) : void 0,
    v: ne.v ? BigInt(ne.v) : void 0
  };
  return oe.yParity = (() => {
    if (ne.yParity)
      return Number(ne.yParity);
    if (typeof oe.v == "bigint") {
      if (oe.v === 0n || oe.v === 27n)
        return 0;
      if (oe.v === 1n || oe.v === 28n)
        return 1;
      if (oe.v >= 35n)
        return oe.v % 2n === 0n ? 1 : 0;
    }
  })(), oe.type === "legacy" && (delete oe.accessList, delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas, delete oe.yParity), oe.type === "eip2930" && (delete oe.maxFeePerBlobGas, delete oe.maxFeePerGas, delete oe.maxPriorityFeePerGas), oe.type === "eip1559" && delete oe.maxFeePerBlobGas, oe;
}
const defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatBlock(ne) {
  var ae;
  const oe = (ae = ne.transactions) == null ? void 0 : ae.map((fe) => typeof fe == "string" ? fe : formatTransaction(fe));
  return {
    ...ne,
    baseFeePerGas: ne.baseFeePerGas ? BigInt(ne.baseFeePerGas) : null,
    blobGasUsed: ne.blobGasUsed ? BigInt(ne.blobGasUsed) : void 0,
    difficulty: ne.difficulty ? BigInt(ne.difficulty) : void 0,
    excessBlobGas: ne.excessBlobGas ? BigInt(ne.excessBlobGas) : void 0,
    gasLimit: ne.gasLimit ? BigInt(ne.gasLimit) : void 0,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : void 0,
    hash: ne.hash ? ne.hash : null,
    logsBloom: ne.logsBloom ? ne.logsBloom : null,
    nonce: ne.nonce ? ne.nonce : null,
    number: ne.number ? BigInt(ne.number) : null,
    size: ne.size ? BigInt(ne.size) : void 0,
    timestamp: ne.timestamp ? BigInt(ne.timestamp) : void 0,
    transactions: oe,
    totalDifficulty: ne.totalDifficulty ? BigInt(ne.totalDifficulty) : null
  };
}
const defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);
async function getBlock(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, includeTransactions: ye } = {}) {
  var $e, Ne, Me;
  const ge = fe ?? "latest", we = ye ?? !1, _e = ae !== void 0 ? numberToHex(ae) : void 0;
  let Se = null;
  if (oe ? Se = await ne.request({
    method: "eth_getBlockByHash",
    params: [oe, we]
  }) : Se = await ne.request({
    method: "eth_getBlockByNumber",
    params: [_e || ge, we]
  }), !Se)
    throw new BlockNotFoundError({ blockHash: oe, blockNumber: ae });
  return (((Me = (Ne = ($e = ne.chain) == null ? void 0 : $e.formatters) == null ? void 0 : Ne.block) == null ? void 0 : Me.format) || formatBlock)(Se);
}
async function getGasPrice(ne) {
  const oe = await ne.request({
    method: "eth_gasPrice"
  });
  return BigInt(oe);
}
async function estimateMaxPriorityFeePerGas(ne, oe) {
  return internal_estimateMaxPriorityFeePerGas(ne, oe);
}
async function internal_estimateMaxPriorityFeePerGas(ne, oe) {
  var ge, we, _e;
  const { block: ae, chain: fe = ne.chain, request: ye } = oe || {};
  if (typeof ((ge = fe == null ? void 0 : fe.fees) == null ? void 0 : ge.defaultPriorityFee) == "function") {
    const Se = ae || await getAction(ne, getBlock, "getBlock")({});
    return fe.fees.defaultPriorityFee({
      block: Se,
      client: ne,
      request: ye
    });
  }
  if (typeof ((we = fe == null ? void 0 : fe.fees) == null ? void 0 : we.defaultPriorityFee) < "u")
    return (_e = fe == null ? void 0 : fe.fees) == null ? void 0 : _e.defaultPriorityFee;
  try {
    const Se = await ne.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(Se);
  } catch {
    const [Se, Ie] = await Promise.all([
      ae ? Promise.resolve(ae) : getAction(ne, getBlock, "getBlock")({}),
      getAction(ne, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof Se.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const $e = Ie - Se.baseFeePerGas;
    return $e < 0n ? 0n : $e;
  }
}
async function estimateFeesPerGas(ne, oe) {
  return internal_estimateFeesPerGas(ne, oe);
}
async function internal_estimateFeesPerGas(ne, oe) {
  var Me, Be;
  const { block: ae, chain: fe = ne.chain, request: ye, type: ge = "eip1559" } = oe || {}, we = await (async () => {
    var ze, He;
    return typeof ((ze = fe == null ? void 0 : fe.fees) == null ? void 0 : ze.baseFeeMultiplier) == "function" ? fe.fees.baseFeeMultiplier({
      block: ae,
      client: ne,
      request: ye
    }) : ((He = fe == null ? void 0 : fe.fees) == null ? void 0 : He.baseFeeMultiplier) ?? 1.2;
  })();
  if (we < 1)
    throw new BaseFeeScalarError();
  const Se = 10 ** (((Me = we.toString().split(".")[1]) == null ? void 0 : Me.length) ?? 0), Ie = (ze) => ze * BigInt(Math.ceil(we * Se)) / BigInt(Se), $e = ae || await getAction(ne, getBlock, "getBlock")({});
  if (typeof ((Be = fe == null ? void 0 : fe.fees) == null ? void 0 : Be.estimateFeesPerGas) == "function") {
    const ze = await fe.fees.estimateFeesPerGas({
      block: ae,
      client: ne,
      multiply: Ie,
      request: ye,
      type: ge
    });
    if (ze !== null)
      return ze;
  }
  if (ge === "eip1559") {
    if (typeof $e.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const ze = typeof (ye == null ? void 0 : ye.maxPriorityFeePerGas) == "bigint" ? ye.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(ne, {
      block: $e,
      chain: fe,
      request: ye
    }), He = Ie($e.baseFeePerGas);
    return {
      maxFeePerGas: (ye == null ? void 0 : ye.maxFeePerGas) ?? He + ze,
      maxPriorityFeePerGas: ze
    };
  }
  return {
    gasPrice: (ye == null ? void 0 : ye.gasPrice) ?? Ie(await getAction(ne, getGasPrice, "getGasPrice")({}))
  };
}
async function getTransactionCount(ne, { address: oe, blockTag: ae = "latest", blockNumber: fe }) {
  const ye = await ne.request({
    method: "eth_getTransactionCount",
    params: [oe, fe ? numberToHex(fe) : ae]
  });
  return hexToNumber$1(ye);
}
class AccountNotFoundError extends BaseError {
  constructor({ docsPath: oe } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join(`
`), {
      docsPath: oe,
      docsSlug: "account"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountNotFoundError"
    });
  }
}
function blobsToCommitments(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((ge) => hexToBytes$1(ge)) : ne.blobs, ye = [];
  for (const ge of fe)
    ye.push(Uint8Array.from(oe.blobToKzgCommitment(ge)));
  return ae === "bytes" ? ye : ye.map((ge) => bytesToHex$1(ge));
}
function blobsToProofs(ne) {
  const { kzg: oe } = ne, ae = ne.to ?? (typeof ne.blobs[0] == "string" ? "hex" : "bytes"), fe = typeof ne.blobs[0] == "string" ? ne.blobs.map((we) => hexToBytes$1(we)) : ne.blobs, ye = typeof ne.commitments[0] == "string" ? ne.commitments.map((we) => hexToBytes$1(we)) : ne.commitments, ge = [];
  for (let we = 0; we < fe.length; we++) {
    const _e = fe[we], Se = ye[we];
    ge.push(Uint8Array.from(oe.computeBlobKzgProof(_e, Se)));
  }
  return ae === "bytes" ? ge : ge.map((we) => bytesToHex$1(we));
}
function setBigUint64(ne, oe, ae, fe) {
  if (typeof ne.setBigUint64 == "function")
    return ne.setBigUint64(oe, ae, fe);
  const ye = BigInt(32), ge = BigInt(4294967295), we = Number(ae >> ye & ge), _e = Number(ae & ge), Se = fe ? 4 : 0, Ie = fe ? 0 : 4;
  ne.setUint32(oe + Se, we, fe), ne.setUint32(oe + Ie, _e, fe);
}
class SHA2 extends Hash {
  constructor(oe, ae, fe, ye) {
    super(), this.blockLen = oe, this.outputLen = ae, this.padOffset = fe, this.isLE = ye, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(oe), this.view = createView(this.buffer);
  }
  update(oe) {
    exists(this);
    const { view: ae, buffer: fe, blockLen: ye } = this;
    oe = toBytes(oe);
    const ge = oe.length;
    for (let we = 0; we < ge; ) {
      const _e = Math.min(ye - this.pos, ge - we);
      if (_e === ye) {
        const Se = createView(oe);
        for (; ye <= ge - we; we += ye)
          this.process(Se, we);
        continue;
      }
      fe.set(oe.subarray(we, we + _e), this.pos), this.pos += _e, we += _e, this.pos === ye && (this.process(ae, 0), this.pos = 0);
    }
    return this.length += oe.length, this.roundClean(), this;
  }
  digestInto(oe) {
    exists(this), output(oe, this), this.finished = !0;
    const { buffer: ae, view: fe, blockLen: ye, isLE: ge } = this;
    let { pos: we } = this;
    ae[we++] = 128, this.buffer.subarray(we).fill(0), this.padOffset > ye - we && (this.process(fe, 0), we = 0);
    for (let Ne = we; Ne < ye; Ne++)
      ae[Ne] = 0;
    setBigUint64(fe, ye - 8, BigInt(this.length * 8), ge), this.process(fe, 0);
    const _e = createView(oe), Se = this.outputLen;
    if (Se % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Ie = Se / 4, $e = this.get();
    if (Ie > $e.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ne = 0; Ne < Ie; Ne++)
      _e.setUint32(4 * Ne, $e[Ne], ge);
  }
  digest() {
    const { buffer: oe, outputLen: ae } = this;
    this.digestInto(oe);
    const fe = oe.slice(0, ae);
    return this.destroy(), fe;
  }
  _cloneInto(oe) {
    oe || (oe = new this.constructor()), oe.set(...this.get());
    const { blockLen: ae, buffer: fe, length: ye, finished: ge, destroyed: we, pos: _e } = this;
    return oe.length = ye, oe.pos = _e, oe.finished = ge, oe.destroyed = we, ye % ae && oe.buffer.set(fe), oe;
  }
}
const Chi = (ne, oe, ae) => ne & oe ^ ~ne & ae, Maj = (ne, oe, ae) => ne & oe ^ ne & ae ^ oe & ae, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: oe, B: ae, C: fe, D: ye, E: ge, F: we, G: _e, H: Se } = this;
    return [oe, ae, fe, ye, ge, we, _e, Se];
  }
  // prettier-ignore
  set(oe, ae, fe, ye, ge, we, _e, Se) {
    this.A = oe | 0, this.B = ae | 0, this.C = fe | 0, this.D = ye | 0, this.E = ge | 0, this.F = we | 0, this.G = _e | 0, this.H = Se | 0;
  }
  process(oe, ae) {
    for (let Ne = 0; Ne < 16; Ne++, ae += 4)
      SHA256_W[Ne] = oe.getUint32(ae, !1);
    for (let Ne = 16; Ne < 64; Ne++) {
      const Me = SHA256_W[Ne - 15], Be = SHA256_W[Ne - 2], ze = rotr(Me, 7) ^ rotr(Me, 18) ^ Me >>> 3, He = rotr(Be, 17) ^ rotr(Be, 19) ^ Be >>> 10;
      SHA256_W[Ne] = He + SHA256_W[Ne - 7] + ze + SHA256_W[Ne - 16] | 0;
    }
    let { A: fe, B: ye, C: ge, D: we, E: _e, F: Se, G: Ie, H: $e } = this;
    for (let Ne = 0; Ne < 64; Ne++) {
      const Me = rotr(_e, 6) ^ rotr(_e, 11) ^ rotr(_e, 25), Be = $e + Me + Chi(_e, Se, Ie) + SHA256_K[Ne] + SHA256_W[Ne] | 0, He = (rotr(fe, 2) ^ rotr(fe, 13) ^ rotr(fe, 22)) + Maj(fe, ye, ge) | 0;
      $e = Ie, Ie = Se, Se = _e, _e = we + Be | 0, we = ge, ge = ye, ye = fe, fe = Be + He | 0;
    }
    fe = fe + this.A | 0, ye = ye + this.B | 0, ge = ge + this.C | 0, we = we + this.D | 0, _e = _e + this.E | 0, Se = Se + this.F | 0, Ie = Ie + this.G | 0, $e = $e + this.H | 0, this.set(fe, ye, ge, we, _e, Se, Ie, $e);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
function sha256(ne, oe) {
  const ae = oe || "hex", fe = sha256$1(isHex(ne, { strict: !1 }) ? toBytes$1(ne) : ne);
  return ae === "bytes" ? fe : toHex(fe);
}
function commitmentToVersionedHash(ne) {
  const { commitment: oe, version: ae = 1 } = ne, fe = ne.to ?? (typeof oe == "string" ? "hex" : "bytes"), ye = sha256(oe, "bytes");
  return ye.set([ae], 0), fe === "bytes" ? ye : bytesToHex$1(ye);
}
function commitmentsToVersionedHashes(ne) {
  const { commitments: oe, version: ae } = ne, fe = ne.to ?? (typeof oe[0] == "string" ? "hex" : "bytes"), ye = [];
  for (const ge of oe)
    ye.push(commitmentToVersionedHash({
      commitment: ge,
      to: fe,
      version: ae
    }));
  return ye;
}
const blobsPerTransaction = 6, bytesPerFieldElement = 32, fieldElementsPerBlob = 4096, bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob, maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction, versionedHashVersionKzg = 1;
class BlobSizeTooLargeError extends BaseError {
  constructor({ maxSize: oe, size: ae }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${oe} bytes`, `Given: ${ae} bytes`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError {
  constructor() {
    super("Blob data must not be empty."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EmptyBlobError"
    });
  }
}
class InvalidVersionedHashSizeError extends BaseError {
  constructor({ hash: oe, size: ae }) {
    super(`Versioned hash "${oe}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${ae}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashSizeError"
    });
  }
}
class InvalidVersionedHashVersionError extends BaseError {
  constructor({ hash: oe, version: ae }) {
    super(`Versioned hash "${oe}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${ae}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidVersionedHashVersionError"
    });
  }
}
function toBlobs(ne) {
  const oe = ne.to ?? (typeof ne.data == "string" ? "hex" : "bytes"), ae = typeof ne.data == "string" ? hexToBytes$1(ne.data) : ne.data, fe = size$1(ae);
  if (!fe)
    throw new EmptyBlobError();
  if (fe > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: fe
    });
  const ye = [];
  let ge = !0, we = 0;
  for (; ge; ) {
    const _e = createCursor(new Uint8Array(bytesPerBlob));
    let Se = 0;
    for (; Se < fieldElementsPerBlob; ) {
      const Ie = ae.slice(we, we + (bytesPerFieldElement - 1));
      if (_e.pushByte(0), _e.pushBytes(Ie), Ie.length < 31) {
        _e.pushByte(128), ge = !1;
        break;
      }
      Se++, we += 31;
    }
    ye.push(_e);
  }
  return oe === "bytes" ? ye.map((_e) => _e.bytes) : ye.map((_e) => bytesToHex$1(_e.bytes));
}
function toBlobSidecars(ne) {
  const { data: oe, kzg: ae, to: fe } = ne, ye = ne.blobs ?? toBlobs({ data: oe, to: fe }), ge = ne.commitments ?? blobsToCommitments({ blobs: ye, kzg: ae, to: fe }), we = ne.proofs ?? blobsToProofs({ blobs: ye, commitments: ge, kzg: ae, to: fe }), _e = [];
  for (let Se = 0; Se < ye.length; Se++)
    _e.push({
      blob: ye[Se],
      commitment: ge[Se],
      proof: we[Se]
    });
  return _e;
}
function getTransactionType(ne) {
  if (ne.type)
    return ne.type;
  if (typeof ne.blobs < "u" || typeof ne.blobVersionedHashes < "u" || typeof ne.maxFeePerBlobGas < "u" || typeof ne.sidecars < "u")
    return "eip4844";
  if (typeof ne.maxFeePerGas < "u" || typeof ne.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof ne.gasPrice < "u")
    return typeof ne.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: ne });
}
async function getChainId(ne) {
  const oe = await ne.request({
    method: "eth_chainId"
  });
  return hexToNumber$1(oe);
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(ne, oe) {
  const { account: ae = ne.account, blobs: fe, chain: ye, chainId: ge, gas: we, kzg: _e, nonce: Se, parameters: Ie = defaultParameters, type: $e } = oe, Ne = ae ? parseAccount(ae) : void 0, Me = { ...oe, ...Ne ? { from: Ne == null ? void 0 : Ne.address } : {} };
  let Be;
  async function ze() {
    return Be || (Be = await getAction(ne, getBlock, "getBlock")({ blockTag: "latest" }), Be);
  }
  if ((Ie.includes("blobVersionedHashes") || Ie.includes("sidecars")) && fe && _e) {
    const He = blobsToCommitments({ blobs: fe, kzg: _e });
    if (Ie.includes("blobVersionedHashes")) {
      const Ze = commitmentsToVersionedHashes({
        commitments: He,
        to: "hex"
      });
      Me.blobVersionedHashes = Ze;
    }
    if (Ie.includes("sidecars")) {
      const Ze = blobsToProofs({ blobs: fe, commitments: He, kzg: _e }), qe = toBlobSidecars({
        blobs: fe,
        commitments: He,
        proofs: Ze,
        to: "hex"
      });
      Me.sidecars = qe;
    }
  }
  if (Ie.includes("chainId") && (ye ? Me.chainId = ye.id : typeof ge < "u" ? Me.chainId = ge : Me.chainId = await getAction(ne, getChainId, "getChainId")({})), Ie.includes("nonce") && typeof Se > "u" && Ne && (Me.nonce = await getAction(ne, getTransactionCount, "getTransactionCount")({
    address: Ne.address,
    blockTag: "pending"
  })), (Ie.includes("fees") || Ie.includes("type")) && typeof $e > "u")
    try {
      Me.type = getTransactionType(Me);
    } catch {
      const He = await ze();
      Me.type = typeof (He == null ? void 0 : He.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (Ie.includes("fees"))
    if (Me.type === "eip1559" || Me.type === "eip4844") {
      if (typeof Me.maxFeePerGas > "u" || typeof Me.maxPriorityFeePerGas > "u") {
        const He = await ze(), { maxFeePerGas: Ze, maxPriorityFeePerGas: qe } = await internal_estimateFeesPerGas(ne, {
          block: He,
          chain: ye,
          request: Me
        });
        if (typeof oe.maxPriorityFeePerGas > "u" && oe.maxFeePerGas && oe.maxFeePerGas < qe)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas: qe
          });
        Me.maxPriorityFeePerGas = qe, Me.maxFeePerGas = Ze;
      }
    } else {
      if (typeof oe.maxFeePerGas < "u" || typeof oe.maxPriorityFeePerGas < "u")
        throw new Eip1559FeesNotSupportedError();
      const He = await ze(), { gasPrice: Ze } = await internal_estimateFeesPerGas(ne, {
        block: He,
        chain: ye,
        request: Me,
        type: "legacy"
      });
      Me.gasPrice = Ze;
    }
  return Ie.includes("gas") && typeof we > "u" && (Me.gas = await getAction(ne, estimateGas, "estimateGas")({
    ...Me,
    account: Ne ? { address: Ne.address, type: "json-rpc" } : void 0
  })), assertRequest(Me), delete Me.parameters, Me;
}
async function estimateGas(ne, oe) {
  var ye, ge, we;
  const ae = oe.account ?? ne.account, fe = ae ? parseAccount(ae) : void 0;
  try {
    const { accessList: _e, blobs: Se, blobVersionedHashes: Ie, blockNumber: $e, blockTag: Ne, data: Me, gas: Be, gasPrice: ze, maxFeePerBlobGas: He, maxFeePerGas: Ze, maxPriorityFeePerGas: qe, nonce: tt, to: Xe, value: ot, ...pt } = await prepareTransactionRequest(ne, {
      ...oe,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (fe == null ? void 0 : fe.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), wt = ($e ? numberToHex($e) : void 0) || Ne;
    assertRequest(oe);
    const gt = (we = (ge = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : ge.transactionRequest) == null ? void 0 : we.format, Nt = (gt || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(pt, { format: gt }),
      from: fe == null ? void 0 : fe.address,
      accessList: _e,
      blobs: Se,
      blobVersionedHashes: Ie,
      data: Me,
      gas: Be,
      gasPrice: ze,
      maxFeePerBlobGas: He,
      maxFeePerGas: Ze,
      maxPriorityFeePerGas: qe,
      nonce: tt,
      to: Xe,
      value: ot
    }), Ft = await ne.request({
      method: "eth_estimateGas",
      params: wt ? [Nt, wt] : [Nt]
    });
    return BigInt(Ft);
  } catch (_e) {
    throw getEstimateGasError(_e, {
      ...oe,
      account: fe,
      chain: ne.chain
    });
  }
}
async function estimateContractGas(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: ge, ...we } = oe, _e = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: ge
  });
  try {
    return await getAction(ne, estimateGas, "estimateGas")({
      data: _e,
      to: fe,
      ...we
    });
  } catch (Se) {
    const Ie = we.account ? parseAccount(we.account) : void 0;
    throw getContractError(Se, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: ge,
      sender: Ie == null ? void 0 : Ie.address
    });
  }
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog(ne) {
  const { abi: oe, data: ae, strict: fe, topics: ye } = ne, ge = fe ?? !0, [we, ..._e] = ye;
  if (!we)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath$2 });
  const Se = oe.find((He) => He.type === "event" && we === toEventSelector(formatAbiItem(He)));
  if (!(Se && "name" in Se) || Se.type !== "event")
    throw new AbiEventSignatureNotFoundError(we, { docsPath: docsPath$2 });
  const { name: Ie, inputs: $e } = Se, Ne = $e == null ? void 0 : $e.some((He) => !("name" in He && He.name));
  let Me = Ne ? [] : {};
  const Be = $e.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    const Ze = Be[He], qe = _e[He];
    if (!qe)
      throw new DecodeLogTopicsMismatch({
        abiItem: Se,
        param: Ze
      });
    Me[Ne ? He : Ze.name || He] = decodeTopic({ param: Ze, value: qe });
  }
  const ze = $e.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        const He = decodeAbiParameters(ze, ae);
        if (He)
          if (Ne)
            Me = [...Me, ...He];
          else
            for (let Ze = 0; Ze < ze.length; Ze++)
              Me[ze[Ze].name] = He[Ze];
      } catch (He) {
        if (ge)
          throw He instanceof AbiDecodingDataSizeTooSmallError || He instanceof PositionOutOfBoundsError ? new DecodeLogDataMismatch({
            abiItem: Se,
            data: ae,
            params: ze,
            size: size$1(ae)
          }) : He;
      }
    else if (ge)
      throw new DecodeLogDataMismatch({
        abiItem: Se,
        data: "0x",
        params: ze,
        size: 0
      });
  }
  return {
    eventName: Ie,
    args: Object.values(Me).length > 0 ? Me : void 0
  };
}
function decodeTopic({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (decodeAbiParameters([ne], oe) || [])[0];
}
function parseEventLogs({ abi: ne, eventName: oe, logs: ae, strict: fe = !0 }) {
  return ae.map((ye) => {
    var ge;
    try {
      const we = decodeEventLog({
        ...ye,
        abi: ne,
        strict: fe
      });
      return oe && !oe.includes(we.eventName) ? null : { ...we, ...ye };
    } catch (we) {
      let _e, Se;
      if (we instanceof AbiEventSignatureNotFoundError)
        return null;
      if (we instanceof DecodeLogDataMismatch || we instanceof DecodeLogTopicsMismatch) {
        if (fe)
          return null;
        _e = we.abiItem.name, Se = (ge = we.abiItem.inputs) == null ? void 0 : ge.some((Ie) => !("name" in Ie && Ie.name));
      }
      return { ...ye, args: Se ? [] : {}, eventName: _e };
    }
  }).filter(Boolean);
}
function formatLog(ne, { args: oe, eventName: ae } = {}) {
  return {
    ...ne,
    blockHash: ne.blockHash ? ne.blockHash : null,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    logIndex: ne.logIndex ? Number(ne.logIndex) : null,
    transactionHash: ne.transactionHash ? ne.transactionHash : null,
    transactionIndex: ne.transactionIndex ? Number(ne.transactionIndex) : null,
    ...ae ? { args: oe, eventName: ae } : {}
  };
}
async function getLogs(ne, { address: oe, blockHash: ae, fromBlock: fe, toBlock: ye, event: ge, events: we, args: _e, strict: Se } = {}) {
  const Ie = Se ?? !1, $e = we ?? (ge ? [ge] : void 0);
  let Ne = [];
  $e && (Ne = [
    $e.flatMap((ze) => encodeEventTopics({
      abi: [ze],
      eventName: ze.name,
      args: _e
    }))
  ], ge && (Ne = Ne[0]));
  let Me;
  ae ? Me = await ne.request({
    method: "eth_getLogs",
    params: [{ address: oe, topics: Ne, blockHash: ae }]
  }) : Me = await ne.request({
    method: "eth_getLogs",
    params: [
      {
        address: oe,
        topics: Ne,
        fromBlock: typeof fe == "bigint" ? numberToHex(fe) : fe,
        toBlock: typeof ye == "bigint" ? numberToHex(ye) : ye
      }
    ]
  });
  const Be = Me.map((ze) => formatLog(ze));
  return $e ? parseEventLogs({
    abi: $e,
    logs: Be,
    strict: Ie
  }) : Be;
}
async function getContractEvents(ne, oe) {
  const { abi: ae, address: fe, args: ye, blockHash: ge, eventName: we, fromBlock: _e, toBlock: Se, strict: Ie } = oe, $e = we ? getAbiItem({ abi: ae, name: we }) : void 0, Ne = $e ? void 0 : ae.filter((Me) => Me.type === "event");
  return getAction(ne, getLogs, "getLogs")({
    address: fe,
    args: ye,
    blockHash: ge,
    event: $e,
    events: Ne,
    fromBlock: _e,
    toBlock: Se,
    strict: Ie
  });
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(ne) {
  const { abi: oe, args: ae, functionName: fe, data: ye } = ne;
  let ge = oe[0];
  if (fe) {
    const _e = getAbiItem({ abi: oe, args: ae, name: fe });
    if (!_e)
      throw new AbiFunctionNotFoundError(fe, { docsPath: docsPath$1 });
    ge = _e;
  }
  if (ge.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!ge.outputs)
    throw new AbiFunctionOutputsNotFoundError(ge.name, { docsPath: docsPath$1 });
  const we = decodeAbiParameters(ge.outputs, ye);
  if (we && we.length > 1)
    return we;
  if (we && we.length === 1)
    return we[0];
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
], aggregate3Signature = "0x82ad56cb";
class ChainDoesNotSupportContract extends BaseError {
  constructor({ blockNumber: oe, chain: ae, contract: fe }) {
    super(`Chain "${ae.name}" does not support contract "${fe.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...oe && fe.blockCreated && fe.blockCreated > oe ? [
          `- The contract "${fe.name}" was not deployed until block ${fe.blockCreated} (current block ${oe}).`
        ] : [
          `- The chain does not have the contract "${fe.name}" configured.`
        ]
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError {
  constructor({ chain: oe, currentChainId: ae }) {
    super(`The current chain of the wallet (id: ${ae}) does not match the target chain for the transaction (id: ${oe.id} – ${oe.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${ae}`,
        `Expected Chain ID: ${oe.id} – ${oe.name}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError {
  constructor() {
    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ClientChainNotConfiguredError"
    });
  }
}
class InvalidChainIdError extends BaseError {
  constructor({ chainId: oe }) {
    super(typeof oe == "number" ? `Chain ID "${oe}" is invalid.` : "Chain ID is invalid."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidChainIdError"
    });
  }
}
function getChainContractAddress({ blockNumber: ne, chain: oe, contract: ae }) {
  var ye;
  const fe = (ye = oe == null ? void 0 : oe.contracts) == null ? void 0 : ye[ae];
  if (!fe)
    throw new ChainDoesNotSupportContract({
      chain: oe,
      contract: { name: ae }
    });
  if (ne && fe.blockCreated && fe.blockCreated > ne)
    throw new ChainDoesNotSupportContract({
      blockNumber: ne,
      chain: oe,
      contract: {
        name: ae,
        blockCreated: fe.blockCreated
      }
    });
  return fe.address;
}
function getCallError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new CallExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: ne, id: oe, shouldSplitBatch: ae, wait: fe = 0, sort: ye }) {
  const ge = async () => {
    const $e = Se();
    we();
    const Ne = $e.map(({ args: Me }) => Me);
    Ne.length !== 0 && ne(Ne).then((Me) => {
      var Be;
      ye && Array.isArray(Me) && Me.sort(ye);
      for (let ze = 0; ze < $e.length; ze++) {
        const { pendingPromise: He } = $e[ze];
        (Be = He.resolve) == null || Be.call(He, [Me[ze], Me]);
      }
    }).catch((Me) => {
      var Be;
      for (let ze = 0; ze < $e.length; ze++) {
        const { pendingPromise: He } = $e[ze];
        (Be = He.reject) == null || Be.call(He, Me);
      }
    });
  }, we = () => schedulerCache.delete(oe), _e = () => Se().map(({ args: $e }) => $e), Se = () => schedulerCache.get(oe) || [], Ie = ($e) => schedulerCache.set(oe, [...Se(), $e]);
  return {
    flush: we,
    async schedule($e) {
      const Ne = {}, Me = new Promise((He, Ze) => {
        Ne.resolve = He, Ne.reject = Ze;
      });
      return (ae == null ? void 0 : ae([..._e(), $e])) && ge(), Se().length > 0 ? (Ie({ args: $e, pendingPromise: Ne }), Me) : (Ie({ args: $e, pendingPromise: Ne }), setTimeout(ge, fe), Me);
    }
  };
}
async function call(ne, oe) {
  var ot, pt, ht, wt;
  const { account: ae = ne.account, batch: fe = !!((ot = ne.batch) != null && ot.multicall), blockNumber: ye, blockTag: ge = "latest", accessList: we, blobs: _e, data: Se, gas: Ie, gasPrice: $e, maxFeePerBlobGas: Ne, maxFeePerGas: Me, maxPriorityFeePerGas: Be, nonce: ze, to: He, value: Ze, stateOverride: qe, ...tt } = oe, Xe = ae ? parseAccount(ae) : void 0;
  try {
    assertRequest(oe);
    const It = (ye ? numberToHex(ye) : void 0) || ge, Nt = parseStateOverride(qe), Ft = (wt = (ht = (pt = ne.chain) == null ? void 0 : pt.formatters) == null ? void 0 : ht.transactionRequest) == null ? void 0 : wt.format, en = (Ft || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(tt, { format: Ft }),
      from: Xe == null ? void 0 : Xe.address,
      accessList: we,
      blobs: _e,
      data: Se,
      gas: Ie,
      gasPrice: $e,
      maxFeePerBlobGas: Ne,
      maxFeePerGas: Me,
      maxPriorityFeePerGas: Be,
      nonce: ze,
      to: He,
      value: Ze
    });
    if (fe && shouldPerformMulticall({ request: en }) && !Nt)
      try {
        return await scheduleMulticall(ne, {
          ...en,
          blockNumber: ye,
          blockTag: ge
        });
      } catch (Zt) {
        if (!(Zt instanceof ClientChainNotConfiguredError) && !(Zt instanceof ChainDoesNotSupportContract))
          throw Zt;
      }
    const wn = await ne.request({
      method: "eth_call",
      params: Nt ? [
        en,
        It,
        Nt
      ] : [en, It]
    });
    return wn === "0x" ? { data: void 0 } : { data: wn };
  } catch (gt) {
    const It = getRevertErrorData(gt), { offchainLookup: Nt, offchainLookupSignature: Ft } = await import("./ccip-52000c30.js");
    if (ne.ccipRead !== !1 && (It == null ? void 0 : It.slice(0, 10)) === Ft && He)
      return { data: await Nt(ne, { data: It, to: He }) };
    throw getCallError(gt, {
      ...oe,
      account: Xe,
      chain: ne.chain
    });
  }
}
function shouldPerformMulticall({ request: ne }) {
  const { data: oe, to: ae, ...fe } = ne;
  return !(!oe || oe.startsWith(aggregate3Signature) || !ae || Object.values(fe).filter((ye) => typeof ye < "u").length > 0);
}
async function scheduleMulticall(ne, oe) {
  var He;
  const { batchSize: ae = 1024, wait: fe = 0 } = typeof ((He = ne.batch) == null ? void 0 : He.multicall) == "object" ? ne.batch.multicall : {}, { blockNumber: ye, blockTag: ge = "latest", data: we, multicallAddress: _e, to: Se } = oe;
  let Ie = _e;
  if (!Ie) {
    if (!ne.chain)
      throw new ClientChainNotConfiguredError();
    Ie = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Ne = (ye ? numberToHex(ye) : void 0) || ge, { schedule: Me } = createBatchScheduler({
    id: `${ne.uid}.${Ne}`,
    wait: fe,
    shouldSplitBatch(Ze) {
      return Ze.reduce((tt, { data: Xe }) => tt + (Xe.length - 2), 0) > ae * 2;
    },
    fn: async (Ze) => {
      const qe = Ze.map((ot) => ({
        allowFailure: !0,
        callData: ot.data,
        target: ot.to
      })), tt = encodeFunctionData({
        abi: multicall3Abi,
        args: [qe],
        functionName: "aggregate3"
      }), Xe = await ne.request({
        method: "eth_call",
        params: [
          {
            data: tt,
            to: Ie
          },
          Ne
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [qe],
        functionName: "aggregate3",
        data: Xe || "0x"
      });
    }
  }), [{ returnData: Be, success: ze }] = await Me({ data: we, to: Se });
  if (!ze)
    throw new RawContractError({ data: Be });
  return Be === "0x" ? { data: void 0 } : { data: Be };
}
function getRevertErrorData(ne) {
  var ae;
  if (!(ne instanceof BaseError))
    return;
  const oe = ne.walk();
  return typeof (oe == null ? void 0 : oe.data) == "object" ? (ae = oe.data) == null ? void 0 : ae.data : oe.data;
}
function parseStateMapping(ne) {
  if (!(!ne || ne.length === 0))
    return ne.reduce((oe, { slot: ae, value: fe }) => {
      if (ae.length !== 66)
        throw new InvalidBytesLengthError({
          size: ae.length,
          targetSize: 66,
          type: "hex"
        });
      if (fe.length !== 66)
        throw new InvalidBytesLengthError({
          size: fe.length,
          targetSize: 66,
          type: "hex"
        });
      return oe[ae] = fe, oe;
    }, {});
}
function parseAccountStateOverride(ne) {
  const { balance: oe, nonce: ae, state: fe, stateDiff: ye, code: ge } = ne, we = {};
  if (ge !== void 0 && (we.code = ge), oe !== void 0 && (we.balance = numberToHex(oe)), ae !== void 0 && (we.nonce = numberToHex(ae)), fe !== void 0 && (we.state = parseStateMapping(fe)), ye !== void 0) {
    if (we.state)
      throw new StateAssignmentConflictError();
    we.stateDiff = parseStateMapping(ye);
  }
  return we;
}
function parseStateOverride(ne) {
  if (!ne)
    return;
  const oe = {};
  for (const { address: ae, ...fe } of ne) {
    if (!isAddress(ae, { strict: !1 }))
      throw new InvalidAddressError({ address: ae });
    if (oe[ae])
      throw new AccountStateConflictError({ address: ae });
    oe[ae] = parseAccountStateOverride(fe);
  }
  return oe;
}
async function readContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, functionName: ge, ...we } = oe, _e = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: ge
  });
  try {
    const { data: Se } = await getAction(ne, call, "call")({
      ...we,
      data: _e,
      to: fe
    });
    return decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: ge,
      data: Se || "0x"
    });
  } catch (Se) {
    throw getContractError(Se, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/readContract",
      functionName: ge
    });
  }
}
async function simulateContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: ge, functionName: we, ..._e } = oe, Se = _e.account ? parseAccount(_e.account) : ne.account, Ie = encodeFunctionData({ abi: ae, args: ye, functionName: we });
  try {
    const { data: $e } = await getAction(ne, call, "call")({
      batch: !1,
      data: `${Ie}${ge ? ge.replace("0x", "") : ""}`,
      to: fe,
      ..._e,
      account: Se
    }), Ne = decodeFunctionResult({
      abi: ae,
      args: ye,
      functionName: we,
      data: $e || "0x"
    }), Me = ae.filter((Be) => "name" in Be && Be.name === oe.functionName);
    return {
      result: Ne,
      request: {
        abi: Me,
        address: fe,
        args: ye,
        dataSuffix: ge,
        functionName: we,
        ..._e,
        account: Se
      }
    };
  } catch ($e) {
    throw getContractError($e, {
      abi: ae,
      address: fe,
      args: ye,
      docsPath: "/docs/contract/simulateContract",
      functionName: we,
      sender: Se == null ? void 0 : Se.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map(), cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(ne, oe, ae) {
  const fe = ++callbackCount, ye = () => listenersCache.get(ne) || [], ge = () => {
    const $e = ye();
    listenersCache.set(ne, $e.filter((Ne) => Ne.id !== fe));
  }, we = () => {
    const $e = cleanupCache.get(ne);
    ye().length === 1 && $e && $e(), ge();
  }, _e = ye();
  if (listenersCache.set(ne, [
    ..._e,
    { id: fe, fns: oe }
  ]), _e && _e.length > 0)
    return we;
  const Se = {};
  for (const $e in oe)
    Se[$e] = (...Ne) => {
      var Be, ze;
      const Me = ye();
      if (Me.length !== 0)
        for (const He of Me)
          (ze = (Be = He.fns)[$e]) == null || ze.call(Be, ...Ne);
    };
  const Ie = ae(Se);
  return typeof Ie == "function" && cleanupCache.set(ne, Ie), we;
}
async function wait(ne) {
  return new Promise((oe) => setTimeout(oe, ne));
}
function poll(ne, { emitOnBegin: oe, initialWaitTime: ae, interval: fe }) {
  let ye = !0;
  const ge = () => ye = !1;
  return (async () => {
    let _e;
    oe && (_e = await ne({ unpoll: ge }));
    const Se = await (ae == null ? void 0 : ae(_e)) ?? fe;
    await wait(Se);
    const Ie = async () => {
      ye && (await ne({ unpoll: ge }), await wait(fe), Ie());
    };
    Ie();
  })(), ge;
}
const promiseCache = /* @__PURE__ */ new Map(), responseCache = /* @__PURE__ */ new Map();
function getCache(ne) {
  const oe = (ye, ge) => ({
    clear: () => ge.delete(ye),
    get: () => ge.get(ye),
    set: (we) => ge.set(ye, we)
  }), ae = oe(ne, promiseCache), fe = oe(ne, responseCache);
  return {
    clear: () => {
      ae.clear(), fe.clear();
    },
    promise: ae,
    response: fe
  };
}
async function withCache(ne, { cacheKey: oe, cacheTime: ae = 1 / 0 }) {
  const fe = getCache(oe), ye = fe.response.get();
  if (ye && ae > 0 && (/* @__PURE__ */ new Date()).getTime() - ye.created.getTime() < ae)
    return ye.data;
  let ge = fe.promise.get();
  ge || (ge = ne(), fe.promise.set(ge));
  try {
    const we = await ge;
    return fe.response.set({ created: /* @__PURE__ */ new Date(), data: we }), we;
  } finally {
    fe.promise.clear();
  }
}
const cacheKey = (ne) => `blockNumber.${ne}`;
async function getBlockNumber(ne, { cacheTime: oe = ne.cacheTime } = {}) {
  const ae = await withCache(() => ne.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(ne.uid), cacheTime: oe });
  return BigInt(ae);
}
async function getFilterChanges(ne, { filter: oe }) {
  const ae = "strict" in oe && oe.strict, fe = await oe.request({
    method: "eth_getFilterChanges",
    params: [oe.id]
  });
  if (typeof fe[0] == "string")
    return fe;
  const ye = fe.map((ge) => formatLog(ge));
  return !("abi" in oe) || !oe.abi ? ye : parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  });
}
async function uninstallFilter(ne, { filter: oe }) {
  return oe.request({
    method: "eth_uninstallFilter",
    params: [oe.id]
  });
}
function watchContractEvent(ne, oe) {
  const { abi: ae, address: fe, args: ye, batch: ge = !0, eventName: we, fromBlock: _e, onError: Se, onLogs: Ie, poll: $e, pollingInterval: Ne = ne.pollingInterval, strict: Me } = oe;
  return (typeof $e < "u" ? $e : ne.transport.type !== "webSocket" || typeof _e == "number") ? (() => {
    const Ze = Me ?? !1, qe = stringify([
      "watchContractEvent",
      fe,
      ye,
      ge,
      ne.uid,
      we,
      Ne,
      Ze,
      _e
    ]);
    return observe(qe, { onLogs: Ie, onError: Se }, (tt) => {
      let Xe;
      _e !== void 0 && (Xe = _e - 1n);
      let ot, pt = !1;
      const ht = poll(async () => {
        var wt;
        if (!pt) {
          try {
            ot = await getAction(ne, createContractEventFilter, "createContractEventFilter")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: we,
              strict: Ze,
              fromBlock: _e
            });
          } catch {
          }
          pt = !0;
          return;
        }
        try {
          let gt;
          if (ot)
            gt = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: ot });
          else {
            const It = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            Xe && Xe !== It ? gt = await getAction(ne, getContractEvents, "getContractEvents")({
              abi: ae,
              address: fe,
              args: ye,
              eventName: we,
              fromBlock: Xe + 1n,
              toBlock: It,
              strict: Ze
            }) : gt = [], Xe = It;
          }
          if (gt.length === 0)
            return;
          if (ge)
            tt.onLogs(gt);
          else
            for (const It of gt)
              tt.onLogs([It]);
        } catch (gt) {
          ot && gt instanceof InvalidInputRpcError && (pt = !1), (wt = tt.onError) == null || wt.call(tt, gt);
        }
      }, {
        emitOnBegin: !0,
        interval: Ne
      });
      return async () => {
        ot && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: ot }), ht();
      };
    });
  })() : (() => {
    const Ze = Me ?? !1, qe = stringify([
      "watchContractEvent",
      fe,
      ye,
      ge,
      ne.uid,
      we,
      Ne,
      Ze
    ]);
    let tt = !0, Xe = () => tt = !1;
    return observe(qe, { onLogs: Ie, onError: Se }, (ot) => ((async () => {
      try {
        const pt = we ? encodeEventTopics({
          abi: ae,
          eventName: we,
          args: ye
        }) : [], { unsubscribe: ht } = await ne.transport.subscribe({
          params: ["logs", { address: fe, topics: pt }],
          onData(wt) {
            var It;
            if (!tt)
              return;
            const gt = wt.result;
            try {
              const { eventName: Nt, args: Ft } = decodeEventLog({
                abi: ae,
                data: gt.data,
                topics: gt.topics,
                strict: Me
              }), on = formatLog(gt, {
                args: Ft,
                eventName: Nt
              });
              ot.onLogs([on]);
            } catch (Nt) {
              let Ft, on;
              if (Nt instanceof DecodeLogDataMismatch || Nt instanceof DecodeLogTopicsMismatch) {
                if (Me)
                  return;
                Ft = Nt.abiItem.name, on = (It = Nt.abiItem.inputs) == null ? void 0 : It.some((wn) => !("name" in wn && wn.name));
              }
              const en = formatLog(gt, {
                args: on ? [] : {},
                eventName: Ft
              });
              ot.onLogs([en]);
            }
          },
          onError(wt) {
            var gt;
            (gt = ot.onError) == null || gt.call(ot, wt);
          }
        });
        Xe = ht, tt || Xe();
      } catch (pt) {
        Se == null || Se(pt);
      }
    })(), () => Xe()));
  })();
}
function assertCurrentChain({ chain: ne, currentChainId: oe }) {
  if (!ne)
    throw new ChainNotFoundError();
  if (oe !== ne.id)
    throw new ChainMismatchError({ chain: ne, currentChainId: oe });
}
function getTransactionError(ne, { docsPath: oe, ...ae }) {
  const fe = (() => {
    const ye = getNodeError(ne, ae);
    return ye instanceof UnknownNodeError ? ne : ye;
  })();
  return new TransactionExecutionError(fe, {
    docsPath: oe,
    ...ae
  });
}
async function sendRawTransaction(ne, { serializedTransaction: oe }) {
  return ne.request({
    method: "eth_sendRawTransaction",
    params: [oe]
  }, { retryCount: 0 });
}
async function sendTransaction(ne, oe) {
  var qe, tt, Xe, ot;
  const { account: ae = ne.account, chain: fe = ne.chain, accessList: ye, blobs: ge, data: we, gas: _e, gasPrice: Se, maxFeePerBlobGas: Ie, maxFeePerGas: $e, maxPriorityFeePerGas: Ne, nonce: Me, to: Be, value: ze, ...He } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const Ze = parseAccount(ae);
  try {
    assertRequest(oe);
    let pt;
    if (fe !== null && (pt = await getAction(ne, getChainId, "getChainId")({}), assertCurrentChain({
      currentChainId: pt,
      chain: fe
    })), Ze.type === "local") {
      const It = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({
        account: Ze,
        accessList: ye,
        blobs: ge,
        chain: fe,
        chainId: pt,
        data: we,
        gas: _e,
        gasPrice: Se,
        maxFeePerBlobGas: Ie,
        maxFeePerGas: $e,
        maxPriorityFeePerGas: Ne,
        nonce: Me,
        parameters: [...defaultParameters, "sidecars"],
        to: Be,
        value: ze,
        ...He
      }), Nt = (qe = fe == null ? void 0 : fe.serializers) == null ? void 0 : qe.transaction, Ft = await Ze.signTransaction(It, {
        serializer: Nt
      });
      return await getAction(ne, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction: Ft
      });
    }
    const ht = (ot = (Xe = (tt = ne.chain) == null ? void 0 : tt.formatters) == null ? void 0 : Xe.transactionRequest) == null ? void 0 : ot.format, gt = (ht || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(He, { format: ht }),
      accessList: ye,
      blobs: ge,
      data: we,
      from: Ze.address,
      gas: _e,
      gasPrice: Se,
      maxFeePerBlobGas: Ie,
      maxFeePerGas: $e,
      maxPriorityFeePerGas: Ne,
      nonce: Me,
      to: Be,
      value: ze
    });
    return await ne.request({
      method: "eth_sendTransaction",
      params: [gt]
    }, { retryCount: 0 });
  } catch (pt) {
    throw getTransactionError(pt, {
      ...oe,
      account: Ze,
      chain: oe.chain || void 0
    });
  }
}
async function writeContract(ne, oe) {
  const { abi: ae, address: fe, args: ye, dataSuffix: ge, functionName: we, ..._e } = oe, Se = encodeFunctionData({
    abi: ae,
    args: ye,
    functionName: we
  });
  return getAction(ne, sendTransaction, "sendTransaction")({
    data: `${Se}${ge ? ge.replace("0x", "") : ""}`,
    to: fe,
    ..._e
  });
}
function getContract({ abi: ne, address: oe, client: ae }) {
  const fe = ae, [ye, ge] = (() => fe ? "public" in fe && "wallet" in fe ? [fe.public, fe.wallet] : "public" in fe ? [fe.public, void 0] : "wallet" in fe ? [void 0, fe.wallet] : [fe, fe] : [void 0, void 0])(), we = ye != null, _e = ge != null, Se = {};
  let Ie = !1, $e = !1, Ne = !1;
  for (const Me of ne)
    if (Me.type === "function" ? Me.stateMutability === "view" || Me.stateMutability === "pure" ? Ie = !0 : $e = !0 : Me.type === "event" && (Ne = !0), Ie && $e && Ne)
      break;
  return we && (Ie && (Se.read = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const { args: He, options: Ze } = getFunctionParameters(ze);
        return getAction(ye, readContract, "readContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...Ze
        });
      };
    }
  })), $e && (Se.simulate = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const { args: He, options: Ze } = getFunctionParameters(ze);
        return getAction(ye, simulateContract, "simulateContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...Ze
        });
      };
    }
  })), Ne && (Se.createEventFilter = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const He = ne.find((tt) => tt.type === "event" && tt.name === Be), { args: Ze, options: qe } = getEventParameters(ze, He);
        return getAction(ye, createContractEventFilter, "createContractEventFilter")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: Ze,
          ...qe
        });
      };
    }
  }), Se.getEvents = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const He = ne.find((tt) => tt.type === "event" && tt.name === Be), { args: Ze, options: qe } = getEventParameters(ze, He);
        return getAction(ye, getContractEvents, "getContractEvents")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: Ze,
          ...qe
        });
      };
    }
  }), Se.watchEvent = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const He = ne.find((tt) => tt.type === "event" && tt.name === Be), { args: Ze, options: qe } = getEventParameters(ze, He);
        return getAction(ye, watchContractEvent, "watchContractEvent")({
          abi: ne,
          address: oe,
          eventName: Be,
          args: Ze,
          ...qe
        });
      };
    }
  }))), _e && $e && (Se.write = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const { args: He, options: Ze } = getFunctionParameters(ze);
        return getAction(ge, writeContract, "writeContract")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...Ze
        });
      };
    }
  })), (we || _e) && $e && (Se.estimateGas = new Proxy({}, {
    get(Me, Be) {
      return (...ze) => {
        const { args: He, options: Ze } = getFunctionParameters(ze);
        return getAction(ye ?? ge, estimateContractGas, "estimateContractGas")({
          abi: ne,
          address: oe,
          functionName: Be,
          args: He,
          ...Ze,
          account: Ze.account ?? ge.account
        });
      };
    }
  })), Se.address = oe, Se.abi = ne, Se;
}
function getFunctionParameters(ne) {
  const oe = ne.length && Array.isArray(ne[0]), ae = oe ? ne[0] : [], fe = (oe ? ne[1] : ne[0]) ?? {};
  return { args: ae, options: fe };
}
function getEventParameters(ne, oe) {
  let ae = !1;
  Array.isArray(ne[0]) ? ae = !0 : ne.length === 1 ? ae = oe.inputs.some((ge) => ge.indexed) : ne.length === 2 && (ae = !0);
  const fe = ae ? ne[0] : void 0, ye = (ae ? ne[1] : ne[0]) ?? {};
  return { args: fe, options: ye };
}
async function addChain(ne, { chain: oe }) {
  const { id: ae, name: fe, nativeCurrency: ye, rpcUrls: ge, blockExplorers: we } = oe;
  await ne.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(ae),
        chainName: fe,
        nativeCurrency: ye,
        rpcUrls: ge.default.http,
        blockExplorerUrls: we ? Object.values(we).map(({ url: _e }) => _e) : void 0
      }
    ]
  }, { retryCount: 0 });
}
function publicKeyToAddress(ne) {
  const oe = keccak256(`0x${ne.substring(4)}`).substring(26);
  return checksumAddress(`0x${oe}`);
}
const size = 256;
let index = size, buffer;
function uid(ne = 11) {
  if (!buffer || index + ne > size * 2) {
    buffer = "", index = 0;
    for (let oe = 0; oe < size; oe++)
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer.substring(index, index++ + ne);
}
function createClient$1(ne) {
  const { batch: oe, cacheTime: ae = ne.pollingInterval ?? 4e3, ccipRead: fe, key: ye = "base", name: ge = "Base Client", pollingInterval: we = 4e3, type: _e = "base" } = ne, Se = ne.chain, Ie = ne.account ? parseAccount(ne.account) : void 0, { config: $e, request: Ne, value: Me } = ne.transport({
    chain: Se,
    pollingInterval: we
  }), Be = { ...$e, ...Me }, ze = {
    account: Ie,
    batch: oe,
    cacheTime: ae,
    ccipRead: fe,
    chain: Se,
    key: ye,
    name: ge,
    pollingInterval: we,
    request: Ne,
    transport: Be,
    type: _e,
    uid: uid()
  };
  function He(Ze) {
    return (qe) => {
      const tt = qe(Ze);
      for (const ot in ze)
        delete tt[ot];
      const Xe = { ...Ze, ...tt };
      return Object.assign(Xe, { extend: He(Xe) });
    };
  }
  return Object.assign(ze, { extend: He(ze) });
}
function withRetry(ne, { delay: oe = 100, retryCount: ae = 2, shouldRetry: fe = () => !0 } = {}) {
  return new Promise((ye, ge) => {
    const we = async ({ count: _e = 0 } = {}) => {
      const Se = async ({ error: Ie }) => {
        const $e = typeof oe == "function" ? oe({ count: _e, error: Ie }) : oe;
        $e && await wait($e), we({ count: _e + 1 });
      };
      try {
        const Ie = await ne();
        ye(Ie);
      } catch (Ie) {
        if (_e < ae && await fe({ count: _e, error: Ie }))
          return Se({ error: Ie });
        ge(Ie);
      }
    };
    we();
  });
}
function buildRequest(ne, oe = {}) {
  return async (ae, fe = {}) => {
    const { retryDelay: ye = 150, retryCount: ge = 3 } = {
      ...oe,
      ...fe
    };
    return withRetry(async () => {
      try {
        return await ne(ae);
      } catch (we) {
        const _e = we;
        switch (_e.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(_e);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(_e);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(_e);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(_e);
          case InternalRpcError.code:
            throw new InternalRpcError(_e);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(_e);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(_e);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(_e);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(_e);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(_e);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(_e);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(_e);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(_e);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(_e);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(_e);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(_e);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(_e);
          case SwitchChainError.code:
            throw new SwitchChainError(_e);
          case 5e3:
            throw new UserRejectedRequestError(_e);
          default:
            throw we instanceof BaseError ? we : new UnknownRpcError(_e);
        }
      }
    }, {
      delay: ({ count: we, error: _e }) => {
        var Se;
        if (_e && _e instanceof HttpRequestError) {
          const Ie = (Se = _e == null ? void 0 : _e.headers) == null ? void 0 : Se.get("Retry-After");
          if (Ie != null && Ie.match(/\d/))
            return parseInt(Ie) * 1e3;
        }
        return ~~(1 << we) * ye;
      },
      retryCount: ge,
      shouldRetry: ({ error: we }) => shouldRetry(we)
    });
  };
}
function shouldRetry(ne) {
  return "code" in ne && typeof ne.code == "number" ? ne.code === -1 || ne.code === LimitExceededRpcError.code || ne.code === InternalRpcError.code : ne instanceof HttpRequestError && ne.status ? ne.status === 403 || ne.status === 408 || ne.status === 413 || ne.status === 429 || ne.status === 500 || ne.status === 502 || ne.status === 503 || ne.status === 504 : !0;
}
function createTransport({ key: ne, name: oe, request: ae, retryCount: fe = 3, retryDelay: ye = 150, timeout: ge, type: we }, _e) {
  return {
    config: { key: ne, name: oe, request: ae, retryCount: fe, retryDelay: ye, timeout: ge, type: we },
    request: buildRequest(ae, { retryCount: fe, retryDelay: ye }),
    value: _e
  };
}
function fallback(ne, oe = {}) {
  const { key: ae = "fallback", name: fe = "Fallback", rank: ye = !1, retryCount: ge, retryDelay: we } = oe;
  return ({ chain: _e, pollingInterval: Se = 4e3, timeout: Ie, ...$e }) => {
    let Ne = ne, Me = () => {
    };
    const Be = createTransport({
      key: ae,
      name: fe,
      async request({ method: ze, params: He }) {
        const Ze = async (qe = 0) => {
          const tt = Ne[qe]({
            ...$e,
            chain: _e,
            retryCount: 0,
            timeout: Ie
          });
          try {
            const Xe = await tt.request({
              method: ze,
              params: He
            });
            return Me({
              method: ze,
              params: He,
              response: Xe,
              transport: tt,
              status: "success"
            }), Xe;
          } catch (Xe) {
            if (Me({
              error: Xe,
              method: ze,
              params: He,
              transport: tt,
              status: "error"
            }), shouldThrow(Xe) || qe === Ne.length - 1)
              throw Xe;
            return Ze(qe + 1);
          }
        };
        return Ze();
      },
      retryCount: ge,
      retryDelay: we,
      type: "fallback"
    }, {
      onResponse: (ze) => Me = ze,
      transports: Ne.map((ze) => ze({ chain: _e, retryCount: 0 }))
    });
    if (ye) {
      const ze = typeof ye == "object" ? ye : {};
      rankTransports({
        chain: _e,
        interval: ze.interval ?? Se,
        onTransports: (He) => Ne = He,
        sampleCount: ze.sampleCount,
        timeout: ze.timeout,
        transports: Ne,
        weights: ze.weights
      });
    }
    return Be;
  };
}
function shouldThrow(ne) {
  return "code" in ne && typeof ne.code == "number" && (ne.code === TransactionRejectedRpcError.code || ne.code === UserRejectedRequestError.code || ne.code === 5e3);
}
function rankTransports({ chain: ne, interval: oe = 4e3, onTransports: ae, sampleCount: fe = 10, timeout: ye = 1e3, transports: ge, weights: we = {} }) {
  const { stability: _e = 0.7, latency: Se = 0.3 } = we, Ie = [], $e = async () => {
    const Ne = await Promise.all(ge.map(async (ze) => {
      const He = ze({ chain: ne, retryCount: 0, timeout: ye }), Ze = Date.now();
      let qe, tt;
      try {
        await He.request({ method: "net_listening" }), tt = 1;
      } catch {
        tt = 0;
      } finally {
        qe = Date.now();
      }
      return { latency: qe - Ze, success: tt };
    }));
    Ie.push(Ne), Ie.length > fe && Ie.shift();
    const Me = Math.max(...Ie.map((ze) => Math.max(...ze.map(({ latency: He }) => He)))), Be = ge.map((ze, He) => {
      const Ze = Ie.map((pt) => pt[He].latency), tt = 1 - Ze.reduce((pt, ht) => pt + ht, 0) / Ze.length / Me, Xe = Ie.map((pt) => pt[He].success), ot = Xe.reduce((pt, ht) => pt + ht, 0) / Xe.length;
      return ot === 0 ? [0, He] : [
        Se * tt + _e * ot,
        He
      ];
    }).sort((ze, He) => He[0] - ze[0]);
    ae(Be.map(([, ze]) => ge[ze])), await wait(oe), $e();
  };
  $e();
}
class UrlRequiredError extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function withTimeout(ne, { errorInstance: oe = new Error("timed out"), timeout: ae, signal: fe }) {
  return new Promise((ye, ge) => {
    (async () => {
      let we;
      try {
        const _e = new AbortController();
        ae > 0 && (we = setTimeout(() => {
          fe ? _e.abort() : ge(oe);
        }, ae)), ye(await ne({ signal: (_e == null ? void 0 : _e.signal) || null }));
      } catch (_e) {
        _e.name === "AbortError" && ge(oe), ge(_e);
      } finally {
        clearTimeout(we);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(ne, oe = {}) {
  return {
    async request(ae) {
      var Ne;
      const { body: fe, fetchOptions: ye = {}, onRequest: ge = oe.onRequest, onResponse: we = oe.onResponse, timeout: _e = oe.timeout ?? 1e4 } = ae, { headers: Se, method: Ie, signal: $e } = { ...oe.fetchOptions, ...ye };
      try {
        const Me = await withTimeout(async ({ signal: ze }) => {
          const He = {
            ...ye,
            body: Array.isArray(fe) ? stringify(fe.map((tt) => ({
              jsonrpc: "2.0",
              id: tt.id ?? idCache.take(),
              ...tt
            }))) : stringify({
              jsonrpc: "2.0",
              id: fe.id ?? idCache.take(),
              ...fe
            }),
            headers: {
              ...Se,
              "Content-Type": "application/json"
            },
            method: Ie || "POST",
            signal: $e || (_e > 0 ? ze : null)
          }, Ze = new Request(ne, He);
          return ge && await ge(Ze), await fetch(ne, He);
        }, {
          errorInstance: new TimeoutError$1({ body: fe, url: ne }),
          timeout: _e,
          signal: !0
        });
        we && await we(Me);
        let Be;
        if ((Ne = Me.headers.get("Content-Type")) != null && Ne.startsWith("application/json") ? Be = await Me.json() : Be = await Me.text(), !Me.ok)
          throw new HttpRequestError({
            body: fe,
            details: stringify(Be.error) || Me.statusText,
            headers: Me.headers,
            status: Me.status,
            url: ne
          });
        return Be;
      } catch (Me) {
        throw Me instanceof HttpRequestError || Me instanceof TimeoutError$1 ? Me : new HttpRequestError({
          body: fe,
          details: Me.message,
          url: ne
        });
      }
    }
  };
}
function http(ne, oe = {}) {
  const { batch: ae, fetchOptions: fe, key: ye = "http", name: ge = "HTTP JSON-RPC", onFetchRequest: we, onFetchResponse: _e, retryDelay: Se } = oe;
  return ({ chain: Ie, retryCount: $e, timeout: Ne }) => {
    const { batchSize: Me = 1e3, wait: Be = 0 } = typeof ae == "object" ? ae : {}, ze = oe.retryCount ?? $e, He = Ne ?? oe.timeout ?? 1e4, Ze = ne || (Ie == null ? void 0 : Ie.rpcUrls.default.http[0]);
    if (!Ze)
      throw new UrlRequiredError();
    const qe = getHttpRpcClient(Ze, {
      fetchOptions: fe,
      onRequest: we,
      onResponse: _e,
      timeout: He
    });
    return createTransport({
      key: ye,
      name: ge,
      async request({ method: tt, params: Xe }) {
        const ot = { method: tt, params: Xe }, { schedule: pt } = createBatchScheduler({
          id: `${ne}`,
          wait: Be,
          shouldSplitBatch(It) {
            return It.length > Me;
          },
          fn: (It) => qe.request({
            body: It
          }),
          sort: (It, Nt) => It.id - Nt.id
        }), ht = async (It) => ae ? pt(It) : [
          await qe.request({
            body: It
          })
        ], [{ error: wt, result: gt }] = await ht(ot);
        if (wt)
          throw new RpcRequestError({
            body: ot,
            error: wt,
            url: Ze
          });
        return gt;
      },
      retryCount: ze,
      retryDelay: Se,
      timeout: He,
      type: "http"
    }, {
      fetchOptions: fe,
      url: Ze
    });
  };
}
function isNullUniversalResolverError(ne, oe) {
  var fe, ye, ge, we, _e, Se;
  if (!(ne instanceof BaseError))
    return !1;
  const ae = ne.walk((Ie) => Ie instanceof ContractFunctionRevertedError);
  return ae instanceof ContractFunctionRevertedError ? !!(((fe = ae.data) == null ? void 0 : fe.errorName) === "ResolverNotFound" || ((ye = ae.data) == null ? void 0 : ye.errorName) === "ResolverWildcardNotSupported" || ((ge = ae.data) == null ? void 0 : ge.errorName) === "ResolverNotContract" || ((we = ae.data) == null ? void 0 : we.errorName) === "ResolverError" || ((_e = ae.data) == null ? void 0 : _e.errorName) === "HttpError" || (Se = ae.reason) != null && Se.includes("Wildcard on non-extended resolvers is not supported") || oe === "reverse" && ae.reason === panicReasons[50]) : !1;
}
function encodedLabelToLabelhash(ne) {
  if (ne.length !== 66 || ne.indexOf("[") !== 0 || ne.indexOf("]") !== 65)
    return null;
  const oe = `0x${ne.slice(1, 65)}`;
  return isHex(oe) ? oe : null;
}
function namehash(ne) {
  let oe = new Uint8Array(32).fill(0);
  if (!ne)
    return bytesToHex$1(oe);
  const ae = ne.split(".");
  for (let fe = ae.length - 1; fe >= 0; fe -= 1) {
    const ye = encodedLabelToLabelhash(ae[fe]), ge = ye ? toBytes$1(ye) : keccak256(stringToBytes(ae[fe]), "bytes");
    oe = keccak256(concat$1([oe, ge]), "bytes");
  }
  return bytesToHex$1(oe);
}
function encodeLabelhash(ne) {
  return `[${ne.slice(2)}]`;
}
function labelhash(ne) {
  const oe = new Uint8Array(32).fill(0);
  return ne ? encodedLabelToLabelhash(ne) || keccak256(stringToBytes(ne)) : bytesToHex$1(oe);
}
function packetToBytes(ne) {
  const oe = ne.replace(/^\.|\.$/gm, "");
  if (oe.length === 0)
    return new Uint8Array(1);
  const ae = new Uint8Array(stringToBytes(oe).byteLength + 2);
  let fe = 0;
  const ye = oe.split(".");
  for (let ge = 0; ge < ye.length; ge++) {
    let we = stringToBytes(ye[ge]);
    we.byteLength > 255 && (we = stringToBytes(encodeLabelhash(labelhash(ye[ge])))), ae[fe] = we.length, ae.set(we, fe + 1), fe += we.length + 1;
  }
  return ae.byteLength !== fe + 1 ? ae.slice(0, fe + 1) : ae;
}
async function getEnsAddress(ne, { blockNumber: oe, blockTag: ae, coinType: fe, name: ye, gatewayUrls: ge, strict: we, universalResolverAddress: _e }) {
  let Se = _e;
  if (!Se) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Se = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const Ie = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...fe != null ? { args: [namehash(ye), BigInt(fe)] } : { args: [namehash(ye)] }
    }), $e = {
      address: Se,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(ye)), Ie],
      blockNumber: oe,
      blockTag: ae
    }, Ne = getAction(ne, readContract, "readContract"), Me = ge ? await Ne({
      ...$e,
      args: [...$e.args, ge]
    }) : await Ne($e);
    if (Me[0] === "0x")
      return null;
    const Be = decodeFunctionResult({
      abi: addressResolverAbi,
      args: fe != null ? [namehash(ye), BigInt(fe)] : void 0,
      functionName: "addr",
      data: Me[0]
    });
    return Be === "0x" || trim(Be) === "0x00" ? null : Be;
  } catch (Ie) {
    if (we)
      throw Ie;
    if (isNullUniversalResolverError(Ie, "resolve"))
      return null;
    throw Ie;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError {
  constructor({ data: oe }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(oe)}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError {
  constructor({ reason: oe }) {
    super(`ENS NFT avatar URI is invalid. ${oe}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError {
  constructor({ uri: oe }) {
    super(`Unable to resolve ENS avatar URI "${oe}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError {
  constructor({ namespace: oe }) {
    super(`ENS NFT avatar namespace "${oe}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, base64Regex$1 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(ne) {
  try {
    const oe = await fetch(ne, { method: "HEAD" });
    if (oe.status === 200) {
      const ae = oe.headers.get("content-type");
      return ae == null ? void 0 : ae.startsWith("image/");
    }
    return !1;
  } catch (oe) {
    return typeof oe == "object" && typeof oe.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((ae) => {
      const fe = new Image();
      fe.onload = () => {
        ae(!0);
      }, fe.onerror = () => {
        ae(!1);
      }, fe.src = ne;
    });
  }
}
function getGateway(ne, oe) {
  return ne ? ne.endsWith("/") ? ne.slice(0, -1) : ne : oe;
}
function resolveAvatarUri({ uri: ne, gatewayUrls: oe }) {
  const ae = base64Regex$1.test(ne);
  if (ae)
    return { uri: ne, isOnChain: !0, isEncoded: ae };
  const fe = getGateway(oe == null ? void 0 : oe.ipfs, "https://ipfs.io"), ye = getGateway(oe == null ? void 0 : oe.arweave, "https://arweave.net"), ge = ne.match(networkRegex), { protocol: we, subpath: _e, target: Se, subtarget: Ie = "" } = (ge == null ? void 0 : ge.groups) || {}, $e = we === "ipns:/" || _e === "ipns/", Ne = we === "ipfs:/" || _e === "ipfs/" || ipfsHashRegex.test(ne);
  if (ne.startsWith("http") && !$e && !Ne) {
    let Be = ne;
    return oe != null && oe.arweave && (Be = ne.replace(/https:\/\/arweave.net/g, oe == null ? void 0 : oe.arweave)), { uri: Be, isOnChain: !1, isEncoded: !1 };
  }
  if (($e || Ne) && Se)
    return {
      uri: `${fe}/${$e ? "ipns" : "ipfs"}/${Se}${Ie}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (we === "ar:/" && Se)
    return {
      uri: `${ye}/${Se}${Ie || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let Me = ne.replace(dataURIRegex, "");
  if (Me.startsWith("<svg") && (Me = `data:image/svg+xml;base64,${btoa(Me)}`), Me.startsWith("data:") || Me.startsWith("{"))
    return {
      uri: Me,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new EnsAvatarUriResolutionError({ uri: ne });
}
function getJsonImage(ne) {
  if (typeof ne != "object" || !("image" in ne) && !("image_url" in ne) && !("image_data" in ne))
    throw new EnsAvatarInvalidMetadataError({ data: ne });
  return ne.image || ne.image_url || ne.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls: ne, uri: oe }) {
  try {
    const ae = await fetch(oe).then((ye) => ye.json());
    return await parseAvatarUri({
      gatewayUrls: ne,
      uri: getJsonImage(ae)
    });
  } catch {
    throw new EnsAvatarUriResolutionError({ uri: oe });
  }
}
async function parseAvatarUri({ gatewayUrls: ne, uri: oe }) {
  const { uri: ae, isOnChain: fe } = resolveAvatarUri({ uri: oe, gatewayUrls: ne });
  if (fe || await isImageUri(ae))
    return ae;
  throw new EnsAvatarUriResolutionError({ uri: oe });
}
function parseNftUri(ne) {
  let oe = ne;
  oe.startsWith("did:nft:") && (oe = oe.replace("did:nft:", "").replace(/_/g, "/"));
  const [ae, fe, ye] = oe.split("/"), [ge, we] = ae.split(":"), [_e, Se] = fe.split(":");
  if (!ge || ge.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!we)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!Se)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!ye)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!_e)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(we),
    namespace: _e.toLowerCase(),
    contractAddress: Se,
    tokenID: ye
  };
}
async function getNftTokenUri(ne, { nft: oe }) {
  if (oe.namespace === "erc721")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(oe.tokenID)]
    });
  if (oe.namespace === "erc1155")
    return readContract(ne, {
      address: oe.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(oe.tokenID)]
    });
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: oe.namespace });
}
async function parseAvatarRecord(ne, { gatewayUrls: oe, record: ae }) {
  return /eip155:/i.test(ae) ? parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) : parseAvatarUri({ uri: ae, gatewayUrls: oe });
}
async function parseNftAvatarUri(ne, { gatewayUrls: oe, record: ae }) {
  const fe = parseNftUri(ae), ye = await getNftTokenUri(ne, { nft: fe }), { uri: ge, isOnChain: we, isEncoded: _e } = resolveAvatarUri({ uri: ye, gatewayUrls: oe });
  if (we && (ge.includes("data:application/json;base64,") || ge.startsWith("{"))) {
    const Ie = _e ? (
      // if it is encoded, decode it
      atob(ge.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      ge
    ), $e = JSON.parse(Ie);
    return parseAvatarUri({ uri: getJsonImage($e), gatewayUrls: oe });
  }
  let Se = fe.tokenID;
  return fe.namespace === "erc1155" && (Se = Se.replace("0x", "").padStart(64, "0")), getMetadataAvatarUri({
    gatewayUrls: oe,
    uri: ge.replace(/(?:0x)?{id}/, Se)
  });
}
async function getEnsText(ne, { blockNumber: oe, blockTag: ae, name: fe, key: ye, gatewayUrls: ge, strict: we, universalResolverAddress: _e }) {
  let Se = _e;
  if (!Se) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Se = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const Ie = {
      address: Se,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(fe)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(fe), ye]
        })
      ],
      blockNumber: oe,
      blockTag: ae
    }, $e = getAction(ne, readContract, "readContract"), Ne = ge ? await $e({
      ...Ie,
      args: [...Ie.args, ge]
    }) : await $e(Ie);
    if (Ne[0] === "0x")
      return null;
    const Me = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: Ne[0]
    });
    return Me === "" ? null : Me;
  } catch (Ie) {
    if (we)
      throw Ie;
    if (isNullUniversalResolverError(Ie, "resolve"))
      return null;
    throw Ie;
  }
}
async function getEnsAvatar(ne, { blockNumber: oe, blockTag: ae, assetGatewayUrls: fe, name: ye, gatewayUrls: ge, strict: we, universalResolverAddress: _e }) {
  const Se = await getAction(ne, getEnsText, "getEnsText")({
    blockNumber: oe,
    blockTag: ae,
    key: "avatar",
    name: ye,
    universalResolverAddress: _e,
    gatewayUrls: ge,
    strict: we
  });
  if (!Se)
    return null;
  try {
    return await parseAvatarRecord(ne, {
      record: Se,
      gatewayUrls: fe
    });
  } catch {
    return null;
  }
}
async function getEnsName(ne, { address: oe, blockNumber: ae, blockTag: fe, gatewayUrls: ye, strict: ge, universalResolverAddress: we }) {
  let _e = we;
  if (!_e) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    _e = getChainContractAddress({
      blockNumber: ae,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const Se = `${oe.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const Ie = {
      address: _e,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(Se))],
      blockNumber: ae,
      blockTag: fe
    }, $e = getAction(ne, readContract, "readContract"), [Ne, Me] = ye ? await $e({
      ...Ie,
      args: [...Ie.args, ye]
    }) : await $e(Ie);
    return oe.toLowerCase() !== Me.toLowerCase() ? null : Ne;
  } catch (Ie) {
    if (ge)
      throw Ie;
    if (isNullUniversalResolverError(Ie, "reverse"))
      return null;
    throw Ie;
  }
}
async function getEnsResolver(ne, { blockNumber: oe, blockTag: ae, name: fe, universalResolverAddress: ye }) {
  let ge = ye;
  if (!ge) {
    if (!ne.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    ge = getChainContractAddress({
      blockNumber: oe,
      chain: ne.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [we] = await getAction(ne, readContract, "readContract")({
    address: ge,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(fe))],
    blockNumber: oe,
    blockTag: ae
  });
  return we;
}
async function createBlockFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newBlockFilter"
  }), ae = await ne.request({
    method: "eth_newBlockFilter"
  });
  return { id: ae, request: oe(ae), type: "block" };
}
async function createEventFilter(ne, { address: oe, args: ae, event: fe, events: ye, fromBlock: ge, strict: we, toBlock: _e } = {}) {
  const Se = ye ?? (fe ? [fe] : void 0), Ie = createFilterRequestScope(ne, {
    method: "eth_newFilter"
  });
  let $e = [];
  Se && ($e = [
    Se.flatMap((Me) => encodeEventTopics({
      abi: [Me],
      eventName: Me.name,
      args: ae
    }))
  ], fe && ($e = $e[0]));
  const Ne = await ne.request({
    method: "eth_newFilter",
    params: [
      {
        address: oe,
        fromBlock: typeof ge == "bigint" ? numberToHex(ge) : ge,
        toBlock: typeof _e == "bigint" ? numberToHex(_e) : _e,
        ...$e.length ? { topics: $e } : {}
      }
    ]
  });
  return {
    abi: Se,
    args: ae,
    eventName: fe ? fe.name : void 0,
    fromBlock: ge,
    id: Ne,
    request: Ie(Ne),
    strict: !!we,
    toBlock: _e,
    type: "event"
  };
}
async function createPendingTransactionFilter(ne) {
  const oe = createFilterRequestScope(ne, {
    method: "eth_newPendingTransactionFilter"
  }), ae = await ne.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: ae, request: oe(ae), type: "transaction" };
}
async function getBalance(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae ? numberToHex(ae) : void 0, ge = await ne.request({
    method: "eth_getBalance",
    params: [oe, ye || fe]
  });
  return BigInt(ge);
}
async function getBlobBaseFee(ne) {
  const oe = await ne.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(oe);
}
async function getBlockTransactionCount(ne, { blockHash: oe, blockNumber: ae, blockTag: fe = "latest" } = {}) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0;
  let ge;
  return oe ? ge = await ne.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [oe]
  }) : ge = await ne.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [ye || fe]
  }), hexToNumber$1(ge);
}
async function getBytecode(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest" }) {
  const ye = ae !== void 0 ? numberToHex(ae) : void 0, ge = await ne.request({
    method: "eth_getCode",
    params: [oe, ye || fe]
  });
  if (ge !== "0x")
    return ge;
}
function formatFeeHistory(ne) {
  var oe;
  return {
    baseFeePerGas: ne.baseFeePerGas.map((ae) => BigInt(ae)),
    gasUsedRatio: ne.gasUsedRatio,
    oldestBlock: BigInt(ne.oldestBlock),
    reward: (oe = ne.reward) == null ? void 0 : oe.map((ae) => ae.map((fe) => BigInt(fe)))
  };
}
async function getFeeHistory(ne, { blockCount: oe, blockNumber: ae, blockTag: fe = "latest", rewardPercentiles: ye }) {
  const ge = ae ? numberToHex(ae) : void 0, we = await ne.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(oe),
      ge || fe,
      ye
    ]
  });
  return formatFeeHistory(we);
}
async function getFilterLogs(ne, { filter: oe }) {
  const ae = oe.strict ?? !1, ye = (await oe.request({
    method: "eth_getFilterLogs",
    params: [oe.id]
  })).map((ge) => formatLog(ge));
  return oe.abi ? parseEventLogs({
    abi: oe.abi,
    logs: ye,
    strict: ae
  }) : ye;
}
function defineChain(ne) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...ne
  };
}
const arrayRegex = /^(.*)\[([0-9]*)\]$/, bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, socketClientCache = /* @__PURE__ */ new Map();
async function getSocketRpcClient(ne) {
  const { getSocket: oe, reconnect: ae = !0, url: fe } = ne, { attempts: ye = 5, delay: ge = 2e3 } = typeof ae == "object" ? ae : {};
  let we = socketClientCache.get(fe);
  if (we)
    return we;
  let _e = 0;
  const { schedule: Se } = createBatchScheduler({
    id: fe,
    fn: async () => {
      const Ne = /* @__PURE__ */ new Map(), Me = /* @__PURE__ */ new Map();
      let Be, ze;
      async function He() {
        return oe({
          onError(Ze) {
            var qe, tt;
            Be = Ze;
            for (const Xe of Ne.values())
              (qe = Xe.onError) == null || qe.call(Xe, Be);
            for (const Xe of Me.values())
              (tt = Xe.onError) == null || tt.call(Xe, Be);
            Ne.clear(), Me.clear(), ae && _e < ye && setTimeout(async () => {
              _e++, ze = await He().catch(console.error);
            }, ge);
          },
          onOpen() {
            Be = void 0, _e = 0;
          },
          onResponse(Ze) {
            const qe = Ze.method === "eth_subscription", tt = qe ? Ze.params.subscription : Ze.id, Xe = qe ? Me : Ne, ot = Xe.get(tt);
            ot && ot.onResponse(Ze), qe || Xe.delete(tt);
          }
        });
      }
      return ze = await He(), Be = void 0, we = {
        close() {
          ze.close(), socketClientCache.delete(fe);
        },
        socket: ze,
        request({ body: Ze, onError: qe, onResponse: tt }) {
          Be && qe && qe(Be);
          const Xe = Ze.id ?? idCache.take(), ot = (pt) => {
            var ht;
            typeof pt.id == "number" && Xe !== pt.id || (Ze.method === "eth_subscribe" && typeof pt.result == "string" && Me.set(pt.result, {
              onResponse: ot,
              onError: qe
            }), Ze.method === "eth_unsubscribe" && Me.delete((ht = Ze.params) == null ? void 0 : ht[0]), tt(pt));
          };
          Ne.set(Xe, { onResponse: ot, onError: qe });
          try {
            ze.request({
              body: {
                jsonrpc: "2.0",
                id: Xe,
                ...Ze
              }
            });
          } catch (pt) {
            qe == null || qe(pt);
          }
        },
        requestAsync({ body: Ze, timeout: qe = 1e4 }) {
          return withTimeout(() => new Promise((tt, Xe) => this.request({
            body: Ze,
            onError: Xe,
            onResponse: tt
          })), {
            errorInstance: new TimeoutError$1({ body: Ze, url: fe }),
            timeout: qe
          });
        },
        requests: Ne,
        subscriptions: Me,
        url: fe
      }, socketClientCache.set(fe, we), [we];
    }
  }), [Ie, [$e]] = await Se();
  return $e;
}
async function getWebSocketRpcClient(ne, oe = {}) {
  const { reconnect: ae } = oe;
  return getSocketRpcClient({
    async getSocket({ onError: fe, onOpen: ye, onResponse: ge }) {
      const we = await import("./native-15074a2a.js").then((Ne) => Ne.WebSocket), _e = new we(ne);
      function Se() {
        _e.removeEventListener("close", Se), _e.removeEventListener("message", Ie), _e.removeEventListener("error", fe), _e.removeEventListener("open", ye);
      }
      function Ie({ data: Ne }) {
        ge(JSON.parse(Ne));
      }
      _e.addEventListener("close", Se), _e.addEventListener("message", Ie), _e.addEventListener("error", fe), _e.addEventListener("open", ye), _e.readyState === we.CONNECTING && await new Promise((Ne, Me) => {
        _e && (_e.onopen = Ne, _e.onerror = Me);
      });
      const { close: $e } = _e;
      return Object.assign(_e, {
        close() {
          $e.bind(_e)(), Se();
        },
        request({ body: Ne }) {
          if (_e.readyState === _e.CLOSED || _e.readyState === _e.CLOSING)
            throw new WebSocketRequestError({
              body: Ne,
              url: _e.url,
              details: "Socket is closed."
            });
          return _e.send(JSON.stringify(Ne));
        }
      });
    },
    reconnect: ae,
    url: ne
  });
}
async function getSocket(ne) {
  const oe = await getWebSocketRpcClient(ne);
  return Object.assign(oe.socket, {
    requests: oe.requests,
    subscriptions: oe.subscriptions
  });
}
function hashTypedData(ne) {
  const { domain: oe = {}, message: ae, primaryType: fe } = ne, ye = {
    EIP712Domain: getTypesForEIP712Domain({ domain: oe }),
    ...ne.types
  };
  validateTypedData({
    domain: oe,
    message: ae,
    primaryType: fe,
    types: ye
  });
  const ge = ["0x1901"];
  return oe && ge.push(hashDomain({
    domain: oe,
    types: ye
  })), fe !== "EIP712Domain" && ge.push(hashStruct({
    data: ae,
    primaryType: fe,
    types: ye
  })), keccak256(concat$1(ge));
}
function hashDomain({ domain: ne, types: oe }) {
  return hashStruct({
    data: ne,
    primaryType: "EIP712Domain",
    types: oe
  });
}
function hashStruct({ data: ne, primaryType: oe, types: ae }) {
  const fe = encodeData({
    data: ne,
    primaryType: oe,
    types: ae
  });
  return keccak256(fe);
}
function encodeData({ data: ne, primaryType: oe, types: ae }) {
  const fe = [{ type: "bytes32" }], ye = [hashType({ primaryType: oe, types: ae })];
  for (const ge of ae[oe]) {
    const [we, _e] = encodeField({
      types: ae,
      name: ge.name,
      type: ge.type,
      value: ne[ge.name]
    });
    fe.push(we), ye.push(_e);
  }
  return encodeAbiParameters(fe, ye);
}
function hashType({ primaryType: ne, types: oe }) {
  const ae = toHex(encodeType({ primaryType: ne, types: oe }));
  return keccak256(ae);
}
function encodeType({ primaryType: ne, types: oe }) {
  let ae = "";
  const fe = findTypeDependencies({ primaryType: ne, types: oe });
  fe.delete(ne);
  const ye = [ne, ...Array.from(fe).sort()];
  for (const ge of ye)
    ae += `${ge}(${oe[ge].map(({ name: we, type: _e }) => `${_e} ${we}`).join(",")})`;
  return ae;
}
function findTypeDependencies({ primaryType: ne, types: oe }, ae = /* @__PURE__ */ new Set()) {
  const fe = ne.match(/^\w*/u), ye = fe == null ? void 0 : fe[0];
  if (ae.has(ye) || oe[ye] === void 0)
    return ae;
  ae.add(ye);
  for (const ge of oe[ye])
    findTypeDependencies({ primaryType: ge.type, types: oe }, ae);
  return ae;
}
function encodeField({ types: ne, name: oe, type: ae, value: fe }) {
  if (ne[ae] !== void 0)
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: fe, primaryType: ae, types: ne }))
    ];
  if (ae === "bytes")
    return fe = `0x${(fe.length % 2 ? "0" : "") + fe.slice(2)}`, [{ type: "bytes32" }, keccak256(fe)];
  if (ae === "string")
    return [{ type: "bytes32" }, keccak256(toHex(fe))];
  if (ae.lastIndexOf("]") === ae.length - 1) {
    const ye = ae.slice(0, ae.lastIndexOf("[")), ge = fe.map((we) => encodeField({
      name: oe,
      type: ye,
      types: ne,
      value: we
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(ge.map(([we]) => we), ge.map(([, we]) => we)))
    ];
  }
  return [{ type: ae }, fe];
}
function validateTypedData(ne) {
  const { domain: oe, message: ae, primaryType: fe, types: ye } = ne, ge = (we, _e) => {
    for (const Se of we) {
      const { name: Ie, type: $e } = Se, Ne = _e[Ie], Me = $e.match(integerRegex);
      if (Me && (typeof Ne == "number" || typeof Ne == "bigint")) {
        const [He, Ze, qe] = Me;
        numberToHex(Ne, {
          signed: Ze === "int",
          size: parseInt(qe) / 8
        });
      }
      if ($e === "address" && typeof Ne == "string" && !isAddress(Ne))
        throw new InvalidAddressError({ address: Ne });
      const Be = $e.match(bytesRegex);
      if (Be) {
        const [He, Ze] = Be;
        if (Ze && size$1(Ne) !== parseInt(Ze))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(Ze),
            givenSize: size$1(Ne)
          });
      }
      const ze = ye[$e];
      ze && ge(ze, Ne);
    }
  };
  if (ye.EIP712Domain && oe && ge(ye.EIP712Domain, oe), fe !== "EIP712Domain") {
    const we = ye[fe];
    ge(we, ae);
  }
}
function getTypesForEIP712Domain({ domain: ne }) {
  return [
    typeof (ne == null ? void 0 : ne.name) == "string" && { name: "name", type: "string" },
    (ne == null ? void 0 : ne.version) && { name: "version", type: "string" },
    typeof (ne == null ? void 0 : ne.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (ne == null ? void 0 : ne.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (ne == null ? void 0 : ne.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData(ne) {
  const { abi: oe, args: ae, bytecode: fe } = ne;
  if (!ae || ae.length === 0)
    return fe;
  const ye = oe.find((we) => "type" in we && we.type === "constructor");
  if (!ye)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in ye))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!ye.inputs || ye.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const ge = encodeAbiParameters(ye.inputs, ae);
  return concatHex([fe, ge]);
}
function encodePacked(ne, oe) {
  if (ne.length !== oe.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: ne.length,
      givenLength: oe.length
    });
  const ae = [];
  for (let fe = 0; fe < ne.length; fe++) {
    const ye = ne[fe], ge = oe[fe];
    ae.push(encode(ye, ge));
  }
  return concatHex(ae);
}
function encode(ne, oe, ae = !1) {
  if (ne === "address") {
    const we = oe;
    if (!isAddress(we))
      throw new InvalidAddressError({ address: we });
    return pad(we.toLowerCase(), {
      size: ae ? 32 : null
    });
  }
  if (ne === "string")
    return stringToHex(oe);
  if (ne === "bytes")
    return oe;
  if (ne === "bool")
    return pad(boolToHex(oe), { size: ae ? 32 : 1 });
  const fe = ne.match(integerRegex);
  if (fe) {
    const [we, _e, Se = "256"] = fe, Ie = parseInt(Se) / 8;
    return numberToHex(oe, {
      size: ae ? 32 : Ie,
      signed: _e === "int"
    });
  }
  const ye = ne.match(bytesRegex);
  if (ye) {
    const [we, _e] = ye;
    if (parseInt(_e) !== (oe.length - 2) / 2)
      throw new BytesSizeMismatchError({
        expectedSize: parseInt(_e),
        givenSize: (oe.length - 2) / 2
      });
    return pad(oe, { dir: "right", size: ae ? 32 : null });
  }
  const ge = ne.match(arrayRegex);
  if (ge && Array.isArray(oe)) {
    const [we, _e] = ge, Se = [];
    for (let Ie = 0; Ie < oe.length; Ie++)
      Se.push(encode(_e, oe[Ie], !0));
    return Se.length === 0 ? "0x" : concatHex(Se);
  }
  throw new UnsupportedPackedAbiType(ne);
}
function toRlp(ne, oe = "hex") {
  const ae = getEncodable(ne), fe = createCursor(new Uint8Array(ae.length));
  return ae.encode(fe), oe === "hex" ? bytesToHex$1(fe.bytes) : fe.bytes;
}
function getEncodable(ne) {
  return Array.isArray(ne) ? getEncodableList(ne.map((oe) => getEncodable(oe))) : getEncodableBytes(ne);
}
function getEncodableList(ne) {
  const oe = ne.reduce((ye, ge) => ye + ge.length, 0), ae = getSizeOfLength(oe);
  return {
    length: (() => oe <= 55 ? 1 + oe : 1 + ae + oe)(),
    encode(ye) {
      oe <= 55 ? ye.pushByte(192 + oe) : (ye.pushByte(192 + 55 + ae), ae === 1 ? ye.pushUint8(oe) : ae === 2 ? ye.pushUint16(oe) : ae === 3 ? ye.pushUint24(oe) : ye.pushUint32(oe));
      for (const { encode: ge } of ne)
        ge(ye);
    }
  };
}
function getEncodableBytes(ne) {
  const oe = typeof ne == "string" ? hexToBytes$1(ne) : ne, ae = getSizeOfLength(oe.length);
  return {
    length: (() => oe.length === 1 && oe[0] < 128 ? 1 : oe.length <= 55 ? 1 + oe.length : 1 + ae + oe.length)(),
    encode(ye) {
      oe.length === 1 && oe[0] < 128 ? ye.pushBytes(oe) : oe.length <= 55 ? (ye.pushByte(128 + oe.length), ye.pushBytes(oe)) : (ye.pushByte(128 + 55 + ae), ae === 1 ? ye.pushUint8(oe.length) : ae === 2 ? ye.pushUint16(oe.length) : ae === 3 ? ye.pushUint24(oe.length) : ye.pushUint32(oe.length), ye.pushBytes(oe));
    }
  };
}
function getSizeOfLength(ne) {
  if (ne < 2 ** 8)
    return 1;
  if (ne < 2 ** 16)
    return 2;
  if (ne < 2 ** 24)
    return 3;
  if (ne < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(ne) {
  const oe = {
    ...ne,
    blockNumber: ne.blockNumber ? BigInt(ne.blockNumber) : null,
    contractAddress: ne.contractAddress ? ne.contractAddress : null,
    cumulativeGasUsed: ne.cumulativeGasUsed ? BigInt(ne.cumulativeGasUsed) : null,
    effectiveGasPrice: ne.effectiveGasPrice ? BigInt(ne.effectiveGasPrice) : null,
    gasUsed: ne.gasUsed ? BigInt(ne.gasUsed) : null,
    logs: ne.logs ? ne.logs.map((ae) => formatLog(ae)) : null,
    to: ne.to ? ne.to : null,
    transactionIndex: ne.transactionIndex ? hexToNumber$1(ne.transactionIndex) : null,
    status: ne.status ? receiptStatuses[ne.status] : null,
    type: ne.type ? transactionType[ne.type] || ne.type : null
  };
  return ne.blobGasPrice && (oe.blobGasPrice = BigInt(ne.blobGasPrice)), ne.blobGasUsed && (oe.blobGasUsed = BigInt(ne.blobGasUsed)), oe;
}
const defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt), presignMessagePrefix = `Ethereum Signed Message:
`;
function hashMessage(ne, oe) {
  const ae = (() => typeof ne == "string" ? stringToBytes(ne) : ne.raw instanceof Uint8Array ? ne.raw : toBytes$1(ne.raw))(), fe = stringToBytes(`${presignMessagePrefix}${ae.length}`);
  return keccak256(concat$1([fe, ae]), oe);
}
function assertTransactionEIP4844(ne) {
  const { blobVersionedHashes: oe } = ne;
  if (oe) {
    if (oe.length === 0)
      throw new EmptyBlobError();
    for (const ae of oe) {
      const fe = size$1(ae), ye = hexToNumber$1(slice(ae, 0, 1));
      if (fe !== 32)
        throw new InvalidVersionedHashSizeError({ hash: ae, size: fe });
      if (ye !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash: ae,
          version: ye
        });
    }
  }
  assertTransactionEIP1559(ne);
}
function assertTransactionEIP1559(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, maxFeePerGas: fe, to: ye } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ye && !isAddress(ye))
    throw new InvalidAddressError({ address: ye });
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (ae && fe && ae > fe)
    throw new TipAboveFeeCapError({ maxFeePerGas: fe, maxPriorityFeePerGas: ae });
}
function assertTransactionEIP2930(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: ge } = ne;
  if (oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ge && !isAddress(ge))
    throw new InvalidAddressError({ address: ge });
  if (ae || ye)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
}
function assertTransactionLegacy(ne) {
  const { chainId: oe, maxPriorityFeePerGas: ae, gasPrice: fe, maxFeePerGas: ye, to: ge, accessList: we } = ne;
  if (ge && !isAddress(ge))
    throw new InvalidAddressError({ address: ge });
  if (typeof oe < "u" && oe <= 0)
    throw new InvalidChainIdError({ chainId: oe });
  if (ae || ye)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (fe && fe > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: fe });
  if (we)
    throw new BaseError("`accessList` is not a valid Legacy Transaction attribute.");
}
function serializeAccessList(ne) {
  if (!ne || ne.length === 0)
    return [];
  const oe = [];
  for (let ae = 0; ae < ne.length; ae++) {
    const { address: fe, storageKeys: ye } = ne[ae];
    for (let ge = 0; ge < ye.length; ge++)
      if (ye[ge].length - 2 !== 64)
        throw new InvalidStorageKeySizeError({ storageKey: ye[ge] });
    if (!isAddress(fe, { strict: !1 }))
      throw new InvalidAddressError({ address: fe });
    oe.push([fe, ye]);
  }
  return oe;
}
function serializeTransaction$1(ne, oe) {
  const ae = getTransactionType(ne);
  return ae === "eip1559" ? serializeTransactionEIP1559(ne, oe) : ae === "eip2930" ? serializeTransactionEIP2930(ne, oe) : ae === "eip4844" ? serializeTransactionEIP4844(ne, oe) : serializeTransactionLegacy(ne, oe);
}
function serializeTransactionEIP4844(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: ge, value: we, maxFeePerBlobGas: _e, maxFeePerGas: Se, maxPriorityFeePerGas: Ie, accessList: $e, data: Ne } = ne;
  assertTransactionEIP4844(ne);
  let Me = ne.blobVersionedHashes, Be = ne.sidecars;
  if (ne.blobs && (typeof Me > "u" || typeof Be > "u")) {
    const Xe = typeof ne.blobs[0] == "string" ? ne.blobs : ne.blobs.map((ht) => bytesToHex$1(ht)), ot = ne.kzg, pt = blobsToCommitments({
      blobs: Xe,
      kzg: ot
    });
    if (typeof Me > "u" && (Me = commitmentsToVersionedHashes({
      commitments: pt
    })), typeof Be > "u") {
      const ht = blobsToProofs({ blobs: Xe, commitments: pt, kzg: ot });
      Be = toBlobSidecars({ blobs: Xe, commitments: pt, proofs: ht });
    }
  }
  const ze = serializeAccessList($e), He = [
    toHex(ae),
    ye ? toHex(ye) : "0x",
    Ie ? toHex(Ie) : "0x",
    Se ? toHex(Se) : "0x",
    fe ? toHex(fe) : "0x",
    ge ?? "0x",
    we ? toHex(we) : "0x",
    Ne ?? "0x",
    ze,
    _e ? toHex(_e) : "0x",
    Me ?? [],
    ...toYParitySignatureArray(ne, oe)
  ], Ze = [], qe = [], tt = [];
  if (Be)
    for (let Xe = 0; Xe < Be.length; Xe++) {
      const { blob: ot, commitment: pt, proof: ht } = Be[Xe];
      Ze.push(ot), qe.push(pt), tt.push(ht);
    }
  return concatHex([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    toRlp(Be ? [He, Ze, qe, tt] : He)
  ]);
}
function serializeTransactionEIP1559(ne, oe) {
  const { chainId: ae, gas: fe, nonce: ye, to: ge, value: we, maxFeePerGas: _e, maxPriorityFeePerGas: Se, accessList: Ie, data: $e } = ne;
  assertTransactionEIP1559(ne);
  const Ne = serializeAccessList(Ie), Me = [
    toHex(ae),
    ye ? toHex(ye) : "0x",
    Se ? toHex(Se) : "0x",
    _e ? toHex(_e) : "0x",
    fe ? toHex(fe) : "0x",
    ge ?? "0x",
    we ? toHex(we) : "0x",
    $e ?? "0x",
    Ne,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex([
    "0x02",
    toRlp(Me)
  ]);
}
function serializeTransactionEIP2930(ne, oe) {
  const { chainId: ae, gas: fe, data: ye, nonce: ge, to: we, value: _e, accessList: Se, gasPrice: Ie } = ne;
  assertTransactionEIP2930(ne);
  const $e = serializeAccessList(Se), Ne = [
    toHex(ae),
    ge ? toHex(ge) : "0x",
    Ie ? toHex(Ie) : "0x",
    fe ? toHex(fe) : "0x",
    we ?? "0x",
    _e ? toHex(_e) : "0x",
    ye ?? "0x",
    $e,
    ...toYParitySignatureArray(ne, oe)
  ];
  return concatHex([
    "0x01",
    toRlp(Ne)
  ]);
}
function serializeTransactionLegacy(ne, oe) {
  const { chainId: ae = 0, gas: fe, data: ye, nonce: ge, to: we, value: _e, gasPrice: Se } = ne;
  assertTransactionLegacy(ne);
  let Ie = [
    ge ? toHex(ge) : "0x",
    Se ? toHex(Se) : "0x",
    fe ? toHex(fe) : "0x",
    we ?? "0x",
    _e ? toHex(_e) : "0x",
    ye ?? "0x"
  ];
  if (oe) {
    const $e = (() => {
      if (oe.v >= 35n)
        return (oe.v - 35n) / 2n > 0 ? oe.v : 27n + (oe.v === 35n ? 0n : 1n);
      if (ae > 0)
        return BigInt(ae * 2) + BigInt(35n + oe.v - 27n);
      const Ne = 27n + (oe.v === 27n ? 0n : 1n);
      if (oe.v !== Ne)
        throw new InvalidLegacyVError({ v: oe.v });
      return Ne;
    })();
    Ie = [
      ...Ie,
      toHex($e),
      oe.r,
      oe.s
    ];
  } else
    ae > 0 && (Ie = [
      ...Ie,
      toHex(ae),
      "0x",
      "0x"
    ]);
  return toRlp(Ie);
}
function toYParitySignatureArray(ne, oe) {
  const { r: ae, s: fe, v: ye, yParity: ge } = oe ?? ne;
  return typeof ae > "u" ? [] : typeof fe > "u" ? [] : typeof ye > "u" && typeof ge > "u" ? [] : [(() => typeof ge == "number" ? ge ? toHex(1) : "0x" : ye === 0n ? "0x" : ye === 1n ? toHex(1) : ye === 27n ? "0x" : toHex(1))(), trim(ae), trim(fe)];
}
function parseUnits(ne, oe) {
  let [ae, fe = "0"] = ne.split(".");
  const ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    const [ge, we, _e] = [
      fe.slice(0, oe - 1),
      fe.slice(oe - 1, oe),
      fe.slice(oe)
    ], Se = Math.round(+`${we}.${_e}`);
    Se > 9 ? fe = `${BigInt(ge) + BigInt(1)}0`.padStart(ge.length + 1, "0") : fe = `${ge}${Se}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
function parseEther(ne, oe = "wei") {
  return parseUnits(ne, etherUnits[oe]);
}
function formatStorageProof(ne) {
  return ne.map((oe) => ({
    ...oe,
    value: BigInt(oe.value)
  }));
}
function formatProof(ne) {
  return {
    ...ne,
    balance: ne.balance ? BigInt(ne.balance) : void 0,
    nonce: ne.nonce ? hexToNumber$1(ne.nonce) : void 0,
    storageProof: ne.storageProof ? formatStorageProof(ne.storageProof) : void 0
  };
}
async function getProof(ne, { address: oe, blockNumber: ae, blockTag: fe, storageKeys: ye }) {
  const ge = fe ?? "latest", we = ae !== void 0 ? numberToHex(ae) : void 0, _e = await ne.request({
    method: "eth_getProof",
    params: [oe, ye, we || ge]
  });
  return formatProof(_e);
}
async function getStorageAt(ne, { address: oe, blockNumber: ae, blockTag: fe = "latest", slot: ye }) {
  const ge = ae !== void 0 ? numberToHex(ae) : void 0;
  return await ne.request({
    method: "eth_getStorageAt",
    params: [oe, ye, ge || fe]
  });
}
async function getTransaction(ne, { blockHash: oe, blockNumber: ae, blockTag: fe, hash: ye, index: ge }) {
  var $e, Ne, Me;
  const we = fe || "latest", _e = ae !== void 0 ? numberToHex(ae) : void 0;
  let Se = null;
  if (ye ? Se = await ne.request({
    method: "eth_getTransactionByHash",
    params: [ye]
  }) : oe ? Se = await ne.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [oe, numberToHex(ge)]
  }) : (_e || we) && (Se = await ne.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [_e || we, numberToHex(ge)]
  })), !Se)
    throw new TransactionNotFoundError({
      blockHash: oe,
      blockNumber: ae,
      blockTag: we,
      hash: ye,
      index: ge
    });
  return (((Me = (Ne = ($e = ne.chain) == null ? void 0 : $e.formatters) == null ? void 0 : Ne.transaction) == null ? void 0 : Me.format) || formatTransaction)(Se);
}
async function getTransactionConfirmations(ne, { hash: oe, transactionReceipt: ae }) {
  const [fe, ye] = await Promise.all([
    getAction(ne, getBlockNumber, "getBlockNumber")({}),
    oe ? getAction(ne, getTransaction, "getBlockNumber")({ hash: oe }) : void 0
  ]), ge = (ae == null ? void 0 : ae.blockNumber) || (ye == null ? void 0 : ye.blockNumber);
  return ge ? fe - ge + 1n : 0n;
}
async function getTransactionReceipt(ne, { hash: oe }) {
  var ye, ge, we;
  const ae = await ne.request({
    method: "eth_getTransactionReceipt",
    params: [oe]
  });
  if (!ae)
    throw new TransactionReceiptNotFoundError({ hash: oe });
  return (((we = (ge = (ye = ne.chain) == null ? void 0 : ye.formatters) == null ? void 0 : ge.transactionReceipt) == null ? void 0 : we.format) || formatTransactionReceipt)(ae);
}
async function multicall(ne, oe) {
  var Ze;
  const { allowFailure: ae = !0, batchSize: fe, blockNumber: ye, blockTag: ge, multicallAddress: we, stateOverride: _e } = oe, Se = oe.contracts, Ie = fe ?? (typeof ((Ze = ne.batch) == null ? void 0 : Ze.multicall) == "object" && ne.batch.multicall.batchSize || 1024);
  let $e = we;
  if (!$e) {
    if (!ne.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    $e = getChainContractAddress({
      blockNumber: ye,
      chain: ne.chain,
      contract: "multicall3"
    });
  }
  const Ne = [[]];
  let Me = 0, Be = 0;
  for (let qe = 0; qe < Se.length; qe++) {
    const { abi: tt, address: Xe, args: ot, functionName: pt } = Se[qe];
    try {
      const ht = encodeFunctionData({ abi: tt, args: ot, functionName: pt });
      Be += (ht.length - 2) / 2, // Check if batching is enabled.
      Ie > 0 && // Check if the current size of the batch exceeds the size limit.
      Be > Ie && // Check if the current chunk is not already empty.
      Ne[Me].length > 0 && (Me++, Be = (ht.length - 2) / 2, Ne[Me] = []), Ne[Me] = [
        ...Ne[Me],
        {
          allowFailure: !0,
          callData: ht,
          target: Xe
        }
      ];
    } catch (ht) {
      const wt = getContractError(ht, {
        abi: tt,
        address: Xe,
        args: ot,
        docsPath: "/docs/contract/multicall",
        functionName: pt
      });
      if (!ae)
        throw wt;
      Ne[Me] = [
        ...Ne[Me],
        {
          allowFailure: !0,
          callData: "0x",
          target: Xe
        }
      ];
    }
  }
  const ze = await Promise.allSettled(Ne.map((qe) => getAction(ne, readContract, "readContract")({
    abi: multicall3Abi,
    address: $e,
    args: [qe],
    blockNumber: ye,
    blockTag: ge,
    functionName: "aggregate3",
    stateOverride: _e
  }))), He = [];
  for (let qe = 0; qe < ze.length; qe++) {
    const tt = ze[qe];
    if (tt.status === "rejected") {
      if (!ae)
        throw tt.reason;
      for (let ot = 0; ot < Ne[qe].length; ot++)
        He.push({
          status: "failure",
          error: tt.reason,
          result: void 0
        });
      continue;
    }
    const Xe = tt.value;
    for (let ot = 0; ot < Xe.length; ot++) {
      const { returnData: pt, success: ht } = Xe[ot], { callData: wt } = Ne[qe][ot], { abi: gt, address: It, functionName: Nt, args: Ft } = Se[He.length];
      try {
        if (wt === "0x")
          throw new AbiDecodingZeroDataError();
        if (!ht)
          throw new RawContractError({ data: pt });
        const on = decodeFunctionResult({
          abi: gt,
          args: Ft,
          data: pt,
          functionName: Nt
        });
        He.push(ae ? { result: on, status: "success" } : on);
      } catch (on) {
        const en = getContractError(on, {
          abi: gt,
          address: It,
          args: Ft,
          docsPath: "/docs/contract/multicall",
          functionName: Nt
        });
        if (!ae)
          throw en;
        He.push({ error: en, result: void 0, status: "failure" });
      }
    }
  }
  if (He.length !== Se.length)
    throw new BaseError("multicall results mismatch");
  return He;
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), u8a = (ne) => ne instanceof Uint8Array, hexes = /* @__PURE__ */ Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0"));
function bytesToHex(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  let oe = "";
  for (let ae = 0; ae < ne.length; ae++)
    oe += hexes[ne[ae]];
  return oe;
}
function numberToHexUnpadded(ne) {
  const oe = ne.toString(16);
  return oe.length & 1 ? `0${oe}` : oe;
}
function hexToNumber(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  return BigInt(ne === "" ? "0" : `0x${ne}`);
}
function hexToBytes(ne) {
  if (typeof ne != "string")
    throw new Error("hex string expected, got " + typeof ne);
  const oe = ne.length;
  if (oe % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + oe);
  const ae = new Uint8Array(oe / 2);
  for (let fe = 0; fe < ae.length; fe++) {
    const ye = fe * 2, ge = ne.slice(ye, ye + 2), we = Number.parseInt(ge, 16);
    if (Number.isNaN(we) || we < 0)
      throw new Error("Invalid byte sequence");
    ae[fe] = we;
  }
  return ae;
}
function bytesToNumberBE(ne) {
  return hexToNumber(bytesToHex(ne));
}
function bytesToNumberLE(ne) {
  if (!u8a(ne))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(ne).reverse()));
}
function numberToBytesBE(ne, oe) {
  return hexToBytes(ne.toString(16).padStart(oe * 2, "0"));
}
function numberToBytesLE(ne, oe) {
  return numberToBytesBE(ne, oe).reverse();
}
function numberToVarBytesBE(ne) {
  return hexToBytes(numberToHexUnpadded(ne));
}
function ensureBytes(ne, oe, ae) {
  let fe;
  if (typeof oe == "string")
    try {
      fe = hexToBytes(oe);
    } catch (ge) {
      throw new Error(`${ne} must be valid hex string, got "${oe}". Cause: ${ge}`);
    }
  else if (u8a(oe))
    fe = Uint8Array.from(oe);
  else
    throw new Error(`${ne} must be hex string or Uint8Array`);
  const ye = fe.length;
  if (typeof ae == "number" && ye !== ae)
    throw new Error(`${ne} expected ${ae} bytes, got ${ye}`);
  return fe;
}
function concatBytes(...ne) {
  const oe = new Uint8Array(ne.reduce((fe, ye) => fe + ye.length, 0));
  let ae = 0;
  return ne.forEach((fe) => {
    if (!u8a(fe))
      throw new Error("Uint8Array expected");
    oe.set(fe, ae), ae += fe.length;
  }), oe;
}
function equalBytes(ne, oe) {
  if (ne.length !== oe.length)
    return !1;
  for (let ae = 0; ae < ne.length; ae++)
    if (ne[ae] !== oe[ae])
      return !1;
  return !0;
}
function utf8ToBytes(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function bitLen(ne) {
  let oe;
  for (oe = 0; ne > _0n$3; ne >>= _1n$4, oe += 1)
    ;
  return oe;
}
function bitGet(ne, oe) {
  return ne >> BigInt(oe) & _1n$4;
}
const bitSet = (ne, oe, ae) => ne | (ae ? _1n$4 : _0n$3) << BigInt(oe), bitMask = (ne) => (_2n$2 << BigInt(ne - 1)) - _1n$4, u8n = (ne) => new Uint8Array(ne), u8fr = (ne) => Uint8Array.from(ne);
function createHmacDrbg(ne, oe, ae) {
  if (typeof ne != "number" || ne < 2)
    throw new Error("hashLen must be a number");
  if (typeof oe != "number" || oe < 2)
    throw new Error("qByteLen must be a number");
  if (typeof ae != "function")
    throw new Error("hmacFn must be a function");
  let fe = u8n(ne), ye = u8n(ne), ge = 0;
  const we = () => {
    fe.fill(1), ye.fill(0), ge = 0;
  }, _e = (...Ne) => ae(ye, fe, ...Ne), Se = (Ne = u8n()) => {
    ye = _e(u8fr([0]), Ne), fe = _e(), Ne.length !== 0 && (ye = _e(u8fr([1]), Ne), fe = _e());
  }, Ie = () => {
    if (ge++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let Ne = 0;
    const Me = [];
    for (; Ne < oe; ) {
      fe = _e();
      const Be = fe.slice();
      Me.push(Be), Ne += fe.length;
    }
    return concatBytes(...Me);
  };
  return (Ne, Me) => {
    we(), Se(Ne);
    let Be;
    for (; !(Be = Me(Ie())); )
      Se();
    return we(), Be;
  };
}
const validatorFns = {
  bigint: (ne) => typeof ne == "bigint",
  function: (ne) => typeof ne == "function",
  boolean: (ne) => typeof ne == "boolean",
  string: (ne) => typeof ne == "string",
  stringOrUint8Array: (ne) => typeof ne == "string" || ne instanceof Uint8Array,
  isSafeInteger: (ne) => Number.isSafeInteger(ne),
  array: (ne) => Array.isArray(ne),
  field: (ne, oe) => oe.Fp.isValid(ne),
  hash: (ne) => typeof ne == "function" && Number.isSafeInteger(ne.outputLen)
};
function validateObject(ne, oe, ae = {}) {
  const fe = (ye, ge, we) => {
    const _e = validatorFns[ge];
    if (typeof _e != "function")
      throw new Error(`Invalid validator "${ge}", expected function`);
    const Se = ne[ye];
    if (!(we && Se === void 0) && !_e(Se, ne))
      throw new Error(`Invalid param ${String(ye)}=${Se} (${typeof Se}), expected ${ge}`);
  };
  for (const [ye, ge] of Object.entries(oe))
    fe(ye, ge, !1);
  for (const [ye, ge] of Object.entries(ae))
    fe(ye, ge, !0);
  return ne;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual(ne, oe) {
  const ae = isHex(ne) ? toBytes$1(ne) : ne, fe = isHex(oe) ? toBytes$1(oe) : oe;
  return equalBytes(ae, fe);
}
async function verifyHash(ne, { address: oe, hash: ae, signature: fe, ...ye }) {
  const ge = isHex(fe) ? fe : toHex(fe);
  try {
    const { data: we } = await getAction(ne, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [oe, ae, ge],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...ye
    });
    return isBytesEqual(we ?? "0x0", "0x1");
  } catch (we) {
    if (we instanceof CallExecutionError)
      return !1;
    throw we;
  }
}
async function verifyMessage(ne, { address: oe, message: ae, signature: fe, ...ye }) {
  const ge = hashMessage(ae);
  return verifyHash(ne, {
    address: oe,
    hash: ge,
    signature: fe,
    ...ye
  });
}
async function verifyTypedData(ne, oe) {
  const { address: ae, signature: fe, message: ye, primaryType: ge, types: we, domain: _e, ...Se } = oe, Ie = hashTypedData({ message: ye, primaryType: ge, types: we, domain: _e });
  return verifyHash(ne, {
    address: ae,
    hash: Ie,
    signature: fe,
    ...Se
  });
}
function watchBlockNumber(ne, { emitOnBegin: oe = !1, emitMissed: ae = !1, onBlockNumber: fe, onError: ye, poll: ge, pollingInterval: we = ne.pollingInterval }) {
  const _e = typeof ge < "u" ? ge : ne.transport.type !== "webSocket";
  let Se;
  return _e ? (() => {
    const Ne = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae,
      we
    ]);
    return observe(Ne, { onBlockNumber: fe, onError: ye }, (Me) => poll(async () => {
      var Be;
      try {
        const ze = await getAction(ne, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (Se) {
          if (ze === Se)
            return;
          if (ze - Se > 1 && ae)
            for (let He = Se + 1n; He < ze; He++)
              Me.onBlockNumber(He, Se), Se = He;
        }
        (!Se || ze > Se) && (Me.onBlockNumber(ze, Se), Se = ze);
      } catch (ze) {
        (Be = Me.onError) == null || Be.call(Me, ze);
      }
    }, {
      emitOnBegin: oe,
      interval: we
    }));
  })() : (() => {
    const Ne = stringify([
      "watchBlockNumber",
      ne.uid,
      oe,
      ae
    ]);
    return observe(Ne, { onBlockNumber: fe, onError: ye }, (Me) => {
      let Be = !0, ze = () => Be = !1;
      return (async () => {
        try {
          const { unsubscribe: He } = await ne.transport.subscribe({
            params: ["newHeads"],
            onData(Ze) {
              var tt;
              if (!Be)
                return;
              const qe = hexToBigInt((tt = Ze.result) == null ? void 0 : tt.number);
              Me.onBlockNumber(qe, Se), Se = qe;
            },
            onError(Ze) {
              var qe;
              (qe = Me.onError) == null || qe.call(Me, Ze);
            }
          });
          ze = He, Be || ze();
        } catch (He) {
          ye == null || ye(He);
        }
      })(), () => ze();
    });
  })();
}
async function waitForTransactionReceipt(ne, {
  confirmations: oe = 1,
  hash: ae,
  onReplaced: fe,
  pollingInterval: ye = ne.pollingInterval,
  retryCount: ge = 6,
  retryDelay: we = ({ count: Se }) => ~~(1 << Se) * 200,
  // exponential backoff
  timeout: _e
}) {
  const Se = stringify(["waitForTransactionReceipt", ne.uid, ae]);
  let Ie, $e, Ne, Me = !1;
  return new Promise((Be, ze) => {
    _e && setTimeout(() => ze(new WaitForTransactionReceiptTimeoutError({ hash: ae })), _e);
    const He = observe(Se, { onReplaced: fe, resolve: Be, reject: ze }, (Ze) => {
      const qe = getAction(ne, watchBlockNumber, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: ye,
        async onBlockNumber(tt) {
          if (Me)
            return;
          let Xe = tt;
          const ot = (pt) => {
            qe(), pt(), He();
          };
          try {
            if (Ne) {
              if (oe > 1 && (!Ne.blockNumber || Xe - Ne.blockNumber + 1n < oe))
                return;
              ot(() => Ze.resolve(Ne));
              return;
            }
            if (Ie || (Me = !0, await withRetry(async () => {
              Ie = await getAction(ne, getTransaction, "getTransaction")({ hash: ae }), Ie.blockNumber && (Xe = Ie.blockNumber);
            }, {
              delay: we,
              retryCount: ge
            }), Me = !1), Ne = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({ hash: ae }), oe > 1 && (!Ne.blockNumber || Xe - Ne.blockNumber + 1n < oe))
              return;
            ot(() => Ze.resolve(Ne));
          } catch (pt) {
            if (pt instanceof TransactionNotFoundError || pt instanceof TransactionReceiptNotFoundError) {
              if (!Ie) {
                Me = !1;
                return;
              }
              try {
                $e = Ie, Me = !0;
                const ht = await withRetry(() => getAction(ne, getBlock, "getBlock")({
                  blockNumber: Xe,
                  includeTransactions: !0
                }), {
                  delay: we,
                  retryCount: ge,
                  shouldRetry: ({ error: It }) => It instanceof BlockNotFoundError
                });
                Me = !1;
                const wt = ht.transactions.find(({ from: It, nonce: Nt }) => It === $e.from && Nt === $e.nonce);
                if (!wt || (Ne = await getAction(ne, getTransactionReceipt, "getTransactionReceipt")({
                  hash: wt.hash
                }), oe > 1 && (!Ne.blockNumber || Xe - Ne.blockNumber + 1n < oe)))
                  return;
                let gt = "replaced";
                wt.to === $e.to && wt.value === $e.value ? gt = "repriced" : wt.from === wt.to && wt.value === 0n && (gt = "cancelled"), ot(() => {
                  var It;
                  (It = Ze.onReplaced) == null || It.call(Ze, {
                    reason: gt,
                    replacedTransaction: $e,
                    transaction: wt,
                    transactionReceipt: Ne
                  }), Ze.resolve(Ne);
                });
              } catch (ht) {
                ot(() => Ze.reject(ht));
              }
            } else
              ot(() => Ze.reject(pt));
          }
        }
      });
    });
  });
}
function watchBlocks(ne, { blockTag: oe = "latest", emitMissed: ae = !1, emitOnBegin: fe = !1, onBlock: ye, onError: ge, includeTransactions: we, poll: _e, pollingInterval: Se = ne.pollingInterval }) {
  const Ie = typeof _e < "u" ? _e : ne.transport.type !== "webSocket", $e = we ?? !1;
  let Ne;
  return Ie ? (() => {
    const ze = stringify([
      "watchBlocks",
      ne.uid,
      oe,
      ae,
      fe,
      $e,
      Se
    ]);
    return observe(ze, { onBlock: ye, onError: ge }, (He) => poll(async () => {
      var Ze;
      try {
        const qe = await getAction(ne, getBlock, "getBlock")({
          blockTag: oe,
          includeTransactions: $e
        });
        if (qe.number && (Ne != null && Ne.number)) {
          if (qe.number === Ne.number)
            return;
          if (qe.number - Ne.number > 1 && ae)
            for (let tt = (Ne == null ? void 0 : Ne.number) + 1n; tt < qe.number; tt++) {
              const Xe = await getAction(ne, getBlock, "getBlock")({
                blockNumber: tt,
                includeTransactions: $e
              });
              He.onBlock(Xe, Ne), Ne = Xe;
            }
        }
        // If no previous block exists, emit.
        (!(Ne != null && Ne.number) || // If the block tag is "pending" with no block number, emit.
        oe === "pending" && !(qe != null && qe.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        qe.number && qe.number > Ne.number) && (He.onBlock(qe, Ne), Ne = qe);
      } catch (qe) {
        (Ze = He.onError) == null || Ze.call(He, qe);
      }
    }, {
      emitOnBegin: fe,
      interval: Se
    }));
  })() : (() => {
    let ze = !0, He = () => ze = !1;
    return (async () => {
      try {
        const { unsubscribe: Ze } = await ne.transport.subscribe({
          params: ["newHeads"],
          onData(qe) {
            var ot, pt, ht;
            if (!ze)
              return;
            const Xe = (((ht = (pt = (ot = ne.chain) == null ? void 0 : ot.formatters) == null ? void 0 : pt.block) == null ? void 0 : ht.format) || formatBlock)(qe.result);
            ye(Xe, Ne), Ne = Xe;
          },
          onError(qe) {
            ge == null || ge(qe);
          }
        });
        He = Ze, ze || He();
      } catch (Ze) {
        ge == null || ge(Ze);
      }
    })(), () => He();
  })();
}
function watchEvent(ne, { address: oe, args: ae, batch: fe = !0, event: ye, events: ge, fromBlock: we, onError: _e, onLogs: Se, poll: Ie, pollingInterval: $e = ne.pollingInterval, strict: Ne }) {
  const Me = typeof Ie < "u" ? Ie : ne.transport.type !== "webSocket" || typeof we == "bigint", Be = Ne ?? !1;
  return Me ? (() => {
    const Ze = stringify([
      "watchEvent",
      oe,
      ae,
      fe,
      ne.uid,
      ye,
      $e,
      we
    ]);
    return observe(Ze, { onLogs: Se, onError: _e }, (qe) => {
      let tt;
      we !== void 0 && (tt = we - 1n);
      let Xe, ot = !1;
      const pt = poll(async () => {
        var ht;
        if (!ot) {
          try {
            Xe = await getAction(ne, createEventFilter, "createEventFilter")({
              address: oe,
              args: ae,
              event: ye,
              events: ge,
              strict: Be,
              fromBlock: we
            });
          } catch {
          }
          ot = !0;
          return;
        }
        try {
          let wt;
          if (Xe)
            wt = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: Xe });
          else {
            const gt = await getAction(ne, getBlockNumber, "getBlockNumber")({});
            tt && tt !== gt ? wt = await getAction(ne, getLogs, "getLogs")({
              address: oe,
              args: ae,
              event: ye,
              events: ge,
              fromBlock: tt + 1n,
              toBlock: gt
            }) : wt = [], tt = gt;
          }
          if (wt.length === 0)
            return;
          if (fe)
            qe.onLogs(wt);
          else
            for (const gt of wt)
              qe.onLogs([gt]);
        } catch (wt) {
          Xe && wt instanceof InvalidInputRpcError && (ot = !1), (ht = qe.onError) == null || ht.call(qe, wt);
        }
      }, {
        emitOnBegin: !0,
        interval: $e
      });
      return async () => {
        Xe && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: Xe }), pt();
      };
    });
  })() : (() => {
    let Ze = !0, qe = () => Ze = !1;
    return (async () => {
      try {
        const tt = ge ?? (ye ? [ye] : void 0);
        let Xe = [];
        tt && (Xe = [
          tt.flatMap((pt) => encodeEventTopics({
            abi: [pt],
            eventName: pt.name,
            args: ae
          }))
        ], ye && (Xe = Xe[0]));
        const { unsubscribe: ot } = await ne.transport.subscribe({
          params: ["logs", { address: oe, topics: Xe }],
          onData(pt) {
            var wt;
            if (!Ze)
              return;
            const ht = pt.result;
            try {
              const { eventName: gt, args: It } = decodeEventLog({
                abi: tt ?? [],
                data: ht.data,
                topics: ht.topics,
                strict: Be
              }), Nt = formatLog(ht, { args: It, eventName: gt });
              Se([Nt]);
            } catch (gt) {
              let It, Nt;
              if (gt instanceof DecodeLogDataMismatch || gt instanceof DecodeLogTopicsMismatch) {
                if (Ne)
                  return;
                It = gt.abiItem.name, Nt = (wt = gt.abiItem.inputs) == null ? void 0 : wt.some((on) => !("name" in on && on.name));
              }
              const Ft = formatLog(ht, {
                args: Nt ? [] : {},
                eventName: It
              });
              Se([Ft]);
            }
          },
          onError(pt) {
            _e == null || _e(pt);
          }
        });
        qe = ot, Ze || qe();
      } catch (tt) {
        _e == null || _e(tt);
      }
    })(), () => qe();
  })();
}
function watchPendingTransactions(ne, { batch: oe = !0, onError: ae, onTransactions: fe, poll: ye, pollingInterval: ge = ne.pollingInterval }) {
  return (typeof ye < "u" ? ye : ne.transport.type !== "webSocket") ? (() => {
    const Ie = stringify([
      "watchPendingTransactions",
      ne.uid,
      oe,
      ge
    ]);
    return observe(Ie, { onTransactions: fe, onError: ae }, ($e) => {
      let Ne;
      const Me = poll(async () => {
        var Be;
        try {
          if (!Ne)
            try {
              Ne = await getAction(ne, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (He) {
              throw Me(), He;
            }
          const ze = await getAction(ne, getFilterChanges, "getFilterChanges")({ filter: Ne });
          if (ze.length === 0)
            return;
          if (oe)
            $e.onTransactions(ze);
          else
            for (const He of ze)
              $e.onTransactions([He]);
        } catch (ze) {
          (Be = $e.onError) == null || Be.call($e, ze);
        }
      }, {
        emitOnBegin: !0,
        interval: ge
      });
      return async () => {
        Ne && await getAction(ne, uninstallFilter, "uninstallFilter")({ filter: Ne }), Me();
      };
    });
  })() : (() => {
    let Ie = !0, $e = () => Ie = !1;
    return (async () => {
      try {
        const { unsubscribe: Ne } = await ne.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(Me) {
            if (!Ie)
              return;
            const Be = Me.result;
            fe([Be]);
          },
          onError(Me) {
            ae == null || ae(Me);
          }
        });
        $e = Ne, Ie || $e();
      } catch (Ne) {
        ae == null || ae(Ne);
      }
    })(), () => $e();
  })();
}
function publicActions(ne) {
  return {
    call: (oe) => call(ne, oe),
    createBlockFilter: () => createBlockFilter(ne),
    createContractEventFilter: (oe) => createContractEventFilter(ne, oe),
    createEventFilter: (oe) => createEventFilter(ne, oe),
    createPendingTransactionFilter: () => createPendingTransactionFilter(ne),
    estimateContractGas: (oe) => estimateContractGas(ne, oe),
    estimateGas: (oe) => estimateGas(ne, oe),
    getBalance: (oe) => getBalance(ne, oe),
    getBlobBaseFee: () => getBlobBaseFee(ne),
    getBlock: (oe) => getBlock(ne, oe),
    getBlockNumber: (oe) => getBlockNumber(ne, oe),
    getBlockTransactionCount: (oe) => getBlockTransactionCount(ne, oe),
    getBytecode: (oe) => getBytecode(ne, oe),
    getChainId: () => getChainId(ne),
    getContractEvents: (oe) => getContractEvents(ne, oe),
    getEnsAddress: (oe) => getEnsAddress(ne, oe),
    getEnsAvatar: (oe) => getEnsAvatar(ne, oe),
    getEnsName: (oe) => getEnsName(ne, oe),
    getEnsResolver: (oe) => getEnsResolver(ne, oe),
    getEnsText: (oe) => getEnsText(ne, oe),
    getFeeHistory: (oe) => getFeeHistory(ne, oe),
    estimateFeesPerGas: (oe) => estimateFeesPerGas(ne, oe),
    getFilterChanges: (oe) => getFilterChanges(ne, oe),
    getFilterLogs: (oe) => getFilterLogs(ne, oe),
    getGasPrice: () => getGasPrice(ne),
    getLogs: (oe) => getLogs(ne, oe),
    getProof: (oe) => getProof(ne, oe),
    estimateMaxPriorityFeePerGas: (oe) => estimateMaxPriorityFeePerGas(ne, oe),
    getStorageAt: (oe) => getStorageAt(ne, oe),
    getTransaction: (oe) => getTransaction(ne, oe),
    getTransactionConfirmations: (oe) => getTransactionConfirmations(ne, oe),
    getTransactionCount: (oe) => getTransactionCount(ne, oe),
    getTransactionReceipt: (oe) => getTransactionReceipt(ne, oe),
    multicall: (oe) => multicall(ne, oe),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    readContract: (oe) => readContract(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    simulateContract: (oe) => simulateContract(ne, oe),
    verifyMessage: (oe) => verifyMessage(ne, oe),
    verifyTypedData: (oe) => verifyTypedData(ne, oe),
    uninstallFilter: (oe) => uninstallFilter(ne, oe),
    waitForTransactionReceipt: (oe) => waitForTransactionReceipt(ne, oe),
    watchBlocks: (oe) => watchBlocks(ne, oe),
    watchBlockNumber: (oe) => watchBlockNumber(ne, oe),
    watchContractEvent: (oe) => watchContractEvent(ne, oe),
    watchEvent: (oe) => watchEvent(ne, oe),
    watchPendingTransactions: (oe) => watchPendingTransactions(ne, oe)
  };
}
function createPublicClient(ne) {
  const { key: oe = "public", name: ae = "Public Client" } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    type: "publicClient"
  }).extend(publicActions);
}
function deployContract(ne, oe) {
  const { abi: ae, args: fe, bytecode: ye, ...ge } = oe, we = encodeDeployData({ abi: ae, args: fe, bytecode: ye });
  return sendTransaction(ne, {
    ...ge,
    data: we
  });
}
async function getAddresses(ne) {
  var ae;
  return ((ae = ne.account) == null ? void 0 : ae.type) === "local" ? [ne.account.address] : (await ne.request({ method: "eth_accounts" })).map((fe) => checksumAddress(fe));
}
async function getPermissions(ne) {
  return await ne.request({ method: "wallet_getPermissions" });
}
async function requestAddresses(ne) {
  return (await ne.request({ method: "eth_requestAccounts" }, { retryCount: 0 })).map((ae) => getAddress(ae));
}
async function requestPermissions(ne, oe) {
  return ne.request({
    method: "wallet_requestPermissions",
    params: [oe]
  }, { retryCount: 0 });
}
async function signMessage$1(ne, { account: oe = ne.account, message: ae }) {
  if (!oe)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const fe = parseAccount(oe);
  if (fe.type === "local")
    return fe.signMessage({ message: ae });
  const ye = (() => typeof ae == "string" ? stringToHex(ae) : ae.raw instanceof Uint8Array ? toHex(ae.raw) : ae.raw)();
  return ne.request({
    method: "personal_sign",
    params: [ye, fe.address]
  }, { retryCount: 0 });
}
async function signTransaction$1(ne, oe) {
  var Ie, $e, Ne, Me;
  const { account: ae = ne.account, chain: fe = ne.chain, ...ye } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const ge = parseAccount(ae);
  assertRequest({
    account: ge,
    ...oe
  });
  const we = await getAction(ne, getChainId, "getChainId")({});
  fe !== null && assertCurrentChain({
    currentChainId: we,
    chain: fe
  });
  const _e = (fe == null ? void 0 : fe.formatters) || ((Ie = ne.chain) == null ? void 0 : Ie.formatters), Se = (($e = _e == null ? void 0 : _e.transactionRequest) == null ? void 0 : $e.format) || formatTransactionRequest;
  return ge.type === "local" ? ge.signTransaction({
    ...ye,
    chainId: we
  }, { serializer: (Me = (Ne = ne.chain) == null ? void 0 : Ne.serializers) == null ? void 0 : Me.transaction }) : await ne.request({
    method: "eth_signTransaction",
    params: [
      {
        ...Se(ye),
        chainId: numberToHex(we),
        from: ge.address
      }
    ]
  }, { retryCount: 0 });
}
async function signTypedData$1(ne, oe) {
  const { account: ae = ne.account, domain: fe, message: ye, primaryType: ge } = oe;
  if (!ae)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const we = parseAccount(ae), _e = {
    EIP712Domain: getTypesForEIP712Domain({ domain: fe }),
    ...oe.types
  };
  if (validateTypedData({ domain: fe, message: ye, primaryType: ge, types: _e }), we.type === "local")
    return we.signTypedData({ domain: fe, message: ye, primaryType: ge, types: _e });
  const Se = stringify({ domain: fe ?? {}, message: ye, primaryType: ge, types: _e }, (Ie, $e) => isHex($e) ? $e.toLowerCase() : $e);
  return ne.request({
    method: "eth_signTypedData_v4",
    params: [we.address, Se]
  }, { retryCount: 0 });
}
async function switchChain(ne, { id: oe }) {
  await ne.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(oe)
      }
    ]
  }, { retryCount: 0 });
}
async function watchAsset(ne, oe) {
  return await ne.request({
    method: "wallet_watchAsset",
    params: oe
  }, { retryCount: 0 });
}
function walletActions(ne) {
  return {
    addChain: (oe) => addChain(ne, oe),
    deployContract: (oe) => deployContract(ne, oe),
    getAddresses: () => getAddresses(ne),
    getChainId: () => getChainId(ne),
    getPermissions: () => getPermissions(ne),
    prepareTransactionRequest: (oe) => prepareTransactionRequest(ne, oe),
    requestAddresses: () => requestAddresses(ne),
    requestPermissions: (oe) => requestPermissions(ne, oe),
    sendRawTransaction: (oe) => sendRawTransaction(ne, oe),
    sendTransaction: (oe) => sendTransaction(ne, oe),
    signMessage: (oe) => signMessage$1(ne, oe),
    signTransaction: (oe) => signTransaction$1(ne, oe),
    signTypedData: (oe) => signTypedData$1(ne, oe),
    switchChain: (oe) => switchChain(ne, oe),
    watchAsset: (oe) => watchAsset(ne, oe),
    writeContract: (oe) => writeContract(ne, oe)
  };
}
function createWalletClient(ne) {
  const { key: oe = "wallet", name: ae = "Wallet Client", transport: fe } = ne;
  return createClient$1({
    ...ne,
    key: oe,
    name: ae,
    transport: fe,
    type: "walletClient"
  }).extend(walletActions);
}
function webSocket(ne, oe = {}) {
  const { key: ae = "webSocket", name: fe = "WebSocket JSON-RPC", reconnect: ye, retryDelay: ge } = oe;
  return ({ chain: we, retryCount: _e, timeout: Se }) => {
    var Me;
    const Ie = oe.retryCount ?? _e, $e = Se ?? oe.timeout ?? 1e4, Ne = ne || ((Me = we == null ? void 0 : we.rpcUrls.default.webSocket) == null ? void 0 : Me[0]);
    if (!Ne)
      throw new UrlRequiredError();
    return createTransport({
      key: ae,
      name: fe,
      async request({ method: Be, params: ze }) {
        const He = { method: Be, params: ze }, Ze = await getWebSocketRpcClient(Ne, { reconnect: ye }), { error: qe, result: tt } = await Ze.requestAsync({
          body: He,
          timeout: $e
        });
        if (qe)
          throw new RpcRequestError({
            body: He,
            error: qe,
            url: Ne
          });
        return tt;
      },
      retryCount: Ie,
      retryDelay: ge,
      timeout: $e,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(Ne);
      },
      getRpcClient() {
        return getWebSocketRpcClient(Ne);
      },
      async subscribe({ params: Be, onData: ze, onError: He }) {
        const Ze = await getWebSocketRpcClient(Ne), { result: qe } = await new Promise((tt, Xe) => Ze.request({
          body: {
            method: "eth_subscribe",
            params: Be
          },
          onResponse(ot) {
            if (ot.error) {
              Xe(ot.error), He == null || He(ot.error);
              return;
            }
            if (typeof ot.id == "number") {
              tt(ot);
              return;
            }
            ot.method === "eth_subscription" && ze(ot.params);
          }
        }));
        return {
          subscriptionId: qe,
          async unsubscribe() {
            return new Promise((tt) => Ze.request({
              body: {
                method: "eth_unsubscribe",
                params: [qe]
              },
              onResponse: tt
            }));
          }
        };
      }
    });
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(ne, oe) {
  const ae = ne % oe;
  return ae >= _0n$2 ? ae : oe + ae;
}
function pow(ne, oe, ae) {
  if (ae <= _0n$2 || oe < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (ae === _1n$3)
    return _0n$2;
  let fe = _1n$3;
  for (; oe > _0n$2; )
    oe & _1n$3 && (fe = fe * ne % ae), ne = ne * ne % ae, oe >>= _1n$3;
  return fe;
}
function pow2(ne, oe, ae) {
  let fe = ne;
  for (; oe-- > _0n$2; )
    fe *= fe, fe %= ae;
  return fe;
}
function invert$1(ne, oe) {
  if (ne === _0n$2 || oe <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${ne} mod=${oe}`);
  let ae = mod(ne, oe), fe = oe, ye = _0n$2, ge = _1n$3;
  for (; ae !== _0n$2; ) {
    const _e = fe / ae, Se = fe % ae, Ie = ye - ge * _e;
    fe = ae, ae = Se, ye = ge, ge = Ie;
  }
  if (fe !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(ye, oe);
}
function tonelliShanks(ne) {
  const oe = (ne - _1n$3) / _2n$1;
  let ae, fe, ye;
  for (ae = ne - _1n$3, fe = 0; ae % _2n$1 === _0n$2; ae /= _2n$1, fe++)
    ;
  for (ye = _2n$1; ye < ne && pow(ye, oe, ne) !== ne - _1n$3; ye++)
    ;
  if (fe === 1) {
    const we = (ne + _1n$3) / _4n;
    return function(Se, Ie) {
      const $e = Se.pow(Ie, we);
      if (!Se.eql(Se.sqr($e), Ie))
        throw new Error("Cannot find square root");
      return $e;
    };
  }
  const ge = (ae + _1n$3) / _2n$1;
  return function(_e, Se) {
    if (_e.pow(Se, oe) === _e.neg(_e.ONE))
      throw new Error("Cannot find square root");
    let Ie = fe, $e = _e.pow(_e.mul(_e.ONE, ye), ae), Ne = _e.pow(Se, ge), Me = _e.pow(Se, ae);
    for (; !_e.eql(Me, _e.ONE); ) {
      if (_e.eql(Me, _e.ZERO))
        return _e.ZERO;
      let Be = 1;
      for (let He = _e.sqr(Me); Be < Ie && !_e.eql(He, _e.ONE); Be++)
        He = _e.sqr(He);
      const ze = _e.pow($e, _1n$3 << BigInt(Ie - Be - 1));
      $e = _e.sqr(ze), Ne = _e.mul(Ne, ze), Me = _e.mul(Me, $e), Ie = Be;
    }
    return Ne;
  };
}
function FpSqrt(ne) {
  if (ne % _4n === _3n$1) {
    const oe = (ne + _1n$3) / _4n;
    return function(fe, ye) {
      const ge = fe.pow(ye, oe);
      if (!fe.eql(fe.sqr(ge), ye))
        throw new Error("Cannot find square root");
      return ge;
    };
  }
  if (ne % _8n === _5n) {
    const oe = (ne - _5n) / _8n;
    return function(fe, ye) {
      const ge = fe.mul(ye, _2n$1), we = fe.pow(ge, oe), _e = fe.mul(ye, we), Se = fe.mul(fe.mul(_e, _2n$1), we), Ie = fe.mul(_e, fe.sub(Se, fe.ONE));
      if (!fe.eql(fe.sqr(Ie), ye))
        throw new Error("Cannot find square root");
      return Ie;
    };
  }
  return tonelliShanks(ne);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(ne) {
  const oe = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, ae = FIELD_FIELDS.reduce((fe, ye) => (fe[ye] = "function", fe), oe);
  return validateObject(ne, ae);
}
function FpPow(ne, oe, ae) {
  if (ae < _0n$2)
    throw new Error("Expected power > 0");
  if (ae === _0n$2)
    return ne.ONE;
  if (ae === _1n$3)
    return oe;
  let fe = ne.ONE, ye = oe;
  for (; ae > _0n$2; )
    ae & _1n$3 && (fe = ne.mul(fe, ye)), ye = ne.sqr(ye), ae >>= _1n$3;
  return fe;
}
function FpInvertBatch(ne, oe) {
  const ae = new Array(oe.length), fe = oe.reduce((ge, we, _e) => ne.is0(we) ? ge : (ae[_e] = ge, ne.mul(ge, we)), ne.ONE), ye = ne.inv(fe);
  return oe.reduceRight((ge, we, _e) => ne.is0(we) ? ge : (ae[_e] = ne.mul(ge, ae[_e]), ne.mul(ge, we)), ye), ae;
}
function nLength(ne, oe) {
  const ae = oe !== void 0 ? oe : ne.toString(2).length, fe = Math.ceil(ae / 8);
  return { nBitLength: ae, nByteLength: fe };
}
function Field(ne, oe, ae = !1, fe = {}) {
  if (ne <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ne}`);
  const { nBitLength: ye, nByteLength: ge } = nLength(ne, oe);
  if (ge > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const we = FpSqrt(ne), _e = Object.freeze({
    ORDER: ne,
    BITS: ye,
    BYTES: ge,
    MASK: bitMask(ye),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (Se) => mod(Se, ne),
    isValid: (Se) => {
      if (typeof Se != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof Se}`);
      return _0n$2 <= Se && Se < ne;
    },
    is0: (Se) => Se === _0n$2,
    isOdd: (Se) => (Se & _1n$3) === _1n$3,
    neg: (Se) => mod(-Se, ne),
    eql: (Se, Ie) => Se === Ie,
    sqr: (Se) => mod(Se * Se, ne),
    add: (Se, Ie) => mod(Se + Ie, ne),
    sub: (Se, Ie) => mod(Se - Ie, ne),
    mul: (Se, Ie) => mod(Se * Ie, ne),
    pow: (Se, Ie) => FpPow(_e, Se, Ie),
    div: (Se, Ie) => mod(Se * invert$1(Ie, ne), ne),
    // Same as above, but doesn't normalize
    sqrN: (Se) => Se * Se,
    addN: (Se, Ie) => Se + Ie,
    subN: (Se, Ie) => Se - Ie,
    mulN: (Se, Ie) => Se * Ie,
    inv: (Se) => invert$1(Se, ne),
    sqrt: fe.sqrt || ((Se) => we(_e, Se)),
    invertBatch: (Se) => FpInvertBatch(_e, Se),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (Se, Ie, $e) => $e ? Ie : Se,
    toBytes: (Se) => ae ? numberToBytesLE(Se, ge) : numberToBytesBE(Se, ge),
    fromBytes: (Se) => {
      if (Se.length !== ge)
        throw new Error(`Fp.fromBytes: expected ${ge}, got ${Se.length}`);
      return ae ? bytesToNumberLE(Se) : bytesToNumberBE(Se);
    }
  });
  return Object.freeze(_e);
}
function getFieldBytesLength(ne) {
  if (typeof ne != "bigint")
    throw new Error("field order must be bigint");
  const oe = ne.toString(2).length;
  return Math.ceil(oe / 8);
}
function getMinHashLength(ne) {
  const oe = getFieldBytesLength(ne);
  return oe + Math.ceil(oe / 2);
}
function mapHashToField(ne, oe, ae = !1) {
  const fe = ne.length, ye = getFieldBytesLength(oe), ge = getMinHashLength(oe);
  if (fe < 16 || fe < ge || fe > 1024)
    throw new Error(`expected ${ge}-1024 bytes of input, got ${fe}`);
  const we = ae ? bytesToNumberBE(ne) : bytesToNumberLE(ne), _e = mod(we, oe - _1n$3) + _1n$3;
  return ae ? numberToBytesLE(_e, ye) : numberToBytesBE(_e, ye);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$2 = BigInt(1);
function wNAF(ne, oe) {
  const ae = (ye, ge) => {
    const we = ge.negate();
    return ye ? we : ge;
  }, fe = (ye) => {
    const ge = Math.ceil(oe / ye) + 1, we = 2 ** (ye - 1);
    return { windows: ge, windowSize: we };
  };
  return {
    constTimeNegate: ae,
    // non-const time multiplication ladder
    unsafeLadder(ye, ge) {
      let we = ne.ZERO, _e = ye;
      for (; ge > _0n$1; )
        ge & _1n$2 && (we = we.add(_e)), _e = _e.double(), ge >>= _1n$2;
      return we;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ye, ge) {
      const { windows: we, windowSize: _e } = fe(ge), Se = [];
      let Ie = ye, $e = Ie;
      for (let Ne = 0; Ne < we; Ne++) {
        $e = Ie, Se.push($e);
        for (let Me = 1; Me < _e; Me++)
          $e = $e.add(Ie), Se.push($e);
        Ie = $e.double();
      }
      return Se;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ye, ge, we) {
      const { windows: _e, windowSize: Se } = fe(ye);
      let Ie = ne.ZERO, $e = ne.BASE;
      const Ne = BigInt(2 ** ye - 1), Me = 2 ** ye, Be = BigInt(ye);
      for (let ze = 0; ze < _e; ze++) {
        const He = ze * Se;
        let Ze = Number(we & Ne);
        we >>= Be, Ze > Se && (Ze -= Me, we += _1n$2);
        const qe = He, tt = He + Math.abs(Ze) - 1, Xe = ze % 2 !== 0, ot = Ze < 0;
        Ze === 0 ? $e = $e.add(ae(Xe, ge[qe])) : Ie = Ie.add(ae(ot, ge[tt]));
      }
      return { p: Ie, f: $e };
    },
    wNAFCached(ye, ge, we, _e) {
      const Se = ye._WINDOW_SIZE || 1;
      let Ie = ge.get(ye);
      return Ie || (Ie = this.precomputeWindow(ye, Se), Se !== 1 && ge.set(ye, _e(Ie))), this.wNAF(Se, Ie, we);
    }
  };
}
function validateBasic(ne) {
  return validateField(ne.Fp), validateObject(ne, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(ne.n, ne.nBitLength),
    ...ne,
    p: ne.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(ne) {
  const oe = validateBasic(ne);
  validateObject(oe, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: ae, Fp: fe, a: ye } = oe;
  if (ae) {
    if (!fe.eql(ye, fe.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof ae != "object" || typeof ae.beta != "bigint" || typeof ae.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...oe });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(oe = "") {
      super(oe);
    }
  },
  _parseInt(ne) {
    const { Err: oe } = DER;
    if (ne.length < 2 || ne[0] !== 2)
      throw new oe("Invalid signature integer tag");
    const ae = ne[1], fe = ne.subarray(2, ae + 2);
    if (!ae || fe.length !== ae)
      throw new oe("Invalid signature integer: wrong length");
    if (fe[0] & 128)
      throw new oe("Invalid signature integer: negative");
    if (fe[0] === 0 && !(fe[1] & 128))
      throw new oe("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(fe), l: ne.subarray(ae + 2) };
  },
  toSig(ne) {
    const { Err: oe } = DER, ae = typeof ne == "string" ? h2b(ne) : ne;
    if (!(ae instanceof Uint8Array))
      throw new Error("ui8a expected");
    let fe = ae.length;
    if (fe < 2 || ae[0] != 48)
      throw new oe("Invalid signature tag");
    if (ae[1] !== fe - 2)
      throw new oe("Invalid signature: incorrect length");
    const { d: ye, l: ge } = DER._parseInt(ae.subarray(2)), { d: we, l: _e } = DER._parseInt(ge);
    if (_e.length)
      throw new oe("Invalid signature: left bytes after parsing");
    return { r: ye, s: we };
  },
  hexFromSig(ne) {
    const oe = (Ie) => Number.parseInt(Ie[0], 16) & 8 ? "00" + Ie : Ie, ae = (Ie) => {
      const $e = Ie.toString(16);
      return $e.length & 1 ? `0${$e}` : $e;
    }, fe = oe(ae(ne.s)), ye = oe(ae(ne.r)), ge = fe.length / 2, we = ye.length / 2, _e = ae(ge), Se = ae(we);
    return `30${ae(we + ge + 4)}02${Se}${ye}02${_e}${fe}`;
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(ne) {
  const oe = validatePointOpts(ne), { Fp: ae } = oe, fe = oe.toBytes || ((ze, He, Ze) => {
    const qe = He.toAffine();
    return concatBytes(Uint8Array.from([4]), ae.toBytes(qe.x), ae.toBytes(qe.y));
  }), ye = oe.fromBytes || ((ze) => {
    const He = ze.subarray(1), Ze = ae.fromBytes(He.subarray(0, ae.BYTES)), qe = ae.fromBytes(He.subarray(ae.BYTES, 2 * ae.BYTES));
    return { x: Ze, y: qe };
  });
  function ge(ze) {
    const { a: He, b: Ze } = oe, qe = ae.sqr(ze), tt = ae.mul(qe, ze);
    return ae.add(ae.add(tt, ae.mul(ze, He)), Ze);
  }
  if (!ae.eql(ae.sqr(oe.Gy), ge(oe.Gx)))
    throw new Error("bad generator point: equation left != right");
  function we(ze) {
    return typeof ze == "bigint" && _0n < ze && ze < oe.n;
  }
  function _e(ze) {
    if (!we(ze))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function Se(ze) {
    const { allowedPrivateKeyLengths: He, nByteLength: Ze, wrapPrivateKey: qe, n: tt } = oe;
    if (He && typeof ze != "bigint") {
      if (ze instanceof Uint8Array && (ze = bytesToHex(ze)), typeof ze != "string" || !He.includes(ze.length))
        throw new Error("Invalid key");
      ze = ze.padStart(Ze * 2, "0");
    }
    let Xe;
    try {
      Xe = typeof ze == "bigint" ? ze : bytesToNumberBE(ensureBytes("private key", ze, Ze));
    } catch {
      throw new Error(`private key must be ${Ze} bytes, hex or bigint, not ${typeof ze}`);
    }
    return qe && (Xe = mod(Xe, tt)), _e(Xe), Xe;
  }
  const Ie = /* @__PURE__ */ new Map();
  function $e(ze) {
    if (!(ze instanceof Ne))
      throw new Error("ProjectivePoint expected");
  }
  class Ne {
    constructor(He, Ze, qe) {
      if (this.px = He, this.py = Ze, this.pz = qe, He == null || !ae.isValid(He))
        throw new Error("x required");
      if (Ze == null || !ae.isValid(Ze))
        throw new Error("y required");
      if (qe == null || !ae.isValid(qe))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(He) {
      const { x: Ze, y: qe } = He || {};
      if (!He || !ae.isValid(Ze) || !ae.isValid(qe))
        throw new Error("invalid affine point");
      if (He instanceof Ne)
        throw new Error("projective point not allowed");
      const tt = (Xe) => ae.eql(Xe, ae.ZERO);
      return tt(Ze) && tt(qe) ? Ne.ZERO : new Ne(Ze, qe, ae.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(He) {
      const Ze = ae.invertBatch(He.map((qe) => qe.pz));
      return He.map((qe, tt) => qe.toAffine(Ze[tt])).map(Ne.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(He) {
      const Ze = Ne.fromAffine(ye(ensureBytes("pointHex", He)));
      return Ze.assertValidity(), Ze;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(He) {
      return Ne.BASE.multiply(Se(He));
    }
    // "Private method", don't use it directly
    _setWindowSize(He) {
      this._WINDOW_SIZE = He, Ie.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (oe.allowInfinityPoint && !ae.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: He, y: Ze } = this.toAffine();
      if (!ae.isValid(He) || !ae.isValid(Ze))
        throw new Error("bad point: x or y not FE");
      const qe = ae.sqr(Ze), tt = ge(He);
      if (!ae.eql(qe, tt))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: He } = this.toAffine();
      if (ae.isOdd)
        return !ae.isOdd(He);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(He) {
      $e(He);
      const { px: Ze, py: qe, pz: tt } = this, { px: Xe, py: ot, pz: pt } = He, ht = ae.eql(ae.mul(Ze, pt), ae.mul(Xe, tt)), wt = ae.eql(ae.mul(qe, pt), ae.mul(ot, tt));
      return ht && wt;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Ne(this.px, ae.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: He, b: Ze } = oe, qe = ae.mul(Ze, _3n), { px: tt, py: Xe, pz: ot } = this;
      let pt = ae.ZERO, ht = ae.ZERO, wt = ae.ZERO, gt = ae.mul(tt, tt), It = ae.mul(Xe, Xe), Nt = ae.mul(ot, ot), Ft = ae.mul(tt, Xe);
      return Ft = ae.add(Ft, Ft), wt = ae.mul(tt, ot), wt = ae.add(wt, wt), pt = ae.mul(He, wt), ht = ae.mul(qe, Nt), ht = ae.add(pt, ht), pt = ae.sub(It, ht), ht = ae.add(It, ht), ht = ae.mul(pt, ht), pt = ae.mul(Ft, pt), wt = ae.mul(qe, wt), Nt = ae.mul(He, Nt), Ft = ae.sub(gt, Nt), Ft = ae.mul(He, Ft), Ft = ae.add(Ft, wt), wt = ae.add(gt, gt), gt = ae.add(wt, gt), gt = ae.add(gt, Nt), gt = ae.mul(gt, Ft), ht = ae.add(ht, gt), Nt = ae.mul(Xe, ot), Nt = ae.add(Nt, Nt), gt = ae.mul(Nt, Ft), pt = ae.sub(pt, gt), wt = ae.mul(Nt, It), wt = ae.add(wt, wt), wt = ae.add(wt, wt), new Ne(pt, ht, wt);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(He) {
      $e(He);
      const { px: Ze, py: qe, pz: tt } = this, { px: Xe, py: ot, pz: pt } = He;
      let ht = ae.ZERO, wt = ae.ZERO, gt = ae.ZERO;
      const It = oe.a, Nt = ae.mul(oe.b, _3n);
      let Ft = ae.mul(Ze, Xe), on = ae.mul(qe, ot), en = ae.mul(tt, pt), wn = ae.add(Ze, qe), Zt = ae.add(Xe, ot);
      wn = ae.mul(wn, Zt), Zt = ae.add(Ft, on), wn = ae.sub(wn, Zt), Zt = ae.add(Ze, tt);
      let pn = ae.add(Xe, pt);
      return Zt = ae.mul(Zt, pn), pn = ae.add(Ft, en), Zt = ae.sub(Zt, pn), pn = ae.add(qe, tt), ht = ae.add(ot, pt), pn = ae.mul(pn, ht), ht = ae.add(on, en), pn = ae.sub(pn, ht), gt = ae.mul(It, Zt), ht = ae.mul(Nt, en), gt = ae.add(ht, gt), ht = ae.sub(on, gt), gt = ae.add(on, gt), wt = ae.mul(ht, gt), on = ae.add(Ft, Ft), on = ae.add(on, Ft), en = ae.mul(It, en), Zt = ae.mul(Nt, Zt), on = ae.add(on, en), en = ae.sub(Ft, en), en = ae.mul(It, en), Zt = ae.add(Zt, en), Ft = ae.mul(on, Zt), wt = ae.add(wt, Ft), Ft = ae.mul(pn, Zt), ht = ae.mul(wn, ht), ht = ae.sub(ht, Ft), Ft = ae.mul(wn, on), gt = ae.mul(pn, gt), gt = ae.add(gt, Ft), new Ne(ht, wt, gt);
    }
    subtract(He) {
      return this.add(He.negate());
    }
    is0() {
      return this.equals(Ne.ZERO);
    }
    wNAF(He) {
      return Be.wNAFCached(this, Ie, He, (Ze) => {
        const qe = ae.invertBatch(Ze.map((tt) => tt.pz));
        return Ze.map((tt, Xe) => tt.toAffine(qe[Xe])).map(Ne.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(He) {
      const Ze = Ne.ZERO;
      if (He === _0n)
        return Ze;
      if (_e(He), He === _1n$1)
        return this;
      const { endo: qe } = oe;
      if (!qe)
        return Be.unsafeLadder(this, He);
      let { k1neg: tt, k1: Xe, k2neg: ot, k2: pt } = qe.splitScalar(He), ht = Ze, wt = Ze, gt = this;
      for (; Xe > _0n || pt > _0n; )
        Xe & _1n$1 && (ht = ht.add(gt)), pt & _1n$1 && (wt = wt.add(gt)), gt = gt.double(), Xe >>= _1n$1, pt >>= _1n$1;
      return tt && (ht = ht.negate()), ot && (wt = wt.negate()), wt = new Ne(ae.mul(wt.px, qe.beta), wt.py, wt.pz), ht.add(wt);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(He) {
      _e(He);
      let Ze = He, qe, tt;
      const { endo: Xe } = oe;
      if (Xe) {
        const { k1neg: ot, k1: pt, k2neg: ht, k2: wt } = Xe.splitScalar(Ze);
        let { p: gt, f: It } = this.wNAF(pt), { p: Nt, f: Ft } = this.wNAF(wt);
        gt = Be.constTimeNegate(ot, gt), Nt = Be.constTimeNegate(ht, Nt), Nt = new Ne(ae.mul(Nt.px, Xe.beta), Nt.py, Nt.pz), qe = gt.add(Nt), tt = It.add(Ft);
      } else {
        const { p: ot, f: pt } = this.wNAF(Ze);
        qe = ot, tt = pt;
      }
      return Ne.normalizeZ([qe, tt])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(He, Ze, qe) {
      const tt = Ne.BASE, Xe = (pt, ht) => ht === _0n || ht === _1n$1 || !pt.equals(tt) ? pt.multiplyUnsafe(ht) : pt.multiply(ht), ot = Xe(this, Ze).add(Xe(He, qe));
      return ot.is0() ? void 0 : ot;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(He) {
      const { px: Ze, py: qe, pz: tt } = this, Xe = this.is0();
      He == null && (He = Xe ? ae.ONE : ae.inv(tt));
      const ot = ae.mul(Ze, He), pt = ae.mul(qe, He), ht = ae.mul(tt, He);
      if (Xe)
        return { x: ae.ZERO, y: ae.ZERO };
      if (!ae.eql(ht, ae.ONE))
        throw new Error("invZ was invalid");
      return { x: ot, y: pt };
    }
    isTorsionFree() {
      const { h: He, isTorsionFree: Ze } = oe;
      if (He === _1n$1)
        return !0;
      if (Ze)
        return Ze(Ne, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: He, clearCofactor: Ze } = oe;
      return He === _1n$1 ? this : Ze ? Ze(Ne, this) : this.multiplyUnsafe(oe.h);
    }
    toRawBytes(He = !0) {
      return this.assertValidity(), fe(Ne, this, He);
    }
    toHex(He = !0) {
      return bytesToHex(this.toRawBytes(He));
    }
  }
  Ne.BASE = new Ne(oe.Gx, oe.Gy, ae.ONE), Ne.ZERO = new Ne(ae.ZERO, ae.ONE, ae.ZERO);
  const Me = oe.nBitLength, Be = wNAF(Ne, oe.endo ? Math.ceil(Me / 2) : Me);
  return {
    CURVE: oe,
    ProjectivePoint: Ne,
    normPrivateKeyToScalar: Se,
    weierstrassEquation: ge,
    isWithinCurveOrder: we
  };
}
function validateOpts(ne) {
  const oe = validateBasic(ne);
  return validateObject(oe, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...oe });
}
function weierstrass(ne) {
  const oe = validateOpts(ne), { Fp: ae, n: fe } = oe, ye = ae.BYTES + 1, ge = 2 * ae.BYTES + 1;
  function we(Zt) {
    return _0n < Zt && Zt < ae.ORDER;
  }
  function _e(Zt) {
    return mod(Zt, fe);
  }
  function Se(Zt) {
    return invert$1(Zt, fe);
  }
  const { ProjectivePoint: Ie, normPrivateKeyToScalar: $e, weierstrassEquation: Ne, isWithinCurveOrder: Me } = weierstrassPoints({
    ...oe,
    toBytes(Zt, pn, un) {
      const dn = pn.toAffine(), xn = ae.toBytes(dn.x), Rn = concatBytes;
      return un ? Rn(Uint8Array.from([pn.hasEvenY() ? 2 : 3]), xn) : Rn(Uint8Array.from([4]), xn, ae.toBytes(dn.y));
    },
    fromBytes(Zt) {
      const pn = Zt.length, un = Zt[0], dn = Zt.subarray(1);
      if (pn === ye && (un === 2 || un === 3)) {
        const xn = bytesToNumberBE(dn);
        if (!we(xn))
          throw new Error("Point is not on curve");
        const Rn = Ne(xn);
        let At = ae.sqrt(Rn);
        const hn = (At & _1n$1) === _1n$1;
        return (un & 1) === 1 !== hn && (At = ae.neg(At)), { x: xn, y: At };
      } else if (pn === ge && un === 4) {
        const xn = ae.fromBytes(dn.subarray(0, ae.BYTES)), Rn = ae.fromBytes(dn.subarray(ae.BYTES, 2 * ae.BYTES));
        return { x: xn, y: Rn };
      } else
        throw new Error(`Point of length ${pn} was invalid. Expected ${ye} compressed bytes or ${ge} uncompressed bytes`);
    }
  }), Be = (Zt) => bytesToHex(numberToBytesBE(Zt, oe.nByteLength));
  function ze(Zt) {
    const pn = fe >> _1n$1;
    return Zt > pn;
  }
  function He(Zt) {
    return ze(Zt) ? _e(-Zt) : Zt;
  }
  const Ze = (Zt, pn, un) => bytesToNumberBE(Zt.slice(pn, un));
  class qe {
    constructor(pn, un, dn) {
      this.r = pn, this.s = un, this.recovery = dn, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(pn) {
      const un = oe.nByteLength;
      return pn = ensureBytes("compactSignature", pn, un * 2), new qe(Ze(pn, 0, un), Ze(pn, un, 2 * un));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(pn) {
      const { r: un, s: dn } = DER.toSig(ensureBytes("DER", pn));
      return new qe(un, dn);
    }
    assertValidity() {
      if (!Me(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!Me(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(pn) {
      return new qe(this.r, this.s, pn);
    }
    recoverPublicKey(pn) {
      const { r: un, s: dn, recovery: xn } = this, Rn = wt(ensureBytes("msgHash", pn));
      if (xn == null || ![0, 1, 2, 3].includes(xn))
        throw new Error("recovery id invalid");
      const At = xn === 2 || xn === 3 ? un + oe.n : un;
      if (At >= ae.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const hn = xn & 1 ? "03" : "02", Yn = Ie.fromHex(hn + Be(At)), Un = Se(At), Ht = _e(-Rn * Un), _n = _e(dn * Un), Vn = Ie.BASE.multiplyAndAddUnsafe(Yn, Ht, _n);
      if (!Vn)
        throw new Error("point at infinify");
      return Vn.assertValidity(), Vn;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return ze(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new qe(this.r, _e(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return Be(this.r) + Be(this.s);
    }
  }
  const tt = {
    isValidPrivateKey(Zt) {
      try {
        return $e(Zt), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: $e,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const Zt = getMinHashLength(oe.n);
      return mapHashToField(oe.randomBytes(Zt), oe.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(Zt = 8, pn = Ie.BASE) {
      return pn._setWindowSize(Zt), pn.multiply(BigInt(3)), pn;
    }
  };
  function Xe(Zt, pn = !0) {
    return Ie.fromPrivateKey(Zt).toRawBytes(pn);
  }
  function ot(Zt) {
    const pn = Zt instanceof Uint8Array, un = typeof Zt == "string", dn = (pn || un) && Zt.length;
    return pn ? dn === ye || dn === ge : un ? dn === 2 * ye || dn === 2 * ge : Zt instanceof Ie;
  }
  function pt(Zt, pn, un = !0) {
    if (ot(Zt))
      throw new Error("first arg must be private key");
    if (!ot(pn))
      throw new Error("second arg must be public key");
    return Ie.fromHex(pn).multiply($e(Zt)).toRawBytes(un);
  }
  const ht = oe.bits2int || function(Zt) {
    const pn = bytesToNumberBE(Zt), un = Zt.length * 8 - oe.nBitLength;
    return un > 0 ? pn >> BigInt(un) : pn;
  }, wt = oe.bits2int_modN || function(Zt) {
    return _e(ht(Zt));
  }, gt = bitMask(oe.nBitLength);
  function It(Zt) {
    if (typeof Zt != "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= Zt && Zt < gt))
      throw new Error(`bigint expected < 2^${oe.nBitLength}`);
    return numberToBytesBE(Zt, oe.nByteLength);
  }
  function Nt(Zt, pn, un = Ft) {
    if (["recovered", "canonical"].some((nr) => nr in un))
      throw new Error("sign() legacy options not supported");
    const { hash: dn, randomBytes: xn } = oe;
    let { lowS: Rn, prehash: At, extraEntropy: hn } = un;
    Rn == null && (Rn = !0), Zt = ensureBytes("msgHash", Zt), At && (Zt = ensureBytes("prehashed msgHash", dn(Zt)));
    const Yn = wt(Zt), Un = $e(pn), Ht = [It(Un), It(Yn)];
    if (hn != null) {
      const nr = hn === !0 ? xn(ae.BYTES) : hn;
      Ht.push(ensureBytes("extraEntropy", nr));
    }
    const _n = concatBytes(...Ht), Vn = Yn;
    function br(nr) {
      const Er = ht(nr);
      if (!Me(Er))
        return;
      const Qo = Se(Er), Yr = Ie.BASE.multiply(Er).toAffine(), qr = _e(Yr.x);
      if (qr === _0n)
        return;
      const Kr = _e(Qo * _e(Vn + qr * Un));
      if (Kr === _0n)
        return;
      let $o = (Yr.x === qr ? 0 : 2) | Number(Yr.y & _1n$1), xo = Kr;
      return Rn && ze(Kr) && (xo = He(Kr), $o ^= 1), new qe(qr, xo, $o);
    }
    return { seed: _n, k2sig: br };
  }
  const Ft = { lowS: oe.lowS, prehash: !1 }, on = { lowS: oe.lowS, prehash: !1 };
  function en(Zt, pn, un = Ft) {
    const { seed: dn, k2sig: xn } = Nt(Zt, pn, un), Rn = oe;
    return createHmacDrbg(Rn.hash.outputLen, Rn.nByteLength, Rn.hmac)(dn, xn);
  }
  Ie.BASE._setWindowSize(8);
  function wn(Zt, pn, un, dn = on) {
    var Yr;
    const xn = Zt;
    if (pn = ensureBytes("msgHash", pn), un = ensureBytes("publicKey", un), "strict" in dn)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Rn, prehash: At } = dn;
    let hn, Yn;
    try {
      if (typeof xn == "string" || xn instanceof Uint8Array)
        try {
          hn = qe.fromDER(xn);
        } catch (qr) {
          if (!(qr instanceof DER.Err))
            throw qr;
          hn = qe.fromCompact(xn);
        }
      else if (typeof xn == "object" && typeof xn.r == "bigint" && typeof xn.s == "bigint") {
        const { r: qr, s: Kr } = xn;
        hn = new qe(qr, Kr);
      } else
        throw new Error("PARSE");
      Yn = Ie.fromHex(un);
    } catch (qr) {
      if (qr.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Rn && hn.hasHighS())
      return !1;
    At && (pn = oe.hash(pn));
    const { r: Un, s: Ht } = hn, _n = wt(pn), Vn = Se(Ht), br = _e(_n * Vn), nr = _e(Un * Vn), Er = (Yr = Ie.BASE.multiplyAndAddUnsafe(Yn, br, nr)) == null ? void 0 : Yr.toAffine();
    return Er ? _e(Er.x) === Un : !1;
  }
  return {
    CURVE: oe,
    getPublicKey: Xe,
    getSharedSecret: pt,
    sign: en,
    verify: wn,
    ProjectivePoint: Ie,
    Signature: qe,
    utils: tt
  };
}
class HMAC extends Hash {
  constructor(oe, ae) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(oe);
    const fe = toBytes(ae);
    if (this.iHash = oe.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const ye = this.blockLen, ge = new Uint8Array(ye);
    ge.set(fe.length > ye ? oe.create().update(fe).digest() : fe);
    for (let we = 0; we < ge.length; we++)
      ge[we] ^= 54;
    this.iHash.update(ge), this.oHash = oe.create();
    for (let we = 0; we < ge.length; we++)
      ge[we] ^= 106;
    this.oHash.update(ge), ge.fill(0);
  }
  update(oe) {
    return exists(this), this.iHash.update(oe), this;
  }
  digestInto(oe) {
    exists(this), bytes(oe, this.outputLen), this.finished = !0, this.iHash.digestInto(oe), this.oHash.update(oe), this.oHash.digestInto(oe), this.destroy();
  }
  digest() {
    const oe = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(oe), oe;
  }
  _cloneInto(oe) {
    oe || (oe = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: ae, iHash: fe, finished: ye, destroyed: ge, blockLen: we, outputLen: _e } = this;
    return oe = oe, oe.finished = ye, oe.destroyed = ge, oe.blockLen = we, oe.outputLen = _e, oe.oHash = ae._cloneInto(oe.oHash), oe.iHash = fe._cloneInto(oe.iHash), oe;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (ne, oe, ae) => new HMAC(ne, oe).update(ae).digest();
hmac.create = (ne, oe) => new HMAC(ne, oe);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(ne) {
  return {
    hash: ne,
    hmac: (oe, ...ae) => hmac(ne, oe, concatBytes$2(...ae)),
    randomBytes
  };
}
function createCurve(ne, oe) {
  const ae = (fe) => weierstrass({ ...ne, ...getHash(fe) });
  return Object.freeze({ ...ae(oe), create: ae });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (ne, oe) => (ne + oe / _2n) / oe;
function sqrtMod(ne) {
  const oe = secp256k1P, ae = BigInt(3), fe = BigInt(6), ye = BigInt(11), ge = BigInt(22), we = BigInt(23), _e = BigInt(44), Se = BigInt(88), Ie = ne * ne * ne % oe, $e = Ie * Ie * ne % oe, Ne = pow2($e, ae, oe) * $e % oe, Me = pow2(Ne, ae, oe) * $e % oe, Be = pow2(Me, _2n, oe) * Ie % oe, ze = pow2(Be, ye, oe) * Be % oe, He = pow2(ze, ge, oe) * ze % oe, Ze = pow2(He, _e, oe) * He % oe, qe = pow2(Ze, Se, oe) * Ze % oe, tt = pow2(qe, _e, oe) * He % oe, Xe = pow2(tt, ae, oe) * $e % oe, ot = pow2(Xe, we, oe) * ze % oe, pt = pow2(ot, fe, oe) * Ie % oe, ht = pow2(pt, _2n, oe);
  if (!Fp.eql(Fp.sqr(ht), ne))
    throw new Error("Cannot find square root");
  return ht;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (ne) => {
      const oe = secp256k1N, ae = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), fe = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ye = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ge = ae, we = BigInt("0x100000000000000000000000000000000"), _e = divNearest(ge * ne, oe), Se = divNearest(-fe * ne, oe);
      let Ie = mod(ne - _e * ae - Se * ye, oe), $e = mod(-_e * fe - Se * ge, oe);
      const Ne = Ie > we, Me = $e > we;
      if (Ne && (Ie = oe - Ie), Me && ($e = oe - $e), Ie > we || $e > we)
        throw new Error("splitScalar: Endomorphism failed, k=" + ne);
      return { k1neg: Ne, k1: Ie, k2neg: Me, k2: $e };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
function signatureToHex({ r: ne, s: oe, v: ae, yParity: fe }) {
  const ye = (() => {
    if (ae === 27n || fe === 0)
      return "1b";
    if (ae === 28n || fe === 1)
      return "1c";
    throw new Error("Invalid v value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(ne), hexToBigInt(oe)).toCompactHex()}${ye}`;
}
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Long(ne, oe, ae) {
  this.low = ne | 0, this.high = oe | 0, this.unsigned = !!ae;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: !0 });
function isLong(ne) {
  return (ne && ne.__isLong__) === !0;
}
function ctz32(ne) {
  var oe = Math.clz32(ne & -ne);
  return ne ? 31 - oe : oe;
}
Long.isLong = isLong;
var INT_CACHE = {}, UINT_CACHE = {};
function fromInt(ne, oe) {
  var ae, fe, ye;
  return oe ? (ne >>>= 0, (ye = 0 <= ne && ne < 256) && (fe = UINT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, 0, !0), ye && (UINT_CACHE[ne] = ae), ae)) : (ne |= 0, (ye = -128 <= ne && ne < 128) && (fe = INT_CACHE[ne], fe) ? fe : (ae = fromBits(ne, ne < 0 ? -1 : 0, !1), ye && (INT_CACHE[ne] = ae), ae));
}
Long.fromInt = fromInt;
function fromNumber(ne, oe) {
  if (isNaN(ne))
    return oe ? UZERO : ZERO;
  if (oe) {
    if (ne < 0)
      return UZERO;
    if (ne >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (ne <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (ne + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  return ne < 0 ? fromNumber(-ne, oe).neg() : fromBits(ne % TWO_PWR_32_DBL | 0, ne / TWO_PWR_32_DBL | 0, oe);
}
Long.fromNumber = fromNumber;
function fromBits(ne, oe, ae) {
  return new Long(ne, oe, ae);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(ne, oe, ae) {
  if (ne.length === 0)
    throw Error("empty string");
  if (typeof oe == "number" ? (ae = oe, oe = !1) : oe = !!oe, ne === "NaN" || ne === "Infinity" || ne === "+Infinity" || ne === "-Infinity")
    return oe ? UZERO : ZERO;
  if (ae = ae || 10, ae < 2 || 36 < ae)
    throw RangeError("radix");
  var fe;
  if ((fe = ne.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (fe === 0)
    return fromString(ne.substring(1), oe, ae).neg();
  for (var ye = fromNumber(pow_dbl(ae, 8)), ge = ZERO, we = 0; we < ne.length; we += 8) {
    var _e = Math.min(8, ne.length - we), Se = parseInt(ne.substring(we, we + _e), ae);
    if (_e < 8) {
      var Ie = fromNumber(pow_dbl(ae, _e));
      ge = ge.mul(Ie).add(fromNumber(Se));
    } else
      ge = ge.mul(ye), ge = ge.add(fromNumber(Se));
  }
  return ge.unsigned = oe, ge;
}
Long.fromString = fromString;
function fromValue(ne, oe) {
  return typeof ne == "number" ? fromNumber(ne, oe) : typeof ne == "string" ? fromString(ne, oe) : fromBits(ne.low, ne.high, typeof oe == "boolean" ? oe : ne.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536, TWO_PWR_24_DBL = 1 << 24, TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = fromInt(TWO_PWR_24_DBL), ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function(oe) {
  if (oe = oe || 10, oe < 2 || 36 < oe)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(MIN_VALUE)) {
      var ae = fromNumber(oe), fe = this.div(ae), ye = fe.mul(ae).sub(this);
      return fe.toString(oe) + ye.toInt().toString(oe);
    } else
      return "-" + this.neg().toString(oe);
  for (var ge = fromNumber(pow_dbl(oe, 6), this.unsigned), we = this, _e = ""; ; ) {
    var Se = we.div(ge), Ie = we.sub(Se.mul(ge)).toInt() >>> 0, $e = Ie.toString(oe);
    if (we = Se, we.isZero())
      return $e + _e;
    for (; $e.length < 6; )
      $e = "0" + $e;
    _e = "" + $e + _e;
  }
};
LongPrototype.getHighBits = function() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (var oe = this.high != 0 ? this.high : this.low, ae = 31; ae > 0 && !(oe & 1 << ae); ae--)
    ;
  return this.high != 0 ? ae + 33 : ae + 1;
};
LongPrototype.isZero = function() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.unsigned !== oe.unsigned && this.high >>> 31 === 1 && oe.high >>> 31 === 1 ? !1 : this.high === oe.high && this.low === oe.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function(oe) {
  return !this.eq(
    /* validates */
    oe
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function(oe) {
  return this.comp(
    /* validates */
    oe
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), this.eq(oe))
    return 0;
  var ae = this.isNegative(), fe = oe.isNegative();
  return ae && !fe ? -1 : !ae && fe ? 1 : this.unsigned ? oe.high >>> 0 > this.high >>> 0 || oe.high === this.high && oe.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(oe).isNegative() ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function() {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function(oe) {
  isLong(oe) || (oe = fromValue(oe));
  var ae = this.high >>> 16, fe = this.high & 65535, ye = this.low >>> 16, ge = this.low & 65535, we = oe.high >>> 16, _e = oe.high & 65535, Se = oe.low >>> 16, Ie = oe.low & 65535, $e = 0, Ne = 0, Me = 0, Be = 0;
  return Be += ge + Ie, Me += Be >>> 16, Be &= 65535, Me += ye + Se, Ne += Me >>> 16, Me &= 65535, Ne += fe + _e, $e += Ne >>> 16, Ne &= 65535, $e += ae + we, $e &= 65535, fromBits(Me << 16 | Be, $e << 16 | Ne, this.unsigned);
};
LongPrototype.subtract = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), this.add(oe.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function(oe) {
  if (this.isZero())
    return this;
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = wasm.mul(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (oe.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return oe.isOdd() ? MIN_VALUE : ZERO;
  if (oe.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return oe.isNegative() ? this.neg().mul(oe.neg()) : this.neg().mul(oe).neg();
  if (oe.isNegative())
    return this.mul(oe.neg()).neg();
  if (this.lt(TWO_PWR_24) && oe.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * oe.toNumber(), this.unsigned);
  var fe = this.high >>> 16, ye = this.high & 65535, ge = this.low >>> 16, we = this.low & 65535, _e = oe.high >>> 16, Se = oe.high & 65535, Ie = oe.low >>> 16, $e = oe.low & 65535, Ne = 0, Me = 0, Be = 0, ze = 0;
  return ze += we * $e, Be += ze >>> 16, ze &= 65535, Be += ge * $e, Me += Be >>> 16, Be &= 65535, Be += we * Ie, Me += Be >>> 16, Be &= 65535, Me += ye * $e, Ne += Me >>> 16, Me &= 65535, Me += ge * Ie, Ne += Me >>> 16, Me &= 65535, Me += we * Se, Ne += Me >>> 16, Me &= 65535, Ne += fe * $e + ye * Ie + ge * Se + we * _e, Ne &= 65535, fromBits(Be << 16 | ze, Ne << 16 | Me, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), oe.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && oe.low === -1 && oe.high === -1)
      return this;
    var ae = (this.unsigned ? wasm.div_u : wasm.div_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var fe, ye, ge;
  if (this.unsigned) {
    if (oe.unsigned || (oe = oe.toUnsigned()), oe.gt(this))
      return UZERO;
    if (oe.gt(this.shru(1)))
      return UONE;
    ge = UZERO;
  } else {
    if (this.eq(MIN_VALUE)) {
      if (oe.eq(ONE) || oe.eq(NEG_ONE))
        return MIN_VALUE;
      if (oe.eq(MIN_VALUE))
        return ONE;
      var we = this.shr(1);
      return fe = we.div(oe).shl(1), fe.eq(ZERO) ? oe.isNegative() ? ONE : NEG_ONE : (ye = this.sub(oe.mul(fe)), ge = fe.add(ye.div(oe)), ge);
    } else if (oe.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return oe.isNegative() ? this.neg().div(oe.neg()) : this.neg().div(oe).neg();
    if (oe.isNegative())
      return this.div(oe.neg()).neg();
    ge = ZERO;
  }
  for (ye = this; ye.gte(oe); ) {
    fe = Math.max(1, Math.floor(ye.toNumber() / oe.toNumber()));
    for (var _e = Math.ceil(Math.log(fe) / Math.LN2), Se = _e <= 48 ? 1 : pow_dbl(2, _e - 48), Ie = fromNumber(fe), $e = Ie.mul(oe); $e.isNegative() || $e.gt(ye); )
      fe -= Se, Ie = fromNumber(fe, this.unsigned), $e = Ie.mul(oe);
    Ie.isZero() && (Ie = ONE), ge = ge.add(Ie), ye = ye.sub($e);
  }
  return ge;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function(oe) {
  if (isLong(oe) || (oe = fromValue(oe)), wasm) {
    var ae = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
      this.low,
      this.high,
      oe.low,
      oe.high
    );
    return fromBits(ae, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(oe).mul(oe));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low & oe.low, this.high & oe.high, this.unsigned);
};
LongPrototype.or = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low | oe.low, this.high | oe.high, this.unsigned);
};
LongPrototype.xor = function(oe) {
  return isLong(oe) || (oe = fromValue(oe)), fromBits(this.low ^ oe.low, this.high ^ oe.high, this.unsigned);
};
LongPrototype.shiftLeft = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low << oe, this.high << oe | this.low >>> 32 - oe, this.unsigned) : fromBits(0, this.low << oe - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >> oe, this.unsigned) : fromBits(this.high >> oe - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function(oe) {
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe < 32 ? fromBits(this.low >>> oe | this.high << 32 - oe, this.high >>> oe, this.unsigned) : oe === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> oe - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.low << oe | this.high >>> ae, this.high << oe | this.low >>> ae, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.high << oe | this.low >>> ae, this.low << oe | this.high >>> ae, this.unsigned));
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function(oe) {
  var ae;
  return isLong(oe) && (oe = oe.toInt()), (oe &= 63) === 0 ? this : oe === 32 ? fromBits(this.high, this.low, this.unsigned) : oe < 32 ? (ae = 32 - oe, fromBits(this.high << ae | this.low >>> oe, this.low << ae | this.high >>> oe, this.unsigned)) : (oe -= 32, ae = 32 - oe, fromBits(this.low << ae | this.high >>> oe, this.high << ae | this.low >>> oe, this.unsigned));
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function() {
  return this.unsigned ? fromBits(this.low, this.high, !1) : this;
};
LongPrototype.toUnsigned = function() {
  return this.unsigned ? this : fromBits(this.low, this.high, !0);
};
LongPrototype.toBytes = function(oe) {
  return oe ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function() {
  var oe = this.high, ae = this.low;
  return [
    ae & 255,
    ae >>> 8 & 255,
    ae >>> 16 & 255,
    ae >>> 24,
    oe & 255,
    oe >>> 8 & 255,
    oe >>> 16 & 255,
    oe >>> 24
  ];
};
LongPrototype.toBytesBE = function() {
  var oe = this.high, ae = this.low;
  return [
    oe >>> 24,
    oe >>> 16 & 255,
    oe >>> 8 & 255,
    oe & 255,
    ae >>> 24,
    ae >>> 16 & 255,
    ae >>> 8 & 255,
    ae & 255
  ];
};
Long.fromBytes = function(oe, ae, fe) {
  return fe ? Long.fromBytesLE(oe, ae) : Long.fromBytesBE(oe, ae);
};
Long.fromBytesLE = function(oe, ae) {
  return new Long(
    oe[0] | oe[1] << 8 | oe[2] << 16 | oe[3] << 24,
    oe[4] | oe[5] << 8 | oe[6] << 16 | oe[7] << 24,
    ae
  );
};
Long.fromBytesBE = function(oe, ae) {
  return new Long(
    oe[4] << 24 | oe[5] << 16 | oe[6] << 8 | oe[7],
    oe[0] << 24 | oe[1] << 16 | oe[2] << 8 | oe[3],
    ae
  );
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(ne) {
  return ne && ne.__esModule && Object.prototype.hasOwnProperty.call(ne, "default") ? ne.default : ne;
}
function getAugmentedNamespace(ne) {
  if (ne.__esModule)
    return ne;
  var oe = ne.default;
  if (typeof oe == "function") {
    var ae = function fe() {
      return this instanceof fe ? Reflect.construct(oe, arguments, this.constructor) : oe.apply(this, arguments);
    };
    ae.prototype = oe.prototype;
  } else
    ae = {};
  return Object.defineProperty(ae, "__esModule", { value: !0 }), Object.keys(ne).forEach(function(fe) {
    var ye = Object.getOwnPropertyDescriptor(ne, fe);
    Object.defineProperty(ae, fe, ye.get ? ye : {
      enumerable: !0,
      get: function() {
        return ne[fe];
      }
    });
  }), ae;
}
var indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(ne, oe) {
  for (var ae = new Array(arguments.length - 1), fe = 0, ye = 2, ge = !0; ye < arguments.length; )
    ae[fe++] = arguments[ye++];
  return new Promise(function(_e, Se) {
    ae[fe] = function($e) {
      if (ge)
        if (ge = !1, $e)
          Se($e);
        else {
          for (var Ne = new Array(arguments.length - 1), Me = 0; Me < Ne.length; )
            Ne[Me++] = arguments[Me];
          _e.apply(null, Ne);
        }
    };
    try {
      ne.apply(oe || null, ae);
    } catch (Ie) {
      ge && (ge = !1, Se(Ie));
    }
  });
}
var base64$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(_e) {
    var Se = _e.length;
    if (!Se)
      return 0;
    for (var Ie = 0; --Se % 4 > 1 && _e.charAt(Se) === "="; )
      ++Ie;
    return Math.ceil(_e.length * 3) / 4 - Ie;
  };
  for (var ae = new Array(64), fe = new Array(123), ye = 0; ye < 64; )
    fe[ae[ye] = ye < 26 ? ye + 65 : ye < 52 ? ye + 71 : ye < 62 ? ye - 4 : ye - 59 | 43] = ye++;
  oe.encode = function(_e, Se, Ie) {
    for (var $e = null, Ne = [], Me = 0, Be = 0, ze; Se < Ie; ) {
      var He = _e[Se++];
      switch (Be) {
        case 0:
          Ne[Me++] = ae[He >> 2], ze = (He & 3) << 4, Be = 1;
          break;
        case 1:
          Ne[Me++] = ae[ze | He >> 4], ze = (He & 15) << 2, Be = 2;
          break;
        case 2:
          Ne[Me++] = ae[ze | He >> 6], Ne[Me++] = ae[He & 63], Be = 0;
          break;
      }
      Me > 8191 && (($e || ($e = [])).push(String.fromCharCode.apply(String, Ne)), Me = 0);
    }
    return Be && (Ne[Me++] = ae[ze], Ne[Me++] = 61, Be === 1 && (Ne[Me++] = 61)), $e ? (Me && $e.push(String.fromCharCode.apply(String, Ne.slice(0, Me))), $e.join("")) : String.fromCharCode.apply(String, Ne.slice(0, Me));
  };
  var ge = "invalid encoding";
  oe.decode = function(_e, Se, Ie) {
    for (var $e = Ie, Ne = 0, Me, Be = 0; Be < _e.length; ) {
      var ze = _e.charCodeAt(Be++);
      if (ze === 61 && Ne > 1)
        break;
      if ((ze = fe[ze]) === void 0)
        throw Error(ge);
      switch (Ne) {
        case 0:
          Me = ze, Ne = 1;
          break;
        case 1:
          Se[Ie++] = Me << 2 | (ze & 48) >> 4, Me = ze, Ne = 2;
          break;
        case 2:
          Se[Ie++] = (Me & 15) << 4 | (ze & 60) >> 2, Me = ze, Ne = 3;
          break;
        case 3:
          Se[Ie++] = (Me & 3) << 6 | ze, Ne = 0;
          break;
      }
    }
    if (Ne === 1)
      throw Error(ge);
    return Ie - $e;
  }, oe.test = function(_e) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(_e);
  };
})(base64$2);
var eventemitter = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function(oe, ae, fe) {
  return (this._listeners[oe] || (this._listeners[oe] = [])).push({
    fn: ae,
    ctx: fe || this
  }), this;
};
EventEmitter$1.prototype.off = function(oe, ae) {
  if (oe === void 0)
    this._listeners = {};
  else if (ae === void 0)
    this._listeners[oe] = [];
  else
    for (var fe = this._listeners[oe], ye = 0; ye < fe.length; )
      fe[ye].fn === ae ? fe.splice(ye, 1) : ++ye;
  return this;
};
EventEmitter$1.prototype.emit = function(oe) {
  var ae = this._listeners[oe];
  if (ae) {
    for (var fe = [], ye = 1; ye < arguments.length; )
      fe.push(arguments[ye++]);
    for (ye = 0; ye < ae.length; )
      ae[ye].fn.apply(ae[ye++].ctx, fe);
  }
  return this;
};
var float = factory(factory);
function factory(ne) {
  return typeof Float32Array < "u" ? function() {
    var oe = new Float32Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[3] === 128;
    function ye(Se, Ie, $e) {
      oe[0] = Se, Ie[$e] = ae[0], Ie[$e + 1] = ae[1], Ie[$e + 2] = ae[2], Ie[$e + 3] = ae[3];
    }
    function ge(Se, Ie, $e) {
      oe[0] = Se, Ie[$e] = ae[3], Ie[$e + 1] = ae[2], Ie[$e + 2] = ae[1], Ie[$e + 3] = ae[0];
    }
    ne.writeFloatLE = fe ? ye : ge, ne.writeFloatBE = fe ? ge : ye;
    function we(Se, Ie) {
      return ae[0] = Se[Ie], ae[1] = Se[Ie + 1], ae[2] = Se[Ie + 2], ae[3] = Se[Ie + 3], oe[0];
    }
    function _e(Se, Ie) {
      return ae[3] = Se[Ie], ae[2] = Se[Ie + 1], ae[1] = Se[Ie + 2], ae[0] = Se[Ie + 3], oe[0];
    }
    ne.readFloatLE = fe ? we : _e, ne.readFloatBE = fe ? _e : we;
  }() : function() {
    function oe(fe, ye, ge, we) {
      var _e = ye < 0 ? 1 : 0;
      if (_e && (ye = -ye), ye === 0)
        fe(1 / ye > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), ge, we);
      else if (isNaN(ye))
        fe(2143289344, ge, we);
      else if (ye > 34028234663852886e22)
        fe((_e << 31 | 2139095040) >>> 0, ge, we);
      else if (ye < 11754943508222875e-54)
        fe((_e << 31 | Math.round(ye / 1401298464324817e-60)) >>> 0, ge, we);
      else {
        var Se = Math.floor(Math.log(ye) / Math.LN2), Ie = Math.round(ye * Math.pow(2, -Se) * 8388608) & 8388607;
        fe((_e << 31 | Se + 127 << 23 | Ie) >>> 0, ge, we);
      }
    }
    ne.writeFloatLE = oe.bind(null, writeUintLE), ne.writeFloatBE = oe.bind(null, writeUintBE);
    function ae(fe, ye, ge) {
      var we = fe(ye, ge), _e = (we >> 31) * 2 + 1, Se = we >>> 23 & 255, Ie = we & 8388607;
      return Se === 255 ? Ie ? NaN : _e * (1 / 0) : Se === 0 ? _e * 1401298464324817e-60 * Ie : _e * Math.pow(2, Se - 150) * (Ie + 8388608);
    }
    ne.readFloatLE = ae.bind(null, readUintLE), ne.readFloatBE = ae.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var oe = new Float64Array([-0]), ae = new Uint8Array(oe.buffer), fe = ae[7] === 128;
    function ye(Se, Ie, $e) {
      oe[0] = Se, Ie[$e] = ae[0], Ie[$e + 1] = ae[1], Ie[$e + 2] = ae[2], Ie[$e + 3] = ae[3], Ie[$e + 4] = ae[4], Ie[$e + 5] = ae[5], Ie[$e + 6] = ae[6], Ie[$e + 7] = ae[7];
    }
    function ge(Se, Ie, $e) {
      oe[0] = Se, Ie[$e] = ae[7], Ie[$e + 1] = ae[6], Ie[$e + 2] = ae[5], Ie[$e + 3] = ae[4], Ie[$e + 4] = ae[3], Ie[$e + 5] = ae[2], Ie[$e + 6] = ae[1], Ie[$e + 7] = ae[0];
    }
    ne.writeDoubleLE = fe ? ye : ge, ne.writeDoubleBE = fe ? ge : ye;
    function we(Se, Ie) {
      return ae[0] = Se[Ie], ae[1] = Se[Ie + 1], ae[2] = Se[Ie + 2], ae[3] = Se[Ie + 3], ae[4] = Se[Ie + 4], ae[5] = Se[Ie + 5], ae[6] = Se[Ie + 6], ae[7] = Se[Ie + 7], oe[0];
    }
    function _e(Se, Ie) {
      return ae[7] = Se[Ie], ae[6] = Se[Ie + 1], ae[5] = Se[Ie + 2], ae[4] = Se[Ie + 3], ae[3] = Se[Ie + 4], ae[2] = Se[Ie + 5], ae[1] = Se[Ie + 6], ae[0] = Se[Ie + 7], oe[0];
    }
    ne.readDoubleLE = fe ? we : _e, ne.readDoubleBE = fe ? _e : we;
  }() : function() {
    function oe(fe, ye, ge, we, _e, Se) {
      var Ie = we < 0 ? 1 : 0;
      if (Ie && (we = -we), we === 0)
        fe(0, _e, Se + ye), fe(1 / we > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), _e, Se + ge);
      else if (isNaN(we))
        fe(0, _e, Se + ye), fe(2146959360, _e, Se + ge);
      else if (we > 17976931348623157e292)
        fe(0, _e, Se + ye), fe((Ie << 31 | 2146435072) >>> 0, _e, Se + ge);
      else {
        var $e;
        if (we < 22250738585072014e-324)
          $e = we / 5e-324, fe($e >>> 0, _e, Se + ye), fe((Ie << 31 | $e / 4294967296) >>> 0, _e, Se + ge);
        else {
          var Ne = Math.floor(Math.log(we) / Math.LN2);
          Ne === 1024 && (Ne = 1023), $e = we * Math.pow(2, -Ne), fe($e * 4503599627370496 >>> 0, _e, Se + ye), fe((Ie << 31 | Ne + 1023 << 20 | $e * 1048576 & 1048575) >>> 0, _e, Se + ge);
        }
      }
    }
    ne.writeDoubleLE = oe.bind(null, writeUintLE, 0, 4), ne.writeDoubleBE = oe.bind(null, writeUintBE, 4, 0);
    function ae(fe, ye, ge, we, _e) {
      var Se = fe(we, _e + ye), Ie = fe(we, _e + ge), $e = (Ie >> 31) * 2 + 1, Ne = Ie >>> 20 & 2047, Me = 4294967296 * (Ie & 1048575) + Se;
      return Ne === 2047 ? Me ? NaN : $e * (1 / 0) : Ne === 0 ? $e * 5e-324 * Me : $e * Math.pow(2, Ne - 1075) * (Me + 4503599627370496);
    }
    ne.readDoubleLE = ae.bind(null, readUintLE, 0, 4), ne.readDoubleBE = ae.bind(null, readUintBE, 4, 0);
  }(), ne;
}
function writeUintLE(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
function writeUintBE(ne, oe, ae) {
  oe[ae] = ne >>> 24, oe[ae + 1] = ne >>> 16 & 255, oe[ae + 2] = ne >>> 8 & 255, oe[ae + 3] = ne & 255;
}
function readUintLE(ne, oe) {
  return (ne[oe] | ne[oe + 1] << 8 | ne[oe + 2] << 16 | ne[oe + 3] << 24) >>> 0;
}
function readUintBE(ne, oe) {
  return (ne[oe] << 24 | ne[oe + 1] << 16 | ne[oe + 2] << 8 | ne[oe + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (ne) {
  }
  return null;
}
var utf8$2 = {};
(function(ne) {
  var oe = ne;
  oe.length = function(fe) {
    for (var ye = 0, ge = 0, we = 0; we < fe.length; ++we)
      ge = fe.charCodeAt(we), ge < 128 ? ye += 1 : ge < 2048 ? ye += 2 : (ge & 64512) === 55296 && (fe.charCodeAt(we + 1) & 64512) === 56320 ? (++we, ye += 4) : ye += 3;
    return ye;
  }, oe.read = function(fe, ye, ge) {
    var we = ge - ye;
    if (we < 1)
      return "";
    for (var _e = null, Se = [], Ie = 0, $e; ye < ge; )
      $e = fe[ye++], $e < 128 ? Se[Ie++] = $e : $e > 191 && $e < 224 ? Se[Ie++] = ($e & 31) << 6 | fe[ye++] & 63 : $e > 239 && $e < 365 ? ($e = (($e & 7) << 18 | (fe[ye++] & 63) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63) - 65536, Se[Ie++] = 55296 + ($e >> 10), Se[Ie++] = 56320 + ($e & 1023)) : Se[Ie++] = ($e & 15) << 12 | (fe[ye++] & 63) << 6 | fe[ye++] & 63, Ie > 8191 && ((_e || (_e = [])).push(String.fromCharCode.apply(String, Se)), Ie = 0);
    return _e ? (Ie && _e.push(String.fromCharCode.apply(String, Se.slice(0, Ie))), _e.join("")) : String.fromCharCode.apply(String, Se.slice(0, Ie));
  }, oe.write = function(fe, ye, ge) {
    for (var we = ge, _e, Se, Ie = 0; Ie < fe.length; ++Ie)
      _e = fe.charCodeAt(Ie), _e < 128 ? ye[ge++] = _e : _e < 2048 ? (ye[ge++] = _e >> 6 | 192, ye[ge++] = _e & 63 | 128) : (_e & 64512) === 55296 && ((Se = fe.charCodeAt(Ie + 1)) & 64512) === 56320 ? (_e = 65536 + ((_e & 1023) << 10) + (Se & 1023), ++Ie, ye[ge++] = _e >> 18 | 240, ye[ge++] = _e >> 12 & 63 | 128, ye[ge++] = _e >> 6 & 63 | 128, ye[ge++] = _e & 63 | 128) : (ye[ge++] = _e >> 12 | 224, ye[ge++] = _e >> 6 & 63 | 128, ye[ge++] = _e & 63 | 128);
    return ge - we;
  };
})(utf8$2);
var pool_1 = pool;
function pool(ne, oe, ae) {
  var fe = ae || 8192, ye = fe >>> 1, ge = null, we = fe;
  return function(Se) {
    if (Se < 1 || Se > ye)
      return ne(Se);
    we + Se > fe && (ge = ne(fe), we = 0);
    var Ie = oe.call(ge, we, we += Se);
    return we & 7 && (we = (we | 7) + 1), Ie;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = oe;
  var ne = requireMinimal();
  function oe(ge, we) {
    this.lo = ge >>> 0, this.hi = we >>> 0;
  }
  var ae = oe.zero = new oe(0, 0);
  ae.toNumber = function() {
    return 0;
  }, ae.zzEncode = ae.zzDecode = function() {
    return this;
  }, ae.length = function() {
    return 1;
  };
  var fe = oe.zeroHash = "\0\0\0\0\0\0\0\0";
  oe.fromNumber = function(we) {
    if (we === 0)
      return ae;
    var _e = we < 0;
    _e && (we = -we);
    var Se = we >>> 0, Ie = (we - Se) / 4294967296 >>> 0;
    return _e && (Ie = ~Ie >>> 0, Se = ~Se >>> 0, ++Se > 4294967295 && (Se = 0, ++Ie > 4294967295 && (Ie = 0))), new oe(Se, Ie);
  }, oe.from = function(we) {
    if (typeof we == "number")
      return oe.fromNumber(we);
    if (ne.isString(we))
      if (ne.Long)
        we = ne.Long.fromString(we);
      else
        return oe.fromNumber(parseInt(we, 10));
    return we.low || we.high ? new oe(we.low >>> 0, we.high >>> 0) : ae;
  }, oe.prototype.toNumber = function(we) {
    if (!we && this.hi >>> 31) {
      var _e = ~this.lo + 1 >>> 0, Se = ~this.hi >>> 0;
      return _e || (Se = Se + 1 >>> 0), -(_e + Se * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, oe.prototype.toLong = function(we) {
    return ne.Long ? new ne.Long(this.lo | 0, this.hi | 0, !!we) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!we };
  };
  var ye = String.prototype.charCodeAt;
  return oe.fromHash = function(we) {
    return we === fe ? ae : new oe(
      (ye.call(we, 0) | ye.call(we, 1) << 8 | ye.call(we, 2) << 16 | ye.call(we, 3) << 24) >>> 0,
      (ye.call(we, 4) | ye.call(we, 5) << 8 | ye.call(we, 6) << 16 | ye.call(we, 7) << 24) >>> 0
    );
  }, oe.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, oe.prototype.zzEncode = function() {
    var we = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ we) >>> 0, this.lo = (this.lo << 1 ^ we) >>> 0, this;
  }, oe.prototype.zzDecode = function() {
    var we = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ we) >>> 0, this.hi = (this.hi >>> 1 ^ we) >>> 0, this;
  }, oe.prototype.length = function() {
    var we = this.lo, _e = (this.lo >>> 28 | this.hi << 4) >>> 0, Se = this.hi >>> 24;
    return Se === 0 ? _e === 0 ? we < 16384 ? we < 128 ? 1 : 2 : we < 2097152 ? 3 : 4 : _e < 16384 ? _e < 128 ? 5 : 6 : _e < 2097152 ? 7 : 8 : Se < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(ne) {
    var oe = ne;
    oe.asPromise = aspromise, oe.base64 = base64$2, oe.EventEmitter = eventemitter, oe.float = float, oe.inquire = inquire_1, oe.utf8 = utf8$2, oe.pool = pool_1, oe.LongBits = requireLongbits(), oe.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), oe.global = oe.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, oe.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), oe.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), oe.isInteger = Number.isInteger || /* istanbul ignore next */
    function(ge) {
      return typeof ge == "number" && isFinite(ge) && Math.floor(ge) === ge;
    }, oe.isString = function(ge) {
      return typeof ge == "string" || ge instanceof String;
    }, oe.isObject = function(ge) {
      return ge && typeof ge == "object";
    }, oe.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    oe.isSet = function(ge, we) {
      var _e = ge[we];
      return _e != null && ge.hasOwnProperty(we) ? typeof _e != "object" || (Array.isArray(_e) ? _e.length : Object.keys(_e).length) > 0 : !1;
    }, oe.Buffer = function() {
      try {
        var ye = oe.inquire("buffer").Buffer;
        return ye.prototype.utf8Write ? ye : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), oe._Buffer_from = null, oe._Buffer_allocUnsafe = null, oe.newBuffer = function(ge) {
      return typeof ge == "number" ? oe.Buffer ? oe._Buffer_allocUnsafe(ge) : new oe.Array(ge) : oe.Buffer ? oe._Buffer_from(ge) : typeof Uint8Array > "u" ? ge : new Uint8Array(ge);
    }, oe.Array = typeof Uint8Array < "u" ? Uint8Array : Array, oe.Long = /* istanbul ignore next */
    oe.global.dcodeIO && /* istanbul ignore next */
    oe.global.dcodeIO.Long || /* istanbul ignore next */
    oe.global.Long || oe.inquire("long"), oe.key2Re = /^true|false|0|1$/, oe.key32Re = /^-?(?:0|[1-9][0-9]*)$/, oe.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, oe.longToHash = function(ge) {
      return ge ? oe.LongBits.from(ge).toHash() : oe.LongBits.zeroHash;
    }, oe.longFromHash = function(ge, we) {
      var _e = oe.LongBits.fromHash(ge);
      return oe.Long ? oe.Long.fromBits(_e.lo, _e.hi, we) : _e.toNumber(!!we);
    };
    function ae(ye, ge, we) {
      for (var _e = Object.keys(ge), Se = 0; Se < _e.length; ++Se)
        (ye[_e[Se]] === void 0 || !we) && (ye[_e[Se]] = ge[_e[Se]]);
      return ye;
    }
    oe.merge = ae, oe.lcFirst = function(ge) {
      return ge.charAt(0).toLowerCase() + ge.substring(1);
    };
    function fe(ye) {
      function ge(we, _e) {
        if (!(this instanceof ge))
          return new ge(we, _e);
        Object.defineProperty(this, "message", { get: function() {
          return we;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, ge) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), _e && ae(this, _e);
      }
      return ge.prototype = Object.create(Error.prototype, {
        constructor: {
          value: ge,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return ye;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), ge;
    }
    oe.newError = fe, oe.ProtocolError = fe("ProtocolError"), oe.oneOfGetter = function(ge) {
      for (var we = {}, _e = 0; _e < ge.length; ++_e)
        we[ge[_e]] = 1;
      return function() {
        for (var Se = Object.keys(this), Ie = Se.length - 1; Ie > -1; --Ie)
          if (we[Se[Ie]] === 1 && this[Se[Ie]] !== void 0 && this[Se[Ie]] !== null)
            return Se[Ie];
      };
    }, oe.oneOfSetter = function(ge) {
      return function(we) {
        for (var _e = 0; _e < ge.length; ++_e)
          ge[_e] !== we && delete this[ge[_e]];
      };
    }, oe.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, oe._configure = function() {
      var ye = oe.Buffer;
      if (!ye) {
        oe._Buffer_from = oe._Buffer_allocUnsafe = null;
        return;
      }
      oe._Buffer_from = ye.from !== Uint8Array.from && ye.from || /* istanbul ignore next */
      function(we, _e) {
        return new ye(we, _e);
      }, oe._Buffer_allocUnsafe = ye.allocUnsafe || /* istanbul ignore next */
      function(we) {
        return new ye(we);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1, util$5 = requireMinimal(), BufferWriter$1, LongBits$1 = util$5.LongBits, base64$1 = util$5.base64, utf8$1 = util$5.utf8;
function Op(ne, oe, ae) {
  this.fn = ne, this.len = oe, this.next = void 0, this.val = ae;
}
function noop$3() {
}
function State(ne) {
  this.head = ne.head, this.tail = ne.tail, this.len = ne.len, this.next = ne.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$3, 0, 0), this.tail = this.head, this.states = null;
}
var create$1 = function ne() {
  return util$5.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$1();
Writer$1.alloc = function ne(oe) {
  return new util$5.Array(oe);
};
util$5.Array !== Array && (Writer$1.alloc = util$5.pool(Writer$1.alloc, util$5.Array.prototype.subarray));
Writer$1.prototype._push = function ne(oe, ae, fe) {
  return this.tail = this.tail.next = new Op(oe, ae, fe), this.len += ae, this;
};
function writeByte(ne, oe, ae) {
  oe[ae] = ne & 255;
}
function writeVarint32(ne, oe, ae) {
  for (; ne > 127; )
    oe[ae++] = ne & 127 | 128, ne >>>= 7;
  oe[ae] = ne;
}
function VarintOp(ne, oe) {
  this.len = ne, this.next = void 0, this.val = oe;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function ne(oe) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (oe = oe >>> 0) < 128 ? 1 : oe < 16384 ? 2 : oe < 2097152 ? 3 : oe < 268435456 ? 4 : 5,
    oe
  )).len, this;
};
Writer$1.prototype.int32 = function ne(oe) {
  return oe < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(oe)) : this.uint32(oe);
};
Writer$1.prototype.sint32 = function ne(oe) {
  return this.uint32((oe << 1 ^ oe >> 31) >>> 0);
};
function writeVarint64(ne, oe, ae) {
  for (; ne.hi; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = (ne.lo >>> 7 | ne.hi << 25) >>> 0, ne.hi >>>= 7;
  for (; ne.lo > 127; )
    oe[ae++] = ne.lo & 127 | 128, ne.lo = ne.lo >>> 7;
  oe[ae++] = ne.lo;
}
Writer$1.prototype.uint64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function ne(oe) {
  var ae = LongBits$1.from(oe).zzEncode();
  return this._push(writeVarint64, ae.length(), ae);
};
Writer$1.prototype.bool = function ne(oe) {
  return this._push(writeByte, 1, oe ? 1 : 0);
};
function writeFixed32(ne, oe, ae) {
  oe[ae] = ne & 255, oe[ae + 1] = ne >>> 8 & 255, oe[ae + 2] = ne >>> 16 & 255, oe[ae + 3] = ne >>> 24;
}
Writer$1.prototype.fixed32 = function ne(oe) {
  return this._push(writeFixed32, 4, oe >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function ne(oe) {
  var ae = LongBits$1.from(oe);
  return this._push(writeFixed32, 4, ae.lo)._push(writeFixed32, 4, ae.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function ne(oe) {
  return this._push(util$5.float.writeFloatLE, 4, oe);
};
Writer$1.prototype.double = function ne(oe) {
  return this._push(util$5.float.writeDoubleLE, 8, oe);
};
var writeBytes = util$5.Array.prototype.set ? function ne(oe, ae, fe) {
  ae.set(oe, fe);
} : function ne(oe, ae, fe) {
  for (var ye = 0; ye < oe.length; ++ye)
    ae[fe + ye] = oe[ye];
};
Writer$1.prototype.bytes = function ne(oe) {
  var ae = oe.length >>> 0;
  if (!ae)
    return this._push(writeByte, 1, 0);
  if (util$5.isString(oe)) {
    var fe = Writer$1.alloc(ae = base64$1.length(oe));
    base64$1.decode(oe, fe, 0), oe = fe;
  }
  return this.uint32(ae)._push(writeBytes, ae, oe);
};
Writer$1.prototype.string = function ne(oe) {
  var ae = utf8$1.length(oe);
  return ae ? this.uint32(ae)._push(utf8$1.write, ae, oe) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function ne() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function ne() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$3, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function ne() {
  var oe = this.head, ae = this.tail, fe = this.len;
  return this.reset().uint32(fe), fe && (this.tail.next = oe.next, this.tail = ae, this.len += fe), this;
};
Writer$1.prototype.finish = function ne() {
  for (var oe = this.head.next, ae = this.constructor.alloc(this.len), fe = 0; oe; )
    oe.fn(oe.val, ae, fe), fe += oe.len, oe = oe.next;
  return ae;
};
Writer$1._configure = function(ne) {
  BufferWriter$1 = ne, Writer$1.create = create$1(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$4 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$4._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$4.Buffer && util$4.Buffer.prototype instanceof Uint8Array && util$4.Buffer.prototype.set.name === "set" ? function(oe, ae, fe) {
    ae.set(oe, fe);
  } : function(oe, ae, fe) {
    if (oe.copy)
      oe.copy(ae, fe, 0, oe.length);
    else
      for (var ye = 0; ye < oe.length; )
        ae[fe++] = oe[ye++];
  };
};
BufferWriter.prototype.bytes = function ne(oe) {
  util$4.isString(oe) && (oe = util$4._Buffer_from(oe, "base64"));
  var ae = oe.length >>> 0;
  return this.uint32(ae), ae && this._push(BufferWriter.writeBytesBuffer, ae, oe), this;
};
function writeStringBuffer(ne, oe, ae) {
  ne.length < 40 ? util$4.utf8.write(ne, oe, ae) : oe.utf8Write ? oe.utf8Write(ne, ae) : oe.write(ne, ae);
}
BufferWriter.prototype.string = function ne(oe) {
  var ae = util$4.Buffer.byteLength(oe);
  return this.uint32(ae), ae && this._push(writeStringBuffer, ae, oe), this;
};
BufferWriter._configure();
var reader = Reader$1, util$3 = requireMinimal(), BufferReader$1, LongBits = util$3.LongBits, utf8 = util$3.utf8;
function indexOutOfRange(ne, oe) {
  return RangeError("index out of range: " + ne.pos + " + " + (oe || 1) + " > " + ne.len);
}
function Reader$1(ne) {
  this.buf = ne, this.pos = 0, this.len = ne.length;
}
var create_array = typeof Uint8Array < "u" ? function ne(oe) {
  if (oe instanceof Uint8Array || Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
} : function ne(oe) {
  if (Array.isArray(oe))
    return new Reader$1(oe);
  throw Error("illegal buffer");
}, create = function ne() {
  return util$3.Buffer ? function(ae) {
    return (Reader$1.create = function(ye) {
      return util$3.Buffer.isBuffer(ye) ? new BufferReader$1(ye) : create_array(ye);
    })(ae);
  } : create_array;
};
Reader$1.create = create();
Reader$1.prototype._slice = util$3.Array.prototype.subarray || /* istanbul ignore next */
util$3.Array.prototype.slice;
Reader$1.prototype.uint32 = function ne() {
  var oe = 4294967295;
  return function() {
    if (oe = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (oe = (oe | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (oe = (oe | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return oe;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return oe;
  };
}();
Reader$1.prototype.int32 = function ne() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function ne() {
  var oe = this.uint32();
  return oe >>> 1 ^ -(oe & 1) | 0;
};
function readLongVarint() {
  var ne = new LongBits(0, 0), oe = 0;
  if (this.len - this.pos > 4) {
    for (; oe < 4; ++oe)
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << 28) >>> 0, ne.hi = (ne.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return ne;
    oe = 0;
  } else {
    for (; oe < 3; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.lo = (ne.lo | (this.buf[this.pos] & 127) << oe * 7) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
    return ne.lo = (ne.lo | (this.buf[this.pos++] & 127) << oe * 7) >>> 0, ne;
  }
  if (this.len - this.pos > 4) {
    for (; oe < 5; ++oe)
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
  } else
    for (; oe < 5; ++oe) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (ne.hi = (ne.hi | (this.buf[this.pos] & 127) << oe * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return ne;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function ne() {
  return this.uint32() !== 0;
};
function readFixed32_end(ne, oe) {
  return (ne[oe - 4] | ne[oe - 3] << 8 | ne[oe - 2] << 16 | ne[oe - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function ne() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, oe;
};
Reader$1.prototype.double = function ne() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var oe = util$3.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, oe;
};
Reader$1.prototype.bytes = function ne() {
  var oe = this.uint32(), ae = this.pos, fe = this.pos + oe;
  if (fe > this.len)
    throw indexOutOfRange(this, oe);
  if (this.pos += oe, Array.isArray(this.buf))
    return this.buf.slice(ae, fe);
  if (ae === fe) {
    var ye = util$3.Buffer;
    return ye ? ye.alloc(0) : new this.buf.constructor(0);
  }
  return this._slice.call(this.buf, ae, fe);
};
Reader$1.prototype.string = function ne() {
  var oe = this.bytes();
  return utf8.read(oe, 0, oe.length);
};
Reader$1.prototype.skip = function ne(oe) {
  if (typeof oe == "number") {
    if (this.pos + oe > this.len)
      throw indexOutOfRange(this, oe);
    this.pos += oe;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(ne) {
  switch (ne) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (ne = this.uint32() & 7) !== 4; )
        this.skipType(ne);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + ne + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(ne) {
  BufferReader$1 = ne, Reader$1.create = create(), BufferReader$1._configure();
  var oe = util$3.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$3.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[oe](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[oe](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[oe](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[oe](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[oe](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$2 = requireMinimal();
function BufferReader(ne) {
  Reader.call(this, ne);
}
BufferReader._configure = function() {
  util$2.Buffer && (BufferReader.prototype._slice = util$2.Buffer.prototype.slice);
};
BufferReader.prototype.string = function ne() {
  var oe = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + oe, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + oe, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$1 = requireMinimal();
(Service.prototype = Object.create(util$1.EventEmitter.prototype)).constructor = Service;
function Service(ne, oe, ae) {
  if (typeof ne != "function")
    throw TypeError("rpcImpl must be a function");
  util$1.EventEmitter.call(this), this.rpcImpl = ne, this.requestDelimited = !!oe, this.responseDelimited = !!ae;
}
Service.prototype.rpcCall = function ne(oe, ae, fe, ye, ge) {
  if (!ye)
    throw TypeError("request must be specified");
  var we = this;
  if (!ge)
    return util$1.asPromise(ne, we, oe, ae, fe, ye);
  if (!we.rpcImpl) {
    setTimeout(function() {
      ge(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return we.rpcImpl(
      oe,
      ae[we.requestDelimited ? "encodeDelimited" : "encode"](ye).finish(),
      function(Se, Ie) {
        if (Se)
          return we.emit("error", Se, oe), ge(Se);
        if (Ie === null) {
          we.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(Ie instanceof fe))
          try {
            Ie = fe[we.responseDelimited ? "decodeDelimited" : "decode"](Ie);
          } catch ($e) {
            return we.emit("error", $e, oe), ge($e);
          }
        return we.emit("data", Ie, oe), ge(null, Ie);
      }
    );
  } catch (_e) {
    we.emit("error", _e, oe), setTimeout(function() {
      ge(_e);
    }, 0);
    return;
  }
};
Service.prototype.end = function ne(oe) {
  return this.rpcImpl && (oe || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(ne) {
  var oe = ne;
  oe.Service = service;
})(rpc);
var roots = {};
(function(ne) {
  var oe = ne;
  oe.build = "minimal", oe.Writer = writer, oe.BufferWriter = writer_buffer, oe.Reader = reader, oe.BufferReader = reader_buffer, oe.util = requireMinimal(), oe.rpc = rpc, oe.roots = roots, oe.configure = ae;
  function ae() {
    oe.util._configure(), oe.Writer._configure(oe.BufferWriter), oe.Reader._configure(oe.BufferReader);
  }
  ae();
})(indexMinimal);
var minimal = indexMinimal;
const _m0 = /* @__PURE__ */ getDefaultExportFromCjs(minimal);
var lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function ne(oe) {
  const ae = /* @__PURE__ */ new Map(), fe = {
    set(ye, ge) {
      if (ye = normalizeKey(ye), Array.isArray(ge))
        if (ge.length === 0)
          ae.delete(ye);
        else {
          for (const we of ge)
            validate(ye, we);
          ae.set(ye, ye.endsWith("-bin") ? ge : [ge.join(", ")]);
        }
      else
        validate(ye, ge), ae.set(ye, [ge]);
      return fe;
    },
    append(ye, ge) {
      ye = normalizeKey(ye), validate(ye, ge);
      let we = ae.get(ye);
      return we == null && (we = [], ae.set(ye, we)), we.push(ge), ye.endsWith("-bin") || ae.set(ye, [we.join(", ")]), fe;
    },
    delete(ye) {
      ye = normalizeKey(ye), ae.delete(ye);
    },
    get(ye) {
      var ge;
      return ye = normalizeKey(ye), (ge = ae.get(ye)) === null || ge === void 0 ? void 0 : ge[0];
    },
    getAll(ye) {
      var ge;
      return ye = normalizeKey(ye), (ge = ae.get(ye)) !== null && ge !== void 0 ? ge : [];
    },
    has(ye) {
      return ye = normalizeKey(ye), ae.has(ye);
    },
    [Symbol.iterator]() {
      return ae[Symbol.iterator]();
    }
  };
  if (oe != null) {
    const ye = isIterable$1(oe) ? oe : Object.entries(oe);
    for (const [ge, we] of ye)
      fe.set(ge, we);
  }
  return fe;
};
function normalizeKey(ne) {
  return ne.toLowerCase();
}
function validate(ne, oe) {
  if (!/^[0-9a-z_.-]+$/.test(ne))
    throw new Error(`Metadata key '${ne}' contains illegal characters`);
  if (ne.endsWith("-bin")) {
    if (!(oe instanceof Uint8Array))
      throw new Error(`Metadata key '${ne}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof oe != "string")
      throw new Error(`Metadata key '${ne}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(oe))
      throw new Error(`Metadata value '${oe}' of key '${ne}' contains illegal characters`);
  }
}
function isIterable$1(ne) {
  return Symbol.iterator in ne;
}
var Status = {};
(function(ne) {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = void 0, function(oe) {
    oe[oe.OK = 0] = "OK", oe[oe.CANCELLED = 1] = "CANCELLED", oe[oe.UNKNOWN = 2] = "UNKNOWN", oe[oe.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", oe[oe.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", oe[oe.NOT_FOUND = 5] = "NOT_FOUND", oe[oe.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", oe[oe.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", oe[oe.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", oe[oe.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", oe[oe.ABORTED = 10] = "ABORTED", oe[oe.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", oe[oe.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", oe[oe.INTERNAL = 13] = "INTERNAL", oe[oe.UNAVAILABLE = 14] = "UNAVAILABLE", oe[oe.DATA_LOSS = 15] = "DATA_LOSS", oe[oe.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(ne.Status || (ne.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(ne, oe) {
  return (ae, fe) => oe(Object.assign(Object.assign({}, ae), { next: (ye, ge) => ne(Object.assign(Object.assign({}, ae), { request: ye }), ge) }), fe);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function ne(oe, ae) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(oe, ae) : oe.__proto__ = ae;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function ne(oe) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(oe) : oe.__proto__ || oe.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function ne(oe, ae, fe) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(oe, ae, fe);
    } catch {
      ie8ObjectDefinePropertyBug = !0, ne(oe, ae, fe);
    }
  else
    oe[ae] = fe.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty = function ne(oe, ae) {
  return objectHasOwnPropertyIsDefined ? oe.hasOwnProperty(oe, ae) : oe[ae] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty;
var objectCreate = function ne(oe, ae) {
  if (objectCreateIsDefined)
    return Object.create(oe, ae);
  var fe = function() {
  };
  fe.prototype = oe;
  var ye = new fe();
  if (typeof ae > "u")
    return ye;
  if (typeof ae == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof ae == "object")
    for (var ge in ae)
      hasOwnProperty(ae, ge) && (ye[ge] = ae[ge].value);
  return ye;
};
helpers.objectCreate = objectCreate;
(function(ne) {
  ne.__esModule = void 0, ne.__esModule = !0;
  var oe = helpers, ae = oe.setPrototypeOf, fe = oe.getPrototypeOf, ye = oe.defineProperty, ge = oe.objectCreate, we = new Error().toString() === "[object Error]", _e = "";
  function Se(Ie) {
    var $e = this.constructor, Ne = $e.name || function() {
      var Ze = $e.toString().match(/^function\s*([^\s(]+)/);
      return Ze === null ? _e || "Error" : Ze[1];
    }(), Me = Ne === "Error", Be = Me ? _e : Ne, ze = Error.apply(this, arguments);
    if (ae(ze, fe(this)), !(ze instanceof $e) || !(ze instanceof Se)) {
      var ze = this;
      Error.apply(this, arguments), ye(ze, "message", {
        configurable: !0,
        enumerable: !1,
        value: Ie,
        writable: !0
      });
    }
    if (ye(ze, "name", {
      configurable: !0,
      enumerable: !1,
      value: Be,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      ze,
      Me ? Se : $e
    ), ze.stack === void 0) {
      var He = new Error(Ie);
      He.name = ze.name, ze.stack = He.stack;
    }
    return we && ye(ze, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), ze;
  }
  _e = Se.name || "ExtendableError", Se.prototype = ge(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), ne.ExtendableError = Se, ne.default = ne.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(oe, ae, fe) {
    super(`${oe} ${Status_1$1.Status[ae]}: ${fe}`), this.path = oe, this.code = ae, this.details = fe, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ClientError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ClientError || oe["@@nice-grpc:ClientError"] === !0 || oe.name === "ClientError" && oe["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(ne, oe) {
  return (ae, fe) => ne(Object.assign(Object.assign({}, ae), { next: (ye, ge) => oe(Object.assign(Object.assign({}, ae), { request: ye }), ge) }), fe);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(oe, ae) {
    super(`${Status_1.Status[oe]}: ${ae}`), this.code = oe, this.details = ae, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](oe) {
    return this !== ServerError ? this.prototype.isPrototypeOf(oe) : typeof oe == "object" && oe !== null && (oe.constructor === ServerError || oe["@@nice-grpc:ServerError"] === !0 || oe.name === "ServerError" && oe["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ye, ge, we) {
    we === void 0 && (we = ge);
    var _e = Object.getOwnPropertyDescriptor(ye, ge);
    (!_e || ("get" in _e ? !ye.__esModule : _e.writable || _e.configurable)) && (_e = { enumerable: !0, get: function() {
      return ye[ge];
    } }), Object.defineProperty(fe, we, _e);
  } : function(fe, ye, ge, we) {
    we === void 0 && (we = ge), fe[we] = ye[ge];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ye) {
    for (var ge in fe)
      ge !== "default" && !Object.prototype.hasOwnProperty.call(ye, ge) && oe(ye, fe, ge);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ae(Metadata, ne), ae(Status, ne), ae(MethodDescriptor, ne), ae(CallOptions, ne), ae(ClientMiddleware, ne), ae(composeClientMiddleware$1, ne), ae(ClientError$1, ne), ae(CallContext, ne), ae(ServerMiddleware, ne), ae(composeServerMiddleware$1, ne), ae(ServerError$1, ne);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne)) {
    if (ae === "serviceName")
      continue;
    const ye = fe;
    oe[uncapitalize(ae)] = {
      path: `/${ne.serviceName}/${ae}`,
      requestStream: ye.requestStream,
      responseStream: ye.responseStream,
      requestDeserialize: ye.requestType.deserializeBinary,
      requestSerialize: (ge) => ge.serializeBinary(),
      responseDeserialize: ye.responseType.deserializeBinary,
      responseSerialize: (ge) => ge.serializeBinary(),
      options: {}
    };
  }
  return oe;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(ne) {
  return "prototype" in ne;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(ne) {
  return ne.length === 0 ? ne : ne[0].toLowerCase() + ne.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(ne) {
  const oe = {};
  for (const [ae, fe] of Object.entries(ne.methods)) {
    const ye = fe.requestType.encode, ge = fe.requestType.fromPartial, we = fe.responseType.encode, _e = fe.responseType.fromPartial;
    oe[ae] = {
      path: `/${ne.fullName}/${fe.name}`,
      requestStream: fe.requestStream,
      responseStream: fe.responseStream,
      requestDeserialize: fe.requestType.decode,
      requestSerialize: ge != null ? (Se) => ye(ge(Se)).finish() : (Se) => ye(Se).finish(),
      responseDeserialize: fe.responseType.decode,
      responseSerialize: _e != null ? (Se) => we(_e(Se)).finish() : (Se) => we(Se).finish(),
      options: fe.options
    };
  }
  return oe;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(ne) {
  return "name" in ne && "fullName" in ne && "methods" in ne;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(ne) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(ne) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(ne) : (0, ts_proto_1.isTsProtoServiceDefinition)(ne) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(ne) : ne;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(ne) {
  const [, oe, ae] = ne.path.split("/");
  return {
    service: {
      serviceName: oe
    },
    methodName: ae,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.requestDeserialize(fe);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(fe) {
        return ne.responseDeserialize(fe);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(ne, oe) {
  return { address: ne, transport: oe };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(commonjsGlobal, function() {
    return ae = { 418: function(ye, ge) {
      (function(we, _e) {
        for (var Se in _e)
          we[Se] = _e[Se];
      })(ge, function(we) {
        var _e = {};
        function Se(Ie) {
          if (_e[Ie])
            return _e[Ie].exports;
          var $e = _e[Ie] = { i: Ie, l: !1, exports: {} };
          return we[Ie].call($e.exports, $e, $e.exports, Se), $e.l = !0, $e.exports;
        }
        return Se.m = we, Se.c = _e, Se.i = function(Ie) {
          return Ie;
        }, Se.d = function(Ie, $e, Ne) {
          Se.o(Ie, $e) || Object.defineProperty(Ie, $e, { configurable: !1, enumerable: !0, get: Ne });
        }, Se.n = function(Ie) {
          var $e = Ie && Ie.__esModule ? function() {
            return Ie.default;
          } : function() {
            return Ie;
          };
          return Se.d($e, "a", $e), $e;
        }, Se.o = function(Ie, $e) {
          return Object.prototype.hasOwnProperty.call(Ie, $e);
        }, Se.p = "", Se(Se.s = 1);
      }([function(we, _e, Se) {
        Object.defineProperty(_e, "__esModule", { value: !0 });
        var Ie = Se(3), $e = function() {
          function Ne(Me, Be) {
            Me === void 0 && (Me = {}), Be === void 0 && (Be = { splitValues: !1 });
            var ze, He = this;
            this.headersMap = {}, Me && (typeof Headers < "u" && Me instanceof Headers ? Ie.getHeaderKeys(Me).forEach(function(Ze) {
              Ie.getHeaderValues(Me, Ze).forEach(function(qe) {
                Be.splitValues ? He.append(Ze, Ie.splitHeaderValue(qe)) : He.append(Ze, qe);
              });
            }) : typeof (ze = Me) == "object" && typeof ze.headersMap == "object" && typeof ze.forEach == "function" ? Me.forEach(function(Ze, qe) {
              He.append(Ze, qe);
            }) : typeof Map < "u" && Me instanceof Map ? Me.forEach(function(Ze, qe) {
              He.append(qe, Ze);
            }) : typeof Me == "string" ? this.appendFromString(Me) : typeof Me == "object" && Object.getOwnPropertyNames(Me).forEach(function(Ze) {
              var qe = Me[Ze];
              Array.isArray(qe) ? qe.forEach(function(tt) {
                He.append(Ze, tt);
              }) : He.append(Ze, qe);
            }));
          }
          return Ne.prototype.appendFromString = function(Me) {
            for (var Be = Me.split(`\r
`), ze = 0; ze < Be.length; ze++) {
              var He = Be[ze], Ze = He.indexOf(":");
              if (Ze > 0) {
                var qe = He.substring(0, Ze).trim(), tt = He.substring(Ze + 1).trim();
                this.append(qe, tt);
              }
            }
          }, Ne.prototype.delete = function(Me, Be) {
            var ze = Ie.normalizeName(Me);
            if (Be === void 0)
              delete this.headersMap[ze];
            else {
              var He = this.headersMap[ze];
              if (He) {
                var Ze = He.indexOf(Be);
                Ze >= 0 && He.splice(Ze, 1), He.length === 0 && delete this.headersMap[ze];
              }
            }
          }, Ne.prototype.append = function(Me, Be) {
            var ze = this, He = Ie.normalizeName(Me);
            Array.isArray(this.headersMap[He]) || (this.headersMap[He] = []), Array.isArray(Be) ? Be.forEach(function(Ze) {
              ze.headersMap[He].push(Ie.normalizeValue(Ze));
            }) : this.headersMap[He].push(Ie.normalizeValue(Be));
          }, Ne.prototype.set = function(Me, Be) {
            var ze = Ie.normalizeName(Me);
            if (Array.isArray(Be)) {
              var He = [];
              Be.forEach(function(Ze) {
                He.push(Ie.normalizeValue(Ze));
              }), this.headersMap[ze] = He;
            } else
              this.headersMap[ze] = [Ie.normalizeValue(Be)];
          }, Ne.prototype.has = function(Me, Be) {
            var ze = this.headersMap[Ie.normalizeName(Me)];
            if (!Array.isArray(ze))
              return !1;
            if (Be !== void 0) {
              var He = Ie.normalizeValue(Be);
              return ze.indexOf(He) >= 0;
            }
            return !0;
          }, Ne.prototype.get = function(Me) {
            var Be = this.headersMap[Ie.normalizeName(Me)];
            return Be !== void 0 ? Be.concat() : [];
          }, Ne.prototype.forEach = function(Me) {
            var Be = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(ze) {
              Me(ze, Be.headersMap[ze]);
            }, this);
          }, Ne.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var Me = new Headers();
              return this.forEach(function(Be, ze) {
                ze.forEach(function(He) {
                  Me.append(Be, He);
                });
              }), Me;
            }
            throw new Error("Headers class is not defined");
          }, Ne;
        }();
        _e.BrowserHeaders = $e;
      }, function(we, _e, Se) {
        Object.defineProperty(_e, "__esModule", { value: !0 });
        var Ie = Se(0);
        _e.BrowserHeaders = Ie.BrowserHeaders;
      }, function(we, _e, Se) {
        Object.defineProperty(_e, "__esModule", { value: !0 }), _e.iterateHeaders = function(Ie, $e) {
          for (var Ne = Ie[Symbol.iterator](), Me = Ne.next(); !Me.done; )
            $e(Me.value[0]), Me = Ne.next();
        }, _e.iterateHeadersKeys = function(Ie, $e) {
          for (var Ne = Ie.keys(), Me = Ne.next(); !Me.done; )
            $e(Me.value), Me = Ne.next();
        };
      }, function(we, _e, Se) {
        Object.defineProperty(_e, "__esModule", { value: !0 });
        var Ie = Se(2);
        _e.normalizeName = function($e) {
          if (typeof $e != "string" && ($e = String($e)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test($e))
            throw new TypeError("Invalid character in header field name");
          return $e.toLowerCase();
        }, _e.normalizeValue = function($e) {
          return typeof $e != "string" && ($e = String($e)), $e;
        }, _e.getHeaderValues = function($e, Ne) {
          var Me = $e;
          if (Me instanceof Headers && Me.getAll)
            return Me.getAll(Ne);
          var Be = Me.get(Ne);
          return Be && typeof Be == "string" ? [Be] : Be;
        }, _e.getHeaderKeys = function($e) {
          var Ne = $e, Me = {}, Be = [];
          return Ne.keys ? Ie.iterateHeadersKeys(Ne, function(ze) {
            Me[ze] || (Me[ze] = !0, Be.push(ze));
          }) : Ne.forEach ? Ne.forEach(function(ze, He) {
            Me[He] || (Me[He] = !0, Be.push(He));
          }) : Ie.iterateHeaders(Ne, function(ze) {
            var He = ze[0];
            Me[He] || (Me[He] = !0, Be.push(He));
          }), Be;
        }, _e.splitHeaderValue = function($e) {
          var Ne = [];
          return $e.split(", ").forEach(function(Me) {
            Me.split(",").forEach(function(Be) {
              Ne.push(Be);
            });
          }), Ne;
        };
      }]));
    }, 617: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.ChunkParser = ge.ChunkType = ge.encodeASCII = ge.decodeASCII = void 0;
      var _e, Se = we(65);
      function Ie(Ze) {
        return (qe = Ze) === 9 || qe === 10 || qe === 13 || Ze >= 32 && Ze <= 126;
        var qe;
      }
      function $e(Ze) {
        for (var qe = 0; qe !== Ze.length; ++qe)
          if (!Ie(Ze[qe]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(Ze));
      }
      function Ne(Ze) {
        return (128 & Ze.getUint8(0)) == 128;
      }
      function Me(Ze) {
        return Ze.getUint32(1, !1);
      }
      function Be(Ze, qe, tt) {
        return Ze.byteLength - qe >= tt;
      }
      function ze(Ze, qe, tt) {
        if (Ze.slice)
          return Ze.slice(qe, tt);
        var Xe = Ze.length;
        tt !== void 0 && (Xe = tt);
        for (var ot = new Uint8Array(Xe - qe), pt = 0, ht = qe; ht < Xe; ht++)
          ot[pt++] = Ze[ht];
        return ot;
      }
      ge.decodeASCII = $e, ge.encodeASCII = function(Ze) {
        for (var qe = new Uint8Array(Ze.length), tt = 0; tt !== Ze.length; ++tt) {
          var Xe = Ze.charCodeAt(tt);
          if (!Ie(Xe))
            throw new Error("Metadata contains invalid ASCII");
          qe[tt] = Xe;
        }
        return qe;
      }, function(Ze) {
        Ze[Ze.MESSAGE = 1] = "MESSAGE", Ze[Ze.TRAILERS = 2] = "TRAILERS";
      }(_e = ge.ChunkType || (ge.ChunkType = {}));
      var He = function() {
        function Ze() {
          this.buffer = null, this.position = 0;
        }
        return Ze.prototype.parse = function(qe, tt) {
          if (qe.length === 0 && tt)
            return [];
          var Xe, ot = [];
          if (this.buffer == null)
            this.buffer = qe, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = qe, this.position = 0;
          else {
            var pt = this.buffer.byteLength - this.position, ht = new Uint8Array(pt + qe.byteLength), wt = ze(this.buffer, this.position);
            ht.set(wt, 0);
            var gt = new Uint8Array(qe);
            ht.set(gt, pt), this.buffer = ht, this.position = 0;
          }
          for (; ; ) {
            if (!Be(this.buffer, this.position, 5))
              return ot;
            var It = ze(this.buffer, this.position, this.position + 5), Nt = new DataView(It.buffer, It.byteOffset, It.byteLength), Ft = Me(Nt);
            if (!Be(this.buffer, this.position, 5 + Ft))
              return ot;
            var on = ze(this.buffer, this.position + 5, this.position + 5 + Ft);
            if (this.position += 5 + Ft, Ne(Nt))
              return ot.push({ chunkType: _e.TRAILERS, trailers: (Xe = on, new Se.Metadata($e(Xe))) }), ot;
            ot.push({ chunkType: _e.MESSAGE, data: on });
          }
        }, Ze;
      }();
      ge.ChunkParser = He;
    }, 8: function(ye, ge) {
      var we;
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.httpStatusToCode = ge.Code = void 0, function(_e) {
        _e[_e.OK = 0] = "OK", _e[_e.Canceled = 1] = "Canceled", _e[_e.Unknown = 2] = "Unknown", _e[_e.InvalidArgument = 3] = "InvalidArgument", _e[_e.DeadlineExceeded = 4] = "DeadlineExceeded", _e[_e.NotFound = 5] = "NotFound", _e[_e.AlreadyExists = 6] = "AlreadyExists", _e[_e.PermissionDenied = 7] = "PermissionDenied", _e[_e.ResourceExhausted = 8] = "ResourceExhausted", _e[_e.FailedPrecondition = 9] = "FailedPrecondition", _e[_e.Aborted = 10] = "Aborted", _e[_e.OutOfRange = 11] = "OutOfRange", _e[_e.Unimplemented = 12] = "Unimplemented", _e[_e.Internal = 13] = "Internal", _e[_e.Unavailable = 14] = "Unavailable", _e[_e.DataLoss = 15] = "DataLoss", _e[_e.Unauthenticated = 16] = "Unauthenticated";
      }(we = ge.Code || (ge.Code = {})), ge.httpStatusToCode = function(_e) {
        switch (_e) {
          case 0:
            return we.Internal;
          case 200:
            return we.OK;
          case 400:
            return we.InvalidArgument;
          case 401:
            return we.Unauthenticated;
          case 403:
            return we.PermissionDenied;
          case 404:
            return we.NotFound;
          case 409:
            return we.Aborted;
          case 412:
            return we.FailedPrecondition;
          case 429:
            return we.ResourceExhausted;
          case 499:
            return we.Canceled;
          case 500:
            return we.Unknown;
          case 501:
            return we.Unimplemented;
          case 503:
            return we.Unavailable;
          case 504:
            return we.DeadlineExceeded;
          default:
            return we.Unknown;
        }
      };
    }, 934: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.client = void 0;
      var _e = we(65), Se = we(617), Ie = we(8), $e = we(346), Ne = we(57), Me = we(882);
      ge.client = function(He, Ze) {
        return new Be(He, Ze);
      };
      var Be = function() {
        function He(Ze, qe) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new Se.ChunkParser(), this.methodDefinition = Ze, this.props = qe, this.createTransport();
        }
        return He.prototype.createTransport = function() {
          var Ze = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, qe = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: Ze, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(qe) : this.transport = Ne.makeDefaultTransport(qe);
        }, He.prototype.onTransportHeaders = function(Ze, qe) {
          if (this.props.debug && $e.debug("onHeaders", Ze, qe), this.closed)
            this.props.debug && $e.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (qe !== 0) {
            this.responseHeaders = Ze, this.props.debug && $e.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var tt = ze(Ze);
            this.props.debug && $e.debug("onHeaders.gRPCStatus", tt);
            var Xe = tt && tt >= 0 ? tt : Ie.httpStatusToCode(qe);
            this.props.debug && $e.debug("onHeaders.code", Xe);
            var ot = Ze.get("grpc-message") || [];
            if (this.props.debug && $e.debug("onHeaders.gRPCMessage", ot), this.rawOnHeaders(Ze), Xe !== Ie.Code.OK) {
              var pt = this.decodeGRPCStatus(ot[0]);
              this.rawOnError(Xe, pt, Ze);
            }
          }
        }, He.prototype.onTransportChunk = function(Ze) {
          var qe = this;
          if (this.closed)
            this.props.debug && $e.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var tt = [];
            try {
              tt = this.parser.parse(Ze);
            } catch (Xe) {
              return this.props.debug && $e.debug("onChunk.parsing error", Xe, Xe.message), void this.rawOnError(Ie.Code.Internal, "parsing error: " + Xe.message);
            }
            tt.forEach(function(Xe) {
              if (Xe.chunkType === Se.ChunkType.MESSAGE) {
                var ot = qe.methodDefinition.responseType.deserializeBinary(Xe.data);
                qe.rawOnMessage(ot);
              } else
                Xe.chunkType === Se.ChunkType.TRAILERS && (qe.responseHeaders ? (qe.responseTrailers = new _e.Metadata(Xe.trailers), qe.props.debug && $e.debug("onChunk.trailers", qe.responseTrailers)) : (qe.responseHeaders = new _e.Metadata(Xe.trailers), qe.rawOnHeaders(qe.responseHeaders)));
            });
          }
        }, He.prototype.onTransportEnd = function() {
          if (this.props.debug && $e.debug("grpc.onEnd"), this.closed)
            this.props.debug && $e.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var Ze = ze(this.responseTrailers);
            if (Ze !== null) {
              var qe = this.responseTrailers.get("grpc-message"), tt = this.decodeGRPCStatus(qe[0]);
              this.rawOnEnd(Ze, tt, this.responseTrailers);
            } else
              this.rawOnError(Ie.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError(Ie.Code.Unknown, "Response closed without headers");
            var Xe = ze(this.responseHeaders), ot = this.responseHeaders.get("grpc-message");
            if (this.props.debug && $e.debug("grpc.headers only response ", Xe, ot), Xe === null)
              return void this.rawOnEnd(Ie.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var pt = this.decodeGRPCStatus(ot[0]);
            this.rawOnEnd(Xe, pt, this.responseHeaders);
          }
        }, He.prototype.decodeGRPCStatus = function(Ze) {
          if (!Ze)
            return "";
          try {
            return decodeURIComponent(Ze);
          } catch {
            return Ze;
          }
        }, He.prototype.rawOnEnd = function(Ze, qe, tt) {
          var Xe = this;
          this.props.debug && $e.debug("rawOnEnd", Ze, qe, tt), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ot) {
            if (!Xe.closed)
              try {
                ot(Ze, qe, tt);
              } catch (pt) {
                setTimeout(function() {
                  throw pt;
                }, 0);
              }
          }));
        }, He.prototype.rawOnHeaders = function(Ze) {
          this.props.debug && $e.debug("rawOnHeaders", Ze), this.completed || this.onHeadersCallbacks.forEach(function(qe) {
            try {
              qe(Ze);
            } catch (tt) {
              setTimeout(function() {
                throw tt;
              }, 0);
            }
          });
        }, He.prototype.rawOnError = function(Ze, qe, tt) {
          var Xe = this;
          tt === void 0 && (tt = new _e.Metadata()), this.props.debug && $e.debug("rawOnError", Ze, qe), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ot) {
            if (!Xe.closed)
              try {
                ot(Ze, qe, tt);
              } catch (pt) {
                setTimeout(function() {
                  throw pt;
                }, 0);
              }
          }));
        }, He.prototype.rawOnMessage = function(Ze) {
          var qe = this;
          this.props.debug && $e.debug("rawOnMessage", Ze.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(tt) {
            if (!qe.closed)
              try {
                tt(Ze);
              } catch (Xe) {
                setTimeout(function() {
                  throw Xe;
                }, 0);
              }
          });
        }, He.prototype.onHeaders = function(Ze) {
          this.onHeadersCallbacks.push(Ze);
        }, He.prototype.onMessage = function(Ze) {
          this.onMessageCallbacks.push(Ze);
        }, He.prototype.onEnd = function(Ze) {
          this.onEndCallbacks.push(Ze);
        }, He.prototype.start = function(Ze) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var qe = new _e.Metadata(Ze || {});
          qe.set("content-type", "application/grpc-web+proto"), qe.set("x-grpc-web", "1"), this.transport.start(qe);
        }, He.prototype.send = function(Ze) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var qe = Me.frameRequest(Ze);
          this.transport.sendMessage(qe);
        }, He.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, He.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && $e.debug("request.abort aborting request"), this.transport.cancel();
        }, He;
      }();
      function ze(He) {
        var Ze = He.get("grpc-status") || [];
        if (Ze.length > 0)
          try {
            var qe = Ze[0];
            return parseInt(qe, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(ye, ge) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.debug = void 0, ge.debug = function() {
        for (var we = [], _e = 0; _e < arguments.length; _e++)
          we[_e] = arguments[_e];
        console.debug ? console.debug.apply(null, we) : console.log.apply(null, we);
      };
    }, 607: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.grpc = void 0;
      var _e, Se = we(418), Ie = we(57), $e = we(229), Ne = we(540), Me = we(210), Be = we(859), ze = we(8), He = we(938), Ze = we(35), qe = we(934);
      (_e = ge.grpc || (ge.grpc = {})).setDefaultTransport = Ie.setDefaultTransportFactory, _e.CrossBrowserHttpTransport = Be.CrossBrowserHttpTransport, _e.FetchReadableStreamTransport = $e.FetchReadableStreamTransport, _e.XhrTransport = Me.XhrTransport, _e.WebsocketTransport = Ne.WebsocketTransport, _e.Code = ze.Code, _e.Metadata = Se.BrowserHeaders, _e.client = function(tt, Xe) {
        return qe.client(tt, Xe);
      }, _e.invoke = He.invoke, _e.unary = Ze.unary;
    }, 938: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.invoke = void 0;
      var _e = we(934);
      ge.invoke = function(Se, Ie) {
        if (Se.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var $e = _e.client(Se, { host: Ie.host, transport: Ie.transport, debug: Ie.debug });
        return Ie.onHeaders && $e.onHeaders(Ie.onHeaders), Ie.onMessage && $e.onMessage(Ie.onMessage), Ie.onEnd && $e.onEnd(Ie.onEnd), $e.start(Ie.metadata), $e.send(Ie.request), $e.finishSend(), { close: function() {
          $e.close();
        } };
      };
    }, 65: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.Metadata = void 0;
      var _e = we(418);
      Object.defineProperty(ge, "Metadata", { enumerable: !0, get: function() {
        return _e.BrowserHeaders;
      } });
    }, 57: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.makeDefaultTransport = ge.setDefaultTransportFactory = void 0;
      var _e = we(859), Se = function(Ie) {
        return _e.CrossBrowserHttpTransport({ withCredentials: !1 })(Ie);
      };
      ge.setDefaultTransportFactory = function(Ie) {
        Se = Ie;
      }, ge.makeDefaultTransport = function(Ie) {
        return Se(Ie);
      };
    }, 229: function(ye, ge, we) {
      var _e = this && this.__assign || function() {
        return (_e = Object.assign || function(Ne) {
          for (var Me, Be = 1, ze = arguments.length; Be < ze; Be++)
            for (var He in Me = arguments[Be])
              Object.prototype.hasOwnProperty.call(Me, He) && (Ne[He] = Me[He]);
          return Ne;
        }).apply(this, arguments);
      };
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.detectFetchSupport = ge.FetchReadableStreamTransport = void 0;
      var Se = we(65), Ie = we(346);
      ge.FetchReadableStreamTransport = function(Ne) {
        return function(Me) {
          return function(Be, ze) {
            return Be.debug && Ie.debug("fetchRequest", Be), new $e(Be, ze);
          }(Me, Ne);
        };
      };
      var $e = function() {
        function Ne(Me, Be) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = Me, this.init = Be;
        }
        return Ne.prototype.pump = function(Me, Be) {
          var ze = this;
          if (this.reader = Me, this.cancelled)
            return this.options.debug && Ie.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(He) {
              ze.options.debug && Ie.debug("Fetch.pump.reader.cancel exception", He);
            });
          this.reader.read().then(function(He) {
            if (He.done)
              return ze.options.onEnd(), Be;
            ze.options.onChunk(He.value), ze.pump(ze.reader, Be);
          }).catch(function(He) {
            ze.cancelled ? ze.options.debug && Ie.debug("Fetch.catch - request cancelled") : (ze.cancelled = !0, ze.options.debug && Ie.debug("Fetch.catch", He.message), ze.options.onEnd(He));
          });
        }, Ne.prototype.send = function(Me) {
          var Be = this;
          fetch(this.options.url, _e(_e({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: Me, signal: this.controller && this.controller.signal })).then(function(ze) {
            if (Be.options.debug && Ie.debug("Fetch.response", ze), Be.options.onHeaders(new Se.Metadata(ze.headers), ze.status), !ze.body)
              return ze;
            Be.pump(ze.body.getReader(), ze);
          }).catch(function(ze) {
            Be.cancelled ? Be.options.debug && Ie.debug("Fetch.catch - request cancelled") : (Be.cancelled = !0, Be.options.debug && Ie.debug("Fetch.catch", ze.message), Be.options.onEnd(ze));
          });
        }, Ne.prototype.sendMessage = function(Me) {
          this.send(Me);
        }, Ne.prototype.finishSend = function() {
        }, Ne.prototype.start = function(Me) {
          this.metadata = Me;
        }, Ne.prototype.cancel = function() {
          var Me = this;
          this.cancelled ? this.options.debug && Ie.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && Ie.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && Ie.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && Ie.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(Be) {
            Me.options.debug && Ie.debug("Fetch.cancel.reader.cancel exception", Be);
          })) : this.options.debug && Ie.debug("Fetch.cancel before reader"));
        }, Ne;
      }();
      ge.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.CrossBrowserHttpTransport = void 0;
      var _e = we(229), Se = we(210);
      ge.CrossBrowserHttpTransport = function(Ie) {
        if (_e.detectFetchSupport()) {
          var $e = { credentials: Ie.withCredentials ? "include" : "same-origin" };
          return _e.FetchReadableStreamTransport($e);
        }
        return Se.XhrTransport({ withCredentials: Ie.withCredentials });
      };
    }, 210: function(ye, ge, we) {
      var _e, Se = this && this.__extends || (_e = function(Ze, qe) {
        return (_e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(tt, Xe) {
          tt.__proto__ = Xe;
        } || function(tt, Xe) {
          for (var ot in Xe)
            Object.prototype.hasOwnProperty.call(Xe, ot) && (tt[ot] = Xe[ot]);
        })(Ze, qe);
      }, function(Ze, qe) {
        function tt() {
          this.constructor = Ze;
        }
        _e(Ze, qe), Ze.prototype = qe === null ? Object.create(qe) : (tt.prototype = qe.prototype, new tt());
      });
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.stringToArrayBuffer = ge.MozChunkedArrayBufferXHR = ge.XHR = ge.XhrTransport = void 0;
      var Ie = we(65), $e = we(346), Ne = we(849);
      ge.XhrTransport = function(Ze) {
        return function(qe) {
          if (Ne.detectMozXHRSupport())
            return new Be(qe, Ze);
          if (Ne.detectXHROverrideMimeTypeSupport())
            return new Me(qe, Ze);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var Me = function() {
        function Ze(qe, tt) {
          this.options = qe, this.init = tt;
        }
        return Ze.prototype.onProgressEvent = function() {
          this.options.debug && $e.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var qe = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var tt = He(qe);
          this.options.onChunk(tt);
        }, Ze.prototype.onLoadEvent = function() {
          this.options.debug && $e.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, Ze.prototype.onStateChange = function() {
          this.options.debug && $e.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new Ie.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, Ze.prototype.sendMessage = function(qe) {
          this.xhr.send(qe);
        }, Ze.prototype.finishSend = function() {
        }, Ze.prototype.start = function(qe) {
          var tt = this;
          this.metadata = qe;
          var Xe = new XMLHttpRequest();
          this.xhr = Xe, Xe.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(ot, pt) {
            Xe.setRequestHeader(ot, pt.join(", "));
          }), Xe.withCredentials = !!this.init.withCredentials, Xe.addEventListener("readystatechange", this.onStateChange.bind(this)), Xe.addEventListener("progress", this.onProgressEvent.bind(this)), Xe.addEventListener("loadend", this.onLoadEvent.bind(this)), Xe.addEventListener("error", function(ot) {
            tt.options.debug && $e.debug("XHR.error", ot), tt.options.onEnd(ot.error);
          });
        }, Ze.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, Ze.prototype.cancel = function() {
          this.options.debug && $e.debug("XHR.abort"), this.xhr.abort();
        }, Ze;
      }();
      ge.XHR = Me;
      var Be = function(Ze) {
        function qe() {
          return Ze !== null && Ze.apply(this, arguments) || this;
        }
        return Se(qe, Ze), qe.prototype.configureXhr = function() {
          this.options.debug && $e.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, qe.prototype.onProgressEvent = function() {
          var tt = this.xhr.response;
          this.options.debug && $e.debug("MozXHR.onProgressEvent: ", new Uint8Array(tt)), this.options.onChunk(new Uint8Array(tt));
        }, qe;
      }(Me);
      function ze(Ze, qe) {
        var tt = Ze.charCodeAt(qe);
        if (tt >= 55296 && tt <= 56319) {
          var Xe = Ze.charCodeAt(qe + 1);
          Xe >= 56320 && Xe <= 57343 && (tt = 65536 + (tt - 55296 << 10) + (Xe - 56320));
        }
        return tt;
      }
      function He(Ze) {
        for (var qe = new Uint8Array(Ze.length), tt = 0, Xe = 0; Xe < Ze.length; Xe++) {
          var ot = String.prototype.codePointAt ? Ze.codePointAt(Xe) : ze(Ze, Xe);
          qe[tt++] = 255 & ot;
        }
        return qe;
      }
      ge.MozChunkedArrayBufferXHR = Be, ge.stringToArrayBuffer = He;
    }, 849: function(ye, ge) {
      var we;
      function _e() {
        if (we !== void 0)
          return we;
        if (XMLHttpRequest) {
          we = new XMLHttpRequest();
          try {
            we.open("GET", "https://localhost");
          } catch {
          }
        }
        return we;
      }
      function Se(Ie) {
        var $e = _e();
        if (!$e)
          return !1;
        try {
          return $e.responseType = Ie, $e.responseType === Ie;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.detectXHROverrideMimeTypeSupport = ge.detectMozXHRSupport = ge.xhrSupportsResponseType = void 0, ge.xhrSupportsResponseType = Se, ge.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && Se("moz-chunked-arraybuffer");
      }, ge.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.WebsocketTransport = void 0;
      var _e, Se = we(346), Ie = we(617);
      (function(Ne) {
        Ne[Ne.FINISH_SEND = 1] = "FINISH_SEND";
      })(_e || (_e = {}));
      var $e = new Uint8Array([1]);
      ge.WebsocketTransport = function() {
        return function(Ne) {
          return function(Me) {
            Me.debug && Se.debug("websocketRequest", Me);
            var Be, ze = function(qe) {
              if (qe.substr(0, 8) === "https://")
                return "wss://" + qe.substr(8);
              if (qe.substr(0, 7) === "http://")
                return "ws://" + qe.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(Me.url), He = [];
            function Ze(qe) {
              if (qe === _e.FINISH_SEND)
                Be.send($e);
              else {
                var tt = qe, Xe = new Int8Array(tt.byteLength + 1);
                Xe.set(new Uint8Array([0])), Xe.set(tt, 1), Be.send(Xe);
              }
            }
            return { sendMessage: function(qe) {
              Be && Be.readyState !== Be.CONNECTING ? Ze(qe) : He.push(qe);
            }, finishSend: function() {
              Be && Be.readyState !== Be.CONNECTING ? Ze(_e.FINISH_SEND) : He.push(_e.FINISH_SEND);
            }, start: function(qe) {
              (Be = new WebSocket(ze, ["grpc-websockets"])).binaryType = "arraybuffer", Be.onopen = function() {
                var tt;
                Me.debug && Se.debug("websocketRequest.onopen"), Be.send((tt = "", qe.forEach(function(Xe, ot) {
                  tt += Xe + ": " + ot.join(", ") + `\r
`;
                }), Ie.encodeASCII(tt))), He.forEach(function(Xe) {
                  Ze(Xe);
                });
              }, Be.onclose = function(tt) {
                Me.debug && Se.debug("websocketRequest.onclose", tt), Me.onEnd();
              }, Be.onerror = function(tt) {
                Me.debug && Se.debug("websocketRequest.onerror", tt);
              }, Be.onmessage = function(tt) {
                Me.onChunk(new Uint8Array(tt.data));
              };
            }, cancel: function() {
              Me.debug && Se.debug("websocket.abort"), Be.close();
            } };
          }(Ne);
        };
      };
    }, 35: function(ye, ge, we) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.unary = void 0;
      var _e = we(65), Se = we(934);
      ge.unary = function(Ie, $e) {
        if (Ie.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (Ie.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var Ne = null, Me = null, Be = Se.client(Ie, { host: $e.host, transport: $e.transport, debug: $e.debug });
        return Be.onHeaders(function(ze) {
          Ne = ze;
        }), Be.onMessage(function(ze) {
          Me = ze;
        }), Be.onEnd(function(ze, He, Ze) {
          $e.onEnd({ status: ze, statusMessage: He, headers: Ne || new _e.Metadata(), message: Me, trailers: Ze });
        }), Be.start($e.metadata), Be.send($e.request), Be.finishSend(), { close: function() {
          Be.close();
        } };
      };
    }, 882: function(ye, ge) {
      Object.defineProperty(ge, "__esModule", { value: !0 }), ge.frameRequest = void 0, ge.frameRequest = function(we) {
        var _e = we.serializeBinary(), Se = new ArrayBuffer(_e.byteLength + 5);
        return new DataView(Se, 1, 4).setUint32(0, _e.length, !1), new Uint8Array(Se, 5).set(_e), new Uint8Array(Se);
      };
    } }, fe = {}, function ye(ge) {
      if (fe[ge])
        return fe[ge].exports;
      var we = fe[ge] = { exports: {} };
      return ae[ge].call(we.exports, we, we.exports, ye), we.exports;
    }(607);
    var ae, fe;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
let AbortError$3 = class extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
};
function isAbortError(ne) {
  return typeof ne == "object" && ne !== null && ne.name === "AbortError";
}
function throwIfAborted(ne) {
  if (ne.aborted)
    throw new AbortError$3();
}
function rethrowAbortError(ne) {
  if (isAbortError(ne))
    throw ne;
}
function catchAbortError(ne) {
  if (!isAbortError(ne))
    throw ne;
}
function execute(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    let ye, ge = !1;
    function we() {
      ge || (ge = !0, ye != null && ye());
    }
    const _e = oe((Se) => {
      ae(Se), we();
    }, (Se) => {
      fe(Se), we();
    });
    if (!ge) {
      const Se = () => {
        const Ie = _e();
        Ie == null ? fe(new AbortError$3()) : Ie.then(() => {
          fe(new AbortError$3());
        }, ($e) => {
          fe($e);
        }), we();
      };
      ne.addEventListener("abort", Se), ye = () => {
        ne.removeEventListener("abort", Se);
      };
    }
  });
}
function abortable(ne, oe) {
  if (ne.aborted) {
    const ae = () => {
    };
    oe.then(ae, ae);
  }
  return execute(ne, (ae, fe) => (oe.then(ae, fe), () => {
  }));
}
function delay(ne, oe) {
  return execute(ne, (ae) => {
    const fe = typeof oe == "number" ? oe : oe.getTime() - Date.now(), ye = setTimeout(ae, fe);
    return () => {
      clearTimeout(ye);
    };
  });
}
function forever(ne) {
  return execute(ne, () => () => {
  });
}
function waitForEvent(ne, oe, ae, fe) {
  return execute(ne, (ye) => {
    let ge, we = !1;
    return ge = listen(oe, ae, (...Se) => {
      ye(Se.length > 1 ? Se : Se[0]), we = !0, ge != null && ge();
    }, fe), we && ge(), () => {
      we = !0, ge != null && ge();
    };
  });
}
function listen(ne, oe, ae, fe) {
  if (isEventTarget(ne))
    return ne.addEventListener(oe, ae, fe), () => ne.removeEventListener(oe, ae, fe);
  if (isJQueryStyleEventEmitter(ne))
    return ne.on(oe, ae), () => ne.off(oe, ae);
  if (isNodeStyleEventEmitter(ne))
    return ne.addListener(oe, ae), () => ne.removeListener(oe, ae);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(ne) {
  return isFunction$3(ne.addListener) && isFunction$3(ne.removeListener);
}
function isJQueryStyleEventEmitter(ne) {
  return isFunction$3(ne.on) && isFunction$3(ne.off);
}
function isEventTarget(ne) {
  return isFunction$3(ne.addEventListener) && isFunction$3(ne.removeEventListener);
}
const isFunction$3 = (ne) => typeof ne == "function";
function all(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), ge = oe(ye.signal);
    if (ge.length === 0) {
      ae([]);
      return;
    }
    const we = () => {
      ye.abort();
    };
    ne.addEventListener("abort", we);
    let _e;
    const Se = new Array(ge.length);
    let Ie = 0;
    function $e() {
      Ie += 1, Ie === ge.length && (ne.removeEventListener("abort", we), _e != null ? fe(_e.reason) : ae(Se));
    }
    for (const [Ne, Me] of ge.entries())
      Me.then((Be) => {
        Se[Ne] = Be, $e();
      }, (Be) => {
        ye.abort(), (_e == null || !isAbortError(Be) && isAbortError(_e.reason)) && (_e = { reason: Be }), $e();
      });
  });
}
function race(ne, oe) {
  return new Promise((ae, fe) => {
    if (ne.aborted) {
      fe(new AbortError$3());
      return;
    }
    const ye = new AbortController(), ge = oe(ye.signal), we = () => {
      ye.abort();
    };
    ne.addEventListener("abort", we);
    let _e = 0;
    function Se($e) {
      ye.abort(), _e += 1, _e === ge.length && (ne.removeEventListener("abort", we), $e.status === "fulfilled" ? ae($e.value) : fe($e.reason));
    }
    let Ie;
    for (const $e of ge)
      $e.then((Ne) => {
        Ie == null && (Ie = { status: "fulfilled", value: Ne }), Se(Ie);
      }, (Ne) => {
        (Ie == null || !isAbortError(Ne) && (Ie.status === "fulfilled" || isAbortError(Ie.reason))) && (Ie = { status: "rejected", reason: Ne }), Se(Ie);
      });
  });
}
async function retry$3(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, maxDelayMs: ye = 3e4, onError: ge, maxAttempts: we = 1 / 0 } = ae;
  let _e = 0;
  const Se = () => {
    _e = -1;
  };
  for (; ; )
    try {
      return await oe(ne, _e, Se);
    } catch (Ie) {
      if (rethrowAbortError(Ie), _e >= we)
        throw Ie;
      let $e;
      if (_e === -1)
        $e = 0;
      else {
        const Ne = Math.min(ye, Math.pow(2, _e) * fe);
        $e = Math.round(Ne * (1 + Math.random()) / 2);
      }
      ge && ge(Ie, _e, $e), $e !== 0 && await delay(ne, $e), _e += 1;
    }
}
function spawn(ne, oe) {
  if (ne.aborted)
    return Promise.reject(new AbortError$3());
  const ae = [], fe = new AbortController(), ye = fe.signal, ge = () => {
    fe.abort();
  };
  ne.addEventListener("abort", ge);
  const we = () => {
    ne.removeEventListener("abort", ge);
  }, _e = /* @__PURE__ */ new Set(), Se = () => {
    for (const Ne of _e)
      Ne.abort();
  };
  ye.addEventListener("abort", Se);
  const Ie = () => {
    ye.removeEventListener("abort", Se);
  };
  let $e = new Promise((Ne, Me) => {
    let Be, ze;
    He((Ze) => oe(Ze, {
      defer(qe) {
        ae.push(qe);
      },
      fork: He
    })).join().then((Ze) => {
      fe.abort(), Be = { value: Ze };
    }, (Ze) => {
      fe.abort(), (!isAbortError(Ze) || ze == null) && (ze = { error: Ze });
    });
    function He(Ze) {
      if (ye.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError$3();
          }
        };
      const qe = new AbortController(), tt = qe.signal, Xe = Ze(tt), ot = {
        abort() {
          qe.abort();
        },
        join: () => Xe
      };
      return _e.add(ot), Xe.catch(catchAbortError).catch((pt) => {
        ze = { error: pt }, fe.abort();
      }).finally(() => {
        _e.delete(ot), _e.size === 0 && (ze != null ? Me(ze.error) : Ne(Be.value));
      }), ot;
    }
  });
  return $e = $e.finally(() => {
    we(), Ie();
    let Ne = Promise.resolve();
    for (let Me = ae.length - 1; Me >= 0; Me--)
      Ne = Ne.finally(ae[Me]);
    return Ne;
  }), $e;
}
function run$1(ne) {
  const oe = new AbortController(), ae = ne(oe.signal).catch(catchAbortError);
  return () => (oe.abort(), ae);
}
function proactiveRetry(ne, oe, ae = {}) {
  const { baseMs: fe = 1e3, onError: ye, maxAttempts: ge = 1 / 0 } = ae;
  return execute(ne, (we, _e) => {
    const Se = new AbortController();
    let Ie = !1;
    const $e = /* @__PURE__ */ new Map();
    function Ne(ze) {
      Se.abort(), $e.clear(), we(ze);
    }
    function Me(ze, He) {
      if ($e.delete(He), Ie && $e.size === 0) {
        _e(ze);
        return;
      }
      if (!isAbortError(ze) && ye)
        try {
          ye(ze, He);
        } catch (Ze) {
          Se.abort(), $e.clear(), _e(Ze);
        }
    }
    async function Be(ze) {
      for (let He = 0; ; He++) {
        const Ze = oe(ze, He);
        if ($e.set(He, Ze), Ze.then(Ne, (Xe) => Me(Xe, He)), He + 1 >= ge)
          break;
        const qe = Math.pow(2, He) * fe, tt = Math.round(qe * (1 + Math.random()) / 2);
        await delay(ze, tt);
      }
      Ie = !0;
    }
    return Be(Se.signal).catch(catchAbortError), () => {
      Se.abort();
    };
  });
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError: AbortError$3,
  abortable,
  all,
  catchAbortError,
  delay,
  execute,
  forever,
  isAbortError,
  proactiveRetry,
  race,
  rethrowAbortError,
  retry: retry$3,
  run: run$1,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(oe) {
    this._push({ type: ARRAY_VALUE, value: oe });
  }
  error(oe) {
    this._push({ type: ARRAY_ERROR, error: oe });
  }
  _push(oe) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: ae, reject: fe } = this._resolvers.shift();
      oe.type === ARRAY_ERROR ? fe(oe.error) : ae({ done: !1, value: oe.value });
    } else
      this._values.push(oe);
  }
  next() {
    if (this._values.length > 0) {
      const { type: oe, value: ae, error: fe } = this._values.shift();
      return oe === ARRAY_ERROR ? Promise.reject(fe) : Promise.resolve({ done: !1, value: ae });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((oe, ae) => {
      this._resolvers.push({ resolve: oe, reject: ae });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$2 = {};
Object.defineProperty(isAsyncIterable$2, "__esModule", { value: !0 });
isAsyncIterable$2.isAsyncIterable = void 0;
function isAsyncIterable$1(ne) {
  return ne != null && Symbol.asyncIterator in ne;
}
isAsyncIterable$2.isAsyncIterable = isAsyncIterable$1;
var convertMetadata = {}, base64 = { exports: {} };
(function(ne, oe) {
  (function(ae, fe) {
    ne.exports = fe();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal, function() {
    var ae = "3.7.7", fe = ae, ye = typeof Buffer == "function", ge = typeof TextDecoder == "function" ? new TextDecoder() : void 0, we = typeof TextEncoder == "function" ? new TextEncoder() : void 0, _e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Se = Array.prototype.slice.call(_e), Ie = function(Ht) {
      var _n = {};
      return Ht.forEach(function(Vn, br) {
        return _n[Vn] = br;
      }), _n;
    }(Se), $e = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, Ne = String.fromCharCode.bind(String), Me = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(Ht) {
      return new Uint8Array(Array.prototype.slice.call(Ht, 0));
    }, Be = function(Ht) {
      return Ht.replace(/=/g, "").replace(/[+\/]/g, function(_n) {
        return _n == "+" ? "-" : "_";
      });
    }, ze = function(Ht) {
      return Ht.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, He = function(Ht) {
      for (var _n, Vn, br, nr, Er = "", Qo = Ht.length % 3, Yr = 0; Yr < Ht.length; ) {
        if ((Vn = Ht.charCodeAt(Yr++)) > 255 || (br = Ht.charCodeAt(Yr++)) > 255 || (nr = Ht.charCodeAt(Yr++)) > 255)
          throw new TypeError("invalid character found");
        _n = Vn << 16 | br << 8 | nr, Er += Se[_n >> 18 & 63] + Se[_n >> 12 & 63] + Se[_n >> 6 & 63] + Se[_n & 63];
      }
      return Qo ? Er.slice(0, Qo - 3) + "===".substring(Qo) : Er;
    }, Ze = typeof btoa == "function" ? function(Ht) {
      return btoa(Ht);
    } : ye ? function(Ht) {
      return Buffer.from(Ht, "binary").toString("base64");
    } : He, qe = ye ? function(Ht) {
      return Buffer.from(Ht).toString("base64");
    } : function(Ht) {
      for (var _n = 4096, Vn = [], br = 0, nr = Ht.length; br < nr; br += _n)
        Vn.push(Ne.apply(null, Ht.subarray(br, br + _n)));
      return Ze(Vn.join(""));
    }, tt = function(Ht, _n) {
      return _n === void 0 && (_n = !1), _n ? Be(qe(Ht)) : qe(Ht);
    }, Xe = function(Ht) {
      if (Ht.length < 2) {
        var _n = Ht.charCodeAt(0);
        return _n < 128 ? Ht : _n < 2048 ? Ne(192 | _n >>> 6) + Ne(128 | _n & 63) : Ne(224 | _n >>> 12 & 15) + Ne(128 | _n >>> 6 & 63) + Ne(128 | _n & 63);
      } else {
        var _n = 65536 + (Ht.charCodeAt(0) - 55296) * 1024 + (Ht.charCodeAt(1) - 56320);
        return Ne(240 | _n >>> 18 & 7) + Ne(128 | _n >>> 12 & 63) + Ne(128 | _n >>> 6 & 63) + Ne(128 | _n & 63);
      }
    }, ot = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, pt = function(Ht) {
      return Ht.replace(ot, Xe);
    }, ht = ye ? function(Ht) {
      return Buffer.from(Ht, "utf8").toString("base64");
    } : we ? function(Ht) {
      return qe(we.encode(Ht));
    } : function(Ht) {
      return Ze(pt(Ht));
    }, wt = function(Ht, _n) {
      return _n === void 0 && (_n = !1), _n ? Be(ht(Ht)) : ht(Ht);
    }, gt = function(Ht) {
      return wt(Ht, !0);
    }, It = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, Nt = function(Ht) {
      switch (Ht.length) {
        case 4:
          var _n = (7 & Ht.charCodeAt(0)) << 18 | (63 & Ht.charCodeAt(1)) << 12 | (63 & Ht.charCodeAt(2)) << 6 | 63 & Ht.charCodeAt(3), Vn = _n - 65536;
          return Ne((Vn >>> 10) + 55296) + Ne((Vn & 1023) + 56320);
        case 3:
          return Ne((15 & Ht.charCodeAt(0)) << 12 | (63 & Ht.charCodeAt(1)) << 6 | 63 & Ht.charCodeAt(2));
        default:
          return Ne((31 & Ht.charCodeAt(0)) << 6 | 63 & Ht.charCodeAt(1));
      }
    }, Ft = function(Ht) {
      return Ht.replace(It, Nt);
    }, on = function(Ht) {
      if (Ht = Ht.replace(/\s+/g, ""), !$e.test(Ht))
        throw new TypeError("malformed base64.");
      Ht += "==".slice(2 - (Ht.length & 3));
      for (var _n, Vn = "", br, nr, Er = 0; Er < Ht.length; )
        _n = Ie[Ht.charAt(Er++)] << 18 | Ie[Ht.charAt(Er++)] << 12 | (br = Ie[Ht.charAt(Er++)]) << 6 | (nr = Ie[Ht.charAt(Er++)]), Vn += br === 64 ? Ne(_n >> 16 & 255) : nr === 64 ? Ne(_n >> 16 & 255, _n >> 8 & 255) : Ne(_n >> 16 & 255, _n >> 8 & 255, _n & 255);
      return Vn;
    }, en = typeof atob == "function" ? function(Ht) {
      return atob(ze(Ht));
    } : ye ? function(Ht) {
      return Buffer.from(Ht, "base64").toString("binary");
    } : on, wn = ye ? function(Ht) {
      return Me(Buffer.from(Ht, "base64"));
    } : function(Ht) {
      return Me(en(Ht).split("").map(function(_n) {
        return _n.charCodeAt(0);
      }));
    }, Zt = function(Ht) {
      return wn(un(Ht));
    }, pn = ye ? function(Ht) {
      return Buffer.from(Ht, "base64").toString("utf8");
    } : ge ? function(Ht) {
      return ge.decode(wn(Ht));
    } : function(Ht) {
      return Ft(en(Ht));
    }, un = function(Ht) {
      return ze(Ht.replace(/[-_]/g, function(_n) {
        return _n == "-" ? "+" : "/";
      }));
    }, dn = function(Ht) {
      return pn(un(Ht));
    }, xn = function(Ht) {
      if (typeof Ht != "string")
        return !1;
      var _n = Ht.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(_n) || !/[^\s0-9a-zA-Z\-_]/.test(_n);
    }, Rn = function(Ht) {
      return {
        value: Ht,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, At = function() {
      var Ht = function(_n, Vn) {
        return Object.defineProperty(String.prototype, _n, Rn(Vn));
      };
      Ht("fromBase64", function() {
        return dn(this);
      }), Ht("toBase64", function(_n) {
        return wt(this, _n);
      }), Ht("toBase64URI", function() {
        return wt(this, !0);
      }), Ht("toBase64URL", function() {
        return wt(this, !0);
      }), Ht("toUint8Array", function() {
        return Zt(this);
      });
    }, hn = function() {
      var Ht = function(_n, Vn) {
        return Object.defineProperty(Uint8Array.prototype, _n, Rn(Vn));
      };
      Ht("toBase64", function(_n) {
        return tt(this, _n);
      }), Ht("toBase64URI", function() {
        return tt(this, !0);
      }), Ht("toBase64URL", function() {
        return tt(this, !0);
      });
    }, Yn = function() {
      At(), hn();
    }, Un = {
      version: ae,
      VERSION: fe,
      atob: en,
      atobPolyfill: on,
      btoa: Ze,
      btoaPolyfill: He,
      fromBase64: dn,
      toBase64: wt,
      encode: wt,
      encodeURI: gt,
      encodeURL: gt,
      utob: pt,
      btou: Ft,
      decode: dn,
      isValid: xn,
      fromUint8Array: tt,
      toUint8Array: Zt,
      extendString: At,
      extendUint8Array: hn,
      extendBuiltins: Yn
    };
    return Un.Base64 = {}, Object.keys(Un).forEach(function(Ht) {
      return Un.Base64[Ht] = Un[Ht];
    }), Un;
  });
})(base64);
var base64Exports = base64.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(ne) {
  const oe = new grpc_web_1$4.grpc.Metadata();
  for (const [ae, fe] of ne)
    for (const ye of fe)
      oe.append(ae, typeof ye == "string" ? ye : js_base64_1.Base64.fromUint8Array(ye));
  return oe;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(ne) {
  const oe = (0, nice_grpc_common_1$5.Metadata)();
  for (const [ae, fe] of Object.entries(ne.headersMap))
    if (ae.endsWith("-bin"))
      for (const ye of fe)
        for (const ge of ye.split(/,\s?/))
          oe.append(ae, js_base64_1.Base64.toUint8Array(ge));
    else
      oe.set(ae, fe);
  return oe;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$2, AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$2, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(ne), ge = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* we(Se, Ie) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(Se))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: $e = (0, nice_grpc_common_1$4.Metadata)(), signal: Ne = new AbortController().signal, onHeader: Me, onTrailer: Be } = Ie, ze = new AbortController(), He = new AsyncSink_1$1.AsyncSink(), Ze = grpc_web_1$3.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    Ze.onHeaders((Xe) => {
      Me == null || Me((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Xe));
    }), Ze.onMessage((Xe) => {
      He.write(Xe);
    }), Ze.onEnd((Xe, ot, pt) => {
      Be == null || Be((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(pt)), Xe === grpc_web_1$3.grpc.Code.OK ? He.end() : He.error(new nice_grpc_common_1$4.ClientError(ne.path, +Xe, ot));
    }), Ze.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)($e));
    let qe;
    pipeRequest$1(ze.signal, Se, Ze, ne).then(() => {
      Ze.finishSend();
    }, (Xe) => {
      (0, abort_controller_x_1$3.isAbortError)(Xe) || (qe = Xe, Ze.close(), He.end());
    });
    const tt = () => {
      He.error(new abort_controller_x_1$3.AbortError()), ze.abort(), Ze.close();
    };
    Ne.addEventListener("abort", tt);
    try {
      yield* He;
    } finally {
      if (ze.abort(), Ne.removeEventListener("abort", tt), (0, abort_controller_x_1$3.throwIfAborted)(Ne), qe)
        throw qe;
    }
  }
  const _e = ae == null ? we : (Se, Ie) => ae({
    method: ge,
    requestStream: !0,
    request: Se,
    responseStream: !0,
    next: we
  }, Ie);
  return (Se, Ie) => {
    const Ne = _e(Se, {
      ...fe,
      ...Ie
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const Me = await Ne.next();
            return Me.done && Me.value != null ? await Ne.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : Me;
          },
          return() {
            return Ne.return();
          },
          throw(Me) {
            return Ne.throw(Me);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$3.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createClientStreamingMethod$1 = {};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$2, service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$2, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(ne), ge = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* we(Se, Ie) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(Se))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: $e = (0, nice_grpc_common_1$3.Metadata)(), signal: Ne = new AbortController().signal, onHeader: Me, onTrailer: Be } = Ie;
    return await (0, abort_controller_x_1$2.execute)(Ne, (ze, He) => {
      const Ze = new AbortController();
      let qe;
      const tt = grpc_web_1$2.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return tt.onHeaders((Xe) => {
        Me == null || Me((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Xe));
      }), tt.onMessage((Xe) => {
        qe = Xe;
      }), tt.onEnd((Xe, ot, pt) => {
        Be == null || Be((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(pt)), Ze.abort(), Xe === grpc_web_1$2.grpc.Code.OK ? ze(qe) : He(new nice_grpc_common_1$3.ClientError(ne.path, +Xe, ot));
      }), tt.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)($e)), pipeRequest(Ze.signal, Se, tt, ne).then(() => {
        tt.finishSend();
      }, (Xe) => {
        (0, abort_controller_x_1$2.isAbortError)(Xe) || (He(Xe), tt.close());
      }), () => {
        Ze.abort(), tt.close();
      };
    });
  }
  const _e = ae == null ? we : (Se, Ie) => ae({
    method: ge,
    requestStream: !0,
    request: Se,
    responseStream: !1,
    next: we
  }, Ie);
  return async (Se, Ie) => {
    const Ne = _e(Se, {
      ...fe,
      ...Ie
    })[Symbol.asyncIterator]();
    let Me = await Ne.next();
    for (; ; ) {
      if (!Me.done) {
        Me = await Ne.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (Me.value == null) {
        Me = await Ne.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return Me.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(ne, oe, ae, fe) {
  for await (const ye of oe)
    (0, abort_controller_x_1$2.throwIfAborted)(ne), ae.send({
      serializeBinary: () => fe.requestSerialize(ye)
    });
}
var createServerStreamingMethod$1 = {};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$2, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$2;
function createServerStreamingMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(ne), ge = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* we(Se, Ie) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(Se))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: $e = (0, nice_grpc_common_1$2.Metadata)(), signal: Ne = new AbortController().signal, onHeader: Me, onTrailer: Be } = Ie, ze = new AsyncSink_1.AsyncSink(), He = grpc_web_1$1.grpc.client(ye, {
      host: oe.address,
      transport: oe.transport
    });
    He.onHeaders((qe) => {
      Me == null || Me((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(qe));
    }), He.onMessage((qe) => {
      ze.write(qe);
    }), He.onEnd((qe, tt, Xe) => {
      Be == null || Be((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(Xe)), qe === grpc_web_1$1.grpc.Code.OK ? ze.end() : ze.error(new nice_grpc_common_1$2.ClientError(ne.path, +qe, tt));
    }), He.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)($e)), He.send({
      serializeBinary: () => ne.requestSerialize(Se)
    }), He.finishSend();
    const Ze = () => {
      ze.error(new abort_controller_x_1$1.AbortError()), He.close();
    };
    Ne.addEventListener("abort", Ze);
    try {
      yield* ze;
    } finally {
      Ne.removeEventListener("abort", Ze), (0, abort_controller_x_1$1.throwIfAborted)(Ne);
    }
  }
  const _e = ae == null ? we : (Se, Ie) => ae({
    method: ge,
    requestStream: !1,
    request: Se,
    responseStream: !0,
    next: we
  }, Ie);
  return (Se, Ie) => {
    const Ne = _e(Se, {
      ...fe,
      ...Ie
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const Me = await Ne.next();
            return Me.done && Me.value != null ? await Ne.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : Me;
          },
          return() {
            return Ne.return();
          },
          throw(Me) {
            return Ne.throw(Me);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1 = require$$2, service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$2, convertMetadata_1 = convertMetadata;
function createUnaryMethod(ne, oe, ae, fe) {
  const ye = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(ne), ge = {
    path: ne.path,
    requestStream: ne.requestStream,
    responseStream: ne.responseStream,
    options: ne.options
  };
  async function* we(Se, Ie) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(Se))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: $e = (0, nice_grpc_common_1$1.Metadata)(), signal: Ne = new AbortController().signal, onHeader: Me, onTrailer: Be } = Ie;
    return await (0, abort_controller_x_1.execute)(Ne, (ze, He) => {
      let Ze;
      const qe = grpc_web_1.grpc.client(ye, {
        host: oe.address,
        transport: oe.transport
      });
      return qe.onHeaders((tt) => {
        Me == null || Me((0, convertMetadata_1.convertMetadataFromGrpcWeb)(tt));
      }), qe.onMessage((tt) => {
        Ze = tt;
      }), qe.onEnd((tt, Xe, ot) => {
        Be == null || Be((0, convertMetadata_1.convertMetadataFromGrpcWeb)(ot)), tt === grpc_web_1.grpc.Code.OK ? ze(Ze) : He(new nice_grpc_common_1$1.ClientError(ne.path, +tt, Xe));
      }), qe.start((0, convertMetadata_1.convertMetadataToGrpcWeb)($e)), qe.send({
        serializeBinary: () => ne.requestSerialize(Se)
      }), qe.finishSend(), () => {
        qe.close();
      };
    });
  }
  const _e = ae == null ? we : (Se, Ie) => ae({
    method: ge,
    requestStream: !1,
    request: Se,
    responseStream: !1,
    next: we
  }, Ie);
  return async (Se, Ie) => {
    const Ne = _e(Se, {
      ...fe,
      ...Ie
    })[Symbol.asyncIterator]();
    let Me = await Ne.next();
    for (; ; ) {
      if (!Me.done) {
        Me = await Ne.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (Me.value == null) {
        Me = await Ne.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return Me.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(ne, oe, ae) {
  return createClientFactory().create(ne, oe, ae);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(ne) {
  return {
    use(oe) {
      return createClientFactoryWithMiddleware(ne == null ? oe : (0, nice_grpc_common_1.composeClientMiddleware)(ne, oe));
    },
    create(oe, ae, fe = {}) {
      const ye = {}, ge = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(oe));
      for (const [we, _e] of ge) {
        const Se = {
          ...fe["*"],
          ...fe[we]
        };
        _e.requestStream ? _e.responseStream ? ye[we] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(_e, ae, ne, Se) : ye[we] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(_e, ae, ne, Se) : _e.responseStream ? ye[we] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(_e, ae, ne, Se) : ye[we] = (0, createUnaryMethod_1.createUnaryMethod)(_e, ae, ne, Se);
      }
      return ye;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(ne) {
  var oe = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ye, ge, we, _e) {
    _e === void 0 && (_e = we);
    var Se = Object.getOwnPropertyDescriptor(ge, we);
    (!Se || ("get" in Se ? !ge.__esModule : Se.writable || Se.configurable)) && (Se = { enumerable: !0, get: function() {
      return ge[we];
    } }), Object.defineProperty(ye, _e, Se);
  } : function(ye, ge, we, _e) {
    _e === void 0 && (_e = we), ye[_e] = ge[we];
  }), ae = commonjsGlobal && commonjsGlobal.__exportStar || function(ye, ge) {
    for (var we in ye)
      we !== "default" && !Object.prototype.hasOwnProperty.call(ge, we) && oe(ge, ye, we);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Status = ne.Metadata = ne.composeClientMiddleware = ne.ClientError = void 0;
  var fe = lib;
  Object.defineProperty(ne, "ClientError", { enumerable: !0, get: function() {
    return fe.ClientError;
  } }), Object.defineProperty(ne, "composeClientMiddleware", { enumerable: !0, get: function() {
    return fe.composeClientMiddleware;
  } }), Object.defineProperty(ne, "Metadata", { enumerable: !0, get: function() {
    return fe.Metadata;
  } }), Object.defineProperty(ne, "Status", { enumerable: !0, get: function() {
    return fe.Status;
  } }), ae(serviceDefinitions, ne), ae(channel, ne), ae(ClientFactory, ne), ae(Client, ne);
})(lib$1);
function createBaseLinkedTwitterPair() {
  return { username: "", address: "" };
}
var LinkedTwitterPair = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterPair();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (ge != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterPair.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterPair();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripRequest() {
  return { username: "", address: "" };
}
var DripRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), ne.address !== "" && oe.uint32(18).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.username = ae.string();
          continue;
        case 2:
          if (ge != 18)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return DripRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripRequest();
    return oe.username = ne.username ?? "", oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripDevRequest() {
  return { address: "" };
}
var DripDevRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripDevRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return DripDevRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripDevRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseDripResponse() {
  return { dripTxHash: "", ecsTxHash: "" };
}
var DripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.dripTxHash !== "" && oe.uint32(10).string(ne.dripTxHash), ne.ecsTxHash !== "" && oe.uint32(18).string(ne.ecsTxHash), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseDripResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.dripTxHash = ae.string();
          continue;
        case 2:
          if (ge != 18)
            break;
          ye.ecsTxHash = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return DripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseDripResponse();
    return oe.dripTxHash = ne.dripTxHash ?? "", oe.ecsTxHash = ne.ecsTxHash ?? "", oe;
  }
};
function createBaseTimeUntilDripResponse() {
  return { timeUntilDripMinutes: 0, timeUntilDripSeconds: 0 };
}
var TimeUntilDripResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.timeUntilDripMinutes !== 0 && oe.uint32(9).double(ne.timeUntilDripMinutes), ne.timeUntilDripSeconds !== 0 && oe.uint32(17).double(ne.timeUntilDripSeconds), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseTimeUntilDripResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 9)
            break;
          ye.timeUntilDripMinutes = ae.double();
          continue;
        case 2:
          if (ge != 17)
            break;
          ye.timeUntilDripSeconds = ae.double();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return TimeUntilDripResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseTimeUntilDripResponse();
    return oe.timeUntilDripMinutes = ne.timeUntilDripMinutes ?? 0, oe.timeUntilDripSeconds = ne.timeUntilDripSeconds ?? 0, oe;
  }
};
function createBaseGetLinkedTwittersRequest() {
  return {};
}
var GetLinkedTwittersRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseGetLinkedTwittersRequest();
  }
};
function createBaseGetLinkedTwittersResponse() {
  return { linkedTwitters: [] };
}
var GetLinkedTwittersResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    for (const ae of ne.linkedTwitters)
      LinkedTwitterPair.encode(ae, oe.uint32(10).fork()).ldelim();
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseGetLinkedTwittersResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.linkedTwitters.push(LinkedTwitterPair.decode(ae, ae.uint32()));
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return GetLinkedTwittersResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    var ae;
    const oe = createBaseGetLinkedTwittersResponse();
    return oe.linkedTwitters = ((ae = ne.linkedTwitters) == null ? void 0 : ae.map((fe) => LinkedTwitterPair.fromPartial(fe))) || [], oe;
  }
};
function createBaseLinkedTwitterForAddressRequest() {
  return { address: "" };
}
var LinkedTwitterForAddressRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressRequest();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseLinkedTwitterForAddressResponse() {
  return { username: "" };
}
var LinkedTwitterForAddressResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedTwitterForAddressResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedTwitterForAddressResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedTwitterForAddressResponse();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterRequest() {
  return { username: "" };
}
var LinkedAddressForTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.username !== "" && oe.uint32(10).string(ne.username), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.username = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterRequest();
    return oe.username = ne.username ?? "", oe;
  }
};
function createBaseLinkedAddressForTwitterResponse() {
  return { address: "" };
}
var LinkedAddressForTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseLinkedAddressForTwitterResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.address = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return LinkedAddressForTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseLinkedAddressForTwitterResponse();
    return oe.address = ne.address ?? "", oe;
  }
};
function createBaseSetLinkedTwitterRequest() {
  return { address: "", username: "", signature: "" };
}
var SetLinkedTwitterRequest = {
  encode(ne, oe = _m0.Writer.create()) {
    return ne.address !== "" && oe.uint32(10).string(ne.address), ne.username !== "" && oe.uint32(18).string(ne.username), ne.signature !== "" && oe.uint32(26).string(ne.signature), oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterRequest();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      switch (ge >>> 3) {
        case 1:
          if (ge != 10)
            break;
          ye.address = ae.string();
          continue;
        case 2:
          if (ge != 18)
            break;
          ye.username = ae.string();
          continue;
        case 3:
          if (ge != 26)
            break;
          ye.signature = ae.string();
          continue;
      }
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterRequest.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    const oe = createBaseSetLinkedTwitterRequest();
    return oe.address = ne.address ?? "", oe.username = ne.username ?? "", oe.signature = ne.signature ?? "", oe;
  }
};
function createBaseSetLinkedTwitterResponse() {
  return {};
}
var SetLinkedTwitterResponse = {
  encode(ne, oe = _m0.Writer.create()) {
    return oe;
  },
  decode(ne, oe) {
    const ae = ne instanceof _m0.Reader ? ne : _m0.Reader.create(ne);
    let fe = oe === void 0 ? ae.len : ae.pos + oe;
    const ye = createBaseSetLinkedTwitterResponse();
    for (; ae.pos < fe; ) {
      const ge = ae.uint32();
      if ((ge & 7) == 4 || ge == 0)
        break;
      ae.skipType(ge & 7);
    }
    return ye;
  },
  create(ne) {
    return SetLinkedTwitterResponse.fromPartial(ne ?? {});
  },
  fromPartial(ne) {
    return createBaseSetLinkedTwitterResponse();
  }
}, FaucetServiceDefinition = {
  name: "FaucetService",
  fullName: "faucet.FaucetService",
  methods: {
    drip: {
      name: "Drip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripDev: {
      name: "DripDev",
      requestType: DripDevRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    dripVerifyTweet: {
      name: "DripVerifyTweet",
      requestType: DripRequest,
      requestStream: !1,
      responseType: DripResponse,
      responseStream: !1,
      options: {}
    },
    timeUntilDrip: {
      name: "TimeUntilDrip",
      requestType: DripRequest,
      requestStream: !1,
      responseType: TimeUntilDripResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitters: {
      name: "GetLinkedTwitters",
      requestType: GetLinkedTwittersRequest,
      requestStream: !1,
      responseType: GetLinkedTwittersResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedTwitterForAddress: {
      name: "GetLinkedTwitterForAddress",
      requestType: LinkedTwitterForAddressRequest,
      requestStream: !1,
      responseType: LinkedTwitterForAddressResponse,
      responseStream: !1,
      options: {}
    },
    getLinkedAddressForTwitter: {
      name: "GetLinkedAddressForTwitter",
      requestType: LinkedAddressForTwitterRequest,
      requestStream: !1,
      responseType: LinkedAddressForTwitterResponse,
      responseStream: !1,
      options: {}
    },
    /** Admin utility endpoints for modifying state. Requires a signature with faucet private key. */
    setLinkedTwitter: {
      name: "SetLinkedTwitter",
      requestType: SetLinkedTwitterRequest,
      requestStream: !1,
      responseType: SetLinkedTwitterResponse,
      responseStream: !1,
      options: {}
    }
  }
};
(() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && (_m0.util.Long = Long, _m0.configure());
function createFaucetService(ne) {
  return lib$1.createClient(FaucetServiceDefinition, lib$1.createChannel(ne));
}
var util;
(function(ne) {
  ne.assertEqual = (ye) => ye;
  function oe(ye) {
  }
  ne.assertIs = oe;
  function ae(ye) {
    throw new Error();
  }
  ne.assertNever = ae, ne.arrayToEnum = (ye) => {
    const ge = {};
    for (const we of ye)
      ge[we] = we;
    return ge;
  }, ne.getValidEnumValues = (ye) => {
    const ge = ne.objectKeys(ye).filter((_e) => typeof ye[ye[_e]] != "number"), we = {};
    for (const _e of ge)
      we[_e] = ye[_e];
    return ne.objectValues(we);
  }, ne.objectValues = (ye) => ne.objectKeys(ye).map(function(ge) {
    return ye[ge];
  }), ne.objectKeys = typeof Object.keys == "function" ? (ye) => Object.keys(ye) : (ye) => {
    const ge = [];
    for (const we in ye)
      Object.prototype.hasOwnProperty.call(ye, we) && ge.push(we);
    return ge;
  }, ne.find = (ye, ge) => {
    for (const we of ye)
      if (ge(we))
        return we;
  }, ne.isInteger = typeof Number.isInteger == "function" ? (ye) => Number.isInteger(ye) : (ye) => typeof ye == "number" && isFinite(ye) && Math.floor(ye) === ye;
  function fe(ye, ge = " | ") {
    return ye.map((we) => typeof we == "string" ? `'${we}'` : we).join(ge);
  }
  ne.joinValues = fe, ne.jsonStringifyReplacer = (ye, ge) => typeof ge == "bigint" ? ge.toString() : ge;
})(util || (util = {}));
var objectUtil;
(function(ne) {
  ne.mergeShapes = (oe, ae) => ({
    ...oe,
    ...ae
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (ne) => {
  switch (typeof ne) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(ne) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(ne) ? ZodParsedType.array : ne === null ? ZodParsedType.null : ne.then && typeof ne.then == "function" && ne.catch && typeof ne.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && ne instanceof Map ? ZodParsedType.map : typeof Set < "u" && ne instanceof Set ? ZodParsedType.set : typeof Date < "u" && ne instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson = (ne) => JSON.stringify(ne, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
  constructor(oe) {
    super(), this.issues = [], this.addIssue = (fe) => {
      this.issues = [...this.issues, fe];
    }, this.addIssues = (fe = []) => {
      this.issues = [...this.issues, ...fe];
    };
    const ae = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, ae) : this.__proto__ = ae, this.name = "ZodError", this.issues = oe;
  }
  get errors() {
    return this.issues;
  }
  format(oe) {
    const ae = oe || function(ge) {
      return ge.message;
    }, fe = { _errors: [] }, ye = (ge) => {
      for (const we of ge.issues)
        if (we.code === "invalid_union")
          we.unionErrors.map(ye);
        else if (we.code === "invalid_return_type")
          ye(we.returnTypeError);
        else if (we.code === "invalid_arguments")
          ye(we.argumentsError);
        else if (we.path.length === 0)
          fe._errors.push(ae(we));
        else {
          let _e = fe, Se = 0;
          for (; Se < we.path.length; ) {
            const Ie = we.path[Se];
            Se === we.path.length - 1 ? (_e[Ie] = _e[Ie] || { _errors: [] }, _e[Ie]._errors.push(ae(we))) : _e[Ie] = _e[Ie] || { _errors: [] }, _e = _e[Ie], Se++;
          }
        }
    };
    return ye(this), fe;
  }
  static assert(oe) {
    if (!(oe instanceof ZodError))
      throw new Error(`Not a ZodError: ${oe}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(oe = (ae) => ae.message) {
    const ae = {}, fe = [];
    for (const ye of this.issues)
      ye.path.length > 0 ? (ae[ye.path[0]] = ae[ye.path[0]] || [], ae[ye.path[0]].push(oe(ye))) : fe.push(oe(ye));
    return { formErrors: fe, fieldErrors: ae };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (ne) => new ZodError(ne);
const errorMap = (ne, oe) => {
  let ae;
  switch (ne.code) {
    case ZodIssueCode.invalid_type:
      ne.received === ZodParsedType.undefined ? ae = "Required" : ae = `Expected ${ne.expected}, received ${ne.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      ae = `Invalid literal value, expected ${JSON.stringify(ne.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      ae = `Unrecognized key(s) in object: ${util.joinValues(ne.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      ae = `Invalid discriminator value. Expected ${util.joinValues(ne.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      ae = `Invalid enum value. Expected ${util.joinValues(ne.options)}, received '${ne.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      ae = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      ae = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      ae = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof ne.validation == "object" ? "includes" in ne.validation ? (ae = `Invalid input: must include "${ne.validation.includes}"`, typeof ne.validation.position == "number" && (ae = `${ae} at one or more positions greater than or equal to ${ne.validation.position}`)) : "startsWith" in ne.validation ? ae = `Invalid input: must start with "${ne.validation.startsWith}"` : "endsWith" in ne.validation ? ae = `Invalid input: must end with "${ne.validation.endsWith}"` : util.assertNever(ne.validation) : ne.validation !== "regex" ? ae = `Invalid ${ne.validation}` : ae = "Invalid";
      break;
    case ZodIssueCode.too_small:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "more than"} ${ne.minimum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at least" : "over"} ${ne.minimum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${ne.minimum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly equal to " : ne.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(ne.minimum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      ne.type === "array" ? ae = `Array must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "less than"} ${ne.maximum} element(s)` : ne.type === "string" ? ae = `String must contain ${ne.exact ? "exactly" : ne.inclusive ? "at most" : "under"} ${ne.maximum} character(s)` : ne.type === "number" ? ae = `Number must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "bigint" ? ae = `BigInt must be ${ne.exact ? "exactly" : ne.inclusive ? "less than or equal to" : "less than"} ${ne.maximum}` : ne.type === "date" ? ae = `Date must be ${ne.exact ? "exactly" : ne.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(ne.maximum))}` : ae = "Invalid input";
      break;
    case ZodIssueCode.custom:
      ae = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      ae = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      ae = `Number must be a multiple of ${ne.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      ae = "Number must be finite";
      break;
    default:
      ae = oe.defaultError, util.assertNever(ne);
  }
  return { message: ae };
};
let overrideErrorMap = errorMap;
function setErrorMap(ne) {
  overrideErrorMap = ne;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (ne) => {
  const { data: oe, path: ae, errorMaps: fe, issueData: ye } = ne, ge = [...ae, ...ye.path || []], we = {
    ...ye,
    path: ge
  };
  if (ye.message !== void 0)
    return {
      ...ye,
      path: ge,
      message: ye.message
    };
  let _e = "";
  const Se = fe.filter((Ie) => !!Ie).slice().reverse();
  for (const Ie of Se)
    _e = Ie(we, { data: oe, defaultError: _e }).message;
  return {
    ...ye,
    path: ge,
    message: _e
  };
}, EMPTY_PATH = [];
function addIssueToContext(ne, oe) {
  const ae = getErrorMap(), fe = makeIssue({
    issueData: oe,
    data: ne.data,
    path: ne.path,
    errorMaps: [
      ne.common.contextualErrorMap,
      ne.schemaErrorMap,
      ae,
      ae === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((ye) => !!ye)
  });
  ne.common.issues.push(fe);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      if (ye.status === "aborted")
        return INVALID;
      ye.status === "dirty" && oe.dirty(), fe.push(ye.value);
    }
    return { status: oe.value, value: fe };
  }
  static async mergeObjectAsync(oe, ae) {
    const fe = [];
    for (const ye of ae) {
      const ge = await ye.key, we = await ye.value;
      fe.push({
        key: ge,
        value: we
      });
    }
    return ParseStatus.mergeObjectSync(oe, fe);
  }
  static mergeObjectSync(oe, ae) {
    const fe = {};
    for (const ye of ae) {
      const { key: ge, value: we } = ye;
      if (ge.status === "aborted" || we.status === "aborted")
        return INVALID;
      ge.status === "dirty" && oe.dirty(), we.status === "dirty" && oe.dirty(), ge.value !== "__proto__" && (typeof we.value < "u" || ye.alwaysSet) && (fe[ge.value] = we.value);
    }
    return { status: oe.value, value: fe };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (ne) => ({ status: "dirty", value: ne }), OK = (ne) => ({ status: "valid", value: ne }), isAborted = (ne) => ne.status === "aborted", isDirty = (ne) => ne.status === "dirty", isValid = (ne) => ne.status === "valid", isAsync = (ne) => typeof Promise < "u" && ne instanceof Promise;
function __classPrivateFieldGet$2(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}
function __classPrivateFieldSet$1(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}
typeof SuppressedError == "function" && SuppressedError;
var errorUtil;
(function(ne) {
  ne.errToObj = (oe) => typeof oe == "string" ? { message: oe } : oe || {}, ne.toString = (oe) => typeof oe == "string" ? oe : oe == null ? void 0 : oe.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(oe, ae, fe, ye) {
    this._cachedPath = [], this.parent = oe, this.data = ae, this._path = fe, this._key = ye;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const handleResult = (ne, oe) => {
  if (isValid(oe))
    return { success: !0, data: oe.value };
  if (!ne.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const ae = new ZodError(ne.common.issues);
      return this._error = ae, this._error;
    }
  };
};
function processCreateParams(ne) {
  if (!ne)
    return {};
  const { errorMap: oe, invalid_type_error: ae, required_error: fe, description: ye } = ne;
  if (oe && (ae || fe))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return oe ? { errorMap: oe, description: ye } : { errorMap: (we, _e) => {
    var Se, Ie;
    const { message: $e } = ne;
    return we.code === "invalid_enum_value" ? { message: $e ?? _e.defaultError } : typeof _e.data > "u" ? { message: (Se = $e ?? fe) !== null && Se !== void 0 ? Se : _e.defaultError } : we.code !== "invalid_type" ? { message: _e.defaultError } : { message: (Ie = $e ?? ae) !== null && Ie !== void 0 ? Ie : _e.defaultError };
  }, description: ye };
}
class ZodType {
  constructor(oe) {
    this.spa = this.safeParseAsync, this._def = oe, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(oe) {
    return getParsedType(oe.data);
  }
  _getOrReturnCtx(oe, ae) {
    return ae || {
      common: oe.parent.common,
      data: oe.data,
      parsedType: getParsedType(oe.data),
      schemaErrorMap: this._def.errorMap,
      path: oe.path,
      parent: oe.parent
    };
  }
  _processInputParams(oe) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: oe.parent.common,
        data: oe.data,
        parsedType: getParsedType(oe.data),
        schemaErrorMap: this._def.errorMap,
        path: oe.path,
        parent: oe.parent
      }
    };
  }
  _parseSync(oe) {
    const ae = this._parse(oe);
    if (isAsync(ae))
      throw new Error("Synchronous parse encountered promise.");
    return ae;
  }
  _parseAsync(oe) {
    const ae = this._parse(oe);
    return Promise.resolve(ae);
  }
  parse(oe, ae) {
    const fe = this.safeParse(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  safeParse(oe, ae) {
    var fe;
    const ye = {
      common: {
        issues: [],
        async: (fe = ae == null ? void 0 : ae.async) !== null && fe !== void 0 ? fe : !1,
        contextualErrorMap: ae == null ? void 0 : ae.errorMap
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, ge = this._parseSync({ data: oe, path: ye.path, parent: ye });
    return handleResult(ye, ge);
  }
  async parseAsync(oe, ae) {
    const fe = await this.safeParseAsync(oe, ae);
    if (fe.success)
      return fe.data;
    throw fe.error;
  }
  async safeParseAsync(oe, ae) {
    const fe = {
      common: {
        issues: [],
        contextualErrorMap: ae == null ? void 0 : ae.errorMap,
        async: !0
      },
      path: (ae == null ? void 0 : ae.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: oe,
      parsedType: getParsedType(oe)
    }, ye = this._parse({ data: oe, path: fe.path, parent: fe }), ge = await (isAsync(ye) ? ye : Promise.resolve(ye));
    return handleResult(fe, ge);
  }
  refine(oe, ae) {
    const fe = (ye) => typeof ae == "string" || typeof ae > "u" ? { message: ae } : typeof ae == "function" ? ae(ye) : ae;
    return this._refinement((ye, ge) => {
      const we = oe(ye), _e = () => ge.addIssue({
        code: ZodIssueCode.custom,
        ...fe(ye)
      });
      return typeof Promise < "u" && we instanceof Promise ? we.then((Se) => Se ? !0 : (_e(), !1)) : we ? !0 : (_e(), !1);
    });
  }
  refinement(oe, ae) {
    return this._refinement((fe, ye) => oe(fe) ? !0 : (ye.addIssue(typeof ae == "function" ? ae(fe, ye) : ae), !1));
  }
  _refinement(oe) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement: oe }
    });
  }
  superRefine(oe) {
    return this._refinement(oe);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(oe) {
    return ZodUnion.create([this, oe], this._def);
  }
  and(oe) {
    return ZodIntersection.create(this, oe, this._def);
  }
  transform(oe) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: oe }
    });
  }
  default(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(oe) {
    const ae = typeof oe == "function" ? oe : () => oe;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: ae,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(oe) {
    const ae = this.constructor;
    return new ae({
      ...this._def,
      description: oe
    });
  }
  pipe(oe) {
    return ZodPipeline.create(this, oe);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(ne) {
  let oe = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return ne.precision ? oe = `${oe}\\.\\d{${ne.precision}}` : ne.precision == null && (oe = `${oe}(\\.\\d+)?`), oe;
}
function timeRegex(ne) {
  return new RegExp(`^${timeRegexSource(ne)}$`);
}
function datetimeRegex(ne) {
  let oe = `${dateRegexSource}T${timeRegexSource(ne)}`;
  const ae = [];
  return ae.push(ne.local ? "Z?" : "Z"), ne.offset && ae.push("([+-]\\d{2}:?\\d{2})"), oe = `${oe}(${ae.join("|")})`, new RegExp(`^${oe}$`);
}
function isValidIP(ne, oe) {
  return !!((oe === "v4" || !oe) && ipv4Regex.test(ne) || (oe === "v6" || !oe) && ipv6Regex.test(ne));
}
class ZodString extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = String(oe.data)), this._getType(oe) !== ZodParsedType.string) {
      const ge = this._getOrReturnCtx(oe);
      return addIssueToContext(ge, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ge.parsedType
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const ge of this._def.checks)
      if (ge.kind === "min")
        oe.data.length < ge.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: ge.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "max")
        oe.data.length > ge.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: ge.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "length") {
        const we = oe.data.length > ge.value, _e = oe.data.length < ge.value;
        (we || _e) && (ye = this._getOrReturnCtx(oe, ye), we ? addIssueToContext(ye, {
          code: ZodIssueCode.too_big,
          maximum: ge.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: ge.message
        }) : _e && addIssueToContext(ye, {
          code: ZodIssueCode.too_small,
          minimum: ge.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: ge.message
        }), fe.dirty());
      } else if (ge.kind === "email")
        emailRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "uuid")
        uuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "nanoid")
        nanoidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "cuid")
        cuidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "cuid2")
        cuid2Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "ulid")
        ulidRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty());
      else if (ge.kind === "url")
        try {
          new URL(oe.data);
        } catch {
          ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: ge.message
          }), fe.dirty();
        }
      else
        ge.kind === "regex" ? (ge.regex.lastIndex = 0, ge.regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "regex",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty())) : ge.kind === "trim" ? oe.data = oe.data.trim() : ge.kind === "includes" ? oe.data.includes(ge.value, ge.position) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { includes: ge.value, position: ge.position },
          message: ge.message
        }), fe.dirty()) : ge.kind === "toLowerCase" ? oe.data = oe.data.toLowerCase() : ge.kind === "toUpperCase" ? oe.data = oe.data.toUpperCase() : ge.kind === "startsWith" ? oe.data.startsWith(ge.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { startsWith: ge.value },
          message: ge.message
        }), fe.dirty()) : ge.kind === "endsWith" ? oe.data.endsWith(ge.value) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: { endsWith: ge.value },
          message: ge.message
        }), fe.dirty()) : ge.kind === "datetime" ? datetimeRegex(ge).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "datetime",
          message: ge.message
        }), fe.dirty()) : ge.kind === "date" ? dateRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "date",
          message: ge.message
        }), fe.dirty()) : ge.kind === "time" ? timeRegex(ge).test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          code: ZodIssueCode.invalid_string,
          validation: "time",
          message: ge.message
        }), fe.dirty()) : ge.kind === "duration" ? durationRegex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "duration",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty()) : ge.kind === "ip" ? isValidIP(oe.data, ge.version) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "ip",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty()) : ge.kind === "base64" ? base64Regex.test(oe.data) || (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
          validation: "base64",
          code: ZodIssueCode.invalid_string,
          message: ge.message
        }), fe.dirty()) : util.assertNever(ge);
    return { status: fe.value, value: oe.data };
  }
  _regex(oe, ae, fe) {
    return this.refinement((ye) => oe.test(ye), {
      validation: ae,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(fe)
    });
  }
  _addCheck(oe) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  email(oe) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(oe) });
  }
  url(oe) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(oe) });
  }
  emoji(oe) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(oe) });
  }
  uuid(oe) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(oe) });
  }
  nanoid(oe) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(oe) });
  }
  cuid(oe) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(oe) });
  }
  cuid2(oe) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(oe) });
  }
  ulid(oe) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(oe) });
  }
  base64(oe) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(oe) });
  }
  ip(oe) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(oe) });
  }
  datetime(oe) {
    var ae, fe;
    return typeof oe == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: oe
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      offset: (ae = oe == null ? void 0 : oe.offset) !== null && ae !== void 0 ? ae : !1,
      local: (fe = oe == null ? void 0 : oe.local) !== null && fe !== void 0 ? fe : !1,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  date(oe) {
    return this._addCheck({ kind: "date", message: oe });
  }
  time(oe) {
    return typeof oe == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: oe
    }) : this._addCheck({
      kind: "time",
      precision: typeof (oe == null ? void 0 : oe.precision) > "u" ? null : oe == null ? void 0 : oe.precision,
      ...errorUtil.errToObj(oe == null ? void 0 : oe.message)
    });
  }
  duration(oe) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(oe) });
  }
  regex(oe, ae) {
    return this._addCheck({
      kind: "regex",
      regex: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  includes(oe, ae) {
    return this._addCheck({
      kind: "includes",
      value: oe,
      position: ae == null ? void 0 : ae.position,
      ...errorUtil.errToObj(ae == null ? void 0 : ae.message)
    });
  }
  startsWith(oe, ae) {
    return this._addCheck({
      kind: "startsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  endsWith(oe, ae) {
    return this._addCheck({
      kind: "endsWith",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  length(oe, ae) {
    return this._addCheck({
      kind: "length",
      value: oe,
      ...errorUtil.errToObj(ae)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(oe) {
    return this.min(1, errorUtil.errToObj(oe));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((oe) => oe.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((oe) => oe.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((oe) => oe.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((oe) => oe.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((oe) => oe.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((oe) => oe.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((oe) => oe.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((oe) => oe.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((oe) => oe.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((oe) => oe.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((oe) => oe.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((oe) => oe.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((oe) => oe.kind === "base64");
  }
  get minLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxLength() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodString.create = (ne) => {
  var oe;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
function floatSafeRemainder(ne, oe) {
  const ae = (ne.toString().split(".")[1] || "").length, fe = (oe.toString().split(".")[1] || "").length, ye = ae > fe ? ae : fe, ge = parseInt(ne.toFixed(ye).replace(".", "")), we = parseInt(oe.toFixed(ye).replace(".", ""));
  return ge % we / Math.pow(10, ye);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = Number(oe.data)), this._getType(oe) !== ZodParsedType.number) {
      const ge = this._getOrReturnCtx(oe);
      return addIssueToContext(ge, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ge.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const ge of this._def.checks)
      ge.kind === "int" ? util.isInteger(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: ge.message
      }), ye.dirty()) : ge.kind === "min" ? (ge.inclusive ? oe.data < ge.value : oe.data <= ge.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: ge.value,
        type: "number",
        inclusive: ge.inclusive,
        exact: !1,
        message: ge.message
      }), ye.dirty()) : ge.kind === "max" ? (ge.inclusive ? oe.data > ge.value : oe.data >= ge.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        maximum: ge.value,
        type: "number",
        inclusive: ge.inclusive,
        exact: !1,
        message: ge.message
      }), ye.dirty()) : ge.kind === "multipleOf" ? floatSafeRemainder(oe.data, ge.value) !== 0 && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: ge.value,
        message: ge.message
      }), ye.dirty()) : ge.kind === "finite" ? Number.isFinite(oe.data) || (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_finite,
        message: ge.message
      }), ye.dirty()) : util.assertNever(ge);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  int(oe) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(oe)
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  finite(oe) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(oe)
    });
  }
  safe(oe) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(oe)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
  get isInt() {
    return !!this._def.checks.find((oe) => oe.kind === "int" || oe.kind === "multipleOf" && util.isInteger(oe.value));
  }
  get isFinite() {
    let oe = null, ae = null;
    for (const fe of this._def.checks) {
      if (fe.kind === "finite" || fe.kind === "int" || fe.kind === "multipleOf")
        return !0;
      fe.kind === "min" ? (ae === null || fe.value > ae) && (ae = fe.value) : fe.kind === "max" && (oe === null || fe.value < oe) && (oe = fe.value);
    }
    return Number.isFinite(ae) && Number.isFinite(oe);
  }
}
ZodNumber.create = (ne) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(oe) {
    if (this._def.coerce && (oe.data = BigInt(oe.data)), this._getType(oe) !== ZodParsedType.bigint) {
      const ge = this._getOrReturnCtx(oe);
      return addIssueToContext(ge, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ge.parsedType
      }), INVALID;
    }
    let fe;
    const ye = new ParseStatus();
    for (const ge of this._def.checks)
      ge.kind === "min" ? (ge.inclusive ? oe.data < ge.value : oe.data <= ge.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: ge.value,
        inclusive: ge.inclusive,
        message: ge.message
      }), ye.dirty()) : ge.kind === "max" ? (ge.inclusive ? oe.data > ge.value : oe.data >= ge.value) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: ge.value,
        inclusive: ge.inclusive,
        message: ge.message
      }), ye.dirty()) : ge.kind === "multipleOf" ? oe.data % ge.value !== BigInt(0) && (fe = this._getOrReturnCtx(oe, fe), addIssueToContext(fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: ge.value,
        message: ge.message
      }), ye.dirty()) : util.assertNever(ge);
    return { status: ye.value, value: oe.data };
  }
  gte(oe, ae) {
    return this.setLimit("min", oe, !0, errorUtil.toString(ae));
  }
  gt(oe, ae) {
    return this.setLimit("min", oe, !1, errorUtil.toString(ae));
  }
  lte(oe, ae) {
    return this.setLimit("max", oe, !0, errorUtil.toString(ae));
  }
  lt(oe, ae) {
    return this.setLimit("max", oe, !1, errorUtil.toString(ae));
  }
  setLimit(oe, ae, fe, ye) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: oe,
          value: ae,
          inclusive: fe,
          message: errorUtil.toString(ye)
        }
      ]
    });
  }
  _addCheck(oe) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  positive(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  negative(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(oe)
    });
  }
  nonpositive(oe) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  nonnegative(oe) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(oe)
    });
  }
  multipleOf(oe, ae) {
    return this._addCheck({
      kind: "multipleOf",
      value: oe,
      message: errorUtil.toString(ae)
    });
  }
  get minValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe;
  }
  get maxValue() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe;
  }
}
ZodBigInt.create = (ne) => {
  var oe;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (oe = ne == null ? void 0 : ne.coerce) !== null && oe !== void 0 ? oe : !1,
    ...processCreateParams(ne)
  });
};
class ZodBoolean extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = !!oe.data), this._getType(oe) !== ZodParsedType.boolean) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodBoolean.create = (ne) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  ...processCreateParams(ne)
});
class ZodDate extends ZodType {
  _parse(oe) {
    if (this._def.coerce && (oe.data = new Date(oe.data)), this._getType(oe) !== ZodParsedType.date) {
      const ge = this._getOrReturnCtx(oe);
      return addIssueToContext(ge, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ge.parsedType
      }), INVALID;
    }
    if (isNaN(oe.data.getTime())) {
      const ge = this._getOrReturnCtx(oe);
      return addIssueToContext(ge, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    const fe = new ParseStatus();
    let ye;
    for (const ge of this._def.checks)
      ge.kind === "min" ? oe.data.getTime() < ge.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_small,
        message: ge.message,
        inclusive: !0,
        exact: !1,
        minimum: ge.value,
        type: "date"
      }), fe.dirty()) : ge.kind === "max" ? oe.data.getTime() > ge.value && (ye = this._getOrReturnCtx(oe, ye), addIssueToContext(ye, {
        code: ZodIssueCode.too_big,
        message: ge.message,
        inclusive: !0,
        exact: !1,
        maximum: ge.value,
        type: "date"
      }), fe.dirty()) : util.assertNever(ge);
    return {
      status: fe.value,
      value: new Date(oe.data.getTime())
    };
  }
  _addCheck(oe) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, oe]
    });
  }
  min(oe, ae) {
    return this._addCheck({
      kind: "min",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  max(oe, ae) {
    return this._addCheck({
      kind: "max",
      value: oe.getTime(),
      message: errorUtil.toString(ae)
    });
  }
  get minDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "min" && (oe === null || ae.value > oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
  get maxDate() {
    let oe = null;
    for (const ae of this._def.checks)
      ae.kind === "max" && (oe === null || ae.value < oe) && (oe = ae.value);
    return oe != null ? new Date(oe) : null;
  }
}
ZodDate.create = (ne) => new ZodDate({
  checks: [],
  coerce: (ne == null ? void 0 : ne.coerce) || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(ne)
});
class ZodSymbol extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.symbol) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodSymbol.create = (ne) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(ne)
});
class ZodUndefined extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodUndefined.create = (ne) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(ne)
});
class ZodNull extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.null) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodNull.create = (ne) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(ne)
});
class ZodAny extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodAny.create = (ne) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(ne)
});
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(oe) {
    return OK(oe.data);
  }
}
ZodUnknown.create = (ne) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(ne)
});
class ZodNever extends ZodType {
  _parse(oe) {
    const ae = this._getOrReturnCtx(oe);
    return addIssueToContext(ae, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ae.parsedType
    }), INVALID;
  }
}
ZodNever.create = (ne) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(ne)
});
class ZodVoid extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.undefined) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: fe.parsedType
      }), INVALID;
    }
    return OK(oe.data);
  }
}
ZodVoid.create = (ne) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(ne)
});
class ZodArray extends ZodType {
  _parse(oe) {
    const { ctx: ae, status: fe } = this._processInputParams(oe), ye = this._def;
    if (ae.parsedType !== ZodParsedType.array)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ae.parsedType
      }), INVALID;
    if (ye.exactLength !== null) {
      const we = ae.data.length > ye.exactLength.value, _e = ae.data.length < ye.exactLength.value;
      (we || _e) && (addIssueToContext(ae, {
        code: we ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: _e ? ye.exactLength.value : void 0,
        maximum: we ? ye.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: ye.exactLength.message
      }), fe.dirty());
    }
    if (ye.minLength !== null && ae.data.length < ye.minLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_small,
      minimum: ye.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.minLength.message
    }), fe.dirty()), ye.maxLength !== null && ae.data.length > ye.maxLength.value && (addIssueToContext(ae, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: ye.maxLength.message
    }), fe.dirty()), ae.common.async)
      return Promise.all([...ae.data].map((we, _e) => ye.type._parseAsync(new ParseInputLazyPath(ae, we, ae.path, _e)))).then((we) => ParseStatus.mergeArray(fe, we));
    const ge = [...ae.data].map((we, _e) => ye.type._parseSync(new ParseInputLazyPath(ae, we, ae.path, _e)));
    return ParseStatus.mergeArray(fe, ge);
  }
  get element() {
    return this._def.type;
  }
  min(oe, ae) {
    return new ZodArray({
      ...this._def,
      minLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  length(oe, ae) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodArray.create = (ne, oe) => new ZodArray({
  type: ne,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(oe)
});
function deepPartialify(ne) {
  if (ne instanceof ZodObject) {
    const oe = {};
    for (const ae in ne.shape) {
      const fe = ne.shape[ae];
      oe[ae] = ZodOptional.create(deepPartialify(fe));
    }
    return new ZodObject({
      ...ne._def,
      shape: () => oe
    });
  } else
    return ne instanceof ZodArray ? new ZodArray({
      ...ne._def,
      type: deepPartialify(ne.element)
    }) : ne instanceof ZodOptional ? ZodOptional.create(deepPartialify(ne.unwrap())) : ne instanceof ZodNullable ? ZodNullable.create(deepPartialify(ne.unwrap())) : ne instanceof ZodTuple ? ZodTuple.create(ne.items.map((oe) => deepPartialify(oe))) : ne;
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const oe = this._def.shape(), ae = util.objectKeys(oe);
    return this._cached = { shape: oe, keys: ae };
  }
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.object) {
      const Ie = this._getOrReturnCtx(oe);
      return addIssueToContext(Ie, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: Ie.parsedType
      }), INVALID;
    }
    const { status: fe, ctx: ye } = this._processInputParams(oe), { shape: ge, keys: we } = this._getCached(), _e = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (const Ie in ye.data)
        we.includes(Ie) || _e.push(Ie);
    const Se = [];
    for (const Ie of we) {
      const $e = ge[Ie], Ne = ye.data[Ie];
      Se.push({
        key: { status: "valid", value: Ie },
        value: $e._parse(new ParseInputLazyPath(ye, Ne, ye.path, Ie)),
        alwaysSet: Ie in ye.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const Ie = this._def.unknownKeys;
      if (Ie === "passthrough")
        for (const $e of _e)
          Se.push({
            key: { status: "valid", value: $e },
            value: { status: "valid", value: ye.data[$e] }
          });
      else if (Ie === "strict")
        _e.length > 0 && (addIssueToContext(ye, {
          code: ZodIssueCode.unrecognized_keys,
          keys: _e
        }), fe.dirty());
      else if (Ie !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const Ie = this._def.catchall;
      for (const $e of _e) {
        const Ne = ye.data[$e];
        Se.push({
          key: { status: "valid", value: $e },
          value: Ie._parse(
            new ParseInputLazyPath(ye, Ne, ye.path, $e)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: $e in ye.data
        });
      }
    }
    return ye.common.async ? Promise.resolve().then(async () => {
      const Ie = [];
      for (const $e of Se) {
        const Ne = await $e.key, Me = await $e.value;
        Ie.push({
          key: Ne,
          value: Me,
          alwaysSet: $e.alwaysSet
        });
      }
      return Ie;
    }).then((Ie) => ParseStatus.mergeObjectSync(fe, Ie)) : ParseStatus.mergeObjectSync(fe, Se);
  }
  get shape() {
    return this._def.shape();
  }
  strict(oe) {
    return errorUtil.errToObj, new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...oe !== void 0 ? {
        errorMap: (ae, fe) => {
          var ye, ge, we, _e;
          const Se = (we = (ge = (ye = this._def).errorMap) === null || ge === void 0 ? void 0 : ge.call(ye, ae, fe).message) !== null && we !== void 0 ? we : fe.defaultError;
          return ae.code === "unrecognized_keys" ? {
            message: (_e = errorUtil.errToObj(oe).message) !== null && _e !== void 0 ? _e : Se
          } : {
            message: Se
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(oe) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...oe
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(oe) {
    return new ZodObject({
      unknownKeys: oe._def.unknownKeys,
      catchall: oe._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...oe._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(oe, ae) {
    return this.augment({ [oe]: ae });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(oe) {
    return new ZodObject({
      ...this._def,
      catchall: oe
    });
  }
  pick(oe) {
    const ae = {};
    return util.objectKeys(oe).forEach((fe) => {
      oe[fe] && this.shape[fe] && (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  omit(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      oe[fe] || (ae[fe] = this.shape[fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      const ye = this.shape[fe];
      oe && !oe[fe] ? ae[fe] = ye : ae[fe] = ye.optional();
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  required(oe) {
    const ae = {};
    return util.objectKeys(this.shape).forEach((fe) => {
      if (oe && !oe[fe])
        ae[fe] = this.shape[fe];
      else {
        let ge = this.shape[fe];
        for (; ge instanceof ZodOptional; )
          ge = ge._def.innerType;
        ae[fe] = ge;
      }
    }), new ZodObject({
      ...this._def,
      shape: () => ae
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.strictCreate = (ne, oe) => new ZodObject({
  shape: () => ne,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
ZodObject.lazycreate = (ne, oe) => new ZodObject({
  shape: ne,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(oe)
});
class ZodUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = this._def.options;
    function ye(ge) {
      for (const _e of ge)
        if (_e.result.status === "valid")
          return _e.result;
      for (const _e of ge)
        if (_e.result.status === "dirty")
          return ae.common.issues.push(..._e.ctx.common.issues), _e.result;
      const we = ge.map((_e) => new ZodError(_e.ctx.common.issues));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: we
      }), INVALID;
    }
    if (ae.common.async)
      return Promise.all(fe.map(async (ge) => {
        const we = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await ge._parseAsync({
            data: ae.data,
            path: ae.path,
            parent: we
          }),
          ctx: we
        };
      })).then(ye);
    {
      let ge;
      const we = [];
      for (const Se of fe) {
        const Ie = {
          ...ae,
          common: {
            ...ae.common,
            issues: []
          },
          parent: null
        }, $e = Se._parseSync({
          data: ae.data,
          path: ae.path,
          parent: Ie
        });
        if ($e.status === "valid")
          return $e;
        $e.status === "dirty" && !ge && (ge = { result: $e, ctx: Ie }), Ie.common.issues.length && we.push(Ie.common.issues);
      }
      if (ge)
        return ae.common.issues.push(...ge.ctx.common.issues), ge.result;
      const _e = we.map((Se) => new ZodError(Se));
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_union,
        unionErrors: _e
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (ne, oe) => new ZodUnion({
  options: ne,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(oe)
});
const getDiscriminator = (ne) => ne instanceof ZodLazy ? getDiscriminator(ne.schema) : ne instanceof ZodEffects ? getDiscriminator(ne.innerType()) : ne instanceof ZodLiteral ? [ne.value] : ne instanceof ZodEnum ? ne.options : ne instanceof ZodNativeEnum ? util.objectValues(ne.enum) : ne instanceof ZodDefault ? getDiscriminator(ne._def.innerType) : ne instanceof ZodUndefined ? [void 0] : ne instanceof ZodNull ? [null] : ne instanceof ZodOptional ? [void 0, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodNullable ? [null, ...getDiscriminator(ne.unwrap())] : ne instanceof ZodBranded || ne instanceof ZodReadonly ? getDiscriminator(ne.unwrap()) : ne instanceof ZodCatch ? getDiscriminator(ne._def.innerType) : [];
class ZodDiscriminatedUnion extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.object)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ae.parsedType
      }), INVALID;
    const fe = this.discriminator, ye = ae.data[fe], ge = this.optionsMap.get(ye);
    return ge ? ae.common.async ? ge._parseAsync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : ge._parseSync({
      data: ae.data,
      path: ae.path,
      parent: ae
    }) : (addIssueToContext(ae, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [fe]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(oe, ae, fe) {
    const ye = /* @__PURE__ */ new Map();
    for (const ge of ae) {
      const we = getDiscriminator(ge.shape[oe]);
      if (!we.length)
        throw new Error(`A discriminator value for key \`${oe}\` could not be extracted from all schema options`);
      for (const _e of we) {
        if (ye.has(_e))
          throw new Error(`Discriminator property ${String(oe)} has duplicate value ${String(_e)}`);
        ye.set(_e, ge);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: oe,
      options: ae,
      optionsMap: ye,
      ...processCreateParams(fe)
    });
  }
}
function mergeValues(ne, oe) {
  const ae = getParsedType(ne), fe = getParsedType(oe);
  if (ne === oe)
    return { valid: !0, data: ne };
  if (ae === ZodParsedType.object && fe === ZodParsedType.object) {
    const ye = util.objectKeys(oe), ge = util.objectKeys(ne).filter((_e) => ye.indexOf(_e) !== -1), we = { ...ne, ...oe };
    for (const _e of ge) {
      const Se = mergeValues(ne[_e], oe[_e]);
      if (!Se.valid)
        return { valid: !1 };
      we[_e] = Se.data;
    }
    return { valid: !0, data: we };
  } else if (ae === ZodParsedType.array && fe === ZodParsedType.array) {
    if (ne.length !== oe.length)
      return { valid: !1 };
    const ye = [];
    for (let ge = 0; ge < ne.length; ge++) {
      const we = ne[ge], _e = oe[ge], Se = mergeValues(we, _e);
      if (!Se.valid)
        return { valid: !1 };
      ye.push(Se.data);
    }
    return { valid: !0, data: ye };
  } else
    return ae === ZodParsedType.date && fe === ZodParsedType.date && +ne == +oe ? { valid: !0, data: ne } : { valid: !1 };
}
class ZodIntersection extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = (ge, we) => {
      if (isAborted(ge) || isAborted(we))
        return INVALID;
      const _e = mergeValues(ge.value, we.value);
      return _e.valid ? ((isDirty(ge) || isDirty(we)) && ae.dirty(), { status: ae.value, value: _e.data }) : (addIssueToContext(fe, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return fe.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      }),
      this._def.right._parseAsync({
        data: fe.data,
        path: fe.path,
        parent: fe
      })
    ]).then(([ge, we]) => ye(ge, we)) : ye(this._def.left._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }), this._def.right._parseSync({
      data: fe.data,
      path: fe.path,
      parent: fe
    }));
  }
}
ZodIntersection.create = (ne, oe, ae) => new ZodIntersection({
  left: ne,
  right: oe,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(ae)
});
class ZodTuple extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.array)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: fe.parsedType
      }), INVALID;
    if (fe.data.length < this._def.items.length)
      return addIssueToContext(fe, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && fe.data.length > this._def.items.length && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), ae.dirty());
    const ge = [...fe.data].map((we, _e) => {
      const Se = this._def.items[_e] || this._def.rest;
      return Se ? Se._parse(new ParseInputLazyPath(fe, we, fe.path, _e)) : null;
    }).filter((we) => !!we);
    return fe.common.async ? Promise.all(ge).then((we) => ParseStatus.mergeArray(ae, we)) : ParseStatus.mergeArray(ae, ge);
  }
  get items() {
    return this._def.items;
  }
  rest(oe) {
    return new ZodTuple({
      ...this._def,
      rest: oe
    });
  }
}
ZodTuple.create = (ne, oe) => {
  if (!Array.isArray(ne))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: ne,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(oe)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.object)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: fe.parsedType
      }), INVALID;
    const ye = [], ge = this._def.keyType, we = this._def.valueType;
    for (const _e in fe.data)
      ye.push({
        key: ge._parse(new ParseInputLazyPath(fe, _e, fe.path, _e)),
        value: we._parse(new ParseInputLazyPath(fe, fe.data[_e], fe.path, _e)),
        alwaysSet: _e in fe.data
      });
    return fe.common.async ? ParseStatus.mergeObjectAsync(ae, ye) : ParseStatus.mergeObjectSync(ae, ye);
  }
  get element() {
    return this._def.valueType;
  }
  static create(oe, ae, fe) {
    return ae instanceof ZodType ? new ZodRecord({
      keyType: oe,
      valueType: ae,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(fe)
    }) : new ZodRecord({
      keyType: ZodString.create(),
      valueType: oe,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(ae)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.map)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def.keyType, ge = this._def.valueType, we = [...fe.data.entries()].map(([_e, Se], Ie) => ({
      key: ye._parse(new ParseInputLazyPath(fe, _e, fe.path, [Ie, "key"])),
      value: ge._parse(new ParseInputLazyPath(fe, Se, fe.path, [Ie, "value"]))
    }));
    if (fe.common.async) {
      const _e = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const Se of we) {
          const Ie = await Se.key, $e = await Se.value;
          if (Ie.status === "aborted" || $e.status === "aborted")
            return INVALID;
          (Ie.status === "dirty" || $e.status === "dirty") && ae.dirty(), _e.set(Ie.value, $e.value);
        }
        return { status: ae.value, value: _e };
      });
    } else {
      const _e = /* @__PURE__ */ new Map();
      for (const Se of we) {
        const Ie = Se.key, $e = Se.value;
        if (Ie.status === "aborted" || $e.status === "aborted")
          return INVALID;
        (Ie.status === "dirty" || $e.status === "dirty") && ae.dirty(), _e.set(Ie.value, $e.value);
      }
      return { status: ae.value, value: _e };
    }
  }
}
ZodMap.create = (ne, oe, ae) => new ZodMap({
  valueType: oe,
  keyType: ne,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(ae)
});
class ZodSet extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.parsedType !== ZodParsedType.set)
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: fe.parsedType
      }), INVALID;
    const ye = this._def;
    ye.minSize !== null && fe.data.size < ye.minSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_small,
      minimum: ye.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.minSize.message
    }), ae.dirty()), ye.maxSize !== null && fe.data.size > ye.maxSize.value && (addIssueToContext(fe, {
      code: ZodIssueCode.too_big,
      maximum: ye.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: ye.maxSize.message
    }), ae.dirty());
    const ge = this._def.valueType;
    function we(Se) {
      const Ie = /* @__PURE__ */ new Set();
      for (const $e of Se) {
        if ($e.status === "aborted")
          return INVALID;
        $e.status === "dirty" && ae.dirty(), Ie.add($e.value);
      }
      return { status: ae.value, value: Ie };
    }
    const _e = [...fe.data.values()].map((Se, Ie) => ge._parse(new ParseInputLazyPath(fe, Se, fe.path, Ie)));
    return fe.common.async ? Promise.all(_e).then((Se) => we(Se)) : we(_e);
  }
  min(oe, ae) {
    return new ZodSet({
      ...this._def,
      minSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  max(oe, ae) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: oe, message: errorUtil.toString(ae) }
    });
  }
  size(oe, ae) {
    return this.min(oe, ae).max(oe, ae);
  }
  nonempty(oe) {
    return this.min(1, oe);
  }
}
ZodSet.create = (ne, oe) => new ZodSet({
  valueType: ne,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(oe)
});
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.function)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ae.parsedType
      }), INVALID;
    function fe(_e, Se) {
      return makeIssue({
        data: _e,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((Ie) => !!Ie),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: Se
        }
      });
    }
    function ye(_e, Se) {
      return makeIssue({
        data: _e,
        path: ae.path,
        errorMaps: [
          ae.common.contextualErrorMap,
          ae.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((Ie) => !!Ie),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: Se
        }
      });
    }
    const ge = { errorMap: ae.common.contextualErrorMap }, we = ae.data;
    if (this._def.returns instanceof ZodPromise) {
      const _e = this;
      return OK(async function(...Se) {
        const Ie = new ZodError([]), $e = await _e._def.args.parseAsync(Se, ge).catch((Be) => {
          throw Ie.addIssue(fe(Se, Be)), Ie;
        }), Ne = await Reflect.apply(we, this, $e);
        return await _e._def.returns._def.type.parseAsync(Ne, ge).catch((Be) => {
          throw Ie.addIssue(ye(Ne, Be)), Ie;
        });
      });
    } else {
      const _e = this;
      return OK(function(...Se) {
        const Ie = _e._def.args.safeParse(Se, ge);
        if (!Ie.success)
          throw new ZodError([fe(Se, Ie.error)]);
        const $e = Reflect.apply(we, this, Ie.data), Ne = _e._def.returns.safeParse($e, ge);
        if (!Ne.success)
          throw new ZodError([ye($e, Ne.error)]);
        return Ne.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...oe) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(oe).rest(ZodUnknown.create())
    });
  }
  returns(oe) {
    return new ZodFunction({
      ...this._def,
      returns: oe
    });
  }
  implement(oe) {
    return this.parse(oe);
  }
  strictImplement(oe) {
    return this.parse(oe);
  }
  static create(oe, ae, fe) {
    return new ZodFunction({
      args: oe || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: ae || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(fe)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    return this._def.getter()._parse({ data: ae.data, path: ae.path, parent: ae });
  }
}
ZodLazy.create = (ne, oe) => new ZodLazy({
  getter: ne,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(oe)
});
class ZodLiteral extends ZodType {
  _parse(oe) {
    if (oe.data !== this._def.value) {
      const ae = this._getOrReturnCtx(oe);
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (ne, oe) => new ZodLiteral({
  value: ne,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(oe)
});
function createZodEnum(ne, oe) {
  return new ZodEnum({
    values: ne,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(oe)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    if (typeof oe.data != "string") {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        expected: util.joinValues(fe),
        received: ae.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodEnum_cache, new Set(this._def.values), "f"), !__classPrivateFieldGet$2(this, _ZodEnum_cache, "f").has(oe.data)) {
      const ae = this._getOrReturnCtx(oe), fe = this._def.values;
      return addIssueToContext(ae, {
        received: ae.data,
        code: ZodIssueCode.invalid_enum_value,
        options: fe
      }), INVALID;
    }
    return OK(oe.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Values() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  get Enum() {
    const oe = {};
    for (const ae of this._def.values)
      oe[ae] = ae;
    return oe;
  }
  extract(oe, ae = this._def) {
    return ZodEnum.create(oe, {
      ...this._def,
      ...ae
    });
  }
  exclude(oe, ae = this._def) {
    return ZodEnum.create(this.options.filter((fe) => !oe.includes(fe)), {
      ...this._def,
      ...ae
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(oe) {
    const ae = util.getValidEnumValues(this._def.values), fe = this._getOrReturnCtx(oe);
    if (fe.parsedType !== ZodParsedType.string && fe.parsedType !== ZodParsedType.number) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        expected: util.joinValues(ye),
        received: fe.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f") || __classPrivateFieldSet$1(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f"), !__classPrivateFieldGet$2(this, _ZodNativeEnum_cache, "f").has(oe.data)) {
      const ye = util.objectValues(ae);
      return addIssueToContext(fe, {
        received: fe.data,
        code: ZodIssueCode.invalid_enum_value,
        options: ye
      }), INVALID;
    }
    return OK(oe.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (ne, oe) => new ZodNativeEnum({
  values: ne,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(oe)
});
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    if (ae.parsedType !== ZodParsedType.promise && ae.common.async === !1)
      return addIssueToContext(ae, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ae.parsedType
      }), INVALID;
    const fe = ae.parsedType === ZodParsedType.promise ? ae.data : Promise.resolve(ae.data);
    return OK(fe.then((ye) => this._def.type.parseAsync(ye, {
      path: ae.path,
      errorMap: ae.common.contextualErrorMap
    })));
  }
}
ZodPromise.create = (ne, oe) => new ZodPromise({
  type: ne,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(oe)
});
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe), ye = this._def.effect || null, ge = {
      addIssue: (we) => {
        addIssueToContext(fe, we), we.fatal ? ae.abort() : ae.dirty();
      },
      get path() {
        return fe.path;
      }
    };
    if (ge.addIssue = ge.addIssue.bind(ge), ye.type === "preprocess") {
      const we = ye.transform(fe.data, ge);
      if (fe.common.async)
        return Promise.resolve(we).then(async (_e) => {
          if (ae.value === "aborted")
            return INVALID;
          const Se = await this._def.schema._parseAsync({
            data: _e,
            path: fe.path,
            parent: fe
          });
          return Se.status === "aborted" ? INVALID : Se.status === "dirty" || ae.value === "dirty" ? DIRTY(Se.value) : Se;
        });
      {
        if (ae.value === "aborted")
          return INVALID;
        const _e = this._def.schema._parseSync({
          data: we,
          path: fe.path,
          parent: fe
        });
        return _e.status === "aborted" ? INVALID : _e.status === "dirty" || ae.value === "dirty" ? DIRTY(_e.value) : _e;
      }
    }
    if (ye.type === "refinement") {
      const we = (_e) => {
        const Se = ye.refinement(_e, ge);
        if (fe.common.async)
          return Promise.resolve(Se);
        if (Se instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return _e;
      };
      if (fe.common.async === !1) {
        const _e = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return _e.status === "aborted" ? INVALID : (_e.status === "dirty" && ae.dirty(), we(_e.value), { status: ae.value, value: _e.value });
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((_e) => _e.status === "aborted" ? INVALID : (_e.status === "dirty" && ae.dirty(), we(_e.value).then(() => ({ status: ae.value, value: _e.value }))));
    }
    if (ye.type === "transform")
      if (fe.common.async === !1) {
        const we = this._def.schema._parseSync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        if (!isValid(we))
          return we;
        const _e = ye.transform(we.value, ge);
        if (_e instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: ae.value, value: _e };
      } else
        return this._def.schema._parseAsync({ data: fe.data, path: fe.path, parent: fe }).then((we) => isValid(we) ? Promise.resolve(ye.transform(we.value, ge)).then((_e) => ({ status: ae.value, value: _e })) : we);
    util.assertNever(ye);
  }
}
ZodEffects.create = (ne, oe, ae) => new ZodEffects({
  schema: ne,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect: oe,
  ...processCreateParams(ae)
});
ZodEffects.createWithPreprocess = (ne, oe, ae) => new ZodEffects({
  schema: oe,
  effect: { type: "preprocess", transform: ne },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(ae)
});
class ZodOptional extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (ne, oe) => new ZodOptional({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(oe)
});
class ZodNullable extends ZodType {
  _parse(oe) {
    return this._getType(oe) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(oe);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (ne, oe) => new ZodNullable({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(oe)
});
class ZodDefault extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe);
    let fe = ae.data;
    return ae.parsedType === ZodParsedType.undefined && (fe = this._def.defaultValue()), this._def.innerType._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (ne, oe) => new ZodDefault({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof oe.default == "function" ? oe.default : () => oe.default,
  ...processCreateParams(oe)
});
class ZodCatch extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = {
      ...ae,
      common: {
        ...ae.common,
        issues: []
      }
    }, ye = this._def.innerType._parse({
      data: fe.data,
      path: fe.path,
      parent: {
        ...fe
      }
    });
    return isAsync(ye) ? ye.then((ge) => ({
      status: "valid",
      value: ge.status === "valid" ? ge.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    })) : {
      status: "valid",
      value: ye.status === "valid" ? ye.value : this._def.catchValue({
        get error() {
          return new ZodError(fe.common.issues);
        },
        input: fe.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (ne, oe) => new ZodCatch({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof oe.catch == "function" ? oe.catch : () => oe.catch,
  ...processCreateParams(oe)
});
class ZodNaN extends ZodType {
  _parse(oe) {
    if (this._getType(oe) !== ZodParsedType.nan) {
      const fe = this._getOrReturnCtx(oe);
      return addIssueToContext(fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: fe.parsedType
      }), INVALID;
    }
    return { status: "valid", value: oe.data };
  }
}
ZodNaN.create = (ne) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(ne)
});
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(oe) {
    const { ctx: ae } = this._processInputParams(oe), fe = ae.data;
    return this._def.type._parse({
      data: fe,
      path: ae.path,
      parent: ae
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(oe) {
    const { status: ae, ctx: fe } = this._processInputParams(oe);
    if (fe.common.async)
      return (async () => {
        const ge = await this._def.in._parseAsync({
          data: fe.data,
          path: fe.path,
          parent: fe
        });
        return ge.status === "aborted" ? INVALID : ge.status === "dirty" ? (ae.dirty(), DIRTY(ge.value)) : this._def.out._parseAsync({
          data: ge.value,
          path: fe.path,
          parent: fe
        });
      })();
    {
      const ye = this._def.in._parseSync({
        data: fe.data,
        path: fe.path,
        parent: fe
      });
      return ye.status === "aborted" ? INVALID : ye.status === "dirty" ? (ae.dirty(), {
        status: "dirty",
        value: ye.value
      }) : this._def.out._parseSync({
        data: ye.value,
        path: fe.path,
        parent: fe
      });
    }
  }
  static create(oe, ae) {
    return new ZodPipeline({
      in: oe,
      out: ae,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(oe) {
    const ae = this._def.innerType._parse(oe), fe = (ye) => (isValid(ye) && (ye.value = Object.freeze(ye.value)), ye);
    return isAsync(ae) ? ae.then((ye) => fe(ye)) : fe(ae);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (ne, oe) => new ZodReadonly({
  innerType: ne,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(oe)
});
function custom(ne, oe = {}, ae) {
  return ne ? ZodAny.create().superRefine((fe, ye) => {
    var ge, we;
    if (!ne(fe)) {
      const _e = typeof oe == "function" ? oe(fe) : typeof oe == "string" ? { message: oe } : oe, Se = (we = (ge = _e.fatal) !== null && ge !== void 0 ? ge : ae) !== null && we !== void 0 ? we : !0, Ie = typeof _e == "string" ? { message: _e } : _e;
      ye.addIssue({ code: "custom", ...Ie, fatal: Se });
    }
  }) : ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ne) {
  ne.ZodString = "ZodString", ne.ZodNumber = "ZodNumber", ne.ZodNaN = "ZodNaN", ne.ZodBigInt = "ZodBigInt", ne.ZodBoolean = "ZodBoolean", ne.ZodDate = "ZodDate", ne.ZodSymbol = "ZodSymbol", ne.ZodUndefined = "ZodUndefined", ne.ZodNull = "ZodNull", ne.ZodAny = "ZodAny", ne.ZodUnknown = "ZodUnknown", ne.ZodNever = "ZodNever", ne.ZodVoid = "ZodVoid", ne.ZodArray = "ZodArray", ne.ZodObject = "ZodObject", ne.ZodUnion = "ZodUnion", ne.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ne.ZodIntersection = "ZodIntersection", ne.ZodTuple = "ZodTuple", ne.ZodRecord = "ZodRecord", ne.ZodMap = "ZodMap", ne.ZodSet = "ZodSet", ne.ZodFunction = "ZodFunction", ne.ZodLazy = "ZodLazy", ne.ZodLiteral = "ZodLiteral", ne.ZodEnum = "ZodEnum", ne.ZodEffects = "ZodEffects", ne.ZodNativeEnum = "ZodNativeEnum", ne.ZodOptional = "ZodOptional", ne.ZodNullable = "ZodNullable", ne.ZodDefault = "ZodDefault", ne.ZodCatch = "ZodCatch", ne.ZodPromise = "ZodPromise", ne.ZodBranded = "ZodBranded", ne.ZodPipeline = "ZodPipeline", ne.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (ne, oe = {
  message: `Input not instance of ${ne.name}`
}) => custom((ae) => ae instanceof ne, oe), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = {
  string: (ne) => ZodString.create({ ...ne, coerce: !0 }),
  number: (ne) => ZodNumber.create({ ...ne, coerce: !0 }),
  boolean: (ne) => ZodBoolean.create({
    ...ne,
    coerce: !0
  }),
  bigint: (ne) => ZodBigInt.create({ ...ne, coerce: !0 }),
  date: (ne) => ZodDate.create({ ...ne, coerce: !0 })
}, NEVER = INVALID;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
z$2.object({ chainId: z$2.number(), address: z$2.string().refine(isHex).optional(), filters: z$2.array(z$2.object({ tableId: z$2.string().refine(isHex), key0: z$2.string().refine(isHex).optional(), key1: z$2.string().refine(isHex).optional() })).default([]) });
function invert(ne) {
  const oe = /* @__PURE__ */ Object.create(null);
  for (const ae in ne) {
    const fe = ne[ae];
    oe[fe] = ae;
  }
  return oe;
}
const TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);
invert(TRPC_ERROR_CODES_BY_KEY);
const noop$2 = () => {
};
function createInnerProxy(ne, oe) {
  return new Proxy(noop$2, {
    get(fe, ye) {
      if (!(typeof ye != "string" || ye === "then"))
        return createInnerProxy(ne, [
          ...oe,
          ye
        ]);
    },
    apply(fe, ye, ge) {
      const we = oe[oe.length - 1] === "apply";
      return ne({
        args: we ? ge.length >= 2 ? ge[1] : [] : ge,
        path: we ? oe.slice(0, -1) : oe
      });
    }
  });
}
const createRecursiveProxy = (ne) => createInnerProxy(ne, []), createFlatProxy = (ne) => new Proxy(noop$2, {
  get(oe, ae) {
    if (!(typeof ae != "string" || ae === "then"))
      return ne(ae);
  }
});
var tO, nO, rO, oO, aO, iO;
typeof window > "u" || "Deno" in window || ((nO = (tO = globalThis.process) == null ? void 0 : tO.env) == null ? void 0 : nO.NODE_ENV) === "test" || (oO = (rO = globalThis.process) == null ? void 0 : rO.env) != null && oO.JEST_WORKER_ID || (iO = (aO = globalThis.process) == null ? void 0 : aO.env) != null && iO.VITEST_WORKER_ID;
var DoubleIndexedKV = (
  /** @class */
  function() {
    function ne() {
      this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
    }
    return ne.prototype.set = function(oe, ae) {
      this.keyToValue.set(oe, ae), this.valueToKey.set(ae, oe);
    }, ne.prototype.getByKey = function(oe) {
      return this.keyToValue.get(oe);
    }, ne.prototype.getByValue = function(oe) {
      return this.valueToKey.get(oe);
    }, ne.prototype.clear = function() {
      this.keyToValue.clear(), this.valueToKey.clear();
    }, ne;
  }()
), Registry = (
  /** @class */
  function() {
    function ne(oe) {
      this.generateIdentifier = oe, this.kv = new DoubleIndexedKV();
    }
    return ne.prototype.register = function(oe, ae) {
      this.kv.getByValue(oe) || (ae || (ae = this.generateIdentifier(oe)), this.kv.set(ae, oe));
    }, ne.prototype.clear = function() {
      this.kv.clear();
    }, ne.prototype.getIdentifier = function(oe) {
      return this.kv.getByValue(oe);
    }, ne.prototype.getValue = function(oe) {
      return this.kv.getByKey(oe);
    }, ne;
  }()
), __extends$1 = globalThis && globalThis.__extends || function() {
  var ne = function(oe, ae) {
    return ne = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ye) {
      fe.__proto__ = ye;
    } || function(fe, ye) {
      for (var ge in ye)
        Object.prototype.hasOwnProperty.call(ye, ge) && (fe[ge] = ye[ge]);
    }, ne(oe, ae);
  };
  return function(oe, ae) {
    if (typeof ae != "function" && ae !== null)
      throw new TypeError("Class extends value " + String(ae) + " is not a constructor or null");
    ne(oe, ae);
    function fe() {
      this.constructor = oe;
    }
    oe.prototype = ae === null ? Object.create(ae) : (fe.prototype = ae.prototype, new fe());
  };
}(), ClassRegistry = (
  /** @class */
  function(ne) {
    __extends$1(oe, ne);
    function oe() {
      var ae = ne.call(this, function(fe) {
        return fe.name;
      }) || this;
      return ae.classToAllowedProps = /* @__PURE__ */ new Map(), ae;
    }
    return oe.prototype.register = function(ae, fe) {
      typeof fe == "object" ? (fe.allowProps && this.classToAllowedProps.set(ae, fe.allowProps), ne.prototype.register.call(this, ae, fe.identifier)) : ne.prototype.register.call(this, ae, fe);
    }, oe.prototype.getAllowedProps = function(ae) {
      return this.classToAllowedProps.get(ae);
    }, oe;
  }(Registry)
), __read$4 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ge = [], we;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ge.push(ye.value);
  } catch (_e) {
    we = { error: _e };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (we)
        throw we.error;
    }
  }
  return ge;
};
function valuesOfObj(ne) {
  if ("values" in Object)
    return Object.values(ne);
  var oe = [];
  for (var ae in ne)
    ne.hasOwnProperty(ae) && oe.push(ne[ae]);
  return oe;
}
function find(ne, oe) {
  var ae = valuesOfObj(ne);
  if ("find" in ae)
    return ae.find(oe);
  for (var fe = ae, ye = 0; ye < fe.length; ye++) {
    var ge = fe[ye];
    if (oe(ge))
      return ge;
  }
}
function forEach(ne, oe) {
  Object.entries(ne).forEach(function(ae) {
    var fe = __read$4(ae, 2), ye = fe[0], ge = fe[1];
    return oe(ge, ye);
  });
}
function includes(ne, oe) {
  return ne.indexOf(oe) !== -1;
}
function findArr(ne, oe) {
  for (var ae = 0; ae < ne.length; ae++) {
    var fe = ne[ae];
    if (oe(fe))
      return fe;
  }
}
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function ne() {
      this.transfomers = {};
    }
    return ne.prototype.register = function(oe) {
      this.transfomers[oe.name] = oe;
    }, ne.prototype.findApplicable = function(oe) {
      return find(this.transfomers, function(ae) {
        return ae.isApplicable(oe);
      });
    }, ne.prototype.findByName = function(oe) {
      return this.transfomers[oe];
    }, ne;
  }()
), getType$1 = function(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}, isUndefined = function(ne) {
  return typeof ne > "u";
}, isNull = function(ne) {
  return ne === null;
}, isPlainObject$2 = function(ne) {
  return typeof ne != "object" || ne === null || ne === Object.prototype ? !1 : Object.getPrototypeOf(ne) === null ? !0 : Object.getPrototypeOf(ne) === Object.prototype;
}, isEmptyObject = function(ne) {
  return isPlainObject$2(ne) && Object.keys(ne).length === 0;
}, isArray$3 = function(ne) {
  return Array.isArray(ne);
}, isString = function(ne) {
  return typeof ne == "string";
}, isNumber = function(ne) {
  return typeof ne == "number" && !isNaN(ne);
}, isBoolean = function(ne) {
  return typeof ne == "boolean";
}, isRegExp = function(ne) {
  return ne instanceof RegExp;
}, isMap = function(ne) {
  return ne instanceof Map;
}, isSet = function(ne) {
  return ne instanceof Set;
}, isSymbol = function(ne) {
  return getType$1(ne) === "Symbol";
}, isDate = function(ne) {
  return ne instanceof Date && !isNaN(ne.valueOf());
}, isError = function(ne) {
  return ne instanceof Error;
}, isNaNValue = function(ne) {
  return typeof ne == "number" && isNaN(ne);
}, isPrimitive = function(ne) {
  return isBoolean(ne) || isNull(ne) || isUndefined(ne) || isNumber(ne) || isString(ne) || isSymbol(ne);
}, isBigint = function(ne) {
  return typeof ne == "bigint";
}, isInfinite = function(ne) {
  return ne === 1 / 0 || ne === -1 / 0;
}, isTypedArray = function(ne) {
  return ArrayBuffer.isView(ne) && !(ne instanceof DataView);
}, isURL = function(ne) {
  return ne instanceof URL;
}, escapeKey = function(ne) {
  return ne.replace(/\./g, "\\.");
}, stringifyPath = function(ne) {
  return ne.map(String).map(escapeKey).join(".");
}, parsePath = function(ne) {
  for (var oe = [], ae = "", fe = 0; fe < ne.length; fe++) {
    var ye = ne.charAt(fe), ge = ye === "\\" && ne.charAt(fe + 1) === ".";
    if (ge) {
      ae += ".", fe++;
      continue;
    }
    var we = ye === ".";
    if (we) {
      oe.push(ae), ae = "";
      continue;
    }
    ae += ye;
  }
  var _e = ae;
  return oe.push(_e), oe;
}, __assign$1 = globalThis && globalThis.__assign || function() {
  return __assign$1 = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign$1.apply(this, arguments);
}, __read$3 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ge = [], we;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ge.push(ye.value);
  } catch (_e) {
    we = { error: _e };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (we)
        throw we.error;
    }
  }
  return ge;
}, __spreadArray$3 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function simpleTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
  }),
  simpleTransformation(isBigint, "bigint", function(ne) {
    return ne.toString();
  }, function(ne) {
    return typeof BigInt < "u" ? BigInt(ne) : (console.error("Please add a BigInt polyfill."), ne);
  }),
  simpleTransformation(isDate, "Date", function(ne) {
    return ne.toISOString();
  }, function(ne) {
    return new Date(ne);
  }),
  simpleTransformation(isError, "Error", function(ne, oe) {
    var ae = {
      name: ne.name,
      message: ne.message
    };
    return oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }, function(ne, oe) {
    var ae = new Error(ne.message);
    return ae.name = ne.name, ae.stack = ne.stack, oe.allowedErrorProps.forEach(function(fe) {
      ae[fe] = ne[fe];
    }), ae;
  }),
  simpleTransformation(isRegExp, "regexp", function(ne) {
    return "" + ne;
  }, function(ne) {
    var oe = ne.slice(1, ne.lastIndexOf("/")), ae = ne.slice(ne.lastIndexOf("/") + 1);
    return new RegExp(oe, ae);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(ne) {
      return __spreadArray$3([], __read$3(ne.values()));
    },
    function(ne) {
      return new Set(ne);
    }
  ),
  simpleTransformation(isMap, "map", function(ne) {
    return __spreadArray$3([], __read$3(ne.entries()));
  }, function(ne) {
    return new Map(ne);
  }),
  simpleTransformation(function(ne) {
    return isNaNValue(ne) || isInfinite(ne);
  }, "number", function(ne) {
    return isNaNValue(ne) ? "NaN" : ne > 0 ? "Infinity" : "-Infinity";
  }, Number),
  simpleTransformation(function(ne) {
    return ne === 0 && 1 / ne === -1 / 0;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(ne) {
    return ne.toString();
  }, function(ne) {
    return new URL(ne);
  })
];
function compositeTransformation(ne, oe, ae, fe) {
  return {
    isApplicable: ne,
    annotation: oe,
    transform: ae,
    untransform: fe
  };
}
var symbolRule = compositeTransformation(function(ne, oe) {
  if (isSymbol(ne)) {
    var ae = !!oe.symbolRegistry.getIdentifier(ne);
    return ae;
  }
  return !1;
}, function(ne, oe) {
  var ae = oe.symbolRegistry.getIdentifier(ne);
  return ["symbol", ae];
}, function(ne) {
  return ne.description;
}, function(ne, oe, ae) {
  var fe = ae.symbolRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown symbol");
  return fe;
}), constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(ne, oe) {
  return ne[oe.name] = oe, ne;
}, {}), typedArrayRule = compositeTransformation(isTypedArray, function(ne) {
  return ["typed-array", ne.constructor.name];
}, function(ne) {
  return __spreadArray$3([], __read$3(ne));
}, function(ne, oe) {
  var ae = constructorToName[oe[1]];
  if (!ae)
    throw new Error("Trying to deserialize unknown typed array");
  return new ae(ne);
});
function isInstanceOfRegisteredClass(ne, oe) {
  if (ne != null && ne.constructor) {
    var ae = !!oe.classRegistry.getIdentifier(ne.constructor);
    return ae;
  }
  return !1;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(ne, oe) {
  var ae = oe.classRegistry.getIdentifier(ne.constructor);
  return ["class", ae];
}, function(ne, oe) {
  var ae = oe.classRegistry.getAllowedProps(ne.constructor);
  if (!ae)
    return __assign$1({}, ne);
  var fe = {};
  return ae.forEach(function(ye) {
    fe[ye] = ne[ye];
  }), fe;
}, function(ne, oe, ae) {
  var fe = ae.classRegistry.getValue(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  return Object.assign(Object.create(fe.prototype), ne);
}), customRule = compositeTransformation(function(ne, oe) {
  return !!oe.customTransformerRegistry.findApplicable(ne);
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ["custom", ae.name];
}, function(ne, oe) {
  var ae = oe.customTransformerRegistry.findApplicable(ne);
  return ae.serialize(ne);
}, function(ne, oe, ae) {
  var fe = ae.customTransformerRegistry.findByName(oe[1]);
  if (!fe)
    throw new Error("Trying to deserialize unknown custom value");
  return fe.deserialize(ne);
}), compositeRules = [classRule, symbolRule, customRule, typedArrayRule], transformValue = function(ne, oe) {
  var ae = findArr(compositeRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (ae)
    return {
      value: ae.transform(ne, oe),
      type: ae.annotation(ne, oe)
    };
  var fe = findArr(simpleRules, function(ye) {
    return ye.isApplicable(ne, oe);
  });
  if (fe)
    return {
      value: fe.transform(ne, oe),
      type: fe.annotation
    };
}, simpleRulesByAnnotation = {};
simpleRules.forEach(function(ne) {
  simpleRulesByAnnotation[ne.annotation] = ne;
});
var untransformValue = function(ne, oe, ae) {
  if (isArray$3(oe))
    switch (oe[0]) {
      case "symbol":
        return symbolRule.untransform(ne, oe, ae);
      case "class":
        return classRule.untransform(ne, oe, ae);
      case "custom":
        return customRule.untransform(ne, oe, ae);
      case "typed-array":
        return typedArrayRule.untransform(ne, oe, ae);
      default:
        throw new Error("Unknown transformation: " + oe);
    }
  else {
    var fe = simpleRulesByAnnotation[oe];
    if (!fe)
      throw new Error("Unknown transformation: " + oe);
    return fe.untransform(ne, ae);
  }
}, getNthKey = function(ne, oe) {
  for (var ae = ne.keys(); oe > 0; )
    ae.next(), oe--;
  return ae.next().value;
};
function validatePath(ne) {
  if (includes(ne, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (includes(ne, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (includes(ne, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var getDeep = function(ne, oe) {
  validatePath(oe);
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    if (isSet(ne))
      ne = getNthKey(ne, +fe);
    else if (isMap(ne)) {
      var ye = +fe, ge = +oe[++ae] == 0 ? "key" : "value", we = getNthKey(ne, ye);
      switch (ge) {
        case "key":
          ne = we;
          break;
        case "value":
          ne = ne.get(we);
          break;
      }
    } else
      ne = ne[fe];
  }
  return ne;
}, setDeep = function(ne, oe, ae) {
  if (validatePath(oe), oe.length === 0)
    return ae(ne);
  for (var fe = ne, ye = 0; ye < oe.length - 1; ye++) {
    var ge = oe[ye];
    if (isArray$3(fe)) {
      var we = +ge;
      fe = fe[we];
    } else if (isPlainObject$2(fe))
      fe = fe[ge];
    else if (isSet(fe)) {
      var _e = +ge;
      fe = getNthKey(fe, _e);
    } else if (isMap(fe)) {
      var Se = ye === oe.length - 2;
      if (Se)
        break;
      var _e = +ge, Ie = +oe[++ye] == 0 ? "key" : "value", $e = getNthKey(fe, _e);
      switch (Ie) {
        case "key":
          fe = $e;
          break;
        case "value":
          fe = fe.get($e);
          break;
      }
    }
  }
  var Ne = oe[oe.length - 1];
  if (isArray$3(fe) ? fe[+Ne] = ae(fe[+Ne]) : isPlainObject$2(fe) && (fe[Ne] = ae(fe[Ne])), isSet(fe)) {
    var Me = getNthKey(fe, +Ne), Be = ae(Me);
    Me !== Be && (fe.delete(Me), fe.add(Be));
  }
  if (isMap(fe)) {
    var _e = +oe[oe.length - 2], ze = getNthKey(fe, _e), Ie = +Ne == 0 ? "key" : "value";
    switch (Ie) {
      case "key": {
        var He = ae(ze);
        fe.set(He, fe.get(ze)), He !== ze && fe.delete(ze);
        break;
      }
      case "value": {
        fe.set(ze, ae(fe.get(ze)));
        break;
      }
    }
  }
  return ne;
}, __read$2 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ge = [], we;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ge.push(ye.value);
  } catch (_e) {
    we = { error: _e };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (we)
        throw we.error;
    }
  }
  return ge;
}, __spreadArray$2 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
};
function traverse(ne, oe, ae) {
  if (ae === void 0 && (ae = []), !!ne) {
    if (!isArray$3(ne)) {
      forEach(ne, function(we, _e) {
        return traverse(we, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(_e))));
      });
      return;
    }
    var fe = __read$2(ne, 2), ye = fe[0], ge = fe[1];
    ge && forEach(ge, function(we, _e) {
      traverse(we, oe, __spreadArray$2(__spreadArray$2([], __read$2(ae)), __read$2(parsePath(_e))));
    }), oe(ye, ae);
  }
}
function applyValueAnnotations(ne, oe, ae) {
  return traverse(oe, function(fe, ye) {
    ne = setDeep(ne, ye, function(ge) {
      return untransformValue(ge, fe, ae);
    });
  }), ne;
}
function applyReferentialEqualityAnnotations(ne, oe) {
  function ae(we, _e) {
    var Se = getDeep(ne, parsePath(_e));
    we.map(parsePath).forEach(function(Ie) {
      ne = setDeep(ne, Ie, function() {
        return Se;
      });
    });
  }
  if (isArray$3(oe)) {
    var fe = __read$2(oe, 2), ye = fe[0], ge = fe[1];
    ye.forEach(function(we) {
      ne = setDeep(ne, parsePath(we), function() {
        return ne;
      });
    }), ge && forEach(ge, ae);
  } else
    forEach(oe, ae);
  return ne;
}
var isDeep = function(ne, oe) {
  return isPlainObject$2(ne) || isArray$3(ne) || isMap(ne) || isSet(ne) || isInstanceOfRegisteredClass(ne, oe);
};
function addIdentity(ne, oe, ae) {
  var fe = ae.get(ne);
  fe ? fe.push(oe) : ae.set(ne, [oe]);
}
function generateReferentialEqualityAnnotations(ne, oe) {
  var ae = {}, fe = void 0;
  return ne.forEach(function(ye) {
    if (!(ye.length <= 1)) {
      oe || (ye = ye.map(function(Se) {
        return Se.map(String);
      }).sort(function(Se, Ie) {
        return Se.length - Ie.length;
      }));
      var ge = __read$2(ye), we = ge[0], _e = ge.slice(1);
      we.length === 0 ? fe = _e.map(stringifyPath) : ae[stringifyPath(we)] = _e.map(stringifyPath);
    }
  }), fe ? isEmptyObject(ae) ? [fe] : [fe, ae] : isEmptyObject(ae) ? void 0 : ae;
}
var walker = function(ne, oe, ae, fe, ye, ge, we) {
  var _e;
  ye === void 0 && (ye = []), ge === void 0 && (ge = []), we === void 0 && (we = /* @__PURE__ */ new Map());
  var Se = isPrimitive(ne);
  if (!Se) {
    addIdentity(ne, ye, oe);
    var Ie = we.get(ne);
    if (Ie)
      return fe ? {
        transformedValue: null
      } : Ie;
  }
  if (!isDeep(ne, ae)) {
    var $e = transformValue(ne, ae), Ne = $e ? {
      transformedValue: $e.value,
      annotations: [$e.type]
    } : {
      transformedValue: ne
    };
    return Se || we.set(ne, Ne), Ne;
  }
  if (includes(ge, ne))
    return {
      transformedValue: null
    };
  var Me = transformValue(ne, ae), Be = (_e = Me == null ? void 0 : Me.value) !== null && _e !== void 0 ? _e : ne, ze = isArray$3(Be) ? [] : {}, He = {};
  forEach(Be, function(qe, tt) {
    var Xe = walker(qe, oe, ae, fe, __spreadArray$2(__spreadArray$2([], __read$2(ye)), [tt]), __spreadArray$2(__spreadArray$2([], __read$2(ge)), [ne]), we);
    ze[tt] = Xe.transformedValue, isArray$3(Xe.annotations) ? He[tt] = Xe.annotations : isPlainObject$2(Xe.annotations) && forEach(Xe.annotations, function(ot, pt) {
      He[escapeKey(tt) + "." + pt] = ot;
    });
  });
  var Ze = isEmptyObject(He) ? {
    transformedValue: ze,
    annotations: Me ? [Me.type] : void 0
  } : {
    transformedValue: ze,
    annotations: Me ? [Me.type, He] : He
  };
  return Se || we.set(ne, Ze), Ze;
};
function getType(ne) {
  return Object.prototype.toString.call(ne).slice(8, -1);
}
function isArray$2(ne) {
  return getType(ne) === "Array";
}
function isPlainObject$1(ne) {
  if (getType(ne) !== "Object")
    return !1;
  const oe = Object.getPrototypeOf(ne);
  return !!oe && oe.constructor === Object && oe === Object.prototype;
}
function assignProp(ne, oe, ae, fe, ye) {
  const ge = {}.propertyIsEnumerable.call(fe, oe) ? "enumerable" : "nonenumerable";
  ge === "enumerable" && (ne[oe] = ae), ye && ge === "nonenumerable" && Object.defineProperty(ne, oe, {
    value: ae,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function copy(ne, oe = {}) {
  if (isArray$2(ne))
    return ne.map((ye) => copy(ye, oe));
  if (!isPlainObject$1(ne))
    return ne;
  const ae = Object.getOwnPropertyNames(ne), fe = Object.getOwnPropertySymbols(ne);
  return [...ae, ...fe].reduce((ye, ge) => {
    if (isArray$2(oe.props) && !oe.props.includes(ge))
      return ye;
    const we = ne[ge], _e = copy(we, oe);
    return assignProp(ye, ge, _e, ne, oe.nonenumerable), ye;
  }, {});
}
var __assign = globalThis && globalThis.__assign || function() {
  return __assign = Object.assign || function(ne) {
    for (var oe, ae = 1, fe = arguments.length; ae < fe; ae++) {
      oe = arguments[ae];
      for (var ye in oe)
        Object.prototype.hasOwnProperty.call(oe, ye) && (ne[ye] = oe[ye]);
    }
    return ne;
  }, __assign.apply(this, arguments);
}, __read$1 = globalThis && globalThis.__read || function(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ge = [], we;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ge.push(ye.value);
  } catch (_e) {
    we = { error: _e };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (we)
        throw we.error;
    }
  }
  return ge;
}, __spreadArray$1 = globalThis && globalThis.__spreadArray || function(ne, oe) {
  for (var ae = 0, fe = oe.length, ye = ne.length; ae < fe; ae++, ye++)
    ne[ye] = oe[ae];
  return ne;
}, SuperJSON = (
  /** @class */
  function() {
    function ne(oe) {
      var ae = oe === void 0 ? {} : oe, fe = ae.dedupe, ye = fe === void 0 ? !1 : fe;
      this.classRegistry = new ClassRegistry(), this.symbolRegistry = new Registry(function(ge) {
        var we;
        return (we = ge.description) !== null && we !== void 0 ? we : "";
      }), this.customTransformerRegistry = new CustomTransformerRegistry(), this.allowedErrorProps = [], this.dedupe = ye;
    }
    return ne.prototype.serialize = function(oe) {
      var ae = /* @__PURE__ */ new Map(), fe = walker(oe, ae, this, this.dedupe), ye = {
        json: fe.transformedValue
      };
      fe.annotations && (ye.meta = __assign(__assign({}, ye.meta), { values: fe.annotations }));
      var ge = generateReferentialEqualityAnnotations(ae, this.dedupe);
      return ge && (ye.meta = __assign(__assign({}, ye.meta), { referentialEqualities: ge })), ye;
    }, ne.prototype.deserialize = function(oe) {
      var ae = oe.json, fe = oe.meta, ye = copy(ae);
      return fe != null && fe.values && (ye = applyValueAnnotations(ye, fe.values, this)), fe != null && fe.referentialEqualities && (ye = applyReferentialEqualityAnnotations(ye, fe.referentialEqualities)), ye;
    }, ne.prototype.stringify = function(oe) {
      return JSON.stringify(this.serialize(oe));
    }, ne.prototype.parse = function(oe) {
      return this.deserialize(JSON.parse(oe));
    }, ne.prototype.registerClass = function(oe, ae) {
      this.classRegistry.register(oe, ae);
    }, ne.prototype.registerSymbol = function(oe, ae) {
      this.symbolRegistry.register(oe, ae);
    }, ne.prototype.registerCustom = function(oe, ae) {
      this.customTransformerRegistry.register(__assign({ name: ae }, oe));
    }, ne.prototype.allowErrorProps = function() {
      for (var oe, ae = [], fe = 0; fe < arguments.length; fe++)
        ae[fe] = arguments[fe];
      (oe = this.allowedErrorProps).push.apply(oe, __spreadArray$1([], __read$1(ae)));
    }, ne.defaultInstance = new ne(), ne.serialize = ne.defaultInstance.serialize.bind(ne.defaultInstance), ne.deserialize = ne.defaultInstance.deserialize.bind(ne.defaultInstance), ne.stringify = ne.defaultInstance.stringify.bind(ne.defaultInstance), ne.parse = ne.defaultInstance.parse.bind(ne.defaultInstance), ne.registerClass = ne.defaultInstance.registerClass.bind(ne.defaultInstance), ne.registerSymbol = ne.defaultInstance.registerSymbol.bind(ne.defaultInstance), ne.registerCustom = ne.defaultInstance.registerCustom.bind(ne.defaultInstance), ne.allowErrorProps = ne.defaultInstance.allowErrorProps.bind(ne.defaultInstance), ne;
  }()
);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
function identity$1(ne) {
  return ne;
}
function pipeFromArray$1(ne) {
  return ne.length === 0 ? identity$1 : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce((fe, ye) => ye(fe), ae);
  };
}
function observable$2(ne) {
  const oe = {
    subscribe(ae) {
      let fe = null, ye = !1, ge = !1, we = !1;
      function _e() {
        if (fe === null) {
          we = !0;
          return;
        }
        ge || (ge = !0, typeof fe == "function" ? fe() : fe && fe.unsubscribe());
      }
      return fe = ne({
        next(Se) {
          var Ie;
          ye || (Ie = ae.next) == null || Ie.call(ae, Se);
        },
        error(Se) {
          var Ie;
          ye || (ye = !0, (Ie = ae.error) == null || Ie.call(ae, Se), _e());
        },
        complete() {
          var Se;
          ye || (ye = !0, (Se = ae.complete) == null || Se.call(ae), _e());
        }
      }), we && _e(), {
        unsubscribe: _e
      };
    },
    pipe(...ae) {
      return pipeFromArray$1(ae)(oe);
    }
  };
  return oe;
}
function share$1(ne) {
  return (oe) => {
    let ae = 0, fe = null;
    const ye = [];
    function ge() {
      fe || (fe = oe.subscribe({
        next(_e) {
          var Se;
          for (const Ie of ye)
            (Se = Ie.next) == null || Se.call(Ie, _e);
        },
        error(_e) {
          var Se;
          for (const Ie of ye)
            (Se = Ie.error) == null || Se.call(Ie, _e);
        },
        complete() {
          var _e;
          for (const Se of ye)
            (_e = Se.complete) == null || _e.call(Se);
        }
      }));
    }
    function we() {
      if (ae === 0 && fe) {
        const _e = fe;
        fe = null, _e.unsubscribe();
      }
    }
    return {
      subscribe(_e) {
        return ae++, ye.push(_e), ge(), {
          unsubscribe() {
            ae--, we();
            const Se = ye.findIndex((Ie) => Ie === _e);
            Se > -1 && ye.splice(Se, 1);
          }
        };
      }
    };
  };
}
class ObservableAbortError extends Error {
  constructor(oe) {
    super(oe), this.name = "ObservableAbortError", Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
}
function observableToPromise(ne) {
  let oe;
  return {
    promise: new Promise((fe, ye) => {
      let ge = !1;
      function we() {
        ge || (ge = !0, ye(new ObservableAbortError("This operation was aborted.")), _e.unsubscribe());
      }
      const _e = ne.subscribe({
        next(Se) {
          ge = !0, fe(Se), we();
        },
        error(Se) {
          ge = !0, ye(Se), we();
        },
        complete() {
          ge = !0, we();
        }
      });
      oe = we;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: oe
  };
}
function createChain(ne) {
  return observable$2((oe) => {
    function ae(ye = 0, ge = ne.op) {
      const we = ne.links[ye];
      if (!we)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return we({
        op: ge,
        next(Se) {
          return ae(ye + 1, Se);
        }
      });
    }
    return ae().subscribe(oe);
  });
}
function isTRPCClientError(ne) {
  return ne instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  ne.name === "TRPCClientError";
}
class TRPCClientError extends Error {
  static from(oe, ae = {}) {
    return oe instanceof Error ? isTRPCClientError(oe) ? (ae.meta && (oe.meta = {
      ...oe.meta,
      ...ae.meta
    }), oe) : new TRPCClientError(oe.message, {
      ...ae,
      cause: oe,
      result: null
    }) : new TRPCClientError(oe.error.message ?? "", {
      ...ae,
      cause: void 0,
      result: oe
    });
  }
  constructor(oe, ae) {
    var ye, ge;
    const fe = ae == null ? void 0 : ae.cause;
    super(oe, {
      cause: fe
    }), this.meta = ae == null ? void 0 : ae.meta, this.cause = fe, this.shape = (ye = ae == null ? void 0 : ae.result) == null ? void 0 : ye.error, this.data = (ge = ae == null ? void 0 : ae.result) == null ? void 0 : ge.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
}
const isFunction$2 = (ne) => typeof ne == "function";
function getFetch(ne) {
  if (ne)
    return ne;
  if (typeof window < "u" && isFunction$2(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && isFunction$2(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function getAbortController(ne) {
  return ne || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function resolveHTTPLinkOptions(ne) {
  return {
    url: ne.url,
    fetch: ne.fetch,
    AbortController: getAbortController(ne.AbortController)
  };
}
function arrayToDict(ne) {
  const oe = {};
  for (let ae = 0; ae < ne.length; ae++) {
    const fe = ne[ae];
    oe[ae] = fe;
  }
  return oe;
}
const METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(ne) {
  return "input" in ne ? ne.runtime.transformer.serialize(ne.input) : arrayToDict(ne.inputs.map((oe) => ne.runtime.transformer.serialize(oe)));
}
const getUrl = (ne) => {
  let oe = ne.url + "/" + ne.path;
  const ae = [];
  if ("inputs" in ne && ae.push("batch=1"), ne.type === "query") {
    const fe = getInput(ne);
    fe !== void 0 && ae.push(`input=${encodeURIComponent(JSON.stringify(fe))}`);
  }
  return ae.length && (oe += "?" + ae.join("&")), oe;
}, getBody = (ne) => {
  if (ne.type === "query")
    return;
  const oe = getInput(ne);
  return oe !== void 0 ? JSON.stringify(oe) : void 0;
}, jsonHttpRequester = (ne) => httpRequest({
  ...ne,
  contentTypeHeader: "application/json",
  getUrl,
  getBody
});
async function fetchHTTPResponse(ne, oe) {
  const ae = ne.getUrl(ne), fe = ne.getBody(ne), { type: ye } = ne, ge = await ne.headers();
  /* istanbul ignore if -- @preserve */
  if (ye === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const we = {
    ...ne.contentTypeHeader ? {
      "content-type": ne.contentTypeHeader
    } : {},
    ...ne.batchModeHeader ? {
      "trpc-batch-mode": ne.batchModeHeader
    } : {},
    ...ge
  };
  return getFetch(ne.fetch)(ae, {
    method: METHOD[ye],
    signal: oe == null ? void 0 : oe.signal,
    body: fe,
    headers: we
  });
}
function httpRequest(ne) {
  const oe = ne.AbortController ? new ne.AbortController() : null, ae = {};
  return {
    promise: new Promise((ge, we) => {
      fetchHTTPResponse(ne, oe).then((_e) => (ae.response = _e, _e.json())).then((_e) => {
        ae.responseJSON = _e, ge({
          json: _e,
          meta: ae
        });
      }).catch((_e) => {
        we(TRPCClientError.from(_e, {
          meta: ae
        }));
      });
    }),
    cancel: () => {
      oe == null || oe.abort();
    }
  };
}
function isObject$1(ne) {
  return !!ne && !Array.isArray(ne) && typeof ne == "object";
}
function transformResultInner(ne, oe) {
  if ("error" in ne) {
    const fe = oe.transformer.deserialize(ne.error);
    return {
      ok: !1,
      error: {
        ...ne,
        error: fe
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...ne.result,
      ...(!ne.result.type || ne.result.type === "data") && {
        type: "data",
        data: oe.transformer.deserialize(ne.result.data)
      }
    }
  };
}
class TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function transformResult(ne, oe) {
  let ae;
  try {
    ae = transformResultInner(ne, oe);
  } catch {
    throw new TransformResultError();
  }
  if (!ae.ok && (!isObject$1(ae.error.error) || typeof ae.error.error.code != "number"))
    throw new TransformResultError();
  if (ae.ok && !isObject$1(ae.result))
    throw new TransformResultError();
  return ae;
}
const throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(ne) {
  let oe = null, ae = null;
  const fe = () => {
    clearTimeout(ae), ae = null, oe = null;
  };
  function ye(_e) {
    var $e, Ne;
    const Se = [
      []
    ];
    let Ie = 0;
    for (; ; ) {
      const Me = _e[Ie];
      if (!Me)
        break;
      const Be = Se[Se.length - 1];
      if (Me.aborted) {
        ($e = Me.reject) == null || $e.call(Me, new Error("Aborted")), Ie++;
        continue;
      }
      if (ne.validate(Be.concat(Me).map((He) => He.key))) {
        Be.push(Me), Ie++;
        continue;
      }
      if (Be.length === 0) {
        (Ne = Me.reject) == null || Ne.call(Me, new Error("Input is too big for a single dispatch")), Ie++;
        continue;
      }
      Se.push([]);
    }
    return Se;
  }
  function ge() {
    const _e = ye(oe);
    fe();
    for (const Se of _e) {
      if (!Se.length)
        continue;
      const Ie = {
        items: Se,
        cancel: throwFatalError
      };
      for (const Be of Se)
        Be.batch = Ie;
      const $e = (Be, ze) => {
        var Ze;
        const He = Ie.items[Be];
        (Ze = He.resolve) == null || Ze.call(He, ze), He.batch = null, He.reject = null, He.resolve = null;
      }, { promise: Ne, cancel: Me } = ne.fetch(Ie.items.map((Be) => Be.key), $e);
      Ie.cancel = Me, Ne.then((Be) => {
        var ze;
        for (let He = 0; He < Be.length; He++) {
          const Ze = Be[He];
          $e(He, Ze);
        }
        for (const He of Ie.items)
          (ze = He.reject) == null || ze.call(He, new Error("Missing result")), He.batch = null;
      }).catch((Be) => {
        var ze;
        for (const He of Ie.items)
          (ze = He.reject) == null || ze.call(He, Be), He.batch = null;
      });
    }
  }
  function we(_e) {
    const Se = {
      aborted: !1,
      key: _e,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    }, Ie = new Promise((Ne, Me) => {
      Se.reject = Me, Se.resolve = Ne, oe || (oe = []), oe.push(Se);
    });
    return ae || (ae = setTimeout(ge)), {
      promise: Ie,
      cancel: () => {
        var Ne;
        Se.aborted = !0, (Ne = Se.batch) != null && Ne.items.every((Me) => Me.aborted) && (Se.batch.cancel(), Se.batch = null);
      }
    };
  }
  return {
    load: we
  };
}
function createHTTPBatchLink(ne) {
  return function(ae) {
    const fe = resolveHTTPLinkOptions(ae), ye = ae.maxURLLength ?? 1 / 0;
    return (ge) => {
      const we = (Ne) => {
        const Me = (ze) => {
          if (ye === 1 / 0)
            return !0;
          const He = ze.map((tt) => tt.path).join(","), Ze = ze.map((tt) => tt.input);
          return getUrl({
            ...fe,
            runtime: ge,
            type: Ne,
            path: He,
            inputs: Ze
          }).length <= ye;
        }, Be = ne({
          ...fe,
          runtime: ge,
          type: Ne,
          opts: ae
        });
        return {
          validate: Me,
          fetch: Be
        };
      }, _e = dataLoader(we("query")), Se = dataLoader(we("mutation")), Ie = dataLoader(we("subscription")), $e = {
        query: _e,
        subscription: Ie,
        mutation: Se
      };
      return ({ op: Ne }) => observable$2((Me) => {
        const Be = $e[Ne.type], { promise: ze, cancel: He } = Be.load(Ne);
        let Ze;
        return ze.then((qe) => {
          Ze = qe;
          const tt = transformResult(qe.json, ge);
          if (!tt.ok) {
            Me.error(TRPCClientError.from(tt.error, {
              meta: qe.meta
            }));
            return;
          }
          Me.next({
            context: qe.meta,
            result: tt.result
          }), Me.complete();
        }).catch((qe) => {
          Me.error(TRPCClientError.from(qe, {
            meta: Ze == null ? void 0 : Ze.meta
          }));
        }), () => {
          He();
        };
      });
    };
  };
}
const batchRequester = (ne) => (oe) => {
  const ae = oe.map((we) => we.path).join(","), fe = oe.map((we) => we.input), { promise: ye, cancel: ge } = jsonHttpRequester({
    ...ne,
    path: ae,
    inputs: fe,
    headers() {
      return ne.opts.headers ? typeof ne.opts.headers == "function" ? ne.opts.headers({
        opList: oe
      }) : ne.opts.headers : {};
    }
  });
  return {
    promise: ye.then((we) => (Array.isArray(we.json) ? we.json : oe.map(() => we.json)).map((Ie) => ({
      meta: we.meta,
      json: Ie
    }))),
    cancel: ge
  };
}, httpBatchLink = createHTTPBatchLink(batchRequester);
class TRPCUntypedClient {
  $request({ type: oe, input: ae, path: fe, context: ye = {} }) {
    return createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: oe,
        path: fe,
        input: ae,
        context: ye
      }
    }).pipe(share$1());
  }
  requestAsPromise(oe) {
    const ae = this.$request(oe), { promise: fe, abort: ye } = observableToPromise(ae);
    return new Promise((we, _e) => {
      var Se;
      (Se = oe.signal) == null || Se.addEventListener("abort", ye), fe.then((Ie) => {
        we(Ie.result.data);
      }).catch((Ie) => {
        _e(TRPCClientError.from(Ie));
      });
    });
  }
  query(oe, ae, fe) {
    return this.requestAsPromise({
      type: "query",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  mutation(oe, ae, fe) {
    return this.requestAsPromise({
      type: "mutation",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context,
      signal: fe == null ? void 0 : fe.signal
    });
  }
  subscription(oe, ae, fe) {
    return this.$request({
      type: "subscription",
      path: oe,
      input: ae,
      context: fe == null ? void 0 : fe.context
    }).subscribe({
      next(ge) {
        var we, _e, Se;
        ge.result.type === "started" ? (we = fe.onStarted) == null || we.call(fe) : ge.result.type === "stopped" ? (_e = fe.onStopped) == null || _e.call(fe) : (Se = fe.onData) == null || Se.call(fe, ge.result.data);
      },
      error(ge) {
        var we;
        (we = fe.onError) == null || we.call(fe, ge);
      },
      complete() {
        var ge;
        (ge = fe.onComplete) == null || ge.call(fe);
      }
    });
  }
  constructor(oe) {
    this.requestId = 0;
    const ae = (() => {
      const fe = oe.transformer;
      return fe ? "input" in fe ? oe.transformer : {
        input: fe,
        output: fe
      } : {
        input: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        },
        output: {
          serialize: (ye) => ye,
          deserialize: (ye) => ye
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (fe) => ae.input.serialize(fe),
        deserialize: (fe) => ae.output.deserialize(fe)
      },
      combinedTransformer: ae
    }, this.links = oe.links.map((fe) => fe(this.runtime));
  }
}
const clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, clientCallTypeToProcedureType = (ne) => clientCallTypeMap[ne];
function createTRPCClientProxy(ne) {
  return createFlatProxy((oe) => ne.hasOwnProperty(oe) ? ne[oe] : oe === "__untypedClient" ? ne : createRecursiveProxy(({ path: ae, args: fe }) => {
    const ye = [
      oe,
      ...ae
    ], ge = clientCallTypeToProcedureType(ye.pop()), we = ye.join(".");
    return ne[ge](we, ...fe);
  }));
}
function createTRPCProxyClient(ne) {
  const oe = new TRPCUntypedClient(ne);
  return createTRPCClientProxy(oe);
}
function g$5({ url: ne }) {
  return createTRPCProxyClient({ transformer: SuperJSON, links: [httpBatchLink({ url: ne })] });
}
function s$3({ url: ne }) {
  return { getLogs: async (oe) => {
    try {
      let ae = encodeURIComponent(JSON.stringify(oe)), fe = new URL(ne).origin, ye = await (await fetch(`${fe}/api/logs?input=${ae}`, { method: "GET" })).json();
      return i$4(ye) ? { ok: { ...ye, blockNumber: BigInt(ye.blockNumber) } } : { error: ye };
    } catch (ae) {
      return { error: ae };
    }
  } };
}
function i$4(ne) {
  return ne && typeof ne.blockNumber == "string" && Array.isArray(ne.logs);
}
var n$1 = ["uint8", "uint16", "uint24", "uint32", "uint40", "uint48", "uint56", "uint64", "uint72", "uint80", "uint88", "uint96", "uint104", "uint112", "uint120", "uint128", "uint136", "uint144", "uint152", "uint160", "uint168", "uint176", "uint184", "uint192", "uint200", "uint208", "uint216", "uint224", "uint232", "uint240", "uint248", "uint256", "int8", "int16", "int24", "int32", "int40", "int48", "int56", "int64", "int72", "int80", "int88", "int96", "int104", "int112", "int120", "int128", "int136", "int144", "int152", "int160", "int168", "int176", "int184", "int192", "int200", "int208", "int216", "int224", "int232", "int240", "int248", "int256", "bytes1", "bytes2", "bytes3", "bytes4", "bytes5", "bytes6", "bytes7", "bytes8", "bytes9", "bytes10", "bytes11", "bytes12", "bytes13", "bytes14", "bytes15", "bytes16", "bytes17", "bytes18", "bytes19", "bytes20", "bytes21", "bytes22", "bytes23", "bytes24", "bytes25", "bytes26", "bytes27", "bytes28", "bytes29", "bytes30", "bytes31", "bytes32", "bool", "address", "uint8[]", "uint16[]", "uint24[]", "uint32[]", "uint40[]", "uint48[]", "uint56[]", "uint64[]", "uint72[]", "uint80[]", "uint88[]", "uint96[]", "uint104[]", "uint112[]", "uint120[]", "uint128[]", "uint136[]", "uint144[]", "uint152[]", "uint160[]", "uint168[]", "uint176[]", "uint184[]", "uint192[]", "uint200[]", "uint208[]", "uint216[]", "uint224[]", "uint232[]", "uint240[]", "uint248[]", "uint256[]", "int8[]", "int16[]", "int24[]", "int32[]", "int40[]", "int48[]", "int56[]", "int64[]", "int72[]", "int80[]", "int88[]", "int96[]", "int104[]", "int112[]", "int120[]", "int128[]", "int136[]", "int144[]", "int152[]", "int160[]", "int168[]", "int176[]", "int184[]", "int192[]", "int200[]", "int208[]", "int216[]", "int224[]", "int232[]", "int240[]", "int248[]", "int256[]", "bytes1[]", "bytes2[]", "bytes3[]", "bytes4[]", "bytes5[]", "bytes6[]", "bytes7[]", "bytes8[]", "bytes9[]", "bytes10[]", "bytes11[]", "bytes12[]", "bytes13[]", "bytes14[]", "bytes15[]", "bytes16[]", "bytes17[]", "bytes18[]", "bytes19[]", "bytes20[]", "bytes21[]", "bytes22[]", "bytes23[]", "bytes24[]", "bytes25[]", "bytes26[]", "bytes27[]", "bytes28[]", "bytes29[]", "bytes30[]", "bytes31[]", "bytes32[]", "bool[]", "address[]", "bytes", "string"], a$4 = n$1.slice(0, 98), s$2 = n$1.slice(98);
function o$5(ne) {
  return n$1.includes(ne);
}
var b$6 = { uint8: 0, uint16: 0, uint24: 0, uint32: 0, uint40: 0, uint48: 0, uint56: 0n, uint64: 0n, uint72: 0n, uint80: 0n, uint88: 0n, uint96: 0n, uint104: 0n, uint112: 0n, uint120: 0n, uint128: 0n, uint136: 0n, uint144: 0n, uint152: 0n, uint160: 0n, uint168: 0n, uint176: 0n, uint184: 0n, uint192: 0n, uint200: 0n, uint208: 0n, uint216: 0n, uint224: 0n, uint232: 0n, uint240: 0n, uint248: 0n, uint256: 0n, int8: 0, int16: 0, int24: 0, int32: 0, int40: 0, int48: 0, int56: 0n, int64: 0n, int72: 0n, int80: 0n, int88: 0n, int96: 0n, int104: 0n, int112: 0n, int120: 0n, int128: 0n, int136: 0n, int144: 0n, int152: 0n, int160: 0n, int168: 0n, int176: 0n, int184: 0n, int192: 0n, int200: 0n, int208: 0n, int216: 0n, int224: 0n, int232: 0n, int240: 0n, int248: 0n, int256: 0n, bytes1: "0x00", bytes2: "0x0000", bytes3: "0x000000", bytes4: "0x00000000", bytes5: "0x0000000000", bytes6: "0x000000000000", bytes7: "0x00000000000000", bytes8: "0x0000000000000000", bytes9: "0x000000000000000000", bytes10: "0x00000000000000000000", bytes11: "0x0000000000000000000000", bytes12: "0x000000000000000000000000", bytes13: "0x00000000000000000000000000", bytes14: "0x0000000000000000000000000000", bytes15: "0x000000000000000000000000000000", bytes16: "0x00000000000000000000000000000000", bytes17: "0x0000000000000000000000000000000000", bytes18: "0x000000000000000000000000000000000000", bytes19: "0x00000000000000000000000000000000000000", bytes20: "0x0000000000000000000000000000000000000000", bytes21: "0x000000000000000000000000000000000000000000", bytes22: "0x00000000000000000000000000000000000000000000", bytes23: "0x0000000000000000000000000000000000000000000000", bytes24: "0x000000000000000000000000000000000000000000000000", bytes25: "0x00000000000000000000000000000000000000000000000000", bytes26: "0x0000000000000000000000000000000000000000000000000000", bytes27: "0x000000000000000000000000000000000000000000000000000000", bytes28: "0x00000000000000000000000000000000000000000000000000000000", bytes29: "0x0000000000000000000000000000000000000000000000000000000000", bytes30: "0x000000000000000000000000000000000000000000000000000000000000", bytes31: "0x00000000000000000000000000000000000000000000000000000000000000", bytes32: "0x0000000000000000000000000000000000000000000000000000000000000000", bool: !1, address: "0x0000000000000000000000000000000000000000" }, T$7 = { uint8: 1, uint16: 2, uint24: 3, uint32: 4, uint40: 5, uint48: 6, uint56: 7, uint64: 8, uint72: 9, uint80: 10, uint88: 11, uint96: 12, uint104: 13, uint112: 14, uint120: 15, uint128: 16, uint136: 17, uint144: 18, uint152: 19, uint160: 20, uint168: 21, uint176: 22, uint184: 23, uint192: 24, uint200: 25, uint208: 26, uint216: 27, uint224: 28, uint232: 29, uint240: 30, uint248: 31, uint256: 32, int8: 1, int16: 2, int24: 3, int32: 4, int40: 5, int48: 6, int56: 7, int64: 8, int72: 9, int80: 10, int88: 11, int96: 12, int104: 13, int112: 14, int120: 15, int128: 16, int136: 17, int144: 18, int152: 19, int160: 20, int168: 21, int176: 22, int184: 23, int192: 24, int200: 25, int208: 26, int216: 27, int224: 28, int232: 29, int240: 30, int248: 31, int256: 32, bytes1: 1, bytes2: 2, bytes3: 3, bytes4: 4, bytes5: 5, bytes6: 6, bytes7: 7, bytes8: 8, bytes9: 9, bytes10: 10, bytes11: 11, bytes12: 12, bytes13: 13, bytes14: 14, bytes15: 15, bytes16: 16, bytes17: 17, bytes18: 18, bytes19: 19, bytes20: 20, bytes21: 21, bytes22: 22, bytes23: 23, bytes24: 24, bytes25: 25, bytes26: 26, bytes27: 27, bytes28: 28, bytes29: 29, bytes30: 30, bytes31: 31, bytes32: 32, bool: 1, address: 20 };
function e$3(ne) {
  return a$4.includes(ne);
}
var y$6 = /\[\]$/, i$3 = /\[\d+\]$/;
function c$4(ne) {
  return typeof ne == "string" && y$6.test(ne) && e$3(ne.replace(y$6, ""));
}
function A$4(ne) {
  return typeof ne == "string" && i$3.test(ne) && e$3(ne.replace(i$3, ""));
}
function m$5(ne) {
  return ne.replace(y$6, "");
}
function f$4(ne) {
  return ne.replace(i$3, "[]");
}
var r$5 = { "uint8[]": [], "uint16[]": [], "uint24[]": [], "uint32[]": [], "uint40[]": [], "uint48[]": [], "uint56[]": [], "uint64[]": [], "uint72[]": [], "uint80[]": [], "uint88[]": [], "uint96[]": [], "uint104[]": [], "uint112[]": [], "uint120[]": [], "uint128[]": [], "uint136[]": [], "uint144[]": [], "uint152[]": [], "uint160[]": [], "uint168[]": [], "uint176[]": [], "uint184[]": [], "uint192[]": [], "uint200[]": [], "uint208[]": [], "uint216[]": [], "uint224[]": [], "uint232[]": [], "uint240[]": [], "uint248[]": [], "uint256[]": [], "int8[]": [], "int16[]": [], "int24[]": [], "int32[]": [], "int40[]": [], "int48[]": [], "int56[]": [], "int64[]": [], "int72[]": [], "int80[]": [], "int88[]": [], "int96[]": [], "int104[]": [], "int112[]": [], "int120[]": [], "int128[]": [], "int136[]": [], "int144[]": [], "int152[]": [], "int160[]": [], "int168[]": [], "int176[]": [], "int184[]": [], "int192[]": [], "int200[]": [], "int208[]": [], "int216[]": [], "int224[]": [], "int232[]": [], "int240[]": [], "int248[]": [], "int256[]": [], "bytes1[]": [], "bytes2[]": [], "bytes3[]": [], "bytes4[]": [], "bytes5[]": [], "bytes6[]": [], "bytes7[]": [], "bytes8[]": [], "bytes9[]": [], "bytes10[]": [], "bytes11[]": [], "bytes12[]": [], "bytes13[]": [], "bytes14[]": [], "bytes15[]": [], "bytes16[]": [], "bytes17[]": [], "bytes18[]": [], "bytes19[]": [], "bytes20[]": [], "bytes21[]": [], "bytes22[]": [], "bytes23[]": [], "bytes24[]": [], "bytes25[]": [], "bytes26[]": [], "bytes27[]": [], "bytes28[]": [], "bytes29[]": [], "bytes30[]": [], "bytes31[]": [], "bytes32[]": [], "bool[]": [], "address[]": [], bytes: "0x", string: "" };
function v$4(ne) {
  return s$2.includes(ne);
}
function u$3(ne, oe) {
  throw new Error(oe ?? `Unexpected value: ${ne}`);
}
function a$3(...ne) {
  return ne.reduce((oe, ae) => ae > oe ? ae : oe);
}
function l$3(...ne) {
  return ne.reduce((oe, ae) => ae < oe ? ae : oe);
}
function s$1(ne, oe) {
  return ne < oe ? -1 : ne > oe ? 1 : 0;
}
function* m$4(ne, oe) {
  for (let ae = 0; ae < ne.length; ae += oe)
    yield ne.slice(ae, ae + oe);
}
function y$5(ne, oe) {
  let ae = /* @__PURE__ */ new Map();
  for (let fe of ne) {
    let ye = oe(fe);
    ae.has(ye) || ae.set(ye, []), ae.get(ye).push(fe);
  }
  return ae;
}
function b$5(ne) {
  return ne !== void 0;
}
function P$6(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, oe(fe, ae)]));
}
function B$2(ne) {
  return new Promise((oe) => setTimeout(() => oe(), ne));
}
function N$5() {
  return new Promise((ne) => {
    typeof requestIdleCallback < "u" ? requestIdleCallback(() => ne()) : setTimeout(() => ne(), 1);
  });
}
var r$4 = class extends Error {
  constructor() {
    super(...arguments);
    Tl(this, "name", "MUDError");
  }
}, browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var ne = 1e3, oe = ne * 60, ae = oe * 60, fe = ae * 24, ye = fe * 7, ge = fe * 365.25;
  ms = function($e, Ne) {
    Ne = Ne || {};
    var Me = typeof $e;
    if (Me === "string" && $e.length > 0)
      return we($e);
    if (Me === "number" && isFinite($e))
      return Ne.long ? Se($e) : _e($e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify($e)
    );
  };
  function we($e) {
    if ($e = String($e), !($e.length > 100)) {
      var Ne = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        $e
      );
      if (Ne) {
        var Me = parseFloat(Ne[1]), Be = (Ne[2] || "ms").toLowerCase();
        switch (Be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return Me * ge;
          case "weeks":
          case "week":
          case "w":
            return Me * ye;
          case "days":
          case "day":
          case "d":
            return Me * fe;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return Me * ae;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return Me * oe;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return Me * ne;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return Me;
          default:
            return;
        }
      }
    }
  }
  function _e($e) {
    var Ne = Math.abs($e);
    return Ne >= fe ? Math.round($e / fe) + "d" : Ne >= ae ? Math.round($e / ae) + "h" : Ne >= oe ? Math.round($e / oe) + "m" : Ne >= ne ? Math.round($e / ne) + "s" : $e + "ms";
  }
  function Se($e) {
    var Ne = Math.abs($e);
    return Ne >= fe ? Ie($e, Ne, fe, "day") : Ne >= ae ? Ie($e, Ne, ae, "hour") : Ne >= oe ? Ie($e, Ne, oe, "minute") : Ne >= ne ? Ie($e, Ne, ne, "second") : $e + " ms";
  }
  function Ie($e, Ne, Me, Be) {
    var ze = Ne >= Me * 1.5;
    return Math.round($e / Me) + " " + Be + (ze ? "s" : "");
  }
  return ms;
}
function setup$1(ne) {
  ae.debug = ae, ae.default = ae, ae.coerce = Se, ae.disable = ge, ae.enable = ye, ae.enabled = we, ae.humanize = requireMs(), ae.destroy = Ie, Object.keys(ne).forEach(($e) => {
    ae[$e] = ne[$e];
  }), ae.names = [], ae.skips = [], ae.formatters = {};
  function oe($e) {
    let Ne = 0;
    for (let Me = 0; Me < $e.length; Me++)
      Ne = (Ne << 5) - Ne + $e.charCodeAt(Me), Ne |= 0;
    return ae.colors[Math.abs(Ne) % ae.colors.length];
  }
  ae.selectColor = oe;
  function ae($e) {
    let Ne, Me = null, Be, ze;
    function He(...Ze) {
      if (!He.enabled)
        return;
      const qe = He, tt = Number(/* @__PURE__ */ new Date()), Xe = tt - (Ne || tt);
      qe.diff = Xe, qe.prev = Ne, qe.curr = tt, Ne = tt, Ze[0] = ae.coerce(Ze[0]), typeof Ze[0] != "string" && Ze.unshift("%O");
      let ot = 0;
      Ze[0] = Ze[0].replace(/%([a-zA-Z%])/g, (ht, wt) => {
        if (ht === "%%")
          return "%";
        ot++;
        const gt = ae.formatters[wt];
        if (typeof gt == "function") {
          const It = Ze[ot];
          ht = gt.call(qe, It), Ze.splice(ot, 1), ot--;
        }
        return ht;
      }), ae.formatArgs.call(qe, Ze), (qe.log || ae.log).apply(qe, Ze);
    }
    return He.namespace = $e, He.useColors = ae.useColors(), He.color = ae.selectColor($e), He.extend = fe, He.destroy = ae.destroy, Object.defineProperty(He, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => Me !== null ? Me : (Be !== ae.namespaces && (Be = ae.namespaces, ze = ae.enabled($e)), ze),
      set: (Ze) => {
        Me = Ze;
      }
    }), typeof ae.init == "function" && ae.init(He), He;
  }
  function fe($e, Ne) {
    const Me = ae(this.namespace + (typeof Ne > "u" ? ":" : Ne) + $e);
    return Me.log = this.log, Me;
  }
  function ye($e) {
    ae.save($e), ae.namespaces = $e, ae.names = [], ae.skips = [];
    let Ne;
    const Me = (typeof $e == "string" ? $e : "").split(/[\s,]+/), Be = Me.length;
    for (Ne = 0; Ne < Be; Ne++)
      Me[Ne] && ($e = Me[Ne].replace(/\*/g, ".*?"), $e[0] === "-" ? ae.skips.push(new RegExp("^" + $e.slice(1) + "$")) : ae.names.push(new RegExp("^" + $e + "$")));
  }
  function ge() {
    const $e = [
      ...ae.names.map(_e),
      ...ae.skips.map(_e).map((Ne) => "-" + Ne)
    ].join(",");
    return ae.enable(""), $e;
  }
  function we($e) {
    if ($e[$e.length - 1] === "*")
      return !0;
    let Ne, Me;
    for (Ne = 0, Me = ae.skips.length; Ne < Me; Ne++)
      if (ae.skips[Ne].test($e))
        return !1;
    for (Ne = 0, Me = ae.names.length; Ne < Me; Ne++)
      if (ae.names[Ne].test($e))
        return !0;
    return !1;
  }
  function _e($e) {
    return $e.toString().substring(2, $e.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function Se($e) {
    return $e instanceof Error ? $e.stack || $e.message : $e;
  }
  function Ie() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ae.enable(ae.load()), ae;
}
var common = setup$1;
(function(ne, oe) {
  oe.formatArgs = fe, oe.save = ye, oe.load = ge, oe.useColors = ae, oe.storage = we(), oe.destroy = (() => {
    let Se = !1;
    return () => {
      Se || (Se = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), oe.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ae() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let Se;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (Se = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Se[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fe(Se) {
    if (Se[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Se[0] + (this.useColors ? "%c " : " ") + "+" + ne.exports.humanize(this.diff), !this.useColors)
      return;
    const Ie = "color: " + this.color;
    Se.splice(1, 0, Ie, "color: inherit");
    let $e = 0, Ne = 0;
    Se[0].replace(/%[a-zA-Z%]/g, (Me) => {
      Me !== "%%" && ($e++, Me === "%c" && (Ne = $e));
    }), Se.splice(Ne, 0, Ie);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ye(Se) {
    try {
      Se ? oe.storage.setItem("debug", Se) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function ge() {
    let Se;
    try {
      Se = oe.storage.getItem("debug");
    } catch {
    }
    return !Se && typeof process < "u" && "env" in process && (Se = process.env.DEBUG), Se;
  }
  function we() {
    try {
      return localStorage;
    } catch {
    }
  }
  ne.exports = common(oe);
  const { formatters: _e } = ne.exports;
  _e.j = function(Se) {
    try {
      return JSON.stringify(Se);
    } catch (Ie) {
      return "[UnexpectedJSONParseError]: " + Ie.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const z$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var e$2 = z$1("mud:common"), r$3 = z$1("mud:common");
e$2.log = console.debug.bind(console);
r$3.log = console.error.bind(console);
var eventemitter3 = { exports: {} };
(function(ne) {
  var oe = Object.prototype.hasOwnProperty, ae = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (ae = !1));
  function ye(Se, Ie, $e) {
    this.fn = Se, this.context = Ie, this.once = $e || !1;
  }
  function ge(Se, Ie, $e, Ne, Me) {
    if (typeof $e != "function")
      throw new TypeError("The listener must be a function");
    var Be = new ye($e, Ne || Se, Me), ze = ae ? ae + Ie : Ie;
    return Se._events[ze] ? Se._events[ze].fn ? Se._events[ze] = [Se._events[ze], Be] : Se._events[ze].push(Be) : (Se._events[ze] = Be, Se._eventsCount++), Se;
  }
  function we(Se, Ie) {
    --Se._eventsCount === 0 ? Se._events = new fe() : delete Se._events[Ie];
  }
  function _e() {
    this._events = new fe(), this._eventsCount = 0;
  }
  _e.prototype.eventNames = function() {
    var Ie = [], $e, Ne;
    if (this._eventsCount === 0)
      return Ie;
    for (Ne in $e = this._events)
      oe.call($e, Ne) && Ie.push(ae ? Ne.slice(1) : Ne);
    return Object.getOwnPropertySymbols ? Ie.concat(Object.getOwnPropertySymbols($e)) : Ie;
  }, _e.prototype.listeners = function(Ie) {
    var $e = ae ? ae + Ie : Ie, Ne = this._events[$e];
    if (!Ne)
      return [];
    if (Ne.fn)
      return [Ne.fn];
    for (var Me = 0, Be = Ne.length, ze = new Array(Be); Me < Be; Me++)
      ze[Me] = Ne[Me].fn;
    return ze;
  }, _e.prototype.listenerCount = function(Ie) {
    var $e = ae ? ae + Ie : Ie, Ne = this._events[$e];
    return Ne ? Ne.fn ? 1 : Ne.length : 0;
  }, _e.prototype.emit = function(Ie, $e, Ne, Me, Be, ze) {
    var He = ae ? ae + Ie : Ie;
    if (!this._events[He])
      return !1;
    var Ze = this._events[He], qe = arguments.length, tt, Xe;
    if (Ze.fn) {
      switch (Ze.once && this.removeListener(Ie, Ze.fn, void 0, !0), qe) {
        case 1:
          return Ze.fn.call(Ze.context), !0;
        case 2:
          return Ze.fn.call(Ze.context, $e), !0;
        case 3:
          return Ze.fn.call(Ze.context, $e, Ne), !0;
        case 4:
          return Ze.fn.call(Ze.context, $e, Ne, Me), !0;
        case 5:
          return Ze.fn.call(Ze.context, $e, Ne, Me, Be), !0;
        case 6:
          return Ze.fn.call(Ze.context, $e, Ne, Me, Be, ze), !0;
      }
      for (Xe = 1, tt = new Array(qe - 1); Xe < qe; Xe++)
        tt[Xe - 1] = arguments[Xe];
      Ze.fn.apply(Ze.context, tt);
    } else {
      var ot = Ze.length, pt;
      for (Xe = 0; Xe < ot; Xe++)
        switch (Ze[Xe].once && this.removeListener(Ie, Ze[Xe].fn, void 0, !0), qe) {
          case 1:
            Ze[Xe].fn.call(Ze[Xe].context);
            break;
          case 2:
            Ze[Xe].fn.call(Ze[Xe].context, $e);
            break;
          case 3:
            Ze[Xe].fn.call(Ze[Xe].context, $e, Ne);
            break;
          case 4:
            Ze[Xe].fn.call(Ze[Xe].context, $e, Ne, Me);
            break;
          default:
            if (!tt)
              for (pt = 1, tt = new Array(qe - 1); pt < qe; pt++)
                tt[pt - 1] = arguments[pt];
            Ze[Xe].fn.apply(Ze[Xe].context, tt);
        }
    }
    return !0;
  }, _e.prototype.on = function(Ie, $e, Ne) {
    return ge(this, Ie, $e, Ne, !1);
  }, _e.prototype.once = function(Ie, $e, Ne) {
    return ge(this, Ie, $e, Ne, !0);
  }, _e.prototype.removeListener = function(Ie, $e, Ne, Me) {
    var Be = ae ? ae + Ie : Ie;
    if (!this._events[Be])
      return this;
    if (!$e)
      return we(this, Be), this;
    var ze = this._events[Be];
    if (ze.fn)
      ze.fn === $e && (!Me || ze.once) && (!Ne || ze.context === Ne) && we(this, Be);
    else {
      for (var He = 0, Ze = [], qe = ze.length; He < qe; He++)
        (ze[He].fn !== $e || Me && !ze[He].once || Ne && ze[He].context !== Ne) && Ze.push(ze[He]);
      Ze.length ? this._events[Be] = Ze.length === 1 ? Ze[0] : Ze : we(this, Be);
    }
    return this;
  }, _e.prototype.removeAllListeners = function(Ie) {
    var $e;
    return Ie ? ($e = ae ? ae + Ie : Ie, this._events[$e] && we(this, $e)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, _e.prototype.off = _e.prototype.removeListener, _e.prototype.addListener = _e.prototype.on, _e.prefixed = ae, _e.EventEmitter = _e, ne.exports = _e;
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError extends Error {
  constructor(oe) {
    super(oe), this.name = "TimeoutError";
  }
}
let AbortError$2 = class extends Error {
  constructor(oe) {
    super(), this.name = "AbortError", this.message = oe;
  }
};
const getDOMException$1 = (ne) => globalThis.DOMException === void 0 ? new AbortError$2(ne) : new DOMException(ne), getAbortedReason = (ne) => {
  const oe = ne.reason === void 0 ? getDOMException$1("This operation was aborted.") : ne.reason;
  return oe instanceof Error ? oe : getDOMException$1(oe);
};
function pTimeout(ne, oe, ae, fe) {
  let ye;
  const ge = new Promise((we, _e) => {
    if (typeof oe != "number" || Math.sign(oe) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${oe}\``);
    if (oe === Number.POSITIVE_INFINITY) {
      we(ne);
      return;
    }
    if (fe = {
      customTimers: { setTimeout, clearTimeout },
      ...fe
    }, fe.signal) {
      const { signal: Se } = fe;
      Se.aborted && _e(getAbortedReason(Se)), Se.addEventListener("abort", () => {
        _e(getAbortedReason(Se));
      });
    }
    ye = fe.customTimers.setTimeout.call(void 0, () => {
      if (typeof ae == "function") {
        try {
          we(ae());
        } catch ($e) {
          _e($e);
        }
        return;
      }
      const Se = typeof ae == "string" ? ae : `Promise timed out after ${oe} milliseconds`, Ie = ae instanceof Error ? ae : new TimeoutError(Se);
      typeof ne.cancel == "function" && ne.cancel(), _e(Ie);
    }, oe), (async () => {
      try {
        we(await ne);
      } catch (Se) {
        _e(Se);
      } finally {
        fe.customTimers.clearTimeout.call(void 0, ye);
      }
    })();
  });
  return ge.clear = () => {
    clearTimeout(ye), ye = void 0;
  }, ge;
}
function lowerBound(ne, oe, ae) {
  let fe = 0, ye = ne.length;
  for (; ye > 0; ) {
    const ge = Math.trunc(ye / 2);
    let we = fe + ge;
    ae(ne[we], oe) <= 0 ? (fe = ++we, ye -= ge + 1) : ye = ge;
  }
  return fe;
}
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(oe, ae) {
    ae = {
      priority: 0,
      ...ae
    };
    const fe = {
      priority: ae.priority,
      run: oe
    };
    if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= ae.priority) {
      __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(fe);
      return;
    }
    const ye = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), fe, (ge, we) => we.priority - ge.priority);
    __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(ye, 0, fe);
  }
  dequeue() {
    const oe = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
    return oe == null ? void 0 : oe.run;
  }
  filter(oe) {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((ae) => ae.priority === oe.priority).map((ae) => ae.run);
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(ne, oe, ae, fe, ye) {
  if (fe === "m")
    throw new TypeError("Private method is not writable");
  if (fe === "a" && !ye)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof oe == "function" ? ne !== oe || !ye : !oe.has(ne))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return fe === "a" ? ye.call(ne, ae) : ye ? ye.value = ae : oe.set(ne, ae), ae;
}, __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(ne, oe, ae, fe) {
  if (ae === "a" && !fe)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof oe == "function" ? ne !== oe || !fe : !oe.has(ne))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ae === "m" ? fe : ae === "a" ? fe.call(ne) : fe ? fe.value : oe.get(ne);
}, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;
let AbortError$1 = class extends Error {
};
class PQueue extends EventEmitter {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(oe) {
    var ae, fe, ye, ge;
    if (super(), _PQueue_instances.add(this), _PQueue_carryoverConcurrencyCount.set(this, void 0), _PQueue_isIntervalIgnored.set(this, void 0), _PQueue_intervalCount.set(this, 0), _PQueue_intervalCap.set(this, void 0), _PQueue_interval.set(this, void 0), _PQueue_intervalEnd.set(this, 0), _PQueue_intervalId.set(this, void 0), _PQueue_timeoutId.set(this, void 0), _PQueue_queue.set(this, void 0), _PQueue_queueClass.set(this, void 0), _PQueue_pending.set(this, 0), _PQueue_concurrency.set(this, void 0), _PQueue_isPaused.set(this, void 0), _PQueue_throwOnTimeout.set(this, void 0), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), oe = {
      carryoverConcurrencyCount: !1,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: !0,
      queueClass: PriorityQueue,
      ...oe
    }, !(typeof oe.intervalCap == "number" && oe.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(fe = (ae = oe.intervalCap) === null || ae === void 0 ? void 0 : ae.toString()) !== null && fe !== void 0 ? fe : ""}\` (${typeof oe.intervalCap})`);
    if (oe.interval === void 0 || !(Number.isFinite(oe.interval) && oe.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(ge = (ye = oe.interval) === null || ye === void 0 ? void 0 : ye.toString()) !== null && ge !== void 0 ? ge : ""}\` (${typeof oe.interval})`);
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, oe.carryoverConcurrencyCount, "f"), __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, oe.intervalCap === Number.POSITIVE_INFINITY || oe.interval === 0, "f"), __classPrivateFieldSet(this, _PQueue_intervalCap, oe.intervalCap, "f"), __classPrivateFieldSet(this, _PQueue_interval, oe.interval, "f"), __classPrivateFieldSet(this, _PQueue_queue, new oe.queueClass(), "f"), __classPrivateFieldSet(this, _PQueue_queueClass, oe.queueClass, "f"), this.concurrency = oe.concurrency, this.timeout = oe.timeout, __classPrivateFieldSet(this, _PQueue_throwOnTimeout, oe.throwOnTimeout === !0, "f"), __classPrivateFieldSet(this, _PQueue_isPaused, oe.autoStart === !1, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet(this, _PQueue_concurrency, "f");
  }
  set concurrency(oe) {
    if (!(typeof oe == "number" && oe >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${oe}\` (${typeof oe})`);
    __classPrivateFieldSet(this, _PQueue_concurrency, oe, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(oe, ae = {}) {
    return ae = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f"),
      ...ae
    }, new Promise((fe, ye) => {
      __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(async () => {
        var ge, we, _e;
        __classPrivateFieldSet(this, _PQueue_pending, (we = __classPrivateFieldGet(this, _PQueue_pending, "f"), we++, we), "f"), __classPrivateFieldSet(this, _PQueue_intervalCount, (_e = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"), _e++, _e), "f");
        try {
          if (!((ge = ae.signal) === null || ge === void 0) && ge.aborted)
            throw new AbortError$1("The task was aborted.");
          let Se = oe({ signal: ae.signal });
          ae.timeout && (Se = pTimeout(Promise.resolve(Se), ae.timeout)), ae.signal && (Se = Promise.race([Se, __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, ae.signal)]));
          const Ie = await Se;
          fe(Ie), this.emit("completed", Ie);
        } catch (Se) {
          if (Se instanceof TimeoutError && !ae.throwOnTimeout) {
            fe();
            return;
          }
          ye(Se), this.emit("error", Se);
        } finally {
          __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, ae), this.emit("add"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(oe, ae) {
    return Promise.all(oe.map(async (fe) => this.add(fe, ae)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet(this, _PQueue_isPaused, !1, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, !0, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(oe) {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet(this, _PQueue_queue, "f").size < oe);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(oe) {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(oe).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function ne() {
  return __classPrivateFieldGet(this, _PQueue_pending, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f");
}, _PQueue_next = function ne() {
  var oe;
  __classPrivateFieldSet(this, _PQueue_pending, (oe = __classPrivateFieldGet(this, _PQueue_pending, "f"), oe--, oe), "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("next");
}, _PQueue_onResumeInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function ne() {
  const oe = Date.now();
  if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
    const ae = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - oe;
    if (ae < 0)
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f");
    else
      return __classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
      }, ae), "f"), !0;
  }
  return !1;
}, _PQueue_tryToStartAnother = function ne() {
  if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0)
    return __classPrivateFieldGet(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f"), this.emit("empty"), __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && this.emit("idle"), !1;
  if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
    const oe = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const ae = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
      return ae ? (this.emit("active"), ae(), oe && __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), !0) : !1;
    }
  }
  return !1;
}, _PQueue_initializeIntervalIfNeeded = function ne() {
  __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet(this, _PQueue_interval, "f")), "f"), __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f"));
}, _PQueue_onInterval = function ne() {
  __classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f")), __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function ne() {
  for (; __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
    ;
}, _PQueue_throwOnAbort = async function ne(oe) {
  return new Promise((ae, fe) => {
    oe.addEventListener("abort", () => {
      fe(new AbortError$1("The task was aborted."));
    }, { once: !0 });
  });
}, _PQueue_onEvent = async function ne(oe, ae) {
  return new Promise((fe) => {
    const ye = () => {
      ae && !ae() || (this.off(oe, ye), fe());
    };
    this.on(oe, ye);
  });
};
var retry$2 = {};
function RetryOperation(ne, oe) {
  typeof oe == "boolean" && (oe = { forever: oe }), this._originalTimeouts = JSON.parse(JSON.stringify(ne)), this._timeouts = ne, this._options = oe || {}, this._maxRetryTime = oe && oe.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(ne) {
  if (this._timeout && clearTimeout(this._timeout), !ne)
    return !1;
  var oe = (/* @__PURE__ */ new Date()).getTime();
  if (ne && oe - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ne), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ne);
  var ae = this._timeouts.shift();
  if (ae === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), ae = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, ae), this._options.unref && this._timer.unref(), !0;
};
RetryOperation.prototype.attempt = function(ne, oe) {
  this._fn = ne, oe && (oe.timeout && (this._operationTimeout = oe.timeout), oe.cb && (this._operationTimeoutCb = oe.cb));
  var ae = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    ae._operationTimeoutCb();
  }, ae._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation.prototype.try = function(ne) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = function(ne) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ne);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ne = {}, oe = null, ae = 0, fe = 0; fe < this._errors.length; fe++) {
    var ye = this._errors[fe], ge = ye.message, we = (ne[ge] || 0) + 1;
    ne[ge] = we, we >= ae && (oe = ye, ae = we);
  }
  return oe;
};
(function(ne) {
  var oe = retry_operation;
  ne.operation = function(ae) {
    var fe = ne.timeouts(ae);
    return new oe(fe, {
      forever: ae && (ae.forever || ae.retries === 1 / 0),
      unref: ae && ae.unref,
      maxRetryTime: ae && ae.maxRetryTime
    });
  }, ne.timeouts = function(ae) {
    if (ae instanceof Array)
      return [].concat(ae);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ye in ae)
      fe[ye] = ae[ye];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var ge = [], we = 0; we < fe.retries; we++)
      ge.push(this.createTimeout(we, fe));
    return ae && ae.forever && !ge.length && ge.push(this.createTimeout(we, fe)), ge.sort(function(_e, Se) {
      return _e - Se;
    }), ge;
  }, ne.createTimeout = function(ae, fe) {
    var ye = fe.randomize ? Math.random() + 1 : 1, ge = Math.round(ye * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, ae));
    return ge = Math.min(ge, fe.maxTimeout), ge;
  }, ne.wrap = function(ae, fe, ye) {
    if (fe instanceof Array && (ye = fe, fe = null), !ye) {
      ye = [];
      for (var ge in ae)
        typeof ae[ge] == "function" && ye.push(ge);
    }
    for (var we = 0; we < ye.length; we++) {
      var _e = ye[we], Se = ae[_e];
      ae[_e] = (function($e) {
        var Ne = ne.operation(fe), Me = Array.prototype.slice.call(arguments, 1), Be = Me.pop();
        Me.push(function(ze) {
          Ne.retry(ze) || (ze && (arguments[0] = Ne.mainError()), Be.apply(this, arguments));
        }), Ne.attempt(function() {
          $e.apply(ae, Me);
        });
      }).bind(ae, Se), ae[_e].options = fe;
    }
  };
})(retry$2);
var retry = retry$2;
const retry$1 = /* @__PURE__ */ getDefaultExportFromCjs(retry), networkErrorMsgs = /* @__PURE__ */ new Set([
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed",
  // `cross-fetch`
  "fetch failed"
  // Undici (Node.js)
]);
class AbortError extends Error {
  constructor(oe) {
    super(), oe instanceof Error ? (this.originalError = oe, { message: oe } = oe) : (this.originalError = new Error(oe), this.originalError.stack = this.stack), this.name = "AbortError", this.message = oe;
  }
}
const decorateErrorWithCounts = (ne, oe, ae) => {
  const fe = ae.retries - (oe - 1);
  return ne.attemptNumber = oe, ne.retriesLeft = fe, ne;
}, isNetworkError = (ne) => networkErrorMsgs.has(ne), getDOMException = (ne) => globalThis.DOMException === void 0 ? new Error(ne) : new DOMException(ne);
async function pRetry(ne, oe) {
  return new Promise((ae, fe) => {
    oe = {
      onFailedAttempt() {
      },
      retries: 10,
      ...oe
    };
    const ye = retry$1.operation(oe);
    ye.attempt(async (ge) => {
      try {
        ae(await ne(ge));
      } catch (we) {
        if (!(we instanceof Error)) {
          fe(new TypeError(`Non-error was thrown: "${we}". You should only throw errors.`));
          return;
        }
        if (we instanceof AbortError)
          ye.stop(), fe(we.originalError);
        else if (we instanceof TypeError && !isNetworkError(we.message))
          ye.stop(), fe(we);
        else {
          decorateErrorWithCounts(we, ge, oe);
          try {
            await oe.onFailedAttempt(we);
          } catch (_e) {
            fe(_e);
            return;
          }
          ye.retry(we) || fe(ye.mainError());
        }
      }
    }), oe.signal && !oe.signal.aborted && oe.signal.addEventListener("abort", () => {
      ye.stop();
      const ge = oe.signal.reason === void 0 ? getDOMException("The operation was aborted.") : oe.signal.reason;
      fe(ge instanceof Error ? ge : getDOMException(ge));
    }, {
      once: !0
    });
  });
}
function toAccount(ne) {
  if (typeof ne == "string") {
    if (!isAddress(ne, { strict: !1 }))
      throw new InvalidAddressError({ address: ne });
    return {
      address: ne,
      type: "json-rpc"
    };
  }
  if (!isAddress(ne.address, { strict: !1 }))
    throw new InvalidAddressError({ address: ne.address });
  return {
    address: ne.address,
    signMessage: ne.signMessage,
    signTransaction: ne.signTransaction,
    signTypedData: ne.signTypedData,
    source: "custom",
    type: "local"
  };
}
async function sign({ hash: ne, privateKey: oe }) {
  const { r: ae, s: fe, recovery: ye } = secp256k1.sign(ne.slice(2), oe.slice(2));
  return {
    r: toHex(ae),
    s: toHex(fe),
    v: ye ? 28n : 27n,
    yParity: ye
  };
}
async function signMessage({ message: ne, privateKey: oe }) {
  const ae = await sign({ hash: hashMessage(ne), privateKey: oe });
  return signatureToHex(ae);
}
async function signTransaction(ne) {
  const { privateKey: oe, transaction: ae, serializer: fe = serializeTransaction$1 } = ne, ye = (() => ae.type === "eip4844" ? {
    ...ae,
    sidecars: !1
  } : ae)(), ge = await sign({
    hash: keccak256(fe(ye)),
    privateKey: oe
  });
  return fe(ae, ge);
}
async function signTypedData(ne) {
  const { privateKey: oe, ...ae } = ne, fe = await sign({
    hash: hashTypedData(ae),
    privateKey: oe
  });
  return signatureToHex(fe);
}
function privateKeyToAccount(ne) {
  const oe = toHex(secp256k1.getPublicKey(ne.slice(2), !1)), ae = publicKeyToAddress(oe);
  return {
    ...toAccount({
      address: ae,
      async signMessage({ message: ye }) {
        return signMessage({ message: ye, privateKey: ne });
      },
      async signTransaction(ye, { serializer: ge } = {}) {
        return signTransaction({ privateKey: ne, transaction: ye, serializer: ge });
      },
      async signTypedData(ye) {
        return signTypedData({ ...ye, privateKey: ne });
      }
    }),
    publicKey: oe,
    source: "privateKey"
  };
}
async function h$2({ client: ne, address: oe, blockTag: ae }) {
  var fe;
  return `mud:createNonceManager:${((fe = ne.chain) == null ? void 0 : fe.id) ?? await getChainId(ne)}:${getAddress(oe)}:${ae}`;
}
var R = e$2.extend("createNonceManager");
function P$5({ client: ne, address: oe, blockTag: ae = "pending", broadcastChannelName: fe, queueConcurrency: ye = 1 }) {
  let ge = { current: -1 }, we = null;
  typeof BroadcastChannel < "u" && (fe ? Promise.resolve(fe) : h$2({ client: ne, address: oe, blockTag: ae })).then((Be) => {
    we = new BroadcastChannel(Be), we.addEventListener("message", (ze) => {
      let He = JSON.parse(ze.data);
      R("got nonce from broadcast channel", He), ge.current = He;
    });
  });
  function _e() {
    return ge.current >= 0;
  }
  function Se() {
    if (!_e())
      throw new Error("call resetNonce before using getNonce");
    return ge.current;
  }
  function Ie() {
    if (!_e())
      throw new Error("call resetNonce before using nextNonce");
    let Be = ge.current++;
    return we == null || we.postMessage(JSON.stringify(ge.current)), Be;
  }
  async function $e() {
    let Be = await getTransactionCount(ne, { address: oe, blockTag: ae });
    ge.current = Be, we == null || we.postMessage(JSON.stringify(ge.current)), R("reset nonce to", ge.current);
  }
  function Ne(Be) {
    return Be instanceof BaseError && Be.walk((ze) => ze instanceof NonceTooLowError || ze instanceof NonceTooHighError) != null;
  }
  let Me = new PQueue({ concurrency: ye });
  return { hasNonce: _e, getNonce: Se, nextNonce: Ie, resetNonce: $e, shouldResetNonce: Ne, mempoolQueue: Me };
}
var T$6 = /* @__PURE__ */ new Map();
async function C$3({ client: ne, address: oe, blockTag: ae = "pending", ...fe }) {
  let ye = await h$2({ client: ne, address: oe, blockTag: ae }), ge = T$6.get(ye);
  if (ge)
    return ge;
  let we = P$5({ client: ne, address: oe, blockTag: ae, ...fe });
  return T$6.set(ye, we), we;
}
async function F$2({ client: ne, args: oe, refreshInterval: ae }) {
  let fe = { fees: {}, lastUpdatedTimestamp: 0 };
  async function ye() {
    let ge = await estimateFeesPerGas(ne, oe);
    fe.fees = ge, fe.lastUpdatedTimestamp = Date.now();
  }
  return setInterval(ye, ae), await ye(), fe;
}
var M$4 = /* @__PURE__ */ new Map();
async function N$4(ne) {
  var ye, ge, we;
  let oe = ((ge = (ye = ne.args) == null ? void 0 : ye.chain) == null ? void 0 : ge.id) ?? ((we = ne.client.chain) == null ? void 0 : we.id) ?? await getChainId(ne.client), ae = M$4.get(oe);
  if (ae)
    return ae;
  let fe = await F$2(ne);
  return M$4.set(oe, fe), fe;
}
var y$4 = e$2.extend("writeContract");
async function Je(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), ge = ne.chain, we = { chain: ge, ...ge != null && ge.fees ? { type: "eip1559" } : {} }, _e = await C$3({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), Se = await N$4({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: ge } });
  async function Ie() {
    if (oe.gas)
      return y$4("gas provided, skipping preparation", oe.functionName, oe.address), oe;
    let { abi: $e, address: Ne, args: Me, dataSuffix: Be, functionName: ze } = oe, He = encodeFunctionData({ abi: $e, args: Me, functionName: ze }), { nonce: Ze, maxFeePerGas: qe, maxPriorityFeePerGas: tt, ...Xe } = await getAction(ne, prepareTransactionRequest, "prepareTransactionRequest")({ maxFeePerGas: 0n, maxPriorityFeePerGas: 0n, nonce: _e.getNonce(), ...we, ...oe, blockTag: "pending", account: ye, data: `${He}${Be ? Be.replace("0x", "") : ""}`, to: Ne });
    return Xe;
  }
  return _e.mempoolQueue.add(() => pRetry(async () => {
    _e.hasNonce() || await _e.resetNonce();
    let $e = await Ie(), Ne = _e.nextNonce(), Me = { ...$e, nonce: Ne, ...Se.fees };
    return y$4("calling", Me.functionName, "with nonce", Ne, "at", Me.address), await writeContract(ne, Me);
  }, { retries: 3, onFailedAttempt: async ($e) => {
    if (_e.shouldResetNonce($e)) {
      y$4("got nonce error, retrying", $e.message), await _e.resetNonce();
      return;
    }
    throw $e;
  } }), { throwOnTimeout: !0 });
}
var b$4 = e$2.extend("sendTransaction");
async function Ve(ne, oe, ae = {}) {
  let fe = oe.account ?? ne.account;
  if (!fe)
    throw new Error("No account provided");
  let ye = parseAccount(fe), ge = ne.chain, we = await C$3({ client: ae.publicClient ?? ne, address: ye.address, blockTag: "pending", queueConcurrency: ae.queueConcurrency }), _e = await N$4({ client: ae.publicClient ?? ne, refreshInterval: 1e4, args: { chain: ge } });
  async function Se() {
    return oe.gas ? (b$4("gas provided, skipping simulate", oe.to), oe) : (b$4("simulating tx to", oe.to), await call(ae.publicClient ?? ne, { ...oe, blockTag: "pending", account: ye }), oe);
  }
  return await we.mempoolQueue.add(() => pRetry(async () => {
    let Ie = await Se();
    we.hasNonce() || await we.resetNonce();
    let $e = we.nextNonce();
    b$4("sending tx with nonce", $e, "to", Ie.to);
    let Ne = { ...Ie, nonce: $e, ..._e.fees };
    return await sendTransaction(ne, Ne);
  }, { retries: 3, onFailedAttempt: async (Ie) => {
    if (we.shouldResetNonce(Ie)) {
      b$4("got nonce error, retrying", Ie.message), await we.resetNonce();
      return;
    }
    throw Ie;
  } }), { throwOnTimeout: !0 });
}
var m$3 = ["table", "offchainTable", "namespace", "system"], o$4 = { table: "tb", offchainTable: "ot", namespace: "ns", system: "sy" };
function x$1(ne) {
  let oe = o$4[ne.type];
  if (ne.namespace.length > 14)
    throw new Error(`Namespaces must fit into \`bytes14\`, but "${ne.namespace}" is too long.`);
  return concatHex([stringToHex(oe, { size: 2 }), stringToHex(ne.namespace, { size: 14 }), stringToHex(ne.name.slice(0, 16), { size: 16 })]);
}
var y$3 = "";
function i$2({ namespace: ne, name: oe }) {
  return ne === y$3 ? oe : `${ne}__${oe}`;
}
var f$3 = Object.fromEntries(Object.entries(o$4).map(([ne, oe]) => [oe, ne]));
function T$5(ne) {
  let oe = f$3[ne];
  if (m$3.includes(oe))
    return oe;
}
function _$2(ne) {
  let oe = hexToString(sliceHex(ne, 0, 2)).replace(/\0+$/, ""), ae = T$5(oe), fe = hexToString(sliceHex(ne, 2, 16)).replace(/\0+$/, ""), ye = hexToString(sliceHex(ne, 16, 32)).replace(/\0+$/, "");
  if (!ae)
    throw new Error(`Unknown type (${oe}) for resource (${i$2({ namespace: fe, name: ye })})`);
  return { resourceId: ne, type: ae, namespace: fe, name: ye };
}
var T$4 = z$1("mud:benchmark");
T$4.log = console.info.bind(console);
function Q$3(ne) {
  return { ...privateKeyToAccount(ne) };
}
var C$2 = class extends Map {
  constructor(ae) {
    super();
    Tl(this, "maxSize");
    this.maxSize = ae;
  }
  set(ae, fe) {
    return super.set(ae, fe), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
};
function a$2(ne, oe, ae) {
  return `0x${ne.replace(/^0x/, "").slice(oe * 2, ae != null ? ae * 2 : void 0).padEnd(((ae ?? oe) - oe) * 2, "0")}`;
}
function be(ne) {
  return "ok" in ne;
}
function Pe(ne, oe, ae = 0, fe = "0x") {
  return concatHex([a$2(ne, 0, oe), fe, a$2(ne, oe + ae)]);
}
var G$2 = e$2.extend("transportObserver");
function Ee(ne) {
  return (oe) => {
    let ae = ne(oe);
    return { ...ae, request: async (fe) => {
      if (fe.method === "eth_sendRawTransaction" && fe.params instanceof Array) {
        let ye = fe.params.map((ge) => keccak256(ge));
        G$2("saw txs", ye);
      }
      return ae.request(fe);
    } };
  };
}
var u$2 = class extends r$4 {
  constructor(ae) {
    super(`Hex value "${ae}" is an odd length (${ae.length - 2}). It must be an even length.`);
    Tl(this, "name", "InvalidHexValueError");
  }
}, S$1 = class extends r$4 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for a schema.`);
    Tl(this, "name", "InvalidHexLengthForSchemaError");
  }
}, g$4 = class extends r$4 {
  constructor(ae) {
    super(`Hex value "${ae}" has length of ${ae.length - 2}, but expected length of 64 for encoded lengths.`);
    Tl(this, "name", "InvalidHexLengthForEncodedLengthsError");
  }
}, A$3 = class extends r$4 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected length of ${T$7[ae] * 2} for ${ae} type.`);
    Tl(this, "name", "InvalidHexLengthForStaticFieldError");
  }
}, v$3 = class extends r$4 {
  constructor(ae, fe) {
    super(`Hex value "${fe}" has length of ${fe.length - 2}, but expected a multiple of ${T$7[ae] * 2} for ${ae}[] type.`);
    Tl(this, "name", "InvalidHexLengthForArrayFieldError");
  }
}, H$2 = class extends r$4 {
  constructor(ae, fe, ye) {
    super(`Schema "${ae}" static data length (${fe}) did not match the summed length of all static fields (${ye}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`);
    Tl(this, "name", "SchemaStaticLengthMismatchError");
  }
}, F$1 = class extends r$4 {
  constructor(ae, fe, ye) {
    super(`EncodedLengths "${ae}" total bytes length (${fe}) did not match the summed length of all field byte lengths (${ye}).`);
    Tl(this, "name", "EncodedLengthsLengthMismatchError");
  }
};
function y$2(ne, oe) {
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$2(oe);
  if ((oe.length - 2) / 2 !== T$7[ne])
    throw new A$3(ne, oe);
  switch (ne) {
    case "uint8":
    case "uint16":
    case "uint24":
    case "uint32":
    case "uint40":
    case "uint48":
    case "uint56":
    case "uint64":
    case "uint72":
    case "uint80":
    case "uint88":
    case "uint96":
    case "uint104":
    case "uint112":
    case "uint120":
    case "uint128":
    case "uint136":
    case "uint144":
    case "uint152":
    case "uint160":
    case "uint168":
    case "uint176":
    case "uint184":
    case "uint192":
    case "uint200":
    case "uint208":
    case "uint216":
    case "uint224":
    case "uint232":
    case "uint240":
    case "uint248":
    case "uint256":
    case "int8":
    case "int16":
    case "int24":
    case "int32":
    case "int40":
    case "int48":
    case "int56":
    case "int64":
    case "int72":
    case "int80":
    case "int88":
    case "int96":
    case "int104":
    case "int112":
    case "int120":
    case "int128":
    case "int136":
    case "int144":
    case "int152":
    case "int160":
    case "int168":
    case "int176":
    case "int184":
    case "int192":
    case "int200":
    case "int208":
    case "int216":
    case "int224":
    case "int232":
    case "int240":
    case "int248":
    case "int256": {
      let ae = hexToBigInt(oe, { signed: ne.startsWith("int") }), fe = typeof b$6[ne];
      if (fe === "number")
        return Number(ae);
      if (fe === "bigint")
        return ae;
      throw new Error(`Unexpected default value type (${fe}) for ABI type (${ne})`);
    }
    case "bytes1":
    case "bytes2":
    case "bytes3":
    case "bytes4":
    case "bytes5":
    case "bytes6":
    case "bytes7":
    case "bytes8":
    case "bytes9":
    case "bytes10":
    case "bytes11":
    case "bytes12":
    case "bytes13":
    case "bytes14":
    case "bytes15":
    case "bytes16":
    case "bytes17":
    case "bytes18":
    case "bytes19":
    case "bytes20":
    case "bytes21":
    case "bytes22":
    case "bytes23":
    case "bytes24":
    case "bytes25":
    case "bytes26":
    case "bytes27":
    case "bytes28":
    case "bytes29":
    case "bytes30":
    case "bytes31":
    case "bytes32":
      return oe;
    case "bool":
      return hexToBool(oe);
    case "address":
      return getAddress(oe);
  }
  return u$3(ne, `Unsupported static ABI type: ${ne}`);
}
function f$2(ne, oe) {
  if (ne === "bytes")
    return oe;
  if (ne === "string")
    return hexToString(oe);
  if (oe.length > 3 && oe.length % 2 !== 0)
    throw new u$2(oe);
  let ae = (oe.length - 2) / 2;
  switch (ne) {
    case "uint8[]":
    case "uint16[]":
    case "uint24[]":
    case "uint32[]":
    case "uint40[]":
    case "uint48[]":
    case "uint56[]":
    case "uint64[]":
    case "uint72[]":
    case "uint80[]":
    case "uint88[]":
    case "uint96[]":
    case "uint104[]":
    case "uint112[]":
    case "uint120[]":
    case "uint128[]":
    case "uint136[]":
    case "uint144[]":
    case "uint152[]":
    case "uint160[]":
    case "uint168[]":
    case "uint176[]":
    case "uint184[]":
    case "uint192[]":
    case "uint200[]":
    case "uint208[]":
    case "uint216[]":
    case "uint224[]":
    case "uint232[]":
    case "uint240[]":
    case "uint248[]":
    case "uint256[]":
    case "int8[]":
    case "int16[]":
    case "int24[]":
    case "int32[]":
    case "int40[]":
    case "int48[]":
    case "int56[]":
    case "int64[]":
    case "int72[]":
    case "int80[]":
    case "int88[]":
    case "int96[]":
    case "int104[]":
    case "int112[]":
    case "int120[]":
    case "int128[]":
    case "int136[]":
    case "int144[]":
    case "int152[]":
    case "int160[]":
    case "int168[]":
    case "int176[]":
    case "int184[]":
    case "int192[]":
    case "int200[]":
    case "int208[]":
    case "int216[]":
    case "int224[]":
    case "int232[]":
    case "int240[]":
    case "int248[]":
    case "int256[]":
    case "bytes1[]":
    case "bytes2[]":
    case "bytes3[]":
    case "bytes4[]":
    case "bytes5[]":
    case "bytes6[]":
    case "bytes7[]":
    case "bytes8[]":
    case "bytes9[]":
    case "bytes10[]":
    case "bytes11[]":
    case "bytes12[]":
    case "bytes13[]":
    case "bytes14[]":
    case "bytes15[]":
    case "bytes16[]":
    case "bytes17[]":
    case "bytes18[]":
    case "bytes19[]":
    case "bytes20[]":
    case "bytes21[]":
    case "bytes22[]":
    case "bytes23[]":
    case "bytes24[]":
    case "bytes25[]":
    case "bytes26[]":
    case "bytes27[]":
    case "bytes28[]":
    case "bytes29[]":
    case "bytes30[]":
    case "bytes31[]":
    case "bytes32[]":
    case "bool[]":
    case "address[]": {
      let fe = m$5(ne), ye = T$7[fe];
      if (ae % ye !== 0)
        throw new v$3(fe, oe);
      return new Array(ae / ye).fill(void 0).map((ge, we) => {
        let _e = sliceHex(oe, we * ye, (we + 1) * ye);
        return y$2(fe, _e);
      });
    }
  }
  return u$3(ne, `Unsupported dynamic ABI type: ${ne}`);
}
function E$3(ne) {
  if (ne.length !== 66)
    throw new g$4(ne);
  let oe = y$2("uint56", a$2(ne, 32 - 7, 32)), ae = f$2("uint40[]", a$2(ne, 0, 32 - 7)), fe = Object.freeze([...ae].reverse()), ye = BigInt(fe.reduce((ge, we) => ge + we, 0));
  if (ye !== oe)
    throw new F$1(ne, oe, ye);
  return { totalByteLength: oe, fieldByteLengths: fe };
}
function T$3(ne) {
  return ne.reduce((oe, ae) => oe + T$7[ae], 0);
}
function w$2(ne, oe) {
  let ae = [], fe = 0;
  ne.staticFields.forEach((we) => {
    let _e = T$7[we], Se = y$2(we, a$2(oe, fe, fe + _e));
    fe += _e, ae.push(Se);
  });
  let ye = T$3(ne.staticFields), ge = fe;
  if (ge !== ye && console.warn("Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?", { expectedLength: ye, actualLength: ge, bytesOffset: fe }), ne.dynamicFields.length > 0) {
    let we = E$3(a$2(oe, fe, fe + 32));
    fe += 32, ne.dynamicFields.forEach((Se, Ie) => {
      let $e = we.fieldByteLengths[Ie];
      if ($e > 0) {
        let Ne = f$2(Se, a$2(oe, fe, fe + $e));
        fe += $e, ae.push(Ne);
      } else
        ae.push(r$5[Se]);
    });
    let _e = fe - 32 - ge;
    BigInt(_e) !== we.totalByteLength && console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?", { expectedLength: we.totalByteLength, actualLength: _e, bytesOffset: fe });
  }
  return ae;
}
function j$3(ne, oe) {
  let ae = Object.values(ne).filter(e$3), fe = Object.values(ne).filter(v$4), ye = w$2({ staticFields: ae, dynamicFields: fe }, oe);
  return Object.fromEntries(Object.keys(ne).map((ge, we) => [ge, ye[we]]));
}
function zt$1(ne, { staticData: oe, encodedLengths: ae, dynamicData: fe }) {
  return j$3(ne, concatHex([a$2(oe, 0, T$3(Object.values(ne).filter(e$3))), ae, fe]));
}
function p$4(ne, oe) {
  if (c$4(ne) && Array.isArray(oe)) {
    let ae = m$5(ne);
    return oe.length === 0 ? "0x" : encodePacked(oe.map(() => ae), oe);
  }
  return encodePacked([ne], [oe]);
}
function I$6(ne, oe) {
  return oe.map((ae, fe) => encodeAbiParameters([{ type: ne.staticFields[fe] }], [ae]));
}
function Yt(ne, oe) {
  let ae = Object.values(ne).filter(e$3);
  return I$6({ staticFields: ae, dynamicFields: [] }, Object.values(oe));
}
function K$5(ne) {
  let oe = ne.map(size$1).reverse(), ae = oe.reduce((fe, ye) => fe + BigInt(ye), 0n);
  return padHex(concatHex([...oe.map((fe) => p$4("uint40", fe)), p$4("uint56", ae)]), { size: 32, dir: "left" });
}
function N$3(ne, oe) {
  let ae = Object.entries(ne), fe = ae.filter(([, Se]) => e$3(Se)), ye = ae.filter(([, Se]) => v$4(Se)), ge = fe.map(([Se, Ie]) => p$4(Ie, oe[Se])), we = ye.map(([Se, Ie]) => p$4(Ie, oe[Se])), _e = K$5(we);
  return { staticData: concatHex(ge), encodedLengths: _e, dynamicData: concatHex(we) };
}
function D$1(ne) {
  if (ne.length !== 66)
    throw new S$1(ne);
  let oe = hexToNumber$1(sliceHex(ne, 0, 2)), ae = hexToNumber$1(sliceHex(ne, 2, 3)), fe = hexToNumber$1(sliceHex(ne, 3, 4)), ye = [], ge = [];
  for (let _e = 4; _e < 4 + ae; _e++) {
    let Se = hexToNumber$1(sliceHex(ne, _e, _e + 1));
    ye.push(n$1[Se]);
  }
  for (let _e = 4 + ae; _e < 4 + ae + fe; _e++) {
    let Se = hexToNumber$1(sliceHex(ne, _e, _e + 1));
    ge.push(n$1[Se]);
  }
  let we = ye.reduce((_e, Se) => _e + T$7[Se], 0);
  if (we !== oe)
    throw console.warn(`Schema "${ne}" static data length (${oe}) did not match the summed length of all static fields (${we}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`), new H$2(ne, oe, we);
  return { staticFields: ye, dynamicFields: ge };
}
function P$4(ne) {
  let oe = ne.staticFields.map((fe) => n$1.indexOf(fe)), ae = ne.dynamicFields.map((fe) => n$1.indexOf(fe));
  return `0x${[T$3(ne.staticFields).toString(16).padStart(4, "0"), ne.staticFields.length.toString(16).padStart(2, "0"), ne.dynamicFields.length.toString(16).padStart(2, "0"), ...oe.map((fe) => fe.toString(16).padStart(2, "0")), ...ae.map((fe) => fe.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function zi(ne) {
  return P$4({ staticFields: Object.values(ne).filter(e$3), dynamicFields: [] });
}
function _i(ne) {
  let oe = Object.values(ne).filter(e$3), ae = Object.values(ne).filter(v$4), fe = oe.map((ye) => T$7[ye]);
  return `0x${[fe.reduce((ye, ge) => ye + ge, 0).toString(16).padStart(4, "0"), oe.length.toString(16).padStart(2, "0"), ae.length.toString(16).padStart(2, "0"), ...fe.map((ye) => ye.toString(16).padStart(2, "0"))].join("").padEnd(64, "0")}`;
}
function Ji(ne) {
  return P$4({ staticFields: Object.values(ne).filter(e$3), dynamicFields: Object.values(ne).filter(v$4) });
}
function Xi$1(ne) {
  return Object.fromEntries(ne.key.map((oe) => [oe, ne.schema[oe]]));
}
function Zi(ne) {
  return Object.fromEntries(Object.entries(ne.schema).filter(([oe]) => !ne.key.includes(oe)));
}
function ia(ne) {
  return P$6(ne, (oe) => oe.type);
}
function flatMorph(ne, oe) {
  var ge;
  const ae = Array.isArray(ne), fe = Object.entries(ne).flatMap((we, _e) => {
    const Se = ae ? oe(_e, we[1]) : oe(...we, _e);
    return Array.isArray(Se[0]) || Se.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      Se
    ) : [Se];
  }), ye = Object.fromEntries(fe);
  return typeof ((ge = fe[0]) == null ? void 0 : ge[0]) == "number" ? Object.values(ye) : ye;
}
var Hkt;
(function(ne) {
  class oe {
  }
  ne.Kind = oe;
  class ae {
  }
  ne.Instantiable = ae, ne.reify = (ye) => ye.hkt;
  class fe {
  }
  ne.UnaryKind = fe, ne.pipe = (...ye) => (ge) => ye.reduce((we, _e) => _e.hkt(we), ge);
})(Hkt || (Hkt = {}));
const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);
const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);
const integerLikeMatcher = /^-?\d+$/;
integerLikeMatcher.test.bind(integerLikeMatcher);
const prototypeKeysOf = (ne) => {
  const oe = [];
  let ae = ne;
  for (; ae !== Object.prototype && ae !== null && ae !== void 0; ) {
    for (const fe of Object.getOwnPropertyNames(ae))
      fe !== "constructor" && !oe.includes(fe) && oe.push(fe);
    for (const fe of Object.getOwnPropertySymbols(ae))
      oe.includes(fe) || oe.push(fe);
    ae = Object.getPrototypeOf(ae);
  }
  return oe;
};
prototypeKeysOf(0n), prototypeKeysOf(!1), prototypeKeysOf(0), prototypeKeysOf(""), prototypeKeysOf(Symbol());
function c$3(ne, oe) {
  return typeof ne == "object" && ne != null && o$3(ne, oe) ? ne[oe] : void 0;
}
function o$3(ne, oe) {
  return typeof ne == "object" && ne !== null && ne.hasOwnProperty(oe);
}
function r$2(ne) {
  return ne != null && typeof ne == "object";
}
function i$1(ne, oe) {
  let ae = [.../* @__PURE__ */ new Set([...Object.keys(ne), ...Object.keys(oe)])];
  return Object.fromEntries(ae.map((fe) => [fe, typeof ne[fe] > "u" ? oe[fe] : ne[fe]]));
}
var b$3 = { storeImportPath: "@latticexyz/store/src", userTypesFilename: "common.sol", outputDirectory: "codegen", indexFilename: "index.sol" }, m$2 = { outputDirectory: "tables", tableIdArgument: !1, storeArgument: !1 }, N$2 = { disabled: !1 }, x = { namespace: "", type: "table" }, T$2 = { sourceDirectory: "src", namespace: "" }, a$1 = { types: Object.fromEntries(n$1.map((ne) => [ne, ne])) };
function u$1(ne, oe) {
  return { types: { ...ne.types, ...oe } };
}
function h$1(ne, oe = a$1) {
  if (!r$2(ne))
    throw new Error(`Expected schema, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    if (!A$4(ae) && !o$3(oe.types, ae))
      throw new Error(`"${String(ae)}" is not a valid type in this scope.`);
}
function k$2(ne, oe = a$1) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, { type: A$4(fe) ? f$4(fe) : oe.types[fe], internalType: fe }]));
}
function v$2(ne, oe = a$1) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((ae) => A$4(ae) || o$3(oe.types, ae));
}
function Y$2(ne, oe = a$1) {
  return Object.entries(ne).filter(([, ae]) => o$3(oe.types, ae) && e$3(oe.types[ae])).map(([ae]) => ae);
}
function q$2(ne, oe, ae = a$1) {
  return Array.isArray(ne) && ne.every((fe) => o$3(oe, fe) && o$3(ae.types, oe[fe]) && e$3(ae.types[oe[fe]]));
}
function g$3(ne, oe = a$1, ae = { inStoreContext: !1 }) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full table config, got \`${JSON.stringify(ne)}\``);
  if (!o$3(ne, "schema"))
    throw new Error("Missing schema input");
  if (h$1(ne.schema, oe), !o$3(ne, "key") || !q$2(ne.key, ne.schema, oe))
    throw new Error(`Invalid key. Expected \`(${Y$2(ne.schema, oe).map((fe) => `"${String(fe)}"`).join(" | ")})[]\`, received \`${o$3(ne, "key") && Array.isArray(ne.key) ? `[${ne.key.map((fe) => `"${fe}"`).join(", ")}]` : String(c$3(ne, "key"))}\``);
  if (o$3(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`Table \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$3(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`Table \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
  if (ae.inStoreContext && (o$3(ne, "label") || o$3(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for tables in this context.");
}
function H$1(ne) {
  let oe = ne.codegen;
  return { outputDirectory: c$3(oe, "outputDirectory") ?? m$2.outputDirectory, tableIdArgument: c$3(oe, "tableIdArgument") ?? m$2.tableIdArgument, storeArgument: c$3(oe, "storeArgument") ?? m$2.storeArgument, dataStruct: c$3(oe, "dataStruct") ?? Object.keys(ne.schema).length - ne.key.length > 1 };
}
function E$2(ne, oe = a$1) {
  let ae = ne.label, fe = ne.type ?? x.type, ye = ne.namespace ?? x.namespace, ge = ne.name ?? ae.slice(0, 16), we = x$1({ type: fe, namespace: ye, name: ge });
  return { label: ae, type: fe, namespace: ye, name: ge, tableId: we, schema: k$2(ne.schema, oe), key: ne.key, codegen: H$1(ne), deploy: i$1(ne.deploy ?? {}, N$2) };
}
function D(ne) {
  return typeof ne == "string" || r$2(ne) && Object.values(ne).every((oe) => typeof oe == "string");
}
function A$2(ne, oe = a$1) {
  if (typeof ne == "string") {
    if (A$4(ne) || o$3(oe.types, ne))
      return;
    throw new Error(`Invalid ABI type. \`${ne}\` not found in scope.`);
  }
  if (typeof ne == "object" && ne !== null) {
    if (v$2(ne, oe)) {
      if (o$3(ne, "id") && e$3(oe.types[ne.id]))
        return;
      throw new Error("Invalid schema. Expected an `id` field with a static ABI type or an explicit `key` option.");
    }
    throw new Error("Invalid schema. Are you using invalid types or missing types in your scope?");
  }
  throw new Error("Invalid table shorthand.");
}
function l$2(ne, oe) {
  return typeof ne == "string" ? { schema: { id: "bytes32", value: ne }, key: ["id"] } : v$2(ne, oe) ? { schema: ne, key: ["id"] } : ne;
}
function d$1(ne, oe) {
  if (r$2(ne)) {
    for (let ae of Object.values(ne))
      D(ae) ? A$2(ae, oe) : g$3(ae, oe, { inStoreContext: !0 });
    return;
  }
  throw new Error(`Expected tables config, received ${JSON.stringify(ne)}`);
}
function I$5(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, E$2(i$1(l$2(fe, oe), { label: ae }), oe)]));
}
function Z(ne) {
  return P$6(ne, (oe) => oe.type);
}
function ee(ne) {
  return r$2(ne) && Object.values(ne).every((oe) => o$5(oe.type));
}
function U$3(ne, oe = a$1) {
  return ee(ne) ? u$1(oe, Z(ne)) : oe;
}
function L$2(ne) {
  if (!r$2(ne))
    throw new Error(`Expected userTypes, received ${JSON.stringify(ne)}`);
  for (let { type: oe } of Object.values(ne))
    if (!o$3(a$1.types, oe))
      throw new Error(`"${String(oe)}" is not a valid ABI type.`);
}
function te$1(ne) {
  return typeof ne == "object" && ne != null && Object.values(ne).every((oe) => Array.isArray(oe) && oe.every((ae) => typeof ae == "string"));
}
function _$1(ne, oe = a$1) {
  if (te$1(ne)) {
    let ae = Object.fromEntries(Object.keys(ne).map((fe) => [fe, "uint8"]));
    return u$1(oe, ae);
  }
  return oe;
}
function j$2(ne) {
  return flatMorph(ne, (oe, ae) => [oe, flatMorph(ae, (fe, ye) => [ye, fe])]);
}
function C$1(ne) {
  return r$2(ne) ? i$1(ne, b$3) : b$3;
}
function K$4(ne, oe) {
  if (o$3(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$3(ne, "tables") && d$1(ne.tables, oe);
}
function $(ne, oe = a$1) {
  let ae = ne.label, fe = ne.namespace ?? ae.slice(0, 14);
  return { label: ae, namespace: fe, tables: I$5(flatMorph(ne.tables ?? {}, (ye, ge) => [ye, i$1(l$2(ge, oe), { namespace: fe })]), oe) };
}
function w$1(ne, oe) {
  if (!r$2(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    K$4(ae, oe);
}
function f$1(ne, oe) {
  if (!r$2(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, ge) => [ye, $(i$1(ge, { label: ye }), oe)]), fe = Array.from(y$5(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function B$1(ne) {
  return Object.fromEntries(Object.entries(ne.namespaces).flatMap(([oe, ae]) => Object.entries(ae.tables).map(([fe, ye]) => [oe === "" ? fe : `${oe}__${fe}`, ye])));
}
function G$1(ne) {
  return _$1(c$3(ne, "enums"), U$3(c$3(ne, "userTypes")));
}
function pe(ne) {
  let oe = G$1(ne);
  if (o$3(ne, "namespaces")) {
    if (o$3(ne, "namespace") || o$3(ne, "tables"))
      throw new Error("Cannot use `namespaces` with `namespace` or `tables` keys.");
    w$1(ne.namespaces, oe);
  }
  if (o$3(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`\`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  o$3(ne, "tables") && d$1(ne.tables, oe), o$3(ne, "userTypes") && L$2(ne.userTypes);
}
function re(ne) {
  let oe = G$1(ne), ae = ne.namespace ?? T$2.namespace, fe = ne.namespaces ? { multipleNamespaces: !0, namespace: null, namespaces: f$1(ne.namespaces, oe) } : { multipleNamespaces: !1, namespace: ae, namespaces: f$1({ [ae]: ne }, oe) }, ye = B$1(fe);
  return { ...fe, tables: ye, sourceDirectory: ne.sourceDirectory ?? T$2.sourceDirectory, userTypes: ne.userTypes ?? {}, enums: ne.enums ?? {}, enumValues: j$2(ne.enums ?? {}), codegen: C$1(ne.codegen) };
}
function Lt(ne) {
  return pe(ne), re(ne);
}
var o$2 = Lt({ namespace: "store", codegen: { storeImportPath: "./src" }, userTypes: { ResourceId: { filePath: "./src/ResourceId.sol", type: "bytes32" }, FieldLayout: { filePath: "./src/FieldLayout.sol", type: "bytes32" }, Schema: { filePath: "./src/Schema.sol", type: "bytes32" } }, tables: { StoreHooks: { schema: { tableId: "ResourceId", hooks: "bytes21[]" }, key: ["tableId"] }, Tables: { schema: { tableId: "ResourceId", fieldLayout: "FieldLayout", keySchema: "Schema", valueSchema: "Schema", abiEncodedKeyNames: "bytes", abiEncodedFieldNames: "bytes" }, key: ["tableId"] }, ResourceIds: { schema: { resourceId: "ResourceId", exists: "bool" }, key: ["resourceId"] }, Hooks: { schema: { resourceId: "ResourceId", hooks: "bytes21[]" }, key: ["resourceId"], codegen: { tableIdArgument: !0 }, deploy: { disabled: !0 } } } }), m$1 = { namespace: "", openAccess: !0, accessList: [] }, C = { root: !1, args: [], artifactPath: void 0 }, I$4 = { worldInterfaceName: "IWorld", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src" }, b$2 = { customWorldContract: void 0, postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", upgradeableWorldImplementation: !1 }, P$3 = { systems: {}, tables: {}, excludeSystems: [], modules: [], codegen: I$4, deploy: b$2 };
function i(ne, oe = {}) {
  if (typeof ne != "object" || ne == null)
    throw new Error(`Expected full system config, got \`${JSON.stringify(ne)}\``);
  if (oe.inNamespace && (o$3(ne, "label") || o$3(ne, "namespace")))
    throw new Error("Overrides of `label` and `namespace` are not allowed for systems in this context.");
  if (o$3(ne, "namespace") && typeof ne.namespace == "string" && ne.namespace.length > 14)
    throw new Error(`System \`namespace\` must fit into a \`bytes14\`, but "${ne.namespace}" is too long.`);
  if (o$3(ne, "name") && typeof ne.name == "string" && ne.name.length > 16)
    throw new Error(`System \`name\` must fit into a \`bytes16\`, but "${ne.name}" is too long.`);
}
function c$2(ne) {
  let oe = ne.label, ae = ne.namespace ?? m$1.namespace, fe = ne.name ?? oe.slice(0, 16), ye = x$1({ type: "system", namespace: ae, name: fe });
  return i$1({ ...ne, label: oe, namespace: ae, name: fe, systemId: ye }, m$1);
}
function y$1(ne) {
  if (r$2(ne)) {
    for (let oe of Object.values(ne))
      i(oe, { inNamespace: !0 });
    return;
  }
  throw new Error(`Expected system config, received ${JSON.stringify(ne)}`);
}
function l$1(ne, oe) {
  return Object.fromEntries(Object.entries(ne).map(([ae, fe]) => [ae, c$2({ ...fe, label: ae, namespace: oe })]));
}
function Q$2(ne, oe) {
  o$3(ne, "systems") && y$1(ne.systems), K$4(ne, oe);
}
function X(ne, oe = a$1) {
  let ae = $(ne, oe), fe = l$1(ne.systems ?? {}, ae.namespace);
  return { ...ae, systems: fe };
}
function l(ne, oe) {
  if (!r$2(ne))
    throw new Error(`Expected namespaces, received ${JSON.stringify(ne)}`);
  for (let ae of Object.values(ne))
    Q$2(ae, oe);
}
function r$1(ne, oe) {
  if (!r$2(ne))
    throw new Error(`Expected namespaces config, received ${JSON.stringify(ne)}`);
  let ae = flatMorph(ne, (ye, ge) => [ye, X(i$1(ge, { label: ye }), oe)]), fe = Array.from(y$5(Object.values(ae), (ye) => ye.namespace).entries()).filter(([, ye]) => ye.length > 1).map(([ye]) => ye);
  if (fe.length > 0)
    throw new Error(`Found namespaces defined more than once in config: ${fe.join(", ")}`);
  return ae;
}
function N$1(ne) {
  return r$2(ne) ? i$1(ne, I$4) : I$4;
}
function g$2(ne) {
  return r$2(ne) ? i$1(ne, b$2) : b$2;
}
function W(ne) {
  let oe = G$1(ne);
  if (o$3(ne, "namespaces")) {
    if (o$3(ne, "namespace") || o$3(ne, "tables") || o$3(ne, "systems"))
      throw new Error("Cannot use `namespaces` with `namespace`, `tables`, or `systems` keys.");
    l(ne.namespaces, oe);
  }
  o$3(ne, "systems") && y$1(ne.systems), pe(ne);
}
function _(ne) {
  let oe = G$1(ne), ae = re(ne), fe = ne.namespaces ? r$1(ne.namespaces, oe) : r$1({ [ae.namespace]: ne }, oe), ye = B$1({ namespaces: fe }), ge = (ne.modules ?? P$3.modules).map((we) => i$1(we, C));
  return i$1({ ...ae, namespaces: fe, tables: ye, systems: !ae.multipleNamespaces && ne.systems ? l$1(ne.systems, ae.namespace) : P$3.systems, excludeSystems: c$3(ne, "excludeSystems"), codegen: i$1(ae.codegen, N$1(ne.codegen)), deploy: g$2(ne.deploy), modules: ge }, P$3);
}
function te(ne) {
  return W(ne), _(ne);
}
var s = { namespace: "world", codegen: { worldImportPath: "./src", worldgenDirectory: "interfaces", worldInterfaceName: "IBaseWorld" }, userTypes: { ResourceId: { filePath: "@latticexyz/store/src/ResourceId.sol", type: "bytes32" } }, tables: { NamespaceOwner: { schema: { namespaceId: "ResourceId", owner: "address" }, key: ["namespaceId"] }, ResourceAccess: { schema: { resourceId: "ResourceId", caller: "address", access: "bool" }, key: ["resourceId", "caller"] }, InstalledModules: { schema: { moduleAddress: "address", argumentsHash: "bytes32", isInstalled: "bool" }, key: ["moduleAddress", "argumentsHash"] }, UserDelegationControl: { schema: { delegator: "address", delegatee: "address", delegationControlId: "ResourceId" }, key: ["delegator", "delegatee"] }, NamespaceDelegationControl: { schema: { namespaceId: "ResourceId", delegationControlId: "ResourceId" }, key: ["namespaceId"] }, Balances: { schema: { namespaceId: "ResourceId", balance: "uint256" }, key: ["namespaceId"] }, Systems: { schema: { systemId: "ResourceId", system: "address", publicAccess: "bool" }, key: ["systemId"], codegen: { dataStruct: !1 } }, SystemRegistry: { schema: { system: "address", systemId: "ResourceId" }, key: ["system"] }, SystemHooks: { schema: { systemId: "ResourceId", value: "bytes21[]" }, key: ["systemId"] }, FunctionSelectors: { schema: { worldFunctionSelector: "bytes4", systemId: "ResourceId", systemFunctionSelector: "bytes4" }, key: ["worldFunctionSelector"], codegen: { dataStruct: !1 } }, FunctionSignatures: { type: "offchainTable", schema: { functionSelector: "bytes4", functionSignature: "string" }, key: ["functionSelector"] }, InitModuleAddress: { schema: { value: "address" }, key: [] } }, excludeSystems: ["StoreRegistrationSystem"] }, a = te(s), t$1 = "event Store_SetRecord(bytes32 indexed tableId, bytes32[] keyTuple, bytes staticData, bytes32 encodedLengths, bytes dynamicData)", o$1 = "event Store_SpliceStaticData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, bytes data)", r = "event Store_SpliceDynamicData(bytes32 indexed tableId, bytes32[] keyTuple, uint8 dynamicFieldIndex, uint48 start, uint40 deleteCount, bytes32 encodedLengths, bytes data)", n = "event Store_DeleteRecord(bytes32 indexed tableId, bytes32[] keyTuple)", e$1 = [t$1, o$1, r, n], p$3 = parseAbi(e$1), extendStatics = function(ne, oe) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ae, fe) {
    ae.__proto__ = fe;
  } || function(ae, fe) {
    for (var ye in fe)
      Object.prototype.hasOwnProperty.call(fe, ye) && (ae[ye] = fe[ye]);
  }, extendStatics(ne, oe);
};
function __extends(ne, oe) {
  if (typeof oe != "function" && oe !== null)
    throw new TypeError("Class extends value " + String(oe) + " is not a constructor or null");
  extendStatics(ne, oe);
  function ae() {
    this.constructor = ne;
  }
  ne.prototype = oe === null ? Object.create(oe) : (ae.prototype = oe.prototype, new ae());
}
function __awaiter(ne, oe, ae, fe) {
  function ye(ge) {
    return ge instanceof ae ? ge : new ae(function(we) {
      we(ge);
    });
  }
  return new (ae || (ae = Promise))(function(ge, we) {
    function _e($e) {
      try {
        Ie(fe.next($e));
      } catch (Ne) {
        we(Ne);
      }
    }
    function Se($e) {
      try {
        Ie(fe.throw($e));
      } catch (Ne) {
        we(Ne);
      }
    }
    function Ie($e) {
      $e.done ? ge($e.value) : ye($e.value).then(_e, Se);
    }
    Ie((fe = fe.apply(ne, oe || [])).next());
  });
}
function __generator(ne, oe) {
  var ae = { label: 0, sent: function() {
    if (ge[0] & 1)
      throw ge[1];
    return ge[1];
  }, trys: [], ops: [] }, fe, ye, ge, we;
  return we = { next: _e(0), throw: _e(1), return: _e(2) }, typeof Symbol == "function" && (we[Symbol.iterator] = function() {
    return this;
  }), we;
  function _e(Ie) {
    return function($e) {
      return Se([Ie, $e]);
    };
  }
  function Se(Ie) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; we && (we = 0, Ie[0] && (ae = 0)), ae; )
      try {
        if (fe = 1, ye && (ge = Ie[0] & 2 ? ye.return : Ie[0] ? ye.throw || ((ge = ye.return) && ge.call(ye), 0) : ye.next) && !(ge = ge.call(ye, Ie[1])).done)
          return ge;
        switch (ye = 0, ge && (Ie = [Ie[0] & 2, ge.value]), Ie[0]) {
          case 0:
          case 1:
            ge = Ie;
            break;
          case 4:
            return ae.label++, { value: Ie[1], done: !1 };
          case 5:
            ae.label++, ye = Ie[1], Ie = [0];
            continue;
          case 7:
            Ie = ae.ops.pop(), ae.trys.pop();
            continue;
          default:
            if (ge = ae.trys, !(ge = ge.length > 0 && ge[ge.length - 1]) && (Ie[0] === 6 || Ie[0] === 2)) {
              ae = 0;
              continue;
            }
            if (Ie[0] === 3 && (!ge || Ie[1] > ge[0] && Ie[1] < ge[3])) {
              ae.label = Ie[1];
              break;
            }
            if (Ie[0] === 6 && ae.label < ge[1]) {
              ae.label = ge[1], ge = Ie;
              break;
            }
            if (ge && ae.label < ge[2]) {
              ae.label = ge[2], ae.ops.push(Ie);
              break;
            }
            ge[2] && ae.ops.pop(), ae.trys.pop();
            continue;
        }
        Ie = oe.call(ne, ae);
      } catch ($e) {
        Ie = [6, $e], ye = 0;
      } finally {
        fe = ge = 0;
      }
    if (Ie[0] & 5)
      throw Ie[1];
    return { value: Ie[0] ? Ie[1] : void 0, done: !0 };
  }
}
function __values(ne) {
  var oe = typeof Symbol == "function" && Symbol.iterator, ae = oe && ne[oe], fe = 0;
  if (ae)
    return ae.call(ne);
  if (ne && typeof ne.length == "number")
    return {
      next: function() {
        return ne && fe >= ne.length && (ne = void 0), { value: ne && ne[fe++], done: !ne };
      }
    };
  throw new TypeError(oe ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(ne, oe) {
  var ae = typeof Symbol == "function" && ne[Symbol.iterator];
  if (!ae)
    return ne;
  var fe = ae.call(ne), ye, ge = [], we;
  try {
    for (; (oe === void 0 || oe-- > 0) && !(ye = fe.next()).done; )
      ge.push(ye.value);
  } catch (_e) {
    we = { error: _e };
  } finally {
    try {
      ye && !ye.done && (ae = fe.return) && ae.call(fe);
    } finally {
      if (we)
        throw we.error;
    }
  }
  return ge;
}
function __spreadArray(ne, oe, ae) {
  if (ae || arguments.length === 2)
    for (var fe = 0, ye = oe.length, ge; fe < ye; fe++)
      (ge || !(fe in oe)) && (ge || (ge = Array.prototype.slice.call(oe, 0, fe)), ge[fe] = oe[fe]);
  return ne.concat(ge || Array.prototype.slice.call(oe));
}
function __await(ne) {
  return this instanceof __await ? (this.v = ne, this) : new __await(ne);
}
function __asyncGenerator(ne, oe, ae) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var fe = ae.apply(ne, oe || []), ye, ge = [];
  return ye = {}, _e("next"), _e("throw"), _e("return", we), ye[Symbol.asyncIterator] = function() {
    return this;
  }, ye;
  function we(Be) {
    return function(ze) {
      return Promise.resolve(ze).then(Be, Ne);
    };
  }
  function _e(Be, ze) {
    fe[Be] && (ye[Be] = function(He) {
      return new Promise(function(Ze, qe) {
        ge.push([Be, He, Ze, qe]) > 1 || Se(Be, He);
      });
    }, ze && (ye[Be] = ze(ye[Be])));
  }
  function Se(Be, ze) {
    try {
      Ie(fe[Be](ze));
    } catch (He) {
      Me(ge[0][3], He);
    }
  }
  function Ie(Be) {
    Be.value instanceof __await ? Promise.resolve(Be.value.v).then($e, Ne) : Me(ge[0][2], Be);
  }
  function $e(Be) {
    Se("next", Be);
  }
  function Ne(Be) {
    Se("throw", Be);
  }
  function Me(Be, ze) {
    Be(ze), ge.shift(), ge.length && Se(ge[0][0], ge[0][1]);
  }
}
function __asyncValues(ne) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var oe = ne[Symbol.asyncIterator], ae;
  return oe ? oe.call(ne) : (ne = typeof __values == "function" ? __values(ne) : ne[Symbol.iterator](), ae = {}, fe("next"), fe("throw"), fe("return"), ae[Symbol.asyncIterator] = function() {
    return this;
  }, ae);
  function fe(ge) {
    ae[ge] = ne[ge] && function(we) {
      return new Promise(function(_e, Se) {
        we = ne[ge](we), ye(_e, Se, we.done, we.value);
      });
    };
  }
  function ye(ge, we, _e, Se) {
    Promise.resolve(Se).then(function(Ie) {
      ge({ value: Ie, done: _e });
    }, we);
  }
}
typeof SuppressedError == "function" && SuppressedError;
function isFunction$1(ne) {
  return typeof ne == "function";
}
function createErrorClass(ne) {
  var oe = function(fe) {
    Error.call(fe), fe.stack = new Error().stack;
  }, ae = ne(oe);
  return ae.prototype = Object.create(Error.prototype), ae.prototype.constructor = ae, ae;
}
var UnsubscriptionError = createErrorClass(function(ne) {
  return function(ae) {
    ne(this), this.message = ae ? ae.length + ` errors occurred during unsubscription:
` + ae.map(function(fe, ye) {
      return ye + 1 + ") " + fe.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = ae;
  };
});
function arrRemove(ne, oe) {
  if (ne) {
    var ae = ne.indexOf(oe);
    0 <= ae && ne.splice(ae, 1);
  }
}
var Subscription = function() {
  function ne(oe) {
    this.initialTeardown = oe, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return ne.prototype.unsubscribe = function() {
    var oe, ae, fe, ye, ge;
    if (!this.closed) {
      this.closed = !0;
      var we = this._parentage;
      if (we)
        if (this._parentage = null, Array.isArray(we))
          try {
            for (var _e = __values(we), Se = _e.next(); !Se.done; Se = _e.next()) {
              var Ie = Se.value;
              Ie.remove(this);
            }
          } catch (He) {
            oe = { error: He };
          } finally {
            try {
              Se && !Se.done && (ae = _e.return) && ae.call(_e);
            } finally {
              if (oe)
                throw oe.error;
            }
          }
        else
          we.remove(this);
      var $e = this.initialTeardown;
      if (isFunction$1($e))
        try {
          $e();
        } catch (He) {
          ge = He instanceof UnsubscriptionError ? He.errors : [He];
        }
      var Ne = this._finalizers;
      if (Ne) {
        this._finalizers = null;
        try {
          for (var Me = __values(Ne), Be = Me.next(); !Be.done; Be = Me.next()) {
            var ze = Be.value;
            try {
              execFinalizer(ze);
            } catch (He) {
              ge = ge ?? [], He instanceof UnsubscriptionError ? ge = __spreadArray(__spreadArray([], __read(ge)), __read(He.errors)) : ge.push(He);
            }
          }
        } catch (He) {
          fe = { error: He };
        } finally {
          try {
            Be && !Be.done && (ye = Me.return) && ye.call(Me);
          } finally {
            if (fe)
              throw fe.error;
          }
        }
      }
      if (ge)
        throw new UnsubscriptionError(ge);
    }
  }, ne.prototype.add = function(oe) {
    var ae;
    if (oe && oe !== this)
      if (this.closed)
        execFinalizer(oe);
      else {
        if (oe instanceof ne) {
          if (oe.closed || oe._hasParent(this))
            return;
          oe._addParent(this);
        }
        (this._finalizers = (ae = this._finalizers) !== null && ae !== void 0 ? ae : []).push(oe);
      }
  }, ne.prototype._hasParent = function(oe) {
    var ae = this._parentage;
    return ae === oe || Array.isArray(ae) && ae.includes(oe);
  }, ne.prototype._addParent = function(oe) {
    var ae = this._parentage;
    this._parentage = Array.isArray(ae) ? (ae.push(oe), ae) : ae ? [ae, oe] : oe;
  }, ne.prototype._removeParent = function(oe) {
    var ae = this._parentage;
    ae === oe ? this._parentage = null : Array.isArray(ae) && arrRemove(ae, oe);
  }, ne.prototype.remove = function(oe) {
    var ae = this._finalizers;
    ae && arrRemove(ae, oe), oe instanceof ne && oe._removeParent(this);
  }, ne.EMPTY = function() {
    var oe = new ne();
    return oe.closed = !0, oe;
  }(), ne;
}(), EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(ne) {
  return ne instanceof Subscription || ne && "closed" in ne && isFunction$1(ne.remove) && isFunction$1(ne.add) && isFunction$1(ne.unsubscribe);
}
function execFinalizer(ne) {
  isFunction$1(ne) ? ne() : ne.unsubscribe();
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, timeoutProvider = {
  setTimeout: function(ne, oe) {
    for (var ae = [], fe = 2; fe < arguments.length; fe++)
      ae[fe - 2] = arguments[fe];
    var ye = timeoutProvider.delegate;
    return ye != null && ye.setTimeout ? ye.setTimeout.apply(ye, __spreadArray([ne, oe], __read(ae))) : setTimeout.apply(void 0, __spreadArray([ne, oe], __read(ae)));
  },
  clearTimeout: function(ne) {
    var oe = timeoutProvider.delegate;
    return ((oe == null ? void 0 : oe.clearTimeout) || clearTimeout)(ne);
  },
  delegate: void 0
};
function reportUnhandledError(ne) {
  timeoutProvider.setTimeout(function() {
    throw ne;
  });
}
function noop$1() {
}
function errorContext(ne) {
  ne();
}
var Subscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae) {
    var fe = ne.call(this) || this;
    return fe.isStopped = !1, ae ? (fe.destination = ae, isSubscription(ae) && ae.add(fe)) : fe.destination = EMPTY_OBSERVER, fe;
  }
  return oe.create = function(ae, fe, ye) {
    return new SafeSubscriber(ae, fe, ye);
  }, oe.prototype.next = function(ae) {
    this.isStopped || this._next(ae);
  }, oe.prototype.error = function(ae) {
    this.isStopped || (this.isStopped = !0, this._error(ae));
  }, oe.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, oe.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, ne.prototype.unsubscribe.call(this), this.destination = null);
  }, oe.prototype._next = function(ae) {
    this.destination.next(ae);
  }, oe.prototype._error = function(ae) {
    try {
      this.destination.error(ae);
    } finally {
      this.unsubscribe();
    }
  }, oe.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, oe;
}(Subscription), _bind = Function.prototype.bind;
function bind(ne, oe) {
  return _bind.call(ne, oe);
}
var ConsumerObserver = function() {
  function ne(oe) {
    this.partialObserver = oe;
  }
  return ne.prototype.next = function(oe) {
    var ae = this.partialObserver;
    if (ae.next)
      try {
        ae.next(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
  }, ne.prototype.error = function(oe) {
    var ae = this.partialObserver;
    if (ae.error)
      try {
        ae.error(oe);
      } catch (fe) {
        handleUnhandledError(fe);
      }
    else
      handleUnhandledError(oe);
  }, ne.prototype.complete = function() {
    var oe = this.partialObserver;
    if (oe.complete)
      try {
        oe.complete();
      } catch (ae) {
        handleUnhandledError(ae);
      }
  }, ne;
}(), SafeSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    var ge = ne.call(this) || this, we;
    if (isFunction$1(ae) || !ae)
      we = {
        next: ae ?? void 0,
        error: fe ?? void 0,
        complete: ye ?? void 0
      };
    else {
      var _e;
      ge && config.useDeprecatedNextContext ? (_e = Object.create(ae), _e.unsubscribe = function() {
        return ge.unsubscribe();
      }, we = {
        next: ae.next && bind(ae.next, _e),
        error: ae.error && bind(ae.error, _e),
        complete: ae.complete && bind(ae.complete, _e)
      }) : we = ae;
    }
    return ge.destination = new ConsumerObserver(we), ge;
  }
  return oe;
}(Subscriber);
function handleUnhandledError(ne) {
  reportUnhandledError(ne);
}
function defaultErrorHandler(ne) {
  throw ne;
}
var EMPTY_OBSERVER = {
  closed: !0,
  next: noop$1,
  error: defaultErrorHandler,
  complete: noop$1
}, observable$1 = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity(ne) {
  return ne;
}
function pipe() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return pipeFromArray(ne);
}
function pipeFromArray(ne) {
  return ne.length === 0 ? identity : ne.length === 1 ? ne[0] : function(ae) {
    return ne.reduce(function(fe, ye) {
      return ye(fe);
    }, ae);
  };
}
var Observable = function() {
  function ne(oe) {
    oe && (this._subscribe = oe);
  }
  return ne.prototype.lift = function(oe) {
    var ae = new ne();
    return ae.source = this, ae.operator = oe, ae;
  }, ne.prototype.subscribe = function(oe, ae, fe) {
    var ye = this, ge = isSubscriber(oe) ? oe : new SafeSubscriber(oe, ae, fe);
    return errorContext(function() {
      var we = ye, _e = we.operator, Se = we.source;
      ge.add(_e ? _e.call(ge, Se) : Se ? ye._subscribe(ge) : ye._trySubscribe(ge));
    }), ge;
  }, ne.prototype._trySubscribe = function(oe) {
    try {
      return this._subscribe(oe);
    } catch (ae) {
      oe.error(ae);
    }
  }, ne.prototype.forEach = function(oe, ae) {
    var fe = this;
    return ae = getPromiseCtor(ae), new ae(function(ye, ge) {
      var we = new SafeSubscriber({
        next: function(_e) {
          try {
            oe(_e);
          } catch (Se) {
            ge(Se), we.unsubscribe();
          }
        },
        error: ge,
        complete: ye
      });
      fe.subscribe(we);
    });
  }, ne.prototype._subscribe = function(oe) {
    var ae;
    return (ae = this.source) === null || ae === void 0 ? void 0 : ae.subscribe(oe);
  }, ne.prototype[observable$1] = function() {
    return this;
  }, ne.prototype.pipe = function() {
    for (var oe = [], ae = 0; ae < arguments.length; ae++)
      oe[ae] = arguments[ae];
    return pipeFromArray(oe)(this);
  }, ne.prototype.toPromise = function(oe) {
    var ae = this;
    return oe = getPromiseCtor(oe), new oe(function(fe, ye) {
      var ge;
      ae.subscribe(function(we) {
        return ge = we;
      }, function(we) {
        return ye(we);
      }, function() {
        return fe(ge);
      });
    });
  }, ne.create = function(oe) {
    return new ne(oe);
  }, ne;
}();
function getPromiseCtor(ne) {
  var oe;
  return (oe = ne ?? config.Promise) !== null && oe !== void 0 ? oe : Promise;
}
function isObserver(ne) {
  return ne && isFunction$1(ne.next) && isFunction$1(ne.error) && isFunction$1(ne.complete);
}
function isSubscriber(ne) {
  return ne && ne instanceof Subscriber || isObserver(ne) && isSubscription(ne);
}
function hasLift(ne) {
  return isFunction$1(ne == null ? void 0 : ne.lift);
}
function operate(ne) {
  return function(oe) {
    if (hasLift(oe))
      return oe.lift(function(ae) {
        try {
          return ne(ae, this);
        } catch (fe) {
          this.error(fe);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(ne, oe, ae, fe, ye) {
  return new OperatorSubscriber(ne, oe, ae, fe, ye);
}
var OperatorSubscriber = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye, ge, we, _e) {
    var Se = ne.call(this, ae) || this;
    return Se.onFinalize = we, Se.shouldUnsubscribe = _e, Se._next = fe ? function(Ie) {
      try {
        fe(Ie);
      } catch ($e) {
        ae.error($e);
      }
    } : ne.prototype._next, Se._error = ge ? function(Ie) {
      try {
        ge(Ie);
      } catch ($e) {
        ae.error($e);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._error, Se._complete = ye ? function() {
      try {
        ye();
      } catch (Ie) {
        ae.error(Ie);
      } finally {
        this.unsubscribe();
      }
    } : ne.prototype._complete, Se;
  }
  return oe.prototype.unsubscribe = function() {
    var ae;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var fe = this.closed;
      ne.prototype.unsubscribe.call(this), !fe && ((ae = this.onFinalize) === null || ae === void 0 || ae.call(this));
    }
  }, oe;
}(Subscriber), ObjectUnsubscribedError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Subject = function(ne) {
  __extends(oe, ne);
  function oe() {
    var ae = ne.call(this) || this;
    return ae.closed = !1, ae.currentObservers = null, ae.observers = [], ae.isStopped = !1, ae.hasError = !1, ae.thrownError = null, ae;
  }
  return oe.prototype.lift = function(ae) {
    var fe = new AnonymousSubject(this, this);
    return fe.operator = ae, fe;
  }, oe.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
  }, oe.prototype.next = function(ae) {
    var fe = this;
    errorContext(function() {
      var ye, ge;
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.currentObservers || (fe.currentObservers = Array.from(fe.observers));
        try {
          for (var we = __values(fe.currentObservers), _e = we.next(); !_e.done; _e = we.next()) {
            var Se = _e.value;
            Se.next(ae);
          }
        } catch (Ie) {
          ye = { error: Ie };
        } finally {
          try {
            _e && !_e.done && (ge = we.return) && ge.call(we);
          } finally {
            if (ye)
              throw ye.error;
          }
        }
      }
    });
  }, oe.prototype.error = function(ae) {
    var fe = this;
    errorContext(function() {
      if (fe._throwIfClosed(), !fe.isStopped) {
        fe.hasError = fe.isStopped = !0, fe.thrownError = ae;
        for (var ye = fe.observers; ye.length; )
          ye.shift().error(ae);
      }
    });
  }, oe.prototype.complete = function() {
    var ae = this;
    errorContext(function() {
      if (ae._throwIfClosed(), !ae.isStopped) {
        ae.isStopped = !0;
        for (var fe = ae.observers; fe.length; )
          fe.shift().complete();
      }
    });
  }, oe.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(oe.prototype, "observed", {
    get: function() {
      var ae;
      return ((ae = this.observers) === null || ae === void 0 ? void 0 : ae.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), oe.prototype._trySubscribe = function(ae) {
    return this._throwIfClosed(), ne.prototype._trySubscribe.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(ae), this._innerSubscribe(ae);
  }, oe.prototype._innerSubscribe = function(ae) {
    var fe = this, ye = this, ge = ye.hasError, we = ye.isStopped, _e = ye.observers;
    return ge || we ? EMPTY_SUBSCRIPTION : (this.currentObservers = null, _e.push(ae), new Subscription(function() {
      fe.currentObservers = null, arrRemove(_e, ae);
    }));
  }, oe.prototype._checkFinalizedStatuses = function(ae) {
    var fe = this, ye = fe.hasError, ge = fe.thrownError, we = fe.isStopped;
    ye ? ae.error(ge) : we && ae.complete();
  }, oe.prototype.asObservable = function() {
    var ae = new Observable();
    return ae.source = this, ae;
  }, oe.create = function(ae, fe) {
    return new AnonymousSubject(ae, fe);
  }, oe;
}(Observable), AnonymousSubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe) {
    var ye = ne.call(this) || this;
    return ye.destination = ae, ye.source = fe, ye;
  }
  return oe.prototype.next = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.next) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.error = function(ae) {
    var fe, ye;
    (ye = (fe = this.destination) === null || fe === void 0 ? void 0 : fe.error) === null || ye === void 0 || ye.call(fe, ae);
  }, oe.prototype.complete = function() {
    var ae, fe;
    (fe = (ae = this.destination) === null || ae === void 0 ? void 0 : ae.complete) === null || fe === void 0 || fe.call(ae);
  }, oe.prototype._subscribe = function(ae) {
    var fe, ye;
    return (ye = (fe = this.source) === null || fe === void 0 ? void 0 : fe.subscribe(ae)) !== null && ye !== void 0 ? ye : EMPTY_SUBSCRIPTION;
  }, oe;
}(Subject), dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
}, ReplaySubject = function(ne) {
  __extends(oe, ne);
  function oe(ae, fe, ye) {
    ae === void 0 && (ae = 1 / 0), fe === void 0 && (fe = 1 / 0), ye === void 0 && (ye = dateTimestampProvider);
    var ge = ne.call(this) || this;
    return ge._bufferSize = ae, ge._windowTime = fe, ge._timestampProvider = ye, ge._buffer = [], ge._infiniteTimeWindow = !0, ge._infiniteTimeWindow = fe === 1 / 0, ge._bufferSize = Math.max(1, ae), ge._windowTime = Math.max(1, fe), ge;
  }
  return oe.prototype.next = function(ae) {
    var fe = this, ye = fe.isStopped, ge = fe._buffer, we = fe._infiniteTimeWindow, _e = fe._timestampProvider, Se = fe._windowTime;
    ye || (ge.push(ae), !we && ge.push(_e.now() + Se)), this._trimBuffer(), ne.prototype.next.call(this, ae);
  }, oe.prototype._subscribe = function(ae) {
    this._throwIfClosed(), this._trimBuffer();
    for (var fe = this._innerSubscribe(ae), ye = this, ge = ye._infiniteTimeWindow, we = ye._buffer, _e = we.slice(), Se = 0; Se < _e.length && !ae.closed; Se += ge ? 1 : 2)
      ae.next(_e[Se]);
    return this._checkFinalizedStatuses(ae), fe;
  }, oe.prototype._trimBuffer = function() {
    var ae = this, fe = ae._bufferSize, ye = ae._timestampProvider, ge = ae._buffer, we = ae._infiniteTimeWindow, _e = (we ? 1 : 2) * fe;
    if (fe < 1 / 0 && _e < ge.length && ge.splice(0, ge.length - _e), !we) {
      for (var Se = ye.now(), Ie = 0, $e = 1; $e < ge.length && ge[$e] <= Se; $e += 2)
        Ie = $e;
      Ie && ge.splice(0, Ie + 1);
    }
  }, oe;
}(Subject), EMPTY = new Observable(function(ne) {
  return ne.complete();
});
function isScheduler(ne) {
  return ne && isFunction$1(ne.schedule);
}
function last(ne) {
  return ne[ne.length - 1];
}
function popResultSelector(ne) {
  return isFunction$1(last(ne)) ? ne.pop() : void 0;
}
function popScheduler(ne) {
  return isScheduler(last(ne)) ? ne.pop() : void 0;
}
function popNumber(ne, oe) {
  return typeof last(ne) == "number" ? ne.pop() : oe;
}
var isArrayLike = function(ne) {
  return ne && typeof ne.length == "number" && typeof ne != "function";
};
function isPromise(ne) {
  return isFunction$1(ne == null ? void 0 : ne.then);
}
function isInteropObservable(ne) {
  return isFunction$1(ne[observable$1]);
}
function isAsyncIterable(ne) {
  return Symbol.asyncIterator && isFunction$1(ne == null ? void 0 : ne[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(ne) {
  return new TypeError("You provided " + (ne !== null && typeof ne == "object" ? "an invalid object" : "'" + ne + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(ne) {
  return isFunction$1(ne == null ? void 0 : ne[iterator]);
}
function readableStreamLikeToAsyncGenerator(ne) {
  return __asyncGenerator(this, arguments, function() {
    var ae, fe, ye, ge;
    return __generator(this, function(we) {
      switch (we.label) {
        case 0:
          ae = ne.getReader(), we.label = 1;
        case 1:
          we.trys.push([1, , 9, 10]), we.label = 2;
        case 2:
          return [4, __await(ae.read())];
        case 3:
          return fe = we.sent(), ye = fe.value, ge = fe.done, ge ? [4, __await(void 0)] : [3, 5];
        case 4:
          return [2, we.sent()];
        case 5:
          return [4, __await(ye)];
        case 6:
          return [4, we.sent()];
        case 7:
          return we.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return ae.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(ne) {
  return isFunction$1(ne == null ? void 0 : ne.getReader);
}
function innerFrom(ne) {
  if (ne instanceof Observable)
    return ne;
  if (ne != null) {
    if (isInteropObservable(ne))
      return fromInteropObservable(ne);
    if (isArrayLike(ne))
      return fromArrayLike(ne);
    if (isPromise(ne))
      return fromPromise(ne);
    if (isAsyncIterable(ne))
      return fromAsyncIterable(ne);
    if (isIterable(ne))
      return fromIterable(ne);
    if (isReadableStreamLike(ne))
      return fromReadableStreamLike(ne);
  }
  throw createInvalidObservableTypeError(ne);
}
function fromInteropObservable(ne) {
  return new Observable(function(oe) {
    var ae = ne[observable$1]();
    if (isFunction$1(ae.subscribe))
      return ae.subscribe(oe);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(ne) {
  return new Observable(function(oe) {
    for (var ae = 0; ae < ne.length && !oe.closed; ae++)
      oe.next(ne[ae]);
    oe.complete();
  });
}
function fromPromise(ne) {
  return new Observable(function(oe) {
    ne.then(function(ae) {
      oe.closed || (oe.next(ae), oe.complete());
    }, function(ae) {
      return oe.error(ae);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(ne) {
  return new Observable(function(oe) {
    var ae, fe;
    try {
      for (var ye = __values(ne), ge = ye.next(); !ge.done; ge = ye.next()) {
        var we = ge.value;
        if (oe.next(we), oe.closed)
          return;
      }
    } catch (_e) {
      ae = { error: _e };
    } finally {
      try {
        ge && !ge.done && (fe = ye.return) && fe.call(ye);
      } finally {
        if (ae)
          throw ae.error;
      }
    }
    oe.complete();
  });
}
function fromAsyncIterable(ne) {
  return new Observable(function(oe) {
    process$1(ne, oe).catch(function(ae) {
      return oe.error(ae);
    });
  });
}
function fromReadableStreamLike(ne) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(ne));
}
function process$1(ne, oe) {
  var ae, fe, ye, ge;
  return __awaiter(this, void 0, void 0, function() {
    var we, _e;
    return __generator(this, function(Se) {
      switch (Se.label) {
        case 0:
          Se.trys.push([0, 5, 6, 11]), ae = __asyncValues(ne), Se.label = 1;
        case 1:
          return [4, ae.next()];
        case 2:
          if (fe = Se.sent(), !!fe.done)
            return [3, 4];
          if (we = fe.value, oe.next(we), oe.closed)
            return [2];
          Se.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return _e = Se.sent(), ye = { error: _e }, [3, 11];
        case 6:
          return Se.trys.push([6, , 9, 10]), fe && !fe.done && (ge = ae.return) ? [4, ge.call(ae)] : [3, 8];
        case 7:
          Se.sent(), Se.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (ye)
            throw ye.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return oe.complete(), [2];
      }
    });
  });
}
function executeSchedule(ne, oe, ae, fe, ye) {
  fe === void 0 && (fe = 0), ye === void 0 && (ye = !1);
  var ge = oe.schedule(function() {
    ae(), ye ? ne.add(this.schedule(null, fe)) : this.unsubscribe();
  }, fe);
  if (ne.add(ge), !ye)
    return ge;
}
function observeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    ae.subscribe(createOperatorSubscriber(fe, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.next(ye);
      }, oe);
    }, function() {
      return executeSchedule(fe, ne, function() {
        return fe.complete();
      }, oe);
    }, function(ye) {
      return executeSchedule(fe, ne, function() {
        return fe.error(ye);
      }, oe);
    }));
  });
}
function subscribeOn(ne, oe) {
  return oe === void 0 && (oe = 0), operate(function(ae, fe) {
    fe.add(ne.schedule(function() {
      return ae.subscribe(fe);
    }, oe));
  });
}
function scheduleObservable(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function schedulePromise(ne, oe) {
  return innerFrom(ne).pipe(subscribeOn(oe), observeOn(oe));
}
function scheduleArray(ne, oe) {
  return new Observable(function(ae) {
    var fe = 0;
    return oe.schedule(function() {
      fe === ne.length ? ae.complete() : (ae.next(ne[fe++]), ae.closed || this.schedule());
    });
  });
}
function scheduleIterable(ne, oe) {
  return new Observable(function(ae) {
    var fe;
    return executeSchedule(ae, oe, function() {
      fe = ne[iterator](), executeSchedule(ae, oe, function() {
        var ye, ge, we;
        try {
          ye = fe.next(), ge = ye.value, we = ye.done;
        } catch (_e) {
          ae.error(_e);
          return;
        }
        we ? ae.complete() : ae.next(ge);
      }, 0, !0);
    }), function() {
      return isFunction$1(fe == null ? void 0 : fe.return) && fe.return();
    };
  });
}
function scheduleAsyncIterable(ne, oe) {
  if (!ne)
    throw new Error("Iterable cannot be null");
  return new Observable(function(ae) {
    executeSchedule(ae, oe, function() {
      var fe = ne[Symbol.asyncIterator]();
      executeSchedule(ae, oe, function() {
        fe.next().then(function(ye) {
          ye.done ? ae.complete() : ae.next(ye.value);
        });
      }, 0, !0);
    });
  });
}
function scheduleReadableStreamLike(ne, oe) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(ne), oe);
}
function scheduled(ne, oe) {
  if (ne != null) {
    if (isInteropObservable(ne))
      return scheduleObservable(ne, oe);
    if (isArrayLike(ne))
      return scheduleArray(ne, oe);
    if (isPromise(ne))
      return schedulePromise(ne, oe);
    if (isAsyncIterable(ne))
      return scheduleAsyncIterable(ne, oe);
    if (isIterable(ne))
      return scheduleIterable(ne, oe);
    if (isReadableStreamLike(ne))
      return scheduleReadableStreamLike(ne, oe);
  }
  throw createInvalidObservableTypeError(ne);
}
function from(ne, oe) {
  return oe ? scheduled(ne, oe) : innerFrom(ne);
}
function of() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne);
  return from(ne, ae);
}
var EmptyError = createErrorClass(function(ne) {
  return function() {
    ne(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function firstValueFrom(ne, oe) {
  var ae = typeof oe == "object";
  return new Promise(function(fe, ye) {
    var ge = new SafeSubscriber({
      next: function(we) {
        fe(we), ge.unsubscribe();
      },
      error: ye,
      complete: function() {
        ae ? fe(oe.defaultValue) : ye(new EmptyError());
      }
    });
    ne.subscribe(ge);
  });
}
function map(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(ge) {
      fe.next(ne.call(oe, ge, ye++));
    }));
  });
}
var isArray$1 = Array.isArray;
function callOrApply(ne, oe) {
  return isArray$1(oe) ? ne.apply(void 0, __spreadArray([], __read(oe))) : ne(oe);
}
function mapOneOrManyArgs(ne) {
  return map(function(oe) {
    return callOrApply(ne, oe);
  });
}
var isArray = Array.isArray, getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(ne) {
  if (ne.length === 1) {
    var oe = ne[0];
    if (isArray(oe))
      return { args: oe, keys: null };
    if (isPOJO(oe)) {
      var ae = getKeys(oe);
      return {
        args: ae.map(function(fe) {
          return oe[fe];
        }),
        keys: ae
      };
    }
  }
  return { args: ne, keys: null };
}
function isPOJO(ne) {
  return ne && typeof ne == "object" && getPrototypeOf(ne) === objectProto;
}
function createObject(ne, oe) {
  return ne.reduce(function(ae, fe, ye) {
    return ae[fe] = oe[ye], ae;
  }, {});
}
function combineLatest() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popResultSelector(ne), ye = argsArgArrayOrObject(ne), ge = ye.args, we = ye.keys;
  if (ge.length === 0)
    return from([], ae);
  var _e = new Observable(combineLatestInit(ge, ae, we ? function(Se) {
    return createObject(we, Se);
  } : identity));
  return fe ? _e.pipe(mapOneOrManyArgs(fe)) : _e;
}
function combineLatestInit(ne, oe, ae) {
  return ae === void 0 && (ae = identity), function(fe) {
    maybeSchedule(oe, function() {
      for (var ye = ne.length, ge = new Array(ye), we = ye, _e = ye, Se = function($e) {
        maybeSchedule(oe, function() {
          var Ne = from(ne[$e], oe), Me = !1;
          Ne.subscribe(createOperatorSubscriber(fe, function(Be) {
            ge[$e] = Be, Me || (Me = !0, _e--), _e || fe.next(ae(ge.slice()));
          }, function() {
            --we || fe.complete();
          }));
        }, fe);
      }, Ie = 0; Ie < ye; Ie++)
        Se(Ie);
    }, fe);
  };
}
function maybeSchedule(ne, oe, ae) {
  ne ? executeSchedule(ae, ne, oe) : oe();
}
function mergeInternals(ne, oe, ae, fe, ye, ge, we, _e) {
  var Se = [], Ie = 0, $e = 0, Ne = !1, Me = function() {
    Ne && !Se.length && !Ie && oe.complete();
  }, Be = function(He) {
    return Ie < fe ? ze(He) : Se.push(He);
  }, ze = function(He) {
    ge && oe.next(He), Ie++;
    var Ze = !1;
    innerFrom(ae(He, $e++)).subscribe(createOperatorSubscriber(oe, function(qe) {
      ye == null || ye(qe), ge ? Be(qe) : oe.next(qe);
    }, function() {
      Ze = !0;
    }, void 0, function() {
      if (Ze)
        try {
          Ie--;
          for (var qe = function() {
            var tt = Se.shift();
            we ? executeSchedule(oe, we, function() {
              return ze(tt);
            }) : ze(tt);
          }; Se.length && Ie < fe; )
            qe();
          Me();
        } catch (tt) {
          oe.error(tt);
        }
    }));
  };
  return ne.subscribe(createOperatorSubscriber(oe, Be, function() {
    Ne = !0, Me();
  })), function() {
    _e == null || _e();
  };
}
function mergeMap(ne, oe, ae) {
  return ae === void 0 && (ae = 1 / 0), isFunction$1(oe) ? mergeMap(function(fe, ye) {
    return map(function(ge, we) {
      return oe(fe, ge, ye, we);
    })(innerFrom(ne(fe, ye)));
  }, ae) : (typeof oe == "number" && (ae = oe), operate(function(fe, ye) {
    return mergeInternals(fe, ye, ne, ae);
  }));
}
function mergeAll(ne) {
  return ne === void 0 && (ne = 1 / 0), mergeMap(identity, ne);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  return concatAll()(from(ne, popScheduler(ne)));
}
function defer(ne) {
  return new Observable(function(oe) {
    innerFrom(ne()).subscribe(oe);
  });
}
function merge() {
  for (var ne = [], oe = 0; oe < arguments.length; oe++)
    ne[oe] = arguments[oe];
  var ae = popScheduler(ne), fe = popNumber(ne, 1 / 0), ye = ne;
  return ye.length ? ye.length === 1 ? innerFrom(ye[0]) : mergeAll(fe)(from(ye, ae)) : EMPTY;
}
function filter(ne, oe) {
  return operate(function(ae, fe) {
    var ye = 0;
    ae.subscribe(createOperatorSubscriber(fe, function(ge) {
      return ne.call(oe, ge, ye++) && fe.next(ge);
    }));
  });
}
function catchError(ne) {
  return operate(function(oe, ae) {
    var fe = null, ye = !1, ge;
    fe = oe.subscribe(createOperatorSubscriber(ae, void 0, void 0, function(we) {
      ge = innerFrom(ne(we, catchError(ne)(oe))), fe ? (fe.unsubscribe(), fe = null, ge.subscribe(ae)) : ye = !0;
    })), ye && (fe.unsubscribe(), fe = null, ge.subscribe(ae));
  });
}
function scanInternals(ne, oe, ae, fe, ye) {
  return function(ge, we) {
    var _e = ae, Se = oe, Ie = 0;
    ge.subscribe(createOperatorSubscriber(we, function($e) {
      var Ne = Ie++;
      Se = _e ? ne(Se, $e, Ne) : (_e = !0, $e), fe && we.next(Se);
    }, ye && function() {
      _e && we.next(Se), we.complete();
    }));
  };
}
function concatMap(ne, oe) {
  return isFunction$1(oe) ? mergeMap(ne, oe, 1) : mergeMap(ne, 1);
}
function take(ne) {
  return ne <= 0 ? function() {
    return EMPTY;
  } : operate(function(oe, ae) {
    var fe = 0;
    oe.subscribe(createOperatorSubscriber(ae, function(ye) {
      ++fe <= ne && (ae.next(ye), ne <= fe && ae.complete());
    }));
  });
}
function scan(ne, oe) {
  return operate(scanInternals(ne, oe, arguments.length >= 2, !0));
}
function share(ne) {
  ne === void 0 && (ne = {});
  var oe = ne.connector, ae = oe === void 0 ? function() {
    return new Subject();
  } : oe, fe = ne.resetOnError, ye = fe === void 0 ? !0 : fe, ge = ne.resetOnComplete, we = ge === void 0 ? !0 : ge, _e = ne.resetOnRefCountZero, Se = _e === void 0 ? !0 : _e;
  return function(Ie) {
    var $e = null, Ne = null, Me = null, Be = 0, ze = !1, He = !1, Ze = function() {
      Ne == null || Ne.unsubscribe(), Ne = null;
    }, qe = function() {
      Ze(), $e = Me = null, ze = He = !1;
    }, tt = function() {
      var Xe = $e;
      qe(), Xe == null || Xe.unsubscribe();
    };
    return operate(function(Xe, ot) {
      Be++, !He && !ze && Ze();
      var pt = Me = Me ?? ae();
      ot.add(function() {
        Be--, Be === 0 && !He && !ze && (Ne = handleReset(tt, Se));
      }), pt.subscribe(ot), $e || ($e = new SafeSubscriber({
        next: function(ht) {
          return pt.next(ht);
        },
        error: function(ht) {
          He = !0, Ze(), Ne = handleReset(qe, ye, ht), pt.error(ht);
        },
        complete: function() {
          ze = !0, Ze(), Ne = handleReset(qe, we), pt.complete();
        }
      }), from(Xe).subscribe($e));
    })(Ie);
  };
}
function handleReset(ne, oe) {
  for (var ae = [], fe = 2; fe < arguments.length; fe++)
    ae[fe - 2] = arguments[fe];
  return oe === !0 ? (ne(), null) : oe === !1 ? null : oe.apply(void 0, __spreadArray([], __read(ae))).pipe(take(1)).subscribe(function() {
    return ne();
  });
}
function shareReplay(ne, oe, ae) {
  var fe, ye, ge, we, _e = !1;
  return ne && typeof ne == "object" ? (fe = ne.bufferSize, we = fe === void 0 ? 1 / 0 : fe, ye = ne.windowTime, oe = ye === void 0 ? 1 / 0 : ye, ge = ne.refCount, _e = ge === void 0 ? !1 : ge, ae = ne.scheduler) : we = ne ?? 1 / 0, share({
    connector: function() {
      return new ReplaySubject(we, oe, ae);
    },
    resetOnError: !0,
    resetOnComplete: !1,
    resetOnRefCountZero: _e
  });
}
function tap(ne, oe, ae) {
  var fe = isFunction$1(ne) || oe || ae ? { next: ne, error: oe, complete: ae } : ne;
  return fe ? operate(function(ye, ge) {
    var we;
    (we = fe.subscribe) === null || we === void 0 || we.call(fe);
    var _e = !0;
    ye.subscribe(createOperatorSubscriber(ge, function(Se) {
      var Ie;
      (Ie = fe.next) === null || Ie === void 0 || Ie.call(fe, Se), ge.next(Se);
    }, function() {
      var Se;
      _e = !1, (Se = fe.complete) === null || Se === void 0 || Se.call(fe), ge.complete();
    }, function(Se) {
      var Ie;
      _e = !1, (Ie = fe.error) === null || Ie === void 0 || Ie.call(fe, Se), ge.error(Se);
    }, function() {
      var Se, Ie;
      _e && ((Se = fe.unsubscribe) === null || Se === void 0 || Se.call(fe)), (Ie = fe.finalize) === null || Ie === void 0 || Ie.call(fe);
    }));
  }) : identity;
}
var g$1 = z$1("mud:block-events-stream"), k$1 = z$1("mud:block-events-stream");
g$1.log = console.debug.bind(console);
k$1.log = console.error.bind(console);
var p$2 = ["rate limit exceeded", "over rate limit", "sender is over rate limit"], B = ["block range exceeded", "backend response too large", "block range is too large", "block is out of range"];
async function* u({ maxBlockRange: ne = 1000n, maxRetryCount: oe = 3, publicClient: ae, ...fe }) {
  let ye = fe.fromBlock, ge = l$3(ne, fe.toBlock - ye), we = 0;
  for (; ye <= fe.toBlock; )
    try {
      let _e = ye + ge;
      g$1("getting logs", { fromBlock: ye, toBlock: _e });
      let Se = await ae.getLogs({ ...fe, fromBlock: ye, toBlock: _e, strict: !0 });
      yield { fromBlock: ye, toBlock: _e, logs: Se }, ye = _e + 1n, ge = l$3(ne, fe.toBlock - ye);
    } catch (_e) {
      if (g$1("error getting logs:", String(_e)), !(_e instanceof Error))
        throw _e;
      if (we < oe && p$2.some((Se) => _e.message.includes(Se))) {
        let Se = 2 * we;
        g$1(`too many requests, retrying in ${Se}s`, _e), await B$2(1e3 * Se), we += 1;
        continue;
      }
      if (B.some((Se) => _e.message.includes(Se))) {
        if (ge /= 2n, ge <= 0n)
          throw new Error("can't reduce block range any further");
        g$1("block range exceeded or too many logs in range, trying a smaller block range", _e);
        continue;
      }
      throw _e;
    }
}
function M$3({ publicClient: ne, blockTag: oe }) {
  return new Observable(function(ae) {
    return ne.watchBlocks({ blockTag: oe, emitOnBegin: !0, onBlock: (fe) => ae.next(fe), onError: (fe) => ae.error(fe) });
  });
}
function K$3(ne, oe) {
  let ae = Array.from(new Set(ne.map((ge) => ge.blockNumber)));
  ae.sort(s$1);
  let fe = ae.map((ge) => {
    let we = ne.filter((_e) => _e.blockNumber === ge);
    if (we.length && (we.sort((_e, Se) => _e.logIndex < Se.logIndex ? -1 : _e.logIndex > Se.logIndex ? 1 : 0), !!we.length))
      return { blockNumber: ge, logs: we };
  }).filter(b$5), ye = ae.length > 0 ? ae[ae.length - 1] : null;
  return oe != null && (ye == null || oe > ye) && fe.push({ blockNumber: oe, logs: [] }), fe;
}
function O(ne) {
  let oe = Object.values(ne.namespaces).flatMap((ae) => Object.values(ae.tables));
  return Object.fromEntries(oe.map((ae) => [ae.label, ae]));
}
var A$1 = { ...O(o$2), ...O(a) }, K$2 = Object.values(A$1).map((ne) => ne.tableId), L$1 = { ...A$1.Tables, keySchema: ia(Xi$1(A$1.Tables)), valueSchema: ia(Zi(A$1.Tables)) }, V$2 = ((ne) => (ne.INITIALIZE = "initialize", ne.SNAPSHOT = "snapshot", ne.RPC = "rpc", ne.LIVE = "live", ne))(V$2 || {});
function j$1(ne) {
  return { eventName: "Store_SetRecord", address: ne.address, args: { tableId: L$1.tableId, keyTuple: Yt(L$1.keySchema, { tableId: ne.tableId }), ...N$3(L$1.valueSchema, { fieldLayout: _i(ne.valueSchema), keySchema: zi(ne.keySchema), valueSchema: Ji(ne.valueSchema), abiEncodedKeyNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.keySchema)]), abiEncodedFieldNames: encodeAbiParameters(parseAbiParameters("string[]"), [Object.keys(ne.valueSchema)]) }) } };
}
function P$2(ne) {
  return [...ne.map(j$1), ...ne.flatMap((oe) => oe.records.map((ae) => ({ eventName: "Store_SetRecord", address: oe.address, args: { tableId: oe.tableId, keyTuple: Yt(ia(Xi$1(oe)), ae.key), ...N$3(ia(Zi(oe)), ae.value) } })))];
}
var S = z$1("mud:store-sync"), he$1 = z$1("mud:store-sync");
S.log = console.debug.bind(console);
he$1.log = console.error.bind(console);
var I$3 = S.extend("getSnapshot");
async function U$2({ chainId: ne, address: oe, filters: ae, initialState: fe, initialBlockLogs: ye, indexerUrl: ge }) {
  if (ye && fe)
    throw new Error("Only one of initialBlockLogs or initialState should be provided.");
  if (ye)
    return ye;
  if (fe)
    return { blockNumber: fe.blockNumber, logs: P$2(fe.tables) };
  if (!ge)
    return;
  let we = new URL(ge).origin, _e = s$3({ url: we }), Se = g$5({ url: `${we}/trpc` });
  I$3("fetching logs from indexer via get", ge);
  let Ie = await _e.getLogs({ chainId: ne, address: oe, filters: ae });
  if (be(Ie))
    return Ie.ok;
  console.warn(Ie.error);
  try {
    return I$3("fetching logs from indexer via trpc", ge), await Se.getLogs.query({ chainId: ne, address: oe, filters: ae });
  } catch ($e) {
    if ($e instanceof TRPCClientError) {
      I$3("failed to fetch logs, fetching table records instead", ge);
      let Ne = await Se.findAll.query({ chainId: ne, address: oe, filters: ae });
      return console.warn(`The indexer at ${ge} appears to be outdated. Consider upgrading to a recent version for better performance.`), Ne.blockNumber == null ? void 0 : { blockNumber: Ne.blockNumber, logs: P$2(Ne.tables) };
    }
    throw $e;
  }
}
async function* q$1({ storageAdapter: ne, logFilter: oe, ...ae }) {
  for await (let { logs: fe, toBlock: ye } of u(ae)) {
    let ge = K$3(oe ? fe.filter(oe) : fe, ye);
    for (let we of ge)
      await ne(we), yield we;
  }
}
var m = S.extend("createStoreSync"), We = K$2.map((ne) => ({ tableId: ne }));
async function Et({ storageAdapter: ne, onProgress: oe, publicClient: ae, address: fe, filters: ye = [], tableIds: ge = [], followBlockTag: we = "latest", startBlock: _e = 0n, maxBlockRange: Se, initialState: Ie, initialBlockLogs: $e, indexerUrl: Ne }) {
  let Me = ye.length || ge.length ? [...ye, ...ge.map((Ft) => ({ tableId: Ft })), ...We] : [], Be = Me.length ? (Ft) => Me.some((on) => on.tableId === Ft.args.tableId && (on.key0 == null || on.key0 === Ft.args.keyTuple[0]) && (on.key1 == null || on.key1 === Ft.args.keyTuple[1])) : void 0, ze = defer(async () => {
    var en;
    let Ft = ((en = ae.chain) == null ? void 0 : en.id) ?? await ae.getChainId();
    oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Getting snapshot" });
    let on = await U$2({ chainId: Ft, address: fe, filters: Me, initialState: Ie, initialBlockLogs: $e, indexerUrl: Ne !== !1 ? Ne ?? (ae.chain && "indexerUrl" in ae.chain && typeof ae.chain.indexerUrl == "string" ? ae.chain.indexerUrl : void 0) : void 0 });
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Got snapshot" }), on;
  }).pipe(catchError((Ft) => (m("error getting snapshot", Ft), oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: _e, message: "Failed to get snapshot" }), of(void 0))), shareReplay(1)), He = ze.pipe(filter(b$5), concatMap(async ({ blockNumber: Ft, logs: on }) => {
    m("hydrating", on.length, "logs to block", Ft), oe == null || oe({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: Ft, message: "Hydrating from snapshot" });
    let en = Math.max(100, Math.floor(on.length / 50)), wn = Array.from(m$4(on, en));
    for (let [Zt, pn] of wn.entries())
      await ne({ blockNumber: Ft, logs: pn }), oe == null || oe({ step: "snapshot", percentage: (Zt + 1) / wn.length * 100, latestBlockNumber: 0n, lastBlockNumberProcessed: Ft, message: "Hydrating from snapshot" }), await N$5();
    return oe == null || oe({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: Ft, message: "Hydrated from snapshot" }), { blockNumber: Ft, logs: on };
  }), shareReplay(1)), Ze = ze.pipe(map((Ft) => a$3((Ft == null ? void 0 : Ft.blockNumber) ?? 0n, _e)), tap((Ft) => m("starting sync from block", Ft))), qe = M$3({ publicClient: ae, blockTag: we }).pipe(shareReplay(1)), tt = qe.pipe(map((Ft) => Ft.number), tap((Ft) => {
    m("on block number", Ft, "for", we, "block tag");
  }), shareReplay(1)), Xe = null, ot = null, pt = null, ht = combineLatest([Ze, tt]).pipe(map(([Ft, on]) => ({ startBlock: Ft, endBlock: on })), tap((Ft) => {
    Xe = Ft.startBlock, ot = Ft.endBlock;
  }), concatMap((Ft) => {
    let on = q$1({ publicClient: ae, address: fe, events: p$3, maxBlockRange: Se, fromBlock: pt ? a$3(Ft.startBlock, pt + 1n) : Ft.startBlock, toBlock: Ft.endBlock, storageAdapter: ne, logFilter: Be });
    return from(on);
  }), tap(({ blockNumber: Ft, logs: on }) => {
    if (m("stored", on.length, "logs for block", Ft), pt = Ft, Xe != null && ot != null)
      if (Ft < ot) {
        let en = ot - Xe, wn = pt - Xe;
        oe == null || oe({ step: "rpc", percentage: Number(wn * 1000n / en) / 10, latestBlockNumber: ot, lastBlockNumberProcessed: pt, message: "Hydrating from RPC" });
      } else
        oe == null || oe({ step: "live", percentage: 100, latestBlockNumber: ot, lastBlockNumberProcessed: pt, message: "All caught up!" });
  }), share()), wt = concat(He, ht).pipe(share()), gt = 10, It = wt.pipe(scan((Ft, on) => [on, ...Ft].slice(0, gt), []), filter((Ft) => Ft.length > 0), shareReplay(1));
  async function Nt(Ft) {
    m("waiting for tx", Ft);
    let on = It.pipe(mergeMap(async (en) => {
      for (let wn of en)
        if (wn.logs.map((Zt) => Zt.transactionHash).includes(Ft))
          return { blockNumber: wn.blockNumber, status: "success", transactionHash: Ft };
      try {
        let wn = en[0];
        m("fetching tx receipt for block", wn.blockNumber);
        let { status: Zt, blockNumber: pn, transactionHash: un } = await ae.getTransactionReceipt({ hash: Ft });
        if (wn.blockNumber >= pn)
          return { status: Zt, blockNumber: pn, transactionHash: un };
      } catch (wn) {
        if (wn instanceof TransactionReceiptNotFoundError)
          return;
        throw wn;
      }
    }), tap((en) => m("has tx?", Ft, en)));
    return await firstValueFrom(on.pipe(filter(b$5)));
  }
  return { latestBlock$: qe, latestBlockNumber$: tt, storedBlockLogs$: wt, waitForTransaction: Nt };
}
function L(ne) {
  return ne.eventName === "Store_SetRecord" && ne.args.tableId === L$1.tableId;
}
function K$1(ne) {
  let [oe, ...ae] = ne.args.keyTuple;
  ae.length && console.warn("registerSchema event is expected to have only one key in key tuple, but got multiple", ne);
  let fe = _$2(oe), ye = j$3(L$1.valueSchema, concatHex([ne.args.staticData, ne.args.encodedLengths, ne.args.dynamicData])), ge = D$1(ye.keySchema), we = D$1(ye.valueSchema), _e = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedKeyNames)[0], Se = decodeAbiParameters(parseAbiParameters("string[]"), ye.abiEncodedFieldNames)[0], Ie = [...we.staticFields, ...we.dynamicFields], $e = Object.fromEntries(ge.staticFields.map((Me, Be) => [_e[Be], { type: Me, internalType: Me }])), Ne = Object.fromEntries(Ie.map((Me, Be) => [Se[Be], { type: Me, internalType: Me }]));
  return { address: ne.address, type: fe.type, namespace: fe.namespace, name: fe.name, tableId: oe, schema: { ...$e, ...Ne }, key: Object.keys($e), keySchema: ia($e), valueSchema: ia(Ne) };
}
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function ne(oe, ae) {
    return "Cannot apply '" + oe + "' to '" + ae.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function ne(oe, ae) {
    return "[mobx.array] Index out of bounds, " + oe + " is larger than " + ae;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function ne(oe) {
    return "Cannot initialize from classes that inherit from Map: " + oe.constructor.name;
  },
  20: function ne(oe) {
    return "Cannot initialize map from " + oe;
  },
  21: function ne(oe) {
    return "Cannot convert to map from '" + oe + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function ne(oe) {
    return "Cannot obtain administration from " + oe;
  },
  25: function ne(oe, ae) {
    return "the entry '" + oe + "' does not exist in the observable map '" + ae + "'";
  },
  26: "please specify a property",
  27: function ne(oe, ae) {
    return "no observable property '" + oe.toString() + "' found on the observable object '" + ae + "'";
  },
  28: function ne(oe) {
    return "Cannot obtain atom from " + oe;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function ne(oe, ae) {
    return "Cycle detected in computation " + oe + ": " + ae;
  },
  33: function ne(oe) {
    return "The setter of computed value '" + oe + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function ne(oe) {
    return "[ComputedValue '" + oe + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function ne(oe) {
    return "[mobx] `observableArray." + oe + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + oe + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
}, errors = process.env.NODE_ENV !== "production" ? niceErrors : {};
function die(ne) {
  for (var oe = arguments.length, ae = new Array(oe > 1 ? oe - 1 : 0), fe = 1; fe < oe; fe++)
    ae[fe - 1] = arguments[fe];
  if (process.env.NODE_ENV !== "production") {
    var ye = typeof ne == "string" ? ne : errors[ne];
    throw typeof ye == "function" && (ye = ye.apply(null, ae)), new Error("[MobX] " + ye);
  }
  throw new Error(typeof ne == "number" ? "[MobX] minified error nr: " + ne + (ae.length ? " " + ae.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + ne);
}
var mockGlobal = {};
function getGlobal() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : mockGlobal;
}
var assign = Object.assign, getDescriptor = Object.getOwnPropertyDescriptor, defineProperty = Object.defineProperty, objectPrototype = Object.prototype, EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy < "u", plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  hasProxy || die(process.env.NODE_ENV !== "production" ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
}
function warnAboutProxyRequirement(ne) {
  process.env.NODE_ENV !== "production" && globalState.verifyProxies && die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + ne);
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(ne) {
  var oe = !1;
  return function() {
    if (!oe)
      return oe = !0, ne.apply(this, arguments);
  };
}
var noop = function ne() {
};
function isFunction(ne) {
  return typeof ne == "function";
}
function isStringish(ne) {
  var oe = typeof ne;
  switch (oe) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function isObject(ne) {
  return ne !== null && typeof ne == "object";
}
function isPlainObject(ne) {
  if (!isObject(ne))
    return !1;
  var oe = Object.getPrototypeOf(ne);
  if (oe == null)
    return !0;
  var ae = Object.hasOwnProperty.call(oe, "constructor") && oe.constructor;
  return typeof ae == "function" && ae.toString() === plainObjectString;
}
function isGenerator(ne) {
  var oe = ne == null ? void 0 : ne.constructor;
  return oe ? oe.name === "GeneratorFunction" || oe.displayName === "GeneratorFunction" : !1;
}
function addHiddenProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: ae
  });
}
function addHiddenFinalProp(ne, oe, ae) {
  defineProperty(ne, oe, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: ae
  });
}
function createInstanceofPredicate(ne, oe) {
  var ae = "isMobX" + ne;
  return oe.prototype[ae] = !0, function(fe) {
    return isObject(fe) && fe[ae] === !0;
  };
}
function isES6Map(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Map]";
}
function isPlainES6Map(ne) {
  var oe = Object.getPrototypeOf(ne), ae = Object.getPrototypeOf(oe), fe = Object.getPrototypeOf(ae);
  return fe === null;
}
function isES6Set(ne) {
  return ne != null && Object.prototype.toString.call(ne) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols < "u";
function getPlainObjectKeys(ne) {
  var oe = Object.keys(ne);
  if (!hasGetOwnPropertySymbols)
    return oe;
  var ae = Object.getOwnPropertySymbols(ne);
  return ae.length ? [].concat(oe, ae.filter(function(fe) {
    return objectPrototype.propertyIsEnumerable.call(ne, fe);
  })) : oe;
}
var ownKeys = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(ne) {
  return Object.getOwnPropertyNames(ne).concat(Object.getOwnPropertySymbols(ne));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function stringifyKey(ne) {
  return typeof ne == "string" ? ne : typeof ne == "symbol" ? ne.toString() : new String(ne).toString();
}
function toPrimitive(ne) {
  return ne === null ? null : typeof ne == "object" ? "" + ne : ne;
}
function hasProp(ne, oe) {
  return objectPrototype.hasOwnProperty.call(ne, oe);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function ne(oe) {
  var ae = {};
  return ownKeys(oe).forEach(function(fe) {
    ae[fe] = getDescriptor(oe, fe);
  }), ae;
};
function getFlag(ne, oe) {
  return !!(ne & oe);
}
function setFlag(ne, oe, ae) {
  return ae ? ne |= oe : ne &= ~oe, ne;
}
function _arrayLikeToArray(ne, oe) {
  (oe == null || oe > ne.length) && (oe = ne.length);
  for (var ae = 0, fe = Array(oe); ae < oe; ae++)
    fe[ae] = ne[ae];
  return fe;
}
function _defineProperties(ne, oe) {
  for (var ae = 0; ae < oe.length; ae++) {
    var fe = oe[ae];
    fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(ne, _toPropertyKey(fe.key), fe);
  }
}
function _createClass(ne, oe, ae) {
  return oe && _defineProperties(ne.prototype, oe), ae && _defineProperties(ne, ae), Object.defineProperty(ne, "prototype", {
    writable: !1
  }), ne;
}
function _createForOfIteratorHelperLoose(ne, oe) {
  var ae = typeof Symbol < "u" && ne[Symbol.iterator] || ne["@@iterator"];
  if (ae)
    return (ae = ae.call(ne)).next.bind(ae);
  if (Array.isArray(ne) || (ae = _unsupportedIterableToArray(ne)) || oe && ne && typeof ne.length == "number") {
    ae && (ne = ae);
    var fe = 0;
    return function() {
      return fe >= ne.length ? {
        done: !0
      } : {
        done: !1,
        value: ne[fe++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        ({}).hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(ne, oe) {
  ne.prototype = Object.create(oe.prototype), ne.prototype.constructor = ne, _setPrototypeOf(ne, oe);
}
function _setPrototypeOf(ne, oe) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ae, fe) {
    return ae.__proto__ = fe, ae;
  }, _setPrototypeOf(ne, oe);
}
function _toPrimitive(ne, oe) {
  if (typeof ne != "object" || !ne)
    return ne;
  var ae = ne[Symbol.toPrimitive];
  if (ae !== void 0) {
    var fe = ae.call(ne, oe || "default");
    if (typeof fe != "object")
      return fe;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (oe === "string" ? String : Number)(ne);
}
function _toPropertyKey(ne) {
  var oe = _toPrimitive(ne, "string");
  return typeof oe == "symbol" ? oe : oe + "";
}
function _unsupportedIterableToArray(ne, oe) {
  if (ne) {
    if (typeof ne == "string")
      return _arrayLikeToArray(ne, oe);
    var ae = {}.toString.call(ne).slice(8, -1);
    return ae === "Object" && ne.constructor && (ae = ne.constructor.name), ae === "Map" || ae === "Set" ? Array.from(ne) : ae === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ae) ? _arrayLikeToArray(ne, oe) : void 0;
  }
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(ne) {
  function oe(ae, fe) {
    if (is20223Decorator(fe))
      return ne.decorate_20223_(ae, fe);
    storeAnnotation(ae, fe, ne);
  }
  return Object.assign(oe, ne);
}
function storeAnnotation(ne, oe, ae) {
  if (hasProp(ne, storedAnnotationsSymbol) || addHiddenProp(ne, storedAnnotationsSymbol, _extends({}, ne[storedAnnotationsSymbol])), process.env.NODE_ENV !== "production" && isOverride(ae) && !hasProp(ne[storedAnnotationsSymbol], oe)) {
    var fe = ne.constructor.name + ".prototype." + oe.toString();
    die("'" + fe + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(ne, ae, oe), isOverride(ae) || (ne[storedAnnotationsSymbol][oe] = ae);
}
function assertNotDecorated(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne[storedAnnotationsSymbol], ae)) {
    var fe = ne.constructor.name + ".prototype." + ae.toString(), ye = ne[storedAnnotationsSymbol][ae].annotationType_, ge = oe.annotationType_;
    die("Cannot apply '@" + ge + "' to '" + fe + "':" + (`
The field is already decorated with '@` + ye + "'.") + `
Re-decorating fields is not allowed.
Use '@override' decorator for methods overridden by subclass.`);
  }
}
function is20223Decorator(ne) {
  return typeof ne == "object" && typeof ne.kind == "string";
}
function assert20223DecoratorType(ne, oe) {
  process.env.NODE_ENV !== "production" && !oe.includes(ne.kind) && die("The decorator applied to '" + String(ne.name) + "' cannot be used on a " + ne.kind + " element");
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration"), Atom = /* @__PURE__ */ function() {
  function ne(ae) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Atom@" + getNextId() : "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = ae;
  }
  var oe = ne.prototype;
  return oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.reportObserved = function() {
    return reportObserved(this);
  }, oe.reportChanged = function() {
    startBatch(), propagateChanged(this), endBatch();
  }, oe.toString = function() {
    return this.name_;
  }, _createClass(ne, [{
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(ne, oe, ae) {
  oe === void 0 && (oe = noop), ae === void 0 && (ae = noop);
  var fe = new Atom(ne);
  return oe !== noop && onBecomeObserved(fe, oe), ae !== noop && onBecomeUnobserved(fe, ae), fe;
}
function identityComparer(ne, oe) {
  return ne === oe;
}
function structuralComparer(ne, oe) {
  return deepEqual(ne, oe);
}
function shallowComparer(ne, oe) {
  return deepEqual(ne, oe, 1);
}
function defaultComparer(ne, oe) {
  return Object.is ? Object.is(ne, oe) : ne === oe ? ne !== 0 || 1 / ne === 1 / oe : ne !== ne && oe !== oe;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(ne, oe, ae) {
  return isObservable(ne) ? ne : Array.isArray(ne) ? observable.array(ne, {
    name: ae
  }) : isPlainObject(ne) ? observable.object(ne, void 0, {
    name: ae
  }) : isES6Map(ne) ? observable.map(ne, {
    name: ae
  }) : isES6Set(ne) ? observable.set(ne, {
    name: ae
  }) : typeof ne == "function" && !isAction(ne) && !isFlow(ne) ? isGenerator(ne) ? flow(ne) : autoAction(ae, ne) : ne;
}
function shallowEnhancer(ne, oe, ae) {
  if (ne == null || isObservableObject(ne) || isObservableArray(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (Array.isArray(ne))
    return observable.array(ne, {
      name: ae,
      deep: !1
    });
  if (isPlainObject(ne))
    return observable.object(ne, void 0, {
      name: ae,
      deep: !1
    });
  if (isES6Map(ne))
    return observable.map(ne, {
      name: ae,
      deep: !1
    });
  if (isES6Set(ne))
    return observable.set(ne, {
      name: ae,
      deep: !1
    });
  process.env.NODE_ENV !== "production" && die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(ne) {
  return ne;
}
function refStructEnhancer(ne, oe) {
  return process.env.NODE_ENV !== "production" && isObservable(ne) && die("observable.struct should not be used with observable values"), deepEqual(ne, oe) ? oe : ne;
}
var OVERRIDE = "override";
function isOverride(ne) {
  return ne.annotationType_ === OVERRIDE;
}
function createActionAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(ne, oe, ae, fe) {
  var ye;
  if ((ye = this.options_) != null && ye.bound)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if (isAction(ae.value))
    return 1;
  var ge = createActionDescriptor(ne, this, oe, ae, !1);
  return defineProperty(fe, oe, ge), 2;
}
function extend_$1(ne, oe, ae, fe) {
  var ye = createActionDescriptor(ne, this, oe, ae);
  return ne.defineProperty_(oe, ye, fe);
}
function decorate_20223_$1(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method", "field"]);
  var ae = oe.kind, fe = oe.name, ye = oe.addInitializer, ge = this, we = function(Ie) {
    var $e, Ne, Me, Be;
    return createAction(($e = (Ne = ge.options_) == null ? void 0 : Ne.name) != null ? $e : fe.toString(), Ie, (Me = (Be = ge.options_) == null ? void 0 : Be.autoAction) != null ? Me : !1);
  };
  if (ae == "field") {
    ye(function() {
      storeAnnotation(this, fe, ge);
    });
    return;
  }
  if (ae == "method") {
    var _e;
    return isAction(ne) || (ne = we(ne)), (_e = this.options_) != null && _e.bound && ye(function() {
      var Se = this, Ie = Se[fe].bind(Se);
      Ie.isMobxAction = !0, Se[fe] = Ie;
    }), ne;
  }
  die("Cannot apply '" + ge.annotationType_ + "' to '" + String(fe) + "' (kind: " + ae + "):" + (`
'` + ge.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ge = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(ge) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a function value."));
}
function createActionDescriptor(ne, oe, ae, fe, ye) {
  var ge, we, _e, Se, Ie, $e, Ne;
  ye === void 0 && (ye = globalState.safeDescriptors), assertActionDescriptor(ne, oe, ae, fe);
  var Me = fe.value;
  if ((ge = oe.options_) != null && ge.bound) {
    var Be;
    Me = Me.bind((Be = ne.proxy_) != null ? Be : ne.target_);
  }
  return {
    value: createAction(
      (we = (_e = oe.options_) == null ? void 0 : _e.name) != null ? we : ae.toString(),
      Me,
      (Se = (Ie = oe.options_) == null ? void 0 : Ie.autoAction) != null ? Se : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      ($e = oe.options_) != null && $e.bound ? (Ne = ne.proxy_) != null ? Ne : ne.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: ye ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !ye
  };
}
function createFlowAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(ne, oe, ae, fe) {
  var ye;
  if (fe === ne.target_)
    return this.extend_(ne, oe, ae, !1) === null ? 0 : 2;
  if ((ye = this.options_) != null && ye.bound && (!hasProp(ne.target_, oe) || !isFlow(ne.target_[oe])) && this.extend_(ne, oe, ae, !1) === null)
    return 0;
  if (isFlow(ae.value))
    return 1;
  var ge = createFlowDescriptor(ne, this, oe, ae, !1, !1);
  return defineProperty(fe, oe, ge), 2;
}
function extend_$2(ne, oe, ae, fe) {
  var ye, ge = createFlowDescriptor(ne, this, oe, ae, (ye = this.options_) == null ? void 0 : ye.bound);
  return ne.defineProperty_(oe, ge, fe);
}
function decorate_20223_$2(ne, oe) {
  var ae;
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["method"]);
  var fe = oe.name, ye = oe.addInitializer;
  return isFlow(ne) || (ne = flow(ne)), (ae = this.options_) != null && ae.bound && ye(function() {
    var ge = this, we = ge[fe].bind(ge);
    we.isMobXFlow = !0, ge[fe] = we;
  }), ne;
}
function assertFlowDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ge = fe.value;
  process.env.NODE_ENV !== "production" && !isFunction(ge) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on properties with a generator function value."));
}
function createFlowDescriptor(ne, oe, ae, fe, ye, ge) {
  ge === void 0 && (ge = globalState.safeDescriptors), assertFlowDescriptor(ne, oe, ae, fe);
  var we = fe.value;
  if (isFlow(we) || (we = flow(we)), ye) {
    var _e;
    we = we.bind((_e = ne.proxy_) != null ? _e : ne.target_), we.isMobXFlow = !0;
  }
  return {
    value: we,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: ge ? ne.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !ge
  };
}
function createComputedAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$3(ne, oe, ae, fe) {
  return assertComputedDescriptor(ne, this, oe, ae), ne.defineComputedProperty_(oe, _extends({}, this.options_, {
    get: ae.get,
    set: ae.set
  }), fe);
}
function decorate_20223_$3(ne, oe) {
  process.env.NODE_ENV !== "production" && assert20223DecoratorType(oe, ["getter"]);
  var ae = this, fe = oe.name, ye = oe.addInitializer;
  return ye(function() {
    var ge = asObservableObject(this)[$mobx], we = _extends({}, ae.options_, {
      get: ne,
      context: this
    });
    we.name || (we.name = process.env.NODE_ENV !== "production" ? ge.name_ + "." + fe.toString() : "ObservableObject." + fe.toString()), ge.values_.set(fe, new ComputedValue(we));
  }), function() {
    return this[$mobx].getObservablePropValue_(fe);
  };
}
function assertComputedDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_, ge = fe.get;
  process.env.NODE_ENV !== "production" && !ge && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' can only be used on getter(+setter) properties."));
}
function createObservableAnnotation(ne, oe) {
  return {
    annotationType_: ne,
    options_: oe,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(ne, oe, ae) {
  return this.extend_(ne, oe, ae, !1) === null ? 0 : 1;
}
function extend_$4(ne, oe, ae, fe) {
  var ye, ge;
  return assertObservableDescriptor(ne, this, oe, ae), ne.defineObservableProperty_(oe, ae.value, (ye = (ge = this.options_) == null ? void 0 : ge.enhancer) != null ? ye : deepEnhancer, fe);
}
function decorate_20223_$4(ne, oe) {
  if (process.env.NODE_ENV !== "production") {
    if (oe.kind === "field")
      throw die("Please use `@observable accessor " + String(oe.name) + "` instead of `@observable " + String(oe.name) + "`");
    assert20223DecoratorType(oe, ["accessor"]);
  }
  var ae = this, fe = oe.kind, ye = oe.name, ge = /* @__PURE__ */ new WeakSet();
  function we(_e, Se) {
    var Ie, $e, Ne = asObservableObject(_e)[$mobx], Me = new ObservableValue(Se, (Ie = ($e = ae.options_) == null ? void 0 : $e.enhancer) != null ? Ie : deepEnhancer, process.env.NODE_ENV !== "production" ? Ne.name_ + "." + ye.toString() : "ObservableObject." + ye.toString(), !1);
    Ne.values_.set(ye, Me), ge.add(_e);
  }
  if (fe == "accessor")
    return {
      get: function() {
        return ge.has(this) || we(this, ne.get.call(this)), this[$mobx].getObservablePropValue_(ye);
      },
      set: function(Se) {
        return ge.has(this) || we(this, Se), this[$mobx].setObservablePropValue_(ye, Se);
      },
      init: function(Se) {
        return ge.has(this) || we(this, Se), Se;
      }
    };
}
function assertObservableDescriptor(ne, oe, ae, fe) {
  var ye = oe.annotationType_;
  process.env.NODE_ENV !== "production" && !("value" in fe) && die("Cannot apply '" + ye + "' to '" + ne.name_ + "." + ae.toString() + "':" + (`
'` + ye + "' cannot be used on getter/setter properties"));
}
var AUTO = "true", autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(ne) {
  return {
    annotationType_: AUTO,
    options_: ne,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(ne, oe, ae, fe) {
  var ye, ge;
  if (ae.get)
    return computed.make_(ne, oe, ae, fe);
  if (ae.set) {
    var we = createAction(oe.toString(), ae.set);
    return fe === ne.target_ ? ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: we
    }) === null ? 0 : 2 : (defineProperty(fe, oe, {
      configurable: !0,
      set: we
    }), 2);
  }
  if (fe !== ne.target_ && typeof ae.value == "function") {
    var _e;
    if (isGenerator(ae.value)) {
      var Se, Ie = (Se = this.options_) != null && Se.autoBind ? flow.bound : flow;
      return Ie.make_(ne, oe, ae, fe);
    }
    var $e = (_e = this.options_) != null && _e.autoBind ? autoAction.bound : autoAction;
    return $e.make_(ne, oe, ae, fe);
  }
  var Ne = ((ye = this.options_) == null ? void 0 : ye.deep) === !1 ? observable.ref : observable;
  if (typeof ae.value == "function" && (ge = this.options_) != null && ge.autoBind) {
    var Me;
    ae.value = ae.value.bind((Me = ne.proxy_) != null ? Me : ne.target_);
  }
  return Ne.make_(ne, oe, ae, fe);
}
function extend_$5(ne, oe, ae, fe) {
  var ye, ge;
  if (ae.get)
    return computed.extend_(ne, oe, ae, fe);
  if (ae.set)
    return ne.defineProperty_(oe, {
      configurable: globalState.safeDescriptors ? ne.isPlainObject_ : !0,
      set: createAction(oe.toString(), ae.set)
    }, fe);
  if (typeof ae.value == "function" && (ye = this.options_) != null && ye.autoBind) {
    var we;
    ae.value = ae.value.bind((we = ne.proxy_) != null ? we : ne.target_);
  }
  var _e = ((ge = this.options_) == null ? void 0 : ge.deep) === !1 ? observable.ref : observable;
  return _e.extend_(ne, oe, ae, fe);
}
function decorate_20223_$5(ne, oe) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable", OBSERVABLE_REF = "observable.ref", OBSERVABLE_SHALLOW = "observable.shallow", OBSERVABLE_STRUCT = "observable.struct", defaultCreateObservableOptions = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(ne) {
  return ne || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE), observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
}), observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
}), observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
}), observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(ne) {
  return ne.deep === !0 ? deepEnhancer : ne.deep === !1 ? referenceEnhancer : getEnhancerFromAnnotation(ne.defaultDecorator);
}
function getAnnotationFromOptions(ne) {
  var oe;
  return ne ? (oe = ne.defaultDecorator) != null ? oe : createAutoAnnotation(ne) : void 0;
}
function getEnhancerFromAnnotation(ne) {
  var oe, ae;
  return ne && (oe = (ae = ne.options_) == null ? void 0 : ae.enhancer) != null ? oe : deepEnhancer;
}
function createObservable(ne, oe, ae) {
  if (is20223Decorator(oe))
    return observableAnnotation.decorate_20223_(ne, oe);
  if (isStringish(oe)) {
    storeAnnotation(ne, oe, observableAnnotation);
    return;
  }
  return isObservable(ne) ? ne : isPlainObject(ne) ? observable.object(ne, oe, ae) : Array.isArray(ne) ? observable.array(ne, oe) : isES6Map(ne) ? observable.map(ne, oe) : isES6Set(ne) ? observable.set(ne, oe) : typeof ne == "object" && ne !== null ? ne : observable.box(ne, oe);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableValue(oe, getEnhancerFromOptions(fe), fe.name, !0, fe.equals);
  },
  array: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return (globalState.useProxies === !1 || fe.proxy === !1 ? createLegacyArray : createObservableArray)(oe, getEnhancerFromOptions(fe), fe.name);
  },
  map: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableMap(oe, getEnhancerFromOptions(fe), fe.name);
  },
  set: function ne(oe, ae) {
    var fe = asCreateObservableOptions(ae);
    return new ObservableSet(oe, getEnhancerFromOptions(fe), fe.name);
  },
  object: function ne(oe, ae, fe) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === !1 || (fe == null ? void 0 : fe.proxy) === !1 ? asObservableObject({}, fe) : asDynamicObservableObject({}, fe), oe, ae);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
}, observable = /* @__PURE__ */ assign(createObservable, observableFactories), COMPUTED = "computed", COMPUTED_STRUCT = "computed.struct", computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED), computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
}), computed = function ne(oe, ae) {
  if (is20223Decorator(ae))
    return computedAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, computedAnnotation);
  if (isPlainObject(oe))
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, oe));
  process.env.NODE_ENV !== "production" && (isFunction(oe) || die("First argument to `computed` should be an expression."), isFunction(ae) && die("A setter as second argument is no longer supported, use `{ set: fn }` option instead"));
  var fe = isPlainObject(ae) ? ae : {};
  return fe.get = oe, fe.name || (fe.name = oe.name || ""), new ComputedValue(fe);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor, currentActionId = 0, nextActionId = 1, isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : !1, tmpNameDescriptor = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function createAction(ne, oe, ae, fe) {
  ae === void 0 && (ae = !1), process.env.NODE_ENV !== "production" && (isFunction(oe) || die("`action` can only be invoked on functions"), (typeof ne != "string" || !ne) && die("actions should have valid names, got: '" + ne + "'"));
  function ye() {
    return executeAction(ne, ae, oe, fe || this, arguments);
  }
  return ye.isMobxAction = !0, ye.toString = function() {
    return oe.toString();
  }, isFunctionNameConfigurable && (tmpNameDescriptor.value = ne, defineProperty(ye, "name", tmpNameDescriptor)), ye;
}
function executeAction(ne, oe, ae, fe, ye) {
  var ge = _startAction(ne, oe, fe, ye);
  try {
    return ae.apply(fe, ye);
  } catch (we) {
    throw ge.error_ = we, we;
  } finally {
    _endAction(ge);
  }
}
function _startAction(ne, oe, ae, fe) {
  var ye = process.env.NODE_ENV !== "production" && isSpyEnabled() && !!ne, ge = 0;
  if (process.env.NODE_ENV !== "production" && ye) {
    ge = Date.now();
    var we = fe ? Array.from(fe) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: ne,
      object: ae,
      arguments: we
    });
  }
  var _e = globalState.trackingDerivation, Se = !oe || !_e;
  startBatch();
  var Ie = globalState.allowStateChanges;
  Se && (untrackedStart(), Ie = allowStateChangesStart(!0));
  var $e = allowStateReadsStart(!0), Ne = {
    runAsAction_: Se,
    prevDerivation_: _e,
    prevAllowStateChanges_: Ie,
    prevAllowStateReads_: $e,
    notifySpy_: ye,
    startTime_: ge,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  return currentActionId = Ne.actionId_, Ne;
}
function _endAction(ne) {
  currentActionId !== ne.actionId_ && die(30), currentActionId = ne.parentActionId_, ne.error_ !== void 0 && (globalState.suppressReactionErrors = !0), allowStateChangesEnd(ne.prevAllowStateChanges_), allowStateReadsEnd(ne.prevAllowStateReads_), endBatch(), ne.runAsAction_ && untrackedEnd(ne.prevDerivation_), process.env.NODE_ENV !== "production" && ne.notifySpy_ && spyReportEnd({
    time: Date.now() - ne.startTime_
  }), globalState.suppressReactionErrors = !1;
}
function allowStateChangesStart(ne) {
  var oe = globalState.allowStateChanges;
  return globalState.allowStateChanges = ne, oe;
}
function allowStateChangesEnd(ne) {
  globalState.allowStateChanges = ne;
}
var CREATE = "create", ObservableValue = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, ge, we, _e) {
    var Se;
    return ge === void 0 && (ge = process.env.NODE_ENV !== "production" ? "ObservableValue@" + getNextId() : "ObservableValue"), we === void 0 && (we = !0), _e === void 0 && (_e = comparer.default), Se = ne.call(this, ge) || this, Se.enhancer = void 0, Se.name_ = void 0, Se.equals = void 0, Se.hasUnreportedChange_ = !1, Se.interceptors_ = void 0, Se.changeListeners_ = void 0, Se.value_ = void 0, Se.dehancer = void 0, Se.enhancer = ye, Se.name_ = ge, Se.equals = _e, Se.value_ = ye(fe, void 0, ge), process.env.NODE_ENV !== "production" && we && isSpyEnabled() && spyReport({
      type: CREATE,
      object: Se,
      observableKind: "value",
      debugObjectName: Se.name_,
      newValue: "" + Se.value_
    }), Se;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.dehanceValue = function(ye) {
    return this.dehancer !== void 0 ? this.dehancer(ye) : ye;
  }, ae.set = function(ye) {
    var ge = this.value_;
    if (ye = this.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var we = isSpyEnabled();
      process.env.NODE_ENV !== "production" && we && spyReportStart({
        type: UPDATE,
        object: this,
        observableKind: "value",
        debugObjectName: this.name_,
        newValue: ye,
        oldValue: ge
      }), this.setNewValue_(ye), process.env.NODE_ENV !== "production" && we && spyReportEnd();
    }
  }, ae.prepareNewValue_ = function(ye) {
    if (checkIfStateModificationsAreAllowed(this), hasInterceptors(this)) {
      var ge = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: ye
      });
      if (!ge)
        return globalState.UNCHANGED;
      ye = ge.newValue;
    }
    return ye = this.enhancer(ye, this.value_, this.name_), this.equals(this.value_, ye) ? globalState.UNCHANGED : ye;
  }, ae.setNewValue_ = function(ye) {
    var ge = this.value_;
    this.value_ = ye, this.reportChanged(), hasListeners(this) && notifyListeners(this, {
      type: UPDATE,
      object: this,
      newValue: ye,
      oldValue: ge
    });
  }, ae.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, ae.intercept_ = function(ye) {
    return registerInterceptor(this, ye);
  }, ae.observe_ = function(ye, ge) {
    return ge && ye({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: void 0
    }), registerListener(this, ye);
  }, ae.raw = function() {
    return this.value_;
  }, ae.toJSON = function() {
    return this.get();
  }, ae.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, ae.valueOf = function() {
    return toPrimitive(this.get());
  }, ae[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, oe;
}(Atom), ComputedValue = /* @__PURE__ */ function() {
  function ne(ae) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new CaughtException(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = TraceMode.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, ae.get || die(31), this.derivation = ae.get, this.name_ = ae.name || (process.env.NODE_ENV !== "production" ? "ComputedValue@" + getNextId() : "ComputedValue"), ae.set && (this.setter_ = createAction(process.env.NODE_ENV !== "production" ? this.name_ + "-setter" : "ComputedValue-setter", ae.set)), this.equals_ = ae.equals || (ae.compareStructural || ae.struct ? comparer.structural : comparer.default), this.scope_ = ae.context, this.requiresReaction_ = ae.requiresReaction, this.keepAlive_ = !!ae.keepAlive;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    propagateMaybeChanged(this);
  }, oe.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(fe) {
      return fe();
    });
  }, oe.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(fe) {
      return fe();
    });
  }, oe.get = function() {
    if (this.isComputing && die(32, this.name_, this.derivation), globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      shouldCompute(this) && (this.warnAboutUntrackedRead_(), startBatch(), this.value_ = this.computeValue_(!1), endBatch());
    else if (reportObserved(this), shouldCompute(this)) {
      var fe = globalState.trackingContext;
      this.keepAlive_ && !fe && (globalState.trackingContext = this), this.trackAndCompute() && propagateChangeConfirmed(this), globalState.trackingContext = fe;
    }
    var ye = this.value_;
    if (isCaughtException(ye))
      throw ye.cause;
    return ye;
  }, oe.set = function(fe) {
    if (this.setter_) {
      this.isRunningSetter && die(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, fe);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      die(34, this.name_);
  }, oe.trackAndCompute = function() {
    var fe = this.value_, ye = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    ), ge = this.computeValue_(!0), we = ye || isCaughtException(fe) || isCaughtException(ge) || !this.equals_(fe, ge);
    return we && (this.value_ = ge, process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      observableKind: "computed",
      debugObjectName: this.name_,
      object: this.scope_,
      type: "update",
      oldValue: fe,
      newValue: ge
    })), we;
  }, oe.computeValue_ = function(fe) {
    this.isComputing = !0;
    var ye = allowStateChangesStart(!1), ge;
    if (fe)
      ge = trackDerivedFunction(this, this.derivation, this.scope_);
    else if (globalState.disableErrorBoundaries === !0)
      ge = this.derivation.call(this.scope_);
    else
      try {
        ge = this.derivation.call(this.scope_);
      } catch (we) {
        ge = new CaughtException(we);
      }
    return allowStateChangesEnd(ye), this.isComputing = !1, ge;
  }, oe.suspend_ = function() {
    this.keepAlive_ || (clearObserving(this), this.value_ = void 0, process.env.NODE_ENV !== "production" && this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access."));
  }, oe.observe_ = function(fe, ye) {
    var ge = this, we = !0, _e = void 0;
    return autorun(function() {
      var Se = ge.get();
      if (!we || ye) {
        var Ie = untrackedStart();
        fe({
          observableKind: "computed",
          debugObjectName: ge.name_,
          type: UPDATE,
          object: ge,
          newValue: Se,
          oldValue: _e
        }), untrackedEnd(Ie);
      }
      we = !1, _e = Se;
    });
  }, oe.warnAboutUntrackedRead_ = function() {
    process.env.NODE_ENV !== "production" && (this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."), (typeof this.requiresReaction_ == "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) && console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."));
  }, oe.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, oe.valueOf = function() {
    return toPrimitive(this.get());
  }, oe[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, _createClass(ne, [{
    key: "isComputing",
    get: function() {
      return getFlag(this.flags_, ne.isComputingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isComputingMask_, fe);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return getFlag(this.flags_, ne.isRunningSetterMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningSetterMask_, fe);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return getFlag(this.flags_, ne.isBeingObservedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isBeingObservedMask_, fe);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return getFlag(this.flags_, ne.isPendingUnobservationMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isPendingUnobservationMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue), IDerivationState_;
(function(ne) {
  ne[ne.NOT_TRACKING_ = -1] = "NOT_TRACKING_", ne[ne.UP_TO_DATE_ = 0] = "UP_TO_DATE_", ne[ne.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", ne[ne.STALE_ = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(ne) {
  ne[ne.NONE = 0] = "NONE", ne[ne.LOG = 1] = "LOG", ne[ne.BREAK = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function ne(oe) {
  this.cause = void 0, this.cause = oe;
};
function isCaughtException(ne) {
  return ne instanceof CaughtException;
}
function shouldCompute(ne) {
  switch (ne.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return !1;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return !0;
    case IDerivationState_.POSSIBLY_STALE_: {
      for (var oe = allowStateReadsStart(!0), ae = untrackedStart(), fe = ne.observing_, ye = fe.length, ge = 0; ge < ye; ge++) {
        var we = fe[ge];
        if (isComputedValue(we)) {
          if (globalState.disableErrorBoundaries)
            we.get();
          else
            try {
              we.get();
            } catch {
              return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
            }
          if (ne.dependenciesState_ === IDerivationState_.STALE_)
            return untrackedEnd(ae), allowStateReadsEnd(oe), !0;
        }
      }
      return changeDependenciesStateTo0(ne), untrackedEnd(ae), allowStateReadsEnd(oe), !1;
    }
  }
}
function checkIfStateModificationsAreAllowed(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = ne.observers_.size > 0;
    !globalState.allowStateChanges && (oe || globalState.enforceActions === "always") && console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + ne.name_);
  }
}
function checkIfStateReadsAreAllowed(ne) {
  process.env.NODE_ENV !== "production" && !globalState.allowStateReads && globalState.observableRequiresReaction && console.warn("[mobx] Observable '" + ne.name_ + "' being read outside a reactive context.");
}
function trackDerivedFunction(ne, oe, ae) {
  var fe = allowStateReadsStart(!0);
  changeDependenciesStateTo0(ne), ne.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    ne.runId_ === 0 ? 100 : ne.observing_.length
  ), ne.unboundDepsCount_ = 0, ne.runId_ = ++globalState.runId;
  var ye = globalState.trackingDerivation;
  globalState.trackingDerivation = ne, globalState.inBatch++;
  var ge;
  if (globalState.disableErrorBoundaries === !0)
    ge = oe.call(ae);
  else
    try {
      ge = oe.call(ae);
    } catch (we) {
      ge = new CaughtException(we);
    }
  return globalState.inBatch--, globalState.trackingDerivation = ye, bindDependencies(ne), warnAboutDerivationWithoutDependencies(ne), allowStateReadsEnd(fe), ge;
}
function warnAboutDerivationWithoutDependencies(ne) {
  process.env.NODE_ENV !== "production" && ne.observing_.length === 0 && (typeof ne.requiresObservable_ == "boolean" ? ne.requiresObservable_ : globalState.reactionRequiresObservable) && console.warn("[mobx] Derivation '" + ne.name_ + "' is created/updated without reading any observable value.");
}
function bindDependencies(ne) {
  for (var oe = ne.observing_, ae = ne.observing_ = ne.newObserving_, fe = IDerivationState_.UP_TO_DATE_, ye = 0, ge = ne.unboundDepsCount_, we = 0; we < ge; we++) {
    var _e = ae[we];
    _e.diffValue === 0 && (_e.diffValue = 1, ye !== we && (ae[ye] = _e), ye++), _e.dependenciesState_ > fe && (fe = _e.dependenciesState_);
  }
  for (ae.length = ye, ne.newObserving_ = null, ge = oe.length; ge--; ) {
    var Se = oe[ge];
    Se.diffValue === 0 && removeObserver(Se, ne), Se.diffValue = 0;
  }
  for (; ye--; ) {
    var Ie = ae[ye];
    Ie.diffValue === 1 && (Ie.diffValue = 0, addObserver(Ie, ne));
  }
  fe !== IDerivationState_.UP_TO_DATE_ && (ne.dependenciesState_ = fe, ne.onBecomeStale_());
}
function clearObserving(ne) {
  var oe = ne.observing_;
  ne.observing_ = [];
  for (var ae = oe.length; ae--; )
    removeObserver(oe[ae], ne);
  ne.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(ne) {
  var oe = untrackedStart();
  try {
    return ne();
  } finally {
    untrackedEnd(oe);
  }
}
function untrackedStart() {
  var ne = globalState.trackingDerivation;
  return globalState.trackingDerivation = null, ne;
}
function untrackedEnd(ne) {
  globalState.trackingDerivation = ne;
}
function allowStateReadsStart(ne) {
  var oe = globalState.allowStateReads;
  return globalState.allowStateReads = ne, oe;
}
function allowStateReadsEnd(ne) {
  globalState.allowStateReads = ne;
}
function changeDependenciesStateTo0(ne) {
  if (ne.dependenciesState_ !== IDerivationState_.UP_TO_DATE_) {
    ne.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    for (var oe = ne.observing_, ae = oe.length; ae--; )
      oe[ae].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function ne() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, canMergeGlobalState = !0, globalState = /* @__PURE__ */ function() {
  var ne = /* @__PURE__ */ getGlobal();
  return ne.__mobxInstanceCount > 0 && !ne.__mobxGlobals && (canMergeGlobalState = !1), ne.__mobxGlobals && ne.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = !1), canMergeGlobalState ? ne.__mobxGlobals ? (ne.__mobxInstanceCount += 1, ne.__mobxGlobals.UNCHANGED || (ne.__mobxGlobals.UNCHANGED = {}), ne.__mobxGlobals) : (ne.__mobxInstanceCount = 1, ne.__mobxGlobals = /* @__PURE__ */ new MobXGlobals()) : (setTimeout(function() {
    die(35);
  }, 1), new MobXGlobals());
}();
function addObserver(ne, oe) {
  ne.observers_.add(oe), ne.lowestObserverState_ > oe.dependenciesState_ && (ne.lowestObserverState_ = oe.dependenciesState_);
}
function removeObserver(ne, oe) {
  ne.observers_.delete(oe), ne.observers_.size === 0 && queueForUnobservation(ne);
}
function queueForUnobservation(ne) {
  ne.isPendingUnobservation === !1 && (ne.isPendingUnobservation = !0, globalState.pendingUnobservations.push(ne));
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    for (var ne = globalState.pendingUnobservations, oe = 0; oe < ne.length; oe++) {
      var ae = ne[oe];
      ae.isPendingUnobservation = !1, ae.observers_.size === 0 && (ae.isBeingObserved && (ae.isBeingObserved = !1, ae.onBUO()), ae instanceof ComputedValue && ae.suspend_());
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(ne) {
  checkIfStateReadsAreAllowed(ne);
  var oe = globalState.trackingDerivation;
  return oe !== null ? (oe.runId_ !== ne.lastAccessedBy_ && (ne.lastAccessedBy_ = oe.runId_, oe.newObserving_[oe.unboundDepsCount_++] = ne, !ne.isBeingObserved && globalState.trackingContext && (ne.isBeingObserved = !0, ne.onBO())), ne.isBeingObserved) : (ne.observers_.size === 0 && globalState.inBatch > 0 && queueForUnobservation(ne), !1);
}
function propagateChanged(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne), oe.onBecomeStale_()), oe.dependenciesState_ = IDerivationState_.STALE_;
  }));
}
function propagateChangeConfirmed(ne) {
  ne.lowestObserverState_ !== IDerivationState_.STALE_ && (ne.lowestObserverState_ = IDerivationState_.STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_ ? (oe.dependenciesState_ = IDerivationState_.STALE_, process.env.NODE_ENV !== "production" && oe.isTracing_ !== TraceMode.NONE && logTraceInfo(oe, ne)) : oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.UP_TO_DATE_);
  }));
}
function propagateMaybeChanged(ne) {
  ne.lowestObserverState_ === IDerivationState_.UP_TO_DATE_ && (ne.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_, ne.observers_.forEach(function(oe) {
    oe.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (oe.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_, oe.onBecomeStale_());
  }));
}
function logTraceInfo(ne, oe) {
  if (console.log("[mobx.trace] '" + ne.name_ + "' is invalidated due to a change in: '" + oe.name_ + "'"), ne.isTracing_ === TraceMode.BREAK) {
    var ae = [];
    printDepTree(getDependencyTree(ne), ae, 1), new Function(`debugger;
/*
Tracing '` + ne.name_ + `'

You are entering this break point because derivation '` + ne.name_ + "' is being traced and '" + oe.name_ + `' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

` + (ne instanceof ComputedValue ? ne.derivation.toString().replace(/[*]\//g, "/") : "") + `

The dependencies for this derivation are:

` + ae.join(`
`) + `
*/
    `)();
  }
}
function printDepTree(ne, oe, ae) {
  if (oe.length >= 1e3) {
    oe.push("(and many more)");
    return;
  }
  oe.push("" + "	".repeat(ae - 1) + ne.name), ne.dependencies && ne.dependencies.forEach(function(fe) {
    return printDepTree(fe, oe, ae + 1);
  });
}
var Reaction = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ge) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "Reaction@" + getNextId() : "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = TraceMode.NONE, this.name_ = ae, this.onInvalidate_ = fe, this.errorHandler_ = ye, this.requiresObservable_ = ge;
  }
  var oe = ne.prototype;
  return oe.onBecomeStale_ = function() {
    this.schedule_();
  }, oe.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, globalState.pendingReactions.push(this), runReactions());
  }, oe.runReaction_ = function() {
    if (!this.isDisposed) {
      startBatch(), this.isScheduled = !1;
      var fe = globalState.trackingContext;
      if (globalState.trackingContext = this, shouldCompute(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_(), process.env.NODE_ENV !== "production" && this.isTrackPending && isSpyEnabled() && spyReport({
            name: this.name_,
            type: "scheduled-reaction"
          });
        } catch (ye) {
          this.reportExceptionInDerivation_(ye);
        }
      }
      globalState.trackingContext = fe, endBatch();
    }
  }, oe.track = function(fe) {
    if (!this.isDisposed) {
      startBatch();
      var ye = isSpyEnabled(), ge;
      process.env.NODE_ENV !== "production" && ye && (ge = Date.now(), spyReportStart({
        name: this.name_,
        type: "reaction"
      })), this.isRunning = !0;
      var we = globalState.trackingContext;
      globalState.trackingContext = this;
      var _e = trackDerivedFunction(this, fe, void 0);
      globalState.trackingContext = we, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && clearObserving(this), isCaughtException(_e) && this.reportExceptionInDerivation_(_e.cause), process.env.NODE_ENV !== "production" && ye && spyReportEnd({
        time: Date.now() - ge
      }), endBatch();
    }
  }, oe.reportExceptionInDerivation_ = function(fe) {
    var ye = this;
    if (this.errorHandler_) {
      this.errorHandler_(fe, this);
      return;
    }
    if (globalState.disableErrorBoundaries)
      throw fe;
    var ge = process.env.NODE_ENV !== "production" ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    globalState.suppressReactionErrors ? process.env.NODE_ENV !== "production" && console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(ge, fe), process.env.NODE_ENV !== "production" && isSpyEnabled() && spyReport({
      type: "error",
      name: this.name_,
      message: ge,
      error: "" + fe
    }), globalState.globalReactionErrorHandlers.forEach(function(we) {
      return we(fe, ye);
    });
  }, oe.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (startBatch(), clearObserving(this), endBatch()));
  }, oe.getDisposer_ = function(fe) {
    var ye = this, ge = function we() {
      ye.dispose(), fe == null || fe.removeEventListener == null || fe.removeEventListener("abort", we);
    };
    return fe == null || fe.addEventListener == null || fe.addEventListener("abort", ge), ge[$mobx] = this, ge;
  }, oe.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, oe.trace = function(fe) {
    fe === void 0 && (fe = !1), trace(this, fe);
  }, _createClass(ne, [{
    key: "isDisposed",
    get: function() {
      return getFlag(this.flags_, ne.isDisposedMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isDisposedMask_, fe);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return getFlag(this.flags_, ne.isScheduledMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isScheduledMask_, fe);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return getFlag(this.flags_, ne.isTrackPendingMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isTrackPendingMask_, fe);
    }
  }, {
    key: "isRunning",
    get: function() {
      return getFlag(this.flags_, ne.isRunningMask_);
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.isRunningMask_, fe);
    }
  }, {
    key: "diffValue",
    get: function() {
      return getFlag(this.flags_, ne.diffValueMask_) ? 1 : 0;
    },
    set: function(fe) {
      this.flags_ = setFlag(this.flags_, ne.diffValueMask_, fe === 1);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100, reactionScheduler = function ne(oe) {
  return oe();
};
function runReactions() {
  globalState.inBatch > 0 || globalState.isRunningReactions || reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = !0;
  for (var ne = globalState.pendingReactions, oe = 0; ne.length > 0; ) {
    ++oe === MAX_REACTION_ITERATIONS && (console.error(process.env.NODE_ENV !== "production" ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + ne[0]) : "[mobx] cycle in reaction: " + ne[0]), ne.splice(0));
    for (var ae = ne.splice(0), fe = 0, ye = ae.length; fe < ye; fe++)
      ae[fe].runReaction_();
  }
  globalState.isRunningReactions = !1;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return process.env.NODE_ENV !== "production" && !!globalState.spyListeners.length;
}
function spyReport(ne) {
  if (process.env.NODE_ENV !== "production" && globalState.spyListeners.length)
    for (var oe = globalState.spyListeners, ae = 0, fe = oe.length; ae < fe; ae++)
      oe[ae](ne);
}
function spyReportStart(ne) {
  if (process.env.NODE_ENV !== "production") {
    var oe = _extends({}, ne, {
      spyReportStart: !0
    });
    spyReport(oe);
  }
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: !0
};
function spyReportEnd(ne) {
  process.env.NODE_ENV !== "production" && spyReport(ne ? _extends({}, ne, {
    type: "report-end",
    spyReportEnd: !0
  }) : END_EVENT);
}
function spy(ne) {
  return process.env.NODE_ENV === "production" ? (console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  }) : (globalState.spyListeners.push(ne), once(function() {
    globalState.spyListeners = globalState.spyListeners.filter(function(oe) {
      return oe !== ne;
    });
  }));
}
var ACTION = "action", ACTION_BOUND = "action.bound", AUTOACTION = "autoAction", AUTOACTION_BOUND = "autoAction.bound", DEFAULT_ACTION_NAME = "<unnamed action>", actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION), actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: !0
}), autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: !0
}), autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: !0,
  bound: !0
});
function createActionFactory(ne) {
  var oe = function(fe, ye) {
    if (isFunction(fe))
      return createAction(fe.name || DEFAULT_ACTION_NAME, fe, ne);
    if (isFunction(ye))
      return createAction(fe, ye, ne);
    if (is20223Decorator(ye))
      return (ne ? autoActionAnnotation : actionAnnotation).decorate_20223_(fe, ye);
    if (isStringish(ye))
      return storeAnnotation(fe, ye, ne ? autoActionAnnotation : actionAnnotation);
    if (isStringish(fe))
      return createDecoratorAnnotation(createActionAnnotation(ne ? AUTOACTION : ACTION, {
        name: fe,
        autoAction: ne
      }));
    process.env.NODE_ENV !== "production" && die("Invalid arguments for `action`");
  };
  return oe;
}
var action = /* @__PURE__ */ createActionFactory(!1);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(!0);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(ne) {
  return isFunction(ne) && ne.isMobxAction === !0;
}
function autorun(ne, oe) {
  var ae, fe, ye, ge;
  oe === void 0 && (oe = EMPTY_OBJECT), process.env.NODE_ENV !== "production" && (isFunction(ne) || die("Autorun expects a function as first argument"), isAction(ne) && die("Autorun does not accept actions since actions are untrackable"));
  var we = (ae = (fe = oe) == null ? void 0 : fe.name) != null ? ae : process.env.NODE_ENV !== "production" ? ne.name || "Autorun@" + getNextId() : "Autorun", _e = !oe.scheduler && !oe.delay, Se;
  if (_e)
    Se = new Reaction(we, function() {
      this.track(Ne);
    }, oe.onError, oe.requiresObservable);
  else {
    var Ie = createSchedulerFromOptions(oe), $e = !1;
    Se = new Reaction(we, function() {
      $e || ($e = !0, Ie(function() {
        $e = !1, Se.isDisposed || Se.track(Ne);
      }));
    }, oe.onError, oe.requiresObservable);
  }
  function Ne() {
    ne(Se);
  }
  return (ye = oe) != null && (ye = ye.signal) != null && ye.aborted || Se.schedule_(), Se.getDisposer_((ge = oe) == null ? void 0 : ge.signal);
}
var run = function ne(oe) {
  return oe();
};
function createSchedulerFromOptions(ne) {
  return ne.scheduler ? ne.scheduler : ne.delay ? function(oe) {
    return setTimeout(oe, ne.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO", ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_OBSERVED, ne, oe, ae);
}
function onBecomeUnobserved(ne, oe, ae) {
  return interceptHook(ON_BECOME_UNOBSERVED, ne, oe, ae);
}
function interceptHook(ne, oe, ae, fe) {
  var ye = typeof fe == "function" ? getAtom(oe, ae) : getAtom(oe), ge = isFunction(fe) ? fe : ae, we = ne + "L";
  return ye[we] ? ye[we].add(ge) : ye[we] = /* @__PURE__ */ new Set([ge]), function() {
    var _e = ye[we];
    _e && (_e.delete(ge), _e.size === 0 && delete ye[we]);
  };
}
function extendObservable(ne, oe, ae, fe) {
  process.env.NODE_ENV !== "production" && (arguments.length > 4 && die("'extendObservable' expected 2-4 arguments"), typeof ne != "object" && die("'extendObservable' expects an object as first argument"), isObservableMap(ne) && die("'extendObservable' should not be used on maps, use map.merge instead"), isPlainObject(oe) || die("'extendObservable' only accepts plain objects as second argument"), (isObservable(oe) || isObservable(ae)) && die("Extending an object with another observable (object) is not supported"));
  var ye = getOwnPropertyDescriptors(oe);
  return initObservable(function() {
    var ge = asObservableObject(ne, fe)[$mobx];
    ownKeys(ye).forEach(function(we) {
      ge.extend_(
        we,
        ye[we],
        // must pass "undefined" for { key: undefined }
        ae && we in ae ? ae[we] : !0
      );
    });
  }), ne;
}
function getDependencyTree(ne, oe) {
  return nodeToDependencyTree(getAtom(ne, oe));
}
function nodeToDependencyTree(ne) {
  var oe = {
    name: ne.name_
  };
  return ne.observing_ && ne.observing_.length > 0 && (oe.dependencies = unique(ne.observing_).map(nodeToDependencyTree)), oe;
}
function unique(ne) {
  return Array.from(new Set(ne));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow"), flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: !0
}), flow = /* @__PURE__ */ Object.assign(function ne(oe, ae) {
  if (is20223Decorator(ae))
    return flowAnnotation.decorate_20223_(oe, ae);
  if (isStringish(ae))
    return storeAnnotation(oe, ae, flowAnnotation);
  process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("Flow expects single argument with generator function");
  var fe = oe, ye = fe.name || "<unnamed flow>", ge = function() {
    var _e = this, Se = arguments, Ie = ++generatorId, $e = action(ye + " - runid: " + Ie + " - init", fe).apply(_e, Se), Ne, Me = void 0, Be = new Promise(function(ze, He) {
      var Ze = 0;
      Ne = He;
      function qe(ot) {
        Me = void 0;
        var pt;
        try {
          pt = action(ye + " - runid: " + Ie + " - yield " + Ze++, $e.next).call($e, ot);
        } catch (ht) {
          return He(ht);
        }
        Xe(pt);
      }
      function tt(ot) {
        Me = void 0;
        var pt;
        try {
          pt = action(ye + " - runid: " + Ie + " - yield " + Ze++, $e.throw).call($e, ot);
        } catch (ht) {
          return He(ht);
        }
        Xe(pt);
      }
      function Xe(ot) {
        if (isFunction(ot == null ? void 0 : ot.then)) {
          ot.then(Xe, He);
          return;
        }
        return ot.done ? ze(ot.value) : (Me = Promise.resolve(ot.value), Me.then(qe, tt));
      }
      qe(void 0);
    });
    return Be.cancel = action(ye + " - runid: " + Ie + " - cancel", function() {
      try {
        Me && cancelPromise(Me);
        var ze = $e.return(void 0), He = Promise.resolve(ze.value);
        He.then(noop, noop), cancelPromise(He), Ne(new FlowCancellationError());
      } catch (Ze) {
        Ne(Ze);
      }
    }), Be;
  };
  return ge.isMobXFlow = !0, ge;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(ne) {
  isFunction(ne.cancel) && ne.cancel();
}
function isFlow(ne) {
  return (ne == null ? void 0 : ne.isMobXFlow) === !0;
}
function _isObservable(ne, oe) {
  return ne ? oe !== void 0 ? process.env.NODE_ENV !== "production" && (isObservableMap(ne) || isObservableArray(ne)) ? die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.") : isObservableObject(ne) ? ne[$mobx].values_.has(oe) : !1 : isObservableObject(ne) || !!ne[$mobx] || isAtom(ne) || isReaction(ne) || isComputedValue(ne) : !1;
}
function isObservable(ne) {
  return process.env.NODE_ENV !== "production" && arguments.length !== 1 && die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"), _isObservable(ne);
}
function trace() {
  if (process.env.NODE_ENV !== "production") {
    for (var ne = !1, oe = arguments.length, ae = new Array(oe), fe = 0; fe < oe; fe++)
      ae[fe] = arguments[fe];
    typeof ae[ae.length - 1] == "boolean" && (ne = ae.pop());
    var ye = getAtomFromArgs(ae);
    if (!ye)
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    ye.isTracing_ === TraceMode.NONE && console.log("[mobx.trace] '" + ye.name_ + "' tracing enabled"), ye.isTracing_ = ne ? TraceMode.BREAK : TraceMode.LOG;
  }
}
function getAtomFromArgs(ne) {
  switch (ne.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(ne[0]);
    case 2:
      return getAtom(ne[0], ne[1]);
  }
}
function transaction(ne, oe) {
  oe === void 0 && (oe = void 0), startBatch();
  try {
    return ne.apply(oe);
  } finally {
    endBatch();
  }
}
function getAdm(ne) {
  return ne[$mobx];
}
var objectProxyTraps = {
  has: function ne(oe, ae) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."), getAdm(oe).has_(ae);
  },
  get: function ne(oe, ae) {
    return getAdm(oe).get_(ae);
  },
  set: function ne(oe, ae, fe) {
    var ye;
    return isStringish(ae) ? (process.env.NODE_ENV !== "production" && !getAdm(oe).values_.has(ae) && warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead."), (ye = getAdm(oe).set_(ae, fe, !0)) != null ? ye : !0) : !1;
  },
  deleteProperty: function ne(oe, ae) {
    var fe;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead."), isStringish(ae) ? (fe = getAdm(oe).delete_(ae, !0)) != null ? fe : !0 : !1;
  },
  defineProperty: function ne(oe, ae, fe) {
    var ye;
    return process.env.NODE_ENV !== "production" && warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead."), (ye = getAdm(oe).defineProperty_(ae, fe)) != null ? ye : !0;
  },
  ownKeys: function ne(oe) {
    return process.env.NODE_ENV !== "production" && globalState.trackingDerivation && warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."), getAdm(oe).ownKeys_();
  },
  preventExtensions: function ne(oe) {
    die(13);
  }
};
function asDynamicObservableObject(ne, oe) {
  var ae, fe;
  return assertProxies(), ne = asObservableObject(ne, oe), (fe = (ae = ne[$mobx]).proxy_) != null ? fe : ae.proxy_ = new Proxy(ne, objectProxyTraps);
}
function hasInterceptors(ne) {
  return ne.interceptors_ !== void 0 && ne.interceptors_.length > 0;
}
function registerInterceptor(ne, oe) {
  var ae = ne.interceptors_ || (ne.interceptors_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function interceptChange(ne, oe) {
  var ae = untrackedStart();
  try {
    for (var fe = [].concat(ne.interceptors_ || []), ye = 0, ge = fe.length; ye < ge && (oe = fe[ye](oe), oe && !oe.type && die(14), !!oe); ye++)
      ;
    return oe;
  } finally {
    untrackedEnd(ae);
  }
}
function hasListeners(ne) {
  return ne.changeListeners_ !== void 0 && ne.changeListeners_.length > 0;
}
function registerListener(ne, oe) {
  var ae = ne.changeListeners_ || (ne.changeListeners_ = []);
  return ae.push(oe), once(function() {
    var fe = ae.indexOf(oe);
    fe !== -1 && ae.splice(fe, 1);
  });
}
function notifyListeners(ne, oe) {
  var ae = untrackedStart(), fe = ne.changeListeners_;
  if (fe) {
    fe = fe.slice();
    for (var ye = 0, ge = fe.length; ye < ge; ye++)
      fe[ye](oe);
    untrackedEnd(ae);
  }
}
var SPLICE = "splice", UPDATE = "update", MAX_SPLICE_SIZE = 1e4, arrayTraps = {
  get: function ne(oe, ae) {
    var fe = oe[$mobx];
    return ae === $mobx ? fe : ae === "length" ? fe.getArrayLength_() : typeof ae == "string" && !isNaN(ae) ? fe.get_(parseInt(ae)) : hasProp(arrayExtensions, ae) ? arrayExtensions[ae] : oe[ae];
  },
  set: function ne(oe, ae, fe) {
    var ye = oe[$mobx];
    return ae === "length" && ye.setArrayLength_(fe), typeof ae == "symbol" || isNaN(ae) ? oe[ae] = fe : ye.set_(parseInt(ae), fe), !0;
  },
  preventExtensions: function ne() {
    die(15);
  }
}, ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ge) {
    ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = ye, this.legacyMode_ = ge, this.atom_ = new Atom(ae), this.enhancer_ = function(we, _e) {
      return fe(we, _e, process.env.NODE_ENV !== "production" ? ae + "[..]" : "ObservableArray[..]");
    };
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.dehanceValues_ = function(fe) {
    return this.dehancer !== void 0 && fe.length > 0 ? fe.map(this.dehancer) : fe;
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.observe_ = function(fe, ye) {
    return ye === void 0 && (ye = !1), ye && fe({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), registerListener(this, fe);
  }, oe.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, oe.setArrayLength_ = function(fe) {
    (typeof fe != "number" || isNaN(fe) || fe < 0) && die("Out of range: " + fe);
    var ye = this.values_.length;
    if (fe !== ye)
      if (fe > ye) {
        for (var ge = new Array(fe - ye), we = 0; we < fe - ye; we++)
          ge[we] = void 0;
        this.spliceWithArray_(ye, 0, ge);
      } else
        this.spliceWithArray_(fe, ye - fe);
  }, oe.updateArrayLength_ = function(fe, ye) {
    fe !== this.lastKnownLength_ && die(16), this.lastKnownLength_ += ye, this.legacyMode_ && ye > 0 && reserveArrayBuffer(fe + ye + 1);
  }, oe.spliceWithArray_ = function(fe, ye, ge) {
    var we = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var _e = this.values_.length;
    if (fe === void 0 ? fe = 0 : fe > _e ? fe = _e : fe < 0 && (fe = Math.max(0, _e + fe)), arguments.length === 1 ? ye = _e - fe : ye == null ? ye = 0 : ye = Math.max(0, Math.min(ye, _e - fe)), ge === void 0 && (ge = EMPTY_ARRAY), hasInterceptors(this)) {
      var Se = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: fe,
        removedCount: ye,
        added: ge
      });
      if (!Se)
        return EMPTY_ARRAY;
      ye = Se.removedCount, ge = Se.added;
    }
    if (ge = ge.length === 0 ? ge : ge.map(function(Ne) {
      return we.enhancer_(Ne, void 0);
    }), this.legacyMode_ || process.env.NODE_ENV !== "production") {
      var Ie = ge.length - ye;
      this.updateArrayLength_(_e, Ie);
    }
    var $e = this.spliceItemsIntoValues_(fe, ye, ge);
    return (ye !== 0 || ge.length !== 0) && this.notifyArraySplice_(fe, ge, $e), this.dehanceValues_($e);
  }, oe.spliceItemsIntoValues_ = function(fe, ye, ge) {
    if (ge.length < MAX_SPLICE_SIZE) {
      var we;
      return (we = this.values_).splice.apply(we, [fe, ye].concat(ge));
    } else {
      var _e = this.values_.slice(fe, fe + ye), Se = this.values_.slice(fe + ye);
      this.values_.length += ge.length - ye;
      for (var Ie = 0; Ie < ge.length; Ie++)
        this.values_[fe + Ie] = ge[Ie];
      for (var $e = 0; $e < Se.length; $e++)
        this.values_[fe + ge.length + $e] = Se[$e];
      return _e;
    }
  }, oe.notifyArrayChildUpdate_ = function(fe, ye, ge) {
    var we = !this.owned_ && isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: fe,
      newValue: ye,
      oldValue: ge
    } : null;
    process.env.NODE_ENV !== "production" && we && spyReportStart(Se), this.atom_.reportChanged(), _e && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && we && spyReportEnd();
  }, oe.notifyArraySplice_ = function(fe, ye, ge) {
    var we = !this.owned_ && isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: fe,
      removed: ge,
      added: ye,
      removedCount: ge.length,
      addedCount: ye.length
    } : null;
    process.env.NODE_ENV !== "production" && we && spyReportStart(Se), this.atom_.reportChanged(), _e && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && we && spyReportEnd();
  }, oe.get_ = function(fe) {
    if (this.legacyMode_ && fe >= this.values_.length) {
      console.warn(process.env.NODE_ENV !== "production" ? "[mobx.array] Attempt to read an array index (" + fe + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + fe);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[fe]);
  }, oe.set_ = function(fe, ye) {
    var ge = this.values_;
    if (this.legacyMode_ && fe > ge.length && die(17, fe, ge.length), fe < ge.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var we = ge[fe];
      if (hasInterceptors(this)) {
        var _e = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: fe,
          newValue: ye
        });
        if (!_e)
          return;
        ye = _e.newValue;
      }
      ye = this.enhancer_(ye, we);
      var Se = ye !== we;
      Se && (ge[fe] = ye, this.notifyArrayChildUpdate_(fe, ye, we));
    } else {
      for (var Ie = new Array(fe + 1 - ge.length), $e = 0; $e < Ie.length - 1; $e++)
        Ie[$e] = void 0;
      Ie[Ie.length - 1] = ye, this.spliceWithArray_(ge.length, 0, Ie);
    }
  }, ne;
}();
function createObservableArray(ne, oe, ae, fe) {
  return ae === void 0 && (ae = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), fe === void 0 && (fe = !1), assertProxies(), initObservable(function() {
    var ye = new ObservableArrayAdministration(ae, oe, fe, !1);
    addHiddenFinalProp(ye.values_, $mobx, ye);
    var ge = new Proxy(ye.values_, arrayTraps);
    return ye.proxy_ = ge, ne && ne.length && ye.spliceWithArray_(0, 0, ne), ge;
  });
}
var arrayExtensions = {
  clear: function ne() {
    return this.splice(0);
  },
  replace: function ne(oe) {
    var ae = this[$mobx];
    return ae.spliceWithArray_(0, ae.values_.length, oe);
  },
  // Used by JSON.stringify
  toJSON: function ne() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function ne(oe, ae) {
    for (var fe = arguments.length, ye = new Array(fe > 2 ? fe - 2 : 0), ge = 2; ge < fe; ge++)
      ye[ge - 2] = arguments[ge];
    var we = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return we.spliceWithArray_(oe);
      case 2:
        return we.spliceWithArray_(oe, ae);
    }
    return we.spliceWithArray_(oe, ae, ye);
  },
  spliceWithArray: function ne(oe, ae, fe) {
    return this[$mobx].spliceWithArray_(oe, ae, fe);
  },
  push: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(oe.values_.length, 0, fe), oe.values_.length;
  },
  pop: function ne() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function ne() {
    return this.splice(0, 1)[0];
  },
  unshift: function ne() {
    for (var oe = this[$mobx], ae = arguments.length, fe = new Array(ae), ye = 0; ye < ae; ye++)
      fe[ye] = arguments[ye];
    return oe.spliceWithArray_(0, 0, fe), oe.values_.length;
  },
  reverse: function ne() {
    return globalState.trackingDerivation && die(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function ne() {
    globalState.trackingDerivation && die(37, "sort");
    var oe = this.slice();
    return oe.sort.apply(oe, arguments), this.replace(oe), this;
  },
  remove: function ne(oe) {
    var ae = this[$mobx], fe = ae.dehanceValues_(ae.values_).indexOf(oe);
    return fe > -1 ? (this.splice(fe, 1), !0) : !1;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(ne, oe) {
  typeof Array.prototype[ne] == "function" && (arrayExtensions[ne] = oe(ne));
}
function simpleFunc(ne) {
  return function() {
    var oe = this[$mobx];
    oe.atom_.reportObserved();
    var ae = oe.dehanceValues_(oe.values_);
    return ae[ne].apply(ae, arguments);
  };
}
function mapLikeFunc(ne) {
  return function(oe, ae) {
    var fe = this, ye = this[$mobx];
    ye.atom_.reportObserved();
    var ge = ye.dehanceValues_(ye.values_);
    return ge[ne](function(we, _e) {
      return oe.call(ae, we, _e, fe);
    });
  };
}
function reduceLikeFunc(ne) {
  return function() {
    var oe = this, ae = this[$mobx];
    ae.atom_.reportObserved();
    var fe = ae.dehanceValues_(ae.values_), ye = arguments[0];
    return arguments[0] = function(ge, we, _e) {
      return ye(ge, we, _e, oe);
    }, fe[ne].apply(fe, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(ne) {
  return isObject(ne) && isObservableArrayAdministration(ne[$mobx]);
}
var ObservableMapMarker = {}, ADD = "add", DELETE = "delete", ObservableMap = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var ge = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableMap@" + getNextId() : "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[$mobx] = ObservableMapMarker, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = fe, this.name_ = ye, isFunction(Map) || die(18), initObservable(function() {
      ge.keysAtom_ = createAtom(process.env.NODE_ENV !== "production" ? ge.name_ + ".keys()" : "ObservableMap.keys()"), ge.data_ = /* @__PURE__ */ new Map(), ge.hasMap_ = /* @__PURE__ */ new Map(), ae && ge.merge(ae);
    });
  }
  var oe = ne.prototype;
  return oe.has_ = function(fe) {
    return this.data_.has(fe);
  }, oe.has = function(fe) {
    var ye = this;
    if (!globalState.trackingDerivation)
      return this.has_(fe);
    var ge = this.hasMap_.get(fe);
    if (!ge) {
      var we = ge = new ObservableValue(this.has_(fe), referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableMap.key?", !1);
      this.hasMap_.set(fe, we), onBecomeUnobserved(we, function() {
        return ye.hasMap_.delete(fe);
      });
    }
    return ge.get();
  }, oe.set = function(fe, ye) {
    var ge = this.has_(fe);
    if (hasInterceptors(this)) {
      var we = interceptChange(this, {
        type: ge ? UPDATE : ADD,
        object: this,
        newValue: ye,
        name: fe
      });
      if (!we)
        return this;
      ye = we.newValue;
    }
    return ge ? this.updateValue_(fe, ye) : this.addValue_(fe, ye), this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.keysAtom_), hasInterceptors(this)) {
      var ge = interceptChange(this, {
        type: DELETE,
        object: this,
        name: fe
      });
      if (!ge)
        return !1;
    }
    if (this.has_(fe)) {
      var we = isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(fe).value_,
        name: fe
      } : null;
      return process.env.NODE_ENV !== "production" && we && spyReportStart(Se), transaction(function() {
        var Ie;
        ye.keysAtom_.reportChanged(), (Ie = ye.hasMap_.get(fe)) == null || Ie.setNewValue_(!1);
        var $e = ye.data_.get(fe);
        $e.setNewValue_(void 0), ye.data_.delete(fe);
      }), _e && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && we && spyReportEnd(), !0;
    }
    return !1;
  }, oe.updateValue_ = function(fe, ye) {
    var ge = this.data_.get(fe);
    if (ye = ge.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var we = isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: ge.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && we && spyReportStart(Se), ge.setNewValue_(ye), _e && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && we && spyReportEnd();
    }
  }, oe.addValue_ = function(fe, ye) {
    var ge = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_), transaction(function() {
      var Ie, $e = new ObservableValue(ye, ge.enhancer_, process.env.NODE_ENV !== "production" ? ge.name_ + "." + stringifyKey(fe) : "ObservableMap.key", !1);
      ge.data_.set(fe, $e), ye = $e.value_, (Ie = ge.hasMap_.get(fe)) == null || Ie.setNewValue_(!0), ge.keysAtom_.reportChanged();
    });
    var we = isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: fe,
      newValue: ye
    } : null;
    process.env.NODE_ENV !== "production" && we && spyReportStart(Se), _e && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && we && spyReportEnd();
  }, oe.get = function(fe) {
    return this.has(fe) ? this.dehanceValue_(this.data_.get(fe).get()) : this.dehanceValue_(void 0);
  }, oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, oe.values = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var we = ye.next(), _e = we.done, Se = we.value;
        return {
          done: _e,
          value: _e ? void 0 : fe.get(Se)
        };
      }
    });
  }, oe.entries = function() {
    var fe = this, ye = this.keys();
    return makeIterable({
      next: function() {
        var we = ye.next(), _e = we.done, Se = we.value;
        return {
          done: _e,
          value: _e ? void 0 : [Se, fe.get(Se)]
        };
      }
    });
  }, oe[Symbol.iterator] = function() {
    return this.entries();
  }, oe.forEach = function(fe, ye) {
    for (var ge = _createForOfIteratorHelperLoose(this), we; !(we = ge()).done; ) {
      var _e = we.value, Se = _e[0], Ie = _e[1];
      fe.call(ye, Ie, Se, this);
    }
  }, oe.merge = function(fe) {
    var ye = this;
    return isObservableMap(fe) && (fe = new Map(fe)), transaction(function() {
      isPlainObject(fe) ? getPlainObjectKeys(fe).forEach(function(ge) {
        return ye.set(ge, fe[ge]);
      }) : Array.isArray(fe) ? fe.forEach(function(ge) {
        var we = ge[0], _e = ge[1];
        return ye.set(we, _e);
      }) : isES6Map(fe) ? (isPlainES6Map(fe) || die(19, fe), fe.forEach(function(ge, we) {
        return ye.set(we, ge);
      })) : fe != null && die(20, fe);
    }), this;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.keys()), ge; !(ge = ye()).done; ) {
          var we = ge.value;
          fe.delete(we);
        }
      });
    });
  }, oe.replace = function(fe) {
    var ye = this;
    return transaction(function() {
      for (var ge = convertToMap(fe), we = /* @__PURE__ */ new Map(), _e = !1, Se = _createForOfIteratorHelperLoose(ye.data_.keys()), Ie; !(Ie = Se()).done; ) {
        var $e = Ie.value;
        if (!ge.has($e)) {
          var Ne = ye.delete($e);
          if (Ne)
            _e = !0;
          else {
            var Me = ye.data_.get($e);
            we.set($e, Me);
          }
        }
      }
      for (var Be = _createForOfIteratorHelperLoose(ge.entries()), ze; !(ze = Be()).done; ) {
        var He = ze.value, Ze = He[0], qe = He[1], tt = ye.data_.has(Ze);
        if (ye.set(Ze, qe), ye.data_.has(Ze)) {
          var Xe = ye.data_.get(Ze);
          we.set(Ze, Xe), tt || (_e = !0);
        }
      }
      if (!_e)
        if (ye.data_.size !== we.size)
          ye.keysAtom_.reportChanged();
        else
          for (var ot = ye.data_.keys(), pt = we.keys(), ht = ot.next(), wt = pt.next(); !ht.done; ) {
            if (ht.value !== wt.value) {
              ye.keysAtom_.reportChanged();
              break;
            }
            ht = ot.next(), wt = pt.next();
          }
      ye.data_ = we;
    }), this;
  }, oe.toString = function() {
    return "[object ObservableMap]";
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with maps."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(ne) {
  if (isES6Map(ne) || isObservableMap(ne))
    return ne;
  if (Array.isArray(ne))
    return new Map(ne);
  if (isPlainObject(ne)) {
    var oe = /* @__PURE__ */ new Map();
    for (var ae in ne)
      oe.set(ae, ne[ae]);
    return oe;
  } else
    return die(21, ne);
}
var ObservableSetMarker = {}, ObservableSet = /* @__PURE__ */ function() {
  function ne(ae, fe, ye) {
    var ge = this;
    fe === void 0 && (fe = deepEnhancer), ye === void 0 && (ye = process.env.NODE_ENV !== "production" ? "ObservableSet@" + getNextId() : "ObservableSet"), this.name_ = void 0, this[$mobx] = ObservableSetMarker, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = ye, isFunction(Set) || die(22), this.enhancer_ = function(we, _e) {
      return fe(we, _e, ye);
    }, initObservable(function() {
      ge.atom_ = createAtom(ge.name_), ae && ge.replace(ae);
    });
  }
  var oe = ne.prototype;
  return oe.dehanceValue_ = function(fe) {
    return this.dehancer !== void 0 ? this.dehancer(fe) : fe;
  }, oe.clear = function() {
    var fe = this;
    transaction(function() {
      untracked(function() {
        for (var ye = _createForOfIteratorHelperLoose(fe.data_.values()), ge; !(ge = ye()).done; ) {
          var we = ge.value;
          fe.delete(we);
        }
      });
    });
  }, oe.forEach = function(fe, ye) {
    for (var ge = _createForOfIteratorHelperLoose(this), we; !(we = ge()).done; ) {
      var _e = we.value;
      fe.call(ye, _e, _e, this);
    }
  }, oe.add = function(fe) {
    var ye = this;
    if (checkIfStateModificationsAreAllowed(this.atom_), hasInterceptors(this)) {
      var ge = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: fe
      });
      if (!ge)
        return this;
    }
    if (!this.has(fe)) {
      transaction(function() {
        ye.data_.add(ye.enhancer_(fe, void 0)), ye.atom_.reportChanged();
      });
      var we = process.env.NODE_ENV !== "production" && isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: fe
      } : null;
      we && process.env.NODE_ENV !== "production" && spyReportStart(Se), _e && notifyListeners(this, Se), we && process.env.NODE_ENV !== "production" && spyReportEnd();
    }
    return this;
  }, oe.delete = function(fe) {
    var ye = this;
    if (hasInterceptors(this)) {
      var ge = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: fe
      });
      if (!ge)
        return !1;
    }
    if (this.has(fe)) {
      var we = process.env.NODE_ENV !== "production" && isSpyEnabled(), _e = hasListeners(this), Se = _e || we ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: fe
      } : null;
      return we && process.env.NODE_ENV !== "production" && spyReportStart(Se), transaction(function() {
        ye.atom_.reportChanged(), ye.data_.delete(fe);
      }), _e && notifyListeners(this, Se), we && process.env.NODE_ENV !== "production" && spyReportEnd(), !0;
    }
    return !1;
  }, oe.has = function(fe) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(fe));
  }, oe.entries = function() {
    var fe = 0, ye = Array.from(this.keys()), ge = Array.from(this.values());
    return makeIterable({
      next: function() {
        var _e = fe;
        return fe += 1, _e < ge.length ? {
          value: [ye[_e], ge[_e]],
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.keys = function() {
    return this.values();
  }, oe.values = function() {
    this.atom_.reportObserved();
    var fe = this, ye = 0, ge = Array.from(this.data_.values());
    return makeIterable({
      next: function() {
        return ye < ge.length ? {
          value: fe.dehanceValue_(ge[ye++]),
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, oe.intersection = function(fe) {
    if (isES6Set(fe))
      return fe.intersection(this);
    var ye = new Set(this);
    return ye.intersection(fe);
  }, oe.union = function(fe) {
    if (isES6Set(fe))
      return fe.union(this);
    var ye = new Set(this);
    return ye.union(fe);
  }, oe.difference = function(fe) {
    return new Set(this).difference(fe);
  }, oe.symmetricDifference = function(fe) {
    if (isES6Set(fe))
      return fe.symmetricDifference(this);
    var ye = new Set(this);
    return ye.symmetricDifference(fe);
  }, oe.isSubsetOf = function(fe) {
    return new Set(this).isSubsetOf(fe);
  }, oe.isSupersetOf = function(fe) {
    return new Set(this).isSupersetOf(fe);
  }, oe.isDisjointFrom = function(fe) {
    if (isES6Set(fe))
      return fe.isDisjointFrom(this);
    var ye = new Set(this);
    return ye.isDisjointFrom(fe);
  }, oe.replace = function(fe) {
    var ye = this;
    return isObservableSet(fe) && (fe = new Set(fe)), transaction(function() {
      Array.isArray(fe) ? (ye.clear(), fe.forEach(function(ge) {
        return ye.add(ge);
      })) : isES6Set(fe) ? (ye.clear(), fe.forEach(function(ge) {
        return ye.add(ge);
      })) : fe != null && die("Cannot initialize set from " + fe);
    }), this;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support fireImmediately=true in combination with sets."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.toJSON = function() {
    return Array.from(this);
  }, oe.toString = function() {
    return "[object ObservableSet]";
  }, oe[Symbol.iterator] = function() {
    return this.values();
  }, _createClass(ne, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet), descriptorCache = /* @__PURE__ */ Object.create(null), REMOVE = "remove", ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ne(ae, fe, ye, ge) {
    fe === void 0 && (fe = /* @__PURE__ */ new Map()), ge === void 0 && (ge = autoAnnotation), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = ae, this.values_ = fe, this.name_ = ye, this.defaultAnnotation_ = ge, this.keysAtom_ = new Atom(process.env.NODE_ENV !== "production" ? this.name_ + ".keys" : "ObservableObject.keys"), this.isPlainObject_ = isPlainObject(this.target_), process.env.NODE_ENV !== "production" && !isAnnotation(this.defaultAnnotation_) && die("defaultAnnotation must be valid annotation"), process.env.NODE_ENV !== "production" && (this.appliedAnnotations_ = {});
  }
  var oe = ne.prototype;
  return oe.getObservablePropValue_ = function(fe) {
    return this.values_.get(fe).get();
  }, oe.setObservablePropValue_ = function(fe, ye) {
    var ge = this.values_.get(fe);
    if (ge instanceof ComputedValue)
      return ge.set(ye), !0;
    if (hasInterceptors(this)) {
      var we = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      });
      if (!we)
        return null;
      ye = we.newValue;
    }
    if (ye = ge.prepareNewValue_(ye), ye !== globalState.UNCHANGED) {
      var _e = hasListeners(this), Se = process.env.NODE_ENV !== "production" && isSpyEnabled(), Ie = _e || Se ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: ge.value_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && Se && spyReportStart(Ie), ge.setNewValue_(ye), _e && notifyListeners(this, Ie), process.env.NODE_ENV !== "production" && Se && spyReportEnd();
    }
    return !0;
  }, oe.get_ = function(fe) {
    return globalState.trackingDerivation && !hasProp(this.target_, fe) && this.has_(fe), this.target_[fe];
  }, oe.set_ = function(fe, ye, ge) {
    return ge === void 0 && (ge = !1), hasProp(this.target_, fe) ? this.values_.has(fe) ? this.setObservablePropValue_(fe, ye) : ge ? Reflect.set(this.target_, fe, ye) : (this.target_[fe] = ye, !0) : this.extend_(fe, {
      value: ye,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, ge);
  }, oe.has_ = function(fe) {
    if (!globalState.trackingDerivation)
      return fe in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var ye = this.pendingKeys_.get(fe);
    return ye || (ye = new ObservableValue(fe in this.target_, referenceEnhancer, process.env.NODE_ENV !== "production" ? this.name_ + "." + stringifyKey(fe) + "?" : "ObservableObject.key?", !1), this.pendingKeys_.set(fe, ye)), ye.get();
  }, oe.make_ = function(fe, ye) {
    if (ye === !0 && (ye = this.defaultAnnotation_), ye !== !1) {
      if (assertAnnotable(this, ye, fe), !(fe in this.target_)) {
        var ge;
        if ((ge = this.target_[storedAnnotationsSymbol]) != null && ge[fe])
          return;
        die(1, ye.annotationType_, this.name_ + "." + fe.toString());
      }
      for (var we = this.target_; we && we !== objectPrototype; ) {
        var _e = getDescriptor(we, fe);
        if (_e) {
          var Se = ye.make_(this, fe, _e, we);
          if (Se === 0)
            return;
          if (Se === 1)
            break;
        }
        we = Object.getPrototypeOf(we);
      }
      recordAnnotationApplied(this, ye, fe);
    }
  }, oe.extend_ = function(fe, ye, ge, we) {
    if (we === void 0 && (we = !1), ge === !0 && (ge = this.defaultAnnotation_), ge === !1)
      return this.defineProperty_(fe, ye, we);
    assertAnnotable(this, ge, fe);
    var _e = ge.extend_(this, fe, ye, we);
    return _e && recordAnnotationApplied(this, ge, fe), _e;
  }, oe.defineProperty_ = function(fe, ye, ge) {
    ge === void 0 && (ge = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var we = this.delete_(fe);
      if (!we)
        return we;
      if (hasInterceptors(this)) {
        var _e = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye.value
        });
        if (!_e)
          return null;
        var Se = _e.newValue;
        ye.value !== Se && (ye = _extends({}, ye, {
          value: Se
        }));
      }
      if (ge) {
        if (!Reflect.defineProperty(this.target_, fe, ye))
          return !1;
      } else
        defineProperty(this.target_, fe, ye);
      this.notifyPropertyAddition_(fe, ye.value);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineObservableProperty_ = function(fe, ye, ge, we) {
    we === void 0 && (we = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var _e = this.delete_(fe);
      if (!_e)
        return _e;
      if (hasInterceptors(this)) {
        var Se = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: ye
        });
        if (!Se)
          return null;
        ye = Se.newValue;
      }
      var Ie = getCachedObservablePropDescriptor(fe), $e = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: Ie.get,
        set: Ie.set
      };
      if (we) {
        if (!Reflect.defineProperty(this.target_, fe, $e))
          return !1;
      } else
        defineProperty(this.target_, fe, $e);
      var Ne = new ObservableValue(ye, ge, process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key", !1);
      this.values_.set(fe, Ne), this.notifyPropertyAddition_(fe, Ne.value_);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.defineComputedProperty_ = function(fe, ye, ge) {
    ge === void 0 && (ge = !1), checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var we = this.delete_(fe);
      if (!we)
        return we;
      if (hasInterceptors(this)) {
        var _e = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: fe,
          type: ADD,
          newValue: void 0
        });
        if (!_e)
          return null;
      }
      ye.name || (ye.name = process.env.NODE_ENV !== "production" ? this.name_ + "." + fe.toString() : "ObservableObject.key"), ye.context = this.proxy_ || this.target_;
      var Se = getCachedObservablePropDescriptor(fe), Ie = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: Se.get,
        set: Se.set
      };
      if (ge) {
        if (!Reflect.defineProperty(this.target_, fe, Ie))
          return !1;
      } else
        defineProperty(this.target_, fe, Ie);
      this.values_.set(fe, new ComputedValue(ye)), this.notifyPropertyAddition_(fe, void 0);
    } finally {
      endBatch();
    }
    return !0;
  }, oe.delete_ = function(fe, ye) {
    if (ye === void 0 && (ye = !1), checkIfStateModificationsAreAllowed(this.keysAtom_), !hasProp(this.target_, fe))
      return !0;
    if (hasInterceptors(this)) {
      var ge = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: fe,
        type: REMOVE
      });
      if (!ge)
        return null;
    }
    try {
      var we;
      startBatch();
      var _e = hasListeners(this), Se = process.env.NODE_ENV !== "production" && isSpyEnabled(), Ie = this.values_.get(fe), $e = void 0;
      if (!Ie && (_e || Se)) {
        var Ne;
        $e = (Ne = getDescriptor(this.target_, fe)) == null ? void 0 : Ne.value;
      }
      if (ye) {
        if (!Reflect.deleteProperty(this.target_, fe))
          return !1;
      } else
        delete this.target_[fe];
      if (process.env.NODE_ENV !== "production" && delete this.appliedAnnotations_[fe], Ie && (this.values_.delete(fe), Ie instanceof ObservableValue && ($e = Ie.value_), propagateChanged(Ie)), this.keysAtom_.reportChanged(), (we = this.pendingKeys_) == null || (we = we.get(fe)) == null || we.set(fe in this.target_), _e || Se) {
        var Me = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: $e,
          name: fe
        };
        process.env.NODE_ENV !== "production" && Se && spyReportStart(Me), _e && notifyListeners(this, Me), process.env.NODE_ENV !== "production" && Se && spyReportEnd();
      }
    } finally {
      endBatch();
    }
    return !0;
  }, oe.observe_ = function(fe, ye) {
    return process.env.NODE_ENV !== "production" && ye === !0 && die("`observe` doesn't support the fire immediately property for observable objects."), registerListener(this, fe);
  }, oe.intercept_ = function(fe) {
    return registerInterceptor(this, fe);
  }, oe.notifyPropertyAddition_ = function(fe, ye) {
    var ge, we = hasListeners(this), _e = process.env.NODE_ENV !== "production" && isSpyEnabled();
    if (we || _e) {
      var Se = we || _e ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: fe,
        newValue: ye
      } : null;
      process.env.NODE_ENV !== "production" && _e && spyReportStart(Se), we && notifyListeners(this, Se), process.env.NODE_ENV !== "production" && _e && spyReportEnd();
    }
    (ge = this.pendingKeys_) == null || (ge = ge.get(fe)) == null || ge.set(!0), this.keysAtom_.reportChanged();
  }, oe.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), ownKeys(this.target_);
  }, oe.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, ne;
}();
function asObservableObject(ne, oe) {
  var ae;
  if (process.env.NODE_ENV !== "production" && oe && isObservableObject(ne) && die("Options can't be provided for already observable objects."), hasProp(ne, $mobx))
    return process.env.NODE_ENV !== "production" && !(getAdministration(ne) instanceof ObservableObjectAdministration) && die("Cannot convert '" + getDebugName(ne) + `' into observable object:
The target is already observable of different type.
Extending builtins is not supported.`), ne;
  process.env.NODE_ENV !== "production" && !Object.isExtensible(ne) && die("Cannot make the designated object observable; it is not extensible");
  var fe = (ae = oe == null ? void 0 : oe.name) != null ? ae : process.env.NODE_ENV !== "production" ? (isPlainObject(ne) ? "ObservableObject" : ne.constructor.name) + "@" + getNextId() : "ObservableObject", ye = new ObservableObjectAdministration(ne, /* @__PURE__ */ new Map(), String(fe), getAnnotationFromOptions(oe));
  return addHiddenProp(ne, $mobx, ye), ne;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(ne) {
  return descriptorCache[ne] || (descriptorCache[ne] = {
    get: function() {
      return this[$mobx].getObservablePropValue_(ne);
    },
    set: function(ae) {
      return this[$mobx].setObservablePropValue_(ne, ae);
    }
  });
}
function isObservableObject(ne) {
  return isObject(ne) ? isObservableObjectAdministration(ne[$mobx]) : !1;
}
function recordAnnotationApplied(ne, oe, ae) {
  var fe;
  process.env.NODE_ENV !== "production" && (ne.appliedAnnotations_[ae] = oe), (fe = ne.target_[storedAnnotationsSymbol]) == null || delete fe[ae];
}
function assertAnnotable(ne, oe, ae) {
  if (process.env.NODE_ENV !== "production" && !isAnnotation(oe) && die("Cannot annotate '" + ne.name_ + "." + ae.toString() + "': Invalid annotation."), process.env.NODE_ENV !== "production" && !isOverride(oe) && hasProp(ne.appliedAnnotations_, ae)) {
    var fe = ne.name_ + "." + ae.toString(), ye = ne.appliedAnnotations_[ae].annotationType_, ge = oe.annotationType_;
    die("Cannot apply '" + ge + "' to '" + fe + "':" + (`
The field is already annotated with '` + ye + "'.") + `
Re-annotating fields is not allowed.
Use 'override' annotation for methods overridden by subclass.`);
  }
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0), safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var ne = !1, oe = {};
  return Object.defineProperty(oe, "0", {
    set: function() {
      ne = !0;
    }
  }), Object.create(oe)[0] = 1, ne === !1;
}(), OBSERVABLE_ARRAY_BUFFER_SIZE = 0, StubArray = function ne() {
};
function inherit(ne, oe) {
  Object.setPrototypeOf ? Object.setPrototypeOf(ne.prototype, oe) : ne.prototype.__proto__ !== void 0 ? ne.prototype.__proto__ = oe : ne.prototype = oe;
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(ne) {
  function oe(fe, ye, ge, we) {
    var _e;
    return ge === void 0 && (ge = process.env.NODE_ENV !== "production" ? "ObservableArray@" + getNextId() : "ObservableArray"), we === void 0 && (we = !1), _e = ne.call(this) || this, initObservable(function() {
      var Se = new ObservableArrayAdministration(ge, ye, we, !0);
      Se.proxy_ = _e, addHiddenFinalProp(_e, $mobx, Se), fe && fe.length && _e.spliceWithArray(0, 0, fe), safariPrototypeSetterInheritanceBug && Object.defineProperty(_e, "0", ENTRY_0);
    }), _e;
  }
  _inheritsLoose(oe, ne);
  var ae = oe.prototype;
  return ae.concat = function() {
    this[$mobx].atom_.reportObserved();
    for (var ye = arguments.length, ge = new Array(ye), we = 0; we < ye; we++)
      ge[we] = arguments[we];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      ge.map(function(_e) {
        return isObservableArray(_e) ? _e.slice() : _e;
      })
    );
  }, ae[Symbol.iterator] = function() {
    var fe = this, ye = 0;
    return makeIterable({
      next: function() {
        return ye < fe.length ? {
          value: fe[ye++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, _createClass(oe, [{
    key: "length",
    get: function() {
      return this[$mobx].getArrayLength_();
    },
    set: function(ye) {
      this[$mobx].setArrayLength_(ye);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(ne) {
  var oe = ne[0], ae = ne[1];
  oe !== "concat" && addHiddenProp(LegacyObservableArray.prototype, oe, ae);
});
function createArrayEntryDescriptor(ne) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[$mobx].get_(ne);
    },
    set: function(ae) {
      this[$mobx].set_(ne, ae);
    }
  };
}
function createArrayBufferItem(ne) {
  defineProperty(LegacyObservableArray.prototype, "" + ne, createArrayEntryDescriptor(ne));
}
function reserveArrayBuffer(ne) {
  if (ne > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var oe = OBSERVABLE_ARRAY_BUFFER_SIZE; oe < ne + 100; oe++)
      createArrayBufferItem(oe);
    OBSERVABLE_ARRAY_BUFFER_SIZE = ne;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(ne, oe, ae) {
  return new LegacyObservableArray(ne, oe, ae);
}
function getAtom(ne, oe) {
  if (typeof ne == "object" && ne !== null) {
    if (isObservableArray(ne))
      return oe !== void 0 && die(23), ne[$mobx].atom_;
    if (isObservableSet(ne))
      return ne.atom_;
    if (isObservableMap(ne)) {
      if (oe === void 0)
        return ne.keysAtom_;
      var ae = ne.data_.get(oe) || ne.hasMap_.get(oe);
      return ae || die(25, oe, getDebugName(ne)), ae;
    }
    if (isObservableObject(ne)) {
      if (!oe)
        return die(26);
      var fe = ne[$mobx].values_.get(oe);
      return fe || die(27, oe, getDebugName(ne)), fe;
    }
    if (isAtom(ne) || isComputedValue(ne) || isReaction(ne))
      return ne;
  } else if (isFunction(ne) && isReaction(ne[$mobx]))
    return ne[$mobx];
  die(28);
}
function getAdministration(ne, oe) {
  if (ne || die(29), oe !== void 0)
    return getAdministration(getAtom(ne, oe));
  if (isAtom(ne) || isComputedValue(ne) || isReaction(ne) || isObservableMap(ne) || isObservableSet(ne))
    return ne;
  if (ne[$mobx])
    return ne[$mobx];
  die(24, ne);
}
function getDebugName(ne, oe) {
  var ae;
  if (oe !== void 0)
    ae = getAtom(ne, oe);
  else {
    if (isAction(ne))
      return ne.name;
    isObservableObject(ne) || isObservableMap(ne) || isObservableSet(ne) ? ae = getAdministration(ne) : ae = getAtom(ne);
  }
  return ae.name_;
}
function initObservable(ne) {
  var oe = untrackedStart(), ae = allowStateChangesStart(!0);
  startBatch();
  try {
    return ne();
  } finally {
    endBatch(), allowStateChangesEnd(ae), untrackedEnd(oe);
  }
}
var toString = objectPrototype.toString;
function deepEqual(ne, oe, ae) {
  return ae === void 0 && (ae = -1), eq$1(ne, oe, ae);
}
function eq$1(ne, oe, ae, fe, ye) {
  if (ne === oe)
    return ne !== 0 || 1 / ne === 1 / oe;
  if (ne == null || oe == null)
    return !1;
  if (ne !== ne)
    return oe !== oe;
  var ge = typeof ne;
  if (ge !== "function" && ge !== "object" && typeof oe != "object")
    return !1;
  var we = toString.call(ne);
  if (we !== toString.call(oe))
    return !1;
  switch (we) {
    case "[object RegExp]":
    case "[object String]":
      return "" + ne == "" + oe;
    case "[object Number]":
      return +ne != +ne ? +oe != +oe : +ne == 0 ? 1 / +ne === 1 / oe : +ne == +oe;
    case "[object Date]":
    case "[object Boolean]":
      return +ne == +oe;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(ne) === Symbol.valueOf.call(oe);
    case "[object Map]":
    case "[object Set]":
      ae >= 0 && ae++;
      break;
  }
  ne = unwrap(ne), oe = unwrap(oe);
  var _e = we === "[object Array]";
  if (!_e) {
    if (typeof ne != "object" || typeof oe != "object")
      return !1;
    var Se = ne.constructor, Ie = oe.constructor;
    if (Se !== Ie && !(isFunction(Se) && Se instanceof Se && isFunction(Ie) && Ie instanceof Ie) && "constructor" in ne && "constructor" in oe)
      return !1;
  }
  if (ae === 0)
    return !1;
  ae < 0 && (ae = -1), fe = fe || [], ye = ye || [];
  for (var $e = fe.length; $e--; )
    if (fe[$e] === ne)
      return ye[$e] === oe;
  if (fe.push(ne), ye.push(oe), _e) {
    if ($e = ne.length, $e !== oe.length)
      return !1;
    for (; $e--; )
      if (!eq$1(ne[$e], oe[$e], ae - 1, fe, ye))
        return !1;
  } else {
    var Ne = Object.keys(ne), Me;
    if ($e = Ne.length, Object.keys(oe).length !== $e)
      return !1;
    for (; $e--; )
      if (Me = Ne[$e], !(hasProp(oe, Me) && eq$1(ne[Me], oe[Me], ae - 1, fe, ye)))
        return !1;
  }
  return fe.pop(), ye.pop(), !0;
}
function unwrap(ne) {
  return isObservableArray(ne) ? ne.slice() : isES6Map(ne) || isObservableMap(ne) || isES6Set(ne) || isObservableSet(ne) ? Array.from(ne.entries()) : ne;
}
function makeIterable(ne) {
  return ne[Symbol.iterator] = getSelf, ne;
}
function getSelf() {
  return this;
}
function isAnnotation(ne) {
  return (
    // Can be function
    ne instanceof Object && typeof ne.annotationType_ == "string" && isFunction(ne.make_) && isFunction(ne.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(ne) {
  var oe = getGlobal();
  typeof oe[ne] > "u" && die("MobX requires global '" + ne + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy,
  extras: {
    getDebugName
  },
  $mobx
});
function $r(ne, oe) {
  let ae = {};
  for (let fe in ne)
    ae[fe] = oe(ne[fe], fe);
  return ae;
}
function ur() {
  return pipe(filter((ne) => ne != null));
}
var ue$1 = function() {
  let ne = cr, oe = mr;
  return oe(ne(32), 8) + "-" + oe(ne(16), 4) + "-" + oe(16384 | ne(12), 4) + "-" + oe(32768 | ne(14), 4) + "-" + oe(ne(48), 12);
}, cr = function(ne) {
  if (ne < 0 || ne > 53)
    return NaN;
  let oe = 0 | Math.random() * 1073741824;
  return ne > 30 ? oe + (0 | Math.random() * (1 << ne - 30)) * 1073741824 : oe >>> 30 - ne;
}, mr = function(ne, oe) {
  let ae = ne.toString(16), fe = oe - ae.length, ye = "0";
  for (; fe > 0; fe >>>= 1, ye += ye)
    fe & 1 && (ae = ye + ae);
  return ae;
};
function y(ne) {
  return { ...ne, [Symbol.iterator]() {
    return this;
  } };
}
function I$2(ne, oe) {
  return y({ next() {
    let { done: ae, value: fe } = ne.next();
    return { done: ae, value: ae ? fe : oe(fe) };
  } });
}
function yr$1(ne) {
  if (ne < 2)
    throw new Error("Minimum size is 2");
  if (ne > 64)
    throw new Error("Maximum size is 64");
  let oe = 2 ** (ne - 1) - 1, ae = -oe - 1;
  return (fe) => {
    if (fe = fe << 0, fe > oe || fe < ae)
      throw console.log("value", fe, oe, ae, fe > oe, fe < ae), new Error(`Int${ne} overflow`);
    return fe < 0 ? 2 ** ne + fe : fe;
  };
}
yr$1(32);
/**
* UUID.core.js - UUID.js for Minimalists
*
* @file
* @author  LiosK
* @version v4.2.0
* @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
* @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
*/
var P$1 = ((ne) => (ne[ne.Boolean = 0] = "Boolean", ne[ne.Number = 1] = "Number", ne[ne.OptionalNumber = 2] = "OptionalNumber", ne[ne.BigInt = 3] = "BigInt", ne[ne.OptionalBigInt = 4] = "OptionalBigInt", ne[ne.String = 5] = "String", ne[ne.OptionalString = 6] = "OptionalString", ne[ne.NumberArray = 7] = "NumberArray", ne[ne.OptionalNumberArray = 8] = "OptionalNumberArray", ne[ne.BigIntArray = 9] = "BigIntArray", ne[ne.OptionalBigIntArray = 10] = "OptionalBigIntArray", ne[ne.StringArray = 11] = "StringArray", ne[ne.OptionalStringArray = 12] = "OptionalStringArray", ne[ne.Entity = 13] = "Entity", ne[ne.OptionalEntity = 14] = "OptionalEntity", ne[ne.EntityArray = 15] = "EntityArray", ne[ne.OptionalEntityArray = 16] = "OptionalEntityArray", ne[ne.T = 17] = "T", ne[ne.OptionalT = 18] = "OptionalT", ne))(P$1 || {}), k = ((ne) => (ne[ne.Enter = 0] = "Enter", ne[ne.Exit = 1] = "Exit", ne[ne.Update = 2] = "Update", ne[ne.Noop = 3] = "Noop", ne))(k || {}), w = [14, 16, 2, 8, 4, 10, 6, 12, 18];
function M$2(ne) {
  let oe = /* @__PURE__ */ new Map();
  function ae(_e) {
    let Se = oe.get(fe(_e));
    return Se ? new Set([...Se].map(v$1)) : /* @__PURE__ */ new Set();
  }
  function fe(_e) {
    return Object.values(_e).join("/");
  }
  function ye(_e, Se) {
    if (!Se)
      return;
    let Ie = fe(Se), $e = oe.get(Ie);
    $e || ($e = /* @__PURE__ */ new Set(), oe.set(Ie, $e)), $e.add(_e);
  }
  function ge(_e, Se) {
    if (!Se)
      return;
    let Ie = fe(Se), $e = oe.get(Ie);
    $e && $e.delete(_e);
  }
  for (let _e of V$1(ne)) {
    let Se = g(ne, _e);
    ye(p$1(_e), Se);
  }
  let we = ne.update$.subscribe(({ entity: _e, value: Se }) => {
    ge(p$1(_e), Se[1]), ye(p$1(_e), Se[0]);
  });
  return ne.world.registerDisposer(() => we == null ? void 0 : we.unsubscribe()), { ...ne, getEntitiesWithValue: ae };
}
function U$1(ne, oe) {
  let ae = g(oe, ne);
  return { entity: ne, component: oe, value: [ae, void 0], type: ae == null ? 3 : 0 };
}
function Y$1(ne) {
  return pipe(map((oe) => U$1(oe, ne)));
}
function I$1(ne) {
  return "getEntitiesWithValue" in ne;
}
function T$1(ne, oe) {
  return Object.keys(ne.schema).every((ae) => ae in oe);
}
function b$1(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) ?? ((ae = ne.metadata) == null ? void 0 : ae.tableName) ?? ((fe = ne.metadata) == null ? void 0 : fe.tableId) ?? ((ye = ne.metadata) == null ? void 0 : ye.contractId) ?? ne.id;
}
function ie(ne, oe, ae) {
  if (Object.keys(oe).length === 0)
    throw new Error("Component schema must have at least one key");
  let fe = (ae == null ? void 0 : ae.id) ?? ue$1(), ye = $r(oe, () => /* @__PURE__ */ new Map()), ge = new Subject(), we = ae == null ? void 0 : ae.metadata, _e = { values: ye, schema: oe, id: fe, update$: ge, metadata: we, entities: () => I$2(Object.values(ye)[0].keys(), v$1), world: ne };
  return ae != null && ae.indexed && (_e = M$2(_e)), ne.registerComponent(_e), _e;
}
function E$1(ne, oe, ae, fe = {}) {
  var we;
  let ye = p$1(oe), ge = g(ne, oe);
  for (let [_e, Se] of Object.entries(ae))
    ne.values[_e] ? ne.values[_e].set(ye, Se) : (we = ne.metadata) != null && we.tableId && /^\d+$/.test(_e) || console.warn("Component definition for", b$1(ne), "is missing key", _e, ", ignoring value", Se, "for entity", oe, ". Existing keys: ", Object.keys(ne.values));
  fe.skipUpdateStream || ne.update$.next({ entity: oe, value: [ae, ge], component: ne });
}
function ue(ne, oe, ae = {}) {
  let fe = p$1(oe), ye = g(ne, oe);
  for (let ge of Object.keys(ne.values))
    ne.values[ge].delete(fe);
  ae.skipUpdateStream || ne.update$.next({ entity: oe, value: [void 0, ye], component: ne });
}
function le$1(ne, oe) {
  let ae = p$1(oe);
  return Object.values(ne.values)[0].has(ae);
}
function g(ne, oe) {
  let ae = {}, fe = p$1(oe), ye = Object.keys(ne.schema);
  for (let ge of ye) {
    let we = ne.values[ge].get(fe);
    if (we === void 0 && !w.includes(ne.schema[ge]))
      return;
    ae[ge] = we;
  }
  return ae;
}
function de(ne, oe) {
  let ae = g(ne, oe);
  if (!ae)
    throw new Error(`No value for component ${b$1(ne)} on entity ${oe}`);
  return ae;
}
function K(ne, oe) {
  if (!ne && !oe)
    return !0;
  if (!ne || !oe)
    return !1;
  let ae = !0;
  for (let fe of Object.keys(ne))
    if (ae = ne[fe] === oe[fe], !ae)
      return !1;
  return ae;
}
function ce(ne, oe) {
  if (I$1(ne) && T$1(ne, oe))
    return ne.getEntitiesWithValue(oe);
  let ae = /* @__PURE__ */ new Set();
  for (let fe of V$1(ne)) {
    let ye = g(ne, fe);
    K(oe, ye) && ae.add(fe);
  }
  return ae;
}
function V$1(ne) {
  return ne.entities();
}
function p$1(ne) {
  return Symbol.for(ne);
}
function v$1(ne) {
  return Symbol.keyFor(ne);
}
var N = ((ne) => (ne[ne.Has = 0] = "Has", ne[ne.HasValue = 1] = "HasValue", ne[ne.Not = 2] = "Not", ne[ne.NotValue = 3] = "NotValue", ne[ne.ProxyRead = 4] = "ProxyRead", ne[ne.ProxyExpand = 5] = "ProxyExpand", ne))(N || {});
function Le(ne) {
  return { type: 0, component: ne };
}
function c$1(ne, oe) {
  if (oe.type === 0)
    return le$1(oe.component, ne);
  if (oe.type === 1)
    return K(oe.value, g(oe.component, ne));
  if (oe.type === 2)
    return !le$1(oe.component, ne);
  if (oe.type === 3)
    return !K(oe.value, g(oe.component, ne));
  throw new Error("Unknown query fragment");
}
function G(ne) {
  return ne.type === 0 || ne.type == 1;
}
function P(ne) {
  return ne.type === 2 || ne.type == 3;
}
function J(ne) {
  return ne.type === 5 || ne.type == 4;
}
function U(ne, oe) {
  return ne && G(oe) || !ne && P(oe);
}
function I(ne, oe, ae) {
  let fe = ne, ye = !1;
  for (let ge = 0; ge < ae.depth; ge++) {
    let we = g(ae.component, fe);
    if (!we)
      return null;
    let _e = we.value;
    if (!_e)
      return null;
    if (fe = _e, ye = c$1(fe, oe), U(ye, oe))
      return ye;
  }
  return ye;
}
function Q$1(ne, oe, ae) {
  if (ae === 0)
    return /* @__PURE__ */ new Set();
  let fe = ce(oe, { value: ne });
  if (ae === 1)
    return fe;
  let ye = [...fe].map((ge) => [...Q$1(ge, oe, ae - 1)]).flat();
  return /* @__PURE__ */ new Set([...fe, ...ye]);
}
function A(ne, oe) {
  let ae = oe ? /* @__PURE__ */ new Set([...oe]) : void 0, fe, ye;
  for (let ge = 0; ge < ne.length; ge++) {
    let we = ne[ge];
    if (J(we))
      we.type === 4 && (fe = we), we.type === 5 && (ye = we);
    else if (ae)
      for (let _e of [...ae]) {
        let Se = c$1(_e, we);
        if (fe && fe.depth > 0 && !U(Se, we) && (Se = I(_e, we, fe) ?? Se), Se || ae.delete(_e), ye && ye.depth > 0) {
          let Ie = Q$1(_e, ye.component, ye.depth);
          for (let $e of Ie)
            (c$1($e, we) || fe && fe.depth > 0 && I($e, we, fe)) && ae.add($e);
        }
      }
    else {
      if (P(we))
        throw new Error("First EntityQueryFragment must be Has or HasValue");
      if (ae = we.type === 0 ? /* @__PURE__ */ new Set([...V$1(we.component)]) : ce(we.component, we.value), ye && ye.depth > 0)
        for (let _e of [...ae])
          for (let Se of Q$1(_e, ye.component, ye.depth))
            ae.add(Se);
    }
  }
  return ae ?? /* @__PURE__ */ new Set();
}
function f(ne, oe) {
  let ae = oe != null && oe.runOnInit || oe != null && oe.initialSet ? A(ne, oe.initialSet) : /* @__PURE__ */ new Set(), fe = observable(ae), ye = from(fe).pipe(Y$1(ne[0].component)), ge = ne.findIndex((_e) => [5, 4].includes(_e.type)) !== -1, we = merge(...ne.map((_e) => _e.component.update$)).pipe(ge ? concatMap((_e) => {
    let Se = A(ne, oe == null ? void 0 : oe.initialSet), Ie = [];
    for (let $e of fe)
      Se.has($e) || (fe.delete($e), Ie.push({ entity: $e, type: 1, component: _e.component, value: [void 0, void 0] }));
    for (let $e of Se)
      fe.has($e) ? Ie.push({ entity: $e, type: 2, component: _e.component, value: [g(_e.component, $e), void 0] }) : (fe.add($e), Ie.push({ entity: $e, type: 0, component: _e.component, value: [g(_e.component, $e), void 0] }));
    return of(...Ie);
  }) : map((_e) => {
    if (fe.has(_e.entity))
      return ne.filter((Se) => Se.component.id === _e.component.id).every((Se) => c$1(_e.entity, Se)) ? { ..._e, type: 2 } : (fe.delete(_e.entity), { ..._e, type: 1 });
    if (ne.every((Se) => c$1(_e.entity, Se)))
      return fe.add(_e.entity), { ..._e, type: 0 };
  }), ur());
  return { matching: fe, update$: concat(ye, we).pipe(share()) };
}
function lt() {
  let ne = /* @__PURE__ */ new Set(), oe = [], ae = [];
  function fe({ id: $e, idSuffix: Ne } = {}) {
    let Me = $e || ne.size + (Ne ? "-" + Ne : ""), Be = p$1(Me);
    return ne.add(Be), Me;
  }
  function ye() {
    return I$2(ne.values(), v$1);
  }
  function ge($e) {
    oe.push($e);
  }
  function we($e) {
    for (let [, Ne] of ae.filter((Me) => !$e || Me[0] === $e))
      Ne();
    ae = ae.filter((Ne) => $e && Ne[0] !== $e);
  }
  function _e($e, Ne = "") {
    ae.push([Ne, $e]);
  }
  function Se($e) {
    let Ne = p$1($e);
    return ne.has(Ne);
  }
  function Ie($e) {
    for (let Ne of oe)
      le$1(Ne, $e) && ue(Ne, $e);
    ne.delete(p$1($e));
  }
  return { registerEntity: fe, components: oe, registerComponent: ge, dispose: we, registerDisposer: _e, hasEntity: Se, getEntities: ye, entitySymbols: ne, deleteEntity: Ie };
}
function v(ne) {
  if (!isHex(ne))
    throw new Error(`entity ${ne} is not a hex string`);
  let oe = size$1(ne);
  if (oe % 32 !== 0)
    throw new Error(`entity length ${oe} is not a multiple of 32 bytes`);
  return new Array(oe / 32).fill(0).map((ae, fe) => sliceHex(ne, fe * 32, (fe + 1) * 32));
}
var H = /* @__PURE__ */ new Map();
function nt$1(ne) {
  let oe = H.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$2(8096);
  return H.set(ne, ae), ae;
}
function rt(ne, oe) {
  let ae = v(oe);
  if (ae.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ae.length} does not match key schema length ${Object.keys(ne).length}`);
  return Object.fromEntries(Object.entries(ne).map(([fe, ye], ge) => [fe, decodeAbiParameters([{ type: ye }], ae[ge])[0]]));
}
function vt(ne, oe) {
  let ae = nt$1(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = v(oe);
  if (ye.length !== Object.keys(ne).length)
    throw new Error(`entity key tuple length ${ye.length} does not match key schema length ${Object.keys(ne).length}`);
  let ge = rt(ne, oe);
  return ae.set(oe, ge), ge;
}
function d(ne) {
  return concatHex(ne);
}
var j = /* @__PURE__ */ new Map();
function st(ne) {
  let oe = j.get(ne);
  if (oe != null)
    return oe;
  let ae = new C$2(8096);
  return j.set(ne, ae), ae;
}
function mt(ne, oe) {
  if (Object.keys(ne).length !== Object.keys(oe).length)
    throw new Error(`key length ${Object.keys(oe).length} does not match key schema length ${Object.keys(ne).length}`);
  return d(Object.entries(ne).map(([ae, fe]) => encodeAbiParameters([{ type: fe }], [oe[ae]])));
}
function M$1(ne, oe) {
  let ae = st(ne), fe = ae.get(oe);
  if (fe != null)
    return fe;
  let ye = mt(ne, oe);
  return ae.set(oe, ye), ye;
}
function Pt(ne) {
  var oe, ae, fe, ye;
  return ((oe = ne.metadata) == null ? void 0 : oe.componentName) != null && ((ae = ne.metadata) == null ? void 0 : ae.tableName) != null && ((fe = ne.metadata) == null ? void 0 : fe.keySchema) != null && ((ye = ne.metadata) == null ? void 0 : ye.valueSchema) != null;
}
var b = S.extend("recs"), ct = S.extend("reccs");
b.log = console.debug.bind(console);
ct.log = console.error.bind(console);
function V(ne) {
  return { RegisteredTables: ie(ne, { table: P$1.T }, { metadata: { componentName: "RegisteredTables" } }), SyncProgress: ie(ne, { step: P$1.String, message: P$1.String, percentage: P$1.Number, latestBlockNumber: P$1.BigInt, lastBlockNumberProcessed: P$1.BigInt }, { metadata: { componentName: "SyncProgress" } }) };
}
function E(ne) {
  return M$1({ address: "address", namespace: "bytes16", name: "bytes16" }, { address: ne.address, namespace: stringToHex(ne.namespace, { size: 16 }), name: stringToHex(ne.name, { size: 16 }) });
}
var T = d([]), z = { uint8: P$1.Number, uint16: P$1.Number, uint24: P$1.Number, uint32: P$1.Number, uint40: P$1.Number, uint48: P$1.Number, uint56: P$1.BigInt, uint64: P$1.BigInt, uint72: P$1.BigInt, uint80: P$1.BigInt, uint88: P$1.BigInt, uint96: P$1.BigInt, uint104: P$1.BigInt, uint112: P$1.BigInt, uint120: P$1.BigInt, uint128: P$1.BigInt, uint136: P$1.BigInt, uint144: P$1.BigInt, uint152: P$1.BigInt, uint160: P$1.BigInt, uint168: P$1.BigInt, uint176: P$1.BigInt, uint184: P$1.BigInt, uint192: P$1.BigInt, uint200: P$1.BigInt, uint208: P$1.BigInt, uint216: P$1.BigInt, uint224: P$1.BigInt, uint232: P$1.BigInt, uint240: P$1.BigInt, uint248: P$1.BigInt, uint256: P$1.BigInt, int8: P$1.Number, int16: P$1.Number, int24: P$1.Number, int32: P$1.Number, int40: P$1.Number, int48: P$1.Number, int56: P$1.BigInt, int64: P$1.BigInt, int72: P$1.BigInt, int80: P$1.BigInt, int88: P$1.BigInt, int96: P$1.BigInt, int104: P$1.BigInt, int112: P$1.BigInt, int120: P$1.BigInt, int128: P$1.BigInt, int136: P$1.BigInt, int144: P$1.BigInt, int152: P$1.BigInt, int160: P$1.BigInt, int168: P$1.BigInt, int176: P$1.BigInt, int184: P$1.BigInt, int192: P$1.BigInt, int200: P$1.BigInt, int208: P$1.BigInt, int216: P$1.BigInt, int224: P$1.BigInt, int232: P$1.BigInt, int240: P$1.BigInt, int248: P$1.BigInt, int256: P$1.BigInt, bytes1: P$1.String, bytes2: P$1.String, bytes3: P$1.String, bytes4: P$1.String, bytes5: P$1.String, bytes6: P$1.String, bytes7: P$1.String, bytes8: P$1.String, bytes9: P$1.String, bytes10: P$1.String, bytes11: P$1.String, bytes12: P$1.String, bytes13: P$1.String, bytes14: P$1.String, bytes15: P$1.String, bytes16: P$1.String, bytes17: P$1.String, bytes18: P$1.String, bytes19: P$1.String, bytes20: P$1.String, bytes21: P$1.String, bytes22: P$1.String, bytes23: P$1.String, bytes24: P$1.String, bytes25: P$1.String, bytes26: P$1.String, bytes27: P$1.String, bytes28: P$1.String, bytes29: P$1.String, bytes30: P$1.String, bytes31: P$1.String, bytes32: P$1.String, bool: P$1.Boolean, address: P$1.String, "uint8[]": P$1.NumberArray, "uint16[]": P$1.NumberArray, "uint24[]": P$1.NumberArray, "uint32[]": P$1.NumberArray, "uint40[]": P$1.NumberArray, "uint48[]": P$1.NumberArray, "uint56[]": P$1.BigIntArray, "uint64[]": P$1.BigIntArray, "uint72[]": P$1.BigIntArray, "uint80[]": P$1.BigIntArray, "uint88[]": P$1.BigIntArray, "uint96[]": P$1.BigIntArray, "uint104[]": P$1.BigIntArray, "uint112[]": P$1.BigIntArray, "uint120[]": P$1.BigIntArray, "uint128[]": P$1.BigIntArray, "uint136[]": P$1.BigIntArray, "uint144[]": P$1.BigIntArray, "uint152[]": P$1.BigIntArray, "uint160[]": P$1.BigIntArray, "uint168[]": P$1.BigIntArray, "uint176[]": P$1.BigIntArray, "uint184[]": P$1.BigIntArray, "uint192[]": P$1.BigIntArray, "uint200[]": P$1.BigIntArray, "uint208[]": P$1.BigIntArray, "uint216[]": P$1.BigIntArray, "uint224[]": P$1.BigIntArray, "uint232[]": P$1.BigIntArray, "uint240[]": P$1.BigIntArray, "uint248[]": P$1.BigIntArray, "uint256[]": P$1.BigIntArray, "int8[]": P$1.NumberArray, "int16[]": P$1.NumberArray, "int24[]": P$1.NumberArray, "int32[]": P$1.NumberArray, "int40[]": P$1.NumberArray, "int48[]": P$1.NumberArray, "int56[]": P$1.BigIntArray, "int64[]": P$1.BigIntArray, "int72[]": P$1.BigIntArray, "int80[]": P$1.BigIntArray, "int88[]": P$1.BigIntArray, "int96[]": P$1.BigIntArray, "int104[]": P$1.BigIntArray, "int112[]": P$1.BigIntArray, "int120[]": P$1.BigIntArray, "int128[]": P$1.BigIntArray, "int136[]": P$1.BigIntArray, "int144[]": P$1.BigIntArray, "int152[]": P$1.BigIntArray, "int160[]": P$1.BigIntArray, "int168[]": P$1.BigIntArray, "int176[]": P$1.BigIntArray, "int184[]": P$1.BigIntArray, "int192[]": P$1.BigIntArray, "int200[]": P$1.BigIntArray, "int208[]": P$1.BigIntArray, "int216[]": P$1.BigIntArray, "int224[]": P$1.BigIntArray, "int232[]": P$1.BigIntArray, "int240[]": P$1.BigIntArray, "int248[]": P$1.BigIntArray, "int256[]": P$1.BigIntArray, "bytes1[]": P$1.StringArray, "bytes2[]": P$1.StringArray, "bytes3[]": P$1.StringArray, "bytes4[]": P$1.StringArray, "bytes5[]": P$1.StringArray, "bytes6[]": P$1.StringArray, "bytes7[]": P$1.StringArray, "bytes8[]": P$1.StringArray, "bytes9[]": P$1.StringArray, "bytes10[]": P$1.StringArray, "bytes11[]": P$1.StringArray, "bytes12[]": P$1.StringArray, "bytes13[]": P$1.StringArray, "bytes14[]": P$1.StringArray, "bytes15[]": P$1.StringArray, "bytes16[]": P$1.StringArray, "bytes17[]": P$1.StringArray, "bytes18[]": P$1.StringArray, "bytes19[]": P$1.StringArray, "bytes20[]": P$1.StringArray, "bytes21[]": P$1.StringArray, "bytes22[]": P$1.StringArray, "bytes23[]": P$1.StringArray, "bytes24[]": P$1.StringArray, "bytes25[]": P$1.StringArray, "bytes26[]": P$1.StringArray, "bytes27[]": P$1.StringArray, "bytes28[]": P$1.StringArray, "bytes29[]": P$1.StringArray, "bytes30[]": P$1.StringArray, "bytes31[]": P$1.StringArray, "bytes32[]": P$1.StringArray, "bool[]": P$1.T, "address[]": P$1.StringArray, bytes: P$1.String, string: P$1.String };
function q(ne, oe) {
  let ae = ia(Xi$1(oe)), fe = ia(Zi(oe));
  return ie(ne, { ...P$6(fe, (ye) => z[ye]), __staticData: P$1.OptionalString, __encodedLengths: P$1.OptionalString, __dynamicData: P$1.OptionalString }, { id: oe.tableId, metadata: { componentName: oe.label, tableName: oe.label, keySchema: ae, valueSchema: fe } });
}
function F(ne, oe) {
  return Object.fromEntries(Object.entries(oe).map(([, ae]) => [ae.label, q(ne, ae)]));
}
function Q({ world: ne, tables: oe, shouldSkipUpdateStream: ae }) {
  ne.registerEntity({ id: T });
  let fe = { ...F(ne, oe), ...V(ne) };
  async function ye({ logs: ge }) {
    var _e, Se;
    let we = ge.filter(L).map(K$1);
    for (let Ie of we) {
      let $e = E(Ie);
      le$1(fe.RegisteredTables, $e) ? console.warn("table already registered, ignoring", { newTable: Ie, existingTable: (_e = g(fe.RegisteredTables, $e)) == null ? void 0 : _e.table }) : E$1(fe.RegisteredTables, $e, { table: Ie }, { skipUpdateStream: ae == null ? void 0 : ae() });
    }
    for (let Ie of ge) {
      let { namespace: $e, name: Ne } = _$2(Ie.args.tableId), Me = (Se = g(fe.RegisteredTables, E({ address: Ie.address, namespace: $e, name: Ne }))) == null ? void 0 : Se.table;
      if (!Me) {
        b(`skipping update for unknown table: ${i$2({ namespace: $e, name: Ne })} at ${Ie.address}`);
        continue;
      }
      let Be = ne.components.find((He) => He.id === Me.tableId);
      if (!Be) {
        b(`skipping update for unknown component: ${Me.tableId} (${i$2({ namespace: $e, name: Ne })}). Available components: ${Object.keys(fe)}`);
        continue;
      }
      let ze = d(Ie.args.keyTuple);
      if (Ie.eventName === "Store_SetRecord") {
        let He = zt$1(Me.valueSchema, Ie.args);
        b("setting component", { namespace: Me.namespace, name: Me.name, entity: ze, value: He }), E$1(Be, ze, { ...He, __staticData: Ie.args.staticData, __encodedLengths: Ie.args.encodedLengths, __dynamicData: Ie.args.dynamicData }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if (Ie.eventName === "Store_SpliceStaticData") {
        let He = g(Be, ze), Ze = (He == null ? void 0 : He.__staticData) ?? "0x", qe = Pe(Ze, Ie.args.start, size$1(Ie.args.data), Ie.args.data), tt = zt$1(Me.valueSchema, { staticData: qe, encodedLengths: (He == null ? void 0 : He.__encodedLengths) ?? "0x", dynamicData: (He == null ? void 0 : He.__dynamicData) ?? "0x" });
        b("setting component via splice static", { namespace: Me.namespace, name: Me.name, entity: ze, previousStaticData: Ze, newStaticData: qe, previousValue: He, newValue: tt }), E$1(Be, ze, { ...tt, __staticData: qe }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else if (Ie.eventName === "Store_SpliceDynamicData") {
        let He = g(Be, ze), Ze = (He == null ? void 0 : He.__dynamicData) ?? "0x", qe = Pe(Ze, Ie.args.start, Ie.args.deleteCount, Ie.args.data), tt = zt$1(Me.valueSchema, { staticData: (He == null ? void 0 : He.__staticData) ?? "0x", encodedLengths: Ie.args.encodedLengths, dynamicData: qe });
        b("setting component via splice dynamic", { namespace: Me.namespace, name: Me.name, entity: ze, previousDynamicData: Ze, newDynamicData: qe, previousValue: He, newValue: tt }), E$1(Be, ze, { ...tt, __encodedLengths: Ie.args.encodedLengths, __dynamicData: qe }, { skipUpdateStream: ae == null ? void 0 : ae() });
      } else
        Ie.eventName === "Store_DeleteRecord" && (b("deleting component", { namespace: Me.namespace, name: Me.name, entity: ze }), ue(Be, ze, { skipUpdateStream: ae == null ? void 0 : ae() }));
    }
  }
  return { storageAdapter: ye, components: fe };
}
async function Ke({ world: ne, config: oe, tables: ae = {}, startSync: fe = !0, ...ye }) {
  let ge = { ...O(oe), ...ae, ...A$1 }, { storageAdapter: we, components: _e } = Q({ world: ne, tables: ge, shouldSkipUpdateStream: () => {
    var Ne;
    return ((Ne = g(_e.SyncProgress, T)) == null ? void 0 : Ne.step) !== "live";
  } }), Se = await Et({ storageAdapter: we, config: oe, ...ye, onProgress: ({ step: Ne, percentage: Me, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }) => {
    var Ze;
    if (((Ze = g(_e.SyncProgress, T)) == null ? void 0 : Ze.step) !== "live" && (E$1(_e.SyncProgress, T, { step: Ne, percentage: Me, latestBlockNumber: Be, lastBlockNumberProcessed: ze, message: He }), Ne === "live"))
      for (let qe of Object.values(_e)) {
        let tt = qe;
        for (let Xe of tt.entities()) {
          let ot = g(tt, Xe);
          tt.update$.next({ component: tt, entity: Xe, value: [ot, ot] });
        }
      }
  } }), Ie = fe ? Se.storedBlockLogs$.subscribe() : null, $e = () => {
    Ie == null || Ie.unsubscribe();
  };
  return ne.registerDisposer($e), { ...Se, components: _e, stopSync: $e };
}
const worldsJson = {
  4242: {
    address: "0x079f71c3f6e9f4813ef249980F2a3b22dDc1263c",
    ToadNumber: 27977825
  },
  17069: {
    address: "0xb264d4cb90072b53500a721668cd948cba608992",
    blockNumber: 6031841
  },
  31337: {
    address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
  }
}, contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(ne) {
      var ae;
      return {
        transactions: (ae = ne.transactions) == null ? void 0 : ae.map((fe) => {
          if (typeof fe == "string")
            return fe;
          const ye = formatTransaction(fe);
          return ye.typeHex === "0x7e" && (ye.isSystemTx = fe.isSystemTx, ye.mint = fe.mint ? hexToBigInt(fe.mint) : void 0, ye.sourceHash = fe.sourceHash, ye.type = "deposit"), ye;
        }),
        stateRoot: ne.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(ne) {
      const oe = {};
      return ne.type === "0x7e" && (oe.isSystemTx = ne.isSystemTx, oe.mint = ne.mint ? hexToBigInt(ne.mint) : void 0, oe.sourceHash = ne.sourceHash, oe.type = "deposit"), oe;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(ne) {
      return {
        l1GasPrice: ne.l1GasPrice ? hexToBigInt(ne.l1GasPrice) : null,
        l1GasUsed: ne.l1GasUsed ? hexToBigInt(ne.l1GasUsed) : null,
        l1Fee: ne.l1Fee ? hexToBigInt(ne.l1Fee) : null,
        l1FeeScalar: ne.l1FeeScalar ? Number(ne.l1FeeScalar) : null
      };
    }
  })
};
function serializeTransaction(ne, oe) {
  return isDeposit(ne) ? serializeTransactionDeposit(ne) : serializeTransaction$1(ne, oe);
}
const serializers = {
  transaction: serializeTransaction
};
function serializeTransactionDeposit(ne) {
  assertTransactionDeposit(ne);
  const { sourceHash: oe, data: ae, from: fe, gas: ye, isSystemTx: ge, mint: we, to: _e, value: Se } = ne, Ie = [
    oe,
    fe,
    _e ?? "0x",
    we ? toHex(we) : "0x",
    Se ? toHex(Se) : "0x",
    ye ? toHex(ye) : "0x",
    ge ? "0x1" : "0x",
    ae ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(Ie)
  ]);
}
function isDeposit(ne) {
  return ne.type === "deposit" || typeof ne.sourceHash < "u";
}
function assertTransactionDeposit(ne) {
  const { from: oe, to: ae } = ne;
  if (oe && !isAddress(oe))
    throw new InvalidAddressError({ address: oe });
  if (ae && !isAddress(ae))
    throw new InvalidAddressError({ address: ae });
}
const chainConfig = {
  contracts,
  formatters,
  serializers
}, foundry = /* @__PURE__ */ defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});
var o = { ...foundry, fees: { defaultPriorityFee: 0n } }, e = 17e3, c = { ...chainConfig, id: 17069, sourceId: e, name: "Garnet Holesky", testnet: !0, nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 }, rpcUrls: { default: { http: ["https://rpc.garnetchain.com"], webSocket: ["wss://rpc.garnetchain.com"] } }, blockExplorers: { default: { name: "Blockscout", url: "https://explorer.garnetchain.com" } }, contracts: { ...chainConfig.contracts, multicall3: { address: "0xca11bde05977b3631167028862be2a173976ca11" }, portal: { [e]: { address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909", blockCreated: 1274684 } }, l2OutputOracle: { [e]: { address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B", blockCreated: 1274684 } }, l1StandardBridge: { [e]: { address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE", blockCreated: 1274684 } } }, iconUrls: ["https://redstone.xyz/chain-icons/garnet.png"], indexerUrl: "https://indexer.mud.garnetchain.com" }, t = 1;
({ ...chainConfig, contracts: { ...chainConfig.contracts, portal: t + "", l2OutputOracle: t + "", l1StandardBridge: t + "" } });
const supportedChains = [o, c], worlds = worldsJson;
async function getNetworkConfig() {
  const ne = new URLSearchParams(window.location.search), oe = Number(ne.get("chainId") || ne.get("chainid") || {}.VITE_CHAIN_ID || 17069), ae = supportedChains.findIndex((Se) => Se.id === oe), fe = supportedChains[ae];
  if (!fe)
    throw new Error(`Chain ${oe} not found`);
  const ye = worlds[fe.id.toString()], ge = ne.get("worldAddress") || (ye == null ? void 0 : ye.address);
  if (!ge)
    throw new Error(`No world address found for chain ${oe}. Did you run \`mud deploy\`?`);
  const we = ne.has("initialBlockNumber") ? Number(ne.get("initialBlockNumber")) : (ye == null ? void 0 : ye.blockNumber) ?? 0n;
  return {
    privateKey: ne.get("pk") || "0x000000000000000000000000832cce0f0faef94f242adad051e015bed9ffa7d4",
    //getBurnerPrivateKey(),
    chainId: oe,
    chain: fe,
    faucetServiceUrl: ne.get("faucet") ?? fe.faucetUrl,
    worldAddress: ge,
    initialBlockNumber: we
  };
}
const world = lt(), IWorldAbi = [
  {
    type: "function",
    name: "UltraMintB",
    inputs: [
      {
        name: "net_value",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "_calculateLosses",
    inputs: [
      {
        name: "armyKey",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "defenceLocation",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256[8]",
        internalType: "uint256[8]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "attack",
    inputs: [
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCall",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallData[]",
        components: [
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchCallFrom",
    inputs: [
      {
        name: "systemCalls",
        type: "tuple[]",
        internalType: "struct SystemCallFromData[]",
        components: [
          {
            name: "from",
            type: "address",
            internalType: "address"
          },
          {
            name: "systemId",
            type: "bytes32",
            internalType: "ResourceId"
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "returnDatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryA",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyCavalryC",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantry",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "buyInfantryByToken",
    inputs: [
      {
        name: "token_type",
        type: "uint8",
        internalType: "enum TokenType"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "call",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "callFrom",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "claim",
    inputs: [
      {
        name: "proof",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "creator",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "farming",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "garrison",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getArmyPower",
    inputs: [
      {
        name: "entityKey",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getDynamicFieldSlice",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLayout",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFieldLength",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getKeySchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLandPower",
    inputs: [
      {
        name: "land_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStageOneEndTime",
    inputs: [],
    outputs: [
      {
        name: "timestamp",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getStakeLimit",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getValueSchema",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "initModule",
        type: "address",
        internalType: "contract IModule"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "installRootModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "contract IModule"
      },
      {
        name: "encodedArgs",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "march",
    inputs: [
      {
        name: "destination",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "infantry",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryA",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryB",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "cavalryC",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "army_id",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "popFromDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "byteLengthToPop",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pushToDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "dataToPush",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespace",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "delegationControlId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "initCallData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerRootFunctionSelector",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "worldFunctionSignature",
        type: "string",
        internalType: "string"
      },
      {
        name: "systemFunctionSignature",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "worldFunctionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystem",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "system",
        type: "address",
        internalType: "contract System"
      },
      {
        name: "publicAccess",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      },
      {
        name: "enabledHooksBitmap",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registerTable",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      },
      {
        name: "keySchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "valueSchema",
        type: "bytes32",
        internalType: "Schema"
      },
      {
        name: "keyNames",
        type: "string[]",
        internalType: "string[]"
      },
      {
        name: "fieldNames",
        type: "string[]",
        internalType: "string[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeAccess",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "grantee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setDynamicField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setMerkleRoot",
    inputs: [
      {
        name: "_merkleRoot",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setOwner",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPassiveUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setStaticField",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "fieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fieldLayout",
        type: "bytes32",
        internalType: "FieldLayout"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setUnStakeFee",
    inputs: [
      {
        name: "fee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spawnCapital",
    inputs: [
      {
        name: "capital_id",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "spawnPlayer",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "spliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stakeTokenB",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stakeTokenC",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "storeVersion",
    inputs: [],
    outputs: [
      {
        name: "version",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "swapA2B",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "swapA2C",
    inputs: [
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToAddress",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferBalanceToNamespace",
    inputs: [
      {
        name: "fromNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "toNamespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unStakeTokenB",
    inputs: [
      {
        name: "staker",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterDelegation",
    inputs: [
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterNamespaceDelegation",
    inputs: [
      {
        name: "namespaceId",
        type: "bytes32",
        internalType: "ResourceId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterStoreHook",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract IStoreHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "unregisterSystemHook",
    inputs: [
      {
        name: "systemId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "hookAddress",
        type: "address",
        internalType: "contract ISystemHook"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "withdrawToken",
    inputs: [
      {
        name: "tokenAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "worldVersion",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "HelloStore",
    inputs: [
      {
        name: "storeVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "HelloWorld",
    inputs: [
      {
        name: "worldVersion",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_DeleteRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SetRecord",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "staticData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "dynamicData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceDynamicData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "dynamicFieldIndex",
        type: "uint8",
        indexed: !1,
        internalType: "uint8"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "deleteCount",
        type: "uint40",
        indexed: !1,
        internalType: "uint40"
      },
      {
        name: "encodedLengths",
        type: "bytes32",
        indexed: !1,
        internalType: "EncodedLengths"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Store_SpliceStaticData",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        indexed: !0,
        internalType: "ResourceId"
      },
      {
        name: "keyTuple",
        type: "bytes32[]",
        indexed: !1,
        internalType: "bytes32[]"
      },
      {
        name: "start",
        type: "uint48",
        indexed: !1,
        internalType: "uint48"
      },
      {
        name: "data",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "EncodedLengths_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_Empty",
    inputs: []
  },
  {
    type: "error",
    name: "FieldLayout_InvalidStaticDataLength",
    inputs: [
      {
        name: "staticDataLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "computedStaticDataLength",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthDoesNotFitInAWord",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsNotZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_StaticLengthIsZero",
    inputs: [
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyDynamicFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "FieldLayout_TooManyFields",
    inputs: [
      {
        name: "numFields",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "maxFields",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Module_AlreadyInstalled",
    inputs: []
  },
  {
    type: "error",
    name: "Module_MissingDependency",
    inputs: [
      {
        name: "dependency",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "Module_NonRootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Module_RootInstallNotSupported",
    inputs: []
  },
  {
    type: "error",
    name: "Schema_InvalidLength",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Schema_StaticTypeAfterDynamicType",
    inputs: []
  },
  {
    type: "error",
    name: "Slice_OutOfBounds",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_IndexOutOfBounds",
    inputs: [
      {
        name: "length",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "accessedIndex",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidBounds",
    inputs: [
      {
        name: "start",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "end",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidFieldNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidKeyNamesLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidSplice",
    inputs: [
      {
        name: "startWithinField",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "deleteCount",
        type: "uint40",
        internalType: "uint40"
      },
      {
        name: "fieldLength",
        type: "uint40",
        internalType: "uint40"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidStaticDataLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaDynamicLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_InvalidValueSchemaStaticLength",
    inputs: [
      {
        name: "expected",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "received",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableAlreadyExists",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "Store_TableNotFound",
    inputs: [
      {
        name: "tableId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "tableIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_AccessDenied",
    inputs: [
      {
        name: "resource",
        type: "string",
        internalType: "string"
      },
      {
        name: "caller",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_AlreadyInitialized",
    inputs: []
  },
  {
    type: "error",
    name: "World_CallbackNotAllowed",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_DelegationNotFound",
    inputs: [
      {
        name: "delegator",
        type: "address",
        internalType: "address"
      },
      {
        name: "delegatee",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorAlreadyExists",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_FunctionSelectorNotFound",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "World_InterfaceNotSupported",
    inputs: [
      {
        name: "contractAddress",
        type: "address",
        internalType: "address"
      },
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidNamespace",
    inputs: [
      {
        name: "namespace",
        type: "bytes14",
        internalType: "bytes14"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceId",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_InvalidResourceType",
    inputs: [
      {
        name: "expected",
        type: "bytes2",
        internalType: "bytes2"
      },
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceAlreadyExists",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_ResourceNotFound",
    inputs: [
      {
        name: "resourceId",
        type: "bytes32",
        internalType: "ResourceId"
      },
      {
        name: "resourceIdString",
        type: "string",
        internalType: "string"
      }
    ]
  },
  {
    type: "error",
    name: "World_SystemAlreadyExists",
    inputs: [
      {
        name: "system",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "World_UnlimitedDelegationNotAllowed",
    inputs: []
  }
], mudConfig = te({
  worldContractName: "RoR",
  enums: {
    TokenType: ["TokenA", "TokenB", "TokenC"]
  },
  systems: {
    SpawnSystem: {
      name: "spwan",
      openAccess: !0
    },
    TokenManagerSystem: {
      name: "tokenManager",
      openAccess: !1
    }
  },
  tables: {
    Player: "bool",
    PlayerDetail: {
      schema: {
        id: "bytes32",
        wallet: "address",
        gold: "uint256",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lands: "uint16",
        isSpawnCapital: "bool"
      },
      key: ["id"]
    },
    Army: {
      key: ["key"],
      schema: {
        key: "bytes32",
        owner: "bytes32",
        id: "uint8",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        destination: "uint16"
      }
    },
    Capital: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        lastTime: "uint32"
      }
    },
    Land: {
      key: ["id"],
      schema: {
        id: "uint16",
        tileId: "uint16",
        owner: "bytes32",
        infantry: "uint256",
        cavalryA: "uint256",
        cavalryB: "uint256",
        cavalryC: "uint256",
        lastTime: "uint32",
        attackAble: "bool"
      }
    },
    BattleReport: {
      key: ["key"],
      schema: {
        key: "bytes32",
        landId: "uint16",
        timestamp: "uint32",
        attacker: "address",
        defender: "address",
        attackWin: "bool",
        losses: "uint256[8]"
      }
    },
    GlobalStatistics: {
      schema: {
        consumptionTokenB: "uint256",
        consumptionTokenC: "uint256"
      },
      key: []
    },
    GlobalStake: {
      schema: {
        stakeTokenB: "uint256",
        stakeTokenC: "uint256",
        lastStakeTime: "uint256",
        valueB: "uint256",
        valueC: "uint256"
      },
      key: []
    },
    GlobalConfig: {
      schema: {
        unStakeFee: "uint256",
        passiveUnStakeFee: "uint256",
        owner: "address",
        merkleRoot: "bytes32"
      },
      key: []
    },
    PlayerStake: {
      schema: {
        wallet: "address",
        tokenB: "uint256",
        tokenC: "uint256"
      },
      key: ["wallet"]
    },
    PlayerAirdrop: {
      schema: {
        wallet: "address",
        isClaimed: "bool"
      },
      key: ["wallet"]
    }
    // PlayerStatistics:{
    //   schema: {
    //     id: "bytes32",
    //
    //   },
    //   key: ['id']
    // }
  },
  deploysDirectory: "./mud-deploys"
});
function p(ne = {}) {
  return (oe) => ({ writeContract: (ae) => Je(oe, ae, ne), sendTransaction: (ae) => Ve(oe, ae, ne) });
}
function h({ onWrite: ne }) {
  let oe = 0;
  return (ae) => ({ writeContract: (fe) => {
    let ye = getAction(ae, writeContract, "writeContract")(fe), ge = `${ae.chain.id}:${ae.account.address}:${oe++}`;
    return ne({ id: ge, request: fe, result: ye }), ye;
  } });
}
async function setupNetwork() {
  const ne = await getNetworkConfig();
  console.log("chain", ne.chain);
  const oe = {
    chain: ne.chain,
    transport: Ee(fallback([webSocket(), http()])),
    pollingInterval: 1e3
  };
  console.log("clientOptions", oe);
  const ae = createPublicClient(oe);
  console.log("publicClient", ae);
  const fe = new Subject(), ye = Q$3(ne.privateKey), ge = createWalletClient({
    ...oe,
    account: ye
  }).extend(p()).extend(h({ onWrite: (Me) => fe.next(Me) }));
  console.log("burnerAccount", ye), console.log("burnerWalletClient", ge);
  const we = getContract({
    address: ne.worldAddress,
    abi: IWorldAbi,
    client: { public: ae, wallet: ge }
  });
  console.log("worldContract", we);
  const { tables: _e, components: Se, latestBlock$: Ie, storedBlockLogs$: $e, waitForTransaction: Ne } = await Ke({
    world,
    config: mudConfig,
    address: ne.worldAddress,
    publicClient: ae,
    startBlock: BigInt(ne.initialBlockNumber)
  });
  if (ne.faucetServiceUrl) {
    const Me = ye.address;
    console.info("[Dev Faucet]: Player address -> ", Me);
    const Be = createFaucetService(ne.faucetServiceUrl), ze = async () => {
      const He = await ae.getBalance({ address: Me });
      console.info(`[Dev Faucet]: Player balance -> ${He}`), He < parseEther("1") && (console.info("[Dev Faucet]: Balance is low, dripping funds to player"), await Be.dripDev({ address: Me }), await Be.dripDev({ address: Me }));
    };
    ze(), setInterval(ze, 2e4);
  }
  return console.log("components", Se), {
    world,
    components: Se,
    playerEntity: M$1({ address: "address" }, { address: ge.account.address }),
    publicClient: ae,
    walletClient: ge,
    latestBlock$: Ie,
    storedBlockLogs$: $e,
    waitForTransaction: Ne,
    worldContract: we,
    write$: fe.asObservable().pipe(share()),
    tables: _e
  };
}
async function setup() {
  const ne = await setupNetwork(), oe = createClientComponents(ne), ae = createSystemCalls(ne);
  return {
    network: ne,
    components: oe,
    systemCalls: ae
  };
}
var pX = Object.create, AR = Object.defineProperty, vX = Object.getOwnPropertyDescriptor, mX = Object.getOwnPropertyNames, hX = Object.getPrototypeOf, yX = Object.prototype.hasOwnProperty, Y = (ne, oe) => () => (ne && (oe = ne(ne = 0)), oe), M = (ne, oe) => () => (oe || ne((oe = { exports: {} }).exports, oe), oe.exports), Uj = (ne, oe) => {
  for (var ae in oe)
    AR(ne, ae, { get: oe[ae], enumerable: !0 });
}, gX = (ne, oe, ae, fe) => {
  if (oe && typeof oe == "object" || typeof oe == "function")
    for (let ye of mX(oe))
      !yX.call(ne, ye) && ye !== ae && AR(ne, ye, { get: () => oe[ye], enumerable: !(fe = vX(oe, ye)) || fe.enumerable });
  return ne;
}, le = (ne, oe, ae) => (ae = ne != null ? pX(hX(ne)) : {}, gX(oe || !ne || !ne.__esModule ? AR(ae, "default", { value: ne, enumerable: !0 }) : ae, ne)), Gj = M((ne) => {
  var oe = Symbol.for("react.element"), ae = Symbol.for("react.portal"), fe = Symbol.for("react.fragment"), ye = Symbol.for("react.strict_mode"), ge = Symbol.for("react.profiler"), we = Symbol.for("react.provider"), _e = Symbol.for("react.context"), Se = Symbol.for("react.forward_ref"), Ie = Symbol.for("react.suspense"), $e = Symbol.for("react.memo"), Ne = Symbol.for("react.lazy"), Me = Symbol.iterator;
  function Be(At) {
    return At === null || typeof At != "object" ? null : (At = Me && At[Me] || At["@@iterator"], typeof At == "function" ? At : null);
  }
  var ze = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, He = Object.assign, Ze = {};
  function qe(At, hn, Yn) {
    this.props = At, this.context = hn, this.refs = Ze, this.updater = Yn || ze;
  }
  qe.prototype.isReactComponent = {}, qe.prototype.setState = function(At, hn) {
    if (typeof At != "object" && typeof At != "function" && At != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, At, hn, "setState");
  }, qe.prototype.forceUpdate = function(At) {
    this.updater.enqueueForceUpdate(this, At, "forceUpdate");
  };
  function tt() {
  }
  tt.prototype = qe.prototype;
  function Xe(At, hn, Yn) {
    this.props = At, this.context = hn, this.refs = Ze, this.updater = Yn || ze;
  }
  var ot = Xe.prototype = new tt();
  ot.constructor = Xe, He(ot, qe.prototype), ot.isPureReactComponent = !0;
  var pt = Array.isArray, ht = Object.prototype.hasOwnProperty, wt = { current: null }, gt = { key: !0, ref: !0, __self: !0, __source: !0 };
  function It(At, hn, Yn) {
    var Un, Ht = {}, _n = null, Vn = null;
    if (hn != null)
      for (Un in hn.ref !== void 0 && (Vn = hn.ref), hn.key !== void 0 && (_n = "" + hn.key), hn)
        ht.call(hn, Un) && !gt.hasOwnProperty(Un) && (Ht[Un] = hn[Un]);
    var br = arguments.length - 2;
    if (br === 1)
      Ht.children = Yn;
    else if (1 < br) {
      for (var nr = Array(br), Er = 0; Er < br; Er++)
        nr[Er] = arguments[Er + 2];
      Ht.children = nr;
    }
    if (At && At.defaultProps)
      for (Un in br = At.defaultProps, br)
        Ht[Un] === void 0 && (Ht[Un] = br[Un]);
    return { $$typeof: oe, type: At, key: _n, ref: Vn, props: Ht, _owner: wt.current };
  }
  function Nt(At, hn) {
    return { $$typeof: oe, type: At.type, key: hn, ref: At.ref, props: At.props, _owner: At._owner };
  }
  function Ft(At) {
    return typeof At == "object" && At !== null && At.$$typeof === oe;
  }
  function on(At) {
    var hn = { "=": "=0", ":": "=2" };
    return "$" + At.replace(/[=:]/g, function(Yn) {
      return hn[Yn];
    });
  }
  var en = /\/+/g;
  function wn(At, hn) {
    return typeof At == "object" && At !== null && At.key != null ? on("" + At.key) : hn.toString(36);
  }
  function Zt(At, hn, Yn, Un, Ht) {
    var _n = typeof At;
    (_n === "undefined" || _n === "boolean") && (At = null);
    var Vn = !1;
    if (At === null)
      Vn = !0;
    else
      switch (_n) {
        case "string":
        case "number":
          Vn = !0;
          break;
        case "object":
          switch (At.$$typeof) {
            case oe:
            case ae:
              Vn = !0;
          }
      }
    if (Vn)
      return Vn = At, Ht = Ht(Vn), At = Un === "" ? "." + wn(Vn, 0) : Un, pt(Ht) ? (Yn = "", At != null && (Yn = At.replace(en, "$&/") + "/"), Zt(Ht, hn, Yn, "", function(Er) {
        return Er;
      })) : Ht != null && (Ft(Ht) && (Ht = Nt(Ht, Yn + (!Ht.key || Vn && Vn.key === Ht.key ? "" : ("" + Ht.key).replace(en, "$&/") + "/") + At)), hn.push(Ht)), 1;
    if (Vn = 0, Un = Un === "" ? "." : Un + ":", pt(At))
      for (var br = 0; br < At.length; br++) {
        _n = At[br];
        var nr = Un + wn(_n, br);
        Vn += Zt(_n, hn, Yn, nr, Ht);
      }
    else if (nr = Be(At), typeof nr == "function")
      for (At = nr.call(At), br = 0; !(_n = At.next()).done; )
        _n = _n.value, nr = Un + wn(_n, br++), Vn += Zt(_n, hn, Yn, nr, Ht);
    else if (_n === "object")
      throw hn = String(At), Error("Objects are not valid as a React child (found: " + (hn === "[object Object]" ? "object with keys {" + Object.keys(At).join(", ") + "}" : hn) + "). If you meant to render a collection of children, use an array instead.");
    return Vn;
  }
  function pn(At, hn, Yn) {
    if (At == null)
      return At;
    var Un = [], Ht = 0;
    return Zt(At, Un, "", "", function(_n) {
      return hn.call(Yn, _n, Ht++);
    }), Un;
  }
  function un(At) {
    if (At._status === -1) {
      var hn = At._result;
      hn = hn(), hn.then(function(Yn) {
        (At._status === 0 || At._status === -1) && (At._status = 1, At._result = Yn);
      }, function(Yn) {
        (At._status === 0 || At._status === -1) && (At._status = 2, At._result = Yn);
      }), At._status === -1 && (At._status = 0, At._result = hn);
    }
    if (At._status === 1)
      return At._result.default;
    throw At._result;
  }
  var dn = { current: null }, xn = { transition: null }, Rn = { ReactCurrentDispatcher: dn, ReactCurrentBatchConfig: xn, ReactCurrentOwner: wt };
  ne.Children = { map: pn, forEach: function(At, hn, Yn) {
    pn(At, function() {
      hn.apply(this, arguments);
    }, Yn);
  }, count: function(At) {
    var hn = 0;
    return pn(At, function() {
      hn++;
    }), hn;
  }, toArray: function(At) {
    return pn(At, function(hn) {
      return hn;
    }) || [];
  }, only: function(At) {
    if (!Ft(At))
      throw Error("React.Children.only expected to receive a single React element child.");
    return At;
  } }, ne.Component = qe, ne.Fragment = fe, ne.Profiler = ge, ne.PureComponent = Xe, ne.StrictMode = ye, ne.Suspense = Ie, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Rn, ne.cloneElement = function(At, hn, Yn) {
    if (At == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + At + ".");
    var Un = He({}, At.props), Ht = At.key, _n = At.ref, Vn = At._owner;
    if (hn != null) {
      if (hn.ref !== void 0 && (_n = hn.ref, Vn = wt.current), hn.key !== void 0 && (Ht = "" + hn.key), At.type && At.type.defaultProps)
        var br = At.type.defaultProps;
      for (nr in hn)
        ht.call(hn, nr) && !gt.hasOwnProperty(nr) && (Un[nr] = hn[nr] === void 0 && br !== void 0 ? br[nr] : hn[nr]);
    }
    var nr = arguments.length - 2;
    if (nr === 1)
      Un.children = Yn;
    else if (1 < nr) {
      br = Array(nr);
      for (var Er = 0; Er < nr; Er++)
        br[Er] = arguments[Er + 2];
      Un.children = br;
    }
    return { $$typeof: oe, type: At.type, key: Ht, ref: _n, props: Un, _owner: Vn };
  }, ne.createContext = function(At) {
    return At = { $$typeof: _e, _currentValue: At, _currentValue2: At, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, At.Provider = { $$typeof: we, _context: At }, At.Consumer = At;
  }, ne.createElement = It, ne.createFactory = function(At) {
    var hn = It.bind(null, At);
    return hn.type = At, hn;
  }, ne.createRef = function() {
    return { current: null };
  }, ne.forwardRef = function(At) {
    return { $$typeof: Se, render: At };
  }, ne.isValidElement = Ft, ne.lazy = function(At) {
    return { $$typeof: Ne, _payload: { _status: -1, _result: At }, _init: un };
  }, ne.memo = function(At, hn) {
    return { $$typeof: $e, type: At, compare: hn === void 0 ? null : hn };
  }, ne.startTransition = function(At) {
    var hn = xn.transition;
    xn.transition = {};
    try {
      At();
    } finally {
      xn.transition = hn;
    }
  }, ne.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, ne.useCallback = function(At, hn) {
    return dn.current.useCallback(At, hn);
  }, ne.useContext = function(At) {
    return dn.current.useContext(At);
  }, ne.useDebugValue = function() {
  }, ne.useDeferredValue = function(At) {
    return dn.current.useDeferredValue(At);
  }, ne.useEffect = function(At, hn) {
    return dn.current.useEffect(At, hn);
  }, ne.useId = function() {
    return dn.current.useId();
  }, ne.useImperativeHandle = function(At, hn, Yn) {
    return dn.current.useImperativeHandle(At, hn, Yn);
  }, ne.useInsertionEffect = function(At, hn) {
    return dn.current.useInsertionEffect(At, hn);
  }, ne.useLayoutEffect = function(At, hn) {
    return dn.current.useLayoutEffect(At, hn);
  }, ne.useMemo = function(At, hn) {
    return dn.current.useMemo(At, hn);
  }, ne.useReducer = function(At, hn, Yn) {
    return dn.current.useReducer(At, hn, Yn);
  }, ne.useRef = function(At) {
    return dn.current.useRef(At);
  }, ne.useState = function(At) {
    return dn.current.useState(At);
  }, ne.useSyncExternalStore = function(At, hn, Yn) {
    return dn.current.useSyncExternalStore(At, hn, Yn);
  }, ne.useTransition = function() {
    return dn.current.useTransition();
  }, ne.version = "18.2.0";
}), Qj = M((ne, oe) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ae = "18.2.0", fe = Symbol.for("react.element"), ye = Symbol.for("react.portal"), ge = Symbol.for("react.fragment"), we = Symbol.for("react.strict_mode"), _e = Symbol.for("react.profiler"), Se = Symbol.for("react.provider"), Ie = Symbol.for("react.context"), $e = Symbol.for("react.forward_ref"), Ne = Symbol.for("react.suspense"), Me = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), Ze = Symbol.iterator, qe = "@@iterator";
    function tt(it) {
      if (it === null || typeof it != "object")
        return null;
      var Ct = Ze && it[Ze] || it[qe];
      return typeof Ct == "function" ? Ct : null;
    }
    var Xe = { current: null }, ot = { transition: null }, pt = { current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1 }, ht = { current: null }, wt = {}, gt = null;
    function It(it) {
      gt = it;
    }
    wt.setExtraStackFrame = function(it) {
      gt = it;
    }, wt.getCurrentStack = null, wt.getStackAddendum = function() {
      var it = "";
      gt && (it += gt);
      var Ct = wt.getCurrentStack;
      return Ct && (it += Ct() || ""), it;
    };
    var Nt = !1, Ft = !1, on = !1, en = !1, wn = !1, Zt = { ReactCurrentDispatcher: Xe, ReactCurrentBatchConfig: ot, ReactCurrentOwner: ht };
    Zt.ReactDebugCurrentFrame = wt, Zt.ReactCurrentActQueue = pt;
    function pn(it) {
      {
        for (var Ct = arguments.length, Kt = new Array(Ct > 1 ? Ct - 1 : 0), mn = 1; mn < Ct; mn++)
          Kt[mn - 1] = arguments[mn];
        dn("warn", it, Kt);
      }
    }
    function un(it) {
      {
        for (var Ct = arguments.length, Kt = new Array(Ct > 1 ? Ct - 1 : 0), mn = 1; mn < Ct; mn++)
          Kt[mn - 1] = arguments[mn];
        dn("error", it, Kt);
      }
    }
    function dn(it, Ct, Kt) {
      {
        var mn = Zt.ReactDebugCurrentFrame, Sn = mn.getStackAddendum();
        Sn !== "" && (Ct += "%s", Kt = Kt.concat([Sn]));
        var or = Kt.map(function(Jn) {
          return String(Jn);
        });
        or.unshift("Warning: " + Ct), Function.prototype.apply.call(console[it], console, or);
      }
    }
    var xn = {};
    function Rn(it, Ct) {
      {
        var Kt = it.constructor, mn = Kt && (Kt.displayName || Kt.name) || "ReactClass", Sn = mn + "." + Ct;
        if (xn[Sn])
          return;
        un("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Ct, mn), xn[Sn] = !0;
      }
    }
    var At = { isMounted: function(it) {
      return !1;
    }, enqueueForceUpdate: function(it, Ct, Kt) {
      Rn(it, "forceUpdate");
    }, enqueueReplaceState: function(it, Ct, Kt, mn) {
      Rn(it, "replaceState");
    }, enqueueSetState: function(it, Ct, Kt, mn) {
      Rn(it, "setState");
    } }, hn = Object.assign, Yn = {};
    Object.freeze(Yn);
    function Un(it, Ct, Kt) {
      this.props = it, this.context = Ct, this.refs = Yn, this.updater = Kt || At;
    }
    Un.prototype.isReactComponent = {}, Un.prototype.setState = function(it, Ct) {
      if (typeof it != "object" && typeof it != "function" && it != null)
        throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, it, Ct, "setState");
    }, Un.prototype.forceUpdate = function(it) {
      this.updater.enqueueForceUpdate(this, it, "forceUpdate");
    };
    {
      var Ht = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] }, _n = function(it, Ct) {
        Object.defineProperty(Un.prototype, it, { get: function() {
          pn("%s(...) is deprecated in plain JavaScript React classes. %s", Ct[0], Ct[1]);
        } });
      };
      for (var Vn in Ht)
        Ht.hasOwnProperty(Vn) && _n(Vn, Ht[Vn]);
    }
    function br() {
    }
    br.prototype = Un.prototype;
    function nr(it, Ct, Kt) {
      this.props = it, this.context = Ct, this.refs = Yn, this.updater = Kt || At;
    }
    var Er = nr.prototype = new br();
    Er.constructor = nr, hn(Er, Un.prototype), Er.isPureReactComponent = !0;
    function Qo() {
      var it = { current: null };
      return Object.seal(it), it;
    }
    var Yr = Array.isArray;
    function qr(it) {
      return Yr(it);
    }
    function Kr(it) {
      {
        var Ct = typeof Symbol == "function" && Symbol.toStringTag, Kt = Ct && it[Symbol.toStringTag] || it.constructor.name || "Object";
        return Kt;
      }
    }
    function $o(it) {
      try {
        return xo(it), !1;
      } catch {
        return !0;
      }
    }
    function xo(it) {
      return "" + it;
    }
    function _o(it) {
      if ($o(it))
        return un("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Kr(it)), xo(it);
    }
    function ra(it, Ct, Kt) {
      var mn = it.displayName;
      if (mn)
        return mn;
      var Sn = Ct.displayName || Ct.name || "";
      return Sn !== "" ? Kt + "(" + Sn + ")" : Kt;
    }
    function Aa(it) {
      return it.displayName || "Context";
    }
    function Ho(it) {
      if (it == null)
        return null;
      if (typeof it.tag == "number" && un("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof it == "function")
        return it.displayName || it.name || null;
      if (typeof it == "string")
        return it;
      switch (it) {
        case ge:
          return "Fragment";
        case ye:
          return "Portal";
        case _e:
          return "Profiler";
        case we:
          return "StrictMode";
        case Ne:
          return "Suspense";
        case Me:
          return "SuspenseList";
      }
      if (typeof it == "object")
        switch (it.$$typeof) {
          case Ie:
            var Ct = it;
            return Aa(Ct) + ".Consumer";
          case Se:
            var Kt = it;
            return Aa(Kt._context) + ".Provider";
          case $e:
            return ra(it, it.render, "ForwardRef");
          case Be:
            var mn = it.displayName || null;
            return mn !== null ? mn : Ho(it.type) || "Memo";
          case ze: {
            var Sn = it, or = Sn._payload, Jn = Sn._init;
            try {
              return Ho(Jn(or));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ca = Object.prototype.hasOwnProperty, No = { key: !0, ref: !0, __self: !0, __source: !0 }, xa, qa, da;
    da = {};
    function oa(it) {
      if (ca.call(it, "ref")) {
        var Ct = Object.getOwnPropertyDescriptor(it, "ref").get;
        if (Ct && Ct.isReactWarning)
          return !1;
      }
      return it.ref !== void 0;
    }
    function Ka(it) {
      if (ca.call(it, "key")) {
        var Ct = Object.getOwnPropertyDescriptor(it, "key").get;
        if (Ct && Ct.isReactWarning)
          return !1;
      }
      return it.key !== void 0;
    }
    function jo(it, Ct) {
      var Kt = function() {
        xa || (xa = !0, un("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ct));
      };
      Kt.isReactWarning = !0, Object.defineProperty(it, "key", { get: Kt, configurable: !0 });
    }
    function La(it, Ct) {
      var Kt = function() {
        qa || (qa = !0, un("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ct));
      };
      Kt.isReactWarning = !0, Object.defineProperty(it, "ref", { get: Kt, configurable: !0 });
    }
    function $t(it) {
      if (typeof it.ref == "string" && ht.current && it.__self && ht.current.stateNode !== it.__self) {
        var Ct = Ho(ht.current.type);
        da[Ct] || (un('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ct, it.ref), da[Ct] = !0);
      }
    }
    var Vt = function(it, Ct, Kt, mn, Sn, or, Jn) {
      var lr = { $$typeof: fe, type: it, key: Ct, ref: Kt, props: Jn, _owner: or };
      return lr._store = {}, Object.defineProperty(lr._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(lr, "_self", { configurable: !1, enumerable: !1, writable: !1, value: mn }), Object.defineProperty(lr, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Sn }), Object.freeze && (Object.freeze(lr.props), Object.freeze(lr)), lr;
    };
    function rn(it, Ct, Kt) {
      var mn, Sn = {}, or = null, Jn = null, lr = null, Dr = null;
      if (Ct != null) {
        oa(Ct) && (Jn = Ct.ref, $t(Ct)), Ka(Ct) && (_o(Ct.key), or = "" + Ct.key), lr = Ct.__self === void 0 ? null : Ct.__self, Dr = Ct.__source === void 0 ? null : Ct.__source;
        for (mn in Ct)
          ca.call(Ct, mn) && !No.hasOwnProperty(mn) && (Sn[mn] = Ct[mn]);
      }
      var co = arguments.length - 2;
      if (co === 1)
        Sn.children = Kt;
      else if (co > 1) {
        for (var mo = Array(co), Oo = 0; Oo < co; Oo++)
          mo[Oo] = arguments[Oo + 2];
        Object.freeze && Object.freeze(mo), Sn.children = mo;
      }
      if (it && it.defaultProps) {
        var Po = it.defaultProps;
        for (mn in Po)
          Sn[mn] === void 0 && (Sn[mn] = Po[mn]);
      }
      if (or || Jn) {
        var Wo = typeof it == "function" ? it.displayName || it.name || "Unknown" : it;
        or && jo(Sn, Wo), Jn && La(Sn, Wo);
      }
      return Vt(it, or, Jn, lr, Dr, ht.current, Sn);
    }
    function Cn(it, Ct) {
      var Kt = Vt(it.type, Ct, it.ref, it._self, it._source, it._owner, it.props);
      return Kt;
    }
    function Mn(it, Ct, Kt) {
      if (it == null)
        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + it + ".");
      var mn, Sn = hn({}, it.props), or = it.key, Jn = it.ref, lr = it._self, Dr = it._source, co = it._owner;
      if (Ct != null) {
        oa(Ct) && (Jn = Ct.ref, co = ht.current), Ka(Ct) && (_o(Ct.key), or = "" + Ct.key);
        var mo;
        it.type && it.type.defaultProps && (mo = it.type.defaultProps);
        for (mn in Ct)
          ca.call(Ct, mn) && !No.hasOwnProperty(mn) && (Ct[mn] === void 0 && mo !== void 0 ? Sn[mn] = mo[mn] : Sn[mn] = Ct[mn]);
      }
      var Oo = arguments.length - 2;
      if (Oo === 1)
        Sn.children = Kt;
      else if (Oo > 1) {
        for (var Po = Array(Oo), Wo = 0; Wo < Oo; Wo++)
          Po[Wo] = arguments[Wo + 2];
        Sn.children = Po;
      }
      return Vt(it.type, or, Jn, lr, Dr, co, Sn);
    }
    function Bn(it) {
      return typeof it == "object" && it !== null && it.$$typeof === fe;
    }
    var Qn = ".", Kn = ":";
    function jn(it) {
      var Ct = /[=:]/g, Kt = { "=": "=0", ":": "=2" }, mn = it.replace(Ct, function(Sn) {
        return Kt[Sn];
      });
      return "$" + mn;
    }
    var Tr = !1, jr = /\/+/g;
    function bo(it) {
      return it.replace(jr, "$&/");
    }
    function _r(it, Ct) {
      return typeof it == "object" && it !== null && it.key != null ? (_o(it.key), jn("" + it.key)) : Ct.toString(36);
    }
    function Sr(it, Ct, Kt, mn, Sn) {
      var or = typeof it;
      (or === "undefined" || or === "boolean") && (it = null);
      var Jn = !1;
      if (it === null)
        Jn = !0;
      else
        switch (or) {
          case "string":
          case "number":
            Jn = !0;
            break;
          case "object":
            switch (it.$$typeof) {
              case fe:
              case ye:
                Jn = !0;
            }
        }
      if (Jn) {
        var lr = it, Dr = Sn(lr), co = mn === "" ? Qn + _r(lr, 0) : mn;
        if (qr(Dr)) {
          var mo = "";
          co != null && (mo = bo(co) + "/"), Sr(Dr, Ct, mo, "", function(rm) {
            return rm;
          });
        } else
          Dr != null && (Bn(Dr) && (Dr.key && (!lr || lr.key !== Dr.key) && _o(Dr.key), Dr = Cn(Dr, Kt + (Dr.key && (!lr || lr.key !== Dr.key) ? bo("" + Dr.key) + "/" : "") + co)), Ct.push(Dr));
        return 1;
      }
      var Oo, Po, Wo = 0, Xo = mn === "" ? Qn : mn + Kn;
      if (qr(it))
        for (var Jo = 0; Jo < it.length; Jo++)
          Oo = it[Jo], Po = Xo + _r(Oo, Jo), Wo += Sr(Oo, Ct, Kt, Po, Sn);
      else {
        var Bl = tt(it);
        if (typeof Bl == "function") {
          var Kf = it;
          Bl === Kf.entries && (Tr || pn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Tr = !0);
          for (var tm = Bl.call(Kf), nm, Fu = 0; !(nm = tm.next()).done; )
            Oo = nm.value, Po = Xo + _r(Oo, Fu++), Wo += Sr(Oo, Ct, Kt, Po, Sn);
        } else if (or === "object") {
          var Jd = String(it);
          throw new Error("Objects are not valid as a React child (found: " + (Jd === "[object Object]" ? "object with keys {" + Object.keys(it).join(", ") + "}" : Jd) + "). If you meant to render a collection of children, use an array instead.");
        }
      }
      return Wo;
    }
    function Ro(it, Ct, Kt) {
      if (it == null)
        return it;
      var mn = [], Sn = 0;
      return Sr(it, mn, "", "", function(or) {
        return Ct.call(Kt, or, Sn++);
      }), mn;
    }
    function Xa(it) {
      var Ct = 0;
      return Ro(it, function() {
        Ct++;
      }), Ct;
    }
    function Gi(it, Ct, Kt) {
      Ro(it, function() {
        Ct.apply(this, arguments);
      }, Kt);
    }
    function Yi(it) {
      return Ro(it, function(Ct) {
        return Ct;
      }) || [];
    }
    function ei(it) {
      if (!Bn(it))
        throw new Error("React.Children.only expected to receive a single React element child.");
      return it;
    }
    function Si(it) {
      var Ct = { $$typeof: Ie, _currentValue: it, _currentValue2: it, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      Ct.Provider = { $$typeof: Se, _context: Ct };
      var Kt = !1, mn = !1, Sn = !1;
      {
        var or = { $$typeof: Ie, _context: Ct };
        Object.defineProperties(or, { Provider: { get: function() {
          return mn || (mn = !0, un("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Ct.Provider;
        }, set: function(Jn) {
          Ct.Provider = Jn;
        } }, _currentValue: { get: function() {
          return Ct._currentValue;
        }, set: function(Jn) {
          Ct._currentValue = Jn;
        } }, _currentValue2: { get: function() {
          return Ct._currentValue2;
        }, set: function(Jn) {
          Ct._currentValue2 = Jn;
        } }, _threadCount: { get: function() {
          return Ct._threadCount;
        }, set: function(Jn) {
          Ct._threadCount = Jn;
        } }, Consumer: { get: function() {
          return Kt || (Kt = !0, un("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Ct.Consumer;
        } }, displayName: { get: function() {
          return Ct.displayName;
        }, set: function(Jn) {
          Sn || (pn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Jn), Sn = !0);
        } } }), Ct.Consumer = or;
      }
      return Ct._currentRenderer = null, Ct._currentRenderer2 = null, Ct;
    }
    var Da = -1, ti = 0, Ni = 1, Ea = 2;
    function Jr(it) {
      if (it._status === Da) {
        var Ct = it._result, Kt = Ct();
        if (Kt.then(function(or) {
          if (it._status === ti || it._status === Da) {
            var Jn = it;
            Jn._status = Ni, Jn._result = or;
          }
        }, function(or) {
          if (it._status === ti || it._status === Da) {
            var Jn = it;
            Jn._status = Ea, Jn._result = or;
          }
        }), it._status === Da) {
          var mn = it;
          mn._status = ti, mn._result = Kt;
        }
      }
      if (it._status === Ni) {
        var Sn = it._result;
        return Sn === void 0 && un(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Sn), "default" in Sn || un(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Sn), Sn.default;
      } else
        throw it._result;
    }
    function vo(it) {
      var Ct = { _status: Da, _result: it }, Kt = { $$typeof: ze, _payload: Ct, _init: Jr };
      {
        var mn, Sn;
        Object.defineProperties(Kt, { defaultProps: { configurable: !0, get: function() {
          return mn;
        }, set: function(or) {
          un("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), mn = or, Object.defineProperty(Kt, "defaultProps", { enumerable: !0 });
        } }, propTypes: { configurable: !0, get: function() {
          return Sn;
        }, set: function(or) {
          un("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Sn = or, Object.defineProperty(Kt, "propTypes", { enumerable: !0 });
        } } });
      }
      return Kt;
    }
    function aa(it) {
      it != null && it.$$typeof === Be ? un("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof it != "function" ? un("forwardRef requires a render function but was given %s.", it === null ? "null" : typeof it) : it.length !== 0 && it.length !== 2 && un("forwardRef render functions accept exactly two parameters: props and ref. %s", it.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), it != null && (it.defaultProps != null || it.propTypes != null) && un("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
      var Ct = { $$typeof: $e, render: it };
      {
        var Kt;
        Object.defineProperty(Ct, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return Kt;
        }, set: function(mn) {
          Kt = mn, !it.name && !it.displayName && (it.displayName = mn);
        } });
      }
      return Ct;
    }
    var ni;
    ni = Symbol.for("react.module.reference");
    function Ot(it) {
      return !!(typeof it == "string" || typeof it == "function" || it === ge || it === _e || wn || it === we || it === Ne || it === Me || en || it === He || Nt || Ft || on || typeof it == "object" && it !== null && (it.$$typeof === ze || it.$$typeof === Be || it.$$typeof === Se || it.$$typeof === Ie || it.$$typeof === $e || it.$$typeof === ni || it.getModuleId !== void 0));
    }
    function En(it, Ct) {
      Ot(it) || un("memo: The first argument must be a component. Instead received: %s", it === null ? "null" : typeof it);
      var Kt = { $$typeof: Be, type: it, compare: Ct === void 0 ? null : Ct };
      {
        var mn;
        Object.defineProperty(Kt, "displayName", { enumerable: !1, configurable: !0, get: function() {
          return mn;
        }, set: function(Sn) {
          mn = Sn, !it.name && !it.displayName && (it.displayName = Sn);
        } });
      }
      return Kt;
    }
    function An() {
      var it = Xe.current;
      return it === null && un(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), it;
    }
    function ar(it) {
      var Ct = An();
      if (it._context !== void 0) {
        var Kt = it._context;
        Kt.Consumer === it ? un("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Kt.Provider === it && un("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
      }
      return Ct.useContext(it);
    }
    function Rr(it) {
      var Ct = An();
      return Ct.useState(it);
    }
    function Wr(it, Ct, Kt) {
      var mn = An();
      return mn.useReducer(it, Ct, Kt);
    }
    function Lr(it) {
      var Ct = An();
      return Ct.useRef(it);
    }
    function fr(it, Ct) {
      var Kt = An();
      return Kt.useEffect(it, Ct);
    }
    function sa(it, Ct) {
      var Kt = An();
      return Kt.useInsertionEffect(it, Ct);
    }
    function Eo(it, Ct) {
      var Kt = An();
      return Kt.useLayoutEffect(it, Ct);
    }
    function So(it, Ct) {
      var Kt = An();
      return Kt.useCallback(it, Ct);
    }
    function Ca(it, Ct) {
      var Kt = An();
      return Kt.useMemo(it, Ct);
    }
    function zs(it, Ct, Kt) {
      var mn = An();
      return mn.useImperativeHandle(it, Ct, Kt);
    }
    function Ol(it, Ct) {
      {
        var Kt = An();
        return Kt.useDebugValue(it, Ct);
      }
    }
    function Xr() {
      var it = An();
      return it.useTransition();
    }
    function Yf(it) {
      var Ct = An();
      return Ct.useDeferredValue(it);
    }
    function _s() {
      var it = An();
      return it.useId();
    }
    function zr(it, Ct, Kt) {
      var mn = An();
      return mn.useSyncExternalStore(it, Ct, Kt);
    }
    var Pi = 0, Fc, Al, gu, Ci, zc, ri, Uc;
    function Vc() {
    }
    Vc.__reactDisabledLog = !0;
    function Qf() {
      {
        if (Pi === 0) {
          Fc = console.log, Al = console.info, gu = console.warn, Ci = console.error, zc = console.group, ri = console.groupCollapsed, Uc = console.groupEnd;
          var it = { configurable: !0, enumerable: !0, value: Vc, writable: !0 };
          Object.defineProperties(console, { info: it, log: it, warn: it, error: it, group: it, groupCollapsed: it, groupEnd: it });
        }
        Pi++;
      }
    }
    function Cl() {
      {
        if (Pi--, Pi === 0) {
          var it = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: hn({}, it, { value: Fc }), info: hn({}, it, { value: Al }), warn: hn({}, it, { value: gu }), error: hn({}, it, { value: Ci }), group: hn({}, it, { value: zc }), groupCollapsed: hn({}, it, { value: ri }), groupEnd: hn({}, it, { value: Uc }) });
        }
        Pi < 0 && un("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Us = Zt.ReactCurrentDispatcher, xs;
    function Ba(it, Ct, Kt) {
      {
        if (xs === void 0)
          try {
            throw Error();
          } catch (Sn) {
            var mn = Sn.stack.trim().match(/\n( *(at )?)/);
            xs = mn && mn[1] || "";
          }
        return `
` + xs + it;
      }
    }
    var el = !1, su;
    {
      var Hc = typeof WeakMap == "function" ? WeakMap : Map;
      su = new Hc();
    }
    function tl(it, Ct) {
      if (!it || el)
        return "";
      {
        var Kt = su.get(it);
        if (Kt !== void 0)
          return Kt;
      }
      var mn;
      el = !0;
      var Sn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var or;
      or = Us.current, Us.current = null, Qf();
      try {
        if (Ct) {
          var Jn = function() {
            throw Error();
          };
          if (Object.defineProperty(Jn.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Jn, []);
            } catch (Xo) {
              mn = Xo;
            }
            Reflect.construct(it, [], Jn);
          } else {
            try {
              Jn.call();
            } catch (Xo) {
              mn = Xo;
            }
            it.call(Jn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Xo) {
            mn = Xo;
          }
          it();
        }
      } catch (Xo) {
        if (Xo && mn && typeof Xo.stack == "string") {
          for (var lr = Xo.stack.split(`
`), Dr = mn.stack.split(`
`), co = lr.length - 1, mo = Dr.length - 1; co >= 1 && mo >= 0 && lr[co] !== Dr[mo]; )
            mo--;
          for (; co >= 1 && mo >= 0; co--, mo--)
            if (lr[co] !== Dr[mo]) {
              if (co !== 1 || mo !== 1)
                do
                  if (co--, mo--, mo < 0 || lr[co] !== Dr[mo]) {
                    var Oo = `
` + lr[co].replace(" at new ", " at ");
                    return it.displayName && Oo.includes("<anonymous>") && (Oo = Oo.replace("<anonymous>", it.displayName)), typeof it == "function" && su.set(it, Oo), Oo;
                  }
                while (co >= 1 && mo >= 0);
              break;
            }
        }
      } finally {
        el = !1, Us.current = or, Cl(), Error.prepareStackTrace = Sn;
      }
      var Po = it ? it.displayName || it.name : "", Wo = Po ? Ba(Po) : "";
      return typeof it == "function" && su.set(it, Wo), Wo;
    }
    function Zc(it, Ct, Kt) {
      return tl(it, !1);
    }
    function uu(it) {
      var Ct = it.prototype;
      return !!(Ct && Ct.isReactComponent);
    }
    function Rl(it, Ct, Kt) {
      if (it == null)
        return "";
      if (typeof it == "function")
        return tl(it, uu(it));
      if (typeof it == "string")
        return Ba(it);
      switch (it) {
        case Ne:
          return Ba("Suspense");
        case Me:
          return Ba("SuspenseList");
      }
      if (typeof it == "object")
        switch (it.$$typeof) {
          case $e:
            return Zc(it.render);
          case Be:
            return Rl(it.type, Ct, Kt);
          case ze: {
            var mn = it, Sn = mn._payload, or = mn._init;
            try {
              return Rl(or(Sn), Ct, Kt);
            } catch {
            }
          }
        }
      return "";
    }
    var _u = {}, so = Zt.ReactDebugCurrentFrame;
    function Su(it) {
      if (it) {
        var Ct = it._owner, Kt = Rl(it.type, it._source, Ct ? Ct.type : null);
        so.setExtraStackFrame(Kt);
      } else
        so.setExtraStackFrame(null);
    }
    function Yd(it, Ct, Kt, mn, Sn) {
      {
        var or = Function.call.bind(ca);
        for (var Jn in it)
          if (or(it, Jn)) {
            var lr = void 0;
            try {
              if (typeof it[Jn] != "function") {
                var Dr = Error((mn || "React class") + ": " + Kt + " type `" + Jn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof it[Jn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Dr.name = "Invariant Violation", Dr;
              }
              lr = it[Jn](Ct, Jn, mn, Kt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (co) {
              lr = co;
            }
            lr && !(lr instanceof Error) && (Su(Sn), un("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", mn || "React class", Kt, Jn, typeof lr), Su(null)), lr instanceof Error && !(lr.message in _u) && (_u[lr.message] = !0, Su(Sn), un("Failed %s type: %s", Kt, lr.message), Su(null));
          }
      }
    }
    function Es(it) {
      if (it) {
        var Ct = it._owner, Kt = Rl(it.type, it._source, Ct ? Ct.type : null);
        It(Kt);
      } else
        It(null);
    }
    var uo;
    uo = !1;
    function qc() {
      if (ht.current) {
        var it = Ho(ht.current.type);
        if (it)
          return `

Check the render method of \`` + it + "`.";
      }
      return "";
    }
    function Wc(it) {
      if (it !== void 0) {
        var Ct = it.fileName.replace(/^.*[\\\/]/, ""), Kt = it.lineNumber;
        return `

Check your code at ` + Ct + ":" + Kt + ".";
      }
      return "";
    }
    function Ar(it) {
      return it != null ? Wc(it.__source) : "";
    }
    var Pu = {};
    function Zo(it) {
      var Ct = qc();
      if (!Ct) {
        var Kt = typeof it == "string" ? it : it.displayName || it.name;
        Kt && (Ct = `

Check the top-level render call using <` + Kt + ">.");
      }
      return Ct;
    }
    function ii(it, Ct) {
      if (!(!it._store || it._store.validated || it.key != null)) {
        it._store.validated = !0;
        var Kt = Zo(Ct);
        if (!Pu[Kt]) {
          Pu[Kt] = !0;
          var mn = "";
          it && it._owner && it._owner !== ht.current && (mn = " It was passed a child from " + Ho(it._owner.type) + "."), Es(it), un('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Kt, mn), Es(null);
        }
      }
    }
    function si(it, Ct) {
      if (typeof it == "object") {
        if (qr(it))
          for (var Kt = 0; Kt < it.length; Kt++) {
            var mn = it[Kt];
            Bn(mn) && ii(mn, Ct);
          }
        else if (Bn(it))
          it._store && (it._store.validated = !0);
        else if (it) {
          var Sn = tt(it);
          if (typeof Sn == "function" && Sn !== it.entries)
            for (var or = Sn.call(it), Jn; !(Jn = or.next()).done; )
              Bn(Jn.value) && ii(Jn.value, Ct);
        }
      }
    }
    function Iu(it) {
      {
        var Ct = it.type;
        if (Ct == null || typeof Ct == "string")
          return;
        var Kt;
        if (typeof Ct == "function")
          Kt = Ct.propTypes;
        else if (typeof Ct == "object" && (Ct.$$typeof === $e || Ct.$$typeof === Be))
          Kt = Ct.propTypes;
        else
          return;
        if (Kt) {
          var mn = Ho(Ct);
          Yd(Kt, it.props, "prop", mn, it);
        } else if (Ct.PropTypes !== void 0 && !uo) {
          uo = !0;
          var Sn = Ho(Ct);
          un("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Sn || "Unknown");
        }
        typeof Ct.getDefaultProps == "function" && !Ct.getDefaultProps.isReactClassApproved && un("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ko(it) {
      {
        for (var Ct = Object.keys(it.props), Kt = 0; Kt < Ct.length; Kt++) {
          var mn = Ct[Kt];
          if (mn !== "children" && mn !== "key") {
            Es(it), un("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", mn), Es(null);
            break;
          }
        }
        it.ref !== null && (Es(it), un("Invalid attribute `ref` supplied to `React.Fragment`."), Es(null));
      }
    }
    function lo(it, Ct, Kt) {
      var mn = Ot(it);
      if (!mn) {
        var Sn = "";
        (it === void 0 || typeof it == "object" && it !== null && Object.keys(it).length === 0) && (Sn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var or = Ar(Ct);
        or ? Sn += or : Sn += qc();
        var Jn;
        it === null ? Jn = "null" : qr(it) ? Jn = "array" : it !== void 0 && it.$$typeof === fe ? (Jn = "<" + (Ho(it.type) || "Unknown") + " />", Sn = " Did you accidentally export a JSX literal instead of a component?") : Jn = typeof it, un("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Jn, Sn);
      }
      var lr = rn.apply(this, arguments);
      if (lr == null)
        return lr;
      if (mn)
        for (var Dr = 2; Dr < arguments.length; Dr++)
          si(arguments[Dr], it);
      return it === ge ? Ko(lr) : Iu(lr), lr;
    }
    var Xd = !1;
    function Mi(it) {
      var Ct = lo.bind(null, it);
      return Ct.type = it, Xd || (Xd = !0, pn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Ct, "type", { enumerable: !1, get: function() {
        return pn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: it }), it;
      } }), Ct;
    }
    function Sa(it, Ct, Kt) {
      for (var mn = Mn.apply(this, arguments), Sn = 2; Sn < arguments.length; Sn++)
        si(arguments[Sn], mn.type);
      return Iu(mn), mn;
    }
    function Vs(it, Ct) {
      var Kt = ot.transition;
      ot.transition = {};
      var mn = ot.transition;
      ot.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        it();
      } finally {
        if (ot.transition = Kt, Kt === null && mn._updatedFibers) {
          var Sn = mn._updatedFibers.size;
          Sn > 10 && pn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), mn._updatedFibers.clear();
        }
      }
    }
    var Gc = !1, Ss = null;
    function Yc(it) {
      if (Ss === null)
        try {
          var Ct = ("require" + Math.random()).slice(0, 7), Kt = oe && oe[Ct];
          Ss = Kt.call(oe, "timers").setImmediate;
        } catch {
          Ss = function(mn) {
            Gc === !1 && (Gc = !0, typeof MessageChannel > "u" && un("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var Sn = new MessageChannel();
            Sn.port1.onmessage = mn, Sn.port2.postMessage(void 0);
          };
        }
      return Ss(it);
    }
    var lu = 0, $u = !1;
    function nl(it) {
      {
        var Ct = lu;
        lu++, pt.current === null && (pt.current = []);
        var Kt = pt.isBatchingLegacy, mn;
        try {
          if (pt.isBatchingLegacy = !0, mn = it(), !Kt && pt.didScheduleLegacyUpdate) {
            var Sn = pt.current;
            Sn !== null && (pt.didScheduleLegacyUpdate = !1, Bu(Sn));
          }
        } catch (Po) {
          throw Ps(Ct), Po;
        } finally {
          pt.isBatchingLegacy = Kt;
        }
        if (mn !== null && typeof mn == "object" && typeof mn.then == "function") {
          var or = mn, Jn = !1, lr = { then: function(Po, Wo) {
            Jn = !0, or.then(function(Xo) {
              Ps(Ct), lu === 0 ? ks(Xo, Po, Wo) : Po(Xo);
            }, function(Xo) {
              Ps(Ct), Wo(Xo);
            });
          } };
          return !$u && typeof Promise < "u" && Promise.resolve().then(function() {
          }).then(function() {
            Jn || ($u = !0, un("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
          }), lr;
        } else {
          var Dr = mn;
          if (Ps(Ct), lu === 0) {
            var co = pt.current;
            co !== null && (Bu(co), pt.current = null);
            var mo = { then: function(Po, Wo) {
              pt.current === null ? (pt.current = [], ks(Dr, Po, Wo)) : Po(Dr);
            } };
            return mo;
          } else {
            var Oo = { then: function(Po, Wo) {
              Po(Dr);
            } };
            return Oo;
          }
        }
      }
    }
    function Ps(it) {
      it !== lu - 1 && un("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), lu = it;
    }
    function ks(it, Ct, Kt) {
      {
        var mn = pt.current;
        if (mn !== null)
          try {
            Bu(mn), Yc(function() {
              mn.length === 0 ? (pt.current = null, Ct(it)) : ks(it, Ct, Kt);
            });
          } catch (Sn) {
            Kt(Sn);
          }
        else
          Ct(it);
      }
    }
    var Nl = !1;
    function Bu(it) {
      if (!Nl) {
        Nl = !0;
        var Ct = 0;
        try {
          for (; Ct < it.length; Ct++) {
            var Kt = it[Ct];
            do
              Kt = Kt(!0);
            while (Kt !== null);
          }
          it.length = 0;
        } catch (mn) {
          throw it = it.slice(Ct + 1), mn;
        } finally {
          Nl = !1;
        }
      }
    }
    var Ml = lo, rl = Sa, Dl = Mi, Qc = { map: Ro, forEach: Gi, count: Xa, toArray: Yi, only: ei };
    ne.Children = Qc, ne.Component = Un, ne.Fragment = ge, ne.Profiler = _e, ne.PureComponent = nr, ne.StrictMode = we, ne.Suspense = Ne, ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Zt, ne.cloneElement = rl, ne.createContext = Si, ne.createElement = Ml, ne.createFactory = Dl, ne.createRef = Qo, ne.forwardRef = aa, ne.isValidElement = Bn, ne.lazy = vo, ne.memo = En, ne.startTransition = Vs, ne.unstable_act = nl, ne.useCallback = So, ne.useContext = ar, ne.useDebugValue = Ol, ne.useDeferredValue = Yf, ne.useEffect = fr, ne.useId = _s, ne.useImperativeHandle = zs, ne.useInsertionEffect = sa, ne.useLayoutEffect = Eo, ne.useMemo = Ca, ne.useReducer = Wr, ne.useRef = Lr, ne.useState = Rr, ne.useSyncExternalStore = zr, ne.useTransition = Xr, ne.version = ae, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), ir = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Gj() : oe.exports = Qj();
}), Xj = M((ne) => {
  var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.fragment"), ye = Object.prototype.hasOwnProperty, ge = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, we = { key: !0, ref: !0, __self: !0, __source: !0 };
  function _e(Se, Ie, $e) {
    var Ne, Me = {}, Be = null, ze = null;
    $e !== void 0 && (Be = "" + $e), Ie.key !== void 0 && (Be = "" + Ie.key), Ie.ref !== void 0 && (ze = Ie.ref);
    for (Ne in Ie)
      ye.call(Ie, Ne) && !we.hasOwnProperty(Ne) && (Me[Ne] = Ie[Ne]);
    if (Se && Se.defaultProps)
      for (Ne in Ie = Se.defaultProps, Ie)
        Me[Ne] === void 0 && (Me[Ne] = Ie[Ne]);
    return { $$typeof: ae, type: Se, key: Be, ref: ze, props: Me, _owner: ge.current };
  }
  ne.Fragment = fe, ne.jsx = _e, ne.jsxs = _e;
}), Jj = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    var oe = ir(), ae = Symbol.for("react.element"), fe = Symbol.for("react.portal"), ye = Symbol.for("react.fragment"), ge = Symbol.for("react.strict_mode"), we = Symbol.for("react.profiler"), _e = Symbol.for("react.provider"), Se = Symbol.for("react.context"), Ie = Symbol.for("react.forward_ref"), $e = Symbol.for("react.suspense"), Ne = Symbol.for("react.suspense_list"), Me = Symbol.for("react.memo"), Be = Symbol.for("react.lazy"), ze = Symbol.for("react.offscreen"), He = Symbol.iterator, Ze = "@@iterator";
    function qe(Ot) {
      if (Ot === null || typeof Ot != "object")
        return null;
      var En = He && Ot[He] || Ot[Ze];
      return typeof En == "function" ? En : null;
    }
    var tt = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Xe(Ot) {
      {
        for (var En = arguments.length, An = new Array(En > 1 ? En - 1 : 0), ar = 1; ar < En; ar++)
          An[ar - 1] = arguments[ar];
        ot("error", Ot, An);
      }
    }
    function ot(Ot, En, An) {
      {
        var ar = tt.ReactDebugCurrentFrame, Rr = ar.getStackAddendum();
        Rr !== "" && (En += "%s", An = An.concat([Rr]));
        var Wr = An.map(function(Lr) {
          return String(Lr);
        });
        Wr.unshift("Warning: " + En), Function.prototype.apply.call(console[Ot], console, Wr);
      }
    }
    var pt = !1, ht = !1, wt = !1, gt = !1, It = !1, Nt;
    Nt = Symbol.for("react.module.reference");
    function Ft(Ot) {
      return !!(typeof Ot == "string" || typeof Ot == "function" || Ot === ye || Ot === we || It || Ot === ge || Ot === $e || Ot === Ne || gt || Ot === ze || pt || ht || wt || typeof Ot == "object" && Ot !== null && (Ot.$$typeof === Be || Ot.$$typeof === Me || Ot.$$typeof === _e || Ot.$$typeof === Se || Ot.$$typeof === Ie || Ot.$$typeof === Nt || Ot.getModuleId !== void 0));
    }
    function on(Ot, En, An) {
      var ar = Ot.displayName;
      if (ar)
        return ar;
      var Rr = En.displayName || En.name || "";
      return Rr !== "" ? An + "(" + Rr + ")" : An;
    }
    function en(Ot) {
      return Ot.displayName || "Context";
    }
    function wn(Ot) {
      if (Ot == null)
        return null;
      if (typeof Ot.tag == "number" && Xe("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ot == "function")
        return Ot.displayName || Ot.name || null;
      if (typeof Ot == "string")
        return Ot;
      switch (Ot) {
        case ye:
          return "Fragment";
        case fe:
          return "Portal";
        case we:
          return "Profiler";
        case ge:
          return "StrictMode";
        case $e:
          return "Suspense";
        case Ne:
          return "SuspenseList";
      }
      if (typeof Ot == "object")
        switch (Ot.$$typeof) {
          case Se:
            var En = Ot;
            return en(En) + ".Consumer";
          case _e:
            var An = Ot;
            return en(An._context) + ".Provider";
          case Ie:
            return on(Ot, Ot.render, "ForwardRef");
          case Me:
            var ar = Ot.displayName || null;
            return ar !== null ? ar : wn(Ot.type) || "Memo";
          case Be: {
            var Rr = Ot, Wr = Rr._payload, Lr = Rr._init;
            try {
              return wn(Lr(Wr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Zt = Object.assign, pn = 0, un, dn, xn, Rn, At, hn, Yn;
    function Un() {
    }
    Un.__reactDisabledLog = !0;
    function Ht() {
      {
        if (pn === 0) {
          un = console.log, dn = console.info, xn = console.warn, Rn = console.error, At = console.group, hn = console.groupCollapsed, Yn = console.groupEnd;
          var Ot = { configurable: !0, enumerable: !0, value: Un, writable: !0 };
          Object.defineProperties(console, { info: Ot, log: Ot, warn: Ot, error: Ot, group: Ot, groupCollapsed: Ot, groupEnd: Ot });
        }
        pn++;
      }
    }
    function _n() {
      {
        if (pn--, pn === 0) {
          var Ot = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: Zt({}, Ot, { value: un }), info: Zt({}, Ot, { value: dn }), warn: Zt({}, Ot, { value: xn }), error: Zt({}, Ot, { value: Rn }), group: Zt({}, Ot, { value: At }), groupCollapsed: Zt({}, Ot, { value: hn }), groupEnd: Zt({}, Ot, { value: Yn }) });
        }
        pn < 0 && Xe("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Vn = tt.ReactCurrentDispatcher, br;
    function nr(Ot, En, An) {
      {
        if (br === void 0)
          try {
            throw Error();
          } catch (Rr) {
            var ar = Rr.stack.trim().match(/\n( *(at )?)/);
            br = ar && ar[1] || "";
          }
        return `
` + br + Ot;
      }
    }
    var Er = !1, Qo;
    {
      var Yr = typeof WeakMap == "function" ? WeakMap : Map;
      Qo = new Yr();
    }
    function qr(Ot, En) {
      if (!Ot || Er)
        return "";
      {
        var An = Qo.get(Ot);
        if (An !== void 0)
          return An;
      }
      var ar;
      Er = !0;
      var Rr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Wr;
      Wr = Vn.current, Vn.current = null, Ht();
      try {
        if (En) {
          var Lr = function() {
            throw Error();
          };
          if (Object.defineProperty(Lr.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Lr, []);
            } catch (Xr) {
              ar = Xr;
            }
            Reflect.construct(Ot, [], Lr);
          } else {
            try {
              Lr.call();
            } catch (Xr) {
              ar = Xr;
            }
            Ot.call(Lr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Xr) {
            ar = Xr;
          }
          Ot();
        }
      } catch (Xr) {
        if (Xr && ar && typeof Xr.stack == "string") {
          for (var fr = Xr.stack.split(`
`), sa = ar.stack.split(`
`), Eo = fr.length - 1, So = sa.length - 1; Eo >= 1 && So >= 0 && fr[Eo] !== sa[So]; )
            So--;
          for (; Eo >= 1 && So >= 0; Eo--, So--)
            if (fr[Eo] !== sa[So]) {
              if (Eo !== 1 || So !== 1)
                do
                  if (Eo--, So--, So < 0 || fr[Eo] !== sa[So]) {
                    var Ca = `
` + fr[Eo].replace(" at new ", " at ");
                    return Ot.displayName && Ca.includes("<anonymous>") && (Ca = Ca.replace("<anonymous>", Ot.displayName)), typeof Ot == "function" && Qo.set(Ot, Ca), Ca;
                  }
                while (Eo >= 1 && So >= 0);
              break;
            }
        }
      } finally {
        Er = !1, Vn.current = Wr, _n(), Error.prepareStackTrace = Rr;
      }
      var zs = Ot ? Ot.displayName || Ot.name : "", Ol = zs ? nr(zs) : "";
      return typeof Ot == "function" && Qo.set(Ot, Ol), Ol;
    }
    function Kr(Ot, En, An) {
      return qr(Ot, !1);
    }
    function $o(Ot) {
      var En = Ot.prototype;
      return !!(En && En.isReactComponent);
    }
    function xo(Ot, En, An) {
      if (Ot == null)
        return "";
      if (typeof Ot == "function")
        return qr(Ot, $o(Ot));
      if (typeof Ot == "string")
        return nr(Ot);
      switch (Ot) {
        case $e:
          return nr("Suspense");
        case Ne:
          return nr("SuspenseList");
      }
      if (typeof Ot == "object")
        switch (Ot.$$typeof) {
          case Ie:
            return Kr(Ot.render);
          case Me:
            return xo(Ot.type, En, An);
          case Be: {
            var ar = Ot, Rr = ar._payload, Wr = ar._init;
            try {
              return xo(Wr(Rr), En, An);
            } catch {
            }
          }
        }
      return "";
    }
    var _o = Object.prototype.hasOwnProperty, ra = {}, Aa = tt.ReactDebugCurrentFrame;
    function Ho(Ot) {
      if (Ot) {
        var En = Ot._owner, An = xo(Ot.type, Ot._source, En ? En.type : null);
        Aa.setExtraStackFrame(An);
      } else
        Aa.setExtraStackFrame(null);
    }
    function ca(Ot, En, An, ar, Rr) {
      {
        var Wr = Function.call.bind(_o);
        for (var Lr in Ot)
          if (Wr(Ot, Lr)) {
            var fr = void 0;
            try {
              if (typeof Ot[Lr] != "function") {
                var sa = Error((ar || "React class") + ": " + An + " type `" + Lr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ot[Lr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw sa.name = "Invariant Violation", sa;
              }
              fr = Ot[Lr](En, Lr, ar, An, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Eo) {
              fr = Eo;
            }
            fr && !(fr instanceof Error) && (Ho(Rr), Xe("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ar || "React class", An, Lr, typeof fr), Ho(null)), fr instanceof Error && !(fr.message in ra) && (ra[fr.message] = !0, Ho(Rr), Xe("Failed %s type: %s", An, fr.message), Ho(null));
          }
      }
    }
    var No = Array.isArray;
    function xa(Ot) {
      return No(Ot);
    }
    function qa(Ot) {
      {
        var En = typeof Symbol == "function" && Symbol.toStringTag, An = En && Ot[Symbol.toStringTag] || Ot.constructor.name || "Object";
        return An;
      }
    }
    function da(Ot) {
      try {
        return oa(Ot), !1;
      } catch {
        return !0;
      }
    }
    function oa(Ot) {
      return "" + Ot;
    }
    function Ka(Ot) {
      if (da(Ot))
        return Xe("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qa(Ot)), oa(Ot);
    }
    var jo = tt.ReactCurrentOwner, La = { key: !0, ref: !0, __self: !0, __source: !0 }, $t, Vt, rn;
    rn = {};
    function Cn(Ot) {
      if (_o.call(Ot, "ref")) {
        var En = Object.getOwnPropertyDescriptor(Ot, "ref").get;
        if (En && En.isReactWarning)
          return !1;
      }
      return Ot.ref !== void 0;
    }
    function Mn(Ot) {
      if (_o.call(Ot, "key")) {
        var En = Object.getOwnPropertyDescriptor(Ot, "key").get;
        if (En && En.isReactWarning)
          return !1;
      }
      return Ot.key !== void 0;
    }
    function Bn(Ot, En) {
      if (typeof Ot.ref == "string" && jo.current && En && jo.current.stateNode !== En) {
        var An = wn(jo.current.type);
        rn[An] || (Xe('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', wn(jo.current.type), Ot.ref), rn[An] = !0);
      }
    }
    function Qn(Ot, En) {
      {
        var An = function() {
          $t || ($t = !0, Xe("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", En));
        };
        An.isReactWarning = !0, Object.defineProperty(Ot, "key", { get: An, configurable: !0 });
      }
    }
    function Kn(Ot, En) {
      {
        var An = function() {
          Vt || (Vt = !0, Xe("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", En));
        };
        An.isReactWarning = !0, Object.defineProperty(Ot, "ref", { get: An, configurable: !0 });
      }
    }
    var jn = function(Ot, En, An, ar, Rr, Wr, Lr) {
      var fr = { $$typeof: ae, type: Ot, key: En, ref: An, props: Lr, _owner: Wr };
      return fr._store = {}, Object.defineProperty(fr._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(fr, "_self", { configurable: !1, enumerable: !1, writable: !1, value: ar }), Object.defineProperty(fr, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Rr }), Object.freeze && (Object.freeze(fr.props), Object.freeze(fr)), fr;
    };
    function Tr(Ot, En, An, ar, Rr) {
      {
        var Wr, Lr = {}, fr = null, sa = null;
        An !== void 0 && (Ka(An), fr = "" + An), Mn(En) && (Ka(En.key), fr = "" + En.key), Cn(En) && (sa = En.ref, Bn(En, Rr));
        for (Wr in En)
          _o.call(En, Wr) && !La.hasOwnProperty(Wr) && (Lr[Wr] = En[Wr]);
        if (Ot && Ot.defaultProps) {
          var Eo = Ot.defaultProps;
          for (Wr in Eo)
            Lr[Wr] === void 0 && (Lr[Wr] = Eo[Wr]);
        }
        if (fr || sa) {
          var So = typeof Ot == "function" ? Ot.displayName || Ot.name || "Unknown" : Ot;
          fr && Qn(Lr, So), sa && Kn(Lr, So);
        }
        return jn(Ot, fr, sa, Rr, ar, jo.current, Lr);
      }
    }
    var jr = tt.ReactCurrentOwner, bo = tt.ReactDebugCurrentFrame;
    function _r(Ot) {
      if (Ot) {
        var En = Ot._owner, An = xo(Ot.type, Ot._source, En ? En.type : null);
        bo.setExtraStackFrame(An);
      } else
        bo.setExtraStackFrame(null);
    }
    var Sr;
    Sr = !1;
    function Ro(Ot) {
      return typeof Ot == "object" && Ot !== null && Ot.$$typeof === ae;
    }
    function Xa() {
      {
        if (jr.current) {
          var Ot = wn(jr.current.type);
          if (Ot)
            return `

Check the render method of \`` + Ot + "`.";
        }
        return "";
      }
    }
    function Gi(Ot) {
      {
        if (Ot !== void 0) {
          var En = Ot.fileName.replace(/^.*[\\\/]/, ""), An = Ot.lineNumber;
          return `

Check your code at ` + En + ":" + An + ".";
        }
        return "";
      }
    }
    var Yi = {};
    function ei(Ot) {
      {
        var En = Xa();
        if (!En) {
          var An = typeof Ot == "string" ? Ot : Ot.displayName || Ot.name;
          An && (En = `

Check the top-level render call using <` + An + ">.");
        }
        return En;
      }
    }
    function Si(Ot, En) {
      {
        if (!Ot._store || Ot._store.validated || Ot.key != null)
          return;
        Ot._store.validated = !0;
        var An = ei(En);
        if (Yi[An])
          return;
        Yi[An] = !0;
        var ar = "";
        Ot && Ot._owner && Ot._owner !== jr.current && (ar = " It was passed a child from " + wn(Ot._owner.type) + "."), _r(Ot), Xe('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', An, ar), _r(null);
      }
    }
    function Da(Ot, En) {
      {
        if (typeof Ot != "object")
          return;
        if (xa(Ot))
          for (var An = 0; An < Ot.length; An++) {
            var ar = Ot[An];
            Ro(ar) && Si(ar, En);
          }
        else if (Ro(Ot))
          Ot._store && (Ot._store.validated = !0);
        else if (Ot) {
          var Rr = qe(Ot);
          if (typeof Rr == "function" && Rr !== Ot.entries)
            for (var Wr = Rr.call(Ot), Lr; !(Lr = Wr.next()).done; )
              Ro(Lr.value) && Si(Lr.value, En);
        }
      }
    }
    function ti(Ot) {
      {
        var En = Ot.type;
        if (En == null || typeof En == "string")
          return;
        var An;
        if (typeof En == "function")
          An = En.propTypes;
        else if (typeof En == "object" && (En.$$typeof === Ie || En.$$typeof === Me))
          An = En.propTypes;
        else
          return;
        if (An) {
          var ar = wn(En);
          ca(An, Ot.props, "prop", ar, Ot);
        } else if (En.PropTypes !== void 0 && !Sr) {
          Sr = !0;
          var Rr = wn(En);
          Xe("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Rr || "Unknown");
        }
        typeof En.getDefaultProps == "function" && !En.getDefaultProps.isReactClassApproved && Xe("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ni(Ot) {
      {
        for (var En = Object.keys(Ot.props), An = 0; An < En.length; An++) {
          var ar = En[An];
          if (ar !== "children" && ar !== "key") {
            _r(Ot), Xe("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ar), _r(null);
            break;
          }
        }
        Ot.ref !== null && (_r(Ot), Xe("Invalid attribute `ref` supplied to `React.Fragment`."), _r(null));
      }
    }
    function Ea(Ot, En, An, ar, Rr, Wr) {
      {
        var Lr = Ft(Ot);
        if (!Lr) {
          var fr = "";
          (Ot === void 0 || typeof Ot == "object" && Ot !== null && Object.keys(Ot).length === 0) && (fr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sa = Gi(Rr);
          sa ? fr += sa : fr += Xa();
          var Eo;
          Ot === null ? Eo = "null" : xa(Ot) ? Eo = "array" : Ot !== void 0 && Ot.$$typeof === ae ? (Eo = "<" + (wn(Ot.type) || "Unknown") + " />", fr = " Did you accidentally export a JSX literal instead of a component?") : Eo = typeof Ot, Xe("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Eo, fr);
        }
        var So = Tr(Ot, En, An, Rr, Wr);
        if (So == null)
          return So;
        if (Lr) {
          var Ca = En.children;
          if (Ca !== void 0)
            if (ar)
              if (xa(Ca)) {
                for (var zs = 0; zs < Ca.length; zs++)
                  Da(Ca[zs], Ot);
                Object.freeze && Object.freeze(Ca);
              } else
                Xe("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Da(Ca, Ot);
        }
        return Ot === ye ? Ni(So) : ti(So), So;
      }
    }
    function Jr(Ot, En, An) {
      return Ea(Ot, En, An, !0);
    }
    function vo(Ot, En, An) {
      return Ea(Ot, En, An, !1);
    }
    var aa = vo, ni = Jr;
    ne.Fragment = ye, ne.jsx = aa, ne.jsxs = ni;
  }();
}), ke = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = Xj() : oe.exports = Jj();
}), l2 = M((ne) => {
  function oe(dn, xn) {
    var Rn = dn.length;
    dn.push(xn);
    e:
      for (; 0 < Rn; ) {
        var At = Rn - 1 >>> 1, hn = dn[At];
        if (0 < ye(hn, xn))
          dn[At] = xn, dn[Rn] = hn, Rn = At;
        else
          break e;
      }
  }
  function ae(dn) {
    return dn.length === 0 ? null : dn[0];
  }
  function fe(dn) {
    if (dn.length === 0)
      return null;
    var xn = dn[0], Rn = dn.pop();
    if (Rn !== xn) {
      dn[0] = Rn;
      e:
        for (var At = 0, hn = dn.length, Yn = hn >>> 1; At < Yn; ) {
          var Un = 2 * (At + 1) - 1, Ht = dn[Un], _n = Un + 1, Vn = dn[_n];
          if (0 > ye(Ht, Rn))
            _n < hn && 0 > ye(Vn, Ht) ? (dn[At] = Vn, dn[_n] = Rn, At = _n) : (dn[At] = Ht, dn[Un] = Rn, At = Un);
          else if (_n < hn && 0 > ye(Vn, Rn))
            dn[At] = Vn, dn[_n] = Rn, At = _n;
          else
            break e;
        }
    }
    return xn;
  }
  function ye(dn, xn) {
    var Rn = dn.sortIndex - xn.sortIndex;
    return Rn !== 0 ? Rn : dn.id - xn.id;
  }
  typeof performance == "object" && typeof performance.now == "function" ? (ge = performance, ne.unstable_now = function() {
    return ge.now();
  }) : (we = Date, _e = we.now(), ne.unstable_now = function() {
    return we.now() - _e;
  });
  var ge, we, _e, Se = [], Ie = [], $e = 1, Ne = null, Me = 3, Be = !1, ze = !1, He = !1, Ze = typeof setTimeout == "function" ? setTimeout : null, qe = typeof clearTimeout == "function" ? clearTimeout : null, tt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function Xe(dn) {
    for (var xn = ae(Ie); xn !== null; ) {
      if (xn.callback === null)
        fe(Ie);
      else if (xn.startTime <= dn)
        fe(Ie), xn.sortIndex = xn.expirationTime, oe(Se, xn);
      else
        break;
      xn = ae(Ie);
    }
  }
  function ot(dn) {
    if (He = !1, Xe(dn), !ze)
      if (ae(Se) !== null)
        ze = !0, pn(pt);
      else {
        var xn = ae(Ie);
        xn !== null && un(ot, xn.startTime - dn);
      }
  }
  function pt(dn, xn) {
    ze = !1, He && (He = !1, qe(gt), gt = -1), Be = !0;
    var Rn = Me;
    try {
      for (Xe(xn), Ne = ae(Se); Ne !== null && (!(Ne.expirationTime > xn) || dn && !Ft()); ) {
        var At = Ne.callback;
        if (typeof At == "function") {
          Ne.callback = null, Me = Ne.priorityLevel;
          var hn = At(Ne.expirationTime <= xn);
          xn = ne.unstable_now(), typeof hn == "function" ? Ne.callback = hn : Ne === ae(Se) && fe(Se), Xe(xn);
        } else
          fe(Se);
        Ne = ae(Se);
      }
      if (Ne !== null)
        var Yn = !0;
      else {
        var Un = ae(Ie);
        Un !== null && un(ot, Un.startTime - xn), Yn = !1;
      }
      return Yn;
    } finally {
      Ne = null, Me = Rn, Be = !1;
    }
  }
  var ht = !1, wt = null, gt = -1, It = 5, Nt = -1;
  function Ft() {
    return !(ne.unstable_now() - Nt < It);
  }
  function on() {
    if (wt !== null) {
      var dn = ne.unstable_now();
      Nt = dn;
      var xn = !0;
      try {
        xn = wt(!0, dn);
      } finally {
        xn ? en() : (ht = !1, wt = null);
      }
    } else
      ht = !1;
  }
  var en;
  typeof tt == "function" ? en = function() {
    tt(on);
  } : typeof MessageChannel < "u" ? (wn = new MessageChannel(), Zt = wn.port2, wn.port1.onmessage = on, en = function() {
    Zt.postMessage(null);
  }) : en = function() {
    Ze(on, 0);
  };
  var wn, Zt;
  function pn(dn) {
    wt = dn, ht || (ht = !0, en());
  }
  function un(dn, xn) {
    gt = Ze(function() {
      dn(ne.unstable_now());
    }, xn);
  }
  ne.unstable_IdlePriority = 5, ne.unstable_ImmediatePriority = 1, ne.unstable_LowPriority = 4, ne.unstable_NormalPriority = 3, ne.unstable_Profiling = null, ne.unstable_UserBlockingPriority = 2, ne.unstable_cancelCallback = function(dn) {
    dn.callback = null;
  }, ne.unstable_continueExecution = function() {
    ze || Be || (ze = !0, pn(pt));
  }, ne.unstable_forceFrameRate = function(dn) {
    0 > dn || 125 < dn ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : It = 0 < dn ? Math.floor(1e3 / dn) : 5;
  }, ne.unstable_getCurrentPriorityLevel = function() {
    return Me;
  }, ne.unstable_getFirstCallbackNode = function() {
    return ae(Se);
  }, ne.unstable_next = function(dn) {
    switch (Me) {
      case 1:
      case 2:
      case 3:
        var xn = 3;
        break;
      default:
        xn = Me;
    }
    var Rn = Me;
    Me = xn;
    try {
      return dn();
    } finally {
      Me = Rn;
    }
  }, ne.unstable_pauseExecution = function() {
  }, ne.unstable_requestPaint = function() {
  }, ne.unstable_runWithPriority = function(dn, xn) {
    switch (dn) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        dn = 3;
    }
    var Rn = Me;
    Me = dn;
    try {
      return xn();
    } finally {
      Me = Rn;
    }
  }, ne.unstable_scheduleCallback = function(dn, xn, Rn) {
    var At = ne.unstable_now();
    switch (typeof Rn == "object" && Rn !== null ? (Rn = Rn.delay, Rn = typeof Rn == "number" && 0 < Rn ? At + Rn : At) : Rn = At, dn) {
      case 1:
        var hn = -1;
        break;
      case 2:
        hn = 250;
        break;
      case 5:
        hn = 1073741823;
        break;
      case 4:
        hn = 1e4;
        break;
      default:
        hn = 5e3;
    }
    return hn = Rn + hn, dn = { id: $e++, callback: xn, priorityLevel: dn, startTime: Rn, expirationTime: hn, sortIndex: -1 }, Rn > At ? (dn.sortIndex = Rn, oe(Ie, dn), ae(Se) === null && dn === ae(Ie) && (He ? (qe(gt), gt = -1) : He = !0, un(ot, Rn - At))) : (dn.sortIndex = hn, oe(Se, dn), ze || Be || (ze = !0, pn(pt))), dn;
  }, ne.unstable_shouldYield = Ft, ne.unstable_wrapCallback = function(dn) {
    var xn = Me;
    return function() {
      var Rn = Me;
      Me = xn;
      try {
        return dn.apply(this, arguments);
      } finally {
        Me = Rn;
      }
    };
  };
}), s2 = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = !1, ae = !1, fe = 5;
    function ye($t, Vt) {
      var rn = $t.length;
      $t.push(Vt), _e($t, Vt, rn);
    }
    function ge($t) {
      return $t.length === 0 ? null : $t[0];
    }
    function we($t) {
      if ($t.length === 0)
        return null;
      var Vt = $t[0], rn = $t.pop();
      return rn !== Vt && ($t[0] = rn, Se($t, rn, 0)), Vt;
    }
    function _e($t, Vt, rn) {
      for (var Cn = rn; Cn > 0; ) {
        var Mn = Cn - 1 >>> 1, Bn = $t[Mn];
        if (Ie(Bn, Vt) > 0)
          $t[Mn] = Vt, $t[Cn] = Bn, Cn = Mn;
        else
          return;
      }
    }
    function Se($t, Vt, rn) {
      for (var Cn = rn, Mn = $t.length, Bn = Mn >>> 1; Cn < Bn; ) {
        var Qn = (Cn + 1) * 2 - 1, Kn = $t[Qn], jn = Qn + 1, Tr = $t[jn];
        if (Ie(Kn, Vt) < 0)
          jn < Mn && Ie(Tr, Kn) < 0 ? ($t[Cn] = Tr, $t[jn] = Vt, Cn = jn) : ($t[Cn] = Kn, $t[Qn] = Vt, Cn = Qn);
        else if (jn < Mn && Ie(Tr, Vt) < 0)
          $t[Cn] = Tr, $t[jn] = Vt, Cn = jn;
        else
          return;
      }
    }
    function Ie($t, Vt) {
      var rn = $t.sortIndex - Vt.sortIndex;
      return rn !== 0 ? rn : $t.id - Vt.id;
    }
    var $e = 1, Ne = 2, Me = 3, Be = 4, ze = 5, He = typeof performance == "object" && typeof performance.now == "function";
    if (He) {
      var Ze = performance;
      ne.unstable_now = function() {
        return Ze.now();
      };
    } else {
      var qe = Date, tt = qe.now();
      ne.unstable_now = function() {
        return qe.now() - tt;
      };
    }
    var Xe = 1073741823, ot = -1, pt = 250, ht = 5e3, wt = 1e4, gt = Xe, It = [], Nt = [], Ft = 1, on = null, en = Me, wn = !1, Zt = !1, pn = !1, un = typeof setTimeout == "function" ? setTimeout : null, dn = typeof clearTimeout == "function" ? clearTimeout : null, xn = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Rn($t) {
      for (var Vt = ge(Nt); Vt !== null; ) {
        if (Vt.callback === null)
          we(Nt);
        else if (Vt.startTime <= $t)
          we(Nt), Vt.sortIndex = Vt.expirationTime, ye(It, Vt);
        else
          return;
        Vt = ge(Nt);
      }
    }
    function At($t) {
      if (pn = !1, Rn($t), !Zt)
        if (ge(It) !== null)
          Zt = !0, da(hn);
        else {
          var Vt = ge(Nt);
          Vt !== null && oa(At, Vt.startTime - $t);
        }
    }
    function hn($t, Vt) {
      Zt = !1, pn && (pn = !1, Ka()), wn = !0;
      var rn = en;
      try {
        var Cn;
        if (!ae)
          return Yn($t, Vt);
      } finally {
        on = null, en = rn, wn = !1;
      }
    }
    function Yn($t, Vt) {
      var rn = Vt;
      for (Rn(rn), on = ge(It); on !== null && !oe && !(on.expirationTime > rn && (!$t || ra())); ) {
        var Cn = on.callback;
        if (typeof Cn == "function") {
          on.callback = null, en = on.priorityLevel;
          var Mn = on.expirationTime <= rn, Bn = Cn(Mn);
          rn = ne.unstable_now(), typeof Bn == "function" ? on.callback = Bn : on === ge(It) && we(It), Rn(rn);
        } else
          we(It);
        on = ge(It);
      }
      if (on !== null)
        return !0;
      var Qn = ge(Nt);
      return Qn !== null && oa(At, Qn.startTime - rn), !1;
    }
    function Un($t, Vt) {
      switch ($t) {
        case $e:
        case Ne:
        case Me:
        case Be:
        case ze:
          break;
        default:
          $t = Me;
      }
      var rn = en;
      en = $t;
      try {
        return Vt();
      } finally {
        en = rn;
      }
    }
    function Ht($t) {
      var Vt;
      switch (en) {
        case $e:
        case Ne:
        case Me:
          Vt = Me;
          break;
        default:
          Vt = en;
          break;
      }
      var rn = en;
      en = Vt;
      try {
        return $t();
      } finally {
        en = rn;
      }
    }
    function _n($t) {
      var Vt = en;
      return function() {
        var rn = en;
        en = Vt;
        try {
          return $t.apply(this, arguments);
        } finally {
          en = rn;
        }
      };
    }
    function Vn($t, Vt, rn) {
      var Cn = ne.unstable_now(), Mn;
      if (typeof rn == "object" && rn !== null) {
        var Bn = rn.delay;
        typeof Bn == "number" && Bn > 0 ? Mn = Cn + Bn : Mn = Cn;
      } else
        Mn = Cn;
      var Qn;
      switch ($t) {
        case $e:
          Qn = ot;
          break;
        case Ne:
          Qn = pt;
          break;
        case ze:
          Qn = gt;
          break;
        case Be:
          Qn = wt;
          break;
        case Me:
        default:
          Qn = ht;
          break;
      }
      var Kn = Mn + Qn, jn = { id: Ft++, callback: Vt, priorityLevel: $t, startTime: Mn, expirationTime: Kn, sortIndex: -1 };
      return Mn > Cn ? (jn.sortIndex = Mn, ye(Nt, jn), ge(It) === null && jn === ge(Nt) && (pn ? Ka() : pn = !0, oa(At, Mn - Cn))) : (jn.sortIndex = Kn, ye(It, jn), !Zt && !wn && (Zt = !0, da(hn))), jn;
    }
    function br() {
    }
    function nr() {
      !Zt && !wn && (Zt = !0, da(hn));
    }
    function Er() {
      return ge(It);
    }
    function Qo($t) {
      $t.callback = null;
    }
    function Yr() {
      return en;
    }
    var qr = !1, Kr = null, $o = -1, xo = fe, _o = -1;
    function ra() {
      var $t = ne.unstable_now() - _o;
      return !($t < xo);
    }
    function Aa() {
    }
    function Ho($t) {
      if ($t < 0 || $t > 125) {
        console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
        return;
      }
      $t > 0 ? xo = Math.floor(1e3 / $t) : xo = fe;
    }
    var ca = function() {
      if (Kr !== null) {
        var $t = ne.unstable_now();
        _o = $t;
        var Vt = !0, rn = !0;
        try {
          rn = Kr(Vt, $t);
        } finally {
          rn ? No() : (qr = !1, Kr = null);
        }
      } else
        qr = !1;
    }, No;
    if (typeof xn == "function")
      No = function() {
        xn(ca);
      };
    else if (typeof MessageChannel < "u") {
      var xa = new MessageChannel(), qa = xa.port2;
      xa.port1.onmessage = ca, No = function() {
        qa.postMessage(null);
      };
    } else
      No = function() {
        un(ca, 0);
      };
    function da($t) {
      Kr = $t, qr || (qr = !0, No());
    }
    function oa($t, Vt) {
      $o = un(function() {
        $t(ne.unstable_now());
      }, Vt);
    }
    function Ka() {
      dn($o), $o = -1;
    }
    var jo = Aa, La = null;
    ne.unstable_IdlePriority = ze, ne.unstable_ImmediatePriority = $e, ne.unstable_LowPriority = Be, ne.unstable_NormalPriority = Me, ne.unstable_Profiling = La, ne.unstable_UserBlockingPriority = Ne, ne.unstable_cancelCallback = Qo, ne.unstable_continueExecution = nr, ne.unstable_forceFrameRate = Ho, ne.unstable_getCurrentPriorityLevel = Yr, ne.unstable_getFirstCallbackNode = Er, ne.unstable_next = Ht, ne.unstable_pauseExecution = br, ne.unstable_requestPaint = jo, ne.unstable_runWithPriority = Un, ne.unstable_scheduleCallback = Vn, ne.unstable_shouldYield = ra, ne.unstable_wrapCallback = _n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), GR = M((ne, oe) => {
  process.env.NODE_ENV === "production" ? oe.exports = l2() : oe.exports = s2();
}), mz = M((ne) => {
  var oe = ir(), ae = GR();
  function fe(xe) {
    for (var Oe = "https://reactjs.org/docs/error-decoder.html?invariant=" + xe, je = 1; je < arguments.length; je++)
      Oe += "&args[]=" + encodeURIComponent(arguments[je]);
    return "Minified React error #" + xe + "; visit " + Oe + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var ye = /* @__PURE__ */ new Set(), ge = {};
  function we(xe, Oe) {
    _e(xe, Oe), _e(xe + "Capture", Oe);
  }
  function _e(xe, Oe) {
    for (ge[xe] = Oe, xe = 0; xe < Oe.length; xe++)
      ye.add(Oe[xe]);
  }
  var Se = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Ie = Object.prototype.hasOwnProperty, $e = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ne = {}, Me = {};
  function Be(xe) {
    return Ie.call(Me, xe) ? !0 : Ie.call(Ne, xe) ? !1 : $e.test(xe) ? Me[xe] = !0 : (Ne[xe] = !0, !1);
  }
  function ze(xe, Oe, je, Fe) {
    if (je !== null && je.type === 0)
      return !1;
    switch (typeof Oe) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return Fe ? !1 : je !== null ? !je.acceptsBooleans : (xe = xe.toLowerCase().slice(0, 5), xe !== "data-" && xe !== "aria-");
      default:
        return !1;
    }
  }
  function He(xe, Oe, je, Fe) {
    if (Oe === null || typeof Oe > "u" || ze(xe, Oe, je, Fe))
      return !0;
    if (Fe)
      return !1;
    if (je !== null)
      switch (je.type) {
        case 3:
          return !Oe;
        case 4:
          return Oe === !1;
        case 5:
          return isNaN(Oe);
        case 6:
          return isNaN(Oe) || 1 > Oe;
      }
    return !1;
  }
  function Ze(xe, Oe, je, Fe, Ge, Qe, dt) {
    this.acceptsBooleans = Oe === 2 || Oe === 3 || Oe === 4, this.attributeName = Fe, this.attributeNamespace = Ge, this.mustUseProperty = je, this.propertyName = xe, this.type = Oe, this.sanitizeURL = Qe, this.removeEmptyString = dt;
  }
  var qe = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(xe) {
    qe[xe] = new Ze(xe, 0, !1, xe, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(xe) {
    var Oe = xe[0];
    qe[Oe] = new Ze(Oe, 1, !1, xe[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 2, !1, xe.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 2, !1, xe, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(xe) {
    qe[xe] = new Ze(xe, 3, !1, xe.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 3, !0, xe, null, !1, !1);
  }), ["capture", "download"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 4, !1, xe, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 6, !1, xe, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 5, !1, xe.toLowerCase(), null, !1, !1);
  });
  var tt = /[\-:]([a-z])/g;
  function Xe(xe) {
    return xe[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(xe) {
    var Oe = xe.replace(tt, Xe);
    qe[Oe] = new Ze(Oe, 1, !1, xe, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(xe) {
    var Oe = xe.replace(tt, Xe);
    qe[Oe] = new Ze(Oe, 1, !1, xe, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(xe) {
    var Oe = xe.replace(tt, Xe);
    qe[Oe] = new Ze(Oe, 1, !1, xe, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 1, !1, xe.toLowerCase(), null, !1, !1);
  }), qe.xlinkHref = new Ze("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(xe) {
    qe[xe] = new Ze(xe, 1, !1, xe.toLowerCase(), null, !0, !0);
  });
  function ot(xe, Oe, je, Fe) {
    var Ge = qe.hasOwnProperty(Oe) ? qe[Oe] : null;
    (Ge !== null ? Ge.type !== 0 : Fe || !(2 < Oe.length) || Oe[0] !== "o" && Oe[0] !== "O" || Oe[1] !== "n" && Oe[1] !== "N") && (He(Oe, je, Ge, Fe) && (je = null), Fe || Ge === null ? Be(Oe) && (je === null ? xe.removeAttribute(Oe) : xe.setAttribute(Oe, "" + je)) : Ge.mustUseProperty ? xe[Ge.propertyName] = je === null ? Ge.type === 3 ? !1 : "" : je : (Oe = Ge.attributeName, Fe = Ge.attributeNamespace, je === null ? xe.removeAttribute(Oe) : (Ge = Ge.type, je = Ge === 3 || Ge === 4 && je === !0 ? "" : "" + je, Fe ? xe.setAttributeNS(Fe, Oe, je) : xe.setAttribute(Oe, je))));
  }
  var pt = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ht = Symbol.for("react.element"), wt = Symbol.for("react.portal"), gt = Symbol.for("react.fragment"), It = Symbol.for("react.strict_mode"), Nt = Symbol.for("react.profiler"), Ft = Symbol.for("react.provider"), on = Symbol.for("react.context"), en = Symbol.for("react.forward_ref"), wn = Symbol.for("react.suspense"), Zt = Symbol.for("react.suspense_list"), pn = Symbol.for("react.memo"), un = Symbol.for("react.lazy"), dn = Symbol.for("react.offscreen"), xn = Symbol.iterator;
  function Rn(xe) {
    return xe === null || typeof xe != "object" ? null : (xe = xn && xe[xn] || xe["@@iterator"], typeof xe == "function" ? xe : null);
  }
  var At = Object.assign, hn;
  function Yn(xe) {
    if (hn === void 0)
      try {
        throw Error();
      } catch (je) {
        var Oe = je.stack.trim().match(/\n( *(at )?)/);
        hn = Oe && Oe[1] || "";
      }
    return `
` + hn + xe;
  }
  var Un = !1;
  function Ht(xe, Oe) {
    if (!xe || Un)
      return "";
    Un = !0;
    var je = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (Oe)
        if (Oe = function() {
          throw Error();
        }, Object.defineProperty(Oe.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(Oe, []);
          } catch (an) {
            var Fe = an;
          }
          Reflect.construct(xe, [], Oe);
        } else {
          try {
            Oe.call();
          } catch (an) {
            Fe = an;
          }
          xe.call(Oe.prototype);
        }
      else {
        try {
          throw Error();
        } catch (an) {
          Fe = an;
        }
        xe();
      }
    } catch (an) {
      if (an && Fe && typeof an.stack == "string") {
        for (var Ge = an.stack.split(`
`), Qe = Fe.stack.split(`
`), dt = Ge.length - 1, St = Qe.length - 1; 1 <= dt && 0 <= St && Ge[dt] !== Qe[St]; )
          St--;
        for (; 1 <= dt && 0 <= St; dt--, St--)
          if (Ge[dt] !== Qe[St]) {
            if (dt !== 1 || St !== 1)
              do
                if (dt--, St--, 0 > St || Ge[dt] !== Qe[St]) {
                  var Rt = `
` + Ge[dt].replace(" at new ", " at ");
                  return xe.displayName && Rt.includes("<anonymous>") && (Rt = Rt.replace("<anonymous>", xe.displayName)), Rt;
                }
              while (1 <= dt && 0 <= St);
            break;
          }
      }
    } finally {
      Un = !1, Error.prepareStackTrace = je;
    }
    return (xe = xe ? xe.displayName || xe.name : "") ? Yn(xe) : "";
  }
  function _n(xe) {
    switch (xe.tag) {
      case 5:
        return Yn(xe.type);
      case 16:
        return Yn("Lazy");
      case 13:
        return Yn("Suspense");
      case 19:
        return Yn("SuspenseList");
      case 0:
      case 2:
      case 15:
        return xe = Ht(xe.type, !1), xe;
      case 11:
        return xe = Ht(xe.type.render, !1), xe;
      case 1:
        return xe = Ht(xe.type, !0), xe;
      default:
        return "";
    }
  }
  function Vn(xe) {
    if (xe == null)
      return null;
    if (typeof xe == "function")
      return xe.displayName || xe.name || null;
    if (typeof xe == "string")
      return xe;
    switch (xe) {
      case gt:
        return "Fragment";
      case wt:
        return "Portal";
      case Nt:
        return "Profiler";
      case It:
        return "StrictMode";
      case wn:
        return "Suspense";
      case Zt:
        return "SuspenseList";
    }
    if (typeof xe == "object")
      switch (xe.$$typeof) {
        case on:
          return (xe.displayName || "Context") + ".Consumer";
        case Ft:
          return (xe._context.displayName || "Context") + ".Provider";
        case en:
          var Oe = xe.render;
          return xe = xe.displayName, xe || (xe = Oe.displayName || Oe.name || "", xe = xe !== "" ? "ForwardRef(" + xe + ")" : "ForwardRef"), xe;
        case pn:
          return Oe = xe.displayName || null, Oe !== null ? Oe : Vn(xe.type) || "Memo";
        case un:
          Oe = xe._payload, xe = xe._init;
          try {
            return Vn(xe(Oe));
          } catch {
          }
      }
    return null;
  }
  function br(xe) {
    var Oe = xe.type;
    switch (xe.tag) {
      case 24:
        return "Cache";
      case 9:
        return (Oe.displayName || "Context") + ".Consumer";
      case 10:
        return (Oe._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return xe = Oe.render, xe = xe.displayName || xe.name || "", Oe.displayName || (xe !== "" ? "ForwardRef(" + xe + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return Oe;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Vn(Oe);
      case 8:
        return Oe === It ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof Oe == "function")
          return Oe.displayName || Oe.name || null;
        if (typeof Oe == "string")
          return Oe;
    }
    return null;
  }
  function nr(xe) {
    switch (typeof xe) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return xe;
      case "object":
        return xe;
      default:
        return "";
    }
  }
  function Er(xe) {
    var Oe = xe.type;
    return (xe = xe.nodeName) && xe.toLowerCase() === "input" && (Oe === "checkbox" || Oe === "radio");
  }
  function Qo(xe) {
    var Oe = Er(xe) ? "checked" : "value", je = Object.getOwnPropertyDescriptor(xe.constructor.prototype, Oe), Fe = "" + xe[Oe];
    if (!xe.hasOwnProperty(Oe) && typeof je < "u" && typeof je.get == "function" && typeof je.set == "function") {
      var Ge = je.get, Qe = je.set;
      return Object.defineProperty(xe, Oe, { configurable: !0, get: function() {
        return Ge.call(this);
      }, set: function(dt) {
        Fe = "" + dt, Qe.call(this, dt);
      } }), Object.defineProperty(xe, Oe, { enumerable: je.enumerable }), { getValue: function() {
        return Fe;
      }, setValue: function(dt) {
        Fe = "" + dt;
      }, stopTracking: function() {
        xe._valueTracker = null, delete xe[Oe];
      } };
    }
  }
  function Yr(xe) {
    xe._valueTracker || (xe._valueTracker = Qo(xe));
  }
  function qr(xe) {
    if (!xe)
      return !1;
    var Oe = xe._valueTracker;
    if (!Oe)
      return !0;
    var je = Oe.getValue(), Fe = "";
    return xe && (Fe = Er(xe) ? xe.checked ? "true" : "false" : xe.value), xe = Fe, xe !== je ? (Oe.setValue(xe), !0) : !1;
  }
  function Kr(xe) {
    if (xe = xe || (typeof document < "u" ? document : void 0), typeof xe > "u")
      return null;
    try {
      return xe.activeElement || xe.body;
    } catch {
      return xe.body;
    }
  }
  function $o(xe, Oe) {
    var je = Oe.checked;
    return At({}, Oe, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: je ?? xe._wrapperState.initialChecked });
  }
  function xo(xe, Oe) {
    var je = Oe.defaultValue == null ? "" : Oe.defaultValue, Fe = Oe.checked != null ? Oe.checked : Oe.defaultChecked;
    je = nr(Oe.value != null ? Oe.value : je), xe._wrapperState = { initialChecked: Fe, initialValue: je, controlled: Oe.type === "checkbox" || Oe.type === "radio" ? Oe.checked != null : Oe.value != null };
  }
  function _o(xe, Oe) {
    Oe = Oe.checked, Oe != null && ot(xe, "checked", Oe, !1);
  }
  function ra(xe, Oe) {
    _o(xe, Oe);
    var je = nr(Oe.value), Fe = Oe.type;
    if (je != null)
      Fe === "number" ? (je === 0 && xe.value === "" || xe.value != je) && (xe.value = "" + je) : xe.value !== "" + je && (xe.value = "" + je);
    else if (Fe === "submit" || Fe === "reset") {
      xe.removeAttribute("value");
      return;
    }
    Oe.hasOwnProperty("value") ? Ho(xe, Oe.type, je) : Oe.hasOwnProperty("defaultValue") && Ho(xe, Oe.type, nr(Oe.defaultValue)), Oe.checked == null && Oe.defaultChecked != null && (xe.defaultChecked = !!Oe.defaultChecked);
  }
  function Aa(xe, Oe, je) {
    if (Oe.hasOwnProperty("value") || Oe.hasOwnProperty("defaultValue")) {
      var Fe = Oe.type;
      if (!(Fe !== "submit" && Fe !== "reset" || Oe.value !== void 0 && Oe.value !== null))
        return;
      Oe = "" + xe._wrapperState.initialValue, je || Oe === xe.value || (xe.value = Oe), xe.defaultValue = Oe;
    }
    je = xe.name, je !== "" && (xe.name = ""), xe.defaultChecked = !!xe._wrapperState.initialChecked, je !== "" && (xe.name = je);
  }
  function Ho(xe, Oe, je) {
    (Oe !== "number" || Kr(xe.ownerDocument) !== xe) && (je == null ? xe.defaultValue = "" + xe._wrapperState.initialValue : xe.defaultValue !== "" + je && (xe.defaultValue = "" + je));
  }
  var ca = Array.isArray;
  function No(xe, Oe, je, Fe) {
    if (xe = xe.options, Oe) {
      Oe = {};
      for (var Ge = 0; Ge < je.length; Ge++)
        Oe["$" + je[Ge]] = !0;
      for (je = 0; je < xe.length; je++)
        Ge = Oe.hasOwnProperty("$" + xe[je].value), xe[je].selected !== Ge && (xe[je].selected = Ge), Ge && Fe && (xe[je].defaultSelected = !0);
    } else {
      for (je = "" + nr(je), Oe = null, Ge = 0; Ge < xe.length; Ge++) {
        if (xe[Ge].value === je) {
          xe[Ge].selected = !0, Fe && (xe[Ge].defaultSelected = !0);
          return;
        }
        Oe !== null || xe[Ge].disabled || (Oe = xe[Ge]);
      }
      Oe !== null && (Oe.selected = !0);
    }
  }
  function xa(xe, Oe) {
    if (Oe.dangerouslySetInnerHTML != null)
      throw Error(fe(91));
    return At({}, Oe, { value: void 0, defaultValue: void 0, children: "" + xe._wrapperState.initialValue });
  }
  function qa(xe, Oe) {
    var je = Oe.value;
    if (je == null) {
      if (je = Oe.children, Oe = Oe.defaultValue, je != null) {
        if (Oe != null)
          throw Error(fe(92));
        if (ca(je)) {
          if (1 < je.length)
            throw Error(fe(93));
          je = je[0];
        }
        Oe = je;
      }
      Oe == null && (Oe = ""), je = Oe;
    }
    xe._wrapperState = { initialValue: nr(je) };
  }
  function da(xe, Oe) {
    var je = nr(Oe.value), Fe = nr(Oe.defaultValue);
    je != null && (je = "" + je, je !== xe.value && (xe.value = je), Oe.defaultValue == null && xe.defaultValue !== je && (xe.defaultValue = je)), Fe != null && (xe.defaultValue = "" + Fe);
  }
  function oa(xe) {
    var Oe = xe.textContent;
    Oe === xe._wrapperState.initialValue && Oe !== "" && Oe !== null && (xe.value = Oe);
  }
  function Ka(xe) {
    switch (xe) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function jo(xe, Oe) {
    return xe == null || xe === "http://www.w3.org/1999/xhtml" ? Ka(Oe) : xe === "http://www.w3.org/2000/svg" && Oe === "foreignObject" ? "http://www.w3.org/1999/xhtml" : xe;
  }
  var La, $t = function(xe) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(Oe, je, Fe, Ge) {
      MSApp.execUnsafeLocalFunction(function() {
        return xe(Oe, je, Fe, Ge);
      });
    } : xe;
  }(function(xe, Oe) {
    if (xe.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in xe)
      xe.innerHTML = Oe;
    else {
      for (La = La || document.createElement("div"), La.innerHTML = "<svg>" + Oe.valueOf().toString() + "</svg>", Oe = La.firstChild; xe.firstChild; )
        xe.removeChild(xe.firstChild);
      for (; Oe.firstChild; )
        xe.appendChild(Oe.firstChild);
    }
  });
  function Vt(xe, Oe) {
    if (Oe) {
      var je = xe.firstChild;
      if (je && je === xe.lastChild && je.nodeType === 3) {
        je.nodeValue = Oe;
        return;
      }
    }
    xe.textContent = Oe;
  }
  var rn = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Cn = ["Webkit", "ms", "Moz", "O"];
  Object.keys(rn).forEach(function(xe) {
    Cn.forEach(function(Oe) {
      Oe = Oe + xe.charAt(0).toUpperCase() + xe.substring(1), rn[Oe] = rn[xe];
    });
  });
  function Mn(xe, Oe, je) {
    return Oe == null || typeof Oe == "boolean" || Oe === "" ? "" : je || typeof Oe != "number" || Oe === 0 || rn.hasOwnProperty(xe) && rn[xe] ? ("" + Oe).trim() : Oe + "px";
  }
  function Bn(xe, Oe) {
    xe = xe.style;
    for (var je in Oe)
      if (Oe.hasOwnProperty(je)) {
        var Fe = je.indexOf("--") === 0, Ge = Mn(je, Oe[je], Fe);
        je === "float" && (je = "cssFloat"), Fe ? xe.setProperty(je, Ge) : xe[je] = Ge;
      }
  }
  var Qn = At({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Kn(xe, Oe) {
    if (Oe) {
      if (Qn[xe] && (Oe.children != null || Oe.dangerouslySetInnerHTML != null))
        throw Error(fe(137, xe));
      if (Oe.dangerouslySetInnerHTML != null) {
        if (Oe.children != null)
          throw Error(fe(60));
        if (typeof Oe.dangerouslySetInnerHTML != "object" || !("__html" in Oe.dangerouslySetInnerHTML))
          throw Error(fe(61));
      }
      if (Oe.style != null && typeof Oe.style != "object")
        throw Error(fe(62));
    }
  }
  function jn(xe, Oe) {
    if (xe.indexOf("-") === -1)
      return typeof Oe.is == "string";
    switch (xe) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tr = null;
  function jr(xe) {
    return xe = xe.target || xe.srcElement || window, xe.correspondingUseElement && (xe = xe.correspondingUseElement), xe.nodeType === 3 ? xe.parentNode : xe;
  }
  var bo = null, _r = null, Sr = null;
  function Ro(xe) {
    if (xe = gp(xe)) {
      if (typeof bo != "function")
        throw Error(fe(280));
      var Oe = xe.stateNode;
      Oe && (Oe = hr(Oe), bo(xe.stateNode, xe.type, Oe));
    }
  }
  function Xa(xe) {
    _r ? Sr ? Sr.push(xe) : Sr = [xe] : _r = xe;
  }
  function Gi() {
    if (_r) {
      var xe = _r, Oe = Sr;
      if (Sr = _r = null, Ro(xe), Oe)
        for (xe = 0; xe < Oe.length; xe++)
          Ro(Oe[xe]);
    }
  }
  function Yi(xe, Oe) {
    return xe(Oe);
  }
  function ei() {
  }
  var Si = !1;
  function Da(xe, Oe, je) {
    if (Si)
      return xe(Oe, je);
    Si = !0;
    try {
      return Yi(xe, Oe, je);
    } finally {
      Si = !1, (_r !== null || Sr !== null) && (ei(), Gi());
    }
  }
  function ti(xe, Oe) {
    var je = xe.stateNode;
    if (je === null)
      return null;
    var Fe = hr(je);
    if (Fe === null)
      return null;
    je = Fe[Oe];
    e:
      switch (Oe) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (Fe = !Fe.disabled) || (xe = xe.type, Fe = !(xe === "button" || xe === "input" || xe === "select" || xe === "textarea")), xe = !Fe;
          break e;
        default:
          xe = !1;
      }
    if (xe)
      return null;
    if (je && typeof je != "function")
      throw Error(fe(231, Oe, typeof je));
    return je;
  }
  var Ni = !1;
  if (Se)
    try {
      Ea = {}, Object.defineProperty(Ea, "passive", { get: function() {
        Ni = !0;
      } }), window.addEventListener("test", Ea, Ea), window.removeEventListener("test", Ea, Ea);
    } catch {
      Ni = !1;
    }
  var Ea;
  function Jr(xe, Oe, je, Fe, Ge, Qe, dt, St, Rt) {
    var an = Array.prototype.slice.call(arguments, 3);
    try {
      Oe.apply(je, an);
    } catch (Pn) {
      this.onError(Pn);
    }
  }
  var vo = !1, aa = null, ni = !1, Ot = null, En = { onError: function(xe) {
    vo = !0, aa = xe;
  } };
  function An(xe, Oe, je, Fe, Ge, Qe, dt, St, Rt) {
    vo = !1, aa = null, Jr.apply(En, arguments);
  }
  function ar(xe, Oe, je, Fe, Ge, Qe, dt, St, Rt) {
    if (An.apply(this, arguments), vo) {
      if (vo) {
        var an = aa;
        vo = !1, aa = null;
      } else
        throw Error(fe(198));
      ni || (ni = !0, Ot = an);
    }
  }
  function Rr(xe) {
    var Oe = xe, je = xe;
    if (xe.alternate)
      for (; Oe.return; )
        Oe = Oe.return;
    else {
      xe = Oe;
      do
        Oe = xe, Oe.flags & 4098 && (je = Oe.return), xe = Oe.return;
      while (xe);
    }
    return Oe.tag === 3 ? je : null;
  }
  function Wr(xe) {
    if (xe.tag === 13) {
      var Oe = xe.memoizedState;
      if (Oe === null && (xe = xe.alternate, xe !== null && (Oe = xe.memoizedState)), Oe !== null)
        return Oe.dehydrated;
    }
    return null;
  }
  function Lr(xe) {
    if (Rr(xe) !== xe)
      throw Error(fe(188));
  }
  function fr(xe) {
    var Oe = xe.alternate;
    if (!Oe) {
      if (Oe = Rr(xe), Oe === null)
        throw Error(fe(188));
      return Oe !== xe ? null : xe;
    }
    for (var je = xe, Fe = Oe; ; ) {
      var Ge = je.return;
      if (Ge === null)
        break;
      var Qe = Ge.alternate;
      if (Qe === null) {
        if (Fe = Ge.return, Fe !== null) {
          je = Fe;
          continue;
        }
        break;
      }
      if (Ge.child === Qe.child) {
        for (Qe = Ge.child; Qe; ) {
          if (Qe === je)
            return Lr(Ge), xe;
          if (Qe === Fe)
            return Lr(Ge), Oe;
          Qe = Qe.sibling;
        }
        throw Error(fe(188));
      }
      if (je.return !== Fe.return)
        je = Ge, Fe = Qe;
      else {
        for (var dt = !1, St = Ge.child; St; ) {
          if (St === je) {
            dt = !0, je = Ge, Fe = Qe;
            break;
          }
          if (St === Fe) {
            dt = !0, Fe = Ge, je = Qe;
            break;
          }
          St = St.sibling;
        }
        if (!dt) {
          for (St = Qe.child; St; ) {
            if (St === je) {
              dt = !0, je = Qe, Fe = Ge;
              break;
            }
            if (St === Fe) {
              dt = !0, Fe = Qe, je = Ge;
              break;
            }
            St = St.sibling;
          }
          if (!dt)
            throw Error(fe(189));
        }
      }
      if (je.alternate !== Fe)
        throw Error(fe(190));
    }
    if (je.tag !== 3)
      throw Error(fe(188));
    return je.stateNode.current === je ? xe : Oe;
  }
  function sa(xe) {
    return xe = fr(xe), xe !== null ? Eo(xe) : null;
  }
  function Eo(xe) {
    if (xe.tag === 5 || xe.tag === 6)
      return xe;
    for (xe = xe.child; xe !== null; ) {
      var Oe = Eo(xe);
      if (Oe !== null)
        return Oe;
      xe = xe.sibling;
    }
    return null;
  }
  var So = ae.unstable_scheduleCallback, Ca = ae.unstable_cancelCallback, zs = ae.unstable_shouldYield, Ol = ae.unstable_requestPaint, Xr = ae.unstable_now, Yf = ae.unstable_getCurrentPriorityLevel, _s = ae.unstable_ImmediatePriority, zr = ae.unstable_UserBlockingPriority, Pi = ae.unstable_NormalPriority, Fc = ae.unstable_LowPriority, Al = ae.unstable_IdlePriority, gu = null, Ci = null;
  function zc(xe) {
    if (Ci && typeof Ci.onCommitFiberRoot == "function")
      try {
        Ci.onCommitFiberRoot(gu, xe, void 0, (xe.current.flags & 128) === 128);
      } catch {
      }
  }
  var ri = Math.clz32 ? Math.clz32 : Qf, Uc = Math.log, Vc = Math.LN2;
  function Qf(xe) {
    return xe >>>= 0, xe === 0 ? 32 : 31 - (Uc(xe) / Vc | 0) | 0;
  }
  var Cl = 64, Us = 4194304;
  function xs(xe) {
    switch (xe & -xe) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return xe & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return xe & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return xe;
    }
  }
  function Ba(xe, Oe) {
    var je = xe.pendingLanes;
    if (je === 0)
      return 0;
    var Fe = 0, Ge = xe.suspendedLanes, Qe = xe.pingedLanes, dt = je & 268435455;
    if (dt !== 0) {
      var St = dt & ~Ge;
      St !== 0 ? Fe = xs(St) : (Qe &= dt, Qe !== 0 && (Fe = xs(Qe)));
    } else
      dt = je & ~Ge, dt !== 0 ? Fe = xs(dt) : Qe !== 0 && (Fe = xs(Qe));
    if (Fe === 0)
      return 0;
    if (Oe !== 0 && Oe !== Fe && !(Oe & Ge) && (Ge = Fe & -Fe, Qe = Oe & -Oe, Ge >= Qe || Ge === 16 && (Qe & 4194240) !== 0))
      return Oe;
    if (Fe & 4 && (Fe |= je & 16), Oe = xe.entangledLanes, Oe !== 0)
      for (xe = xe.entanglements, Oe &= Fe; 0 < Oe; )
        je = 31 - ri(Oe), Ge = 1 << je, Fe |= xe[je], Oe &= ~Ge;
    return Fe;
  }
  function el(xe, Oe) {
    switch (xe) {
      case 1:
      case 2:
      case 4:
        return Oe + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return Oe + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function su(xe, Oe) {
    for (var je = xe.suspendedLanes, Fe = xe.pingedLanes, Ge = xe.expirationTimes, Qe = xe.pendingLanes; 0 < Qe; ) {
      var dt = 31 - ri(Qe), St = 1 << dt, Rt = Ge[dt];
      Rt === -1 ? (!(St & je) || St & Fe) && (Ge[dt] = el(St, Oe)) : Rt <= Oe && (xe.expiredLanes |= St), Qe &= ~St;
    }
  }
  function Hc(xe) {
    return xe = xe.pendingLanes & -1073741825, xe !== 0 ? xe : xe & 1073741824 ? 1073741824 : 0;
  }
  function tl() {
    var xe = Cl;
    return Cl <<= 1, !(Cl & 4194240) && (Cl = 64), xe;
  }
  function Zc(xe) {
    for (var Oe = [], je = 0; 31 > je; je++)
      Oe.push(xe);
    return Oe;
  }
  function uu(xe, Oe, je) {
    xe.pendingLanes |= Oe, Oe !== 536870912 && (xe.suspendedLanes = 0, xe.pingedLanes = 0), xe = xe.eventTimes, Oe = 31 - ri(Oe), xe[Oe] = je;
  }
  function Rl(xe, Oe) {
    var je = xe.pendingLanes & ~Oe;
    xe.pendingLanes = Oe, xe.suspendedLanes = 0, xe.pingedLanes = 0, xe.expiredLanes &= Oe, xe.mutableReadLanes &= Oe, xe.entangledLanes &= Oe, Oe = xe.entanglements;
    var Fe = xe.eventTimes;
    for (xe = xe.expirationTimes; 0 < je; ) {
      var Ge = 31 - ri(je), Qe = 1 << Ge;
      Oe[Ge] = 0, Fe[Ge] = -1, xe[Ge] = -1, je &= ~Qe;
    }
  }
  function _u(xe, Oe) {
    var je = xe.entangledLanes |= Oe;
    for (xe = xe.entanglements; je; ) {
      var Fe = 31 - ri(je), Ge = 1 << Fe;
      Ge & Oe | xe[Fe] & Oe && (xe[Fe] |= Oe), je &= ~Ge;
    }
  }
  var so = 0;
  function Su(xe) {
    return xe &= -xe, 1 < xe ? 4 < xe ? xe & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Yd, Es, uo, qc, Wc, Ar = !1, Pu = [], Zo = null, ii = null, si = null, Iu = /* @__PURE__ */ new Map(), Ko = /* @__PURE__ */ new Map(), lo = [], Xd = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Mi(xe, Oe) {
    switch (xe) {
      case "focusin":
      case "focusout":
        Zo = null;
        break;
      case "dragenter":
      case "dragleave":
        ii = null;
        break;
      case "mouseover":
      case "mouseout":
        si = null;
        break;
      case "pointerover":
      case "pointerout":
        Iu.delete(Oe.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ko.delete(Oe.pointerId);
    }
  }
  function Sa(xe, Oe, je, Fe, Ge, Qe) {
    return xe === null || xe.nativeEvent !== Qe ? (xe = { blockedOn: Oe, domEventName: je, eventSystemFlags: Fe, nativeEvent: Qe, targetContainers: [Ge] }, Oe !== null && (Oe = gp(Oe), Oe !== null && Es(Oe)), xe) : (xe.eventSystemFlags |= Fe, Oe = xe.targetContainers, Ge !== null && Oe.indexOf(Ge) === -1 && Oe.push(Ge), xe);
  }
  function Vs(xe, Oe, je, Fe, Ge) {
    switch (Oe) {
      case "focusin":
        return Zo = Sa(Zo, xe, Oe, je, Fe, Ge), !0;
      case "dragenter":
        return ii = Sa(ii, xe, Oe, je, Fe, Ge), !0;
      case "mouseover":
        return si = Sa(si, xe, Oe, je, Fe, Ge), !0;
      case "pointerover":
        var Qe = Ge.pointerId;
        return Iu.set(Qe, Sa(Iu.get(Qe) || null, xe, Oe, je, Fe, Ge)), !0;
      case "gotpointercapture":
        return Qe = Ge.pointerId, Ko.set(Qe, Sa(Ko.get(Qe) || null, xe, Oe, je, Fe, Ge)), !0;
    }
    return !1;
  }
  function Gc(xe) {
    var Oe = Zs(xe.target);
    if (Oe !== null) {
      var je = Rr(Oe);
      if (je !== null) {
        if (Oe = je.tag, Oe === 13) {
          if (Oe = Wr(je), Oe !== null) {
            xe.blockedOn = Oe, Wc(xe.priority, function() {
              uo(je);
            });
            return;
          }
        } else if (Oe === 3 && je.stateNode.current.memoizedState.isDehydrated) {
          xe.blockedOn = je.tag === 3 ? je.stateNode.containerInfo : null;
          return;
        }
      }
    }
    xe.blockedOn = null;
  }
  function Ss(xe) {
    if (xe.blockedOn !== null)
      return !1;
    for (var Oe = xe.targetContainers; 0 < Oe.length; ) {
      var je = Dl(xe.domEventName, xe.eventSystemFlags, Oe[0], xe.nativeEvent);
      if (je === null) {
        je = xe.nativeEvent;
        var Fe = new je.constructor(je.type, je);
        Tr = Fe, je.target.dispatchEvent(Fe), Tr = null;
      } else
        return Oe = gp(je), Oe !== null && Es(Oe), xe.blockedOn = je, !1;
      Oe.shift();
    }
    return !0;
  }
  function Yc(xe, Oe, je) {
    Ss(xe) && je.delete(Oe);
  }
  function lu() {
    Ar = !1, Zo !== null && Ss(Zo) && (Zo = null), ii !== null && Ss(ii) && (ii = null), si !== null && Ss(si) && (si = null), Iu.forEach(Yc), Ko.forEach(Yc);
  }
  function $u(xe, Oe) {
    xe.blockedOn === Oe && (xe.blockedOn = null, Ar || (Ar = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, lu)));
  }
  function nl(xe) {
    function Oe(Ge) {
      return $u(Ge, xe);
    }
    if (0 < Pu.length) {
      $u(Pu[0], xe);
      for (var je = 1; je < Pu.length; je++) {
        var Fe = Pu[je];
        Fe.blockedOn === xe && (Fe.blockedOn = null);
      }
    }
    for (Zo !== null && $u(Zo, xe), ii !== null && $u(ii, xe), si !== null && $u(si, xe), Iu.forEach(Oe), Ko.forEach(Oe), je = 0; je < lo.length; je++)
      Fe = lo[je], Fe.blockedOn === xe && (Fe.blockedOn = null);
    for (; 0 < lo.length && (je = lo[0], je.blockedOn === null); )
      Gc(je), je.blockedOn === null && lo.shift();
  }
  var Ps = pt.ReactCurrentBatchConfig, ks = !0;
  function Nl(xe, Oe, je, Fe) {
    var Ge = so, Qe = Ps.transition;
    Ps.transition = null;
    try {
      so = 1, Ml(xe, Oe, je, Fe);
    } finally {
      so = Ge, Ps.transition = Qe;
    }
  }
  function Bu(xe, Oe, je, Fe) {
    var Ge = so, Qe = Ps.transition;
    Ps.transition = null;
    try {
      so = 4, Ml(xe, Oe, je, Fe);
    } finally {
      so = Ge, Ps.transition = Qe;
    }
  }
  function Ml(xe, Oe, je, Fe) {
    if (ks) {
      var Ge = Dl(xe, Oe, je, Fe);
      if (Ge === null)
        pm(xe, Oe, Fe, rl, je), Mi(xe, Fe);
      else if (Vs(Ge, xe, Oe, je, Fe))
        Fe.stopPropagation();
      else if (Mi(xe, Fe), Oe & 4 && -1 < Xd.indexOf(xe)) {
        for (; Ge !== null; ) {
          var Qe = gp(Ge);
          if (Qe !== null && Yd(Qe), Qe = Dl(xe, Oe, je, Fe), Qe === null && pm(xe, Oe, Fe, rl, je), Qe === Ge)
            break;
          Ge = Qe;
        }
        Ge !== null && Fe.stopPropagation();
      } else
        pm(xe, Oe, Fe, null, je);
    }
  }
  var rl = null;
  function Dl(xe, Oe, je, Fe) {
    if (rl = null, xe = jr(Fe), xe = Zs(xe), xe !== null)
      if (Oe = Rr(xe), Oe === null)
        xe = null;
      else if (je = Oe.tag, je === 13) {
        if (xe = Wr(Oe), xe !== null)
          return xe;
        xe = null;
      } else if (je === 3) {
        if (Oe.stateNode.current.memoizedState.isDehydrated)
          return Oe.tag === 3 ? Oe.stateNode.containerInfo : null;
        xe = null;
      } else
        Oe !== xe && (xe = null);
    return rl = xe, null;
  }
  function Qc(xe) {
    switch (xe) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Yf()) {
          case _s:
            return 1;
          case zr:
            return 4;
          case Pi:
          case Fc:
            return 16;
          case Al:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var it = null, Ct = null, Kt = null;
  function mn() {
    if (Kt)
      return Kt;
    var xe, Oe = Ct, je = Oe.length, Fe, Ge = "value" in it ? it.value : it.textContent, Qe = Ge.length;
    for (xe = 0; xe < je && Oe[xe] === Ge[xe]; xe++)
      ;
    var dt = je - xe;
    for (Fe = 1; Fe <= dt && Oe[je - Fe] === Ge[Qe - Fe]; Fe++)
      ;
    return Kt = Ge.slice(xe, 1 < Fe ? 1 - Fe : void 0);
  }
  function Sn(xe) {
    var Oe = xe.keyCode;
    return "charCode" in xe ? (xe = xe.charCode, xe === 0 && Oe === 13 && (xe = 13)) : xe = Oe, xe === 10 && (xe = 13), 32 <= xe || xe === 13 ? xe : 0;
  }
  function or() {
    return !0;
  }
  function Jn() {
    return !1;
  }
  function lr(xe) {
    function Oe(je, Fe, Ge, Qe, dt) {
      this._reactName = je, this._targetInst = Ge, this.type = Fe, this.nativeEvent = Qe, this.target = dt, this.currentTarget = null;
      for (var St in xe)
        xe.hasOwnProperty(St) && (je = xe[St], this[St] = je ? je(Qe) : Qe[St]);
      return this.isDefaultPrevented = (Qe.defaultPrevented != null ? Qe.defaultPrevented : Qe.returnValue === !1) ? or : Jn, this.isPropagationStopped = Jn, this;
    }
    return At(Oe.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var je = this.nativeEvent;
      je && (je.preventDefault ? je.preventDefault() : typeof je.returnValue != "unknown" && (je.returnValue = !1), this.isDefaultPrevented = or);
    }, stopPropagation: function() {
      var je = this.nativeEvent;
      je && (je.stopPropagation ? je.stopPropagation() : typeof je.cancelBubble != "unknown" && (je.cancelBubble = !0), this.isPropagationStopped = or);
    }, persist: function() {
    }, isPersistent: or }), Oe;
  }
  var Dr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(xe) {
    return xe.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, co = lr(Dr), mo = At({}, Dr, { view: 0, detail: 0 }), Oo = lr(mo), Po, Wo, Xo, Jo = At({}, mo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Yy, button: 0, buttons: 0, relatedTarget: function(xe) {
    return xe.relatedTarget === void 0 ? xe.fromElement === xe.srcElement ? xe.toElement : xe.fromElement : xe.relatedTarget;
  }, movementX: function(xe) {
    return "movementX" in xe ? xe.movementX : (xe !== Xo && (Xo && xe.type === "mousemove" ? (Po = xe.screenX - Xo.screenX, Wo = xe.screenY - Xo.screenY) : Wo = Po = 0, Xo = xe), Po);
  }, movementY: function(xe) {
    return "movementY" in xe ? xe.movementY : Wo;
  } }), Bl = lr(Jo), Kf = At({}, Jo, { dataTransfer: 0 }), tm = lr(Kf), nm = At({}, mo, { relatedTarget: 0 }), Fu = lr(nm), Jd = At({}, Dr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), rm = lr(Jd), t_ = At({}, Dr, { clipboardData: function(xe) {
    return "clipboardData" in xe ? xe.clipboardData : window.clipboardData;
  } }), n_ = lr(t_), r_ = At({}, Dr, { data: 0 }), Wy = lr(r_), Gy = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, qv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Wv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Gv(xe) {
    var Oe = this.nativeEvent;
    return Oe.getModifierState ? Oe.getModifierState(xe) : (xe = Wv[xe]) ? !!Oe[xe] : !1;
  }
  function Yy() {
    return Gv;
  }
  var ol = At({}, mo, { key: function(xe) {
    if (xe.key) {
      var Oe = Gy[xe.key] || xe.key;
      if (Oe !== "Unidentified")
        return Oe;
    }
    return xe.type === "keypress" ? (xe = Sn(xe), xe === 13 ? "Enter" : String.fromCharCode(xe)) : xe.type === "keydown" || xe.type === "keyup" ? qv[xe.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Yy, charCode: function(xe) {
    return xe.type === "keypress" ? Sn(xe) : 0;
  }, keyCode: function(xe) {
    return xe.type === "keydown" || xe.type === "keyup" ? xe.keyCode : 0;
  }, which: function(xe) {
    return xe.type === "keypress" ? Sn(xe) : xe.type === "keydown" || xe.type === "keyup" ? xe.keyCode : 0;
  } }), o_ = lr(ol), Qy = At({}, Jo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), om = lr(Qy), Ky = At({}, mo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Yy }), a_ = lr(Ky), am = At({}, Dr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Yv = lr(am), ts = At({}, Jo, { deltaX: function(xe) {
    return "deltaX" in xe ? xe.deltaX : "wheelDeltaX" in xe ? -xe.wheelDeltaX : 0;
  }, deltaY: function(xe) {
    return "deltaY" in xe ? xe.deltaY : "wheelDeltaY" in xe ? -xe.wheelDeltaY : "wheelDelta" in xe ? -xe.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 }), al = lr(ts), Pa = [9, 13, 27, 32], cu = Se && "CompositionEvent" in window, Kc = null;
  Se && "documentMode" in document && (Kc = document.documentMode);
  var im = Se && "TextEvent" in window && !Kc, Qv = Se && (!cu || Kc && 8 < Kc && 11 >= Kc), ef = String.fromCharCode(32), Kv = !1;
  function Xv(xe, Oe) {
    switch (xe) {
      case "keyup":
        return Pa.indexOf(Oe.keyCode) !== -1;
      case "keydown":
        return Oe.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function sm(xe) {
    return xe = xe.detail, typeof xe == "object" && "data" in xe ? xe.data : null;
  }
  var tf = !1;
  function i_(xe, Oe) {
    switch (xe) {
      case "compositionend":
        return sm(Oe);
      case "keypress":
        return Oe.which !== 32 ? null : (Kv = !0, ef);
      case "textInput":
        return xe = Oe.data, xe === ef && Kv ? null : xe;
      default:
        return null;
    }
  }
  function s_(xe, Oe) {
    if (tf)
      return xe === "compositionend" || !cu && Xv(xe, Oe) ? (xe = mn(), Kt = Ct = it = null, tf = !1, xe) : null;
    switch (xe) {
      case "paste":
        return null;
      case "keypress":
        if (!(Oe.ctrlKey || Oe.altKey || Oe.metaKey) || Oe.ctrlKey && Oe.altKey) {
          if (Oe.char && 1 < Oe.char.length)
            return Oe.char;
          if (Oe.which)
            return String.fromCharCode(Oe.which);
        }
        return null;
      case "compositionend":
        return Qv && Oe.locale !== "ko" ? null : Oe.data;
      default:
        return null;
    }
  }
  var Jv = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function eg(xe) {
    var Oe = xe && xe.nodeName && xe.nodeName.toLowerCase();
    return Oe === "input" ? !!Jv[xe.type] : Oe === "textarea";
  }
  function tg(xe, Oe, je, Fe) {
    Xa(Fe), Oe = mp(Oe, "onChange"), 0 < Oe.length && (je = new co("onChange", "change", null, je, Fe), xe.push({ event: je, listeners: Oe }));
  }
  var Xf = null, nf = null;
  function rf(xe) {
    fm(xe, 0);
  }
  function af(xe) {
    var Oe = cf(xe);
    if (qr(Oe))
      return xe;
  }
  function ng(xe, Oe) {
    if (xe === "change")
      return Oe;
  }
  var Xy = !1;
  Se && (Se ? (um = "oninput" in document, um || (eb = document.createElement("div"), eb.setAttribute("oninput", "return;"), um = typeof eb.oninput == "function"), Jy = um) : Jy = !1, Xy = Jy && (!document.documentMode || 9 < document.documentMode));
  var Jy, um, eb;
  function rg() {
    Xf && (Xf.detachEvent("onpropertychange", og), nf = Xf = null);
  }
  function og(xe) {
    if (xe.propertyName === "value" && af(nf)) {
      var Oe = [];
      tg(Oe, nf, xe, jr(xe)), Da(rf, Oe);
    }
  }
  function u_(xe, Oe, je) {
    xe === "focusin" ? (rg(), Xf = Oe, nf = je, Xf.attachEvent("onpropertychange", og)) : xe === "focusout" && rg();
  }
  function l_(xe) {
    if (xe === "selectionchange" || xe === "keyup" || xe === "keydown")
      return af(nf);
  }
  function c_(xe, Oe) {
    if (xe === "click")
      return af(Oe);
  }
  function ag(xe, Oe) {
    if (xe === "input" || xe === "change")
      return af(Oe);
  }
  function d_(xe, Oe) {
    return xe === Oe && (xe !== 0 || 1 / xe === 1 / Oe) || xe !== xe && Oe !== Oe;
  }
  var Hs = typeof Object.is == "function" ? Object.is : d_;
  function Jf(xe, Oe) {
    if (Hs(xe, Oe))
      return !0;
    if (typeof xe != "object" || xe === null || typeof Oe != "object" || Oe === null)
      return !1;
    var je = Object.keys(xe), Fe = Object.keys(Oe);
    if (je.length !== Fe.length)
      return !1;
    for (Fe = 0; Fe < je.length; Fe++) {
      var Ge = je[Fe];
      if (!Ie.call(Oe, Ge) || !Hs(xe[Ge], Oe[Ge]))
        return !1;
    }
    return !0;
  }
  function ig(xe) {
    for (; xe && xe.firstChild; )
      xe = xe.firstChild;
    return xe;
  }
  function sg(xe, Oe) {
    var je = ig(xe);
    xe = 0;
    for (var Fe; je; ) {
      if (je.nodeType === 3) {
        if (Fe = xe + je.textContent.length, xe <= Oe && Fe >= Oe)
          return { node: je, offset: Oe - xe };
        xe = Fe;
      }
      e: {
        for (; je; ) {
          if (je.nextSibling) {
            je = je.nextSibling;
            break e;
          }
          je = je.parentNode;
        }
        je = void 0;
      }
      je = ig(je);
    }
  }
  function ug(xe, Oe) {
    return xe && Oe ? xe === Oe ? !0 : xe && xe.nodeType === 3 ? !1 : Oe && Oe.nodeType === 3 ? ug(xe, Oe.parentNode) : "contains" in xe ? xe.contains(Oe) : xe.compareDocumentPosition ? !!(xe.compareDocumentPosition(Oe) & 16) : !1 : !1;
  }
  function lm() {
    for (var xe = window, Oe = Kr(); Oe instanceof xe.HTMLIFrameElement; ) {
      try {
        var je = typeof Oe.contentWindow.location.href == "string";
      } catch {
        je = !1;
      }
      if (je)
        xe = Oe.contentWindow;
      else
        break;
      Oe = Kr(xe.document);
    }
    return Oe;
  }
  function il(xe) {
    var Oe = xe && xe.nodeName && xe.nodeName.toLowerCase();
    return Oe && (Oe === "input" && (xe.type === "text" || xe.type === "search" || xe.type === "tel" || xe.type === "url" || xe.type === "password") || Oe === "textarea" || xe.contentEditable === "true");
  }
  function cm(xe) {
    var Oe = lm(), je = xe.focusedElem, Fe = xe.selectionRange;
    if (Oe !== je && je && je.ownerDocument && ug(je.ownerDocument.documentElement, je)) {
      if (Fe !== null && il(je)) {
        if (Oe = Fe.start, xe = Fe.end, xe === void 0 && (xe = Oe), "selectionStart" in je)
          je.selectionStart = Oe, je.selectionEnd = Math.min(xe, je.value.length);
        else if (xe = (Oe = je.ownerDocument || document) && Oe.defaultView || window, xe.getSelection) {
          xe = xe.getSelection();
          var Ge = je.textContent.length, Qe = Math.min(Fe.start, Ge);
          Fe = Fe.end === void 0 ? Qe : Math.min(Fe.end, Ge), !xe.extend && Qe > Fe && (Ge = Fe, Fe = Qe, Qe = Ge), Ge = sg(je, Qe);
          var dt = sg(je, Fe);
          Ge && dt && (xe.rangeCount !== 1 || xe.anchorNode !== Ge.node || xe.anchorOffset !== Ge.offset || xe.focusNode !== dt.node || xe.focusOffset !== dt.offset) && (Oe = Oe.createRange(), Oe.setStart(Ge.node, Ge.offset), xe.removeAllRanges(), Qe > Fe ? (xe.addRange(Oe), xe.extend(dt.node, dt.offset)) : (Oe.setEnd(dt.node, dt.offset), xe.addRange(Oe)));
        }
      }
      for (Oe = [], xe = je; xe = xe.parentNode; )
        xe.nodeType === 1 && Oe.push({ element: xe, left: xe.scrollLeft, top: xe.scrollTop });
      for (typeof je.focus == "function" && je.focus(), je = 0; je < Oe.length; je++)
        xe = Oe[je], xe.element.scrollLeft = xe.left, xe.element.scrollTop = xe.top;
    }
  }
  var lg = Se && "documentMode" in document && 11 >= document.documentMode, du = null, tb = null, ep = null, nb = !1;
  function cg(xe, Oe, je) {
    var Fe = je.window === je ? je.document : je.nodeType === 9 ? je : je.ownerDocument;
    nb || du == null || du !== Kr(Fe) || (Fe = du, "selectionStart" in Fe && il(Fe) ? Fe = { start: Fe.selectionStart, end: Fe.selectionEnd } : (Fe = (Fe.ownerDocument && Fe.ownerDocument.defaultView || window).getSelection(), Fe = { anchorNode: Fe.anchorNode, anchorOffset: Fe.anchorOffset, focusNode: Fe.focusNode, focusOffset: Fe.focusOffset }), ep && Jf(ep, Fe) || (ep = Fe, Fe = mp(tb, "onSelect"), 0 < Fe.length && (Oe = new co("onSelect", "select", null, Oe, je), xe.push({ event: Oe, listeners: Fe }), Oe.target = du)));
  }
  function dm(xe, Oe) {
    var je = {};
    return je[xe.toLowerCase()] = Oe.toLowerCase(), je["Webkit" + xe] = "webkit" + Oe, je["Moz" + xe] = "moz" + Oe, je;
  }
  var Xc = { animationend: dm("Animation", "AnimationEnd"), animationiteration: dm("Animation", "AnimationIteration"), animationstart: dm("Animation", "AnimationStart"), transitionend: dm("Transition", "TransitionEnd") }, rb = {}, ob = {};
  Se && (ob = document.createElement("div").style, "AnimationEvent" in window || (delete Xc.animationend.animation, delete Xc.animationiteration.animation, delete Xc.animationstart.animation), "TransitionEvent" in window || delete Xc.transitionend.transition);
  function Fa(xe) {
    if (rb[xe])
      return rb[xe];
    if (!Xc[xe])
      return xe;
    var Oe = Xc[xe], je;
    for (je in Oe)
      if (Oe.hasOwnProperty(je) && je in ob)
        return rb[xe] = Oe[je];
    return xe;
  }
  var ab = Fa("animationend"), dg = Fa("animationiteration"), fg = Fa("animationstart"), pg = Fa("transitionend"), hg = /* @__PURE__ */ new Map(), mg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function sl(xe, Oe) {
    hg.set(xe, Oe), we(Oe, [xe]);
  }
  for (Vl = 0; Vl < mg.length; Vl++)
    sf = mg[Vl], uf = sf.toLowerCase(), yg = sf[0].toUpperCase() + sf.slice(1), sl(uf, "on" + yg);
  var sf, uf, yg, Vl;
  sl(ab, "onAnimationEnd"), sl(dg, "onAnimationIteration"), sl(fg, "onAnimationStart"), sl("dblclick", "onDoubleClick"), sl("focusin", "onFocus"), sl("focusout", "onBlur"), sl(pg, "onTransitionEnd"), _e("onMouseEnter", ["mouseout", "mouseover"]), _e("onMouseLeave", ["mouseout", "mouseover"]), _e("onPointerEnter", ["pointerout", "pointerover"]), _e("onPointerLeave", ["pointerout", "pointerover"]), we("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), we("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), we("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), we("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), we("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), we("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var tp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), f_ = new Set("cancel close invalid load scroll toggle".split(" ").concat(tp));
  function bg(xe, Oe, je) {
    var Fe = xe.type || "unknown-event";
    xe.currentTarget = je, ar(Fe, Oe, void 0, xe), xe.currentTarget = null;
  }
  function fm(xe, Oe) {
    Oe = (Oe & 4) !== 0;
    for (var je = 0; je < xe.length; je++) {
      var Fe = xe[je], Ge = Fe.event;
      Fe = Fe.listeners;
      e: {
        var Qe = void 0;
        if (Oe)
          for (var dt = Fe.length - 1; 0 <= dt; dt--) {
            var St = Fe[dt], Rt = St.instance, an = St.currentTarget;
            if (St = St.listener, Rt !== Qe && Ge.isPropagationStopped())
              break e;
            bg(Ge, St, an), Qe = Rt;
          }
        else
          for (dt = 0; dt < Fe.length; dt++) {
            if (St = Fe[dt], Rt = St.instance, an = St.currentTarget, St = St.listener, Rt !== Qe && Ge.isPropagationStopped())
              break e;
            bg(Ge, St, an), Qe = Rt;
          }
      }
    }
    if (ni)
      throw xe = Ot, ni = !1, Ot = null, xe;
  }
  function Ao(xe, Oe) {
    var je = Oe[fb];
    je === void 0 && (je = Oe[fb] = /* @__PURE__ */ new Set());
    var Fe = xe + "__bubble";
    je.has(Fe) || (vg(Oe, xe, 2, !1), je.add(Fe));
  }
  function Hl(xe, Oe, je) {
    var Fe = 0;
    Oe && (Fe |= 4), vg(je, xe, Fe, Oe);
  }
  var ul = "_reactListening" + Math.random().toString(36).slice(2);
  function lf(xe) {
    if (!xe[ul]) {
      xe[ul] = !0, ye.forEach(function(je) {
        je !== "selectionchange" && (f_.has(je) || Hl(je, !1, xe), Hl(je, !0, xe));
      });
      var Oe = xe.nodeType === 9 ? xe : xe.ownerDocument;
      Oe === null || Oe[ul] || (Oe[ul] = !0, Hl("selectionchange", !1, Oe));
    }
  }
  function vg(xe, Oe, je, Fe) {
    switch (Qc(Oe)) {
      case 1:
        var Ge = Nl;
        break;
      case 4:
        Ge = Bu;
        break;
      default:
        Ge = Ml;
    }
    je = Ge.bind(null, Oe, je, xe), Ge = void 0, !Ni || Oe !== "touchstart" && Oe !== "touchmove" && Oe !== "wheel" || (Ge = !0), Fe ? Ge !== void 0 ? xe.addEventListener(Oe, je, { capture: !0, passive: Ge }) : xe.addEventListener(Oe, je, !0) : Ge !== void 0 ? xe.addEventListener(Oe, je, { passive: Ge }) : xe.addEventListener(Oe, je, !1);
  }
  function pm(xe, Oe, je, Fe, Ge) {
    var Qe = Fe;
    if (!(Oe & 1) && !(Oe & 2) && Fe !== null)
      e:
        for (; ; ) {
          if (Fe === null)
            return;
          var dt = Fe.tag;
          if (dt === 3 || dt === 4) {
            var St = Fe.stateNode.containerInfo;
            if (St === Ge || St.nodeType === 8 && St.parentNode === Ge)
              break;
            if (dt === 4)
              for (dt = Fe.return; dt !== null; ) {
                var Rt = dt.tag;
                if ((Rt === 3 || Rt === 4) && (Rt = dt.stateNode.containerInfo, Rt === Ge || Rt.nodeType === 8 && Rt.parentNode === Ge))
                  return;
                dt = dt.return;
              }
            for (; St !== null; ) {
              if (dt = Zs(St), dt === null)
                return;
              if (Rt = dt.tag, Rt === 5 || Rt === 6) {
                Fe = Qe = dt;
                continue e;
              }
              St = St.parentNode;
            }
          }
          Fe = Fe.return;
        }
    Da(function() {
      var an = Qe, Pn = jr(je), In = [];
      e: {
        var kn = hg.get(xe);
        if (kn !== void 0) {
          var qn = co, er = xe;
          switch (xe) {
            case "keypress":
              if (Sn(je) === 0)
                break e;
            case "keydown":
            case "keyup":
              qn = o_;
              break;
            case "focusin":
              er = "focus", qn = Fu;
              break;
            case "focusout":
              er = "blur", qn = Fu;
              break;
            case "beforeblur":
            case "afterblur":
              qn = Fu;
              break;
            case "click":
              if (je.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              qn = Bl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              qn = tm;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              qn = a_;
              break;
            case ab:
            case dg:
            case fg:
              qn = rm;
              break;
            case pg:
              qn = Yv;
              break;
            case "scroll":
              qn = Oo;
              break;
            case "wheel":
              qn = al;
              break;
            case "copy":
            case "cut":
            case "paste":
              qn = n_;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              qn = om;
          }
          var rr = (Oe & 4) !== 0, va = !rr && xe === "scroll", Gt = rr ? kn !== null ? kn + "Capture" : null : kn;
          rr = [];
          for (var Bt = an, Jt; Bt !== null; ) {
            Jt = Bt;
            var Nn = Jt.stateNode;
            if (Jt.tag === 5 && Nn !== null && (Jt = Nn, Gt !== null && (Nn = ti(Bt, Gt), Nn != null && rr.push(hp(Bt, Nn, Jt)))), va)
              break;
            Bt = Bt.return;
          }
          0 < rr.length && (kn = new qn(kn, er, null, je, Pn), In.push({ event: kn, listeners: rr }));
        }
      }
      if (!(Oe & 7)) {
        e: {
          if (kn = xe === "mouseover" || xe === "pointerover", qn = xe === "mouseout" || xe === "pointerout", kn && je !== Tr && (er = je.relatedTarget || je.fromElement) && (Zs(er) || er[ll]))
            break e;
          if ((qn || kn) && (kn = Pn.window === Pn ? Pn : (kn = Pn.ownerDocument) ? kn.defaultView || kn.parentWindow : window, qn ? (er = je.relatedTarget || je.toElement, qn = an, er = er ? Zs(er) : null, er !== null && (va = Rr(er), er !== va || er.tag !== 5 && er.tag !== 6) && (er = null)) : (qn = null, er = an), qn !== er)) {
            if (rr = Bl, Nn = "onMouseLeave", Gt = "onMouseEnter", Bt = "mouse", (xe === "pointerout" || xe === "pointerover") && (rr = om, Nn = "onPointerLeave", Gt = "onPointerEnter", Bt = "pointer"), va = qn == null ? kn : cf(qn), Jt = er == null ? kn : cf(er), kn = new rr(Nn, Bt + "leave", qn, je, Pn), kn.target = va, kn.relatedTarget = Jt, Nn = null, Zs(Pn) === an && (rr = new rr(Gt, Bt + "enter", er, je, Pn), rr.target = Jt, rr.relatedTarget = va, Nn = rr), va = Nn, qn && er)
              t: {
                for (rr = qn, Gt = er, Bt = 0, Jt = rr; Jt; Jt = Jc(Jt))
                  Bt++;
                for (Jt = 0, Nn = Gt; Nn; Nn = Jc(Nn))
                  Jt++;
                for (; 0 < Bt - Jt; )
                  rr = Jc(rr), Bt--;
                for (; 0 < Jt - Bt; )
                  Gt = Jc(Gt), Jt--;
                for (; Bt--; ) {
                  if (rr === Gt || Gt !== null && rr === Gt.alternate)
                    break t;
                  rr = Jc(rr), Gt = Jc(Gt);
                }
                rr = null;
              }
            else
              rr = null;
            qn !== null && ib(In, kn, qn, rr, !1), er !== null && va !== null && ib(In, va, er, rr, !0);
          }
        }
        e: {
          if (kn = an ? cf(an) : window, qn = kn.nodeName && kn.nodeName.toLowerCase(), qn === "select" || qn === "input" && kn.type === "file")
            var Zn = ng;
          else if (eg(kn))
            if (Xy)
              Zn = ag;
            else {
              Zn = l_;
              var dr = u_;
            }
          else
            (qn = kn.nodeName) && qn.toLowerCase() === "input" && (kn.type === "checkbox" || kn.type === "radio") && (Zn = c_);
          if (Zn && (Zn = Zn(xe, an))) {
            tg(In, Zn, je, Pn);
            break e;
          }
          dr && dr(xe, kn, an), xe === "focusout" && (dr = kn._wrapperState) && dr.controlled && kn.type === "number" && Ho(kn, "number", kn.value);
        }
        switch (dr = an ? cf(an) : window, xe) {
          case "focusin":
            (eg(dr) || dr.contentEditable === "true") && (du = dr, tb = an, ep = null);
            break;
          case "focusout":
            ep = tb = du = null;
            break;
          case "mousedown":
            nb = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            nb = !1, cg(In, je, Pn);
            break;
          case "selectionchange":
            if (lg)
              break;
          case "keydown":
          case "keyup":
            cg(In, je, Pn);
        }
        var gr;
        if (cu)
          e: {
            switch (xe) {
              case "compositionstart":
                var Ir = "onCompositionStart";
                break e;
              case "compositionend":
                Ir = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ir = "onCompositionUpdate";
                break e;
            }
            Ir = void 0;
          }
        else
          tf ? Xv(xe, je) && (Ir = "onCompositionEnd") : xe === "keydown" && je.keyCode === 229 && (Ir = "onCompositionStart");
        Ir && (Qv && je.locale !== "ko" && (tf || Ir !== "onCompositionStart" ? Ir === "onCompositionEnd" && tf && (gr = mn()) : (it = Pn, Ct = "value" in it ? it.value : it.textContent, tf = !0)), dr = mp(an, Ir), 0 < dr.length && (Ir = new Wy(Ir, xe, null, je, Pn), In.push({ event: Ir, listeners: dr }), gr ? Ir.data = gr : (gr = sm(je), gr !== null && (Ir.data = gr)))), (gr = im ? i_(xe, je) : s_(xe, je)) && (an = mp(an, "onBeforeInput"), 0 < an.length && (Pn = new Wy("onBeforeInput", "beforeinput", null, je, Pn), In.push({ event: Pn, listeners: an }), Pn.data = gr));
      }
      fm(In, Oe);
    });
  }
  function hp(xe, Oe, je) {
    return { instance: xe, listener: Oe, currentTarget: je };
  }
  function mp(xe, Oe) {
    for (var je = Oe + "Capture", Fe = []; xe !== null; ) {
      var Ge = xe, Qe = Ge.stateNode;
      Ge.tag === 5 && Qe !== null && (Ge = Qe, Qe = ti(xe, je), Qe != null && Fe.unshift(hp(xe, Qe, Ge)), Qe = ti(xe, Oe), Qe != null && Fe.push(hp(xe, Qe, Ge))), xe = xe.return;
    }
    return Fe;
  }
  function Jc(xe) {
    if (xe === null)
      return null;
    do
      xe = xe.return;
    while (xe && xe.tag !== 5);
    return xe || null;
  }
  function ib(xe, Oe, je, Fe, Ge) {
    for (var Qe = Oe._reactName, dt = []; je !== null && je !== Fe; ) {
      var St = je, Rt = St.alternate, an = St.stateNode;
      if (Rt !== null && Rt === Fe)
        break;
      St.tag === 5 && an !== null && (St = an, Ge ? (Rt = ti(je, Qe), Rt != null && dt.unshift(hp(je, Rt, St))) : Ge || (Rt = ti(je, Qe), Rt != null && dt.push(hp(je, Rt, St)))), je = je.return;
    }
    dt.length !== 0 && xe.push({ event: Oe, listeners: dt });
  }
  var sb = /\r\n?/g, p_ = /\u0000|\uFFFD/g;
  function ub(xe) {
    return (typeof xe == "string" ? xe : "" + xe).replace(sb, `
`).replace(p_, "");
  }
  function hm(xe, Oe, je) {
    if (Oe = ub(Oe), ub(xe) !== Oe && je)
      throw Error(fe(425));
  }
  function mm() {
  }
  var lb = null, ed = null;
  function yp(xe, Oe) {
    return xe === "textarea" || xe === "noscript" || typeof Oe.children == "string" || typeof Oe.children == "number" || typeof Oe.dangerouslySetInnerHTML == "object" && Oe.dangerouslySetInnerHTML !== null && Oe.dangerouslySetInnerHTML.__html != null;
  }
  var td = typeof setTimeout == "function" ? setTimeout : void 0, gg = typeof clearTimeout == "function" ? clearTimeout : void 0, cb = typeof Promise == "function" ? Promise : void 0, db = typeof queueMicrotask == "function" ? queueMicrotask : typeof cb < "u" ? function(xe) {
    return cb.resolve(null).then(xe).catch(m_);
  } : td;
  function m_(xe) {
    setTimeout(function() {
      throw xe;
    });
  }
  function Zl(xe, Oe) {
    var je = Oe, Fe = 0;
    do {
      var Ge = je.nextSibling;
      if (xe.removeChild(je), Ge && Ge.nodeType === 8)
        if (je = Ge.data, je === "/$") {
          if (Fe === 0) {
            xe.removeChild(Ge), nl(Oe);
            return;
          }
          Fe--;
        } else
          je !== "$" && je !== "$?" && je !== "$!" || Fe++;
      je = Ge;
    } while (je);
    nl(Oe);
  }
  function fu(xe) {
    for (; xe != null; xe = xe.nextSibling) {
      var Oe = xe.nodeType;
      if (Oe === 1 || Oe === 3)
        break;
      if (Oe === 8) {
        if (Oe = xe.data, Oe === "$" || Oe === "$!" || Oe === "$?")
          break;
        if (Oe === "/$")
          return null;
      }
    }
    return xe;
  }
  function bp(xe) {
    xe = xe.previousSibling;
    for (var Oe = 0; xe; ) {
      if (xe.nodeType === 8) {
        var je = xe.data;
        if (je === "$" || je === "$!" || je === "$?") {
          if (Oe === 0)
            return xe;
          Oe--;
        } else
          je === "/$" && Oe++;
      }
      xe = xe.previousSibling;
    }
    return null;
  }
  var Yl = Math.random().toString(36).slice(2), zu = "__reactFiber$" + Yl, nd = "__reactProps$" + Yl, ll = "__reactContainer$" + Yl, fb = "__reactEvents$" + Yl, y_ = "__reactListeners$" + Yl, pb = "__reactHandles$" + Yl;
  function Zs(xe) {
    var Oe = xe[zu];
    if (Oe)
      return Oe;
    for (var je = xe.parentNode; je; ) {
      if (Oe = je[ll] || je[zu]) {
        if (je = Oe.alternate, Oe.child !== null || je !== null && je.child !== null)
          for (xe = bp(xe); xe !== null; ) {
            if (je = xe[zu])
              return je;
            xe = bp(xe);
          }
        return Oe;
      }
      xe = je, je = xe.parentNode;
    }
    return null;
  }
  function gp(xe) {
    return xe = xe[zu] || xe[ll], !xe || xe.tag !== 5 && xe.tag !== 6 && xe.tag !== 13 && xe.tag !== 3 ? null : xe;
  }
  function cf(xe) {
    if (xe.tag === 5 || xe.tag === 6)
      return xe.stateNode;
    throw Error(fe(33));
  }
  function hr(xe) {
    return xe[nd] || null;
  }
  var Ql = [], Lo = -1;
  function Br(xe) {
    return { current: xe };
  }
  function yo(xe) {
    0 > Lo || (xe.current = Ql[Lo], Ql[Lo] = null, Lo--);
  }
  function go(xe, Oe) {
    Lo++, Ql[Lo] = xe.current, xe.current = Oe;
  }
  var Uu = {}, Cr = Br(Uu), ua = Br(!1), ns = Uu;
  function qs(xe, Oe) {
    var je = xe.type.contextTypes;
    if (!je)
      return Uu;
    var Fe = xe.stateNode;
    if (Fe && Fe.__reactInternalMemoizedUnmaskedChildContext === Oe)
      return Fe.__reactInternalMemoizedMaskedChildContext;
    var Ge = {}, Qe;
    for (Qe in je)
      Ge[Qe] = Oe[Qe];
    return Fe && (xe = xe.stateNode, xe.__reactInternalMemoizedUnmaskedChildContext = Oe, xe.__reactInternalMemoizedMaskedChildContext = Ge), Ge;
  }
  function Go(xe) {
    return xe = xe.childContextTypes, xe != null;
  }
  function Ws() {
    yo(ua), yo(Cr);
  }
  function Xl(xe, Oe, je) {
    if (Cr.current !== Uu)
      throw Error(fe(168));
    go(Cr, Oe), go(ua, je);
  }
  function wp(xe, Oe, je) {
    var Fe = xe.stateNode;
    if (Oe = Oe.childContextTypes, typeof Fe.getChildContext != "function")
      return je;
    Fe = Fe.getChildContext();
    for (var Ge in Fe)
      if (!(Ge in Oe))
        throw Error(fe(108, br(xe) || "Unknown", Ge));
    return At({}, je, Fe);
  }
  function ym(xe) {
    return xe = (xe = xe.stateNode) && xe.__reactInternalMemoizedMergedChildContext || Uu, ns = Cr.current, go(Cr, xe), go(ua, ua.current), !0;
  }
  function wg(xe, Oe, je) {
    var Fe = xe.stateNode;
    if (!Fe)
      throw Error(fe(169));
    je ? (xe = wp(xe, Oe, ns), Fe.__reactInternalMemoizedMergedChildContext = xe, yo(ua), yo(Cr), go(Cr, xe)) : yo(ua), go(ua, je);
  }
  var Ts = null, za = !1, _p = !1;
  function hb(xe) {
    Ts === null ? Ts = [xe] : Ts.push(xe);
  }
  function mb(xe) {
    za = !0, hb(xe);
  }
  function rs() {
    if (!_p && Ts !== null) {
      _p = !0;
      var xe = 0, Oe = so;
      try {
        var je = Ts;
        for (so = 1; xe < je.length; xe++) {
          var Fe = je[xe];
          do
            Fe = Fe(!0);
          while (Fe !== null);
        }
        Ts = null, za = !1;
      } catch (Ge) {
        throw Ts !== null && (Ts = Ts.slice(xe + 1)), So(_s, rs), Ge;
      } finally {
        so = Oe, _p = !1;
      }
    }
    return null;
  }
  var Jl = [], os = 0, rd = null, df = 0, as = [], Ii = 0, Gs = null, ci = 1, cl = "";
  function Os(xe, Oe) {
    Jl[os++] = df, Jl[os++] = rd, rd = xe, df = Oe;
  }
  function yb(xe, Oe, je) {
    as[Ii++] = ci, as[Ii++] = cl, as[Ii++] = Gs, Gs = xe;
    var Fe = ci;
    xe = cl;
    var Ge = 32 - ri(Fe) - 1;
    Fe &= ~(1 << Ge), je += 1;
    var Qe = 32 - ri(Oe) + Ge;
    if (30 < Qe) {
      var dt = Ge - Ge % 5;
      Qe = (Fe & (1 << dt) - 1).toString(32), Fe >>= dt, Ge -= dt, ci = 1 << 32 - ri(Oe) + Ge | je << Ge | Fe, cl = Qe + xe;
    } else
      ci = 1 << Qe | je << Ge | Fe, cl = xe;
  }
  function bm(xe) {
    xe.return !== null && (Os(xe, 1), yb(xe, 1, 0));
  }
  function bb(xe) {
    for (; xe === rd; )
      rd = Jl[--os], Jl[os] = null, df = Jl[--os], Jl[os] = null;
    for (; xe === Gs; )
      Gs = as[--Ii], as[Ii] = null, cl = as[--Ii], as[Ii] = null, ci = as[--Ii], as[Ii] = null;
  }
  var As = null, is = null, Bo = !1, Ys = null;
  function vb(xe, Oe) {
    var je = tu(5, null, null, 0);
    je.elementType = "DELETED", je.stateNode = Oe, je.return = xe, Oe = xe.deletions, Oe === null ? (xe.deletions = [je], xe.flags |= 16) : Oe.push(je);
  }
  function _g(xe, Oe) {
    switch (xe.tag) {
      case 5:
        var je = xe.type;
        return Oe = Oe.nodeType !== 1 || je.toLowerCase() !== Oe.nodeName.toLowerCase() ? null : Oe, Oe !== null ? (xe.stateNode = Oe, As = xe, is = fu(Oe.firstChild), !0) : !1;
      case 6:
        return Oe = xe.pendingProps === "" || Oe.nodeType !== 3 ? null : Oe, Oe !== null ? (xe.stateNode = Oe, As = xe, is = null, !0) : !1;
      case 13:
        return Oe = Oe.nodeType !== 8 ? null : Oe, Oe !== null ? (je = Gs !== null ? { id: ci, overflow: cl } : null, xe.memoizedState = { dehydrated: Oe, treeContext: je, retryLane: 1073741824 }, je = tu(18, null, null, 0), je.stateNode = Oe, je.return = xe, xe.child = je, As = xe, is = null, !0) : !1;
      default:
        return !1;
    }
  }
  function vm(xe) {
    return (xe.mode & 1) !== 0 && (xe.flags & 128) === 0;
  }
  function gm(xe) {
    if (Bo) {
      var Oe = is;
      if (Oe) {
        var je = Oe;
        if (!_g(xe, Oe)) {
          if (vm(xe))
            throw Error(fe(418));
          Oe = fu(je.nextSibling);
          var Fe = As;
          Oe && _g(xe, Oe) ? vb(Fe, je) : (xe.flags = xe.flags & -4097 | 2, Bo = !1, As = xe);
        }
      } else {
        if (vm(xe))
          throw Error(fe(418));
        xe.flags = xe.flags & -4097 | 2, Bo = !1, As = xe;
      }
    }
  }
  function xg(xe) {
    for (xe = xe.return; xe !== null && xe.tag !== 5 && xe.tag !== 3 && xe.tag !== 13; )
      xe = xe.return;
    As = xe;
  }
  function wm(xe) {
    if (xe !== As)
      return !1;
    if (!Bo)
      return xg(xe), Bo = !0, !1;
    var Oe;
    if ((Oe = xe.tag !== 3) && !(Oe = xe.tag !== 5) && (Oe = xe.type, Oe = Oe !== "head" && Oe !== "body" && !yp(xe.type, xe.memoizedProps)), Oe && (Oe = is)) {
      if (vm(xe))
        throw Eg(), Error(fe(418));
      for (; Oe; )
        vb(xe, Oe), Oe = fu(Oe.nextSibling);
    }
    if (xg(xe), xe.tag === 13) {
      if (xe = xe.memoizedState, xe = xe !== null ? xe.dehydrated : null, !xe)
        throw Error(fe(317));
      e: {
        for (xe = xe.nextSibling, Oe = 0; xe; ) {
          if (xe.nodeType === 8) {
            var je = xe.data;
            if (je === "/$") {
              if (Oe === 0) {
                is = fu(xe.nextSibling);
                break e;
              }
              Oe--;
            } else
              je !== "$" && je !== "$!" && je !== "$?" || Oe++;
          }
          xe = xe.nextSibling;
        }
        is = null;
      }
    } else
      is = As ? fu(xe.stateNode.nextSibling) : null;
    return !0;
  }
  function Eg() {
    for (var xe = is; xe; )
      xe = fu(xe.nextSibling);
  }
  function ea() {
    is = As = null, Bo = !1;
  }
  function gb(xe) {
    Ys === null ? Ys = [xe] : Ys.push(xe);
  }
  var _m = pt.ReactCurrentBatchConfig;
  function Cs(xe, Oe) {
    if (xe && xe.defaultProps) {
      Oe = At({}, Oe), xe = xe.defaultProps;
      for (var je in xe)
        Oe[je] === void 0 && (Oe[je] = xe[je]);
      return Oe;
    }
    return Oe;
  }
  var Vu = Br(null), xm = null, ec = null, wb = null;
  function _b() {
    wb = ec = xm = null;
  }
  function tc(xe) {
    var Oe = Vu.current;
    yo(Vu), xe._currentValue = Oe;
  }
  function Ua(xe, Oe, je) {
    for (; xe !== null; ) {
      var Fe = xe.alternate;
      if ((xe.childLanes & Oe) !== Oe ? (xe.childLanes |= Oe, Fe !== null && (Fe.childLanes |= Oe)) : Fe !== null && (Fe.childLanes & Oe) !== Oe && (Fe.childLanes |= Oe), xe === je)
        break;
      xe = xe.return;
    }
  }
  function Ln(xe, Oe) {
    xm = xe, wb = ec = null, xe = xe.dependencies, xe !== null && xe.firstContext !== null && (xe.lanes & Oe && (ka = !0), xe.firstContext = null);
  }
  function fa(xe) {
    var Oe = xe._currentValue;
    if (wb !== xe)
      if (xe = { context: xe, memoizedValue: Oe, next: null }, ec === null) {
        if (xm === null)
          throw Error(fe(308));
        ec = xe, xm.dependencies = { lanes: 0, firstContext: xe };
      } else
        ec = ec.next = xe;
    return Oe;
  }
  var di = null;
  function xb(xe) {
    di === null ? di = [xe] : di.push(xe);
  }
  function Sg(xe, Oe, je, Fe) {
    var Ge = Oe.interleaved;
    return Ge === null ? (je.next = je, xb(Oe)) : (je.next = Ge.next, Ge.next = je), Oe.interleaved = je, dl(xe, Fe);
  }
  function dl(xe, Oe) {
    xe.lanes |= Oe;
    var je = xe.alternate;
    for (je !== null && (je.lanes |= Oe), je = xe, xe = xe.return; xe !== null; )
      xe.childLanes |= Oe, je = xe.alternate, je !== null && (je.childLanes |= Oe), je = xe, xe = xe.return;
    return je.tag === 3 ? je.stateNode : null;
  }
  var nc = !1;
  function Eb(xe) {
    xe.updateQueue = { baseState: xe.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Ia(xe, Oe) {
    xe = xe.updateQueue, Oe.updateQueue === xe && (Oe.updateQueue = { baseState: xe.baseState, firstBaseUpdate: xe.firstBaseUpdate, lastBaseUpdate: xe.lastBaseUpdate, shared: xe.shared, effects: xe.effects });
  }
  function fl(xe, Oe) {
    return { eventTime: xe, lane: Oe, tag: 0, payload: null, callback: null, next: null };
  }
  function rc(xe, Oe, je) {
    var Fe = xe.updateQueue;
    if (Fe === null)
      return null;
    if (Fe = Fe.shared, Hr & 2) {
      var Ge = Fe.pending;
      return Ge === null ? Oe.next = Oe : (Oe.next = Ge.next, Ge.next = Oe), Fe.pending = Oe, dl(xe, je);
    }
    return Ge = Fe.interleaved, Ge === null ? (Oe.next = Oe, xb(Fe)) : (Oe.next = Ge.next, Ge.next = Oe), Fe.interleaved = Oe, dl(xe, je);
  }
  function Em(xe, Oe, je) {
    if (Oe = Oe.updateQueue, Oe !== null && (Oe = Oe.shared, (je & 4194240) !== 0)) {
      var Fe = Oe.lanes;
      Fe &= xe.pendingLanes, je |= Fe, Oe.lanes = je, _u(xe, je);
    }
  }
  function Sb(xe, Oe) {
    var je = xe.updateQueue, Fe = xe.alternate;
    if (Fe !== null && (Fe = Fe.updateQueue, je === Fe)) {
      var Ge = null, Qe = null;
      if (je = je.firstBaseUpdate, je !== null) {
        do {
          var dt = { eventTime: je.eventTime, lane: je.lane, tag: je.tag, payload: je.payload, callback: je.callback, next: null };
          Qe === null ? Ge = Qe = dt : Qe = Qe.next = dt, je = je.next;
        } while (je !== null);
        Qe === null ? Ge = Qe = Oe : Qe = Qe.next = Oe;
      } else
        Ge = Qe = Oe;
      je = { baseState: Fe.baseState, firstBaseUpdate: Ge, lastBaseUpdate: Qe, shared: Fe.shared, effects: Fe.effects }, xe.updateQueue = je;
      return;
    }
    xe = je.lastBaseUpdate, xe === null ? je.firstBaseUpdate = Oe : xe.next = Oe, je.lastBaseUpdate = Oe;
  }
  function ac(xe, Oe, je, Fe) {
    var Ge = xe.updateQueue;
    nc = !1;
    var Qe = Ge.firstBaseUpdate, dt = Ge.lastBaseUpdate, St = Ge.shared.pending;
    if (St !== null) {
      Ge.shared.pending = null;
      var Rt = St, an = Rt.next;
      Rt.next = null, dt === null ? Qe = an : dt.next = an, dt = Rt;
      var Pn = xe.alternate;
      Pn !== null && (Pn = Pn.updateQueue, St = Pn.lastBaseUpdate, St !== dt && (St === null ? Pn.firstBaseUpdate = an : St.next = an, Pn.lastBaseUpdate = Rt));
    }
    if (Qe !== null) {
      var In = Ge.baseState;
      dt = 0, Pn = an = Rt = null, St = Qe;
      do {
        var kn = St.lane, qn = St.eventTime;
        if ((Fe & kn) === kn) {
          Pn !== null && (Pn = Pn.next = { eventTime: qn, lane: 0, tag: St.tag, payload: St.payload, callback: St.callback, next: null });
          e: {
            var er = xe, rr = St;
            switch (kn = Oe, qn = je, rr.tag) {
              case 1:
                if (er = rr.payload, typeof er == "function") {
                  In = er.call(qn, In, kn);
                  break e;
                }
                In = er;
                break e;
              case 3:
                er.flags = er.flags & -65537 | 128;
              case 0:
                if (er = rr.payload, kn = typeof er == "function" ? er.call(qn, In, kn) : er, kn == null)
                  break e;
                In = At({}, In, kn);
                break e;
              case 2:
                nc = !0;
            }
          }
          St.callback !== null && St.lane !== 0 && (xe.flags |= 64, kn = Ge.effects, kn === null ? Ge.effects = [St] : kn.push(St));
        } else
          qn = { eventTime: qn, lane: kn, tag: St.tag, payload: St.payload, callback: St.callback, next: null }, Pn === null ? (an = Pn = qn, Rt = In) : Pn = Pn.next = qn, dt |= kn;
        if (St = St.next, St === null) {
          if (St = Ge.shared.pending, St === null)
            break;
          kn = St, St = kn.next, kn.next = null, Ge.lastBaseUpdate = kn, Ge.shared.pending = null;
        }
      } while (1);
      if (Pn === null && (Rt = In), Ge.baseState = Rt, Ge.firstBaseUpdate = an, Ge.lastBaseUpdate = Pn, Oe = Ge.shared.interleaved, Oe !== null) {
        Ge = Oe;
        do
          dt |= Ge.lane, Ge = Ge.next;
        while (Ge !== Oe);
      } else
        Qe === null && (Ge.shared.lanes = 0);
      Ad |= dt, xe.lanes = dt, xe.memoizedState = In;
    }
  }
  function od(xe, Oe, je) {
    if (xe = Oe.effects, Oe.effects = null, xe !== null)
      for (Oe = 0; Oe < xe.length; Oe++) {
        var Fe = xe[Oe], Ge = Fe.callback;
        if (Ge !== null) {
          if (Fe.callback = null, Fe = je, typeof Ge != "function")
            throw Error(fe(191, Ge));
          Ge.call(Fe);
        }
      }
  }
  var Pg = new oe.Component().refs;
  function Pb(xe, Oe, je, Fe) {
    Oe = xe.memoizedState, je = je(Fe, Oe), je = je == null ? Oe : At({}, Oe, je), xe.memoizedState = je, xe.lanes === 0 && (xe.updateQueue.baseState = je);
  }
  var Sm = { isMounted: function(xe) {
    return (xe = xe._reactInternals) ? Rr(xe) === xe : !1;
  }, enqueueSetState: function(xe, Oe, je) {
    xe = xe._reactInternals;
    var Fe = Io(), Ge = Ns(xe), Qe = fl(Fe, Ge);
    Qe.payload = Oe, je != null && (Qe.callback = je), Oe = rc(xe, Qe, Ge), Oe !== null && (Ms(Oe, xe, Ge, Fe), Em(Oe, xe, Ge));
  }, enqueueReplaceState: function(xe, Oe, je) {
    xe = xe._reactInternals;
    var Fe = Io(), Ge = Ns(xe), Qe = fl(Fe, Ge);
    Qe.tag = 1, Qe.payload = Oe, je != null && (Qe.callback = je), Oe = rc(xe, Qe, Ge), Oe !== null && (Ms(Oe, xe, Ge, Fe), Em(Oe, xe, Ge));
  }, enqueueForceUpdate: function(xe, Oe) {
    xe = xe._reactInternals;
    var je = Io(), Fe = Ns(xe), Ge = fl(je, Fe);
    Ge.tag = 2, Oe != null && (Ge.callback = Oe), Oe = rc(xe, Ge, Fe), Oe !== null && (Ms(Oe, xe, Fe, je), Em(Oe, xe, Fe));
  } };
  function kg(xe, Oe, je, Fe, Ge, Qe, dt) {
    return xe = xe.stateNode, typeof xe.shouldComponentUpdate == "function" ? xe.shouldComponentUpdate(Fe, Qe, dt) : Oe.prototype && Oe.prototype.isPureReactComponent ? !Jf(je, Fe) || !Jf(Ge, Qe) : !0;
  }
  function Tg(xe, Oe, je) {
    var Fe = !1, Ge = Uu, Qe = Oe.contextType;
    return typeof Qe == "object" && Qe !== null ? Qe = fa(Qe) : (Ge = Go(Oe) ? ns : Cr.current, Fe = Oe.contextTypes, Qe = (Fe = Fe != null) ? qs(xe, Ge) : Uu), Oe = new Oe(je, Qe), xe.memoizedState = Oe.state !== null && Oe.state !== void 0 ? Oe.state : null, Oe.updater = Sm, xe.stateNode = Oe, Oe._reactInternals = xe, Fe && (xe = xe.stateNode, xe.__reactInternalMemoizedUnmaskedChildContext = Ge, xe.__reactInternalMemoizedMaskedChildContext = Qe), Oe;
  }
  function Og(xe, Oe, je, Fe) {
    xe = Oe.state, typeof Oe.componentWillReceiveProps == "function" && Oe.componentWillReceiveProps(je, Fe), typeof Oe.UNSAFE_componentWillReceiveProps == "function" && Oe.UNSAFE_componentWillReceiveProps(je, Fe), Oe.state !== xe && Sm.enqueueReplaceState(Oe, Oe.state, null);
  }
  function Pm(xe, Oe, je, Fe) {
    var Ge = xe.stateNode;
    Ge.props = je, Ge.state = xe.memoizedState, Ge.refs = Pg, Eb(xe);
    var Qe = Oe.contextType;
    typeof Qe == "object" && Qe !== null ? Ge.context = fa(Qe) : (Qe = Go(Oe) ? ns : Cr.current, Ge.context = qs(xe, Qe)), Ge.state = xe.memoizedState, Qe = Oe.getDerivedStateFromProps, typeof Qe == "function" && (Pb(xe, Oe, Qe, je), Ge.state = xe.memoizedState), typeof Oe.getDerivedStateFromProps == "function" || typeof Ge.getSnapshotBeforeUpdate == "function" || typeof Ge.UNSAFE_componentWillMount != "function" && typeof Ge.componentWillMount != "function" || (Oe = Ge.state, typeof Ge.componentWillMount == "function" && Ge.componentWillMount(), typeof Ge.UNSAFE_componentWillMount == "function" && Ge.UNSAFE_componentWillMount(), Oe !== Ge.state && Sm.enqueueReplaceState(Ge, Ge.state, null), ac(xe, je, Ge, Fe), Ge.state = xe.memoizedState), typeof Ge.componentDidMount == "function" && (xe.flags |= 4194308);
  }
  function ff(xe, Oe, je) {
    if (xe = je.ref, xe !== null && typeof xe != "function" && typeof xe != "object") {
      if (je._owner) {
        if (je = je._owner, je) {
          if (je.tag !== 1)
            throw Error(fe(309));
          var Fe = je.stateNode;
        }
        if (!Fe)
          throw Error(fe(147, xe));
        var Ge = Fe, Qe = "" + xe;
        return Oe !== null && Oe.ref !== null && typeof Oe.ref == "function" && Oe.ref._stringRef === Qe ? Oe.ref : (Oe = function(dt) {
          var St = Ge.refs;
          St === Pg && (St = Ge.refs = {}), dt === null ? delete St[Qe] : St[Qe] = dt;
        }, Oe._stringRef = Qe, Oe);
      }
      if (typeof xe != "string")
        throw Error(fe(284));
      if (!je._owner)
        throw Error(fe(290, xe));
    }
    return xe;
  }
  function km(xe, Oe) {
    throw xe = Object.prototype.toString.call(Oe), Error(fe(31, xe === "[object Object]" ? "object with keys {" + Object.keys(Oe).join(", ") + "}" : xe));
  }
  function Ag(xe) {
    var Oe = xe._init;
    return Oe(xe._payload);
  }
  function Cg(xe) {
    function Oe(Gt, Bt) {
      if (xe) {
        var Jt = Gt.deletions;
        Jt === null ? (Gt.deletions = [Bt], Gt.flags |= 16) : Jt.push(Bt);
      }
    }
    function je(Gt, Bt) {
      if (!xe)
        return null;
      for (; Bt !== null; )
        Oe(Gt, Bt), Bt = Bt.sibling;
      return null;
    }
    function Fe(Gt, Bt) {
      for (Gt = /* @__PURE__ */ new Map(); Bt !== null; )
        Bt.key !== null ? Gt.set(Bt.key, Bt) : Gt.set(Bt.index, Bt), Bt = Bt.sibling;
      return Gt;
    }
    function Ge(Gt, Bt) {
      return Gt = vc(Gt, Bt), Gt.index = 0, Gt.sibling = null, Gt;
    }
    function Qe(Gt, Bt, Jt) {
      return Gt.index = Jt, xe ? (Jt = Gt.alternate, Jt !== null ? (Jt = Jt.index, Jt < Bt ? (Gt.flags |= 2, Bt) : Jt) : (Gt.flags |= 2, Bt)) : (Gt.flags |= 1048576, Bt);
    }
    function dt(Gt) {
      return xe && Gt.alternate === null && (Gt.flags |= 2), Gt;
    }
    function St(Gt, Bt, Jt, Nn) {
      return Bt === null || Bt.tag !== 6 ? (Bt = Md(Jt, Gt.mode, Nn), Bt.return = Gt, Bt) : (Bt = Ge(Bt, Jt), Bt.return = Gt, Bt);
    }
    function Rt(Gt, Bt, Jt, Nn) {
      var Zn = Jt.type;
      return Zn === gt ? Pn(Gt, Bt, Jt.props.children, Nn, Jt.key) : Bt !== null && (Bt.elementType === Zn || typeof Zn == "object" && Zn !== null && Zn.$$typeof === un && Ag(Zn) === Bt.type) ? (Nn = Ge(Bt, Jt.props), Nn.ref = ff(Gt, Bt, Jt), Nn.return = Gt, Nn) : (Nn = ly(Jt.type, Jt.key, Jt.props, null, Gt.mode, Nn), Nn.ref = ff(Gt, Bt, Jt), Nn.return = Gt, Nn);
    }
    function an(Gt, Bt, Jt, Nn) {
      return Bt === null || Bt.tag !== 4 || Bt.stateNode.containerInfo !== Jt.containerInfo || Bt.stateNode.implementation !== Jt.implementation ? (Bt = qb(Jt, Gt.mode, Nn), Bt.return = Gt, Bt) : (Bt = Ge(Bt, Jt.children || []), Bt.return = Gt, Bt);
    }
    function Pn(Gt, Bt, Jt, Nn, Zn) {
      return Bt === null || Bt.tag !== 7 ? (Bt = gc(Jt, Gt.mode, Nn, Zn), Bt.return = Gt, Bt) : (Bt = Ge(Bt, Jt), Bt.return = Gt, Bt);
    }
    function In(Gt, Bt, Jt) {
      if (typeof Bt == "string" && Bt !== "" || typeof Bt == "number")
        return Bt = Md("" + Bt, Gt.mode, Jt), Bt.return = Gt, Bt;
      if (typeof Bt == "object" && Bt !== null) {
        switch (Bt.$$typeof) {
          case ht:
            return Jt = ly(Bt.type, Bt.key, Bt.props, null, Gt.mode, Jt), Jt.ref = ff(Gt, null, Bt), Jt.return = Gt, Jt;
          case wt:
            return Bt = qb(Bt, Gt.mode, Jt), Bt.return = Gt, Bt;
          case un:
            var Nn = Bt._init;
            return In(Gt, Nn(Bt._payload), Jt);
        }
        if (ca(Bt) || Rn(Bt))
          return Bt = gc(Bt, Gt.mode, Jt, null), Bt.return = Gt, Bt;
        km(Gt, Bt);
      }
      return null;
    }
    function kn(Gt, Bt, Jt, Nn) {
      var Zn = Bt !== null ? Bt.key : null;
      if (typeof Jt == "string" && Jt !== "" || typeof Jt == "number")
        return Zn !== null ? null : St(Gt, Bt, "" + Jt, Nn);
      if (typeof Jt == "object" && Jt !== null) {
        switch (Jt.$$typeof) {
          case ht:
            return Jt.key === Zn ? Rt(Gt, Bt, Jt, Nn) : null;
          case wt:
            return Jt.key === Zn ? an(Gt, Bt, Jt, Nn) : null;
          case un:
            return Zn = Jt._init, kn(Gt, Bt, Zn(Jt._payload), Nn);
        }
        if (ca(Jt) || Rn(Jt))
          return Zn !== null ? null : Pn(Gt, Bt, Jt, Nn, null);
        km(Gt, Jt);
      }
      return null;
    }
    function qn(Gt, Bt, Jt, Nn, Zn) {
      if (typeof Nn == "string" && Nn !== "" || typeof Nn == "number")
        return Gt = Gt.get(Jt) || null, St(Bt, Gt, "" + Nn, Zn);
      if (typeof Nn == "object" && Nn !== null) {
        switch (Nn.$$typeof) {
          case ht:
            return Gt = Gt.get(Nn.key === null ? Jt : Nn.key) || null, Rt(Bt, Gt, Nn, Zn);
          case wt:
            return Gt = Gt.get(Nn.key === null ? Jt : Nn.key) || null, an(Bt, Gt, Nn, Zn);
          case un:
            var dr = Nn._init;
            return qn(Gt, Bt, Jt, dr(Nn._payload), Zn);
        }
        if (ca(Nn) || Rn(Nn))
          return Gt = Gt.get(Jt) || null, Pn(Bt, Gt, Nn, Zn, null);
        km(Bt, Nn);
      }
      return null;
    }
    function er(Gt, Bt, Jt, Nn) {
      for (var Zn = null, dr = null, gr = Bt, Ir = Bt = 0, Ma = null; gr !== null && Ir < Jt.length; Ir++) {
        gr.index > Ir ? (Ma = gr, gr = null) : Ma = gr.sibling;
        var fo = kn(Gt, gr, Jt[Ir], Nn);
        if (fo === null) {
          gr === null && (gr = Ma);
          break;
        }
        xe && gr && fo.alternate === null && Oe(Gt, gr), Bt = Qe(fo, Bt, Ir), dr === null ? Zn = fo : dr.sibling = fo, dr = fo, gr = Ma;
      }
      if (Ir === Jt.length)
        return je(Gt, gr), Bo && Os(Gt, Ir), Zn;
      if (gr === null) {
        for (; Ir < Jt.length; Ir++)
          gr = In(Gt, Jt[Ir], Nn), gr !== null && (Bt = Qe(gr, Bt, Ir), dr === null ? Zn = gr : dr.sibling = gr, dr = gr);
        return Bo && Os(Gt, Ir), Zn;
      }
      for (gr = Fe(Gt, gr); Ir < Jt.length; Ir++)
        Ma = qn(gr, Gt, Ir, Jt[Ir], Nn), Ma !== null && (xe && Ma.alternate !== null && gr.delete(Ma.key === null ? Ir : Ma.key), Bt = Qe(Ma, Bt, Ir), dr === null ? Zn = Ma : dr.sibling = Ma, dr = Ma);
      return xe && gr.forEach(function(Pc) {
        return Oe(Gt, Pc);
      }), Bo && Os(Gt, Ir), Zn;
    }
    function rr(Gt, Bt, Jt, Nn) {
      var Zn = Rn(Jt);
      if (typeof Zn != "function")
        throw Error(fe(150));
      if (Jt = Zn.call(Jt), Jt == null)
        throw Error(fe(151));
      for (var dr = Zn = null, gr = Bt, Ir = Bt = 0, Ma = null, fo = Jt.next(); gr !== null && !fo.done; Ir++, fo = Jt.next()) {
        gr.index > Ir ? (Ma = gr, gr = null) : Ma = gr.sibling;
        var Pc = kn(Gt, gr, fo.value, Nn);
        if (Pc === null) {
          gr === null && (gr = Ma);
          break;
        }
        xe && gr && Pc.alternate === null && Oe(Gt, gr), Bt = Qe(Pc, Bt, Ir), dr === null ? Zn = Pc : dr.sibling = Pc, dr = Pc, gr = Ma;
      }
      if (fo.done)
        return je(Gt, gr), Bo && Os(Gt, Ir), Zn;
      if (gr === null) {
        for (; !fo.done; Ir++, fo = Jt.next())
          fo = In(Gt, fo.value, Nn), fo !== null && (Bt = Qe(fo, Bt, Ir), dr === null ? Zn = fo : dr.sibling = fo, dr = fo);
        return Bo && Os(Gt, Ir), Zn;
      }
      for (gr = Fe(Gt, gr); !fo.done; Ir++, fo = Jt.next())
        fo = qn(gr, Gt, Ir, fo.value, Nn), fo !== null && (xe && fo.alternate !== null && gr.delete(fo.key === null ? Ir : fo.key), Bt = Qe(fo, Bt, Ir), dr === null ? Zn = fo : dr.sibling = fo, dr = fo);
      return xe && gr.forEach(function(R_) {
        return Oe(Gt, R_);
      }), Bo && Os(Gt, Ir), Zn;
    }
    function va(Gt, Bt, Jt, Nn) {
      if (typeof Jt == "object" && Jt !== null && Jt.type === gt && Jt.key === null && (Jt = Jt.props.children), typeof Jt == "object" && Jt !== null) {
        switch (Jt.$$typeof) {
          case ht:
            e: {
              for (var Zn = Jt.key, dr = Bt; dr !== null; ) {
                if (dr.key === Zn) {
                  if (Zn = Jt.type, Zn === gt) {
                    if (dr.tag === 7) {
                      je(Gt, dr.sibling), Bt = Ge(dr, Jt.props.children), Bt.return = Gt, Gt = Bt;
                      break e;
                    }
                  } else if (dr.elementType === Zn || typeof Zn == "object" && Zn !== null && Zn.$$typeof === un && Ag(Zn) === dr.type) {
                    je(Gt, dr.sibling), Bt = Ge(dr, Jt.props), Bt.ref = ff(Gt, dr, Jt), Bt.return = Gt, Gt = Bt;
                    break e;
                  }
                  je(Gt, dr);
                  break;
                } else
                  Oe(Gt, dr);
                dr = dr.sibling;
              }
              Jt.type === gt ? (Bt = gc(Jt.props.children, Gt.mode, Nn, Jt.key), Bt.return = Gt, Gt = Bt) : (Nn = ly(Jt.type, Jt.key, Jt.props, null, Gt.mode, Nn), Nn.ref = ff(Gt, Bt, Jt), Nn.return = Gt, Gt = Nn);
            }
            return dt(Gt);
          case wt:
            e: {
              for (dr = Jt.key; Bt !== null; ) {
                if (Bt.key === dr)
                  if (Bt.tag === 4 && Bt.stateNode.containerInfo === Jt.containerInfo && Bt.stateNode.implementation === Jt.implementation) {
                    je(Gt, Bt.sibling), Bt = Ge(Bt, Jt.children || []), Bt.return = Gt, Gt = Bt;
                    break e;
                  } else {
                    je(Gt, Bt);
                    break;
                  }
                else
                  Oe(Gt, Bt);
                Bt = Bt.sibling;
              }
              Bt = qb(Jt, Gt.mode, Nn), Bt.return = Gt, Gt = Bt;
            }
            return dt(Gt);
          case un:
            return dr = Jt._init, va(Gt, Bt, dr(Jt._payload), Nn);
        }
        if (ca(Jt))
          return er(Gt, Bt, Jt, Nn);
        if (Rn(Jt))
          return rr(Gt, Bt, Jt, Nn);
        km(Gt, Jt);
      }
      return typeof Jt == "string" && Jt !== "" || typeof Jt == "number" ? (Jt = "" + Jt, Bt !== null && Bt.tag === 6 ? (je(Gt, Bt.sibling), Bt = Ge(Bt, Jt), Bt.return = Gt, Gt = Bt) : (je(Gt, Bt), Bt = Md(Jt, Gt.mode, Nn), Bt.return = Gt, Gt = Bt), dt(Gt)) : je(Gt, Bt);
    }
    return va;
  }
  var pf = Cg(!0), Ig = Cg(!1), xp = {}, pu = Br(xp), Ep = Br(xp), hf = Br(xp);
  function ad(xe) {
    if (xe === xp)
      throw Error(fe(174));
    return xe;
  }
  function kb(xe, Oe) {
    switch (go(hf, Oe), go(Ep, xe), go(pu, xp), xe = Oe.nodeType, xe) {
      case 9:
      case 11:
        Oe = (Oe = Oe.documentElement) ? Oe.namespaceURI : jo(null, "");
        break;
      default:
        xe = xe === 8 ? Oe.parentNode : Oe, Oe = xe.namespaceURI || null, xe = xe.tagName, Oe = jo(Oe, xe);
    }
    yo(pu), go(pu, Oe);
  }
  function ic() {
    yo(pu), yo(Ep), yo(hf);
  }
  function vr(xe) {
    ad(hf.current);
    var Oe = ad(pu.current), je = jo(Oe, xe.type);
    Oe !== je && (go(Ep, xe), go(pu, je));
  }
  function Vr(xe) {
    Ep.current === xe && (yo(pu), yo(Ep));
  }
  var xr = Br(0);
  function ta(xe) {
    for (var Oe = xe; Oe !== null; ) {
      if (Oe.tag === 13) {
        var je = Oe.memoizedState;
        if (je !== null && (je = je.dehydrated, je === null || je.data === "$?" || je.data === "$!"))
          return Oe;
      } else if (Oe.tag === 19 && Oe.memoizedProps.revealOrder !== void 0) {
        if (Oe.flags & 128)
          return Oe;
      } else if (Oe.child !== null) {
        Oe.child.return = Oe, Oe = Oe.child;
        continue;
      }
      if (Oe === xe)
        break;
      for (; Oe.sibling === null; ) {
        if (Oe.return === null || Oe.return === xe)
          return null;
        Oe = Oe.return;
      }
      Oe.sibling.return = Oe.return, Oe = Oe.sibling;
    }
    return null;
  }
  var Qs = [];
  function Tm() {
    for (var xe = 0; xe < Qs.length; xe++)
      Qs[xe]._workInProgressVersionPrimary = null;
    Qs.length = 0;
  }
  var Om = pt.ReactCurrentDispatcher, Tb = pt.ReactCurrentBatchConfig, id = 0, Fo = null, vn = null, oo = null, kr = !1, Hu = !1, Is = 0, ud = 0;
  function Uo() {
    throw Error(fe(321));
  }
  function ld(xe, Oe) {
    if (Oe === null)
      return !1;
    for (var je = 0; je < Oe.length && je < xe.length; je++)
      if (!Hs(xe[je], Oe[je]))
        return !1;
    return !0;
  }
  function dc(xe, Oe, je, Fe, Ge, Qe) {
    if (id = Qe, Fo = Oe, Oe.memoizedState = null, Oe.updateQueue = null, Oe.lanes = 0, Om.current = xe === null || xe.memoizedState === null ? v_ : g_, xe = je(Fe, Ge), Hu) {
      Qe = 0;
      do {
        if (Hu = !1, Is = 0, 25 <= Qe)
          throw Error(fe(301));
        Qe += 1, oo = vn = null, Oe.updateQueue = null, Om.current = Ab, xe = je(Fe, Ge);
      } while (Hu);
    }
    if (Om.current = Hm, Oe = vn !== null && vn.next !== null, id = 0, oo = vn = Fo = null, kr = !1, Oe)
      throw Error(fe(300));
    return xe;
  }
  function bd() {
    var xe = Is !== 0;
    return Is = 0, xe;
  }
  function Ks() {
    var xe = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return oo === null ? Fo.memoizedState = oo = xe : oo = oo.next = xe, oo;
  }
  function ss() {
    if (vn === null) {
      var xe = Fo.alternate;
      xe = xe !== null ? xe.memoizedState : null;
    } else
      xe = vn.next;
    var Oe = oo === null ? Fo.memoizedState : oo.next;
    if (Oe !== null)
      oo = Oe, vn = xe;
    else {
      if (xe === null)
        throw Error(fe(310));
      vn = xe, xe = { memoizedState: vn.memoizedState, baseState: vn.baseState, baseQueue: vn.baseQueue, queue: vn.queue, next: null }, oo === null ? Fo.memoizedState = oo = xe : oo = oo.next = xe;
    }
    return oo;
  }
  function wd(xe, Oe) {
    return typeof Oe == "function" ? Oe(xe) : Oe;
  }
  function Sp(xe) {
    var Oe = ss(), je = Oe.queue;
    if (je === null)
      throw Error(fe(311));
    je.lastRenderedReducer = xe;
    var Fe = vn, Ge = Fe.baseQueue, Qe = je.pending;
    if (Qe !== null) {
      if (Ge !== null) {
        var dt = Ge.next;
        Ge.next = Qe.next, Qe.next = dt;
      }
      Fe.baseQueue = Ge = Qe, je.pending = null;
    }
    if (Ge !== null) {
      Qe = Ge.next, Fe = Fe.baseState;
      var St = dt = null, Rt = null, an = Qe;
      do {
        var Pn = an.lane;
        if ((id & Pn) === Pn)
          Rt !== null && (Rt = Rt.next = { lane: 0, action: an.action, hasEagerState: an.hasEagerState, eagerState: an.eagerState, next: null }), Fe = an.hasEagerState ? an.eagerState : xe(Fe, an.action);
        else {
          var In = { lane: Pn, action: an.action, hasEagerState: an.hasEagerState, eagerState: an.eagerState, next: null };
          Rt === null ? (St = Rt = In, dt = Fe) : Rt = Rt.next = In, Fo.lanes |= Pn, Ad |= Pn;
        }
        an = an.next;
      } while (an !== null && an !== Qe);
      Rt === null ? dt = Fe : Rt.next = St, Hs(Fe, Oe.memoizedState) || (ka = !0), Oe.memoizedState = Fe, Oe.baseState = dt, Oe.baseQueue = Rt, je.lastRenderedState = Fe;
    }
    if (xe = je.interleaved, xe !== null) {
      Ge = xe;
      do
        Qe = Ge.lane, Fo.lanes |= Qe, Ad |= Qe, Ge = Ge.next;
      while (Ge !== xe);
    } else
      Ge === null && (je.lanes = 0);
    return [Oe.memoizedState, je.dispatch];
  }
  function Pp(xe) {
    var Oe = ss(), je = Oe.queue;
    if (je === null)
      throw Error(fe(311));
    je.lastRenderedReducer = xe;
    var Fe = je.dispatch, Ge = je.pending, Qe = Oe.memoizedState;
    if (Ge !== null) {
      je.pending = null;
      var dt = Ge = Ge.next;
      do
        Qe = xe(Qe, dt.action), dt = dt.next;
      while (dt !== Ge);
      Hs(Qe, Oe.memoizedState) || (ka = !0), Oe.memoizedState = Qe, Oe.baseQueue === null && (Oe.baseState = Qe), je.lastRenderedState = Qe;
    }
    return [Qe, Fe];
  }
  function Am() {
  }
  function Cm(xe, Oe) {
    var je = Fo, Fe = ss(), Ge = Oe(), Qe = !Hs(Fe.memoizedState, Ge);
    if (Qe && (Fe.memoizedState = Ge, ka = !0), Fe = Fe.queue, kp(Rm.bind(null, je, Fe, xe), [xe]), Fe.getSnapshot !== Oe || Qe || oo !== null && oo.memoizedState.tag & 1) {
      if (je.flags |= 2048, _d(9, $m.bind(null, je, Fe, Ge, Oe), void 0, null), Ta === null)
        throw Error(fe(349));
      id & 30 || Im(je, Oe, Ge);
    }
    return Ge;
  }
  function Im(xe, Oe, je) {
    xe.flags |= 16384, xe = { getSnapshot: Oe, value: je }, Oe = Fo.updateQueue, Oe === null ? (Oe = { lastEffect: null, stores: null }, Fo.updateQueue = Oe, Oe.stores = [xe]) : (je = Oe.stores, je === null ? Oe.stores = [xe] : je.push(xe));
  }
  function $m(xe, Oe, je, Fe) {
    Oe.value = je, Oe.getSnapshot = Fe, Nm(Oe) && Mm(xe);
  }
  function Rm(xe, Oe, je) {
    return je(function() {
      Nm(Oe) && Mm(xe);
    });
  }
  function Nm(xe) {
    var Oe = xe.getSnapshot;
    xe = xe.value;
    try {
      var je = Oe();
      return !Hs(xe, je);
    } catch {
      return !0;
    }
  }
  function Mm(xe) {
    var Oe = dl(xe, 1);
    Oe !== null && Ms(Oe, xe, 1, -1);
  }
  function jm(xe) {
    var Oe = Ks();
    return typeof xe == "function" && (xe = xe()), Oe.memoizedState = Oe.baseState = xe, xe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: wd, lastRenderedState: xe }, Oe.queue = xe, xe = xe.dispatch = Vm.bind(null, Fo, xe), [Oe.memoizedState, xe];
  }
  function _d(xe, Oe, je, Fe) {
    return xe = { tag: xe, create: Oe, destroy: je, deps: Fe, next: null }, Oe = Fo.updateQueue, Oe === null ? (Oe = { lastEffect: null, stores: null }, Fo.updateQueue = Oe, Oe.lastEffect = xe.next = xe) : (je = Oe.lastEffect, je === null ? Oe.lastEffect = xe.next = xe : (Fe = je.next, je.next = xe, xe.next = Fe, Oe.lastEffect = xe)), xe;
  }
  function Lm() {
    return ss().memoizedState;
  }
  function xd(xe, Oe, je, Fe) {
    var Ge = Ks();
    Fo.flags |= xe, Ge.memoizedState = _d(1 | Oe, je, void 0, Fe === void 0 ? null : Fe);
  }
  function pl(xe, Oe, je, Fe) {
    var Ge = ss();
    Fe = Fe === void 0 ? null : Fe;
    var Qe = void 0;
    if (vn !== null) {
      var dt = vn.memoizedState;
      if (Qe = dt.destroy, Fe !== null && ld(Fe, dt.deps)) {
        Ge.memoizedState = _d(Oe, je, Qe, Fe);
        return;
      }
    }
    Fo.flags |= xe, Ge.memoizedState = _d(1 | Oe, je, Qe, Fe);
  }
  function Dm(xe, Oe) {
    return xd(8390656, 8, xe, Oe);
  }
  function kp(xe, Oe) {
    return pl(2048, 8, xe, Oe);
  }
  function Bm(xe, Oe) {
    return pl(4, 2, xe, Oe);
  }
  function Fm(xe, Oe) {
    return pl(4, 4, xe, Oe);
  }
  function Ob(xe, Oe) {
    if (typeof Oe == "function")
      return xe = xe(), Oe(xe), function() {
        Oe(null);
      };
    if (Oe != null)
      return xe = xe(), Oe.current = xe, function() {
        Oe.current = null;
      };
  }
  function mf(xe, Oe, je) {
    return je = je != null ? je.concat([xe]) : null, pl(4, 4, Ob.bind(null, Oe, xe), je);
  }
  function zm() {
  }
  function yf(xe, Oe) {
    var je = ss();
    Oe = Oe === void 0 ? null : Oe;
    var Fe = je.memoizedState;
    return Fe !== null && Oe !== null && ld(Oe, Fe[1]) ? Fe[0] : (je.memoizedState = [xe, Oe], xe);
  }
  function fc(xe, Oe) {
    var je = ss();
    Oe = Oe === void 0 ? null : Oe;
    var Fe = je.memoizedState;
    return Fe !== null && Oe !== null && ld(Oe, Fe[1]) ? Fe[0] : (xe = xe(), je.memoizedState = [xe, Oe], xe);
  }
  function us(xe, Oe, je) {
    return id & 21 ? (Hs(je, Oe) || (je = tl(), Fo.lanes |= je, Ad |= je, xe.baseState = !0), Oe) : (xe.baseState && (xe.baseState = !1, ka = !0), xe.memoizedState = je);
  }
  function b_(xe, Oe) {
    var je = so;
    so = je !== 0 && 4 > je ? je : 4, xe(!0);
    var Fe = Tb.transition;
    Tb.transition = {};
    try {
      xe(!1), Oe();
    } finally {
      so = je, Tb.transition = Fe;
    }
  }
  function Co() {
    return ss().memoizedState;
  }
  function Um(xe, Oe, je) {
    var Fe = Ns(xe);
    if (je = { lane: Fe, action: je, hasEagerState: !1, eagerState: null, next: null }, bf(xe))
      Tp(Oe, je);
    else if (je = Sg(xe, Oe, je, Fe), je !== null) {
      var Ge = Io();
      Ms(je, xe, Fe, Ge), $g(je, Oe, Fe);
    }
  }
  function Vm(xe, Oe, je) {
    var Fe = Ns(xe), Ge = { lane: Fe, action: je, hasEagerState: !1, eagerState: null, next: null };
    if (bf(xe))
      Tp(Oe, Ge);
    else {
      var Qe = xe.alternate;
      if (xe.lanes === 0 && (Qe === null || Qe.lanes === 0) && (Qe = Oe.lastRenderedReducer, Qe !== null))
        try {
          var dt = Oe.lastRenderedState, St = Qe(dt, je);
          if (Ge.hasEagerState = !0, Ge.eagerState = St, Hs(St, dt)) {
            var Rt = Oe.interleaved;
            Rt === null ? (Ge.next = Ge, xb(Oe)) : (Ge.next = Rt.next, Rt.next = Ge), Oe.interleaved = Ge;
            return;
          }
        } catch {
        } finally {
        }
      je = Sg(xe, Oe, Ge, Fe), je !== null && (Ge = Io(), Ms(je, xe, Fe, Ge), $g(je, Oe, Fe));
    }
  }
  function bf(xe) {
    var Oe = xe.alternate;
    return xe === Fo || Oe !== null && Oe === Fo;
  }
  function Tp(xe, Oe) {
    Hu = kr = !0;
    var je = xe.pending;
    je === null ? Oe.next = Oe : (Oe.next = je.next, je.next = Oe), xe.pending = Oe;
  }
  function $g(xe, Oe, je) {
    if (je & 4194240) {
      var Fe = Oe.lanes;
      Fe &= xe.pendingLanes, je |= Fe, Oe.lanes = je, _u(xe, je);
    }
  }
  var Hm = { readContext: fa, useCallback: Uo, useContext: Uo, useEffect: Uo, useImperativeHandle: Uo, useInsertionEffect: Uo, useLayoutEffect: Uo, useMemo: Uo, useReducer: Uo, useRef: Uo, useState: Uo, useDebugValue: Uo, useDeferredValue: Uo, useTransition: Uo, useMutableSource: Uo, useSyncExternalStore: Uo, useId: Uo, unstable_isNewReconciler: !1 }, v_ = { readContext: fa, useCallback: function(xe, Oe) {
    return Ks().memoizedState = [xe, Oe === void 0 ? null : Oe], xe;
  }, useContext: fa, useEffect: Dm, useImperativeHandle: function(xe, Oe, je) {
    return je = je != null ? je.concat([xe]) : null, xd(4194308, 4, Ob.bind(null, Oe, xe), je);
  }, useLayoutEffect: function(xe, Oe) {
    return xd(4194308, 4, xe, Oe);
  }, useInsertionEffect: function(xe, Oe) {
    return xd(4, 2, xe, Oe);
  }, useMemo: function(xe, Oe) {
    var je = Ks();
    return Oe = Oe === void 0 ? null : Oe, xe = xe(), je.memoizedState = [xe, Oe], xe;
  }, useReducer: function(xe, Oe, je) {
    var Fe = Ks();
    return Oe = je !== void 0 ? je(Oe) : Oe, Fe.memoizedState = Fe.baseState = Oe, xe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: xe, lastRenderedState: Oe }, Fe.queue = xe, xe = xe.dispatch = Um.bind(null, Fo, xe), [Fe.memoizedState, xe];
  }, useRef: function(xe) {
    var Oe = Ks();
    return xe = { current: xe }, Oe.memoizedState = xe;
  }, useState: jm, useDebugValue: zm, useDeferredValue: function(xe) {
    return Ks().memoizedState = xe;
  }, useTransition: function() {
    var xe = jm(!1), Oe = xe[0];
    return xe = b_.bind(null, xe[1]), Ks().memoizedState = xe, [Oe, xe];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(xe, Oe, je) {
    var Fe = Fo, Ge = Ks();
    if (Bo) {
      if (je === void 0)
        throw Error(fe(407));
      je = je();
    } else {
      if (je = Oe(), Ta === null)
        throw Error(fe(349));
      id & 30 || Im(Fe, Oe, je);
    }
    Ge.memoizedState = je;
    var Qe = { value: je, getSnapshot: Oe };
    return Ge.queue = Qe, Dm(Rm.bind(null, Fe, Qe, xe), [xe]), Fe.flags |= 2048, _d(9, $m.bind(null, Fe, Qe, je, Oe), void 0, null), je;
  }, useId: function() {
    var xe = Ks(), Oe = Ta.identifierPrefix;
    if (Bo) {
      var je = cl, Fe = ci;
      je = (Fe & ~(1 << 32 - ri(Fe) - 1)).toString(32) + je, Oe = ":" + Oe + "R" + je, je = Is++, 0 < je && (Oe += "H" + je.toString(32)), Oe += ":";
    } else
      je = ud++, Oe = ":" + Oe + "r" + je.toString(32) + ":";
    return xe.memoizedState = Oe;
  }, unstable_isNewReconciler: !1 }, g_ = { readContext: fa, useCallback: yf, useContext: fa, useEffect: kp, useImperativeHandle: mf, useInsertionEffect: Bm, useLayoutEffect: Fm, useMemo: fc, useReducer: Sp, useRef: Lm, useState: function() {
    return Sp(wd);
  }, useDebugValue: zm, useDeferredValue: function(xe) {
    var Oe = ss();
    return us(Oe, vn.memoizedState, xe);
  }, useTransition: function() {
    var xe = Sp(wd)[0], Oe = ss().memoizedState;
    return [xe, Oe];
  }, useMutableSource: Am, useSyncExternalStore: Cm, useId: Co, unstable_isNewReconciler: !1 }, Ab = { readContext: fa, useCallback: yf, useContext: fa, useEffect: kp, useImperativeHandle: mf, useInsertionEffect: Bm, useLayoutEffect: Fm, useMemo: fc, useReducer: Pp, useRef: Lm, useState: function() {
    return Pp(wd);
  }, useDebugValue: zm, useDeferredValue: function(xe) {
    var Oe = ss();
    return vn === null ? Oe.memoizedState = xe : us(Oe, vn.memoizedState, xe);
  }, useTransition: function() {
    var xe = Pp(wd)[0], Oe = ss().memoizedState;
    return [xe, Oe];
  }, useMutableSource: Am, useSyncExternalStore: Cm, useId: Co, unstable_isNewReconciler: !1 };
  function vf(xe, Oe) {
    try {
      var je = "", Fe = Oe;
      do
        je += _n(Fe), Fe = Fe.return;
      while (Fe);
      var Ge = je;
    } catch (Qe) {
      Ge = `
Error generating stack: ` + Qe.message + `
` + Qe.stack;
    }
    return { value: xe, source: Oe, stack: Ge, digest: null };
  }
  function Ap(xe, Oe, je) {
    return { value: xe, source: null, stack: je ?? null, digest: Oe ?? null };
  }
  function qm(xe, Oe) {
    try {
      console.error(Oe.value);
    } catch (je) {
      setTimeout(function() {
        throw je;
      });
    }
  }
  var w_ = typeof WeakMap == "function" ? WeakMap : Map;
  function Rg(xe, Oe, je) {
    je = fl(-1, je), je.tag = 3, je.payload = { element: null };
    var Fe = Oe.value;
    return je.callback = function() {
      mc || (mc = !0, Lp = Fe), qm(xe, Oe);
    }, je;
  }
  function Cp(xe, Oe, je) {
    je = fl(-1, je), je.tag = 3;
    var Fe = xe.type.getDerivedStateFromError;
    if (typeof Fe == "function") {
      var Ge = Oe.value;
      je.payload = function() {
        return Fe(Ge);
      }, je.callback = function() {
        qm(xe, Oe);
      };
    }
    var Qe = xe.stateNode;
    return Qe !== null && typeof Qe.componentDidCatch == "function" && (je.callback = function() {
      qm(xe, Oe), typeof Fe != "function" && (eu === null ? eu = /* @__PURE__ */ new Set([this]) : eu.add(this));
      var dt = Oe.stack;
      this.componentDidCatch(Oe.value, { componentStack: dt !== null ? dt : "" });
    }), je;
  }
  function Ng(xe, Oe, je) {
    var Fe = xe.pingCache;
    if (Fe === null) {
      Fe = xe.pingCache = new w_();
      var Ge = /* @__PURE__ */ new Set();
      Fe.set(Oe, Ge);
    } else
      Ge = Fe.get(Oe), Ge === void 0 && (Ge = /* @__PURE__ */ new Set(), Fe.set(Oe, Ge));
    Ge.has(je) || (Ge.add(je), xe = Vb.bind(null, xe, Oe, je), Oe.then(xe, xe));
  }
  function Cb(xe) {
    do {
      var Oe;
      if ((Oe = xe.tag === 13) && (Oe = xe.memoizedState, Oe = Oe !== null ? Oe.dehydrated !== null : !0), Oe)
        return xe;
      xe = xe.return;
    } while (xe !== null);
    return null;
  }
  function Ib(xe, Oe, je, Fe, Ge) {
    return xe.mode & 1 ? (xe.flags |= 65536, xe.lanes = Ge, xe) : (xe === Oe ? xe.flags |= 65536 : (xe.flags |= 128, je.flags |= 131072, je.flags &= -52805, je.tag === 1 && (je.alternate === null ? je.tag = 17 : (Oe = fl(-1, 1), Oe.tag = 2, rc(je, Oe, 1))), je.lanes |= 1), xe);
  }
  var __ = pt.ReactCurrentOwner, ka = !1;
  function $a(xe, Oe, je, Fe) {
    Oe.child = xe === null ? Ig(Oe, null, je, Fe) : pf(Oe, xe.child, je, Fe);
  }
  function pc(xe, Oe, je, Fe, Ge) {
    je = je.render;
    var Qe = Oe.ref;
    return Ln(Oe, Ge), Fe = dc(xe, Oe, je, Fe, Qe, Ge), je = bd(), xe !== null && !ka ? (Oe.updateQueue = xe.updateQueue, Oe.flags &= -2053, xe.lanes &= ~Ge, fi(xe, Oe, Ge)) : (Bo && je && bm(Oe), Oe.flags |= 1, $a(xe, Oe, Fe, Ge), Oe.child);
  }
  function Wm(xe, Oe, je, Fe, Ge) {
    if (xe === null) {
      var Qe = je.type;
      return typeof Qe == "function" && !Zb(Qe) && Qe.defaultProps === void 0 && je.compare === null && je.defaultProps === void 0 ? (Oe.tag = 15, Oe.type = Qe, ls(xe, Oe, Qe, Fe, Ge)) : (xe = ly(je.type, null, Fe, Oe, Oe.mode, Ge), xe.ref = Oe.ref, xe.return = Oe, Oe.child = xe);
    }
    if (Qe = xe.child, !(xe.lanes & Ge)) {
      var dt = Qe.memoizedProps;
      if (je = je.compare, je = je !== null ? je : Jf, je(dt, Fe) && xe.ref === Oe.ref)
        return fi(xe, Oe, Ge);
    }
    return Oe.flags |= 1, xe = vc(Qe, Fe), xe.ref = Oe.ref, xe.return = Oe, Oe.child = xe;
  }
  function ls(xe, Oe, je, Fe, Ge) {
    if (xe !== null) {
      var Qe = xe.memoizedProps;
      if (Jf(Qe, Fe) && xe.ref === Oe.ref)
        if (ka = !1, Oe.pendingProps = Fe = Qe, (xe.lanes & Ge) !== 0)
          xe.flags & 131072 && (ka = !0);
        else
          return Oe.lanes = xe.lanes, fi(xe, Oe, Ge);
    }
    return gf(xe, Oe, je, Fe, Ge);
  }
  function Ed(xe, Oe, je) {
    var Fe = Oe.pendingProps, Ge = Fe.children, Qe = xe !== null ? xe.memoizedState : null;
    if (Fe.mode === "hidden")
      if (!(Oe.mode & 1))
        Oe.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, go(Ef, Rs), Rs |= je;
      else {
        if (!(je & 1073741824))
          return xe = Qe !== null ? Qe.baseLanes | je : je, Oe.lanes = Oe.childLanes = 1073741824, Oe.memoizedState = { baseLanes: xe, cachePool: null, transitions: null }, Oe.updateQueue = null, go(Ef, Rs), Rs |= xe, null;
        Oe.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Fe = Qe !== null ? Qe.baseLanes : je, go(Ef, Rs), Rs |= Fe;
      }
    else
      Qe !== null ? (Fe = Qe.baseLanes | je, Oe.memoizedState = null) : Fe = je, go(Ef, Rs), Rs |= Fe;
    return $a(xe, Oe, Ge, je), Oe.child;
  }
  function Fr(xe, Oe) {
    var je = Oe.ref;
    (xe === null && je !== null || xe !== null && xe.ref !== je) && (Oe.flags |= 512, Oe.flags |= 2097152);
  }
  function gf(xe, Oe, je, Fe, Ge) {
    var Qe = Go(je) ? ns : Cr.current;
    return Qe = qs(Oe, Qe), Ln(Oe, Ge), je = dc(xe, Oe, je, Fe, Qe, Ge), Fe = bd(), xe !== null && !ka ? (Oe.updateQueue = xe.updateQueue, Oe.flags &= -2053, xe.lanes &= ~Ge, fi(xe, Oe, Ge)) : (Bo && Fe && bm(Oe), Oe.flags |= 1, $a(xe, Oe, je, Ge), Oe.child);
  }
  function $b(xe, Oe, je, Fe, Ge) {
    if (Go(je)) {
      var Qe = !0;
      ym(Oe);
    } else
      Qe = !1;
    if (Ln(Oe, Ge), Oe.stateNode === null)
      Xs(xe, Oe), Tg(Oe, je, Fe), Pm(Oe, je, Fe, Ge), Fe = !0;
    else if (xe === null) {
      var dt = Oe.stateNode, St = Oe.memoizedProps;
      dt.props = St;
      var Rt = dt.context, an = je.contextType;
      typeof an == "object" && an !== null ? an = fa(an) : (an = Go(je) ? ns : Cr.current, an = qs(Oe, an));
      var Pn = je.getDerivedStateFromProps, In = typeof Pn == "function" || typeof dt.getSnapshotBeforeUpdate == "function";
      In || typeof dt.UNSAFE_componentWillReceiveProps != "function" && typeof dt.componentWillReceiveProps != "function" || (St !== Fe || Rt !== an) && Og(Oe, dt, Fe, an), nc = !1;
      var kn = Oe.memoizedState;
      dt.state = kn, ac(Oe, Fe, dt, Ge), Rt = Oe.memoizedState, St !== Fe || kn !== Rt || ua.current || nc ? (typeof Pn == "function" && (Pb(Oe, je, Pn, Fe), Rt = Oe.memoizedState), (St = nc || kg(Oe, je, St, Fe, kn, Rt, an)) ? (In || typeof dt.UNSAFE_componentWillMount != "function" && typeof dt.componentWillMount != "function" || (typeof dt.componentWillMount == "function" && dt.componentWillMount(), typeof dt.UNSAFE_componentWillMount == "function" && dt.UNSAFE_componentWillMount()), typeof dt.componentDidMount == "function" && (Oe.flags |= 4194308)) : (typeof dt.componentDidMount == "function" && (Oe.flags |= 4194308), Oe.memoizedProps = Fe, Oe.memoizedState = Rt), dt.props = Fe, dt.state = Rt, dt.context = an, Fe = St) : (typeof dt.componentDidMount == "function" && (Oe.flags |= 4194308), Fe = !1);
    } else {
      dt = Oe.stateNode, Ia(xe, Oe), St = Oe.memoizedProps, an = Oe.type === Oe.elementType ? St : Cs(Oe.type, St), dt.props = an, In = Oe.pendingProps, kn = dt.context, Rt = je.contextType, typeof Rt == "object" && Rt !== null ? Rt = fa(Rt) : (Rt = Go(je) ? ns : Cr.current, Rt = qs(Oe, Rt));
      var qn = je.getDerivedStateFromProps;
      (Pn = typeof qn == "function" || typeof dt.getSnapshotBeforeUpdate == "function") || typeof dt.UNSAFE_componentWillReceiveProps != "function" && typeof dt.componentWillReceiveProps != "function" || (St !== In || kn !== Rt) && Og(Oe, dt, Fe, Rt), nc = !1, kn = Oe.memoizedState, dt.state = kn, ac(Oe, Fe, dt, Ge);
      var er = Oe.memoizedState;
      St !== In || kn !== er || ua.current || nc ? (typeof qn == "function" && (Pb(Oe, je, qn, Fe), er = Oe.memoizedState), (an = nc || kg(Oe, je, an, Fe, kn, er, Rt) || !1) ? (Pn || typeof dt.UNSAFE_componentWillUpdate != "function" && typeof dt.componentWillUpdate != "function" || (typeof dt.componentWillUpdate == "function" && dt.componentWillUpdate(Fe, er, Rt), typeof dt.UNSAFE_componentWillUpdate == "function" && dt.UNSAFE_componentWillUpdate(Fe, er, Rt)), typeof dt.componentDidUpdate == "function" && (Oe.flags |= 4), typeof dt.getSnapshotBeforeUpdate == "function" && (Oe.flags |= 1024)) : (typeof dt.componentDidUpdate != "function" || St === xe.memoizedProps && kn === xe.memoizedState || (Oe.flags |= 4), typeof dt.getSnapshotBeforeUpdate != "function" || St === xe.memoizedProps && kn === xe.memoizedState || (Oe.flags |= 1024), Oe.memoizedProps = Fe, Oe.memoizedState = er), dt.props = Fe, dt.state = er, dt.context = Rt, Fe = an) : (typeof dt.componentDidUpdate != "function" || St === xe.memoizedProps && kn === xe.memoizedState || (Oe.flags |= 4), typeof dt.getSnapshotBeforeUpdate != "function" || St === xe.memoizedProps && kn === xe.memoizedState || (Oe.flags |= 1024), Fe = !1);
    }
    return Rb(xe, Oe, je, Fe, Qe, Ge);
  }
  function Rb(xe, Oe, je, Fe, Ge, Qe) {
    Fr(xe, Oe);
    var dt = (Oe.flags & 128) !== 0;
    if (!Fe && !dt)
      return Ge && wg(Oe, je, !1), fi(xe, Oe, Qe);
    Fe = Oe.stateNode, __.current = Oe;
    var St = dt && typeof je.getDerivedStateFromError != "function" ? null : Fe.render();
    return Oe.flags |= 1, xe !== null && dt ? (Oe.child = pf(Oe, xe.child, null, Qe), Oe.child = pf(Oe, null, St, Qe)) : $a(xe, Oe, St, Qe), Oe.memoizedState = Fe.state, Ge && wg(Oe, je, !0), Oe.child;
  }
  function Gm(xe) {
    var Oe = xe.stateNode;
    Oe.pendingContext ? Xl(xe, Oe.pendingContext, Oe.pendingContext !== Oe.context) : Oe.context && Xl(xe, Oe.context, !1), kb(xe, Oe.containerInfo);
  }
  function wf(xe, Oe, je, Fe, Ge) {
    return ea(), gb(Ge), Oe.flags |= 256, $a(xe, Oe, je, Fe), Oe.child;
  }
  var Nb = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ym(xe) {
    return { baseLanes: xe, cachePool: null, transitions: null };
  }
  function Mg(xe, Oe, je) {
    var Fe = Oe.pendingProps, Ge = xr.current, Qe = !1, dt = (Oe.flags & 128) !== 0, St;
    if ((St = dt) || (St = xe !== null && xe.memoizedState === null ? !1 : (Ge & 2) !== 0), St ? (Qe = !0, Oe.flags &= -129) : (xe === null || xe.memoizedState !== null) && (Ge |= 1), go(xr, Ge & 1), xe === null)
      return gm(Oe), xe = Oe.memoizedState, xe !== null && (xe = xe.dehydrated, xe !== null) ? (Oe.mode & 1 ? xe.data === "$!" ? Oe.lanes = 8 : Oe.lanes = 1073741824 : Oe.lanes = 1, null) : (dt = Fe.children, xe = Fe.fallback, Qe ? (Fe = Oe.mode, Qe = Oe.child, dt = { mode: "hidden", children: dt }, !(Fe & 1) && Qe !== null ? (Qe.childLanes = 0, Qe.pendingProps = dt) : Qe = Af(dt, Fe, 0, null), xe = gc(xe, Fe, je, null), Qe.return = Oe, xe.return = Oe, Qe.sibling = xe, Oe.child = Qe, Oe.child.memoizedState = Ym(je), Oe.memoizedState = Nb, xe) : Ip(Oe, dt));
    if (Ge = xe.memoizedState, Ge !== null && (St = Ge.dehydrated, St !== null))
      return jg(xe, Oe, dt, Fe, St, Ge, je);
    if (Qe) {
      Qe = Fe.fallback, dt = Oe.mode, Ge = xe.child, St = Ge.sibling;
      var Rt = { mode: "hidden", children: Fe.children };
      return !(dt & 1) && Oe.child !== Ge ? (Fe = Oe.child, Fe.childLanes = 0, Fe.pendingProps = Rt, Oe.deletions = null) : (Fe = vc(Ge, Rt), Fe.subtreeFlags = Ge.subtreeFlags & 14680064), St !== null ? Qe = vc(St, Qe) : (Qe = gc(Qe, dt, je, null), Qe.flags |= 2), Qe.return = Oe, Fe.return = Oe, Fe.sibling = Qe, Oe.child = Fe, Fe = Qe, Qe = Oe.child, dt = xe.child.memoizedState, dt = dt === null ? Ym(je) : { baseLanes: dt.baseLanes | je, cachePool: null, transitions: dt.transitions }, Qe.memoizedState = dt, Qe.childLanes = xe.childLanes & ~je, Oe.memoizedState = Nb, Fe;
    }
    return Qe = xe.child, xe = Qe.sibling, Fe = vc(Qe, { mode: "visible", children: Fe.children }), !(Oe.mode & 1) && (Fe.lanes = je), Fe.return = Oe, Fe.sibling = null, xe !== null && (je = Oe.deletions, je === null ? (Oe.deletions = [xe], Oe.flags |= 16) : je.push(xe)), Oe.child = Fe, Oe.memoizedState = null, Fe;
  }
  function Ip(xe, Oe) {
    return Oe = Af({ mode: "visible", children: Oe }, xe.mode, 0, null), Oe.return = xe, xe.child = Oe;
  }
  function Qm(xe, Oe, je, Fe) {
    return Fe !== null && gb(Fe), pf(Oe, xe.child, null, je), xe = Ip(Oe, Oe.pendingProps.children), xe.flags |= 2, Oe.memoizedState = null, xe;
  }
  function jg(xe, Oe, je, Fe, Ge, Qe, dt) {
    if (je)
      return Oe.flags & 256 ? (Oe.flags &= -257, Fe = Ap(Error(fe(422))), Qm(xe, Oe, dt, Fe)) : Oe.memoizedState !== null ? (Oe.child = xe.child, Oe.flags |= 128, null) : (Qe = Fe.fallback, Ge = Oe.mode, Fe = Af({ mode: "visible", children: Fe.children }, Ge, 0, null), Qe = gc(Qe, Ge, dt, null), Qe.flags |= 2, Fe.return = Oe, Qe.return = Oe, Fe.sibling = Qe, Oe.child = Fe, Oe.mode & 1 && pf(Oe, xe.child, null, dt), Oe.child.memoizedState = Ym(dt), Oe.memoizedState = Nb, Qe);
    if (!(Oe.mode & 1))
      return Qm(xe, Oe, dt, null);
    if (Ge.data === "$!") {
      if (Fe = Ge.nextSibling && Ge.nextSibling.dataset, Fe)
        var St = Fe.dgst;
      return Fe = St, Qe = Error(fe(419)), Fe = Ap(Qe, Fe, void 0), Qm(xe, Oe, dt, Fe);
    }
    if (St = (dt & xe.childLanes) !== 0, ka || St) {
      if (Fe = Ta, Fe !== null) {
        switch (dt & -dt) {
          case 4:
            Ge = 2;
            break;
          case 16:
            Ge = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            Ge = 32;
            break;
          case 536870912:
            Ge = 268435456;
            break;
          default:
            Ge = 0;
        }
        Ge = Ge & (Fe.suspendedLanes | dt) ? 0 : Ge, Ge !== 0 && Ge !== Qe.retryLane && (Qe.retryLane = Ge, dl(xe, Ge), Ms(Fe, xe, Ge, -1));
      }
      return zb(), Fe = Ap(Error(fe(421))), Qm(xe, Oe, dt, Fe);
    }
    return Ge.data === "$?" ? (Oe.flags |= 128, Oe.child = xe.child, Oe = T_.bind(null, xe), Ge._reactRetry = Oe, null) : (xe = Qe.treeContext, is = fu(Ge.nextSibling), As = Oe, Bo = !0, Ys = null, xe !== null && (as[Ii++] = ci, as[Ii++] = cl, as[Ii++] = Gs, ci = xe.id, cl = xe.overflow, Gs = Oe), Oe = Ip(Oe, Fe.children), Oe.flags |= 4096, Oe);
  }
  function Mb(xe, Oe, je) {
    xe.lanes |= Oe;
    var Fe = xe.alternate;
    Fe !== null && (Fe.lanes |= Oe), Ua(xe.return, Oe, je);
  }
  function Km(xe, Oe, je, Fe, Ge) {
    var Qe = xe.memoizedState;
    Qe === null ? xe.memoizedState = { isBackwards: Oe, rendering: null, renderingStartTime: 0, last: Fe, tail: je, tailMode: Ge } : (Qe.isBackwards = Oe, Qe.rendering = null, Qe.renderingStartTime = 0, Qe.last = Fe, Qe.tail = je, Qe.tailMode = Ge);
  }
  function cs(xe, Oe, je) {
    var Fe = Oe.pendingProps, Ge = Fe.revealOrder, Qe = Fe.tail;
    if ($a(xe, Oe, Fe.children, je), Fe = xr.current, Fe & 2)
      Fe = Fe & 1 | 2, Oe.flags |= 128;
    else {
      if (xe !== null && xe.flags & 128)
        e:
          for (xe = Oe.child; xe !== null; ) {
            if (xe.tag === 13)
              xe.memoizedState !== null && Mb(xe, je, Oe);
            else if (xe.tag === 19)
              Mb(xe, je, Oe);
            else if (xe.child !== null) {
              xe.child.return = xe, xe = xe.child;
              continue;
            }
            if (xe === Oe)
              break e;
            for (; xe.sibling === null; ) {
              if (xe.return === null || xe.return === Oe)
                break e;
              xe = xe.return;
            }
            xe.sibling.return = xe.return, xe = xe.sibling;
          }
      Fe &= 1;
    }
    if (go(xr, Fe), !(Oe.mode & 1))
      Oe.memoizedState = null;
    else
      switch (Ge) {
        case "forwards":
          for (je = Oe.child, Ge = null; je !== null; )
            xe = je.alternate, xe !== null && ta(xe) === null && (Ge = je), je = je.sibling;
          je = Ge, je === null ? (Ge = Oe.child, Oe.child = null) : (Ge = je.sibling, je.sibling = null), Km(Oe, !1, Ge, je, Qe);
          break;
        case "backwards":
          for (je = null, Ge = Oe.child, Oe.child = null; Ge !== null; ) {
            if (xe = Ge.alternate, xe !== null && ta(xe) === null) {
              Oe.child = Ge;
              break;
            }
            xe = Ge.sibling, Ge.sibling = je, je = Ge, Ge = xe;
          }
          Km(Oe, !0, je, null, Qe);
          break;
        case "together":
          Km(Oe, !1, null, null, void 0);
          break;
        default:
          Oe.memoizedState = null;
      }
    return Oe.child;
  }
  function Xs(xe, Oe) {
    !(Oe.mode & 1) && xe !== null && (xe.alternate = null, Oe.alternate = null, Oe.flags |= 2);
  }
  function fi(xe, Oe, je) {
    if (xe !== null && (Oe.dependencies = xe.dependencies), Ad |= Oe.lanes, !(je & Oe.childLanes))
      return null;
    if (xe !== null && Oe.child !== xe.child)
      throw Error(fe(153));
    if (Oe.child !== null) {
      for (xe = Oe.child, je = vc(xe, xe.pendingProps), Oe.child = je, je.return = Oe; xe.sibling !== null; )
        xe = xe.sibling, je = je.sibling = vc(xe, xe.pendingProps), je.return = Oe;
      je.sibling = null;
    }
    return Oe.child;
  }
  function ey(xe, Oe, je) {
    switch (Oe.tag) {
      case 3:
        Gm(Oe), ea();
        break;
      case 5:
        vr(Oe);
        break;
      case 1:
        Go(Oe.type) && ym(Oe);
        break;
      case 4:
        kb(Oe, Oe.stateNode.containerInfo);
        break;
      case 10:
        var Fe = Oe.type._context, Ge = Oe.memoizedProps.value;
        go(Vu, Fe._currentValue), Fe._currentValue = Ge;
        break;
      case 13:
        if (Fe = Oe.memoizedState, Fe !== null)
          return Fe.dehydrated !== null ? (go(xr, xr.current & 1), Oe.flags |= 128, null) : je & Oe.child.childLanes ? Mg(xe, Oe, je) : (go(xr, xr.current & 1), xe = fi(xe, Oe, je), xe !== null ? xe.sibling : null);
        go(xr, xr.current & 1);
        break;
      case 19:
        if (Fe = (je & Oe.childLanes) !== 0, xe.flags & 128) {
          if (Fe)
            return cs(xe, Oe, je);
          Oe.flags |= 128;
        }
        if (Ge = Oe.memoizedState, Ge !== null && (Ge.rendering = null, Ge.tail = null, Ge.lastEffect = null), go(xr, xr.current), Fe)
          break;
        return null;
      case 22:
      case 23:
        return Oe.lanes = 0, Ed(xe, Oe, je);
    }
    return fi(xe, Oe, je);
  }
  var _f, $s, Ra, Lg;
  _f = function(xe, Oe) {
    for (var je = Oe.child; je !== null; ) {
      if (je.tag === 5 || je.tag === 6)
        xe.appendChild(je.stateNode);
      else if (je.tag !== 4 && je.child !== null) {
        je.child.return = je, je = je.child;
        continue;
      }
      if (je === Oe)
        break;
      for (; je.sibling === null; ) {
        if (je.return === null || je.return === Oe)
          return;
        je = je.return;
      }
      je.sibling.return = je.return, je = je.sibling;
    }
  }, $s = function() {
  }, Ra = function(xe, Oe, je, Fe) {
    var Ge = xe.memoizedProps;
    if (Ge !== Fe) {
      xe = Oe.stateNode, ad(pu.current);
      var Qe = null;
      switch (je) {
        case "input":
          Ge = $o(xe, Ge), Fe = $o(xe, Fe), Qe = [];
          break;
        case "select":
          Ge = At({}, Ge, { value: void 0 }), Fe = At({}, Fe, { value: void 0 }), Qe = [];
          break;
        case "textarea":
          Ge = xa(xe, Ge), Fe = xa(xe, Fe), Qe = [];
          break;
        default:
          typeof Ge.onClick != "function" && typeof Fe.onClick == "function" && (xe.onclick = mm);
      }
      Kn(je, Fe);
      var dt;
      je = null;
      for (an in Ge)
        if (!Fe.hasOwnProperty(an) && Ge.hasOwnProperty(an) && Ge[an] != null)
          if (an === "style") {
            var St = Ge[an];
            for (dt in St)
              St.hasOwnProperty(dt) && (je || (je = {}), je[dt] = "");
          } else
            an !== "dangerouslySetInnerHTML" && an !== "children" && an !== "suppressContentEditableWarning" && an !== "suppressHydrationWarning" && an !== "autoFocus" && (ge.hasOwnProperty(an) ? Qe || (Qe = []) : (Qe = Qe || []).push(an, null));
      for (an in Fe) {
        var Rt = Fe[an];
        if (St = Ge == null ? void 0 : Ge[an], Fe.hasOwnProperty(an) && Rt !== St && (Rt != null || St != null))
          if (an === "style")
            if (St) {
              for (dt in St)
                !St.hasOwnProperty(dt) || Rt && Rt.hasOwnProperty(dt) || (je || (je = {}), je[dt] = "");
              for (dt in Rt)
                Rt.hasOwnProperty(dt) && St[dt] !== Rt[dt] && (je || (je = {}), je[dt] = Rt[dt]);
            } else
              je || (Qe || (Qe = []), Qe.push(an, je)), je = Rt;
          else
            an === "dangerouslySetInnerHTML" ? (Rt = Rt ? Rt.__html : void 0, St = St ? St.__html : void 0, Rt != null && St !== Rt && (Qe = Qe || []).push(an, Rt)) : an === "children" ? typeof Rt != "string" && typeof Rt != "number" || (Qe = Qe || []).push(an, "" + Rt) : an !== "suppressContentEditableWarning" && an !== "suppressHydrationWarning" && (ge.hasOwnProperty(an) ? (Rt != null && an === "onScroll" && Ao("scroll", xe), Qe || St === Rt || (Qe = [])) : (Qe = Qe || []).push(an, Rt));
      }
      je && (Qe = Qe || []).push("style", je);
      var an = Qe;
      (Oe.updateQueue = an) && (Oe.flags |= 4);
    }
  }, Lg = function(xe, Oe, je, Fe) {
    je !== Fe && (Oe.flags |= 4);
  };
  function $p(xe, Oe) {
    if (!Bo)
      switch (xe.tailMode) {
        case "hidden":
          Oe = xe.tail;
          for (var je = null; Oe !== null; )
            Oe.alternate !== null && (je = Oe), Oe = Oe.sibling;
          je === null ? xe.tail = null : je.sibling = null;
          break;
        case "collapsed":
          je = xe.tail;
          for (var Fe = null; je !== null; )
            je.alternate !== null && (Fe = je), je = je.sibling;
          Fe === null ? Oe || xe.tail === null ? xe.tail = null : xe.tail.sibling = null : Fe.sibling = null;
      }
  }
  function $i(xe) {
    var Oe = xe.alternate !== null && xe.alternate.child === xe.child, je = 0, Fe = 0;
    if (Oe)
      for (var Ge = xe.child; Ge !== null; )
        je |= Ge.lanes | Ge.childLanes, Fe |= Ge.subtreeFlags & 14680064, Fe |= Ge.flags & 14680064, Ge.return = xe, Ge = Ge.sibling;
    else
      for (Ge = xe.child; Ge !== null; )
        je |= Ge.lanes | Ge.childLanes, Fe |= Ge.subtreeFlags, Fe |= Ge.flags, Ge.return = xe, Ge = Ge.sibling;
    return xe.subtreeFlags |= Fe, xe.childLanes = je, Oe;
  }
  function jb(xe, Oe, je) {
    var Fe = Oe.pendingProps;
    switch (bb(Oe), Oe.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return $i(Oe), null;
      case 1:
        return Go(Oe.type) && Ws(), $i(Oe), null;
      case 3:
        return Fe = Oe.stateNode, ic(), yo(ua), yo(Cr), Tm(), Fe.pendingContext && (Fe.context = Fe.pendingContext, Fe.pendingContext = null), (xe === null || xe.child === null) && (wm(Oe) ? Oe.flags |= 4 : xe === null || xe.memoizedState.isDehydrated && !(Oe.flags & 256) || (Oe.flags |= 1024, Ys !== null && (Up(Ys), Ys = null))), $s(xe, Oe), $i(Oe), null;
      case 5:
        Vr(Oe);
        var Ge = ad(hf.current);
        if (je = Oe.type, xe !== null && Oe.stateNode != null)
          Ra(xe, Oe, je, Fe, Ge), xe.ref !== Oe.ref && (Oe.flags |= 512, Oe.flags |= 2097152);
        else {
          if (!Fe) {
            if (Oe.stateNode === null)
              throw Error(fe(166));
            return $i(Oe), null;
          }
          if (xe = ad(pu.current), wm(Oe)) {
            Fe = Oe.stateNode, je = Oe.type;
            var Qe = Oe.memoizedProps;
            switch (Fe[zu] = Oe, Fe[nd] = Qe, xe = (Oe.mode & 1) !== 0, je) {
              case "dialog":
                Ao("cancel", Fe), Ao("close", Fe);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ao("load", Fe);
                break;
              case "video":
              case "audio":
                for (Ge = 0; Ge < tp.length; Ge++)
                  Ao(tp[Ge], Fe);
                break;
              case "source":
                Ao("error", Fe);
                break;
              case "img":
              case "image":
              case "link":
                Ao("error", Fe), Ao("load", Fe);
                break;
              case "details":
                Ao("toggle", Fe);
                break;
              case "input":
                xo(Fe, Qe), Ao("invalid", Fe);
                break;
              case "select":
                Fe._wrapperState = { wasMultiple: !!Qe.multiple }, Ao("invalid", Fe);
                break;
              case "textarea":
                qa(Fe, Qe), Ao("invalid", Fe);
            }
            Kn(je, Qe), Ge = null;
            for (var dt in Qe)
              if (Qe.hasOwnProperty(dt)) {
                var St = Qe[dt];
                dt === "children" ? typeof St == "string" ? Fe.textContent !== St && (Qe.suppressHydrationWarning !== !0 && hm(Fe.textContent, St, xe), Ge = ["children", St]) : typeof St == "number" && Fe.textContent !== "" + St && (Qe.suppressHydrationWarning !== !0 && hm(Fe.textContent, St, xe), Ge = ["children", "" + St]) : ge.hasOwnProperty(dt) && St != null && dt === "onScroll" && Ao("scroll", Fe);
              }
            switch (je) {
              case "input":
                Yr(Fe), Aa(Fe, Qe, !0);
                break;
              case "textarea":
                Yr(Fe), oa(Fe);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof Qe.onClick == "function" && (Fe.onclick = mm);
            }
            Fe = Ge, Oe.updateQueue = Fe, Fe !== null && (Oe.flags |= 4);
          } else {
            dt = Ge.nodeType === 9 ? Ge : Ge.ownerDocument, xe === "http://www.w3.org/1999/xhtml" && (xe = Ka(je)), xe === "http://www.w3.org/1999/xhtml" ? je === "script" ? (xe = dt.createElement("div"), xe.innerHTML = "<script><\/script>", xe = xe.removeChild(xe.firstChild)) : typeof Fe.is == "string" ? xe = dt.createElement(je, { is: Fe.is }) : (xe = dt.createElement(je), je === "select" && (dt = xe, Fe.multiple ? dt.multiple = !0 : Fe.size && (dt.size = Fe.size))) : xe = dt.createElementNS(xe, je), xe[zu] = Oe, xe[nd] = Fe, _f(xe, Oe, !1, !1), Oe.stateNode = xe;
            e: {
              switch (dt = jn(je, Fe), je) {
                case "dialog":
                  Ao("cancel", xe), Ao("close", xe), Ge = Fe;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Ao("load", xe), Ge = Fe;
                  break;
                case "video":
                case "audio":
                  for (Ge = 0; Ge < tp.length; Ge++)
                    Ao(tp[Ge], xe);
                  Ge = Fe;
                  break;
                case "source":
                  Ao("error", xe), Ge = Fe;
                  break;
                case "img":
                case "image":
                case "link":
                  Ao("error", xe), Ao("load", xe), Ge = Fe;
                  break;
                case "details":
                  Ao("toggle", xe), Ge = Fe;
                  break;
                case "input":
                  xo(xe, Fe), Ge = $o(xe, Fe), Ao("invalid", xe);
                  break;
                case "option":
                  Ge = Fe;
                  break;
                case "select":
                  xe._wrapperState = { wasMultiple: !!Fe.multiple }, Ge = At({}, Fe, { value: void 0 }), Ao("invalid", xe);
                  break;
                case "textarea":
                  qa(xe, Fe), Ge = xa(xe, Fe), Ao("invalid", xe);
                  break;
                default:
                  Ge = Fe;
              }
              Kn(je, Ge), St = Ge;
              for (Qe in St)
                if (St.hasOwnProperty(Qe)) {
                  var Rt = St[Qe];
                  Qe === "style" ? Bn(xe, Rt) : Qe === "dangerouslySetInnerHTML" ? (Rt = Rt ? Rt.__html : void 0, Rt != null && $t(xe, Rt)) : Qe === "children" ? typeof Rt == "string" ? (je !== "textarea" || Rt !== "") && Vt(xe, Rt) : typeof Rt == "number" && Vt(xe, "" + Rt) : Qe !== "suppressContentEditableWarning" && Qe !== "suppressHydrationWarning" && Qe !== "autoFocus" && (ge.hasOwnProperty(Qe) ? Rt != null && Qe === "onScroll" && Ao("scroll", xe) : Rt != null && ot(xe, Qe, Rt, dt));
                }
              switch (je) {
                case "input":
                  Yr(xe), Aa(xe, Fe, !1);
                  break;
                case "textarea":
                  Yr(xe), oa(xe);
                  break;
                case "option":
                  Fe.value != null && xe.setAttribute("value", "" + nr(Fe.value));
                  break;
                case "select":
                  xe.multiple = !!Fe.multiple, Qe = Fe.value, Qe != null ? No(xe, !!Fe.multiple, Qe, !1) : Fe.defaultValue != null && No(xe, !!Fe.multiple, Fe.defaultValue, !0);
                  break;
                default:
                  typeof Ge.onClick == "function" && (xe.onclick = mm);
              }
              switch (je) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  Fe = !!Fe.autoFocus;
                  break e;
                case "img":
                  Fe = !0;
                  break e;
                default:
                  Fe = !1;
              }
            }
            Fe && (Oe.flags |= 4);
          }
          Oe.ref !== null && (Oe.flags |= 512, Oe.flags |= 2097152);
        }
        return $i(Oe), null;
      case 6:
        if (xe && Oe.stateNode != null)
          Lg(xe, Oe, xe.memoizedProps, Fe);
        else {
          if (typeof Fe != "string" && Oe.stateNode === null)
            throw Error(fe(166));
          if (je = ad(hf.current), ad(pu.current), wm(Oe)) {
            if (Fe = Oe.stateNode, je = Oe.memoizedProps, Fe[zu] = Oe, (Qe = Fe.nodeValue !== je) && (xe = As, xe !== null))
              switch (xe.tag) {
                case 3:
                  hm(Fe.nodeValue, je, (xe.mode & 1) !== 0);
                  break;
                case 5:
                  xe.memoizedProps.suppressHydrationWarning !== !0 && hm(Fe.nodeValue, je, (xe.mode & 1) !== 0);
              }
            Qe && (Oe.flags |= 4);
          } else
            Fe = (je.nodeType === 9 ? je : je.ownerDocument).createTextNode(Fe), Fe[zu] = Oe, Oe.stateNode = Fe;
        }
        return $i(Oe), null;
      case 13:
        if (yo(xr), Fe = Oe.memoizedState, xe === null || xe.memoizedState !== null && xe.memoizedState.dehydrated !== null) {
          if (Bo && is !== null && Oe.mode & 1 && !(Oe.flags & 128))
            Eg(), ea(), Oe.flags |= 98560, Qe = !1;
          else if (Qe = wm(Oe), Fe !== null && Fe.dehydrated !== null) {
            if (xe === null) {
              if (!Qe)
                throw Error(fe(318));
              if (Qe = Oe.memoizedState, Qe = Qe !== null ? Qe.dehydrated : null, !Qe)
                throw Error(fe(317));
              Qe[zu] = Oe;
            } else
              ea(), !(Oe.flags & 128) && (Oe.memoizedState = null), Oe.flags |= 4;
            $i(Oe), Qe = !1;
          } else
            Ys !== null && (Up(Ys), Ys = null), Qe = !0;
          if (!Qe)
            return Oe.flags & 65536 ? Oe : null;
        }
        return Oe.flags & 128 ? (Oe.lanes = je, Oe) : (Fe = Fe !== null, Fe !== (xe !== null && xe.memoizedState !== null) && Fe && (Oe.child.flags |= 8192, Oe.mode & 1 && (xe === null || xr.current & 1 ? Na === 0 && (Na = 3) : zb())), Oe.updateQueue !== null && (Oe.flags |= 4), $i(Oe), null);
      case 4:
        return ic(), $s(xe, Oe), xe === null && lf(Oe.stateNode.containerInfo), $i(Oe), null;
      case 10:
        return tc(Oe.type._context), $i(Oe), null;
      case 17:
        return Go(Oe.type) && Ws(), $i(Oe), null;
      case 19:
        if (yo(xr), Qe = Oe.memoizedState, Qe === null)
          return $i(Oe), null;
        if (Fe = (Oe.flags & 128) !== 0, dt = Qe.rendering, dt === null)
          if (Fe)
            $p(Qe, !1);
          else {
            if (Na !== 0 || xe !== null && xe.flags & 128)
              for (xe = Oe.child; xe !== null; ) {
                if (dt = ta(xe), dt !== null) {
                  for (Oe.flags |= 128, $p(Qe, !1), Fe = dt.updateQueue, Fe !== null && (Oe.updateQueue = Fe, Oe.flags |= 4), Oe.subtreeFlags = 0, Fe = je, je = Oe.child; je !== null; )
                    Qe = je, xe = Fe, Qe.flags &= 14680066, dt = Qe.alternate, dt === null ? (Qe.childLanes = 0, Qe.lanes = xe, Qe.child = null, Qe.subtreeFlags = 0, Qe.memoizedProps = null, Qe.memoizedState = null, Qe.updateQueue = null, Qe.dependencies = null, Qe.stateNode = null) : (Qe.childLanes = dt.childLanes, Qe.lanes = dt.lanes, Qe.child = dt.child, Qe.subtreeFlags = 0, Qe.deletions = null, Qe.memoizedProps = dt.memoizedProps, Qe.memoizedState = dt.memoizedState, Qe.updateQueue = dt.updateQueue, Qe.type = dt.type, xe = dt.dependencies, Qe.dependencies = xe === null ? null : { lanes: xe.lanes, firstContext: xe.firstContext }), je = je.sibling;
                  return go(xr, xr.current & 1 | 2), Oe.child;
                }
                xe = xe.sibling;
              }
            Qe.tail !== null && Xr() > Pf && (Oe.flags |= 128, Fe = !0, $p(Qe, !1), Oe.lanes = 4194304);
          }
        else {
          if (!Fe)
            if (xe = ta(dt), xe !== null) {
              if (Oe.flags |= 128, Fe = !0, je = xe.updateQueue, je !== null && (Oe.updateQueue = je, Oe.flags |= 4), $p(Qe, !0), Qe.tail === null && Qe.tailMode === "hidden" && !dt.alternate && !Bo)
                return $i(Oe), null;
            } else
              2 * Xr() - Qe.renderingStartTime > Pf && je !== 1073741824 && (Oe.flags |= 128, Fe = !0, $p(Qe, !1), Oe.lanes = 4194304);
          Qe.isBackwards ? (dt.sibling = Oe.child, Oe.child = dt) : (je = Qe.last, je !== null ? je.sibling = dt : Oe.child = dt, Qe.last = dt);
        }
        return Qe.tail !== null ? (Oe = Qe.tail, Qe.rendering = Oe, Qe.tail = Oe.sibling, Qe.renderingStartTime = Xr(), Oe.sibling = null, je = xr.current, go(xr, Fe ? je & 1 | 2 : je & 1), Oe) : ($i(Oe), null);
      case 22:
      case 23:
        return Fb(), Fe = Oe.memoizedState !== null, xe !== null && xe.memoizedState !== null !== Fe && (Oe.flags |= 8192), Fe && Oe.mode & 1 ? Rs & 1073741824 && ($i(Oe), Oe.subtreeFlags & 6 && (Oe.flags |= 8192)) : $i(Oe), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(fe(156, Oe.tag));
  }
  function Dg(xe, Oe) {
    switch (bb(Oe), Oe.tag) {
      case 1:
        return Go(Oe.type) && Ws(), xe = Oe.flags, xe & 65536 ? (Oe.flags = xe & -65537 | 128, Oe) : null;
      case 3:
        return ic(), yo(ua), yo(Cr), Tm(), xe = Oe.flags, xe & 65536 && !(xe & 128) ? (Oe.flags = xe & -65537 | 128, Oe) : null;
      case 5:
        return Vr(Oe), null;
      case 13:
        if (yo(xr), xe = Oe.memoizedState, xe !== null && xe.dehydrated !== null) {
          if (Oe.alternate === null)
            throw Error(fe(340));
          ea();
        }
        return xe = Oe.flags, xe & 65536 ? (Oe.flags = xe & -65537 | 128, Oe) : null;
      case 19:
        return yo(xr), null;
      case 4:
        return ic(), null;
      case 10:
        return tc(Oe.type._context), null;
      case 22:
      case 23:
        return Fb(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Pd = !1, pi = !1, x_ = typeof WeakSet == "function" ? WeakSet : Set, Xn = null;
  function hc(xe, Oe) {
    var je = xe.ref;
    if (je !== null)
      if (typeof je == "function")
        try {
          je(null);
        } catch (Fe) {
          la(xe, Oe, Fe);
        }
      else
        je.current = null;
  }
  function Bg(xe, Oe, je) {
    try {
      je();
    } catch (Fe) {
      la(xe, Oe, Fe);
    }
  }
  var Lb = !1;
  function E_(xe, Oe) {
    if (lb = ks, xe = lm(), il(xe)) {
      if ("selectionStart" in xe)
        var je = { start: xe.selectionStart, end: xe.selectionEnd };
      else
        e: {
          je = (je = xe.ownerDocument) && je.defaultView || window;
          var Fe = je.getSelection && je.getSelection();
          if (Fe && Fe.rangeCount !== 0) {
            je = Fe.anchorNode;
            var Ge = Fe.anchorOffset, Qe = Fe.focusNode;
            Fe = Fe.focusOffset;
            try {
              je.nodeType, Qe.nodeType;
            } catch {
              je = null;
              break e;
            }
            var dt = 0, St = -1, Rt = -1, an = 0, Pn = 0, In = xe, kn = null;
            t:
              for (; ; ) {
                for (var qn; In !== je || Ge !== 0 && In.nodeType !== 3 || (St = dt + Ge), In !== Qe || Fe !== 0 && In.nodeType !== 3 || (Rt = dt + Fe), In.nodeType === 3 && (dt += In.nodeValue.length), (qn = In.firstChild) !== null; )
                  kn = In, In = qn;
                for (; ; ) {
                  if (In === xe)
                    break t;
                  if (kn === je && ++an === Ge && (St = dt), kn === Qe && ++Pn === Fe && (Rt = dt), (qn = In.nextSibling) !== null)
                    break;
                  In = kn, kn = In.parentNode;
                }
                In = qn;
              }
            je = St === -1 || Rt === -1 ? null : { start: St, end: Rt };
          } else
            je = null;
        }
      je = je || { start: 0, end: 0 };
    } else
      je = null;
    for (ed = { focusedElem: xe, selectionRange: je }, ks = !1, Xn = Oe; Xn !== null; )
      if (Oe = Xn, xe = Oe.child, (Oe.subtreeFlags & 1028) !== 0 && xe !== null)
        xe.return = Oe, Xn = xe;
      else
        for (; Xn !== null; ) {
          Oe = Xn;
          try {
            var er = Oe.alternate;
            if (Oe.flags & 1024)
              switch (Oe.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (er !== null) {
                    var rr = er.memoizedProps, va = er.memoizedState, Gt = Oe.stateNode, Bt = Gt.getSnapshotBeforeUpdate(Oe.elementType === Oe.type ? rr : Cs(Oe.type, rr), va);
                    Gt.__reactInternalSnapshotBeforeUpdate = Bt;
                  }
                  break;
                case 3:
                  var Jt = Oe.stateNode.containerInfo;
                  Jt.nodeType === 1 ? Jt.textContent = "" : Jt.nodeType === 9 && Jt.documentElement && Jt.removeChild(Jt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(fe(163));
              }
          } catch (Nn) {
            la(Oe, Oe.return, Nn);
          }
          if (xe = Oe.sibling, xe !== null) {
            xe.return = Oe.return, Xn = xe;
            break;
          }
          Xn = Oe.return;
        }
    return er = Lb, Lb = !1, er;
  }
  function xf(xe, Oe, je) {
    var Fe = Oe.updateQueue;
    if (Fe = Fe !== null ? Fe.lastEffect : null, Fe !== null) {
      var Ge = Fe = Fe.next;
      do {
        if ((Ge.tag & xe) === xe) {
          var Qe = Ge.destroy;
          Ge.destroy = void 0, Qe !== void 0 && Bg(Oe, je, Qe);
        }
        Ge = Ge.next;
      } while (Ge !== Fe);
    }
  }
  function ty(xe, Oe) {
    if (Oe = Oe.updateQueue, Oe = Oe !== null ? Oe.lastEffect : null, Oe !== null) {
      var je = Oe = Oe.next;
      do {
        if ((je.tag & xe) === xe) {
          var Fe = je.create;
          je.destroy = Fe();
        }
        je = je.next;
      } while (je !== Oe);
    }
  }
  function ny(xe) {
    var Oe = xe.ref;
    if (Oe !== null) {
      var je = xe.stateNode;
      switch (xe.tag) {
        case 5:
          xe = je;
          break;
        default:
          xe = je;
      }
      typeof Oe == "function" ? Oe(xe) : Oe.current = xe;
    }
  }
  function Fg(xe) {
    var Oe = xe.alternate;
    Oe !== null && (xe.alternate = null, Fg(Oe)), xe.child = null, xe.deletions = null, xe.sibling = null, xe.tag === 5 && (Oe = xe.stateNode, Oe !== null && (delete Oe[zu], delete Oe[nd], delete Oe[fb], delete Oe[y_], delete Oe[pb])), xe.stateNode = null, xe.return = null, xe.dependencies = null, xe.memoizedProps = null, xe.memoizedState = null, xe.pendingProps = null, xe.stateNode = null, xe.updateQueue = null;
  }
  function ry(xe) {
    return xe.tag === 5 || xe.tag === 3 || xe.tag === 4;
  }
  function Rp(xe) {
    e:
      for (; ; ) {
        for (; xe.sibling === null; ) {
          if (xe.return === null || ry(xe.return))
            return null;
          xe = xe.return;
        }
        for (xe.sibling.return = xe.return, xe = xe.sibling; xe.tag !== 5 && xe.tag !== 6 && xe.tag !== 18; ) {
          if (xe.flags & 2 || xe.child === null || xe.tag === 4)
            continue e;
          xe.child.return = xe, xe = xe.child;
        }
        if (!(xe.flags & 2))
          return xe.stateNode;
      }
  }
  function Zu(xe, Oe, je) {
    var Fe = xe.tag;
    if (Fe === 5 || Fe === 6)
      xe = xe.stateNode, Oe ? je.nodeType === 8 ? je.parentNode.insertBefore(xe, Oe) : je.insertBefore(xe, Oe) : (je.nodeType === 8 ? (Oe = je.parentNode, Oe.insertBefore(xe, je)) : (Oe = je, Oe.appendChild(xe)), je = je._reactRootContainer, je != null || Oe.onclick !== null || (Oe.onclick = mm));
    else if (Fe !== 4 && (xe = xe.child, xe !== null))
      for (Zu(xe, Oe, je), xe = xe.sibling; xe !== null; )
        Zu(xe, Oe, je), xe = xe.sibling;
  }
  function qu(xe, Oe, je) {
    var Fe = xe.tag;
    if (Fe === 5 || Fe === 6)
      xe = xe.stateNode, Oe ? je.insertBefore(xe, Oe) : je.appendChild(xe);
    else if (Fe !== 4 && (xe = xe.child, xe !== null))
      for (qu(xe, Oe, je), xe = xe.sibling; xe !== null; )
        qu(xe, Oe, je), xe = xe.sibling;
  }
  var Yo = null, ji = !1;
  function Js(xe, Oe, je) {
    for (je = je.child; je !== null; )
      hl(xe, Oe, je), je = je.sibling;
  }
  function hl(xe, Oe, je) {
    if (Ci && typeof Ci.onCommitFiberUnmount == "function")
      try {
        Ci.onCommitFiberUnmount(gu, je);
      } catch {
      }
    switch (je.tag) {
      case 5:
        pi || hc(je, Oe);
      case 6:
        var Fe = Yo, Ge = ji;
        Yo = null, Js(xe, Oe, je), Yo = Fe, ji = Ge, Yo !== null && (ji ? (xe = Yo, je = je.stateNode, xe.nodeType === 8 ? xe.parentNode.removeChild(je) : xe.removeChild(je)) : Yo.removeChild(je.stateNode));
        break;
      case 18:
        Yo !== null && (ji ? (xe = Yo, je = je.stateNode, xe.nodeType === 8 ? Zl(xe.parentNode, je) : xe.nodeType === 1 && Zl(xe, je), nl(xe)) : Zl(Yo, je.stateNode));
        break;
      case 4:
        Fe = Yo, Ge = ji, Yo = je.stateNode.containerInfo, ji = !0, Js(xe, Oe, je), Yo = Fe, ji = Ge;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!pi && (Fe = je.updateQueue, Fe !== null && (Fe = Fe.lastEffect, Fe !== null))) {
          Ge = Fe = Fe.next;
          do {
            var Qe = Ge, dt = Qe.destroy;
            Qe = Qe.tag, dt !== void 0 && (Qe & 2 || Qe & 4) && Bg(je, Oe, dt), Ge = Ge.next;
          } while (Ge !== Fe);
        }
        Js(xe, Oe, je);
        break;
      case 1:
        if (!pi && (hc(je, Oe), Fe = je.stateNode, typeof Fe.componentWillUnmount == "function"))
          try {
            Fe.props = je.memoizedProps, Fe.state = je.memoizedState, Fe.componentWillUnmount();
          } catch (St) {
            la(je, Oe, St);
          }
        Js(xe, Oe, je);
        break;
      case 21:
        Js(xe, Oe, je);
        break;
      case 22:
        je.mode & 1 ? (pi = (Fe = pi) || je.memoizedState !== null, Js(xe, Oe, je), pi = Fe) : Js(xe, Oe, je);
        break;
      default:
        Js(xe, Oe, je);
    }
  }
  function zg(xe) {
    var Oe = xe.updateQueue;
    if (Oe !== null) {
      xe.updateQueue = null;
      var je = xe.stateNode;
      je === null && (je = xe.stateNode = new x_()), Oe.forEach(function(Fe) {
        var Ge = O_.bind(null, xe, Fe);
        je.has(Fe) || (je.add(Fe), Fe.then(Ge, Ge));
      });
    }
  }
  function hu(xe, Oe) {
    var je = Oe.deletions;
    if (je !== null)
      for (var Fe = 0; Fe < je.length; Fe++) {
        var Ge = je[Fe];
        try {
          var Qe = xe, dt = Oe, St = dt;
          e:
            for (; St !== null; ) {
              switch (St.tag) {
                case 5:
                  Yo = St.stateNode, ji = !1;
                  break e;
                case 3:
                  Yo = St.stateNode.containerInfo, ji = !0;
                  break e;
                case 4:
                  Yo = St.stateNode.containerInfo, ji = !0;
                  break e;
              }
              St = St.return;
            }
          if (Yo === null)
            throw Error(fe(160));
          hl(Qe, dt, Ge), Yo = null, ji = !1;
          var Rt = Ge.alternate;
          Rt !== null && (Rt.return = null), Ge.return = null;
        } catch (an) {
          la(Ge, Oe, an);
        }
      }
    if (Oe.subtreeFlags & 12854)
      for (Oe = Oe.child; Oe !== null; )
        Ug(Oe, xe), Oe = Oe.sibling;
  }
  function Ug(xe, Oe) {
    var je = xe.alternate, Fe = xe.flags;
    switch (xe.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (hu(Oe, xe), mu(xe), Fe & 4) {
          try {
            xf(3, xe, xe.return), ty(3, xe);
          } catch (rr) {
            la(xe, xe.return, rr);
          }
          try {
            xf(5, xe, xe.return);
          } catch (rr) {
            la(xe, xe.return, rr);
          }
        }
        break;
      case 1:
        hu(Oe, xe), mu(xe), Fe & 512 && je !== null && hc(je, je.return);
        break;
      case 5:
        if (hu(Oe, xe), mu(xe), Fe & 512 && je !== null && hc(je, je.return), xe.flags & 32) {
          var Ge = xe.stateNode;
          try {
            Vt(Ge, "");
          } catch (rr) {
            la(xe, xe.return, rr);
          }
        }
        if (Fe & 4 && (Ge = xe.stateNode, Ge != null)) {
          var Qe = xe.memoizedProps, dt = je !== null ? je.memoizedProps : Qe, St = xe.type, Rt = xe.updateQueue;
          if (xe.updateQueue = null, Rt !== null)
            try {
              St === "input" && Qe.type === "radio" && Qe.name != null && _o(Ge, Qe), jn(St, dt);
              var an = jn(St, Qe);
              for (dt = 0; dt < Rt.length; dt += 2) {
                var Pn = Rt[dt], In = Rt[dt + 1];
                Pn === "style" ? Bn(Ge, In) : Pn === "dangerouslySetInnerHTML" ? $t(Ge, In) : Pn === "children" ? Vt(Ge, In) : ot(Ge, Pn, In, an);
              }
              switch (St) {
                case "input":
                  ra(Ge, Qe);
                  break;
                case "textarea":
                  da(Ge, Qe);
                  break;
                case "select":
                  var kn = Ge._wrapperState.wasMultiple;
                  Ge._wrapperState.wasMultiple = !!Qe.multiple;
                  var qn = Qe.value;
                  qn != null ? No(Ge, !!Qe.multiple, qn, !1) : kn !== !!Qe.multiple && (Qe.defaultValue != null ? No(Ge, !!Qe.multiple, Qe.defaultValue, !0) : No(Ge, !!Qe.multiple, Qe.multiple ? [] : "", !1));
              }
              Ge[nd] = Qe;
            } catch (rr) {
              la(xe, xe.return, rr);
            }
        }
        break;
      case 6:
        if (hu(Oe, xe), mu(xe), Fe & 4) {
          if (xe.stateNode === null)
            throw Error(fe(162));
          Ge = xe.stateNode, Qe = xe.memoizedProps;
          try {
            Ge.nodeValue = Qe;
          } catch (rr) {
            la(xe, xe.return, rr);
          }
        }
        break;
      case 3:
        if (hu(Oe, xe), mu(xe), Fe & 4 && je !== null && je.memoizedState.isDehydrated)
          try {
            nl(Oe.containerInfo);
          } catch (rr) {
            la(xe, xe.return, rr);
          }
        break;
      case 4:
        hu(Oe, xe), mu(xe);
        break;
      case 13:
        hu(Oe, xe), mu(xe), Ge = xe.child, Ge.flags & 8192 && (Qe = Ge.memoizedState !== null, Ge.stateNode.isHidden = Qe, !Qe || Ge.alternate !== null && Ge.alternate.memoizedState !== null || (Bb = Xr())), Fe & 4 && zg(xe);
        break;
      case 22:
        if (Pn = je !== null && je.memoizedState !== null, xe.mode & 1 ? (pi = (an = pi) || Pn, hu(Oe, xe), pi = an) : hu(Oe, xe), mu(xe), Fe & 8192) {
          if (an = xe.memoizedState !== null, (xe.stateNode.isHidden = an) && !Pn && xe.mode & 1)
            for (Xn = xe, Pn = xe.child; Pn !== null; ) {
              for (In = Xn = Pn; Xn !== null; ) {
                switch (kn = Xn, qn = kn.child, kn.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    xf(4, kn, kn.return);
                    break;
                  case 1:
                    hc(kn, kn.return);
                    var er = kn.stateNode;
                    if (typeof er.componentWillUnmount == "function") {
                      Fe = kn, je = kn.return;
                      try {
                        Oe = Fe, er.props = Oe.memoizedProps, er.state = Oe.memoizedState, er.componentWillUnmount();
                      } catch (rr) {
                        la(Fe, je, rr);
                      }
                    }
                    break;
                  case 5:
                    hc(kn, kn.return);
                    break;
                  case 22:
                    if (kn.memoizedState !== null) {
                      Hg(In);
                      continue;
                    }
                }
                qn !== null ? (qn.return = kn, Xn = qn) : Hg(In);
              }
              Pn = Pn.sibling;
            }
          e:
            for (Pn = null, In = xe; ; ) {
              if (In.tag === 5) {
                if (Pn === null) {
                  Pn = In;
                  try {
                    Ge = In.stateNode, an ? (Qe = Ge.style, typeof Qe.setProperty == "function" ? Qe.setProperty("display", "none", "important") : Qe.display = "none") : (St = In.stateNode, Rt = In.memoizedProps.style, dt = Rt != null && Rt.hasOwnProperty("display") ? Rt.display : null, St.style.display = Mn("display", dt));
                  } catch (rr) {
                    la(xe, xe.return, rr);
                  }
                }
              } else if (In.tag === 6) {
                if (Pn === null)
                  try {
                    In.stateNode.nodeValue = an ? "" : In.memoizedProps;
                  } catch (rr) {
                    la(xe, xe.return, rr);
                  }
              } else if ((In.tag !== 22 && In.tag !== 23 || In.memoizedState === null || In === xe) && In.child !== null) {
                In.child.return = In, In = In.child;
                continue;
              }
              if (In === xe)
                break e;
              for (; In.sibling === null; ) {
                if (In.return === null || In.return === xe)
                  break e;
                Pn === In && (Pn = null), In = In.return;
              }
              Pn === In && (Pn = null), In.sibling.return = In.return, In = In.sibling;
            }
        }
        break;
      case 19:
        hu(Oe, xe), mu(xe), Fe & 4 && zg(xe);
        break;
      case 21:
        break;
      default:
        hu(Oe, xe), mu(xe);
    }
  }
  function mu(xe) {
    var Oe = xe.flags;
    if (Oe & 2) {
      try {
        e: {
          for (var je = xe.return; je !== null; ) {
            if (ry(je)) {
              var Fe = je;
              break e;
            }
            je = je.return;
          }
          throw Error(fe(160));
        }
        switch (Fe.tag) {
          case 5:
            var Ge = Fe.stateNode;
            Fe.flags & 32 && (Vt(Ge, ""), Fe.flags &= -33);
            var Qe = Rp(xe);
            qu(xe, Qe, Ge);
            break;
          case 3:
          case 4:
            var dt = Fe.stateNode.containerInfo, St = Rp(xe);
            Zu(xe, St, dt);
            break;
          default:
            throw Error(fe(161));
        }
      } catch (Rt) {
        la(xe, xe.return, Rt);
      }
      xe.flags &= -3;
    }
    Oe & 4096 && (xe.flags &= -4097);
  }
  function Np(xe, Oe, je) {
    Xn = xe, Vg(xe);
  }
  function Vg(xe, Oe, je) {
    for (var Fe = (xe.mode & 1) !== 0; Xn !== null; ) {
      var Ge = Xn, Qe = Ge.child;
      if (Ge.tag === 22 && Fe) {
        var dt = Ge.memoizedState !== null || Pd;
        if (!dt) {
          var St = Ge.alternate, Rt = St !== null && St.memoizedState !== null || pi;
          St = Pd;
          var an = pi;
          if (Pd = dt, (pi = Rt) && !an)
            for (Xn = Ge; Xn !== null; )
              dt = Xn, Rt = dt.child, dt.tag === 22 && dt.memoizedState !== null ? Mp(Ge) : Rt !== null ? (Rt.return = dt, Xn = Rt) : Mp(Ge);
          for (; Qe !== null; )
            Xn = Qe, Vg(Qe), Qe = Qe.sibling;
          Xn = Ge, Pd = St, pi = an;
        }
        Db(xe);
      } else
        Ge.subtreeFlags & 8772 && Qe !== null ? (Qe.return = Ge, Xn = Qe) : Db(xe);
    }
  }
  function Db(xe) {
    for (; Xn !== null; ) {
      var Oe = Xn;
      if (Oe.flags & 8772) {
        var je = Oe.alternate;
        try {
          if (Oe.flags & 8772)
            switch (Oe.tag) {
              case 0:
              case 11:
              case 15:
                pi || ty(5, Oe);
                break;
              case 1:
                var Fe = Oe.stateNode;
                if (Oe.flags & 4 && !pi)
                  if (je === null)
                    Fe.componentDidMount();
                  else {
                    var Ge = Oe.elementType === Oe.type ? je.memoizedProps : Cs(Oe.type, je.memoizedProps);
                    Fe.componentDidUpdate(Ge, je.memoizedState, Fe.__reactInternalSnapshotBeforeUpdate);
                  }
                var Qe = Oe.updateQueue;
                Qe !== null && od(Oe, Qe, Fe);
                break;
              case 3:
                var dt = Oe.updateQueue;
                if (dt !== null) {
                  if (je = null, Oe.child !== null)
                    switch (Oe.child.tag) {
                      case 5:
                        je = Oe.child.stateNode;
                        break;
                      case 1:
                        je = Oe.child.stateNode;
                    }
                  od(Oe, dt, je);
                }
                break;
              case 5:
                var St = Oe.stateNode;
                if (je === null && Oe.flags & 4) {
                  je = St;
                  var Rt = Oe.memoizedProps;
                  switch (Oe.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Rt.autoFocus && je.focus();
                      break;
                    case "img":
                      Rt.src && (je.src = Rt.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Oe.memoizedState === null) {
                  var an = Oe.alternate;
                  if (an !== null) {
                    var Pn = an.memoizedState;
                    if (Pn !== null) {
                      var In = Pn.dehydrated;
                      In !== null && nl(In);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(fe(163));
            }
          pi || Oe.flags & 512 && ny(Oe);
        } catch (kn) {
          la(Oe, Oe.return, kn);
        }
      }
      if (Oe === xe) {
        Xn = null;
        break;
      }
      if (je = Oe.sibling, je !== null) {
        je.return = Oe.return, Xn = je;
        break;
      }
      Xn = Oe.return;
    }
  }
  function Hg(xe) {
    for (; Xn !== null; ) {
      var Oe = Xn;
      if (Oe === xe) {
        Xn = null;
        break;
      }
      var je = Oe.sibling;
      if (je !== null) {
        je.return = Oe.return, Xn = je;
        break;
      }
      Xn = Oe.return;
    }
  }
  function Mp(xe) {
    for (; Xn !== null; ) {
      var Oe = Xn;
      try {
        switch (Oe.tag) {
          case 0:
          case 11:
          case 15:
            var je = Oe.return;
            try {
              ty(4, Oe);
            } catch (Rt) {
              la(Oe, je, Rt);
            }
            break;
          case 1:
            var Fe = Oe.stateNode;
            if (typeof Fe.componentDidMount == "function") {
              var Ge = Oe.return;
              try {
                Fe.componentDidMount();
              } catch (Rt) {
                la(Oe, Ge, Rt);
              }
            }
            var Qe = Oe.return;
            try {
              ny(Oe);
            } catch (Rt) {
              la(Oe, Qe, Rt);
            }
            break;
          case 5:
            var dt = Oe.return;
            try {
              ny(Oe);
            } catch (Rt) {
              la(Oe, dt, Rt);
            }
        }
      } catch (Rt) {
        la(Oe, Oe.return, Rt);
      }
      if (Oe === xe) {
        Xn = null;
        break;
      }
      var St = Oe.sibling;
      if (St !== null) {
        St.return = Oe.return, Xn = St;
        break;
      }
      Xn = Oe.return;
    }
  }
  var Zg = Math.ceil, oy = pt.ReactCurrentDispatcher, Td = pt.ReactCurrentOwner, Ri = pt.ReactCurrentBatchConfig, Hr = 0, Ta = null, pa = null, hi = 0, Rs = 0, Ef = Br(0), Na = 0, Od = null, Ad = 0, Cd = 0, jp = 0, Sf = null, hs = null, Bb = 0, Pf = 1 / 0, ml = null, mc = !1, Lp = null, eu = null, ay = !1, yc = null, Dp = 0, kf = 0, Tf = null, Id = -1, Bp = 0;
  function Io() {
    return Hr & 6 ? Xr() : Id !== -1 ? Id : Id = Xr();
  }
  function Ns(xe) {
    return xe.mode & 1 ? Hr & 2 && hi !== 0 ? hi & -hi : _m.transition !== null ? (Bp === 0 && (Bp = tl()), Bp) : (xe = so, xe !== 0 || (xe = window.event, xe = xe === void 0 ? 16 : Qc(xe.type)), xe) : 1;
  }
  function Ms(xe, Oe, je, Fe) {
    if (50 < kf)
      throw kf = 0, Tf = null, Error(fe(185));
    uu(xe, je, Fe), (!(Hr & 2) || xe !== Ta) && (xe === Ta && (!(Hr & 2) && (Cd |= je), Na === 4 && bc(xe, hi)), Va(xe, Fe), je === 1 && Hr === 0 && !(Oe.mode & 1) && (Pf = Xr() + 500, za && rs()));
  }
  function Va(xe, Oe) {
    var je = xe.callbackNode;
    su(xe, Oe);
    var Fe = Ba(xe, xe === Ta ? hi : 0);
    if (Fe === 0)
      je !== null && Ca(je), xe.callbackNode = null, xe.callbackPriority = 0;
    else if (Oe = Fe & -Fe, xe.callbackPriority !== Oe) {
      if (je != null && Ca(je), Oe === 1)
        xe.tag === 0 ? mb(Hp.bind(null, xe)) : hb(Hp.bind(null, xe)), db(function() {
          !(Hr & 6) && rs();
        }), je = null;
      else {
        switch (Su(Fe)) {
          case 1:
            je = _s;
            break;
          case 4:
            je = zr;
            break;
          case 16:
            je = Pi;
            break;
          case 536870912:
            je = Al;
            break;
          default:
            je = Pi;
        }
        je = Kg(je, qg.bind(null, xe));
      }
      xe.callbackPriority = Oe, xe.callbackNode = je;
    }
  }
  function qg(xe, Oe) {
    if (Id = -1, Bp = 0, Hr & 6)
      throw Error(fe(327));
    var je = xe.callbackNode;
    if (Of() && xe.callbackNode !== je)
      return null;
    var Fe = Ba(xe, xe === Ta ? hi : 0);
    if (Fe === 0)
      return null;
    if (Fe & 30 || Fe & xe.expiredLanes || Oe)
      Oe = uy(xe, Fe);
    else {
      Oe = Fe;
      var Ge = Hr;
      Hr |= 2;
      var Qe = Wg();
      (Ta !== xe || hi !== Oe) && (ml = null, Pf = Xr() + 500, Rd(xe, Oe));
      do
        try {
          P_();
          break;
        } catch (St) {
          sy(xe, St);
        }
      while (1);
      _b(), oy.current = Qe, Hr = Ge, pa !== null ? Oe = 0 : (Ta = null, hi = 0, Oe = Na);
    }
    if (Oe !== 0) {
      if (Oe === 2 && (Ge = Hc(xe), Ge !== 0 && (Fe = Ge, Oe = zp(xe, Ge))), Oe === 1)
        throw je = Od, Rd(xe, 0), bc(xe, Fe), Va(xe, Xr()), je;
      if (Oe === 6)
        bc(xe, Fe);
      else {
        if (Ge = xe.current.alternate, !(Fe & 30) && !Vp(Ge) && (Oe = uy(xe, Fe), Oe === 2 && (Qe = Hc(xe), Qe !== 0 && (Fe = Qe, Oe = zp(xe, Qe))), Oe === 1))
          throw je = Od, Rd(xe, 0), bc(xe, Fe), Va(xe, Xr()), je;
        switch (xe.finishedWork = Ge, xe.finishedLanes = Fe, Oe) {
          case 0:
          case 1:
            throw Error(fe(345));
          case 2:
            Nd(xe, hs, ml);
            break;
          case 3:
            if (bc(xe, Fe), (Fe & 130023424) === Fe && (Oe = Bb + 500 - Xr(), 10 < Oe)) {
              if (Ba(xe, 0) !== 0)
                break;
              if (Ge = xe.suspendedLanes, (Ge & Fe) !== Fe) {
                Io(), xe.pingedLanes |= xe.suspendedLanes & Ge;
                break;
              }
              xe.timeoutHandle = td(Nd.bind(null, xe, hs, ml), Oe);
              break;
            }
            Nd(xe, hs, ml);
            break;
          case 4:
            if (bc(xe, Fe), (Fe & 4194240) === Fe)
              break;
            for (Oe = xe.eventTimes, Ge = -1; 0 < Fe; ) {
              var dt = 31 - ri(Fe);
              Qe = 1 << dt, dt = Oe[dt], dt > Ge && (Ge = dt), Fe &= ~Qe;
            }
            if (Fe = Ge, Fe = Xr() - Fe, Fe = (120 > Fe ? 120 : 480 > Fe ? 480 : 1080 > Fe ? 1080 : 1920 > Fe ? 1920 : 3e3 > Fe ? 3e3 : 4320 > Fe ? 4320 : 1960 * Zg(Fe / 1960)) - Fe, 10 < Fe) {
              xe.timeoutHandle = td(Nd.bind(null, xe, hs, ml), Fe);
              break;
            }
            Nd(xe, hs, ml);
            break;
          case 5:
            Nd(xe, hs, ml);
            break;
          default:
            throw Error(fe(329));
        }
      }
    }
    return Va(xe, Xr()), xe.callbackNode === je ? qg.bind(null, xe) : null;
  }
  function zp(xe, Oe) {
    var je = Sf;
    return xe.current.memoizedState.isDehydrated && (Rd(xe, Oe).flags |= 256), xe = uy(xe, Oe), xe !== 2 && (Oe = hs, hs = je, Oe !== null && Up(Oe)), xe;
  }
  function Up(xe) {
    hs === null ? hs = xe : hs.push.apply(hs, xe);
  }
  function Vp(xe) {
    for (var Oe = xe; ; ) {
      if (Oe.flags & 16384) {
        var je = Oe.updateQueue;
        if (je !== null && (je = je.stores, je !== null))
          for (var Fe = 0; Fe < je.length; Fe++) {
            var Ge = je[Fe], Qe = Ge.getSnapshot;
            Ge = Ge.value;
            try {
              if (!Hs(Qe(), Ge))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (je = Oe.child, Oe.subtreeFlags & 16384 && je !== null)
        je.return = Oe, Oe = je;
      else {
        if (Oe === xe)
          break;
        for (; Oe.sibling === null; ) {
          if (Oe.return === null || Oe.return === xe)
            return !0;
          Oe = Oe.return;
        }
        Oe.sibling.return = Oe.return, Oe = Oe.sibling;
      }
    }
    return !0;
  }
  function bc(xe, Oe) {
    for (Oe &= ~jp, Oe &= ~Cd, xe.suspendedLanes |= Oe, xe.pingedLanes &= ~Oe, xe = xe.expirationTimes; 0 < Oe; ) {
      var je = 31 - ri(Oe), Fe = 1 << je;
      xe[je] = -1, Oe &= ~Fe;
    }
  }
  function Hp(xe) {
    if (Hr & 6)
      throw Error(fe(327));
    Of();
    var Oe = Ba(xe, 0);
    if (!(Oe & 1))
      return Va(xe, Xr()), null;
    var je = uy(xe, Oe);
    if (xe.tag !== 0 && je === 2) {
      var Fe = Hc(xe);
      Fe !== 0 && (Oe = Fe, je = zp(xe, Fe));
    }
    if (je === 1)
      throw je = Od, Rd(xe, 0), bc(xe, Oe), Va(xe, Xr()), je;
    if (je === 6)
      throw Error(fe(345));
    return xe.finishedWork = xe.current.alternate, xe.finishedLanes = Oe, Nd(xe, hs, ml), Va(xe, Xr()), null;
  }
  function iy(xe, Oe) {
    var je = Hr;
    Hr |= 1;
    try {
      return xe(Oe);
    } finally {
      Hr = je, Hr === 0 && (Pf = Xr() + 500, za && rs());
    }
  }
  function $d(xe) {
    yc !== null && yc.tag === 0 && !(Hr & 6) && Of();
    var Oe = Hr;
    Hr |= 1;
    var je = Ri.transition, Fe = so;
    try {
      if (Ri.transition = null, so = 1, xe)
        return xe();
    } finally {
      so = Fe, Ri.transition = je, Hr = Oe, !(Hr & 6) && rs();
    }
  }
  function Fb() {
    Rs = Ef.current, yo(Ef);
  }
  function Rd(xe, Oe) {
    xe.finishedWork = null, xe.finishedLanes = 0;
    var je = xe.timeoutHandle;
    if (je !== -1 && (xe.timeoutHandle = -1, gg(je)), pa !== null)
      for (je = pa.return; je !== null; ) {
        var Fe = je;
        switch (bb(Fe), Fe.tag) {
          case 1:
            Fe = Fe.type.childContextTypes, Fe != null && Ws();
            break;
          case 3:
            ic(), yo(ua), yo(Cr), Tm();
            break;
          case 5:
            Vr(Fe);
            break;
          case 4:
            ic();
            break;
          case 13:
            yo(xr);
            break;
          case 19:
            yo(xr);
            break;
          case 10:
            tc(Fe.type._context);
            break;
          case 22:
          case 23:
            Fb();
        }
        je = je.return;
      }
    if (Ta = xe, pa = xe = vc(xe.current, null), hi = Rs = Oe, Na = 0, Od = null, jp = Cd = Ad = 0, hs = Sf = null, di !== null) {
      for (Oe = 0; Oe < di.length; Oe++)
        if (je = di[Oe], Fe = je.interleaved, Fe !== null) {
          je.interleaved = null;
          var Ge = Fe.next, Qe = je.pending;
          if (Qe !== null) {
            var dt = Qe.next;
            Qe.next = Ge, Fe.next = dt;
          }
          je.pending = Fe;
        }
      di = null;
    }
    return xe;
  }
  function sy(xe, Oe) {
    do {
      var je = pa;
      try {
        if (_b(), Om.current = Hm, kr) {
          for (var Fe = Fo.memoizedState; Fe !== null; ) {
            var Ge = Fe.queue;
            Ge !== null && (Ge.pending = null), Fe = Fe.next;
          }
          kr = !1;
        }
        if (id = 0, oo = vn = Fo = null, Hu = !1, Is = 0, Td.current = null, je === null || je.return === null) {
          Na = 1, Od = Oe, pa = null;
          break;
        }
        e: {
          var Qe = xe, dt = je.return, St = je, Rt = Oe;
          if (Oe = hi, St.flags |= 32768, Rt !== null && typeof Rt == "object" && typeof Rt.then == "function") {
            var an = Rt, Pn = St, In = Pn.tag;
            if (!(Pn.mode & 1) && (In === 0 || In === 11 || In === 15)) {
              var kn = Pn.alternate;
              kn ? (Pn.updateQueue = kn.updateQueue, Pn.memoizedState = kn.memoizedState, Pn.lanes = kn.lanes) : (Pn.updateQueue = null, Pn.memoizedState = null);
            }
            var qn = Cb(dt);
            if (qn !== null) {
              qn.flags &= -257, Ib(qn, dt, St, Qe, Oe), qn.mode & 1 && Ng(Qe, an, Oe), Oe = qn, Rt = an;
              var er = Oe.updateQueue;
              if (er === null) {
                var rr = /* @__PURE__ */ new Set();
                rr.add(Rt), Oe.updateQueue = rr;
              } else
                er.add(Rt);
              break e;
            } else {
              if (!(Oe & 1)) {
                Ng(Qe, an, Oe), zb();
                break e;
              }
              Rt = Error(fe(426));
            }
          } else if (Bo && St.mode & 1) {
            var va = Cb(dt);
            if (va !== null) {
              !(va.flags & 65536) && (va.flags |= 256), Ib(va, dt, St, Qe, Oe), gb(vf(Rt, St));
              break e;
            }
          }
          Qe = Rt = vf(Rt, St), Na !== 4 && (Na = 2), Sf === null ? Sf = [Qe] : Sf.push(Qe), Qe = dt;
          do {
            switch (Qe.tag) {
              case 3:
                Qe.flags |= 65536, Oe &= -Oe, Qe.lanes |= Oe;
                var Gt = Rg(Qe, Rt, Oe);
                Sb(Qe, Gt);
                break e;
              case 1:
                St = Rt;
                var Bt = Qe.type, Jt = Qe.stateNode;
                if (!(Qe.flags & 128) && (typeof Bt.getDerivedStateFromError == "function" || Jt !== null && typeof Jt.componentDidCatch == "function" && (eu === null || !eu.has(Jt)))) {
                  Qe.flags |= 65536, Oe &= -Oe, Qe.lanes |= Oe;
                  var Nn = Cp(Qe, St, Oe);
                  Sb(Qe, Nn);
                  break e;
                }
            }
            Qe = Qe.return;
          } while (Qe !== null);
        }
        Gg(je);
      } catch (Zn) {
        Oe = Zn, pa === je && je !== null && (pa = je = je.return);
        continue;
      }
      break;
    } while (1);
  }
  function Wg() {
    var xe = oy.current;
    return oy.current = Hm, xe === null ? Hm : xe;
  }
  function zb() {
    (Na === 0 || Na === 3 || Na === 2) && (Na = 4), Ta === null || !(Ad & 268435455) && !(Cd & 268435455) || bc(Ta, hi);
  }
  function uy(xe, Oe) {
    var je = Hr;
    Hr |= 2;
    var Fe = Wg();
    (Ta !== xe || hi !== Oe) && (ml = null, Rd(xe, Oe));
    do
      try {
        S_();
        break;
      } catch (Ge) {
        sy(xe, Ge);
      }
    while (1);
    if (_b(), Hr = je, oy.current = Fe, pa !== null)
      throw Error(fe(261));
    return Ta = null, hi = 0, Na;
  }
  function S_() {
    for (; pa !== null; )
      Ub(pa);
  }
  function P_() {
    for (; pa !== null && !zs(); )
      Ub(pa);
  }
  function Ub(xe) {
    var Oe = Hb(xe.alternate, xe, Rs);
    xe.memoizedProps = xe.pendingProps, Oe === null ? Gg(xe) : pa = Oe, Td.current = null;
  }
  function Gg(xe) {
    var Oe = xe;
    do {
      var je = Oe.alternate;
      if (xe = Oe.return, Oe.flags & 32768) {
        if (je = Dg(je, Oe), je !== null) {
          je.flags &= 32767, pa = je;
          return;
        }
        if (xe !== null)
          xe.flags |= 32768, xe.subtreeFlags = 0, xe.deletions = null;
        else {
          Na = 6, pa = null;
          return;
        }
      } else if (je = jb(je, Oe, Rs), je !== null) {
        pa = je;
        return;
      }
      if (Oe = Oe.sibling, Oe !== null) {
        pa = Oe;
        return;
      }
      pa = Oe = xe;
    } while (Oe !== null);
    Na === 0 && (Na = 5);
  }
  function Nd(xe, Oe, je) {
    var Fe = so, Ge = Ri.transition;
    try {
      Ri.transition = null, so = 1, k_(xe, Oe, je, Fe);
    } finally {
      Ri.transition = Ge, so = Fe;
    }
    return null;
  }
  function k_(xe, Oe, je, Fe) {
    do
      Of();
    while (yc !== null);
    if (Hr & 6)
      throw Error(fe(327));
    je = xe.finishedWork;
    var Ge = xe.finishedLanes;
    if (je === null)
      return null;
    if (xe.finishedWork = null, xe.finishedLanes = 0, je === xe.current)
      throw Error(fe(177));
    xe.callbackNode = null, xe.callbackPriority = 0;
    var Qe = je.lanes | je.childLanes;
    if (Rl(xe, Qe), xe === Ta && (pa = Ta = null, hi = 0), !(je.subtreeFlags & 2064) && !(je.flags & 2064) || ay || (ay = !0, Kg(Pi, function() {
      return Of(), null;
    })), Qe = (je.flags & 15990) !== 0, je.subtreeFlags & 15990 || Qe) {
      Qe = Ri.transition, Ri.transition = null;
      var dt = so;
      so = 1;
      var St = Hr;
      Hr |= 4, Td.current = null, E_(xe, je), Ug(je, xe), cm(ed), ks = !!lb, ed = lb = null, xe.current = je, Np(je), Ol(), Hr = St, so = dt, Ri.transition = Qe;
    } else
      xe.current = je;
    if (ay && (ay = !1, yc = xe, Dp = Ge), Qe = xe.pendingLanes, Qe === 0 && (eu = null), zc(je.stateNode), Va(xe, Xr()), Oe !== null)
      for (Fe = xe.onRecoverableError, je = 0; je < Oe.length; je++)
        Ge = Oe[je], Fe(Ge.value, { componentStack: Ge.stack, digest: Ge.digest });
    if (mc)
      throw mc = !1, xe = Lp, Lp = null, xe;
    return Dp & 1 && xe.tag !== 0 && Of(), Qe = xe.pendingLanes, Qe & 1 ? xe === Tf ? kf++ : (kf = 0, Tf = xe) : kf = 0, rs(), null;
  }
  function Of() {
    if (yc !== null) {
      var xe = Su(Dp), Oe = Ri.transition, je = so;
      try {
        if (Ri.transition = null, so = 16 > xe ? 16 : xe, yc === null)
          var Fe = !1;
        else {
          if (xe = yc, yc = null, Dp = 0, Hr & 6)
            throw Error(fe(331));
          var Ge = Hr;
          for (Hr |= 4, Xn = xe.current; Xn !== null; ) {
            var Qe = Xn, dt = Qe.child;
            if (Xn.flags & 16) {
              var St = Qe.deletions;
              if (St !== null) {
                for (var Rt = 0; Rt < St.length; Rt++) {
                  var an = St[Rt];
                  for (Xn = an; Xn !== null; ) {
                    var Pn = Xn;
                    switch (Pn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        xf(8, Pn, Qe);
                    }
                    var In = Pn.child;
                    if (In !== null)
                      In.return = Pn, Xn = In;
                    else
                      for (; Xn !== null; ) {
                        Pn = Xn;
                        var kn = Pn.sibling, qn = Pn.return;
                        if (Fg(Pn), Pn === an) {
                          Xn = null;
                          break;
                        }
                        if (kn !== null) {
                          kn.return = qn, Xn = kn;
                          break;
                        }
                        Xn = qn;
                      }
                  }
                }
                var er = Qe.alternate;
                if (er !== null) {
                  var rr = er.child;
                  if (rr !== null) {
                    er.child = null;
                    do {
                      var va = rr.sibling;
                      rr.sibling = null, rr = va;
                    } while (rr !== null);
                  }
                }
                Xn = Qe;
              }
            }
            if (Qe.subtreeFlags & 2064 && dt !== null)
              dt.return = Qe, Xn = dt;
            else
              e:
                for (; Xn !== null; ) {
                  if (Qe = Xn, Qe.flags & 2048)
                    switch (Qe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        xf(9, Qe, Qe.return);
                    }
                  var Gt = Qe.sibling;
                  if (Gt !== null) {
                    Gt.return = Qe.return, Xn = Gt;
                    break e;
                  }
                  Xn = Qe.return;
                }
          }
          var Bt = xe.current;
          for (Xn = Bt; Xn !== null; ) {
            dt = Xn;
            var Jt = dt.child;
            if (dt.subtreeFlags & 2064 && Jt !== null)
              Jt.return = dt, Xn = Jt;
            else
              e:
                for (dt = Bt; Xn !== null; ) {
                  if (St = Xn, St.flags & 2048)
                    try {
                      switch (St.tag) {
                        case 0:
                        case 11:
                        case 15:
                          ty(9, St);
                      }
                    } catch (Zn) {
                      la(St, St.return, Zn);
                    }
                  if (St === dt) {
                    Xn = null;
                    break e;
                  }
                  var Nn = St.sibling;
                  if (Nn !== null) {
                    Nn.return = St.return, Xn = Nn;
                    break e;
                  }
                  Xn = St.return;
                }
          }
          if (Hr = Ge, rs(), Ci && typeof Ci.onPostCommitFiberRoot == "function")
            try {
              Ci.onPostCommitFiberRoot(gu, xe);
            } catch {
            }
          Fe = !0;
        }
        return Fe;
      } finally {
        so = je, Ri.transition = Oe;
      }
    }
    return !1;
  }
  function Yg(xe, Oe, je) {
    Oe = vf(je, Oe), Oe = Rg(xe, Oe, 1), xe = rc(xe, Oe, 1), Oe = Io(), xe !== null && (uu(xe, 1, Oe), Va(xe, Oe));
  }
  function la(xe, Oe, je) {
    if (xe.tag === 3)
      Yg(xe, xe, je);
    else
      for (; Oe !== null; ) {
        if (Oe.tag === 3) {
          Yg(Oe, xe, je);
          break;
        } else if (Oe.tag === 1) {
          var Fe = Oe.stateNode;
          if (typeof Oe.type.getDerivedStateFromError == "function" || typeof Fe.componentDidCatch == "function" && (eu === null || !eu.has(Fe))) {
            xe = vf(je, xe), xe = Cp(Oe, xe, 1), Oe = rc(Oe, xe, 1), xe = Io(), Oe !== null && (uu(Oe, 1, xe), Va(Oe, xe));
            break;
          }
        }
        Oe = Oe.return;
      }
  }
  function Vb(xe, Oe, je) {
    var Fe = xe.pingCache;
    Fe !== null && Fe.delete(Oe), Oe = Io(), xe.pingedLanes |= xe.suspendedLanes & je, Ta === xe && (hi & je) === je && (Na === 4 || Na === 3 && (hi & 130023424) === hi && 500 > Xr() - Bb ? Rd(xe, 0) : jp |= je), Va(xe, Oe);
  }
  function Qg(xe, Oe) {
    Oe === 0 && (xe.mode & 1 ? (Oe = Us, Us <<= 1, !(Us & 130023424) && (Us = 4194304)) : Oe = 1);
    var je = Io();
    xe = dl(xe, Oe), xe !== null && (uu(xe, Oe, je), Va(xe, je));
  }
  function T_(xe) {
    var Oe = xe.memoizedState, je = 0;
    Oe !== null && (je = Oe.retryLane), Qg(xe, je);
  }
  function O_(xe, Oe) {
    var je = 0;
    switch (xe.tag) {
      case 13:
        var Fe = xe.stateNode, Ge = xe.memoizedState;
        Ge !== null && (je = Ge.retryLane);
        break;
      case 19:
        Fe = xe.stateNode;
        break;
      default:
        throw Error(fe(314));
    }
    Fe !== null && Fe.delete(Oe), Qg(xe, je);
  }
  var Hb;
  Hb = function(xe, Oe, je) {
    if (xe !== null)
      if (xe.memoizedProps !== Oe.pendingProps || ua.current)
        ka = !0;
      else {
        if (!(xe.lanes & je) && !(Oe.flags & 128))
          return ka = !1, ey(xe, Oe, je);
        ka = !!(xe.flags & 131072);
      }
    else
      ka = !1, Bo && Oe.flags & 1048576 && yb(Oe, df, Oe.index);
    switch (Oe.lanes = 0, Oe.tag) {
      case 2:
        var Fe = Oe.type;
        Xs(xe, Oe), xe = Oe.pendingProps;
        var Ge = qs(Oe, Cr.current);
        Ln(Oe, je), Ge = dc(null, Oe, Fe, xe, Ge, je);
        var Qe = bd();
        return Oe.flags |= 1, typeof Ge == "object" && Ge !== null && typeof Ge.render == "function" && Ge.$$typeof === void 0 ? (Oe.tag = 1, Oe.memoizedState = null, Oe.updateQueue = null, Go(Fe) ? (Qe = !0, ym(Oe)) : Qe = !1, Oe.memoizedState = Ge.state !== null && Ge.state !== void 0 ? Ge.state : null, Eb(Oe), Ge.updater = Sm, Oe.stateNode = Ge, Ge._reactInternals = Oe, Pm(Oe, Fe, xe, je), Oe = Rb(null, Oe, Fe, !0, Qe, je)) : (Oe.tag = 0, Bo && Qe && bm(Oe), $a(null, Oe, Ge, je), Oe = Oe.child), Oe;
      case 16:
        Fe = Oe.elementType;
        e: {
          switch (Xs(xe, Oe), xe = Oe.pendingProps, Ge = Fe._init, Fe = Ge(Fe._payload), Oe.type = Fe, Ge = Oe.tag = C_(Fe), xe = Cs(Fe, xe), Ge) {
            case 0:
              Oe = gf(null, Oe, Fe, xe, je);
              break e;
            case 1:
              Oe = $b(null, Oe, Fe, xe, je);
              break e;
            case 11:
              Oe = pc(null, Oe, Fe, xe, je);
              break e;
            case 14:
              Oe = Wm(null, Oe, Fe, Cs(Fe.type, xe), je);
              break e;
          }
          throw Error(fe(306, Fe, ""));
        }
        return Oe;
      case 0:
        return Fe = Oe.type, Ge = Oe.pendingProps, Ge = Oe.elementType === Fe ? Ge : Cs(Fe, Ge), gf(xe, Oe, Fe, Ge, je);
      case 1:
        return Fe = Oe.type, Ge = Oe.pendingProps, Ge = Oe.elementType === Fe ? Ge : Cs(Fe, Ge), $b(xe, Oe, Fe, Ge, je);
      case 3:
        e: {
          if (Gm(Oe), xe === null)
            throw Error(fe(387));
          Fe = Oe.pendingProps, Qe = Oe.memoizedState, Ge = Qe.element, Ia(xe, Oe), ac(Oe, Fe, null, je);
          var dt = Oe.memoizedState;
          if (Fe = dt.element, Qe.isDehydrated)
            if (Qe = { element: Fe, isDehydrated: !1, cache: dt.cache, pendingSuspenseBoundaries: dt.pendingSuspenseBoundaries, transitions: dt.transitions }, Oe.updateQueue.baseState = Qe, Oe.memoizedState = Qe, Oe.flags & 256) {
              Ge = vf(Error(fe(423)), Oe), Oe = wf(xe, Oe, Fe, je, Ge);
              break e;
            } else if (Fe !== Ge) {
              Ge = vf(Error(fe(424)), Oe), Oe = wf(xe, Oe, Fe, je, Ge);
              break e;
            } else
              for (is = fu(Oe.stateNode.containerInfo.firstChild), As = Oe, Bo = !0, Ys = null, je = Ig(Oe, null, Fe, je), Oe.child = je; je; )
                je.flags = je.flags & -3 | 4096, je = je.sibling;
          else {
            if (ea(), Fe === Ge) {
              Oe = fi(xe, Oe, je);
              break e;
            }
            $a(xe, Oe, Fe, je);
          }
          Oe = Oe.child;
        }
        return Oe;
      case 5:
        return vr(Oe), xe === null && gm(Oe), Fe = Oe.type, Ge = Oe.pendingProps, Qe = xe !== null ? xe.memoizedProps : null, dt = Ge.children, yp(Fe, Ge) ? dt = null : Qe !== null && yp(Fe, Qe) && (Oe.flags |= 32), Fr(xe, Oe), $a(xe, Oe, dt, je), Oe.child;
      case 6:
        return xe === null && gm(Oe), null;
      case 13:
        return Mg(xe, Oe, je);
      case 4:
        return kb(Oe, Oe.stateNode.containerInfo), Fe = Oe.pendingProps, xe === null ? Oe.child = pf(Oe, null, Fe, je) : $a(xe, Oe, Fe, je), Oe.child;
      case 11:
        return Fe = Oe.type, Ge = Oe.pendingProps, Ge = Oe.elementType === Fe ? Ge : Cs(Fe, Ge), pc(xe, Oe, Fe, Ge, je);
      case 7:
        return $a(xe, Oe, Oe.pendingProps, je), Oe.child;
      case 8:
        return $a(xe, Oe, Oe.pendingProps.children, je), Oe.child;
      case 12:
        return $a(xe, Oe, Oe.pendingProps.children, je), Oe.child;
      case 10:
        e: {
          if (Fe = Oe.type._context, Ge = Oe.pendingProps, Qe = Oe.memoizedProps, dt = Ge.value, go(Vu, Fe._currentValue), Fe._currentValue = dt, Qe !== null)
            if (Hs(Qe.value, dt)) {
              if (Qe.children === Ge.children && !ua.current) {
                Oe = fi(xe, Oe, je);
                break e;
              }
            } else
              for (Qe = Oe.child, Qe !== null && (Qe.return = Oe); Qe !== null; ) {
                var St = Qe.dependencies;
                if (St !== null) {
                  dt = Qe.child;
                  for (var Rt = St.firstContext; Rt !== null; ) {
                    if (Rt.context === Fe) {
                      if (Qe.tag === 1) {
                        Rt = fl(-1, je & -je), Rt.tag = 2;
                        var an = Qe.updateQueue;
                        if (an !== null) {
                          an = an.shared;
                          var Pn = an.pending;
                          Pn === null ? Rt.next = Rt : (Rt.next = Pn.next, Pn.next = Rt), an.pending = Rt;
                        }
                      }
                      Qe.lanes |= je, Rt = Qe.alternate, Rt !== null && (Rt.lanes |= je), Ua(Qe.return, je, Oe), St.lanes |= je;
                      break;
                    }
                    Rt = Rt.next;
                  }
                } else if (Qe.tag === 10)
                  dt = Qe.type === Oe.type ? null : Qe.child;
                else if (Qe.tag === 18) {
                  if (dt = Qe.return, dt === null)
                    throw Error(fe(341));
                  dt.lanes |= je, St = dt.alternate, St !== null && (St.lanes |= je), Ua(dt, je, Oe), dt = Qe.sibling;
                } else
                  dt = Qe.child;
                if (dt !== null)
                  dt.return = Qe;
                else
                  for (dt = Qe; dt !== null; ) {
                    if (dt === Oe) {
                      dt = null;
                      break;
                    }
                    if (Qe = dt.sibling, Qe !== null) {
                      Qe.return = dt.return, dt = Qe;
                      break;
                    }
                    dt = dt.return;
                  }
                Qe = dt;
              }
          $a(xe, Oe, Ge.children, je), Oe = Oe.child;
        }
        return Oe;
      case 9:
        return Ge = Oe.type, Fe = Oe.pendingProps.children, Ln(Oe, je), Ge = fa(Ge), Fe = Fe(Ge), Oe.flags |= 1, $a(xe, Oe, Fe, je), Oe.child;
      case 14:
        return Fe = Oe.type, Ge = Cs(Fe, Oe.pendingProps), Ge = Cs(Fe.type, Ge), Wm(xe, Oe, Fe, Ge, je);
      case 15:
        return ls(xe, Oe, Oe.type, Oe.pendingProps, je);
      case 17:
        return Fe = Oe.type, Ge = Oe.pendingProps, Ge = Oe.elementType === Fe ? Ge : Cs(Fe, Ge), Xs(xe, Oe), Oe.tag = 1, Go(Fe) ? (xe = !0, ym(Oe)) : xe = !1, Ln(Oe, je), Tg(Oe, Fe, Ge), Pm(Oe, Fe, Ge, je), Rb(null, Oe, Fe, !0, xe, je);
      case 19:
        return cs(xe, Oe, je);
      case 22:
        return Ed(xe, Oe, je);
    }
    throw Error(fe(156, Oe.tag));
  };
  function Kg(xe, Oe) {
    return So(xe, Oe);
  }
  function A_(xe, Oe, je, Fe) {
    this.tag = xe, this.key = je, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = Oe, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Fe, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function tu(xe, Oe, je, Fe) {
    return new A_(xe, Oe, je, Fe);
  }
  function Zb(xe) {
    return xe = xe.prototype, !(!xe || !xe.isReactComponent);
  }
  function C_(xe) {
    if (typeof xe == "function")
      return Zb(xe) ? 1 : 0;
    if (xe != null) {
      if (xe = xe.$$typeof, xe === en)
        return 11;
      if (xe === pn)
        return 14;
    }
    return 2;
  }
  function vc(xe, Oe) {
    var je = xe.alternate;
    return je === null ? (je = tu(xe.tag, Oe, xe.key, xe.mode), je.elementType = xe.elementType, je.type = xe.type, je.stateNode = xe.stateNode, je.alternate = xe, xe.alternate = je) : (je.pendingProps = Oe, je.type = xe.type, je.flags = 0, je.subtreeFlags = 0, je.deletions = null), je.flags = xe.flags & 14680064, je.childLanes = xe.childLanes, je.lanes = xe.lanes, je.child = xe.child, je.memoizedProps = xe.memoizedProps, je.memoizedState = xe.memoizedState, je.updateQueue = xe.updateQueue, Oe = xe.dependencies, je.dependencies = Oe === null ? null : { lanes: Oe.lanes, firstContext: Oe.firstContext }, je.sibling = xe.sibling, je.index = xe.index, je.ref = xe.ref, je;
  }
  function ly(xe, Oe, je, Fe, Ge, Qe) {
    var dt = 2;
    if (Fe = xe, typeof xe == "function")
      Zb(xe) && (dt = 1);
    else if (typeof xe == "string")
      dt = 5;
    else
      e:
        switch (xe) {
          case gt:
            return gc(je.children, Ge, Qe, Oe);
          case It:
            dt = 8, Ge |= 8;
            break;
          case Nt:
            return xe = tu(12, je, Oe, Ge | 2), xe.elementType = Nt, xe.lanes = Qe, xe;
          case wn:
            return xe = tu(13, je, Oe, Ge), xe.elementType = wn, xe.lanes = Qe, xe;
          case Zt:
            return xe = tu(19, je, Oe, Ge), xe.elementType = Zt, xe.lanes = Qe, xe;
          case dn:
            return Af(je, Ge, Qe, Oe);
          default:
            if (typeof xe == "object" && xe !== null)
              switch (xe.$$typeof) {
                case Ft:
                  dt = 10;
                  break e;
                case on:
                  dt = 9;
                  break e;
                case en:
                  dt = 11;
                  break e;
                case pn:
                  dt = 14;
                  break e;
                case un:
                  dt = 16, Fe = null;
                  break e;
              }
            throw Error(fe(130, xe == null ? xe : typeof xe, ""));
        }
    return Oe = tu(dt, je, Oe, Ge), Oe.elementType = xe, Oe.type = Fe, Oe.lanes = Qe, Oe;
  }
  function gc(xe, Oe, je, Fe) {
    return xe = tu(7, xe, Fe, Oe), xe.lanes = je, xe;
  }
  function Af(xe, Oe, je, Fe) {
    return xe = tu(22, xe, Fe, Oe), xe.elementType = dn, xe.lanes = je, xe.stateNode = { isHidden: !1 }, xe;
  }
  function Md(xe, Oe, je) {
    return xe = tu(6, xe, null, Oe), xe.lanes = je, xe;
  }
  function qb(xe, Oe, je) {
    return Oe = tu(4, xe.children !== null ? xe.children : [], xe.key, Oe), Oe.lanes = je, Oe.stateNode = { containerInfo: xe.containerInfo, pendingChildren: null, implementation: xe.implementation }, Oe;
  }
  function Xg(xe, Oe, je, Fe, Ge) {
    this.tag = Oe, this.containerInfo = xe, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Zc(0), this.expirationTimes = Zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Zc(0), this.identifierPrefix = Fe, this.onRecoverableError = Ge, this.mutableSourceEagerHydrationData = null;
  }
  function cy(xe, Oe, je, Fe, Ge, Qe, dt, St, Rt) {
    return xe = new Xg(xe, Oe, je, St, Rt), Oe === 1 ? (Oe = 1, Qe === !0 && (Oe |= 8)) : Oe = 0, Qe = tu(3, null, null, Oe), xe.current = Qe, Qe.stateNode = xe, Qe.memoizedState = { element: Fe, isDehydrated: je, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Eb(Qe), xe;
  }
  function Jg(xe, Oe, je) {
    var Fe = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: wt, key: Fe == null ? null : "" + Fe, children: xe, containerInfo: Oe, implementation: je };
  }
  function e0(xe) {
    if (!xe)
      return Uu;
    xe = xe._reactInternals;
    e: {
      if (Rr(xe) !== xe || xe.tag !== 1)
        throw Error(fe(170));
      var Oe = xe;
      do {
        switch (Oe.tag) {
          case 3:
            Oe = Oe.stateNode.context;
            break e;
          case 1:
            if (Go(Oe.type)) {
              Oe = Oe.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        Oe = Oe.return;
      } while (Oe !== null);
      throw Error(fe(171));
    }
    if (xe.tag === 1) {
      var je = xe.type;
      if (Go(je))
        return wp(xe, je, Oe);
    }
    return Oe;
  }
  function Wb(xe, Oe, je, Fe, Ge, Qe, dt, St, Rt) {
    return xe = cy(je, Fe, !0, xe, Ge, Qe, dt, St, Rt), xe.context = e0(null), je = xe.current, Fe = Io(), Ge = Ns(je), Qe = fl(Fe, Ge), Qe.callback = Oe ?? null, rc(je, Qe, Ge), xe.current.lanes = Ge, uu(xe, Ge, Fe), Va(xe, Fe), xe;
  }
  function dy(xe, Oe, je, Fe) {
    var Ge = Oe.current, Qe = Io(), dt = Ns(Ge);
    return je = e0(je), Oe.context === null ? Oe.context = je : Oe.pendingContext = je, Oe = fl(Qe, dt), Oe.payload = { element: xe }, Fe = Fe === void 0 ? null : Fe, Fe !== null && (Oe.callback = Fe), xe = rc(Ge, Oe, dt), xe !== null && (Ms(xe, Ge, dt, Qe), Em(xe, Ge, dt)), dt;
  }
  function fy(xe) {
    if (xe = xe.current, !xe.child)
      return null;
    switch (xe.child.tag) {
      case 5:
        return xe.child.stateNode;
      default:
        return xe.child.stateNode;
    }
  }
  function t0(xe, Oe) {
    if (xe = xe.memoizedState, xe !== null && xe.dehydrated !== null) {
      var je = xe.retryLane;
      xe.retryLane = je !== 0 && je < Oe ? je : Oe;
    }
  }
  function py(xe, Oe) {
    t0(xe, Oe), (xe = xe.alternate) && t0(xe, Oe);
  }
  function n0() {
    return null;
  }
  var Gb = typeof reportError == "function" ? reportError : function(xe) {
    console.error(xe);
  };
  function wc(xe) {
    this._internalRoot = xe;
  }
  hy.prototype.render = wc.prototype.render = function(xe) {
    var Oe = this._internalRoot;
    if (Oe === null)
      throw Error(fe(409));
    dy(xe, Oe, null, null);
  }, hy.prototype.unmount = wc.prototype.unmount = function() {
    var xe = this._internalRoot;
    if (xe !== null) {
      this._internalRoot = null;
      var Oe = xe.containerInfo;
      $d(function() {
        dy(null, xe, null, null);
      }), Oe[ll] = null;
    }
  };
  function hy(xe) {
    this._internalRoot = xe;
  }
  hy.prototype.unstable_scheduleHydration = function(xe) {
    if (xe) {
      var Oe = qc();
      xe = { blockedOn: null, target: xe, priority: Oe };
      for (var je = 0; je < lo.length && Oe !== 0 && Oe < lo[je].priority; je++)
        ;
      lo.splice(je, 0, xe), je === 0 && Gc(xe);
    }
  };
  function Yb(xe) {
    return !(!xe || xe.nodeType !== 1 && xe.nodeType !== 9 && xe.nodeType !== 11);
  }
  function my(xe) {
    return !(!xe || xe.nodeType !== 1 && xe.nodeType !== 9 && xe.nodeType !== 11 && (xe.nodeType !== 8 || xe.nodeValue !== " react-mount-point-unstable "));
  }
  function r0() {
  }
  function I_(xe, Oe, je, Fe, Ge) {
    if (Ge) {
      if (typeof Fe == "function") {
        var Qe = Fe;
        Fe = function() {
          var an = fy(dt);
          Qe.call(an);
        };
      }
      var dt = Wb(Oe, Fe, xe, 0, null, !1, !1, "", r0);
      return xe._reactRootContainer = dt, xe[ll] = dt.current, lf(xe.nodeType === 8 ? xe.parentNode : xe), $d(), dt;
    }
    for (; Ge = xe.lastChild; )
      xe.removeChild(Ge);
    if (typeof Fe == "function") {
      var St = Fe;
      Fe = function() {
        var an = fy(Rt);
        St.call(an);
      };
    }
    var Rt = cy(xe, 0, !1, null, null, !1, !1, "", r0);
    return xe._reactRootContainer = Rt, xe[ll] = Rt.current, lf(xe.nodeType === 8 ? xe.parentNode : xe), $d(function() {
      dy(Oe, Rt, je, Fe);
    }), Rt;
  }
  function yy(xe, Oe, je, Fe, Ge) {
    var Qe = je._reactRootContainer;
    if (Qe) {
      var dt = Qe;
      if (typeof Ge == "function") {
        var St = Ge;
        Ge = function() {
          var Rt = fy(dt);
          St.call(Rt);
        };
      }
      dy(Oe, dt, xe, Ge);
    } else
      dt = I_(je, Oe, xe, Ge, Fe);
    return fy(dt);
  }
  Yd = function(xe) {
    switch (xe.tag) {
      case 3:
        var Oe = xe.stateNode;
        if (Oe.current.memoizedState.isDehydrated) {
          var je = xs(Oe.pendingLanes);
          je !== 0 && (_u(Oe, je | 1), Va(Oe, Xr()), !(Hr & 6) && (Pf = Xr() + 500, rs()));
        }
        break;
      case 13:
        $d(function() {
          var Fe = dl(xe, 1);
          if (Fe !== null) {
            var Ge = Io();
            Ms(Fe, xe, 1, Ge);
          }
        }), py(xe, 1);
    }
  }, Es = function(xe) {
    if (xe.tag === 13) {
      var Oe = dl(xe, 134217728);
      if (Oe !== null) {
        var je = Io();
        Ms(Oe, xe, 134217728, je);
      }
      py(xe, 134217728);
    }
  }, uo = function(xe) {
    if (xe.tag === 13) {
      var Oe = Ns(xe), je = dl(xe, Oe);
      if (je !== null) {
        var Fe = Io();
        Ms(je, xe, Oe, Fe);
      }
      py(xe, Oe);
    }
  }, qc = function() {
    return so;
  }, Wc = function(xe, Oe) {
    var je = so;
    try {
      return so = xe, Oe();
    } finally {
      so = je;
    }
  }, bo = function(xe, Oe, je) {
    switch (Oe) {
      case "input":
        if (ra(xe, je), Oe = je.name, je.type === "radio" && Oe != null) {
          for (je = xe; je.parentNode; )
            je = je.parentNode;
          for (je = je.querySelectorAll("input[name=" + JSON.stringify("" + Oe) + '][type="radio"]'), Oe = 0; Oe < je.length; Oe++) {
            var Fe = je[Oe];
            if (Fe !== xe && Fe.form === xe.form) {
              var Ge = hr(Fe);
              if (!Ge)
                throw Error(fe(90));
              qr(Fe), ra(Fe, Ge);
            }
          }
        }
        break;
      case "textarea":
        da(xe, je);
        break;
      case "select":
        Oe = je.value, Oe != null && No(xe, !!je.multiple, Oe, !1);
    }
  }, Yi = iy, ei = $d;
  var o0 = { usingClientEntryPoint: !1, Events: [gp, cf, hr, Xa, Gi, iy] }, Zp = { findFiberByHostInstance: Zs, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, $_ = { bundleType: Zp.bundleType, version: Zp.version, rendererPackageName: Zp.rendererPackageName, rendererConfig: Zp.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: pt.ReactCurrentDispatcher, findHostInstanceByFiber: function(xe) {
    return xe = sa(xe), xe === null ? null : xe.stateNode;
  }, findFiberByHostInstance: Zp.findFiberByHostInstance || n0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Cf = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Cf.isDisabled && Cf.supportsFiber))
    try {
      gu = Cf.inject($_), Ci = Cf;
    } catch {
    }
  var Cf;
  ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = o0, ne.createPortal = function(xe, Oe) {
    var je = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Yb(Oe))
      throw Error(fe(200));
    return Jg(xe, Oe, null, je);
  }, ne.createRoot = function(xe, Oe) {
    if (!Yb(xe))
      throw Error(fe(299));
    var je = !1, Fe = "", Ge = Gb;
    return Oe != null && (Oe.unstable_strictMode === !0 && (je = !0), Oe.identifierPrefix !== void 0 && (Fe = Oe.identifierPrefix), Oe.onRecoverableError !== void 0 && (Ge = Oe.onRecoverableError)), Oe = cy(xe, 1, !1, null, null, je, !1, Fe, Ge), xe[ll] = Oe.current, lf(xe.nodeType === 8 ? xe.parentNode : xe), new wc(Oe);
  }, ne.findDOMNode = function(xe) {
    if (xe == null)
      return null;
    if (xe.nodeType === 1)
      return xe;
    var Oe = xe._reactInternals;
    if (Oe === void 0)
      throw typeof xe.render == "function" ? Error(fe(188)) : (xe = Object.keys(xe).join(","), Error(fe(268, xe)));
    return xe = sa(Oe), xe = xe === null ? null : xe.stateNode, xe;
  }, ne.flushSync = function(xe) {
    return $d(xe);
  }, ne.hydrate = function(xe, Oe, je) {
    if (!my(Oe))
      throw Error(fe(200));
    return yy(null, xe, Oe, !0, je);
  }, ne.hydrateRoot = function(xe, Oe, je) {
    if (!Yb(xe))
      throw Error(fe(405));
    var Fe = je != null && je.hydratedSources || null, Ge = !1, Qe = "", dt = Gb;
    if (je != null && (je.unstable_strictMode === !0 && (Ge = !0), je.identifierPrefix !== void 0 && (Qe = je.identifierPrefix), je.onRecoverableError !== void 0 && (dt = je.onRecoverableError)), Oe = Wb(Oe, null, xe, 1, je ?? null, Ge, !1, Qe, dt), xe[ll] = Oe.current, lf(xe), Fe)
      for (xe = 0; xe < Fe.length; xe++)
        je = Fe[xe], Ge = je._getVersion, Ge = Ge(je._source), Oe.mutableSourceEagerHydrationData == null ? Oe.mutableSourceEagerHydrationData = [je, Ge] : Oe.mutableSourceEagerHydrationData.push(je, Ge);
    return new hy(Oe);
  }, ne.render = function(xe, Oe, je) {
    if (!my(Oe))
      throw Error(fe(200));
    return yy(null, xe, Oe, !1, je);
  }, ne.unmountComponentAtNode = function(xe) {
    if (!my(xe))
      throw Error(fe(40));
    return xe._reactRootContainer ? ($d(function() {
      yy(null, null, xe, !1, function() {
        xe._reactRootContainer = null, xe[ll] = null;
      });
    }), !0) : !1;
  }, ne.unstable_batchedUpdates = iy, ne.unstable_renderSubtreeIntoContainer = function(xe, Oe, je, Fe) {
    if (!my(je))
      throw Error(fe(200));
    if (xe == null || xe._reactInternals === void 0)
      throw Error(fe(38));
    return yy(xe, Oe, je, !1, Fe);
  }, ne.version = "18.2.0-next-9e3b772b8-20220608";
}), hz = M((ne) => {
  process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var oe = ir(), ae = GR(), fe = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ye = !1;
    function ge(me) {
      ye = me;
    }
    function we(me) {
      if (!ye) {
        for (var ve = arguments.length, Ce = new Array(ve > 1 ? ve - 1 : 0), Re = 1; Re < ve; Re++)
          Ce[Re - 1] = arguments[Re];
        Se("warn", me, Ce);
      }
    }
    function _e(me) {
      if (!ye) {
        for (var ve = arguments.length, Ce = new Array(ve > 1 ? ve - 1 : 0), Re = 1; Re < ve; Re++)
          Ce[Re - 1] = arguments[Re];
        Se("error", me, Ce);
      }
    }
    function Se(me, ve, Ce) {
      {
        var Re = fe.ReactDebugCurrentFrame, De = Re.getStackAddendum();
        De !== "" && (ve += "%s", Ce = Ce.concat([De]));
        var Ue = Ce.map(function(Ye) {
          return String(Ye);
        });
        Ue.unshift("Warning: " + ve), Function.prototype.apply.call(console[me], console, Ue);
      }
    }
    var Ie = 0, $e = 1, Ne = 2, Me = 3, Be = 4, ze = 5, He = 6, Ze = 7, qe = 8, tt = 9, Xe = 10, ot = 11, pt = 12, ht = 13, wt = 14, gt = 15, It = 16, Nt = 17, Ft = 18, on = 19, en = 21, wn = 22, Zt = 23, pn = 24, un = 25, dn = !0, xn = !1, Rn = !1, At = !1, hn = !1, Yn = !0, Un = !1, Ht = !1, _n = !0, Vn = !0, br = !0, nr = /* @__PURE__ */ new Set(), Er = {}, Qo = {};
    function Yr(me, ve) {
      qr(me, ve), qr(me + "Capture", ve);
    }
    function qr(me, ve) {
      Er[me] && _e("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", me), Er[me] = ve;
      {
        var Ce = me.toLowerCase();
        Qo[Ce] = me, me === "onDoubleClick" && (Qo.ondblclick = me);
      }
      for (var Re = 0; Re < ve.length; Re++)
        nr.add(ve[Re]);
    }
    var Kr = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", $o = Object.prototype.hasOwnProperty;
    function xo(me) {
      {
        var ve = typeof Symbol == "function" && Symbol.toStringTag, Ce = ve && me[Symbol.toStringTag] || me.constructor.name || "Object";
        return Ce;
      }
    }
    function _o(me) {
      try {
        return ra(me), !1;
      } catch {
        return !0;
      }
    }
    function ra(me) {
      return "" + me;
    }
    function Aa(me, ve) {
      if (_o(me))
        return _e("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, xo(me)), ra(me);
    }
    function Ho(me) {
      if (_o(me))
        return _e("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xo(me)), ra(me);
    }
    function ca(me, ve) {
      if (_o(me))
        return _e("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, xo(me)), ra(me);
    }
    function No(me, ve) {
      if (_o(me))
        return _e("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", ve, xo(me)), ra(me);
    }
    function xa(me) {
      if (_o(me))
        return _e("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", xo(me)), ra(me);
    }
    function qa(me) {
      if (_o(me))
        return _e("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", xo(me)), ra(me);
    }
    var da = 0, oa = 1, Ka = 2, jo = 3, La = 4, $t = 5, Vt = 6, rn = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Cn = rn + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Mn = new RegExp("^[" + rn + "][" + Cn + "]*$"), Bn = {}, Qn = {};
    function Kn(me) {
      return $o.call(Qn, me) ? !0 : $o.call(Bn, me) ? !1 : Mn.test(me) ? (Qn[me] = !0, !0) : (Bn[me] = !0, _e("Invalid attribute name: `%s`", me), !1);
    }
    function jn(me, ve, Ce) {
      return ve !== null ? ve.type === da : Ce ? !1 : me.length > 2 && (me[0] === "o" || me[0] === "O") && (me[1] === "n" || me[1] === "N");
    }
    function Tr(me, ve, Ce, Re) {
      if (Ce !== null && Ce.type === da)
        return !1;
      switch (typeof ve) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (Re)
            return !1;
          if (Ce !== null)
            return !Ce.acceptsBooleans;
          var De = me.toLowerCase().slice(0, 5);
          return De !== "data-" && De !== "aria-";
        }
        default:
          return !1;
      }
    }
    function jr(me, ve, Ce, Re) {
      if (ve === null || typeof ve > "u" || Tr(me, ve, Ce, Re))
        return !0;
      if (Re)
        return !1;
      if (Ce !== null)
        switch (Ce.type) {
          case jo:
            return !ve;
          case La:
            return ve === !1;
          case $t:
            return isNaN(ve);
          case Vt:
            return isNaN(ve) || ve < 1;
        }
      return !1;
    }
    function bo(me) {
      return Sr.hasOwnProperty(me) ? Sr[me] : null;
    }
    function _r(me, ve, Ce, Re, De, Ue, Ye) {
      this.acceptsBooleans = ve === Ka || ve === jo || ve === La, this.attributeName = Re, this.attributeNamespace = De, this.mustUseProperty = Ce, this.propertyName = me, this.type = ve, this.sanitizeURL = Ue, this.removeEmptyString = Ye;
    }
    var Sr = {}, Ro = ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"];
    Ro.forEach(function(me) {
      Sr[me] = new _r(me, da, !1, me, null, !1, !1);
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(me) {
      var ve = me[0], Ce = me[1];
      Sr[ve] = new _r(ve, oa, !1, Ce, null, !1, !1);
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(me) {
      Sr[me] = new _r(me, Ka, !1, me.toLowerCase(), null, !1, !1);
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(me) {
      Sr[me] = new _r(me, Ka, !1, me, null, !1, !1);
    }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(function(me) {
      Sr[me] = new _r(me, jo, !1, me.toLowerCase(), null, !1, !1);
    }), ["checked", "multiple", "muted", "selected"].forEach(function(me) {
      Sr[me] = new _r(me, jo, !0, me, null, !1, !1);
    }), ["capture", "download"].forEach(function(me) {
      Sr[me] = new _r(me, La, !1, me, null, !1, !1);
    }), ["cols", "rows", "size", "span"].forEach(function(me) {
      Sr[me] = new _r(me, Vt, !1, me, null, !1, !1);
    }), ["rowSpan", "start"].forEach(function(me) {
      Sr[me] = new _r(me, $t, !1, me.toLowerCase(), null, !1, !1);
    });
    var Xa = /[\-\:]([a-z])/g, Gi = function(me) {
      return me[1].toUpperCase();
    };
    ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(function(me) {
      var ve = me.replace(Xa, Gi);
      Sr[ve] = new _r(ve, oa, !1, me, null, !1, !1);
    }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(function(me) {
      var ve = me.replace(Xa, Gi);
      Sr[ve] = new _r(ve, oa, !1, me, "http://www.w3.org/1999/xlink", !1, !1);
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function(me) {
      var ve = me.replace(Xa, Gi);
      Sr[ve] = new _r(ve, oa, !1, me, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }), ["tabIndex", "crossOrigin"].forEach(function(me) {
      Sr[me] = new _r(me, oa, !1, me.toLowerCase(), null, !1, !1);
    });
    var Yi = "xlinkHref";
    Sr[Yi] = new _r("xlinkHref", oa, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(me) {
      Sr[me] = new _r(me, oa, !1, me.toLowerCase(), null, !0, !0);
    });
    var ei = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Si = !1;
    function Da(me) {
      !Si && ei.test(me) && (Si = !0, _e("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(me)));
    }
    function ti(me, ve, Ce, Re) {
      if (Re.mustUseProperty) {
        var De = Re.propertyName;
        return me[De];
      } else {
        Aa(Ce, ve), Re.sanitizeURL && Da("" + Ce);
        var Ue = Re.attributeName, Ye = null;
        if (Re.type === La) {
          if (me.hasAttribute(Ue)) {
            var et = me.getAttribute(Ue);
            return et === "" ? !0 : jr(ve, Ce, Re, !1) ? et : et === "" + Ce ? Ce : et;
          }
        } else if (me.hasAttribute(Ue)) {
          if (jr(ve, Ce, Re, !1))
            return me.getAttribute(Ue);
          if (Re.type === jo)
            return Ce;
          Ye = me.getAttribute(Ue);
        }
        return jr(ve, Ce, Re, !1) ? Ye === null ? Ce : Ye : Ye === "" + Ce ? Ce : Ye;
      }
    }
    function Ni(me, ve, Ce, Re) {
      {
        if (!Kn(ve))
          return;
        if (!me.hasAttribute(ve))
          return Ce === void 0 ? void 0 : null;
        var De = me.getAttribute(ve);
        return Aa(Ce, ve), De === "" + Ce ? Ce : De;
      }
    }
    function Ea(me, ve, Ce, Re) {
      var De = bo(ve);
      if (!jn(ve, De, Re)) {
        if (jr(ve, Ce, De, Re) && (Ce = null), Re || De === null) {
          if (Kn(ve)) {
            var Ue = ve;
            Ce === null ? me.removeAttribute(Ue) : (Aa(Ce, ve), me.setAttribute(Ue, "" + Ce));
          }
          return;
        }
        var Ye = De.mustUseProperty;
        if (Ye) {
          var et = De.propertyName;
          if (Ce === null) {
            var at = De.type;
            me[et] = at === jo ? !1 : "";
          } else
            me[et] = Ce;
          return;
        }
        var yt = De.attributeName, bt = De.attributeNamespace;
        if (Ce === null)
          me.removeAttribute(yt);
        else {
          var Ut = De.type, jt;
          Ut === jo || Ut === La && Ce === !0 ? jt = "" : (Aa(Ce, yt), jt = "" + Ce, De.sanitizeURL && Da(jt.toString())), bt ? me.setAttributeNS(bt, yt, jt) : me.setAttribute(yt, jt);
        }
      }
    }
    var Jr = Symbol.for("react.element"), vo = Symbol.for("react.portal"), aa = Symbol.for("react.fragment"), ni = Symbol.for("react.strict_mode"), Ot = Symbol.for("react.profiler"), En = Symbol.for("react.provider"), An = Symbol.for("react.context"), ar = Symbol.for("react.forward_ref"), Rr = Symbol.for("react.suspense"), Wr = Symbol.for("react.suspense_list"), Lr = Symbol.for("react.memo"), fr = Symbol.for("react.lazy"), sa = Symbol.for("react.scope"), Eo = Symbol.for("react.debug_trace_mode"), So = Symbol.for("react.offscreen"), Ca = Symbol.for("react.legacy_hidden"), zs = Symbol.for("react.cache"), Ol = Symbol.for("react.tracing_marker"), Xr = Symbol.iterator, Yf = "@@iterator";
    function _s(me) {
      if (me === null || typeof me != "object")
        return null;
      var ve = Xr && me[Xr] || me[Yf];
      return typeof ve == "function" ? ve : null;
    }
    var zr = Object.assign, Pi = 0, Fc, Al, gu, Ci, zc, ri, Uc;
    function Vc() {
    }
    Vc.__reactDisabledLog = !0;
    function Qf() {
      {
        if (Pi === 0) {
          Fc = console.log, Al = console.info, gu = console.warn, Ci = console.error, zc = console.group, ri = console.groupCollapsed, Uc = console.groupEnd;
          var me = { configurable: !0, enumerable: !0, value: Vc, writable: !0 };
          Object.defineProperties(console, { info: me, log: me, warn: me, error: me, group: me, groupCollapsed: me, groupEnd: me });
        }
        Pi++;
      }
    }
    function Cl() {
      {
        if (Pi--, Pi === 0) {
          var me = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, { log: zr({}, me, { value: Fc }), info: zr({}, me, { value: Al }), warn: zr({}, me, { value: gu }), error: zr({}, me, { value: Ci }), group: zr({}, me, { value: zc }), groupCollapsed: zr({}, me, { value: ri }), groupEnd: zr({}, me, { value: Uc }) });
        }
        Pi < 0 && _e("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Us = fe.ReactCurrentDispatcher, xs;
    function Ba(me, ve, Ce) {
      {
        if (xs === void 0)
          try {
            throw Error();
          } catch (De) {
            var Re = De.stack.trim().match(/\n( *(at )?)/);
            xs = Re && Re[1] || "";
          }
        return `
` + xs + me;
      }
    }
    var el = !1, su;
    {
      var Hc = typeof WeakMap == "function" ? WeakMap : Map;
      su = new Hc();
    }
    function tl(me, ve) {
      if (!me || el)
        return "";
      {
        var Ce = su.get(me);
        if (Ce !== void 0)
          return Ce;
      }
      var Re;
      el = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ue;
      Ue = Us.current, Us.current = null, Qf();
      try {
        if (ve) {
          var Ye = function() {
            throw Error();
          };
          if (Object.defineProperty(Ye.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ye, []);
            } catch (nn) {
              Re = nn;
            }
            Reflect.construct(me, [], Ye);
          } else {
            try {
              Ye.call();
            } catch (nn) {
              Re = nn;
            }
            me.call(Ye.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nn) {
            Re = nn;
          }
          me();
        }
      } catch (nn) {
        if (nn && Re && typeof nn.stack == "string") {
          for (var et = nn.stack.split(`
`), at = Re.stack.split(`
`), yt = et.length - 1, bt = at.length - 1; yt >= 1 && bt >= 0 && et[yt] !== at[bt]; )
            bt--;
          for (; yt >= 1 && bt >= 0; yt--, bt--)
            if (et[yt] !== at[bt]) {
              if (yt !== 1 || bt !== 1)
                do
                  if (yt--, bt--, bt < 0 || et[yt] !== at[bt]) {
                    var Ut = `
` + et[yt].replace(" at new ", " at ");
                    return me.displayName && Ut.includes("<anonymous>") && (Ut = Ut.replace("<anonymous>", me.displayName)), typeof me == "function" && su.set(me, Ut), Ut;
                  }
                while (yt >= 1 && bt >= 0);
              break;
            }
        }
      } finally {
        el = !1, Us.current = Ue, Cl(), Error.prepareStackTrace = De;
      }
      var jt = me ? me.displayName || me.name : "", tn = jt ? Ba(jt) : "";
      return typeof me == "function" && su.set(me, tn), tn;
    }
    function Zc(me, ve, Ce) {
      return tl(me, !0);
    }
    function uu(me, ve, Ce) {
      return tl(me, !1);
    }
    function Rl(me) {
      var ve = me.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function _u(me, ve, Ce) {
      if (me == null)
        return "";
      if (typeof me == "function")
        return tl(me, Rl(me));
      if (typeof me == "string")
        return Ba(me);
      switch (me) {
        case Rr:
          return Ba("Suspense");
        case Wr:
          return Ba("SuspenseList");
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case ar:
            return uu(me.render);
          case Lr:
            return _u(me.type, ve, Ce);
          case fr: {
            var Re = me, De = Re._payload, Ue = Re._init;
            try {
              return _u(Ue(De), ve, Ce);
            } catch {
            }
          }
        }
      return "";
    }
    function so(me) {
      switch (me._debugOwner && me._debugOwner.type, me._debugSource, me.tag) {
        case ze:
          return Ba(me.type);
        case It:
          return Ba("Lazy");
        case ht:
          return Ba("Suspense");
        case on:
          return Ba("SuspenseList");
        case Ie:
        case Ne:
        case gt:
          return uu(me.type);
        case ot:
          return uu(me.type.render);
        case $e:
          return Zc(me.type);
        default:
          return "";
      }
    }
    function Su(me) {
      try {
        var ve = "", Ce = me;
        do
          ve += so(Ce), Ce = Ce.return;
        while (Ce);
        return ve;
      } catch (Re) {
        return `
Error generating stack: ` + Re.message + `
` + Re.stack;
      }
    }
    function Yd(me, ve, Ce) {
      var Re = me.displayName;
      if (Re)
        return Re;
      var De = ve.displayName || ve.name || "";
      return De !== "" ? Ce + "(" + De + ")" : Ce;
    }
    function Es(me) {
      return me.displayName || "Context";
    }
    function uo(me) {
      if (me == null)
        return null;
      if (typeof me.tag == "number" && _e("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof me == "function")
        return me.displayName || me.name || null;
      if (typeof me == "string")
        return me;
      switch (me) {
        case aa:
          return "Fragment";
        case vo:
          return "Portal";
        case Ot:
          return "Profiler";
        case ni:
          return "StrictMode";
        case Rr:
          return "Suspense";
        case Wr:
          return "SuspenseList";
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case An:
            var ve = me;
            return Es(ve) + ".Consumer";
          case En:
            var Ce = me;
            return Es(Ce._context) + ".Provider";
          case ar:
            return Yd(me, me.render, "ForwardRef");
          case Lr:
            var Re = me.displayName || null;
            return Re !== null ? Re : uo(me.type) || "Memo";
          case fr: {
            var De = me, Ue = De._payload, Ye = De._init;
            try {
              return uo(Ye(Ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function qc(me, ve, Ce) {
      var Re = ve.displayName || ve.name || "";
      return me.displayName || (Re !== "" ? Ce + "(" + Re + ")" : Ce);
    }
    function Wc(me) {
      return me.displayName || "Context";
    }
    function Ar(me) {
      var ve = me.tag, Ce = me.type;
      switch (ve) {
        case pn:
          return "Cache";
        case tt:
          var Re = Ce;
          return Wc(Re) + ".Consumer";
        case Xe:
          var De = Ce;
          return Wc(De._context) + ".Provider";
        case Ft:
          return "DehydratedFragment";
        case ot:
          return qc(Ce, Ce.render, "ForwardRef");
        case Ze:
          return "Fragment";
        case ze:
          return Ce;
        case Be:
          return "Portal";
        case Me:
          return "Root";
        case He:
          return "Text";
        case It:
          return uo(Ce);
        case qe:
          return Ce === ni ? "StrictMode" : "Mode";
        case wn:
          return "Offscreen";
        case pt:
          return "Profiler";
        case en:
          return "Scope";
        case ht:
          return "Suspense";
        case on:
          return "SuspenseList";
        case un:
          return "TracingMarker";
        case $e:
        case Ie:
        case Nt:
        case Ne:
        case wt:
        case gt:
          if (typeof Ce == "function")
            return Ce.displayName || Ce.name || null;
          if (typeof Ce == "string")
            return Ce;
          break;
      }
      return null;
    }
    var Pu = fe.ReactDebugCurrentFrame, Zo = null, ii = !1;
    function si() {
      {
        if (Zo === null)
          return null;
        var me = Zo._debugOwner;
        if (me !== null && typeof me < "u")
          return Ar(me);
      }
      return null;
    }
    function Iu() {
      return Zo === null ? "" : Su(Zo);
    }
    function Ko() {
      Pu.getCurrentStack = null, Zo = null, ii = !1;
    }
    function lo(me) {
      Pu.getCurrentStack = me === null ? null : Iu, Zo = me, ii = !1;
    }
    function Xd() {
      return Zo;
    }
    function Mi(me) {
      ii = me;
    }
    function Sa(me) {
      return "" + me;
    }
    function Vs(me) {
      switch (typeof me) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return me;
        case "object":
          return qa(me), me;
        default:
          return "";
      }
    }
    var Gc = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 };
    function Ss(me, ve) {
      Gc[ve.type] || ve.onChange || ve.onInput || ve.readOnly || ve.disabled || ve.value == null || _e("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), ve.onChange || ve.readOnly || ve.disabled || ve.checked == null || _e("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Yc(me) {
      var ve = me.type, Ce = me.nodeName;
      return Ce && Ce.toLowerCase() === "input" && (ve === "checkbox" || ve === "radio");
    }
    function lu(me) {
      return me._valueTracker;
    }
    function $u(me) {
      me._valueTracker = null;
    }
    function nl(me) {
      var ve = "";
      return me && (Yc(me) ? ve = me.checked ? "true" : "false" : ve = me.value), ve;
    }
    function Ps(me) {
      var ve = Yc(me) ? "checked" : "value", Ce = Object.getOwnPropertyDescriptor(me.constructor.prototype, ve);
      qa(me[ve]);
      var Re = "" + me[ve];
      if (!(me.hasOwnProperty(ve) || typeof Ce > "u" || typeof Ce.get != "function" || typeof Ce.set != "function")) {
        var De = Ce.get, Ue = Ce.set;
        Object.defineProperty(me, ve, { configurable: !0, get: function() {
          return De.call(this);
        }, set: function(et) {
          qa(et), Re = "" + et, Ue.call(this, et);
        } }), Object.defineProperty(me, ve, { enumerable: Ce.enumerable });
        var Ye = { getValue: function() {
          return Re;
        }, setValue: function(et) {
          qa(et), Re = "" + et;
        }, stopTracking: function() {
          $u(me), delete me[ve];
        } };
        return Ye;
      }
    }
    function ks(me) {
      lu(me) || (me._valueTracker = Ps(me));
    }
    function Nl(me) {
      if (!me)
        return !1;
      var ve = lu(me);
      if (!ve)
        return !0;
      var Ce = ve.getValue(), Re = nl(me);
      return Re !== Ce ? (ve.setValue(Re), !0) : !1;
    }
    function Bu(me) {
      if (me = me || (typeof document < "u" ? document : void 0), typeof me > "u")
        return null;
      try {
        return me.activeElement || me.body;
      } catch {
        return me.body;
      }
    }
    var Ml = !1, rl = !1, Dl = !1, Qc = !1;
    function it(me) {
      var ve = me.type === "checkbox" || me.type === "radio";
      return ve ? me.checked != null : me.value != null;
    }
    function Ct(me, ve) {
      var Ce = me, Re = ve.checked, De = zr({}, ve, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Re ?? Ce._wrapperState.initialChecked });
      return De;
    }
    function Kt(me, ve) {
      Ss("input", ve), ve.checked !== void 0 && ve.defaultChecked !== void 0 && !rl && (_e("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", ve.type), rl = !0), ve.value !== void 0 && ve.defaultValue !== void 0 && !Ml && (_e("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", ve.type), Ml = !0);
      var Ce = me, Re = ve.defaultValue == null ? "" : ve.defaultValue;
      Ce._wrapperState = { initialChecked: ve.checked != null ? ve.checked : ve.defaultChecked, initialValue: Vs(ve.value != null ? ve.value : Re), controlled: it(ve) };
    }
    function mn(me, ve) {
      var Ce = me, Re = ve.checked;
      Re != null && Ea(Ce, "checked", Re, !1);
    }
    function Sn(me, ve) {
      var Ce = me;
      {
        var Re = it(ve);
        !Ce._wrapperState.controlled && Re && !Qc && (_e("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Qc = !0), Ce._wrapperState.controlled && !Re && !Dl && (_e("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Dl = !0);
      }
      mn(me, ve);
      var De = Vs(ve.value), Ue = ve.type;
      if (De != null)
        Ue === "number" ? (De === 0 && Ce.value === "" || Ce.value != De) && (Ce.value = Sa(De)) : Ce.value !== Sa(De) && (Ce.value = Sa(De));
      else if (Ue === "submit" || Ue === "reset") {
        Ce.removeAttribute("value");
        return;
      }
      ve.hasOwnProperty("value") ? Dr(Ce, ve.type, De) : ve.hasOwnProperty("defaultValue") && Dr(Ce, ve.type, Vs(ve.defaultValue)), ve.checked == null && ve.defaultChecked != null && (Ce.defaultChecked = !!ve.defaultChecked);
    }
    function or(me, ve, Ce) {
      var Re = me;
      if (ve.hasOwnProperty("value") || ve.hasOwnProperty("defaultValue")) {
        var De = ve.type, Ue = De === "submit" || De === "reset";
        if (Ue && (ve.value === void 0 || ve.value === null))
          return;
        var Ye = Sa(Re._wrapperState.initialValue);
        Ce || Ye !== Re.value && (Re.value = Ye), Re.defaultValue = Ye;
      }
      var et = Re.name;
      et !== "" && (Re.name = ""), Re.defaultChecked = !Re.defaultChecked, Re.defaultChecked = !!Re._wrapperState.initialChecked, et !== "" && (Re.name = et);
    }
    function Jn(me, ve) {
      var Ce = me;
      Sn(Ce, ve), lr(Ce, ve);
    }
    function lr(me, ve) {
      var Ce = ve.name;
      if (ve.type === "radio" && Ce != null) {
        for (var Re = me; Re.parentNode; )
          Re = Re.parentNode;
        Aa(Ce, "name");
        for (var De = Re.querySelectorAll("input[name=" + JSON.stringify("" + Ce) + '][type="radio"]'), Ue = 0; Ue < De.length; Ue++) {
          var Ye = De[Ue];
          if (!(Ye === me || Ye.form !== me.form)) {
            var et = _0(Ye);
            if (!et)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Nl(Ye), Sn(Ye, et);
          }
        }
      }
    }
    function Dr(me, ve, Ce) {
      (ve !== "number" || Bu(me.ownerDocument) !== me) && (Ce == null ? me.defaultValue = Sa(me._wrapperState.initialValue) : me.defaultValue !== Sa(Ce) && (me.defaultValue = Sa(Ce)));
    }
    var co = !1, mo = !1, Oo = !1;
    function Po(me, ve) {
      ve.value == null && (typeof ve.children == "object" && ve.children !== null ? oe.Children.forEach(ve.children, function(Ce) {
        Ce != null && (typeof Ce == "string" || typeof Ce == "number" || mo || (mo = !0, _e("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : ve.dangerouslySetInnerHTML != null && (Oo || (Oo = !0, _e("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), ve.selected != null && !co && (_e("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), co = !0);
    }
    function Wo(me, ve) {
      ve.value != null && me.setAttribute("value", Sa(Vs(ve.value)));
    }
    var Xo = Array.isArray;
    function Jo(me) {
      return Xo(me);
    }
    var Bl;
    Bl = !1;
    function Kf() {
      var me = si();
      return me ? `

Check the render method of \`` + me + "`." : "";
    }
    var tm = ["value", "defaultValue"];
    function nm(me) {
      {
        Ss("select", me);
        for (var ve = 0; ve < tm.length; ve++) {
          var Ce = tm[ve];
          if (me[Ce] != null) {
            var Re = Jo(me[Ce]);
            me.multiple && !Re ? _e("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", Ce, Kf()) : !me.multiple && Re && _e("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", Ce, Kf());
          }
        }
      }
    }
    function Fu(me, ve, Ce, Re) {
      var De = me.options;
      if (ve) {
        for (var Ue = Ce, Ye = {}, et = 0; et < Ue.length; et++)
          Ye["$" + Ue[et]] = !0;
        for (var at = 0; at < De.length; at++) {
          var yt = Ye.hasOwnProperty("$" + De[at].value);
          De[at].selected !== yt && (De[at].selected = yt), yt && Re && (De[at].defaultSelected = !0);
        }
      } else {
        for (var bt = Sa(Vs(Ce)), Ut = null, jt = 0; jt < De.length; jt++) {
          if (De[jt].value === bt) {
            De[jt].selected = !0, Re && (De[jt].defaultSelected = !0);
            return;
          }
          Ut === null && !De[jt].disabled && (Ut = De[jt]);
        }
        Ut !== null && (Ut.selected = !0);
      }
    }
    function Jd(me, ve) {
      return zr({}, ve, { value: void 0 });
    }
    function rm(me, ve) {
      var Ce = me;
      nm(ve), Ce._wrapperState = { wasMultiple: !!ve.multiple }, ve.value !== void 0 && ve.defaultValue !== void 0 && !Bl && (_e("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Bl = !0);
    }
    function t_(me, ve) {
      var Ce = me;
      Ce.multiple = !!ve.multiple;
      var Re = ve.value;
      Re != null ? Fu(Ce, !!ve.multiple, Re, !1) : ve.defaultValue != null && Fu(Ce, !!ve.multiple, ve.defaultValue, !0);
    }
    function n_(me, ve) {
      var Ce = me, Re = Ce._wrapperState.wasMultiple;
      Ce._wrapperState.wasMultiple = !!ve.multiple;
      var De = ve.value;
      De != null ? Fu(Ce, !!ve.multiple, De, !1) : Re !== !!ve.multiple && (ve.defaultValue != null ? Fu(Ce, !!ve.multiple, ve.defaultValue, !0) : Fu(Ce, !!ve.multiple, ve.multiple ? [] : "", !1));
    }
    function r_(me, ve) {
      var Ce = me, Re = ve.value;
      Re != null && Fu(Ce, !!ve.multiple, Re, !1);
    }
    var Wy = !1;
    function Gy(me, ve) {
      var Ce = me;
      if (ve.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var Re = zr({}, ve, { value: void 0, defaultValue: void 0, children: Sa(Ce._wrapperState.initialValue) });
      return Re;
    }
    function qv(me, ve) {
      var Ce = me;
      Ss("textarea", ve), ve.value !== void 0 && ve.defaultValue !== void 0 && !Wy && (_e("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component"), Wy = !0);
      var Re = ve.value;
      if (Re == null) {
        var De = ve.children, Ue = ve.defaultValue;
        if (De != null) {
          _e("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (Ue != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Jo(De)) {
              if (De.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              De = De[0];
            }
            Ue = De;
          }
        }
        Ue == null && (Ue = ""), Re = Ue;
      }
      Ce._wrapperState = { initialValue: Vs(Re) };
    }
    function Wv(me, ve) {
      var Ce = me, Re = Vs(ve.value), De = Vs(ve.defaultValue);
      if (Re != null) {
        var Ue = Sa(Re);
        Ue !== Ce.value && (Ce.value = Ue), ve.defaultValue == null && Ce.defaultValue !== Ue && (Ce.defaultValue = Ue);
      }
      De != null && (Ce.defaultValue = Sa(De));
    }
    function Gv(me, ve) {
      var Ce = me, Re = Ce.textContent;
      Re === Ce._wrapperState.initialValue && Re !== "" && Re !== null && (Ce.value = Re);
    }
    function Yy(me, ve) {
      Wv(me, ve);
    }
    var ol = "http://www.w3.org/1999/xhtml", o_ = "http://www.w3.org/1998/Math/MathML", Qy = "http://www.w3.org/2000/svg";
    function om(me) {
      switch (me) {
        case "svg":
          return Qy;
        case "math":
          return o_;
        default:
          return ol;
      }
    }
    function Ky(me, ve) {
      return me == null || me === ol ? om(ve) : me === Qy && ve === "foreignObject" ? ol : me;
    }
    var a_ = function(me) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ve, Ce, Re, De) {
        MSApp.execUnsafeLocalFunction(function() {
          return me(ve, Ce, Re, De);
        });
      } : me;
    }, am, Yv = a_(function(me, ve) {
      if (me.namespaceURI === Qy && !("innerHTML" in me)) {
        am = am || document.createElement("div"), am.innerHTML = "<svg>" + ve.valueOf().toString() + "</svg>";
        for (var Ce = am.firstChild; me.firstChild; )
          me.removeChild(me.firstChild);
        for (; Ce.firstChild; )
          me.appendChild(Ce.firstChild);
        return;
      }
      me.innerHTML = ve;
    }), ts = 1, al = 3, Pa = 8, cu = 9, Kc = 11, im = function(me, ve) {
      if (ve) {
        var Ce = me.firstChild;
        if (Ce && Ce === me.lastChild && Ce.nodeType === al) {
          Ce.nodeValue = ve;
          return;
        }
      }
      me.textContent = ve;
    }, Qv = { animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"], background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"], backgroundPosition: ["backgroundPositionX", "backgroundPositionY"], border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"], borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"], borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"], borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"], borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"], borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"], borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"], borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"], borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"], borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"], borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"], borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"], borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"], borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"], columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"], columns: ["columnCount", "columnWidth"], flex: ["flexBasis", "flexGrow", "flexShrink"], flexFlow: ["flexDirection", "flexWrap"], font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"], fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"], gap: ["columnGap", "rowGap"], grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"], gridColumn: ["gridColumnEnd", "gridColumnStart"], gridColumnGap: ["columnGap"], gridGap: ["columnGap", "rowGap"], gridRow: ["gridRowEnd", "gridRowStart"], gridRowGap: ["rowGap"], gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"], listStyle: ["listStyleImage", "listStylePosition", "listStyleType"], margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"], marker: ["markerEnd", "markerMid", "markerStart"], mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"], maskPosition: ["maskPositionX", "maskPositionY"], outline: ["outlineColor", "outlineStyle", "outlineWidth"], overflow: ["overflowX", "overflowY"], padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"], placeContent: ["alignContent", "justifyContent"], placeItems: ["alignItems", "justifyItems"], placeSelf: ["alignSelf", "justifySelf"], textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"], textEmphasis: ["textEmphasisColor", "textEmphasisStyle"], transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"], wordWrap: ["overflowWrap"] }, ef = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 };
    function Kv(me, ve) {
      return me + ve.charAt(0).toUpperCase() + ve.substring(1);
    }
    var Xv = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ef).forEach(function(me) {
      Xv.forEach(function(ve) {
        ef[Kv(ve, me)] = ef[me];
      });
    });
    function sm(me, ve, Ce) {
      var Re = ve == null || typeof ve == "boolean" || ve === "";
      return Re ? "" : !Ce && typeof ve == "number" && ve !== 0 && !(ef.hasOwnProperty(me) && ef[me]) ? ve + "px" : (No(ve, me), ("" + ve).trim());
    }
    var tf = /([A-Z])/g, i_ = /^ms-/;
    function s_(me) {
      return me.replace(tf, "-$1").toLowerCase().replace(i_, "-ms-");
    }
    var Jv = function() {
    };
    {
      var eg = /^(?:webkit|moz|o)[A-Z]/, tg = /^-ms-/, Xf = /-(.)/g, nf = /;\s*$/, rf = {}, af = {}, ng = !1, Xy = !1, Jy = function(me) {
        return me.replace(Xf, function(ve, Ce) {
          return Ce.toUpperCase();
        });
      }, um = function(me) {
        rf.hasOwnProperty(me) && rf[me] || (rf[me] = !0, _e("Unsupported style property %s. Did you mean %s?", me, Jy(me.replace(tg, "ms-"))));
      }, eb = function(me) {
        rf.hasOwnProperty(me) && rf[me] || (rf[me] = !0, _e("Unsupported vendor-prefixed style property %s. Did you mean %s?", me, me.charAt(0).toUpperCase() + me.slice(1)));
      }, rg = function(me, ve) {
        af.hasOwnProperty(ve) && af[ve] || (af[ve] = !0, _e(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, me, ve.replace(nf, "")));
      }, og = function(me, ve) {
        ng || (ng = !0, _e("`NaN` is an invalid value for the `%s` css style property.", me));
      }, u_ = function(me, ve) {
        Xy || (Xy = !0, _e("`Infinity` is an invalid value for the `%s` css style property.", me));
      };
      Jv = function(me, ve) {
        me.indexOf("-") > -1 ? um(me) : eg.test(me) ? eb(me) : nf.test(ve) && rg(me, ve), typeof ve == "number" && (isNaN(ve) ? og(me, ve) : isFinite(ve) || u_(me, ve));
      };
    }
    var l_ = Jv;
    function c_(me) {
      {
        var ve = "", Ce = "";
        for (var Re in me)
          if (me.hasOwnProperty(Re)) {
            var De = me[Re];
            if (De != null) {
              var Ue = Re.indexOf("--") === 0;
              ve += Ce + (Ue ? Re : s_(Re)) + ":", ve += sm(Re, De, Ue), Ce = ";";
            }
          }
        return ve || null;
      }
    }
    function ag(me, ve) {
      var Ce = me.style;
      for (var Re in ve)
        if (ve.hasOwnProperty(Re)) {
          var De = Re.indexOf("--") === 0;
          De || l_(Re, ve[Re]);
          var Ue = sm(Re, ve[Re], De);
          Re === "float" && (Re = "cssFloat"), De ? Ce.setProperty(Re, Ue) : Ce[Re] = Ue;
        }
    }
    function d_(me) {
      return me == null || typeof me == "boolean" || me === "";
    }
    function Hs(me) {
      var ve = {};
      for (var Ce in me)
        for (var Re = Qv[Ce] || [Ce], De = 0; De < Re.length; De++)
          ve[Re[De]] = Ce;
      return ve;
    }
    function Jf(me, ve) {
      {
        if (!ve)
          return;
        var Ce = Hs(me), Re = Hs(ve), De = {};
        for (var Ue in Ce) {
          var Ye = Ce[Ue], et = Re[Ue];
          if (et && Ye !== et) {
            var at = Ye + "," + et;
            if (De[at])
              continue;
            De[at] = !0, _e("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", d_(me[Ye]) ? "Removing" : "Updating", Ye, et);
          }
        }
      }
    }
    var ig = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, sg = zr({ menuitem: !0 }, ig), ug = "__html";
    function lm(me, ve) {
      if (ve) {
        if (sg[me] && (ve.children != null || ve.dangerouslySetInnerHTML != null))
          throw new Error(me + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (ve.dangerouslySetInnerHTML != null) {
          if (ve.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof ve.dangerouslySetInnerHTML != "object" || !(ug in ve.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!ve.suppressContentEditableWarning && ve.contentEditable && ve.children != null && _e("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), ve.style != null && typeof ve.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function il(me, ve) {
      if (me.indexOf("-") === -1)
        return typeof ve.is == "string";
      switch (me) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var cm = { accept: "accept", acceptcharset: "acceptCharset", "accept-charset": "acceptCharset", accesskey: "accessKey", action: "action", allowfullscreen: "allowFullScreen", alt: "alt", as: "as", async: "async", autocapitalize: "autoCapitalize", autocomplete: "autoComplete", autocorrect: "autoCorrect", autofocus: "autoFocus", autoplay: "autoPlay", autosave: "autoSave", capture: "capture", cellpadding: "cellPadding", cellspacing: "cellSpacing", challenge: "challenge", charset: "charSet", checked: "checked", children: "children", cite: "cite", class: "className", classid: "classID", classname: "className", cols: "cols", colspan: "colSpan", content: "content", contenteditable: "contentEditable", contextmenu: "contextMenu", controls: "controls", controlslist: "controlsList", coords: "coords", crossorigin: "crossOrigin", dangerouslysetinnerhtml: "dangerouslySetInnerHTML", data: "data", datetime: "dateTime", default: "default", defaultchecked: "defaultChecked", defaultvalue: "defaultValue", defer: "defer", dir: "dir", disabled: "disabled", disablepictureinpicture: "disablePictureInPicture", disableremoteplayback: "disableRemotePlayback", download: "download", draggable: "draggable", enctype: "encType", enterkeyhint: "enterKeyHint", for: "htmlFor", form: "form", formmethod: "formMethod", formaction: "formAction", formenctype: "formEncType", formnovalidate: "formNoValidate", formtarget: "formTarget", frameborder: "frameBorder", headers: "headers", height: "height", hidden: "hidden", high: "high", href: "href", hreflang: "hrefLang", htmlfor: "htmlFor", httpequiv: "httpEquiv", "http-equiv": "httpEquiv", icon: "icon", id: "id", imagesizes: "imageSizes", imagesrcset: "imageSrcSet", innerhtml: "innerHTML", inputmode: "inputMode", integrity: "integrity", is: "is", itemid: "itemID", itemprop: "itemProp", itemref: "itemRef", itemscope: "itemScope", itemtype: "itemType", keyparams: "keyParams", keytype: "keyType", kind: "kind", label: "label", lang: "lang", list: "list", loop: "loop", low: "low", manifest: "manifest", marginwidth: "marginWidth", marginheight: "marginHeight", max: "max", maxlength: "maxLength", media: "media", mediagroup: "mediaGroup", method: "method", min: "min", minlength: "minLength", multiple: "multiple", muted: "muted", name: "name", nomodule: "noModule", nonce: "nonce", novalidate: "noValidate", open: "open", optimum: "optimum", pattern: "pattern", placeholder: "placeholder", playsinline: "playsInline", poster: "poster", preload: "preload", profile: "profile", radiogroup: "radioGroup", readonly: "readOnly", referrerpolicy: "referrerPolicy", rel: "rel", required: "required", reversed: "reversed", role: "role", rows: "rows", rowspan: "rowSpan", sandbox: "sandbox", scope: "scope", scoped: "scoped", scrolling: "scrolling", seamless: "seamless", selected: "selected", shape: "shape", size: "size", sizes: "sizes", span: "span", spellcheck: "spellCheck", src: "src", srcdoc: "srcDoc", srclang: "srcLang", srcset: "srcSet", start: "start", step: "step", style: "style", summary: "summary", tabindex: "tabIndex", target: "target", title: "title", type: "type", usemap: "useMap", value: "value", width: "width", wmode: "wmode", wrap: "wrap", about: "about", accentheight: "accentHeight", "accent-height": "accentHeight", accumulate: "accumulate", additive: "additive", alignmentbaseline: "alignmentBaseline", "alignment-baseline": "alignmentBaseline", allowreorder: "allowReorder", alphabetic: "alphabetic", amplitude: "amplitude", arabicform: "arabicForm", "arabic-form": "arabicForm", ascent: "ascent", attributename: "attributeName", attributetype: "attributeType", autoreverse: "autoReverse", azimuth: "azimuth", basefrequency: "baseFrequency", baselineshift: "baselineShift", "baseline-shift": "baselineShift", baseprofile: "baseProfile", bbox: "bbox", begin: "begin", bias: "bias", by: "by", calcmode: "calcMode", capheight: "capHeight", "cap-height": "capHeight", clip: "clip", clippath: "clipPath", "clip-path": "clipPath", clippathunits: "clipPathUnits", cliprule: "clipRule", "clip-rule": "clipRule", color: "color", colorinterpolation: "colorInterpolation", "color-interpolation": "colorInterpolation", colorinterpolationfilters: "colorInterpolationFilters", "color-interpolation-filters": "colorInterpolationFilters", colorprofile: "colorProfile", "color-profile": "colorProfile", colorrendering: "colorRendering", "color-rendering": "colorRendering", contentscripttype: "contentScriptType", contentstyletype: "contentStyleType", cursor: "cursor", cx: "cx", cy: "cy", d: "d", datatype: "datatype", decelerate: "decelerate", descent: "descent", diffuseconstant: "diffuseConstant", direction: "direction", display: "display", divisor: "divisor", dominantbaseline: "dominantBaseline", "dominant-baseline": "dominantBaseline", dur: "dur", dx: "dx", dy: "dy", edgemode: "edgeMode", elevation: "elevation", enablebackground: "enableBackground", "enable-background": "enableBackground", end: "end", exponent: "exponent", externalresourcesrequired: "externalResourcesRequired", fill: "fill", fillopacity: "fillOpacity", "fill-opacity": "fillOpacity", fillrule: "fillRule", "fill-rule": "fillRule", filter: "filter", filterres: "filterRes", filterunits: "filterUnits", floodopacity: "floodOpacity", "flood-opacity": "floodOpacity", floodcolor: "floodColor", "flood-color": "floodColor", focusable: "focusable", fontfamily: "fontFamily", "font-family": "fontFamily", fontsize: "fontSize", "font-size": "fontSize", fontsizeadjust: "fontSizeAdjust", "font-size-adjust": "fontSizeAdjust", fontstretch: "fontStretch", "font-stretch": "fontStretch", fontstyle: "fontStyle", "font-style": "fontStyle", fontvariant: "fontVariant", "font-variant": "fontVariant", fontweight: "fontWeight", "font-weight": "fontWeight", format: "format", from: "from", fx: "fx", fy: "fy", g1: "g1", g2: "g2", glyphname: "glyphName", "glyph-name": "glyphName", glyphorientationhorizontal: "glyphOrientationHorizontal", "glyph-orientation-horizontal": "glyphOrientationHorizontal", glyphorientationvertical: "glyphOrientationVertical", "glyph-orientation-vertical": "glyphOrientationVertical", glyphref: "glyphRef", gradienttransform: "gradientTransform", gradientunits: "gradientUnits", hanging: "hanging", horizadvx: "horizAdvX", "horiz-adv-x": "horizAdvX", horizoriginx: "horizOriginX", "horiz-origin-x": "horizOriginX", ideographic: "ideographic", imagerendering: "imageRendering", "image-rendering": "imageRendering", in2: "in2", in: "in", inlist: "inlist", intercept: "intercept", k1: "k1", k2: "k2", k3: "k3", k4: "k4", k: "k", kernelmatrix: "kernelMatrix", kernelunitlength: "kernelUnitLength", kerning: "kerning", keypoints: "keyPoints", keysplines: "keySplines", keytimes: "keyTimes", lengthadjust: "lengthAdjust", letterspacing: "letterSpacing", "letter-spacing": "letterSpacing", lightingcolor: "lightingColor", "lighting-color": "lightingColor", limitingconeangle: "limitingConeAngle", local: "local", markerend: "markerEnd", "marker-end": "markerEnd", markerheight: "markerHeight", markermid: "markerMid", "marker-mid": "markerMid", markerstart: "markerStart", "marker-start": "markerStart", markerunits: "markerUnits", markerwidth: "markerWidth", mask: "mask", maskcontentunits: "maskContentUnits", maskunits: "maskUnits", mathematical: "mathematical", mode: "mode", numoctaves: "numOctaves", offset: "offset", opacity: "opacity", operator: "operator", order: "order", orient: "orient", orientation: "orientation", origin: "origin", overflow: "overflow", overlineposition: "overlinePosition", "overline-position": "overlinePosition", overlinethickness: "overlineThickness", "overline-thickness": "overlineThickness", paintorder: "paintOrder", "paint-order": "paintOrder", panose1: "panose1", "panose-1": "panose1", pathlength: "pathLength", patterncontentunits: "patternContentUnits", patterntransform: "patternTransform", patternunits: "patternUnits", pointerevents: "pointerEvents", "pointer-events": "pointerEvents", points: "points", pointsatx: "pointsAtX", pointsaty: "pointsAtY", pointsatz: "pointsAtZ", prefix: "prefix", preservealpha: "preserveAlpha", preserveaspectratio: "preserveAspectRatio", primitiveunits: "primitiveUnits", property: "property", r: "r", radius: "radius", refx: "refX", refy: "refY", renderingintent: "renderingIntent", "rendering-intent": "renderingIntent", repeatcount: "repeatCount", repeatdur: "repeatDur", requiredextensions: "requiredExtensions", requiredfeatures: "requiredFeatures", resource: "resource", restart: "restart", result: "result", results: "results", rotate: "rotate", rx: "rx", ry: "ry", scale: "scale", security: "security", seed: "seed", shaperendering: "shapeRendering", "shape-rendering": "shapeRendering", slope: "slope", spacing: "spacing", specularconstant: "specularConstant", specularexponent: "specularExponent", speed: "speed", spreadmethod: "spreadMethod", startoffset: "startOffset", stddeviation: "stdDeviation", stemh: "stemh", stemv: "stemv", stitchtiles: "stitchTiles", stopcolor: "stopColor", "stop-color": "stopColor", stopopacity: "stopOpacity", "stop-opacity": "stopOpacity", strikethroughposition: "strikethroughPosition", "strikethrough-position": "strikethroughPosition", strikethroughthickness: "strikethroughThickness", "strikethrough-thickness": "strikethroughThickness", string: "string", stroke: "stroke", strokedasharray: "strokeDasharray", "stroke-dasharray": "strokeDasharray", strokedashoffset: "strokeDashoffset", "stroke-dashoffset": "strokeDashoffset", strokelinecap: "strokeLinecap", "stroke-linecap": "strokeLinecap", strokelinejoin: "strokeLinejoin", "stroke-linejoin": "strokeLinejoin", strokemiterlimit: "strokeMiterlimit", "stroke-miterlimit": "strokeMiterlimit", strokewidth: "strokeWidth", "stroke-width": "strokeWidth", strokeopacity: "strokeOpacity", "stroke-opacity": "strokeOpacity", suppresscontenteditablewarning: "suppressContentEditableWarning", suppresshydrationwarning: "suppressHydrationWarning", surfacescale: "surfaceScale", systemlanguage: "systemLanguage", tablevalues: "tableValues", targetx: "targetX", targety: "targetY", textanchor: "textAnchor", "text-anchor": "textAnchor", textdecoration: "textDecoration", "text-decoration": "textDecoration", textlength: "textLength", textrendering: "textRendering", "text-rendering": "textRendering", to: "to", transform: "transform", typeof: "typeof", u1: "u1", u2: "u2", underlineposition: "underlinePosition", "underline-position": "underlinePosition", underlinethickness: "underlineThickness", "underline-thickness": "underlineThickness", unicode: "unicode", unicodebidi: "unicodeBidi", "unicode-bidi": "unicodeBidi", unicoderange: "unicodeRange", "unicode-range": "unicodeRange", unitsperem: "unitsPerEm", "units-per-em": "unitsPerEm", unselectable: "unselectable", valphabetic: "vAlphabetic", "v-alphabetic": "vAlphabetic", values: "values", vectoreffect: "vectorEffect", "vector-effect": "vectorEffect", version: "version", vertadvy: "vertAdvY", "vert-adv-y": "vertAdvY", vertoriginx: "vertOriginX", "vert-origin-x": "vertOriginX", vertoriginy: "vertOriginY", "vert-origin-y": "vertOriginY", vhanging: "vHanging", "v-hanging": "vHanging", videographic: "vIdeographic", "v-ideographic": "vIdeographic", viewbox: "viewBox", viewtarget: "viewTarget", visibility: "visibility", vmathematical: "vMathematical", "v-mathematical": "vMathematical", vocab: "vocab", widths: "widths", wordspacing: "wordSpacing", "word-spacing": "wordSpacing", writingmode: "writingMode", "writing-mode": "writingMode", x1: "x1", x2: "x2", x: "x", xchannelselector: "xChannelSelector", xheight: "xHeight", "x-height": "xHeight", xlinkactuate: "xlinkActuate", "xlink:actuate": "xlinkActuate", xlinkarcrole: "xlinkArcrole", "xlink:arcrole": "xlinkArcrole", xlinkhref: "xlinkHref", "xlink:href": "xlinkHref", xlinkrole: "xlinkRole", "xlink:role": "xlinkRole", xlinkshow: "xlinkShow", "xlink:show": "xlinkShow", xlinktitle: "xlinkTitle", "xlink:title": "xlinkTitle", xlinktype: "xlinkType", "xlink:type": "xlinkType", xmlbase: "xmlBase", "xml:base": "xmlBase", xmllang: "xmlLang", "xml:lang": "xmlLang", xmlns: "xmlns", "xml:space": "xmlSpace", xmlnsxlink: "xmlnsXlink", "xmlns:xlink": "xmlnsXlink", xmlspace: "xmlSpace", y1: "y1", y2: "y2", y: "y", ychannelselector: "yChannelSelector", z: "z", zoomandpan: "zoomAndPan" }, lg = { "aria-current": 0, "aria-description": 0, "aria-details": 0, "aria-disabled": 0, "aria-hidden": 0, "aria-invalid": 0, "aria-keyshortcuts": 0, "aria-label": 0, "aria-roledescription": 0, "aria-autocomplete": 0, "aria-checked": 0, "aria-expanded": 0, "aria-haspopup": 0, "aria-level": 0, "aria-modal": 0, "aria-multiline": 0, "aria-multiselectable": 0, "aria-orientation": 0, "aria-placeholder": 0, "aria-pressed": 0, "aria-readonly": 0, "aria-required": 0, "aria-selected": 0, "aria-sort": 0, "aria-valuemax": 0, "aria-valuemin": 0, "aria-valuenow": 0, "aria-valuetext": 0, "aria-atomic": 0, "aria-busy": 0, "aria-live": 0, "aria-relevant": 0, "aria-dropeffect": 0, "aria-grabbed": 0, "aria-activedescendant": 0, "aria-colcount": 0, "aria-colindex": 0, "aria-colspan": 0, "aria-controls": 0, "aria-describedby": 0, "aria-errormessage": 0, "aria-flowto": 0, "aria-labelledby": 0, "aria-owns": 0, "aria-posinset": 0, "aria-rowcount": 0, "aria-rowindex": 0, "aria-rowspan": 0, "aria-setsize": 0 }, du = {}, tb = new RegExp("^(aria)-[" + Cn + "]*$"), ep = new RegExp("^(aria)[A-Z][" + Cn + "]*$");
    function nb(me, ve) {
      {
        if ($o.call(du, ve) && du[ve])
          return !0;
        if (ep.test(ve)) {
          var Ce = "aria-" + ve.slice(4).toLowerCase(), Re = lg.hasOwnProperty(Ce) ? Ce : null;
          if (Re == null)
            return _e("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", ve), du[ve] = !0, !0;
          if (ve !== Re)
            return _e("Invalid ARIA attribute `%s`. Did you mean `%s`?", ve, Re), du[ve] = !0, !0;
        }
        if (tb.test(ve)) {
          var De = ve.toLowerCase(), Ue = lg.hasOwnProperty(De) ? De : null;
          if (Ue == null)
            return du[ve] = !0, !1;
          if (ve !== Ue)
            return _e("Unknown ARIA attribute `%s`. Did you mean `%s`?", ve, Ue), du[ve] = !0, !0;
        }
      }
      return !0;
    }
    function cg(me, ve) {
      {
        var Ce = [];
        for (var Re in ve) {
          var De = nb(me, Re);
          De || Ce.push(Re);
        }
        var Ue = Ce.map(function(Ye) {
          return "`" + Ye + "`";
        }).join(", ");
        Ce.length === 1 ? _e("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ue, me) : Ce.length > 1 && _e("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Ue, me);
      }
    }
    function dm(me, ve) {
      il(me, ve) || cg(me, ve);
    }
    var Xc = !1;
    function rb(me, ve) {
      {
        if (me !== "input" && me !== "textarea" && me !== "select")
          return;
        ve != null && ve.value === null && !Xc && (Xc = !0, me === "select" && ve.multiple ? _e("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", me) : _e("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", me));
      }
    }
    var ob = function() {
    };
    {
      var Fa = {}, ab = /^on./, dg = /^on[^A-Z]/, fg = new RegExp("^(aria)-[" + Cn + "]*$"), pg = new RegExp("^(aria)[A-Z][" + Cn + "]*$");
      ob = function(me, ve, Ce, Re) {
        if ($o.call(Fa, ve) && Fa[ve])
          return !0;
        var De = ve.toLowerCase();
        if (De === "onfocusin" || De === "onfocusout")
          return _e("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Fa[ve] = !0, !0;
        if (Re != null) {
          var Ue = Re.registrationNameDependencies, Ye = Re.possibleRegistrationNames;
          if (Ue.hasOwnProperty(ve))
            return !0;
          var et = Ye.hasOwnProperty(De) ? Ye[De] : null;
          if (et != null)
            return _e("Invalid event handler property `%s`. Did you mean `%s`?", ve, et), Fa[ve] = !0, !0;
          if (ab.test(ve))
            return _e("Unknown event handler property `%s`. It will be ignored.", ve), Fa[ve] = !0, !0;
        } else if (ab.test(ve))
          return dg.test(ve) && _e("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", ve), Fa[ve] = !0, !0;
        if (fg.test(ve) || pg.test(ve))
          return !0;
        if (De === "innerhtml")
          return _e("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Fa[ve] = !0, !0;
        if (De === "aria")
          return _e("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Fa[ve] = !0, !0;
        if (De === "is" && Ce !== null && Ce !== void 0 && typeof Ce != "string")
          return _e("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof Ce), Fa[ve] = !0, !0;
        if (typeof Ce == "number" && isNaN(Ce))
          return _e("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", ve), Fa[ve] = !0, !0;
        var at = bo(ve), yt = at !== null && at.type === da;
        if (cm.hasOwnProperty(De)) {
          var bt = cm[De];
          if (bt !== ve)
            return _e("Invalid DOM property `%s`. Did you mean `%s`?", ve, bt), Fa[ve] = !0, !0;
        } else if (!yt && ve !== De)
          return _e("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", ve, De), Fa[ve] = !0, !0;
        return typeof Ce == "boolean" && Tr(ve, Ce, at, !1) ? (Ce ? _e('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', Ce, ve, ve, Ce, ve) : _e('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', Ce, ve, ve, Ce, ve, ve, ve), Fa[ve] = !0, !0) : yt ? !0 : Tr(ve, Ce, at, !1) ? (Fa[ve] = !0, !1) : ((Ce === "false" || Ce === "true") && at !== null && at.type === jo && (_e("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", Ce, ve, Ce === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', ve, Ce), Fa[ve] = !0), !0);
      };
    }
    var hg = function(me, ve, Ce) {
      {
        var Re = [];
        for (var De in ve) {
          var Ue = ob(me, De, ve[De], Ce);
          Ue || Re.push(De);
        }
        var Ye = Re.map(function(et) {
          return "`" + et + "`";
        }).join(", ");
        Re.length === 1 ? _e("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Ye, me) : Re.length > 1 && _e("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Ye, me);
      }
    };
    function mg(me, ve, Ce) {
      il(me, ve) || hg(me, ve, Ce);
    }
    var sl = 1, sf = 2, uf = 4, yg = sl | sf | uf, Vl = null;
    function tp(me) {
      Vl !== null && _e("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Vl = me;
    }
    function f_() {
      Vl === null && _e("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Vl = null;
    }
    function bg(me) {
      return me === Vl;
    }
    function fm(me) {
      var ve = me.target || me.srcElement || window;
      return ve.correspondingUseElement && (ve = ve.correspondingUseElement), ve.nodeType === al ? ve.parentNode : ve;
    }
    var Ao = null, Hl = null, ul = null;
    function lf(me) {
      var ve = Rf(me);
      if (ve) {
        if (typeof Ao != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var Ce = ve.stateNode;
        if (Ce) {
          var Re = _0(Ce);
          Ao(ve.stateNode, ve.type, Re);
        }
      }
    }
    function vg(me) {
      Ao = me;
    }
    function pm(me) {
      Hl ? ul ? ul.push(me) : ul = [me] : Hl = me;
    }
    function hp() {
      return Hl !== null || ul !== null;
    }
    function mp() {
      if (Hl) {
        var me = Hl, ve = ul;
        if (Hl = null, ul = null, lf(me), ve)
          for (var Ce = 0; Ce < ve.length; Ce++)
            lf(ve[Ce]);
      }
    }
    var Jc = function(me, ve) {
      return me(ve);
    }, ib = function() {
    }, sb = !1;
    function p_() {
      var me = hp();
      me && (ib(), mp());
    }
    function ub(me, ve, Ce) {
      if (sb)
        return me(ve, Ce);
      sb = !0;
      try {
        return Jc(me, ve, Ce);
      } finally {
        sb = !1, p_();
      }
    }
    function hm(me, ve, Ce) {
      Jc = me, ib = Ce;
    }
    function mm(me) {
      return me === "button" || me === "input" || me === "select" || me === "textarea";
    }
    function lb(me, ve, Ce) {
      switch (me) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(Ce.disabled && mm(ve));
        default:
          return !1;
      }
    }
    function ed(me, ve) {
      var Ce = me.stateNode;
      if (Ce === null)
        return null;
      var Re = _0(Ce);
      if (Re === null)
        return null;
      var De = Re[ve];
      if (lb(ve, me.type, Re))
        return null;
      if (De && typeof De != "function")
        throw new Error("Expected `" + ve + "` listener to be a function, instead got a value of `" + typeof De + "` type.");
      return De;
    }
    var yp = !1;
    if (Kr)
      try {
        var td = {};
        Object.defineProperty(td, "passive", { get: function() {
          yp = !0;
        } }), window.addEventListener("test", td, td), window.removeEventListener("test", td, td);
      } catch {
        yp = !1;
      }
    function gg(me, ve, Ce, Re, De, Ue, Ye, et, at) {
      var yt = Array.prototype.slice.call(arguments, 3);
      try {
        ve.apply(Ce, yt);
      } catch (bt) {
        this.onError(bt);
      }
    }
    var cb = gg;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var db = document.createElement("react");
      cb = function(me, ve, Ce, Re, De, Ue, Ye, et, at) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var yt = document.createEvent("Event"), bt = !1, Ut = !0, jt = window.event, tn = Object.getOwnPropertyDescriptor(window, "event");
        function nn() {
          db.removeEventListener(Qt, Fn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = jt);
        }
        var bn = Array.prototype.slice.call(arguments, 3);
        function Fn() {
          bt = !0, nn(), ve.apply(Ce, bn), Ut = !1;
        }
        var sr, wr = !1, Zr = !1;
        function Ur(yn) {
          if (sr = yn.error, wr = !0, sr === null && yn.colno === 0 && yn.lineno === 0 && (Zr = !0), yn.defaultPrevented && sr != null && typeof sr == "object")
            try {
              sr._suppressLogging = !0;
            } catch {
            }
        }
        var Qt = "react-" + (me || "invokeguardedcallback");
        if (window.addEventListener("error", Ur), db.addEventListener(Qt, Fn, !1), yt.initEvent(Qt, !1, !1), db.dispatchEvent(yt), tn && Object.defineProperty(window, "event", tn), bt && Ut && (wr ? Zr && (sr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : sr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(sr)), window.removeEventListener("error", Ur), !bt)
          return nn(), gg.apply(this, arguments);
      };
    }
    var m_ = cb, Zl = !1, fu = null, bp = !1, Yl = null, zu = { onError: function(me) {
      Zl = !0, fu = me;
    } };
    function nd(me, ve, Ce, Re, De, Ue, Ye, et, at) {
      Zl = !1, fu = null, m_.apply(zu, arguments);
    }
    function ll(me, ve, Ce, Re, De, Ue, Ye, et, at) {
      if (nd.apply(this, arguments), Zl) {
        var yt = pb();
        bp || (bp = !0, Yl = yt);
      }
    }
    function fb() {
      if (bp) {
        var me = Yl;
        throw bp = !1, Yl = null, me;
      }
    }
    function y_() {
      return Zl;
    }
    function pb() {
      if (Zl) {
        var me = fu;
        return Zl = !1, fu = null, me;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Zs(me) {
      return me._reactInternals;
    }
    function gp(me) {
      return me._reactInternals !== void 0;
    }
    function cf(me, ve) {
      me._reactInternals = ve;
    }
    var hr = 0, Ql = 1, Lo = 2, Br = 4, yo = 16, go = 32, Uu = 64, Cr = 128, ua = 256, ns = 512, qs = 1024, Go = 2048, Ws = 4096, Xl = 8192, wp = 16384, ym = Go | Br | Uu | ns | qs | wp, wg = 32767, Ts = 32768, za = 65536, _p = 131072, hb = 1048576, mb = 2097152, rs = 4194304, Jl = 8388608, os = 16777216, rd = 33554432, df = Br | qs | 0, as = Lo | Br | yo | go | ns | Ws | Xl, Ii = Br | Uu | ns | Xl, Gs = Go | yo, ci = rs | Jl | mb, cl = fe.ReactCurrentOwner;
    function Os(me) {
      var ve = me, Ce = me;
      if (me.alternate)
        for (; ve.return; )
          ve = ve.return;
      else {
        var Re = ve;
        do
          ve = Re, (ve.flags & (Lo | Ws)) !== hr && (Ce = ve.return), Re = ve.return;
        while (Re);
      }
      return ve.tag === Me ? Ce : null;
    }
    function yb(me) {
      if (me.tag === ht) {
        var ve = me.memoizedState;
        if (ve === null) {
          var Ce = me.alternate;
          Ce !== null && (ve = Ce.memoizedState);
        }
        if (ve !== null)
          return ve.dehydrated;
      }
      return null;
    }
    function bm(me) {
      return me.tag === Me ? me.stateNode.containerInfo : null;
    }
    function bb(me) {
      return Os(me) === me;
    }
    function As(me) {
      {
        var ve = cl.current;
        if (ve !== null && ve.tag === $e) {
          var Ce = ve, Re = Ce.stateNode;
          Re._warnedAboutRefsInRender || _e("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ar(Ce) || "A component"), Re._warnedAboutRefsInRender = !0;
        }
      }
      var De = Zs(me);
      return De ? Os(De) === De : !1;
    }
    function is(me) {
      if (Os(me) !== me)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Bo(me) {
      var ve = me.alternate;
      if (!ve) {
        var Ce = Os(me);
        if (Ce === null)
          throw new Error("Unable to find node on an unmounted component.");
        return Ce !== me ? null : me;
      }
      for (var Re = me, De = ve; ; ) {
        var Ue = Re.return;
        if (Ue === null)
          break;
        var Ye = Ue.alternate;
        if (Ye === null) {
          var et = Ue.return;
          if (et !== null) {
            Re = De = et;
            continue;
          }
          break;
        }
        if (Ue.child === Ye.child) {
          for (var at = Ue.child; at; ) {
            if (at === Re)
              return is(Ue), me;
            if (at === De)
              return is(Ue), ve;
            at = at.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (Re.return !== De.return)
          Re = Ue, De = Ye;
        else {
          for (var yt = !1, bt = Ue.child; bt; ) {
            if (bt === Re) {
              yt = !0, Re = Ue, De = Ye;
              break;
            }
            if (bt === De) {
              yt = !0, De = Ue, Re = Ye;
              break;
            }
            bt = bt.sibling;
          }
          if (!yt) {
            for (bt = Ye.child; bt; ) {
              if (bt === Re) {
                yt = !0, Re = Ye, De = Ue;
                break;
              }
              if (bt === De) {
                yt = !0, De = Ye, Re = Ue;
                break;
              }
              bt = bt.sibling;
            }
            if (!yt)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (Re.alternate !== De)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (Re.tag !== Me)
        throw new Error("Unable to find node on an unmounted component.");
      return Re.stateNode.current === Re ? me : ve;
    }
    function Ys(me) {
      var ve = Bo(me);
      return ve !== null ? vb(ve) : null;
    }
    function vb(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var ve = me.child; ve !== null; ) {
        var Ce = vb(ve);
        if (Ce !== null)
          return Ce;
        ve = ve.sibling;
      }
      return null;
    }
    function _g(me) {
      var ve = Bo(me);
      return ve !== null ? vm(ve) : null;
    }
    function vm(me) {
      if (me.tag === ze || me.tag === He)
        return me;
      for (var ve = me.child; ve !== null; ) {
        if (ve.tag !== Be) {
          var Ce = vm(ve);
          if (Ce !== null)
            return Ce;
        }
        ve = ve.sibling;
      }
      return null;
    }
    var gm = ae.unstable_scheduleCallback, xg = ae.unstable_cancelCallback, wm = ae.unstable_shouldYield, Eg = ae.unstable_requestPaint, ea = ae.unstable_now, gb = ae.unstable_getCurrentPriorityLevel, _m = ae.unstable_ImmediatePriority, Cs = ae.unstable_UserBlockingPriority, Vu = ae.unstable_NormalPriority, xm = ae.unstable_LowPriority, ec = ae.unstable_IdlePriority, wb = ae.unstable_yieldValue, _b = ae.unstable_setDisableYieldValue, tc = null, Ua = null, Ln = null, fa = !1, di = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function xb(me) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var ve = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (ve.isDisabled)
        return !0;
      if (!ve.supportsFiber)
        return _e("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        _n && (me = zr({}, me, { getLaneLabelMap: rc, injectProfilingHooks: fl })), tc = ve.inject(me), Ua = ve;
      } catch (Ce) {
        _e("React instrumentation encountered an error: %s.", Ce);
      }
      return !!ve.checkDCE;
    }
    function Sg(me, ve) {
      if (Ua && typeof Ua.onScheduleFiberRoot == "function")
        try {
          Ua.onScheduleFiberRoot(tc, me, ve);
        } catch (Ce) {
          fa || (fa = !0, _e("React instrumentation encountered an error: %s", Ce));
        }
    }
    function dl(me, ve) {
      if (Ua && typeof Ua.onCommitFiberRoot == "function")
        try {
          var Ce = (me.current.flags & Cr) === Cr;
          if (Vn) {
            var Re;
            switch (ve) {
              case cs:
                Re = _m;
                break;
              case Xs:
                Re = Cs;
                break;
              case fi:
                Re = Vu;
                break;
              case ey:
                Re = ec;
                break;
              default:
                Re = Vu;
                break;
            }
            Ua.onCommitFiberRoot(tc, me, Re, Ce);
          }
        } catch (De) {
          fa || (fa = !0, _e("React instrumentation encountered an error: %s", De));
        }
    }
    function nc(me) {
      if (Ua && typeof Ua.onPostCommitFiberRoot == "function")
        try {
          Ua.onPostCommitFiberRoot(tc, me);
        } catch (ve) {
          fa || (fa = !0, _e("React instrumentation encountered an error: %s", ve));
        }
    }
    function Eb(me) {
      if (Ua && typeof Ua.onCommitFiberUnmount == "function")
        try {
          Ua.onCommitFiberUnmount(tc, me);
        } catch (ve) {
          fa || (fa = !0, _e("React instrumentation encountered an error: %s", ve));
        }
    }
    function Ia(me) {
      if (typeof wb == "function" && (_b(me), ge(me)), Ua && typeof Ua.setStrictMode == "function")
        try {
          Ua.setStrictMode(tc, me);
        } catch (ve) {
          fa || (fa = !0, _e("React instrumentation encountered an error: %s", ve));
        }
    }
    function fl(me) {
      Ln = me;
    }
    function rc() {
      {
        for (var me = /* @__PURE__ */ new Map(), ve = 1, Ce = 0; Ce < Fo; Ce++) {
          var Re = b_(ve);
          me.set(ve, Re), ve *= 2;
        }
        return me;
      }
    }
    function Em(me) {
      Ln !== null && typeof Ln.markCommitStarted == "function" && Ln.markCommitStarted(me);
    }
    function Sb() {
      Ln !== null && typeof Ln.markCommitStopped == "function" && Ln.markCommitStopped();
    }
    function ac(me) {
      Ln !== null && typeof Ln.markComponentRenderStarted == "function" && Ln.markComponentRenderStarted(me);
    }
    function od() {
      Ln !== null && typeof Ln.markComponentRenderStopped == "function" && Ln.markComponentRenderStopped();
    }
    function Pg(me) {
      Ln !== null && typeof Ln.markComponentPassiveEffectMountStarted == "function" && Ln.markComponentPassiveEffectMountStarted(me);
    }
    function Pb() {
      Ln !== null && typeof Ln.markComponentPassiveEffectMountStopped == "function" && Ln.markComponentPassiveEffectMountStopped();
    }
    function Sm(me) {
      Ln !== null && typeof Ln.markComponentPassiveEffectUnmountStarted == "function" && Ln.markComponentPassiveEffectUnmountStarted(me);
    }
    function kg() {
      Ln !== null && typeof Ln.markComponentPassiveEffectUnmountStopped == "function" && Ln.markComponentPassiveEffectUnmountStopped();
    }
    function Tg(me) {
      Ln !== null && typeof Ln.markComponentLayoutEffectMountStarted == "function" && Ln.markComponentLayoutEffectMountStarted(me);
    }
    function Og() {
      Ln !== null && typeof Ln.markComponentLayoutEffectMountStopped == "function" && Ln.markComponentLayoutEffectMountStopped();
    }
    function Pm(me) {
      Ln !== null && typeof Ln.markComponentLayoutEffectUnmountStarted == "function" && Ln.markComponentLayoutEffectUnmountStarted(me);
    }
    function ff() {
      Ln !== null && typeof Ln.markComponentLayoutEffectUnmountStopped == "function" && Ln.markComponentLayoutEffectUnmountStopped();
    }
    function km(me, ve, Ce) {
      Ln !== null && typeof Ln.markComponentErrored == "function" && Ln.markComponentErrored(me, ve, Ce);
    }
    function Ag(me, ve, Ce) {
      Ln !== null && typeof Ln.markComponentSuspended == "function" && Ln.markComponentSuspended(me, ve, Ce);
    }
    function Cg(me) {
      Ln !== null && typeof Ln.markLayoutEffectsStarted == "function" && Ln.markLayoutEffectsStarted(me);
    }
    function pf() {
      Ln !== null && typeof Ln.markLayoutEffectsStopped == "function" && Ln.markLayoutEffectsStopped();
    }
    function Ig(me) {
      Ln !== null && typeof Ln.markPassiveEffectsStarted == "function" && Ln.markPassiveEffectsStarted(me);
    }
    function xp() {
      Ln !== null && typeof Ln.markPassiveEffectsStopped == "function" && Ln.markPassiveEffectsStopped();
    }
    function pu(me) {
      Ln !== null && typeof Ln.markRenderStarted == "function" && Ln.markRenderStarted(me);
    }
    function Ep() {
      Ln !== null && typeof Ln.markRenderYielded == "function" && Ln.markRenderYielded();
    }
    function hf() {
      Ln !== null && typeof Ln.markRenderStopped == "function" && Ln.markRenderStopped();
    }
    function ad(me) {
      Ln !== null && typeof Ln.markRenderScheduled == "function" && Ln.markRenderScheduled(me);
    }
    function kb(me, ve) {
      Ln !== null && typeof Ln.markForceUpdateScheduled == "function" && Ln.markForceUpdateScheduled(me, ve);
    }
    function ic(me, ve) {
      Ln !== null && typeof Ln.markStateUpdateScheduled == "function" && Ln.markStateUpdateScheduled(me, ve);
    }
    var vr = 0, Vr = 1, xr = 2, ta = 8, Qs = 16, Tm = Math.clz32 ? Math.clz32 : id, Om = Math.log, Tb = Math.LN2;
    function id(me) {
      var ve = me >>> 0;
      return ve === 0 ? 32 : 31 - (Om(ve) / Tb | 0) | 0;
    }
    var Fo = 31, vn = 0, oo = 0, kr = 1, Hu = 2, Is = 4, ud = 8, Uo = 16, ld = 32, dc = 4194240, bd = 64, Ks = 128, ss = 256, wd = 512, Sp = 1024, Pp = 2048, Am = 4096, Cm = 8192, Im = 16384, $m = 32768, Rm = 65536, Nm = 131072, Mm = 262144, jm = 524288, _d = 1048576, Lm = 2097152, xd = 130023424, pl = 4194304, Dm = 8388608, kp = 16777216, Bm = 33554432, Fm = 67108864, Ob = pl, mf = 134217728, zm = 268435455, yf = 268435456, fc = 536870912, us = 1073741824;
    function b_(me) {
      {
        if (me & kr)
          return "Sync";
        if (me & Hu)
          return "InputContinuousHydration";
        if (me & Is)
          return "InputContinuous";
        if (me & ud)
          return "DefaultHydration";
        if (me & Uo)
          return "Default";
        if (me & ld)
          return "TransitionHydration";
        if (me & dc)
          return "Transition";
        if (me & xd)
          return "Retry";
        if (me & mf)
          return "SelectiveHydration";
        if (me & yf)
          return "IdleHydration";
        if (me & fc)
          return "Idle";
        if (me & us)
          return "Offscreen";
      }
    }
    var Co = -1, Um = bd, Vm = pl;
    function bf(me) {
      switch (ka(me)) {
        case kr:
          return kr;
        case Hu:
          return Hu;
        case Is:
          return Is;
        case ud:
          return ud;
        case Uo:
          return Uo;
        case ld:
          return ld;
        case bd:
        case Ks:
        case ss:
        case wd:
        case Sp:
        case Pp:
        case Am:
        case Cm:
        case Im:
        case $m:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case _d:
        case Lm:
          return me & dc;
        case pl:
        case Dm:
        case kp:
        case Bm:
        case Fm:
          return me & xd;
        case mf:
          return mf;
        case yf:
          return yf;
        case fc:
          return fc;
        case us:
          return us;
        default:
          return _e("Should have found matching lanes. This is a bug in React."), me;
      }
    }
    function Tp(me, ve) {
      var Ce = me.pendingLanes;
      if (Ce === vn)
        return vn;
      var Re = vn, De = me.suspendedLanes, Ue = me.pingedLanes, Ye = Ce & zm;
      if (Ye !== vn) {
        var et = Ye & ~De;
        if (et !== vn)
          Re = bf(et);
        else {
          var at = Ye & Ue;
          at !== vn && (Re = bf(at));
        }
      } else {
        var yt = Ce & ~De;
        yt !== vn ? Re = bf(yt) : Ue !== vn && (Re = bf(Ue));
      }
      if (Re === vn)
        return vn;
      if (ve !== vn && ve !== Re && (ve & De) === vn) {
        var bt = ka(Re), Ut = ka(ve);
        if (bt >= Ut || bt === Uo && (Ut & dc) !== vn)
          return ve;
      }
      (Re & Is) !== vn && (Re |= Ce & Uo);
      var jt = me.entangledLanes;
      if (jt !== vn)
        for (var tn = me.entanglements, nn = Re & jt; nn > 0; ) {
          var bn = pc(nn), Fn = 1 << bn;
          Re |= tn[bn], nn &= ~Fn;
        }
      return Re;
    }
    function $g(me, ve) {
      for (var Ce = me.eventTimes, Re = Co; ve > 0; ) {
        var De = pc(ve), Ue = 1 << De, Ye = Ce[De];
        Ye > Re && (Re = Ye), ve &= ~Ue;
      }
      return Re;
    }
    function Hm(me, ve) {
      switch (me) {
        case kr:
        case Hu:
        case Is:
          return ve + 250;
        case ud:
        case Uo:
        case ld:
        case bd:
        case Ks:
        case ss:
        case wd:
        case Sp:
        case Pp:
        case Am:
        case Cm:
        case Im:
        case $m:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case _d:
        case Lm:
          return ve + 5e3;
        case pl:
        case Dm:
        case kp:
        case Bm:
        case Fm:
          return Co;
        case mf:
        case yf:
        case fc:
        case us:
          return Co;
        default:
          return _e("Should have found matching lanes. This is a bug in React."), Co;
      }
    }
    function v_(me, ve) {
      for (var Ce = me.pendingLanes, Re = me.suspendedLanes, De = me.pingedLanes, Ue = me.expirationTimes, Ye = Ce; Ye > 0; ) {
        var et = pc(Ye), at = 1 << et, yt = Ue[et];
        yt === Co ? ((at & Re) === vn || (at & De) !== vn) && (Ue[et] = Hm(at, ve)) : yt <= ve && (me.expiredLanes |= at), Ye &= ~at;
      }
    }
    function g_(me) {
      return bf(me.pendingLanes);
    }
    function Ab(me) {
      var ve = me.pendingLanes & ~us;
      return ve !== vn ? ve : ve & us ? us : vn;
    }
    function vf(me) {
      return (me & kr) !== vn;
    }
    function Ap(me) {
      return (me & zm) !== vn;
    }
    function qm(me) {
      return (me & xd) === me;
    }
    function w_(me) {
      var ve = kr | Is | Uo;
      return (me & ve) === vn;
    }
    function Rg(me) {
      return (me & dc) === me;
    }
    function Cp(me, ve) {
      var Ce = Hu | Is | ud | Uo;
      return (ve & Ce) !== vn;
    }
    function Ng(me, ve) {
      return (ve & me.expiredLanes) !== vn;
    }
    function Cb(me) {
      return (me & dc) !== vn;
    }
    function Ib() {
      var me = Um;
      return Um <<= 1, (Um & dc) === vn && (Um = bd), me;
    }
    function __() {
      var me = Vm;
      return Vm <<= 1, (Vm & xd) === vn && (Vm = pl), me;
    }
    function ka(me) {
      return me & -me;
    }
    function $a(me) {
      return ka(me);
    }
    function pc(me) {
      return 31 - Tm(me);
    }
    function Wm(me) {
      return pc(me);
    }
    function ls(me, ve) {
      return (me & ve) !== vn;
    }
    function Ed(me, ve) {
      return (me & ve) === ve;
    }
    function Fr(me, ve) {
      return me | ve;
    }
    function gf(me, ve) {
      return me & ~ve;
    }
    function $b(me, ve) {
      return me & ve;
    }
    function Rb(me, ve) {
      return me !== oo && me < ve ? me : ve;
    }
    function Gm(me) {
      for (var ve = [], Ce = 0; Ce < Fo; Ce++)
        ve.push(me);
      return ve;
    }
    function wf(me, ve, Ce) {
      me.pendingLanes |= ve, ve !== fc && (me.suspendedLanes = vn, me.pingedLanes = vn);
      var Re = me.eventTimes, De = Wm(ve);
      Re[De] = Ce;
    }
    function Nb(me, ve) {
      me.suspendedLanes |= ve, me.pingedLanes &= ~ve;
      for (var Ce = me.expirationTimes, Re = ve; Re > 0; ) {
        var De = pc(Re), Ue = 1 << De;
        Ce[De] = Co, Re &= ~Ue;
      }
    }
    function Ym(me, ve, Ce) {
      me.pingedLanes |= me.suspendedLanes & ve;
    }
    function Mg(me, ve) {
      var Ce = me.pendingLanes & ~ve;
      me.pendingLanes = ve, me.suspendedLanes = vn, me.pingedLanes = vn, me.expiredLanes &= ve, me.mutableReadLanes &= ve, me.entangledLanes &= ve;
      for (var Re = me.entanglements, De = me.eventTimes, Ue = me.expirationTimes, Ye = Ce; Ye > 0; ) {
        var et = pc(Ye), at = 1 << et;
        Re[et] = vn, De[et] = Co, Ue[et] = Co, Ye &= ~at;
      }
    }
    function Ip(me, ve) {
      for (var Ce = me.entangledLanes |= ve, Re = me.entanglements, De = Ce; De; ) {
        var Ue = pc(De), Ye = 1 << Ue;
        Ye & ve | Re[Ue] & ve && (Re[Ue] |= ve), De &= ~Ye;
      }
    }
    function Qm(me, ve) {
      var Ce = ka(ve), Re;
      switch (Ce) {
        case Is:
          Re = Hu;
          break;
        case Uo:
          Re = ud;
          break;
        case bd:
        case Ks:
        case ss:
        case wd:
        case Sp:
        case Pp:
        case Am:
        case Cm:
        case Im:
        case $m:
        case Rm:
        case Nm:
        case Mm:
        case jm:
        case _d:
        case Lm:
        case pl:
        case Dm:
        case kp:
        case Bm:
        case Fm:
          Re = ld;
          break;
        case fc:
          Re = yf;
          break;
        default:
          Re = oo;
          break;
      }
      return (Re & (me.suspendedLanes | ve)) !== oo ? oo : Re;
    }
    function jg(me, ve, Ce) {
      if (di)
        for (var Re = me.pendingUpdatersLaneMap; Ce > 0; ) {
          var De = Wm(Ce), Ue = 1 << De, Ye = Re[De];
          Ye.add(ve), Ce &= ~Ue;
        }
    }
    function Mb(me, ve) {
      if (di)
        for (var Ce = me.pendingUpdatersLaneMap, Re = me.memoizedUpdaters; ve > 0; ) {
          var De = Wm(ve), Ue = 1 << De, Ye = Ce[De];
          Ye.size > 0 && (Ye.forEach(function(et) {
            var at = et.alternate;
            (at === null || !Re.has(at)) && Re.add(et);
          }), Ye.clear()), ve &= ~Ue;
        }
    }
    function Km(me, ve) {
      return null;
    }
    var cs = kr, Xs = Is, fi = Uo, ey = fc, _f = oo;
    function $s() {
      return _f;
    }
    function Ra(me) {
      _f = me;
    }
    function Lg(me, ve) {
      var Ce = _f;
      try {
        return _f = me, ve();
      } finally {
        _f = Ce;
      }
    }
    function $p(me, ve) {
      return me !== 0 && me < ve ? me : ve;
    }
    function $i(me, ve) {
      return me === 0 || me > ve ? me : ve;
    }
    function jb(me, ve) {
      return me !== 0 && me < ve;
    }
    function Dg(me) {
      var ve = ka(me);
      return jb(cs, ve) ? jb(Xs, ve) ? Ap(ve) ? fi : ey : Xs : cs;
    }
    function Pd(me) {
      var ve = me.current.memoizedState;
      return ve.isDehydrated;
    }
    var pi;
    function x_(me) {
      pi = me;
    }
    function Xn(me) {
      pi(me);
    }
    var hc;
    function Bg(me) {
      hc = me;
    }
    var Lb;
    function E_(me) {
      Lb = me;
    }
    var xf;
    function ty(me) {
      xf = me;
    }
    var ny;
    function Fg(me) {
      ny = me;
    }
    var ry = !1, Rp = [], Zu = null, qu = null, Yo = null, ji = /* @__PURE__ */ new Map(), Js = /* @__PURE__ */ new Map(), hl = [], zg = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset", "submit"];
    function hu(me) {
      return zg.indexOf(me) > -1;
    }
    function Ug(me, ve, Ce, Re, De) {
      return { blockedOn: me, domEventName: ve, eventSystemFlags: Ce, nativeEvent: De, targetContainers: [Re] };
    }
    function mu(me, ve) {
      switch (me) {
        case "focusin":
        case "focusout":
          Zu = null;
          break;
        case "dragenter":
        case "dragleave":
          qu = null;
          break;
        case "mouseover":
        case "mouseout":
          Yo = null;
          break;
        case "pointerover":
        case "pointerout": {
          var Ce = ve.pointerId;
          ji.delete(Ce);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var Re = ve.pointerId;
          Js.delete(Re);
          break;
        }
      }
    }
    function Np(me, ve, Ce, Re, De, Ue) {
      if (me === null || me.nativeEvent !== Ue) {
        var Ye = Ug(ve, Ce, Re, De, Ue);
        if (ve !== null) {
          var et = Rf(ve);
          et !== null && hc(et);
        }
        return Ye;
      }
      me.eventSystemFlags |= Re;
      var at = me.targetContainers;
      return De !== null && at.indexOf(De) === -1 && at.push(De), me;
    }
    function Vg(me, ve, Ce, Re, De) {
      switch (ve) {
        case "focusin": {
          var Ue = De;
          return Zu = Np(Zu, me, ve, Ce, Re, Ue), !0;
        }
        case "dragenter": {
          var Ye = De;
          return qu = Np(qu, me, ve, Ce, Re, Ye), !0;
        }
        case "mouseover": {
          var et = De;
          return Yo = Np(Yo, me, ve, Ce, Re, et), !0;
        }
        case "pointerover": {
          var at = De, yt = at.pointerId;
          return ji.set(yt, Np(ji.get(yt) || null, me, ve, Ce, Re, at)), !0;
        }
        case "gotpointercapture": {
          var bt = De, Ut = bt.pointerId;
          return Js.set(Ut, Np(Js.get(Ut) || null, me, ve, Ce, Re, bt)), !0;
        }
      }
      return !1;
    }
    function Db(me) {
      var ve = Gp(me.target);
      if (ve !== null) {
        var Ce = Os(ve);
        if (Ce !== null) {
          var Re = Ce.tag;
          if (Re === ht) {
            var De = yb(Ce);
            if (De !== null) {
              me.blockedOn = De, ny(me.priority, function() {
                Lb(Ce);
              });
              return;
            }
          } else if (Re === Me) {
            var Ue = Ce.stateNode;
            if (Pd(Ue)) {
              me.blockedOn = bm(Ce);
              return;
            }
          }
        }
      }
      me.blockedOn = null;
    }
    function Hg(me) {
      for (var ve = xf(), Ce = { blockedOn: null, target: me, priority: ve }, Re = 0; Re < hl.length && jb(ve, hl[Re].priority); Re++)
        ;
      hl.splice(Re, 0, Ce), Re === 0 && Db(Ce);
    }
    function Mp(me) {
      if (me.blockedOn !== null)
        return !1;
      for (var ve = me.targetContainers; ve.length > 0; ) {
        var Ce = ve[0], Re = jp(me.domEventName, me.eventSystemFlags, Ce, me.nativeEvent);
        if (Re === null) {
          var De = me.nativeEvent, Ue = new De.constructor(De.type, De);
          tp(Ue), De.target.dispatchEvent(Ue), f_();
        } else {
          var Ye = Rf(Re);
          return Ye !== null && hc(Ye), me.blockedOn = Re, !1;
        }
        ve.shift();
      }
      return !0;
    }
    function Zg(me, ve, Ce) {
      Mp(me) && Ce.delete(ve);
    }
    function oy() {
      ry = !1, Zu !== null && Mp(Zu) && (Zu = null), qu !== null && Mp(qu) && (qu = null), Yo !== null && Mp(Yo) && (Yo = null), ji.forEach(Zg), Js.forEach(Zg);
    }
    function Td(me, ve) {
      me.blockedOn === ve && (me.blockedOn = null, ry || (ry = !0, ae.unstable_scheduleCallback(ae.unstable_NormalPriority, oy)));
    }
    function Ri(me) {
      if (Rp.length > 0) {
        Td(Rp[0], me);
        for (var ve = 1; ve < Rp.length; ve++) {
          var Ce = Rp[ve];
          Ce.blockedOn === me && (Ce.blockedOn = null);
        }
      }
      Zu !== null && Td(Zu, me), qu !== null && Td(qu, me), Yo !== null && Td(Yo, me);
      var Re = function(et) {
        return Td(et, me);
      };
      ji.forEach(Re), Js.forEach(Re);
      for (var De = 0; De < hl.length; De++) {
        var Ue = hl[De];
        Ue.blockedOn === me && (Ue.blockedOn = null);
      }
      for (; hl.length > 0; ) {
        var Ye = hl[0];
        if (Ye.blockedOn !== null)
          break;
        Db(Ye), Ye.blockedOn === null && hl.shift();
      }
    }
    var Hr = fe.ReactCurrentBatchConfig, Ta = !0;
    function pa(me) {
      Ta = !!me;
    }
    function hi() {
      return Ta;
    }
    function Rs(me, ve, Ce) {
      var Re = Sf(ve), De;
      switch (Re) {
        case cs:
          De = Ef;
          break;
        case Xs:
          De = Na;
          break;
        case fi:
        default:
          De = Od;
          break;
      }
      return De.bind(null, ve, Ce, me);
    }
    function Ef(me, ve, Ce, Re) {
      var De = $s(), Ue = Hr.transition;
      Hr.transition = null;
      try {
        Ra(cs), Od(me, ve, Ce, Re);
      } finally {
        Ra(De), Hr.transition = Ue;
      }
    }
    function Na(me, ve, Ce, Re) {
      var De = $s(), Ue = Hr.transition;
      Hr.transition = null;
      try {
        Ra(Xs), Od(me, ve, Ce, Re);
      } finally {
        Ra(De), Hr.transition = Ue;
      }
    }
    function Od(me, ve, Ce, Re) {
      Ta && Ad(me, ve, Ce, Re);
    }
    function Ad(me, ve, Ce, Re) {
      var De = jp(me, ve, Ce, Re);
      if (De === null) {
        z_(me, ve, Re, Cd, Ce), mu(me, Re);
        return;
      }
      if (Vg(De, me, ve, Ce, Re)) {
        Re.stopPropagation();
        return;
      }
      if (mu(me, Re), ve & uf && hu(me)) {
        for (; De !== null; ) {
          var Ue = Rf(De);
          Ue !== null && Xn(Ue);
          var Ye = jp(me, ve, Ce, Re);
          if (Ye === null && z_(me, ve, Re, Cd, Ce), Ye === De)
            break;
          De = Ye;
        }
        De !== null && Re.stopPropagation();
        return;
      }
      z_(me, ve, Re, null, Ce);
    }
    var Cd = null;
    function jp(me, ve, Ce, Re) {
      Cd = null;
      var De = fm(Re), Ue = Gp(De);
      if (Ue !== null) {
        var Ye = Os(Ue);
        if (Ye === null)
          Ue = null;
        else {
          var et = Ye.tag;
          if (et === ht) {
            var at = yb(Ye);
            if (at !== null)
              return at;
            Ue = null;
          } else if (et === Me) {
            var yt = Ye.stateNode;
            if (Pd(yt))
              return bm(Ye);
            Ue = null;
          } else
            Ye !== Ue && (Ue = null);
        }
      }
      return Cd = Ue, null;
    }
    function Sf(me) {
      switch (me) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return cs;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Xs;
        case "message": {
          var ve = gb();
          switch (ve) {
            case _m:
              return cs;
            case Cs:
              return Xs;
            case Vu:
            case xm:
              return fi;
            case ec:
              return ey;
            default:
              return fi;
          }
        }
        default:
          return fi;
      }
    }
    function hs(me, ve, Ce) {
      return me.addEventListener(ve, Ce, !1), Ce;
    }
    function Bb(me, ve, Ce) {
      return me.addEventListener(ve, Ce, !0), Ce;
    }
    function Pf(me, ve, Ce, Re) {
      return me.addEventListener(ve, Ce, { capture: !0, passive: Re }), Ce;
    }
    function ml(me, ve, Ce, Re) {
      return me.addEventListener(ve, Ce, { passive: Re }), Ce;
    }
    var mc = null, Lp = null, eu = null;
    function ay(me) {
      return mc = me, Lp = kf(), !0;
    }
    function yc() {
      mc = null, Lp = null, eu = null;
    }
    function Dp() {
      if (eu)
        return eu;
      var me, ve = Lp, Ce = ve.length, Re, De = kf(), Ue = De.length;
      for (me = 0; me < Ce && ve[me] === De[me]; me++)
        ;
      var Ye = Ce - me;
      for (Re = 1; Re <= Ye && ve[Ce - Re] === De[Ue - Re]; Re++)
        ;
      var et = Re > 1 ? 1 - Re : void 0;
      return eu = De.slice(me, et), eu;
    }
    function kf() {
      return "value" in mc ? mc.value : mc.textContent;
    }
    function Tf(me) {
      var ve, Ce = me.keyCode;
      return "charCode" in me ? (ve = me.charCode, ve === 0 && Ce === 13 && (ve = 13)) : ve = Ce, ve === 10 && (ve = 13), ve >= 32 || ve === 13 ? ve : 0;
    }
    function Id() {
      return !0;
    }
    function Bp() {
      return !1;
    }
    function Io(me) {
      function ve(Ce, Re, De, Ue, Ye) {
        this._reactName = Ce, this._targetInst = De, this.type = Re, this.nativeEvent = Ue, this.target = Ye, this.currentTarget = null;
        for (var et in me)
          if (me.hasOwnProperty(et)) {
            var at = me[et];
            at ? this[et] = at(Ue) : this[et] = Ue[et];
          }
        var yt = Ue.defaultPrevented != null ? Ue.defaultPrevented : Ue.returnValue === !1;
        return yt ? this.isDefaultPrevented = Id : this.isDefaultPrevented = Bp, this.isPropagationStopped = Bp, this;
      }
      return zr(ve.prototype, { preventDefault: function() {
        this.defaultPrevented = !0;
        var Ce = this.nativeEvent;
        Ce && (Ce.preventDefault ? Ce.preventDefault() : typeof Ce.returnValue != "unknown" && (Ce.returnValue = !1), this.isDefaultPrevented = Id);
      }, stopPropagation: function() {
        var Ce = this.nativeEvent;
        Ce && (Ce.stopPropagation ? Ce.stopPropagation() : typeof Ce.cancelBubble != "unknown" && (Ce.cancelBubble = !0), this.isPropagationStopped = Id);
      }, persist: function() {
      }, isPersistent: Id }), ve;
    }
    var Ns = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(me) {
      return me.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, Ms = Io(Ns), Va = zr({}, Ns, { view: 0, detail: 0 }), qg = Io(Va), zp, Up, Vp;
    function bc(me) {
      me !== Vp && (Vp && me.type === "mousemove" ? (zp = me.screenX - Vp.screenX, Up = me.screenY - Vp.screenY) : (zp = 0, Up = 0), Vp = me);
    }
    var Hp = zr({}, Va, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Vb, button: 0, buttons: 0, relatedTarget: function(me) {
      return me.relatedTarget === void 0 ? me.fromElement === me.srcElement ? me.toElement : me.fromElement : me.relatedTarget;
    }, movementX: function(me) {
      return "movementX" in me ? me.movementX : (bc(me), zp);
    }, movementY: function(me) {
      return "movementY" in me ? me.movementY : Up;
    } }), iy = Io(Hp), $d = zr({}, Hp, { dataTransfer: 0 }), Fb = Io($d), Rd = zr({}, Va, { relatedTarget: 0 }), sy = Io(Rd), Wg = zr({}, Ns, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), zb = Io(Wg), uy = zr({}, Ns, { clipboardData: function(me) {
      return "clipboardData" in me ? me.clipboardData : window.clipboardData;
    } }), S_ = Io(uy), P_ = zr({}, Ns, { data: 0 }), Ub = Io(P_), Gg = Ub, Nd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, k_ = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
    function Of(me) {
      if (me.key) {
        var ve = Nd[me.key] || me.key;
        if (ve !== "Unidentified")
          return ve;
      }
      if (me.type === "keypress") {
        var Ce = Tf(me);
        return Ce === 13 ? "Enter" : String.fromCharCode(Ce);
      }
      return me.type === "keydown" || me.type === "keyup" ? k_[me.keyCode] || "Unidentified" : "";
    }
    var Yg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function la(me) {
      var ve = this, Ce = ve.nativeEvent;
      if (Ce.getModifierState)
        return Ce.getModifierState(me);
      var Re = Yg[me];
      return Re ? !!Ce[Re] : !1;
    }
    function Vb(me) {
      return la;
    }
    var Qg = zr({}, Va, { key: Of, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Vb, charCode: function(me) {
      return me.type === "keypress" ? Tf(me) : 0;
    }, keyCode: function(me) {
      return me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    }, which: function(me) {
      return me.type === "keypress" ? Tf(me) : me.type === "keydown" || me.type === "keyup" ? me.keyCode : 0;
    } }), T_ = Io(Qg), O_ = zr({}, Hp, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Hb = Io(O_), Kg = zr({}, Va, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Vb }), A_ = Io(Kg), tu = zr({}, Ns, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Zb = Io(tu), C_ = zr({}, Hp, { deltaX: function(me) {
      return "deltaX" in me ? me.deltaX : "wheelDeltaX" in me ? -me.wheelDeltaX : 0;
    }, deltaY: function(me) {
      return "deltaY" in me ? me.deltaY : "wheelDeltaY" in me ? -me.wheelDeltaY : "wheelDelta" in me ? -me.wheelDelta : 0;
    }, deltaZ: 0, deltaMode: 0 }), vc = Io(C_), ly = [9, 13, 27, 32], gc = 229, Af = Kr && "CompositionEvent" in window, Md = null;
    Kr && "documentMode" in document && (Md = document.documentMode);
    var qb = Kr && "TextEvent" in window && !Md, Xg = Kr && (!Af || Md && Md > 8 && Md <= 11), cy = 32, Jg = String.fromCharCode(cy);
    function e0() {
      Yr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Yr("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Yr("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Yr("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Wb = !1;
    function dy(me) {
      return (me.ctrlKey || me.altKey || me.metaKey) && !(me.ctrlKey && me.altKey);
    }
    function fy(me) {
      switch (me) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function t0(me, ve) {
      return me === "keydown" && ve.keyCode === gc;
    }
    function py(me, ve) {
      switch (me) {
        case "keyup":
          return ly.indexOf(ve.keyCode) !== -1;
        case "keydown":
          return ve.keyCode !== gc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function n0(me) {
      var ve = me.detail;
      return typeof ve == "object" && "data" in ve ? ve.data : null;
    }
    function Gb(me) {
      return me.locale === "ko";
    }
    var wc = !1;
    function hy(me, ve, Ce, Re, De) {
      var Ue, Ye;
      if (Af ? Ue = fy(ve) : wc ? py(ve, Re) && (Ue = "onCompositionEnd") : t0(ve, Re) && (Ue = "onCompositionStart"), !Ue)
        return null;
      Xg && !Gb(Re) && (!wc && Ue === "onCompositionStart" ? wc = ay(De) : Ue === "onCompositionEnd" && wc && (Ye = Dp()));
      var et = u0(Ce, Ue);
      if (et.length > 0) {
        var at = new Ub(Ue, ve, null, Re, De);
        if (me.push({ event: at, listeners: et }), Ye)
          at.data = Ye;
        else {
          var yt = n0(Re);
          yt !== null && (at.data = yt);
        }
      }
    }
    function Yb(me, ve) {
      switch (me) {
        case "compositionend":
          return n0(ve);
        case "keypress":
          var Ce = ve.which;
          return Ce !== cy ? null : (Wb = !0, Jg);
        case "textInput":
          var Re = ve.data;
          return Re === Jg && Wb ? null : Re;
        default:
          return null;
      }
    }
    function my(me, ve) {
      if (wc) {
        if (me === "compositionend" || !Af && py(me, ve)) {
          var Ce = Dp();
          return yc(), wc = !1, Ce;
        }
        return null;
      }
      switch (me) {
        case "paste":
          return null;
        case "keypress":
          if (!dy(ve)) {
            if (ve.char && ve.char.length > 1)
              return ve.char;
            if (ve.which)
              return String.fromCharCode(ve.which);
          }
          return null;
        case "compositionend":
          return Xg && !Gb(ve) ? null : ve.data;
        default:
          return null;
      }
    }
    function r0(me, ve, Ce, Re, De) {
      var Ue;
      if (qb ? Ue = Yb(ve, Re) : Ue = my(ve, Re), !Ue)
        return null;
      var Ye = u0(Ce, "onBeforeInput");
      if (Ye.length > 0) {
        var et = new Gg("onBeforeInput", "beforeinput", null, Re, De);
        me.push({ event: et, listeners: Ye }), et.data = Ue;
      }
    }
    function I_(me, ve, Ce, Re, De, Ue, Ye) {
      hy(me, ve, Ce, Re, De), r0(me, ve, Ce, Re, De);
    }
    var yy = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
    function o0(me) {
      var ve = me && me.nodeName && me.nodeName.toLowerCase();
      return ve === "input" ? !!yy[me.type] : ve === "textarea";
    }
    function Zp(me) {
      if (!Kr)
        return !1;
      var ve = "on" + me, Ce = ve in document;
      if (!Ce) {
        var Re = document.createElement("div");
        Re.setAttribute(ve, "return;"), Ce = typeof Re[ve] == "function";
      }
      return Ce;
    }
    function $_() {
      Yr("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Cf(me, ve, Ce, Re) {
      pm(Re);
      var De = u0(ve, "onChange");
      if (De.length > 0) {
        var Ue = new Ms("onChange", "change", null, Ce, Re);
        me.push({ event: Ue, listeners: De });
      }
    }
    var xe = null, Oe = null;
    function je(me) {
      var ve = me.nodeName && me.nodeName.toLowerCase();
      return ve === "select" || ve === "input" && me.type === "file";
    }
    function Fe(me) {
      var ve = [];
      Cf(ve, Oe, me, fm(me)), ub(Ge, ve);
    }
    function Ge(me) {
      lS(me, 0);
    }
    function Qe(me) {
      var ve = xy(me);
      if (Nl(ve))
        return me;
    }
    function dt(me, ve) {
      if (me === "change")
        return ve;
    }
    var St = !1;
    Kr && (St = Zp("input") && (!document.documentMode || document.documentMode > 9));
    function Rt(me, ve) {
      xe = me, Oe = ve, xe.attachEvent("onpropertychange", Pn);
    }
    function an() {
      xe && (xe.detachEvent("onpropertychange", Pn), xe = null, Oe = null);
    }
    function Pn(me) {
      me.propertyName === "value" && Qe(Oe) && Fe(me);
    }
    function In(me, ve, Ce) {
      me === "focusin" ? (an(), Rt(ve, Ce)) : me === "focusout" && an();
    }
    function kn(me, ve) {
      if (me === "selectionchange" || me === "keyup" || me === "keydown")
        return Qe(Oe);
    }
    function qn(me) {
      var ve = me.nodeName;
      return ve && ve.toLowerCase() === "input" && (me.type === "checkbox" || me.type === "radio");
    }
    function er(me, ve) {
      if (me === "click")
        return Qe(ve);
    }
    function rr(me, ve) {
      if (me === "input" || me === "change")
        return Qe(ve);
    }
    function va(me) {
      var ve = me._wrapperState;
      !ve || !ve.controlled || me.type !== "number" || Dr(me, "number", me.value);
    }
    function Gt(me, ve, Ce, Re, De, Ue, Ye) {
      var et = Ce ? xy(Ce) : window, at, yt;
      if (je(et) ? at = dt : o0(et) ? St ? at = rr : (at = kn, yt = In) : qn(et) && (at = er), at) {
        var bt = at(ve, Ce);
        if (bt) {
          Cf(me, bt, Re, De);
          return;
        }
      }
      yt && yt(ve, et, Ce), ve === "focusout" && va(et);
    }
    function Bt() {
      qr("onMouseEnter", ["mouseout", "mouseover"]), qr("onMouseLeave", ["mouseout", "mouseover"]), qr("onPointerEnter", ["pointerout", "pointerover"]), qr("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Jt(me, ve, Ce, Re, De, Ue, Ye) {
      var et = ve === "mouseover" || ve === "pointerover", at = ve === "mouseout" || ve === "pointerout";
      if (et && !bg(Re)) {
        var yt = Re.relatedTarget || Re.fromElement;
        if (yt && (Gp(yt) || lv(yt)))
          return;
      }
      if (!(!at && !et)) {
        var bt;
        if (De.window === De)
          bt = De;
        else {
          var Ut = De.ownerDocument;
          Ut ? bt = Ut.defaultView || Ut.parentWindow : bt = window;
        }
        var jt, tn;
        if (at) {
          var nn = Re.relatedTarget || Re.toElement;
          if (jt = Ce, tn = nn ? Gp(nn) : null, tn !== null) {
            var bn = Os(tn);
            (tn !== bn || tn.tag !== ze && tn.tag !== He) && (tn = null);
          }
        } else
          jt = null, tn = Ce;
        if (jt !== tn) {
          var Fn = iy, sr = "onMouseLeave", wr = "onMouseEnter", Zr = "mouse";
          (ve === "pointerout" || ve === "pointerover") && (Fn = Hb, sr = "onPointerLeave", wr = "onPointerEnter", Zr = "pointer");
          var Ur = jt == null ? bt : xy(jt), Qt = tn == null ? bt : xy(tn), yn = new Fn(sr, Zr + "leave", jt, Re, De);
          yn.target = Ur, yn.relatedTarget = Qt;
          var Xt = null, $n = Gp(De);
          if ($n === Ce) {
            var Gn = new Fn(wr, Zr + "enter", tn, Re, De);
            Gn.target = Qt, Gn.relatedTarget = Ur, Xt = Gn;
          }
          PO(me, yn, Xt, jt, tn);
        }
      }
    }
    function Nn(me, ve) {
      return me === ve && (me !== 0 || 1 / me === 1 / ve) || me !== me && ve !== ve;
    }
    var Zn = typeof Object.is == "function" ? Object.is : Nn;
    function dr(me, ve) {
      if (Zn(me, ve))
        return !0;
      if (typeof me != "object" || me === null || typeof ve != "object" || ve === null)
        return !1;
      var Ce = Object.keys(me), Re = Object.keys(ve);
      if (Ce.length !== Re.length)
        return !1;
      for (var De = 0; De < Ce.length; De++) {
        var Ue = Ce[De];
        if (!$o.call(ve, Ue) || !Zn(me[Ue], ve[Ue]))
          return !1;
      }
      return !0;
    }
    function gr(me) {
      for (; me && me.firstChild; )
        me = me.firstChild;
      return me;
    }
    function Ir(me) {
      for (; me; ) {
        if (me.nextSibling)
          return me.nextSibling;
        me = me.parentNode;
      }
    }
    function Ma(me, ve) {
      for (var Ce = gr(me), Re = 0, De = 0; Ce; ) {
        if (Ce.nodeType === al) {
          if (De = Re + Ce.textContent.length, Re <= ve && De >= ve)
            return { node: Ce, offset: ve - Re };
          Re = De;
        }
        Ce = gr(Ir(Ce));
      }
    }
    function fo(me) {
      var ve = me.ownerDocument, Ce = ve && ve.defaultView || window, Re = Ce.getSelection && Ce.getSelection();
      if (!Re || Re.rangeCount === 0)
        return null;
      var De = Re.anchorNode, Ue = Re.anchorOffset, Ye = Re.focusNode, et = Re.focusOffset;
      try {
        De.nodeType, Ye.nodeType;
      } catch {
        return null;
      }
      return Pc(me, De, Ue, Ye, et);
    }
    function Pc(me, ve, Ce, Re, De) {
      var Ue = 0, Ye = -1, et = -1, at = 0, yt = 0, bt = me, Ut = null;
      e:
        for (; ; ) {
          for (var jt = null; bt === ve && (Ce === 0 || bt.nodeType === al) && (Ye = Ue + Ce), bt === Re && (De === 0 || bt.nodeType === al) && (et = Ue + De), bt.nodeType === al && (Ue += bt.nodeValue.length), (jt = bt.firstChild) !== null; )
            Ut = bt, bt = jt;
          for (; ; ) {
            if (bt === me)
              break e;
            if (Ut === ve && ++at === Ce && (Ye = Ue), Ut === Re && ++yt === De && (et = Ue), (jt = bt.nextSibling) !== null)
              break;
            bt = Ut, Ut = bt.parentNode;
          }
          bt = jt;
        }
      return Ye === -1 || et === -1 ? null : { start: Ye, end: et };
    }
    function R_(me, ve) {
      var Ce = me.ownerDocument || document, Re = Ce && Ce.defaultView || window;
      if (Re.getSelection) {
        var De = Re.getSelection(), Ue = me.textContent.length, Ye = Math.min(ve.start, Ue), et = ve.end === void 0 ? Ye : Math.min(ve.end, Ue);
        if (!De.extend && Ye > et) {
          var at = et;
          et = Ye, Ye = at;
        }
        var yt = Ma(me, Ye), bt = Ma(me, et);
        if (yt && bt) {
          if (De.rangeCount === 1 && De.anchorNode === yt.node && De.anchorOffset === yt.offset && De.focusNode === bt.node && De.focusOffset === bt.offset)
            return;
          var Ut = Ce.createRange();
          Ut.setStart(yt.node, yt.offset), De.removeAllRanges(), Ye > et ? (De.addRange(Ut), De.extend(bt.node, bt.offset)) : (Ut.setEnd(bt.node, bt.offset), De.addRange(Ut));
        }
      }
    }
    function WE(me) {
      return me && me.nodeType === al;
    }
    function GE(me, ve) {
      return !me || !ve ? !1 : me === ve ? !0 : WE(me) ? !1 : WE(ve) ? GE(me, ve.parentNode) : "contains" in me ? me.contains(ve) : me.compareDocumentPosition ? !!(me.compareDocumentPosition(ve) & 16) : !1;
    }
    function sO(me) {
      return me && me.ownerDocument && GE(me.ownerDocument.documentElement, me);
    }
    function uO(me) {
      try {
        return typeof me.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function YE() {
      for (var me = window, ve = Bu(); ve instanceof me.HTMLIFrameElement; ) {
        if (uO(ve))
          me = ve.contentWindow;
        else
          return ve;
        ve = Bu(me.document);
      }
      return ve;
    }
    function N_(me) {
      var ve = me && me.nodeName && me.nodeName.toLowerCase();
      return ve && (ve === "input" && (me.type === "text" || me.type === "search" || me.type === "tel" || me.type === "url" || me.type === "password") || ve === "textarea" || me.contentEditable === "true");
    }
    function lO() {
      var me = YE();
      return { focusedElem: me, selectionRange: N_(me) ? dO(me) : null };
    }
    function cO(me) {
      var ve = YE(), Ce = me.focusedElem, Re = me.selectionRange;
      if (ve !== Ce && sO(Ce)) {
        Re !== null && N_(Ce) && fO(Ce, Re);
        for (var De = [], Ue = Ce; Ue = Ue.parentNode; )
          Ue.nodeType === ts && De.push({ element: Ue, left: Ue.scrollLeft, top: Ue.scrollTop });
        typeof Ce.focus == "function" && Ce.focus();
        for (var Ye = 0; Ye < De.length; Ye++) {
          var et = De[Ye];
          et.element.scrollLeft = et.left, et.element.scrollTop = et.top;
        }
      }
    }
    function dO(me) {
      var ve;
      return "selectionStart" in me ? ve = { start: me.selectionStart, end: me.selectionEnd } : ve = fo(me), ve || { start: 0, end: 0 };
    }
    function fO(me, ve) {
      var Ce = ve.start, Re = ve.end;
      Re === void 0 && (Re = Ce), "selectionStart" in me ? (me.selectionStart = Ce, me.selectionEnd = Math.min(Re, me.value.length)) : R_(me, ve);
    }
    var pO = Kr && "documentMode" in document && document.documentMode <= 11;
    function hO() {
      Yr("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var by = null, j_ = null, Qb = null, L_ = !1;
    function mO(me) {
      if ("selectionStart" in me && N_(me))
        return { start: me.selectionStart, end: me.selectionEnd };
      var ve = me.ownerDocument && me.ownerDocument.defaultView || window, Ce = ve.getSelection();
      return { anchorNode: Ce.anchorNode, anchorOffset: Ce.anchorOffset, focusNode: Ce.focusNode, focusOffset: Ce.focusOffset };
    }
    function yO(me) {
      return me.window === me ? me.document : me.nodeType === cu ? me : me.ownerDocument;
    }
    function QE(me, ve, Ce) {
      var Re = yO(Ce);
      if (!(L_ || by == null || by !== Bu(Re))) {
        var De = mO(by);
        if (!Qb || !dr(Qb, De)) {
          Qb = De;
          var Ue = u0(j_, "onSelect");
          if (Ue.length > 0) {
            var Ye = new Ms("onSelect", "select", null, ve, Ce);
            me.push({ event: Ye, listeners: Ue }), Ye.target = by;
          }
        }
      }
    }
    function bO(me, ve, Ce, Re, De, Ue, Ye) {
      var et = Ce ? xy(Ce) : window;
      switch (ve) {
        case "focusin":
          (o0(et) || et.contentEditable === "true") && (by = et, j_ = Ce, Qb = null);
          break;
        case "focusout":
          by = null, j_ = null, Qb = null;
          break;
        case "mousedown":
          L_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          L_ = !1, QE(me, Re, De);
          break;
        case "selectionchange":
          if (pO)
            break;
        case "keydown":
        case "keyup":
          QE(me, Re, De);
      }
    }
    function a0(me, ve) {
      var Ce = {};
      return Ce[me.toLowerCase()] = ve.toLowerCase(), Ce["Webkit" + me] = "webkit" + ve, Ce["Moz" + me] = "moz" + ve, Ce;
    }
    var vy = { animationend: a0("Animation", "AnimationEnd"), animationiteration: a0("Animation", "AnimationIteration"), animationstart: a0("Animation", "AnimationStart"), transitionend: a0("Transition", "TransitionEnd") }, D_ = {}, KE = {};
    Kr && (KE = document.createElement("div").style, "AnimationEvent" in window || (delete vy.animationend.animation, delete vy.animationiteration.animation, delete vy.animationstart.animation), "TransitionEvent" in window || delete vy.transitionend.transition);
    function i0(me) {
      if (D_[me])
        return D_[me];
      if (!vy[me])
        return me;
      var ve = vy[me];
      for (var Ce in ve)
        if (ve.hasOwnProperty(Ce) && Ce in KE)
          return D_[me] = ve[Ce];
      return me;
    }
    var XE = i0("animationend"), JE = i0("animationiteration"), eS = i0("animationstart"), tS = i0("transitionend"), oS = /* @__PURE__ */ new Map(), aS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function If(me, ve) {
      oS.set(me, ve), Yr(ve, [me]);
    }
    function vO() {
      for (var me = 0; me < aS.length; me++) {
        var ve = aS[me], Ce = ve.toLowerCase(), Re = ve[0].toUpperCase() + ve.slice(1);
        If(Ce, "on" + Re);
      }
      If(XE, "onAnimationEnd"), If(JE, "onAnimationIteration"), If(eS, "onAnimationStart"), If("dblclick", "onDoubleClick"), If("focusin", "onFocus"), If("focusout", "onBlur"), If(tS, "onTransitionEnd");
    }
    function gO(me, ve, Ce, Re, De, Ue, Ye) {
      var et = oS.get(ve);
      if (et !== void 0) {
        var at = Ms, yt = ve;
        switch (ve) {
          case "keypress":
            if (Tf(Re) === 0)
              return;
          case "keydown":
          case "keyup":
            at = T_;
            break;
          case "focusin":
            yt = "focus", at = sy;
            break;
          case "focusout":
            yt = "blur", at = sy;
            break;
          case "beforeblur":
          case "afterblur":
            at = sy;
            break;
          case "click":
            if (Re.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            at = iy;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            at = Fb;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            at = A_;
            break;
          case XE:
          case JE:
          case eS:
            at = zb;
            break;
          case tS:
            at = Zb;
            break;
          case "scroll":
            at = qg;
            break;
          case "wheel":
            at = vc;
            break;
          case "copy":
          case "cut":
          case "paste":
            at = S_;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            at = Hb;
            break;
        }
        var bt = (Ue & uf) !== 0;
        {
          var Ut = !bt && ve === "scroll", jt = EO(Ce, et, Re.type, bt, Ut);
          if (jt.length > 0) {
            var tn = new at(et, yt, null, Re, De);
            me.push({ event: tn, listeners: jt });
          }
        }
      }
    }
    vO(), Bt(), $_(), hO(), e0();
    function wO(me, ve, Ce, Re, De, Ue, Ye) {
      gO(me, ve, Ce, Re, De, Ue);
      var et = (Ue & yg) === 0;
      et && (Jt(me, ve, Ce, Re, De), Gt(me, ve, Ce, Re, De), bO(me, ve, Ce, Re, De), I_(me, ve, Ce, Re, De));
    }
    var Kb = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], B_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Kb));
    function uS(me, ve, Ce) {
      var Re = me.type || "unknown-event";
      me.currentTarget = Ce, ll(Re, ve, void 0, me), me.currentTarget = null;
    }
    function _O(me, ve, Ce) {
      var Re;
      if (Ce)
        for (var De = ve.length - 1; De >= 0; De--) {
          var Ue = ve[De], Ye = Ue.instance, et = Ue.currentTarget, at = Ue.listener;
          if (Ye !== Re && me.isPropagationStopped())
            return;
          uS(me, at, et), Re = Ye;
        }
      else
        for (var yt = 0; yt < ve.length; yt++) {
          var bt = ve[yt], Ut = bt.instance, jt = bt.currentTarget, tn = bt.listener;
          if (Ut !== Re && me.isPropagationStopped())
            return;
          uS(me, tn, jt), Re = Ut;
        }
    }
    function lS(me, ve) {
      for (var Ce = (ve & uf) !== 0, Re = 0; Re < me.length; Re++) {
        var De = me[Re], Ue = De.event, Ye = De.listeners;
        _O(Ue, Ye, Ce);
      }
      fb();
    }
    function xO(me, ve, Ce, Re, De) {
      var Ue = fm(Ce), Ye = [];
      wO(Ye, me, Re, Ce, Ue, ve), lS(Ye, ve);
    }
    function na(me, ve) {
      B_.has(me) || _e('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', me);
      var Ce = !1, Re = zC(ve), De = kO(me, Ce);
      Re.has(De) || (cS(ve, me, sf, Ce), Re.add(De));
    }
    function F_(me, ve, Ce) {
      B_.has(me) && !ve && _e('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', me);
      var Re = 0;
      ve && (Re |= uf), cS(Ce, me, Re, ve);
    }
    var s0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Xb(me) {
      if (!me[s0]) {
        me[s0] = !0, nr.forEach(function(Ce) {
          Ce !== "selectionchange" && (B_.has(Ce) || F_(Ce, !1, me), F_(Ce, !0, me));
        });
        var ve = me.nodeType === cu ? me : me.ownerDocument;
        ve !== null && (ve[s0] || (ve[s0] = !0, F_("selectionchange", !1, ve)));
      }
    }
    function cS(me, ve, Ce, Re, De) {
      var Ue = Rs(me, ve, Ce), Ye = void 0;
      yp && (ve === "touchstart" || ve === "touchmove" || ve === "wheel") && (Ye = !0), me = me, Re ? Ye !== void 0 ? Pf(me, ve, Ue, Ye) : Bb(me, ve, Ue) : Ye !== void 0 ? ml(me, ve, Ue, Ye) : hs(me, ve, Ue);
    }
    function dS(me, ve) {
      return me === ve || me.nodeType === Pa && me.parentNode === ve;
    }
    function z_(me, ve, Ce, Re, De) {
      var Ue = Re;
      if (!(ve & sl) && !(ve & sf)) {
        var Ye = De;
        if (Re !== null) {
          var et = Re;
          e:
            for (; ; ) {
              if (et === null)
                return;
              var at = et.tag;
              if (at === Me || at === Be) {
                var yt = et.stateNode.containerInfo;
                if (dS(yt, Ye))
                  break;
                if (at === Be)
                  for (var bt = et.return; bt !== null; ) {
                    var Ut = bt.tag;
                    if (Ut === Me || Ut === Be) {
                      var jt = bt.stateNode.containerInfo;
                      if (dS(jt, Ye))
                        return;
                    }
                    bt = bt.return;
                  }
                for (; yt !== null; ) {
                  var tn = Gp(yt);
                  if (tn === null)
                    return;
                  var nn = tn.tag;
                  if (nn === ze || nn === He) {
                    et = Ue = tn;
                    continue e;
                  }
                  yt = yt.parentNode;
                }
              }
              et = et.return;
            }
        }
      }
      ub(function() {
        return xO(me, ve, Ce, Ue);
      });
    }
    function Jb(me, ve, Ce) {
      return { instance: me, listener: ve, currentTarget: Ce };
    }
    function EO(me, ve, Ce, Re, De, Ue) {
      for (var Ye = ve !== null ? ve + "Capture" : null, et = Re ? Ye : ve, at = [], yt = me, bt = null; yt !== null; ) {
        var Ut = yt, jt = Ut.stateNode, tn = Ut.tag;
        if (tn === ze && jt !== null && (bt = jt, et !== null)) {
          var nn = ed(yt, et);
          nn != null && at.push(Jb(yt, nn, bt));
        }
        if (De)
          break;
        yt = yt.return;
      }
      return at;
    }
    function u0(me, ve) {
      for (var Ce = ve + "Capture", Re = [], De = me; De !== null; ) {
        var Ue = De, Ye = Ue.stateNode, et = Ue.tag;
        if (et === ze && Ye !== null) {
          var at = Ye, yt = ed(De, Ce);
          yt != null && Re.unshift(Jb(De, yt, at));
          var bt = ed(De, ve);
          bt != null && Re.push(Jb(De, bt, at));
        }
        De = De.return;
      }
      return Re;
    }
    function gy(me) {
      if (me === null)
        return null;
      do
        me = me.return;
      while (me && me.tag !== ze);
      return me || null;
    }
    function SO(me, ve) {
      for (var Ce = me, Re = ve, De = 0, Ue = Ce; Ue; Ue = gy(Ue))
        De++;
      for (var Ye = 0, et = Re; et; et = gy(et))
        Ye++;
      for (; De - Ye > 0; )
        Ce = gy(Ce), De--;
      for (; Ye - De > 0; )
        Re = gy(Re), Ye--;
      for (var at = De; at--; ) {
        if (Ce === Re || Re !== null && Ce === Re.alternate)
          return Ce;
        Ce = gy(Ce), Re = gy(Re);
      }
      return null;
    }
    function fS(me, ve, Ce, Re, De) {
      for (var Ue = ve._reactName, Ye = [], et = Ce; et !== null && et !== Re; ) {
        var at = et, yt = at.alternate, bt = at.stateNode, Ut = at.tag;
        if (yt !== null && yt === Re)
          break;
        if (Ut === ze && bt !== null) {
          var jt = bt;
          if (De) {
            var tn = ed(et, Ue);
            tn != null && Ye.unshift(Jb(et, tn, jt));
          } else if (!De) {
            var nn = ed(et, Ue);
            nn != null && Ye.push(Jb(et, nn, jt));
          }
        }
        et = et.return;
      }
      Ye.length !== 0 && me.push({ event: ve, listeners: Ye });
    }
    function PO(me, ve, Ce, Re, De) {
      var Ue = Re && De ? SO(Re, De) : null;
      Re !== null && fS(me, ve, Re, Ue, !1), De !== null && Ce !== null && fS(me, Ce, De, Ue, !0);
    }
    function kO(me, ve) {
      return me + "__" + (ve ? "capture" : "bubble");
    }
    var nu = !1, ev = "dangerouslySetInnerHTML", l0 = "suppressContentEditableWarning", $f = "suppressHydrationWarning", pS = "autoFocus", qp = "children", Wp = "style", c0 = "__html", U_, d0, tv, hS, f0, yS, bS;
    U_ = { dialog: !0, webview: !0 }, d0 = function(me, ve) {
      dm(me, ve), rb(me, ve), mg(me, ve, { registrationNameDependencies: Er, possibleRegistrationNames: Qo });
    }, yS = Kr && !document.documentMode, tv = function(me, ve, Ce) {
      if (!nu) {
        var Re = p0(Ce), De = p0(ve);
        De !== Re && (nu = !0, _e("Prop `%s` did not match. Server: %s Client: %s", me, JSON.stringify(De), JSON.stringify(Re)));
      }
    }, hS = function(me) {
      if (!nu) {
        nu = !0;
        var ve = [];
        me.forEach(function(Ce) {
          ve.push(Ce);
        }), _e("Extra attributes from the server: %s", ve);
      }
    }, f0 = function(me, ve) {
      ve === !1 ? _e("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", me, me, me) : _e("Expected `%s` listener to be a function, instead got a value of `%s` type.", me, typeof ve);
    }, bS = function(me, ve) {
      var Ce = me.namespaceURI === ol ? me.ownerDocument.createElement(me.tagName) : me.ownerDocument.createElementNS(me.namespaceURI, me.tagName);
      return Ce.innerHTML = ve, Ce.innerHTML;
    };
    var TO = /\r\n?/g, OO = /\u0000|\uFFFD/g;
    function p0(me) {
      xa(me);
      var ve = typeof me == "string" ? me : "" + me;
      return ve.replace(TO, `
`).replace(OO, "");
    }
    function h0(me, ve, Ce, Re) {
      var De = p0(ve), Ue = p0(me);
      if (Ue !== De && (Re && (nu || (nu = !0, _e('Text content did not match. Server: "%s" Client: "%s"', Ue, De))), Ce && dn))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function vS(me) {
      return me.nodeType === cu ? me : me.ownerDocument;
    }
    function AO() {
    }
    function m0(me) {
      me.onclick = AO;
    }
    function CO(me, ve, Ce, Re, De) {
      for (var Ue in Re)
        if (Re.hasOwnProperty(Ue)) {
          var Ye = Re[Ue];
          if (Ue === Wp)
            Ye && Object.freeze(Ye), ag(ve, Ye);
          else if (Ue === ev) {
            var et = Ye ? Ye[c0] : void 0;
            et != null && Yv(ve, et);
          } else if (Ue === qp)
            if (typeof Ye == "string") {
              var at = me !== "textarea" || Ye !== "";
              at && im(ve, Ye);
            } else
              typeof Ye == "number" && im(ve, "" + Ye);
          else
            Ue === l0 || Ue === $f || Ue === pS || (Er.hasOwnProperty(Ue) ? Ye != null && (typeof Ye != "function" && f0(Ue, Ye), Ue === "onScroll" && na("scroll", ve)) : Ye != null && Ea(ve, Ue, Ye, De));
        }
    }
    function IO(me, ve, Ce, Re) {
      for (var De = 0; De < ve.length; De += 2) {
        var Ue = ve[De], Ye = ve[De + 1];
        Ue === Wp ? ag(me, Ye) : Ue === ev ? Yv(me, Ye) : Ue === qp ? im(me, Ye) : Ea(me, Ue, Ye, Re);
      }
    }
    function $O(me, ve, Ce, Re) {
      var De, Ue = vS(Ce), Ye, et = Re;
      if (et === ol && (et = om(me)), et === ol) {
        if (De = il(me, ve), !De && me !== me.toLowerCase() && _e("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", me), me === "script") {
          var at = Ue.createElement("div");
          at.innerHTML = "<script><\/script>";
          var yt = at.firstChild;
          Ye = at.removeChild(yt);
        } else if (typeof ve.is == "string")
          Ye = Ue.createElement(me, { is: ve.is });
        else if (Ye = Ue.createElement(me), me === "select") {
          var bt = Ye;
          ve.multiple ? bt.multiple = !0 : ve.size && (bt.size = ve.size);
        }
      } else
        Ye = Ue.createElementNS(et, me);
      return et === ol && !De && Object.prototype.toString.call(Ye) === "[object HTMLUnknownElement]" && !$o.call(U_, me) && (U_[me] = !0, _e("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", me)), Ye;
    }
    function RO(me, ve) {
      return vS(ve).createTextNode(me);
    }
    function NO(me, ve, Ce, Re) {
      var De = il(ve, Ce);
      d0(ve, Ce);
      var Ue;
      switch (ve) {
        case "dialog":
          na("cancel", me), na("close", me), Ue = Ce;
          break;
        case "iframe":
        case "object":
        case "embed":
          na("load", me), Ue = Ce;
          break;
        case "video":
        case "audio":
          for (var Ye = 0; Ye < Kb.length; Ye++)
            na(Kb[Ye], me);
          Ue = Ce;
          break;
        case "source":
          na("error", me), Ue = Ce;
          break;
        case "img":
        case "image":
        case "link":
          na("error", me), na("load", me), Ue = Ce;
          break;
        case "details":
          na("toggle", me), Ue = Ce;
          break;
        case "input":
          Kt(me, Ce), Ue = Ct(me, Ce), na("invalid", me);
          break;
        case "option":
          Po(me, Ce), Ue = Ce;
          break;
        case "select":
          rm(me, Ce), Ue = Jd(me, Ce), na("invalid", me);
          break;
        case "textarea":
          qv(me, Ce), Ue = Gy(me, Ce), na("invalid", me);
          break;
        default:
          Ue = Ce;
      }
      switch (lm(ve, Ue), CO(ve, me, Re, Ue, De), ve) {
        case "input":
          ks(me), or(me, Ce, !1);
          break;
        case "textarea":
          ks(me), Gv(me);
          break;
        case "option":
          Wo(me, Ce);
          break;
        case "select":
          t_(me, Ce);
          break;
        default:
          typeof Ue.onClick == "function" && m0(me);
          break;
      }
    }
    function MO(me, ve, Ce, Re, De) {
      d0(ve, Re);
      var Ue = null, Ye, et;
      switch (ve) {
        case "input":
          Ye = Ct(me, Ce), et = Ct(me, Re), Ue = [];
          break;
        case "select":
          Ye = Jd(me, Ce), et = Jd(me, Re), Ue = [];
          break;
        case "textarea":
          Ye = Gy(me, Ce), et = Gy(me, Re), Ue = [];
          break;
        default:
          Ye = Ce, et = Re, typeof Ye.onClick != "function" && typeof et.onClick == "function" && m0(me);
          break;
      }
      lm(ve, et);
      var at, yt, bt = null;
      for (at in Ye)
        if (!(et.hasOwnProperty(at) || !Ye.hasOwnProperty(at) || Ye[at] == null))
          if (at === Wp) {
            var Ut = Ye[at];
            for (yt in Ut)
              Ut.hasOwnProperty(yt) && (bt || (bt = {}), bt[yt] = "");
          } else
            at === ev || at === qp || at === l0 || at === $f || at === pS || (Er.hasOwnProperty(at) ? Ue || (Ue = []) : (Ue = Ue || []).push(at, null));
      for (at in et) {
        var jt = et[at], tn = Ye == null ? void 0 : Ye[at];
        if (!(!et.hasOwnProperty(at) || jt === tn || jt == null && tn == null))
          if (at === Wp)
            if (jt && Object.freeze(jt), tn) {
              for (yt in tn)
                tn.hasOwnProperty(yt) && (!jt || !jt.hasOwnProperty(yt)) && (bt || (bt = {}), bt[yt] = "");
              for (yt in jt)
                jt.hasOwnProperty(yt) && tn[yt] !== jt[yt] && (bt || (bt = {}), bt[yt] = jt[yt]);
            } else
              bt || (Ue || (Ue = []), Ue.push(at, bt)), bt = jt;
          else if (at === ev) {
            var nn = jt ? jt[c0] : void 0, bn = tn ? tn[c0] : void 0;
            nn != null && bn !== nn && (Ue = Ue || []).push(at, nn);
          } else
            at === qp ? (typeof jt == "string" || typeof jt == "number") && (Ue = Ue || []).push(at, "" + jt) : at === l0 || at === $f || (Er.hasOwnProperty(at) ? (jt != null && (typeof jt != "function" && f0(at, jt), at === "onScroll" && na("scroll", me)), !Ue && tn !== jt && (Ue = [])) : (Ue = Ue || []).push(at, jt));
      }
      return bt && (Jf(bt, et[Wp]), (Ue = Ue || []).push(Wp, bt)), Ue;
    }
    function jO(me, ve, Ce, Re, De) {
      Ce === "input" && De.type === "radio" && De.name != null && mn(me, De);
      var Ue = il(Ce, Re), Ye = il(Ce, De);
      switch (IO(me, ve, Ue, Ye), Ce) {
        case "input":
          Sn(me, De);
          break;
        case "textarea":
          Wv(me, De);
          break;
        case "select":
          n_(me, De);
          break;
      }
    }
    function LO(me) {
      {
        var ve = me.toLowerCase();
        return cm.hasOwnProperty(ve) && cm[ve] || null;
      }
    }
    function DO(me, ve, Ce, Re, De, Ue, Ye) {
      var et, at;
      switch (et = il(ve, Ce), d0(ve, Ce), ve) {
        case "dialog":
          na("cancel", me), na("close", me);
          break;
        case "iframe":
        case "object":
        case "embed":
          na("load", me);
          break;
        case "video":
        case "audio":
          for (var yt = 0; yt < Kb.length; yt++)
            na(Kb[yt], me);
          break;
        case "source":
          na("error", me);
          break;
        case "img":
        case "image":
        case "link":
          na("error", me), na("load", me);
          break;
        case "details":
          na("toggle", me);
          break;
        case "input":
          Kt(me, Ce), na("invalid", me);
          break;
        case "option":
          Po(me, Ce);
          break;
        case "select":
          rm(me, Ce), na("invalid", me);
          break;
        case "textarea":
          qv(me, Ce), na("invalid", me);
          break;
      }
      lm(ve, Ce);
      {
        at = /* @__PURE__ */ new Set();
        for (var bt = me.attributes, Ut = 0; Ut < bt.length; Ut++) {
          var jt = bt[Ut].name.toLowerCase();
          switch (jt) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              at.add(bt[Ut].name);
          }
        }
      }
      var tn = null;
      for (var nn in Ce)
        if (Ce.hasOwnProperty(nn)) {
          var bn = Ce[nn];
          if (nn === qp)
            typeof bn == "string" ? me.textContent !== bn && (Ce[$f] !== !0 && h0(me.textContent, bn, Ue, Ye), tn = [qp, bn]) : typeof bn == "number" && me.textContent !== "" + bn && (Ce[$f] !== !0 && h0(me.textContent, bn, Ue, Ye), tn = [qp, "" + bn]);
          else if (Er.hasOwnProperty(nn))
            bn != null && (typeof bn != "function" && f0(nn, bn), nn === "onScroll" && na("scroll", me));
          else if (Ye && typeof et == "boolean") {
            var Fn = void 0, sr = et && Un ? null : bo(nn);
            if (Ce[$f] !== !0 && !(nn === l0 || nn === $f || nn === "value" || nn === "checked" || nn === "selected")) {
              if (nn === ev) {
                var wr = me.innerHTML, Zr = bn ? bn[c0] : void 0;
                if (Zr != null) {
                  var Ur = bS(me, Zr);
                  Ur !== wr && tv(nn, wr, Ur);
                }
              } else if (nn === Wp) {
                if (at.delete(nn), yS) {
                  var Qt = c_(bn);
                  Fn = me.getAttribute("style"), Qt !== Fn && tv(nn, Fn, Qt);
                }
              } else if (et && !Un)
                at.delete(nn.toLowerCase()), Fn = Ni(me, nn, bn), bn !== Fn && tv(nn, Fn, bn);
              else if (!jn(nn, sr, et) && !jr(nn, bn, sr, et)) {
                var yn = !1;
                if (sr !== null)
                  at.delete(sr.attributeName), Fn = ti(me, nn, bn, sr);
                else {
                  var Xt = Re;
                  if (Xt === ol && (Xt = om(ve)), Xt === ol)
                    at.delete(nn.toLowerCase());
                  else {
                    var $n = LO(nn);
                    $n !== null && $n !== nn && (yn = !0, at.delete($n)), at.delete(nn);
                  }
                  Fn = Ni(me, nn, bn);
                }
                var Gn = Un;
                !Gn && bn !== Fn && !yn && tv(nn, Fn, bn);
              }
            }
          }
        }
      switch (Ye && at.size > 0 && Ce[$f] !== !0 && hS(at), ve) {
        case "input":
          ks(me), or(me, Ce, !0);
          break;
        case "textarea":
          ks(me), Gv(me);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof Ce.onClick == "function" && m0(me);
          break;
      }
      return tn;
    }
    function BO(me, ve, Ce) {
      var Re = me.nodeValue !== ve;
      return Re;
    }
    function V_(me, ve) {
      {
        if (nu)
          return;
        nu = !0, _e("Did not expect server HTML to contain a <%s> in <%s>.", ve.nodeName.toLowerCase(), me.nodeName.toLowerCase());
      }
    }
    function H_(me, ve) {
      {
        if (nu)
          return;
        nu = !0, _e('Did not expect server HTML to contain the text node "%s" in <%s>.', ve.nodeValue, me.nodeName.toLowerCase());
      }
    }
    function Z_(me, ve, Ce) {
      {
        if (nu)
          return;
        nu = !0, _e("Expected server HTML to contain a matching <%s> in <%s>.", ve, me.nodeName.toLowerCase());
      }
    }
    function q_(me, ve) {
      {
        if (ve === "" || nu)
          return;
        nu = !0, _e('Expected server HTML to contain a matching text node for "%s" in <%s>.', ve, me.nodeName.toLowerCase());
      }
    }
    function FO(me, ve, Ce) {
      switch (ve) {
        case "input":
          Jn(me, Ce);
          return;
        case "textarea":
          Yy(me, Ce);
          return;
        case "select":
          r_(me, Ce);
          return;
      }
    }
    var nv = function() {
    }, rv = function() {
    };
    {
      var zO = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], gS = ["applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title"], UO = gS.concat(["button"]), VO = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], wS = { current: null, formTag: null, aTagInScope: null, buttonTagInScope: null, nobrTagInScope: null, pTagInButtonScope: null, listItemTagAutoclosing: null, dlItemTagAutoclosing: null };
      rv = function(me, ve) {
        var Ce = zr({}, me || wS), Re = { tag: ve };
        return gS.indexOf(ve) !== -1 && (Ce.aTagInScope = null, Ce.buttonTagInScope = null, Ce.nobrTagInScope = null), UO.indexOf(ve) !== -1 && (Ce.pTagInButtonScope = null), zO.indexOf(ve) !== -1 && ve !== "address" && ve !== "div" && ve !== "p" && (Ce.listItemTagAutoclosing = null, Ce.dlItemTagAutoclosing = null), Ce.current = Re, ve === "form" && (Ce.formTag = Re), ve === "a" && (Ce.aTagInScope = Re), ve === "button" && (Ce.buttonTagInScope = Re), ve === "nobr" && (Ce.nobrTagInScope = Re), ve === "p" && (Ce.pTagInButtonScope = Re), ve === "li" && (Ce.listItemTagAutoclosing = Re), (ve === "dd" || ve === "dt") && (Ce.dlItemTagAutoclosing = Re), Ce;
      };
      var HO = function(me, ve) {
        switch (ve) {
          case "select":
            return me === "option" || me === "optgroup" || me === "#text";
          case "optgroup":
            return me === "option" || me === "#text";
          case "option":
            return me === "#text";
          case "tr":
            return me === "th" || me === "td" || me === "style" || me === "script" || me === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return me === "tr" || me === "style" || me === "script" || me === "template";
          case "colgroup":
            return me === "col" || me === "template";
          case "table":
            return me === "caption" || me === "colgroup" || me === "tbody" || me === "tfoot" || me === "thead" || me === "style" || me === "script" || me === "template";
          case "head":
            return me === "base" || me === "basefont" || me === "bgsound" || me === "link" || me === "meta" || me === "title" || me === "noscript" || me === "noframes" || me === "style" || me === "script" || me === "template";
          case "html":
            return me === "head" || me === "body" || me === "frameset";
          case "frameset":
            return me === "frame";
          case "#document":
            return me === "html";
        }
        switch (me) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ve !== "h1" && ve !== "h2" && ve !== "h3" && ve !== "h4" && ve !== "h5" && ve !== "h6";
          case "rp":
          case "rt":
            return VO.indexOf(ve) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return ve == null;
        }
        return !0;
      }, ZO = function(me, ve) {
        switch (me) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ve.pTagInButtonScope;
          case "form":
            return ve.formTag || ve.pTagInButtonScope;
          case "li":
            return ve.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ve.dlItemTagAutoclosing;
          case "button":
            return ve.buttonTagInScope;
          case "a":
            return ve.aTagInScope;
          case "nobr":
            return ve.nobrTagInScope;
        }
        return null;
      }, _S = {};
      nv = function(me, ve, Ce) {
        Ce = Ce || wS;
        var Re = Ce.current, De = Re && Re.tag;
        ve != null && (me != null && _e("validateDOMNesting: when childText is passed, childTag should be null"), me = "#text");
        var Ue = HO(me, De) ? null : Re, Ye = Ue ? null : ZO(me, Ce), et = Ue || Ye;
        if (et) {
          var at = et.tag, yt = !!Ue + "|" + me + "|" + at;
          if (!_S[yt]) {
            _S[yt] = !0;
            var bt = me, Ut = "";
            if (me === "#text" ? /\S/.test(ve) ? bt = "Text nodes" : (bt = "Whitespace text nodes", Ut = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : bt = "<" + me + ">", Ue) {
              var jt = "";
              at === "table" && me === "tr" && (jt += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), _e("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", bt, at, Ut, jt);
            } else
              _e("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", bt, at);
          }
        }
      };
    }
    var y0 = "suppressHydrationWarning", b0 = "$", v0 = "/$", ov = "$?", av = "$!", qO = "style", W_ = null, G_ = null;
    function WO(me) {
      var ve, Ce, Re = me.nodeType;
      switch (Re) {
        case cu:
        case Kc: {
          ve = Re === cu ? "#document" : "#fragment";
          var De = me.documentElement;
          Ce = De ? De.namespaceURI : Ky(null, "");
          break;
        }
        default: {
          var Ue = Re === Pa ? me.parentNode : me, Ye = Ue.namespaceURI || null;
          ve = Ue.tagName, Ce = Ky(Ye, ve);
          break;
        }
      }
      {
        var et = ve.toLowerCase(), at = rv(null, et);
        return { namespace: Ce, ancestorInfo: at };
      }
    }
    function GO(me, ve, Ce) {
      {
        var Re = me, De = Ky(Re.namespace, ve), Ue = rv(Re.ancestorInfo, ve);
        return { namespace: De, ancestorInfo: Ue };
      }
    }
    function YO(me) {
      W_ = hi(), G_ = lO();
      var ve = null;
      return pa(!1), ve;
    }
    function QO(me) {
      cO(G_), pa(W_), W_ = null, G_ = null;
    }
    function KO(me, ve, Ce, Re, De) {
      var Ue;
      {
        var Ye = Re;
        if (nv(me, null, Ye.ancestorInfo), typeof ve.children == "string" || typeof ve.children == "number") {
          var et = "" + ve.children, at = rv(Ye.ancestorInfo, me);
          nv(null, et, at);
        }
        Ue = Ye.namespace;
      }
      var yt = $O(me, ve, Ce, Ue);
      return uv(De, yt), n1(yt, ve), yt;
    }
    function XO(me, ve) {
      me.appendChild(ve);
    }
    function JO(me, ve, Ce, Re, De) {
      switch (NO(me, ve, Ce, Re), ve) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!Ce.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function eA(me, ve, Ce, Re, De, Ue) {
      {
        var Ye = Ue;
        if (typeof Re.children != typeof Ce.children && (typeof Re.children == "string" || typeof Re.children == "number")) {
          var et = "" + Re.children, at = rv(Ye.ancestorInfo, ve);
          nv(null, et, at);
        }
      }
      return MO(me, ve, Ce, Re);
    }
    function Y_(me, ve) {
      return me === "textarea" || me === "noscript" || typeof ve.children == "string" || typeof ve.children == "number" || typeof ve.dangerouslySetInnerHTML == "object" && ve.dangerouslySetInnerHTML !== null && ve.dangerouslySetInnerHTML.__html != null;
    }
    function sA(me, ve, Ce, Re) {
      {
        var De = Ce;
        nv(null, me, De.ancestorInfo);
      }
      var Ue = RO(me, ve);
      return uv(Re, Ue), Ue;
    }
    function uA() {
      var me = window.event;
      return me === void 0 ? fi : Sf(me.type);
    }
    var Q_ = typeof setTimeout == "function" ? setTimeout : void 0, lA = typeof clearTimeout == "function" ? clearTimeout : void 0, K_ = -1, xS = typeof Promise == "function" ? Promise : void 0, yA = typeof queueMicrotask == "function" ? queueMicrotask : typeof xS < "u" ? function(me) {
      return xS.resolve(null).then(me).catch(_A);
    } : Q_;
    function _A(me) {
      setTimeout(function() {
        throw me;
      });
    }
    function OA(me, ve, Ce, Re) {
      switch (ve) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          Ce.autoFocus && me.focus();
          return;
        case "img": {
          Ce.src && (me.src = Ce.src);
          return;
        }
      }
    }
    function $A(me, ve, Ce, Re, De, Ue) {
      jO(me, ve, Ce, Re, De), n1(me, De);
    }
    function ES(me) {
      im(me, "");
    }
    function RA(me, ve, Ce) {
      me.nodeValue = Ce;
    }
    function BA(me, ve) {
      me.appendChild(ve);
    }
    function qA(me, ve) {
      var Ce;
      me.nodeType === Pa ? (Ce = me.parentNode, Ce.insertBefore(ve, me)) : (Ce = me, Ce.appendChild(ve));
      var Re = me._reactRootContainer;
      Re == null && Ce.onclick === null && m0(Ce);
    }
    function eC(me, ve, Ce) {
      me.insertBefore(ve, Ce);
    }
    function tC(me, ve, Ce) {
      me.nodeType === Pa ? me.parentNode.insertBefore(ve, Ce) : me.insertBefore(ve, Ce);
    }
    function nC(me, ve) {
      me.removeChild(ve);
    }
    function rC(me, ve) {
      me.nodeType === Pa ? me.parentNode.removeChild(ve) : me.removeChild(ve);
    }
    function X_(me, ve) {
      var Ce = ve, Re = 0;
      do {
        var De = Ce.nextSibling;
        if (me.removeChild(Ce), De && De.nodeType === Pa) {
          var Ue = De.data;
          if (Ue === v0)
            if (Re === 0) {
              me.removeChild(De), Ri(ve);
              return;
            } else
              Re--;
          else
            (Ue === b0 || Ue === ov || Ue === av) && Re++;
        }
        Ce = De;
      } while (Ce);
      Ri(ve);
    }
    function oC(me, ve) {
      me.nodeType === Pa ? X_(me.parentNode, ve) : me.nodeType === ts && X_(me, ve), Ri(me);
    }
    function aC(me) {
      me = me;
      var ve = me.style;
      typeof ve.setProperty == "function" ? ve.setProperty("display", "none", "important") : ve.display = "none";
    }
    function iC(me) {
      me.nodeValue = "";
    }
    function sC(me, ve) {
      me = me;
      var Ce = ve[qO], Re = Ce != null && Ce.hasOwnProperty("display") ? Ce.display : null;
      me.style.display = sm("display", Re);
    }
    function uC(me, ve) {
      me.nodeValue = ve;
    }
    function lC(me) {
      me.nodeType === ts ? me.textContent = "" : me.nodeType === cu && me.documentElement && me.removeChild(me.documentElement);
    }
    function cC(me, ve, Ce) {
      return me.nodeType !== ts || ve.toLowerCase() !== me.nodeName.toLowerCase() ? null : me;
    }
    function dC(me, ve) {
      return ve === "" || me.nodeType !== al ? null : me;
    }
    function fC(me) {
      return me.nodeType !== Pa ? null : me;
    }
    function SS(me) {
      return me.data === ov;
    }
    function J_(me) {
      return me.data === av;
    }
    function pC(me) {
      var ve = me.nextSibling && me.nextSibling.dataset, Ce, Re, De;
      return ve && (Ce = ve.dgst, Re = ve.msg, De = ve.stck), { message: Re, digest: Ce, stack: De };
    }
    function hC(me, ve) {
      me._reactRetry = ve;
    }
    function g0(me) {
      for (; me != null; me = me.nextSibling) {
        var ve = me.nodeType;
        if (ve === ts || ve === al)
          break;
        if (ve === Pa) {
          var Ce = me.data;
          if (Ce === b0 || Ce === av || Ce === ov)
            break;
          if (Ce === v0)
            return null;
        }
      }
      return me;
    }
    function iv(me) {
      return g0(me.nextSibling);
    }
    function mC(me) {
      return g0(me.firstChild);
    }
    function yC(me) {
      return g0(me.firstChild);
    }
    function bC(me) {
      return g0(me.nextSibling);
    }
    function vC(me, ve, Ce, Re, De, Ue, Ye) {
      uv(Ue, me), n1(me, Ce);
      var et;
      {
        var at = De;
        et = at.namespace;
      }
      var yt = (Ue.mode & Vr) !== vr;
      return DO(me, ve, Ce, et, Re, yt, Ye);
    }
    function gC(me, ve, Ce, Re) {
      return uv(Ce, me), Ce.mode & Vr, BO(me, ve);
    }
    function wC(me, ve) {
      uv(ve, me);
    }
    function _C(me) {
      for (var ve = me.nextSibling, Ce = 0; ve; ) {
        if (ve.nodeType === Pa) {
          var Re = ve.data;
          if (Re === v0) {
            if (Ce === 0)
              return iv(ve);
            Ce--;
          } else
            (Re === b0 || Re === av || Re === ov) && Ce++;
        }
        ve = ve.nextSibling;
      }
      return null;
    }
    function PS(me) {
      for (var ve = me.previousSibling, Ce = 0; ve; ) {
        if (ve.nodeType === Pa) {
          var Re = ve.data;
          if (Re === b0 || Re === av || Re === ov) {
            if (Ce === 0)
              return ve;
            Ce--;
          } else
            Re === v0 && Ce++;
        }
        ve = ve.previousSibling;
      }
      return null;
    }
    function xC(me) {
      Ri(me);
    }
    function EC(me) {
      Ri(me);
    }
    function SC(me) {
      return me !== "head" && me !== "body";
    }
    function PC(me, ve, Ce, Re) {
      var De = !0;
      h0(ve.nodeValue, Ce, Re, De);
    }
    function kC(me, ve, Ce, Re, De, Ue) {
      if (ve[y0] !== !0) {
        var Ye = !0;
        h0(Re.nodeValue, De, Ue, Ye);
      }
    }
    function TC(me, ve) {
      ve.nodeType === ts ? V_(me, ve) : ve.nodeType === Pa || H_(me, ve);
    }
    function OC(me, ve) {
      {
        var Ce = me.parentNode;
        Ce !== null && (ve.nodeType === ts ? V_(Ce, ve) : ve.nodeType === Pa || H_(Ce, ve));
      }
    }
    function AC(me, ve, Ce, Re, De) {
      (De || ve[y0] !== !0) && (Re.nodeType === ts ? V_(Ce, Re) : Re.nodeType === Pa || H_(Ce, Re));
    }
    function CC(me, ve, Ce) {
      Z_(me, ve);
    }
    function IC(me, ve) {
      q_(me, ve);
    }
    function $C(me, ve, Ce) {
      {
        var Re = me.parentNode;
        Re !== null && Z_(Re, ve);
      }
    }
    function RC(me, ve) {
      {
        var Ce = me.parentNode;
        Ce !== null && q_(Ce, ve);
      }
    }
    function NC(me, ve, Ce, Re, De, Ue) {
      (Ue || ve[y0] !== !0) && Z_(Ce, Re);
    }
    function MC(me, ve, Ce, Re, De) {
      (De || ve[y0] !== !0) && q_(Ce, Re);
    }
    function jC(me) {
      _e("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", me.nodeName.toLowerCase());
    }
    function LC(me) {
      Xb(me);
    }
    var wy = Math.random().toString(36).slice(2), _y = "__reactFiber$" + wy, e1 = "__reactProps$" + wy, sv = "__reactContainer$" + wy, t1 = "__reactEvents$" + wy, DC = "__reactListeners$" + wy, BC = "__reactHandles$" + wy;
    function FC(me) {
      delete me[_y], delete me[e1], delete me[t1], delete me[DC], delete me[BC];
    }
    function uv(me, ve) {
      ve[_y] = me;
    }
    function w0(me, ve) {
      ve[sv] = me;
    }
    function kS(me) {
      me[sv] = null;
    }
    function lv(me) {
      return !!me[sv];
    }
    function Gp(me) {
      var ve = me[_y];
      if (ve)
        return ve;
      for (var Ce = me.parentNode; Ce; ) {
        if (ve = Ce[sv] || Ce[_y], ve) {
          var Re = ve.alternate;
          if (ve.child !== null || Re !== null && Re.child !== null)
            for (var De = PS(me); De !== null; ) {
              var Ue = De[_y];
              if (Ue)
                return Ue;
              De = PS(De);
            }
          return ve;
        }
        me = Ce, Ce = me.parentNode;
      }
      return null;
    }
    function Rf(me) {
      var ve = me[_y] || me[sv];
      return ve && (ve.tag === ze || ve.tag === He || ve.tag === ht || ve.tag === Me) ? ve : null;
    }
    function xy(me) {
      if (me.tag === ze || me.tag === He)
        return me.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function _0(me) {
      return me[e1] || null;
    }
    function n1(me, ve) {
      me[e1] = ve;
    }
    function zC(me) {
      var ve = me[t1];
      return ve === void 0 && (ve = me[t1] = /* @__PURE__ */ new Set()), ve;
    }
    var OS = {}, CS = fe.ReactDebugCurrentFrame;
    function x0(me) {
      if (me) {
        var ve = me._owner, Ce = _u(me.type, me._source, ve ? ve.type : null);
        CS.setExtraStackFrame(Ce);
      } else
        CS.setExtraStackFrame(null);
    }
    function yl(me, ve, Ce, Re, De) {
      {
        var Ue = Function.call.bind($o);
        for (var Ye in me)
          if (Ue(me, Ye)) {
            var et = void 0;
            try {
              if (typeof me[Ye] != "function") {
                var at = Error((Re || "React class") + ": " + Ce + " type `" + Ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof me[Ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw at.name = "Invariant Violation", at;
              }
              et = me[Ye](ve, Ye, Re, Ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (yt) {
              et = yt;
            }
            et && !(et instanceof Error) && (x0(De), _e("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Re || "React class", Ce, Ye, typeof et), x0(null)), et instanceof Error && !(et.message in OS) && (OS[et.message] = !0, x0(De), _e("Failed %s type: %s", Ce, et.message), x0(null));
          }
      }
    }
    var r1 = [], E0;
    E0 = [];
    var jd = -1;
    function Nf(me) {
      return { current: me };
    }
    function ys(me, ve) {
      if (jd < 0) {
        _e("Unexpected pop.");
        return;
      }
      ve !== E0[jd] && _e("Unexpected Fiber popped."), me.current = r1[jd], r1[jd] = null, E0[jd] = null, jd--;
    }
    function bs(me, ve, Ce) {
      jd++, r1[jd] = me.current, E0[jd] = Ce, me.current = ve;
    }
    var o1;
    o1 = {};
    var yu = {};
    Object.freeze(yu);
    var Ld = Nf(yu), kc = Nf(!1), a1 = yu;
    function Ey(me, ve, Ce) {
      return Ce && Ac(ve) ? a1 : Ld.current;
    }
    function IS(me, ve, Ce) {
      {
        var Re = me.stateNode;
        Re.__reactInternalMemoizedUnmaskedChildContext = ve, Re.__reactInternalMemoizedMaskedChildContext = Ce;
      }
    }
    function Sy(me, ve) {
      {
        var Ce = me.type, Re = Ce.contextTypes;
        if (!Re)
          return yu;
        var De = me.stateNode;
        if (De && De.__reactInternalMemoizedUnmaskedChildContext === ve)
          return De.__reactInternalMemoizedMaskedChildContext;
        var Ue = {};
        for (var Ye in Re)
          Ue[Ye] = ve[Ye];
        {
          var et = Ar(me) || "Unknown";
          yl(Re, Ue, "context", et);
        }
        return De && IS(me, ve, Ue), Ue;
      }
    }
    function S0() {
      return kc.current;
    }
    function Ac(me) {
      {
        var ve = me.childContextTypes;
        return ve != null;
      }
    }
    function O0(me) {
      ys(kc, me), ys(Ld, me);
    }
    function i1(me) {
      ys(kc, me), ys(Ld, me);
    }
    function $S(me, ve, Ce) {
      {
        if (Ld.current !== yu)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        bs(Ld, ve, me), bs(kc, Ce, me);
      }
    }
    function RS(me, ve, Ce) {
      {
        var Re = me.stateNode, De = ve.childContextTypes;
        if (typeof Re.getChildContext != "function") {
          {
            var Ue = Ar(me) || "Unknown";
            o1[Ue] || (o1[Ue] = !0, _e("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", Ue, Ue));
          }
          return Ce;
        }
        var Ye = Re.getChildContext();
        for (var et in Ye)
          if (!(et in De))
            throw new Error((Ar(me) || "Unknown") + '.getChildContext(): key "' + et + '" is not defined in childContextTypes.');
        {
          var at = Ar(me) || "Unknown";
          yl(De, Ye, "child context", at);
        }
        return zr({}, Ce, Ye);
      }
    }
    function C0(me) {
      {
        var ve = me.stateNode, Ce = ve && ve.__reactInternalMemoizedMergedChildContext || yu;
        return a1 = Ld.current, bs(Ld, Ce, me), bs(kc, kc.current, me), !0;
      }
    }
    function NS(me, ve, Ce) {
      {
        var Re = me.stateNode;
        if (!Re)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (Ce) {
          var De = RS(me, ve, a1);
          Re.__reactInternalMemoizedMergedChildContext = De, ys(kc, me), ys(Ld, me), bs(Ld, De, me), bs(kc, Ce, me);
        } else
          ys(kc, me), bs(kc, Ce, me);
      }
    }
    function UC(me) {
      {
        if (!bb(me) || me.tag !== $e)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var ve = me;
        do {
          switch (ve.tag) {
            case Me:
              return ve.stateNode.context;
            case $e: {
              var Ce = ve.type;
              if (Ac(Ce))
                return ve.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          ve = ve.return;
        } while (ve !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Mf = 0, I0 = 1, Bd = null, s1 = !1, u1 = !1;
    function MS(me) {
      Bd === null ? Bd = [me] : Bd.push(me);
    }
    function VC(me) {
      s1 = !0, MS(me);
    }
    function jS() {
      s1 && jf();
    }
    function jf() {
      if (!u1 && Bd !== null) {
        u1 = !0;
        var me = 0, ve = $s();
        try {
          var Ce = !0, Re = Bd;
          for (Ra(cs); me < Re.length; me++) {
            var De = Re[me];
            do
              De = De(Ce);
            while (De !== null);
          }
          Bd = null, s1 = !1;
        } catch (Ue) {
          throw Bd !== null && (Bd = Bd.slice(me + 1)), gm(_m, jf), Ue;
        } finally {
          Ra(ve), u1 = !1;
        }
      }
      return null;
    }
    var Py = [], ky = 0, $0 = null, R0 = 0, Wu = [], Gu = 0, Yp = null, Fd = 1, zd = "";
    function HC(me) {
      return Kp(), (me.flags & hb) !== hr;
    }
    function ZC(me) {
      return Kp(), R0;
    }
    function qC() {
      var me = zd, ve = Fd, Ce = ve & ~WC(ve);
      return Ce.toString(32) + me;
    }
    function Qp(me, ve) {
      Kp(), Py[ky++] = R0, Py[ky++] = $0, $0 = me, R0 = ve;
    }
    function LS(me, ve, Ce) {
      Kp(), Wu[Gu++] = Fd, Wu[Gu++] = zd, Wu[Gu++] = Yp, Yp = me;
      var Re = Fd, De = zd, Ue = D0(Re) - 1, Ye = Re & ~(1 << Ue), et = Ce + 1, at = D0(ve) + Ue;
      if (at > 30) {
        var yt = Ue - Ue % 5, bt = (1 << yt) - 1, Ut = (Ye & bt).toString(32), jt = Ye >> yt, tn = Ue - yt, nn = D0(ve) + tn, bn = et << tn, Fn = bn | jt, sr = Ut + De;
        Fd = 1 << nn | Fn, zd = sr;
      } else {
        var wr = et << Ue, Zr = wr | Ye, Ur = De;
        Fd = 1 << at | Zr, zd = Ur;
      }
    }
    function l1(me) {
      Kp();
      var ve = me.return;
      if (ve !== null) {
        var Ce = 1, Re = 0;
        Qp(me, Ce), LS(me, Ce, Re);
      }
    }
    function D0(me) {
      return 32 - Tm(me);
    }
    function WC(me) {
      return 1 << D0(me) - 1;
    }
    function c1(me) {
      for (; me === $0; )
        $0 = Py[--ky], Py[ky] = null, R0 = Py[--ky], Py[ky] = null;
      for (; me === Yp; )
        Yp = Wu[--Gu], Wu[Gu] = null, zd = Wu[--Gu], Wu[Gu] = null, Fd = Wu[--Gu], Wu[Gu] = null;
    }
    function GC() {
      return Kp(), Yp !== null ? { id: Fd, overflow: zd } : null;
    }
    function YC(me, ve) {
      Kp(), Wu[Gu++] = Fd, Wu[Gu++] = zd, Wu[Gu++] = Yp, Fd = ve.id, zd = ve.overflow, Yp = me;
    }
    function Kp() {
      Di() || _e("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Li = null, Yu = null, bl = !1, Xp = !1, Lf = null;
    function QC() {
      bl && _e("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function DS() {
      Xp = !0;
    }
    function KC() {
      return Xp;
    }
    function XC(me) {
      var ve = me.stateNode.containerInfo;
      return Yu = yC(ve), Li = me, bl = !0, Lf = null, Xp = !1, !0;
    }
    function JC(me, ve, Ce) {
      return Yu = bC(ve), Li = me, bl = !0, Lf = null, Xp = !1, Ce !== null && YC(me, Ce), !0;
    }
    function BS(me, ve) {
      switch (me.tag) {
        case Me: {
          TC(me.stateNode.containerInfo, ve);
          break;
        }
        case ze: {
          var Ce = (me.mode & Vr) !== vr;
          AC(me.type, me.memoizedProps, me.stateNode, ve, Ce);
          break;
        }
        case ht: {
          var Re = me.memoizedState;
          Re.dehydrated !== null && OC(Re.dehydrated, ve);
          break;
        }
      }
    }
    function FS(me, ve) {
      BS(me, ve);
      var Ce = hM();
      Ce.stateNode = ve, Ce.return = me;
      var Re = me.deletions;
      Re === null ? (me.deletions = [Ce], me.flags |= yo) : Re.push(Ce);
    }
    function d1(me, ve) {
      {
        if (Xp)
          return;
        switch (me.tag) {
          case Me: {
            var Ce = me.stateNode.containerInfo;
            switch (ve.tag) {
              case ze:
                var Re = ve.type;
                ve.pendingProps, CC(Ce, Re);
                break;
              case He:
                var De = ve.pendingProps;
                IC(Ce, De);
                break;
            }
            break;
          }
          case ze: {
            var Ue = me.type, Ye = me.memoizedProps, et = me.stateNode;
            switch (ve.tag) {
              case ze: {
                var at = ve.type, yt = ve.pendingProps, bt = (me.mode & Vr) !== vr;
                NC(Ue, Ye, et, at, yt, bt);
                break;
              }
              case He: {
                var Ut = ve.pendingProps, jt = (me.mode & Vr) !== vr;
                MC(Ue, Ye, et, Ut, jt);
                break;
              }
            }
            break;
          }
          case ht: {
            var tn = me.memoizedState, nn = tn.dehydrated;
            if (nn !== null)
              switch (ve.tag) {
                case ze:
                  var bn = ve.type;
                  ve.pendingProps, $C(nn, bn);
                  break;
                case He:
                  var Fn = ve.pendingProps;
                  RC(nn, Fn);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function US(me, ve) {
      ve.flags = ve.flags & ~Ws | Lo, d1(me, ve);
    }
    function VS(me, ve) {
      switch (me.tag) {
        case ze: {
          var Ce = me.type;
          me.pendingProps;
          var Re = cC(ve, Ce);
          return Re !== null ? (me.stateNode = Re, Li = me, Yu = mC(Re), !0) : !1;
        }
        case He: {
          var De = me.pendingProps, Ue = dC(ve, De);
          return Ue !== null ? (me.stateNode = Ue, Li = me, Yu = null, !0) : !1;
        }
        case ht: {
          var Ye = fC(ve);
          if (Ye !== null) {
            var et = { dehydrated: Ye, treeContext: GC(), retryLane: us };
            me.memoizedState = et;
            var at = mM(Ye);
            return at.return = me, me.child = at, Li = me, Yu = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function f1(me) {
      return (me.mode & Vr) !== vr && (me.flags & Cr) === hr;
    }
    function p1(me) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function h1(me) {
      if (bl) {
        var ve = Yu;
        if (!ve) {
          f1(me) && (d1(Li, me), p1()), US(Li, me), bl = !1, Li = me;
          return;
        }
        var Ce = ve;
        if (!VS(me, ve)) {
          f1(me) && (d1(Li, me), p1()), ve = iv(Ce);
          var Re = Li;
          if (!ve || !VS(me, ve)) {
            US(Li, me), bl = !1, Li = me;
            return;
          }
          FS(Re, Ce);
        }
      }
    }
    function tI(me, ve, Ce) {
      var Re = me.stateNode, De = !Xp, Ue = vC(Re, me.type, me.memoizedProps, ve, Ce, me, De);
      return me.updateQueue = Ue, Ue !== null;
    }
    function nI(me) {
      var ve = me.stateNode, Ce = me.memoizedProps, Re = gC(ve, Ce, me);
      if (Re) {
        var De = Li;
        if (De !== null)
          switch (De.tag) {
            case Me: {
              var Ue = De.stateNode.containerInfo, Ye = (De.mode & Vr) !== vr;
              PC(Ue, ve, Ce, Ye);
              break;
            }
            case ze: {
              var et = De.type, at = De.memoizedProps, yt = De.stateNode, bt = (De.mode & Vr) !== vr;
              kC(et, at, yt, ve, Ce, bt);
              break;
            }
          }
      }
      return Re;
    }
    function rI(me) {
      var ve = me.memoizedState, Ce = ve !== null ? ve.dehydrated : null;
      if (!Ce)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      wC(Ce, me);
    }
    function oI(me) {
      var ve = me.memoizedState, Ce = ve !== null ? ve.dehydrated : null;
      if (!Ce)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return _C(Ce);
    }
    function HS(me) {
      for (var ve = me.return; ve !== null && ve.tag !== ze && ve.tag !== Me && ve.tag !== ht; )
        ve = ve.return;
      Li = ve;
    }
    function B0(me) {
      if (me !== Li)
        return !1;
      if (!bl)
        return HS(me), bl = !0, !1;
      if (me.tag !== Me && (me.tag !== ze || SC(me.type) && !Y_(me.type, me.memoizedProps))) {
        var ve = Yu;
        if (ve)
          if (f1(me))
            ZS(me), p1();
          else
            for (; ve; )
              FS(me, ve), ve = iv(ve);
      }
      return HS(me), me.tag === ht ? Yu = oI(me) : Yu = Li ? iv(me.stateNode) : null, !0;
    }
    function aI() {
      return bl && Yu !== null;
    }
    function ZS(me) {
      for (var ve = Yu; ve; )
        BS(me, ve), ve = iv(ve);
    }
    function Ty() {
      Li = null, Yu = null, bl = !1, Xp = !1;
    }
    function YS() {
      Lf !== null && (a2(Lf), Lf = null);
    }
    function Di() {
      return bl;
    }
    function m1(me) {
      Lf === null ? Lf = [me] : Lf.push(me);
    }
    var iI = fe.ReactCurrentBatchConfig, sI = null;
    function uI() {
      return iI.transition;
    }
    var vl = { recordUnsafeLifecycleWarnings: function(me, ve) {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function(me, ve) {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } };
    {
      var lI = function(me) {
        for (var ve = null, Ce = me; Ce !== null; )
          Ce.mode & ta && (ve = Ce), Ce = Ce.return;
        return ve;
      }, Jp = function(me) {
        var ve = [];
        return me.forEach(function(Ce) {
          ve.push(Ce);
        }), ve.sort().join(", ");
      }, cv = [], dv = [], fv = [], pv = [], hv = [], mv = [], oh = /* @__PURE__ */ new Set();
      vl.recordUnsafeLifecycleWarnings = function(me, ve) {
        oh.has(me.type) || (typeof ve.componentWillMount == "function" && ve.componentWillMount.__suppressDeprecationWarning !== !0 && cv.push(me), me.mode & ta && typeof ve.UNSAFE_componentWillMount == "function" && dv.push(me), typeof ve.componentWillReceiveProps == "function" && ve.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && fv.push(me), me.mode & ta && typeof ve.UNSAFE_componentWillReceiveProps == "function" && pv.push(me), typeof ve.componentWillUpdate == "function" && ve.componentWillUpdate.__suppressDeprecationWarning !== !0 && hv.push(me), me.mode & ta && typeof ve.UNSAFE_componentWillUpdate == "function" && mv.push(me));
      }, vl.flushPendingUnsafeLifecycleWarnings = function() {
        var me = /* @__PURE__ */ new Set();
        cv.length > 0 && (cv.forEach(function(jt) {
          me.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), cv = []);
        var ve = /* @__PURE__ */ new Set();
        dv.length > 0 && (dv.forEach(function(jt) {
          ve.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), dv = []);
        var Ce = /* @__PURE__ */ new Set();
        fv.length > 0 && (fv.forEach(function(jt) {
          Ce.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), fv = []);
        var Re = /* @__PURE__ */ new Set();
        pv.length > 0 && (pv.forEach(function(jt) {
          Re.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), pv = []);
        var De = /* @__PURE__ */ new Set();
        hv.length > 0 && (hv.forEach(function(jt) {
          De.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), hv = []);
        var Ue = /* @__PURE__ */ new Set();
        if (mv.length > 0 && (mv.forEach(function(jt) {
          Ue.add(Ar(jt) || "Component"), oh.add(jt.type);
        }), mv = []), ve.size > 0) {
          var Ye = Jp(ve);
          _e(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Ye);
        }
        if (Re.size > 0) {
          var et = Jp(Re);
          _e(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, et);
        }
        if (Ue.size > 0) {
          var at = Jp(Ue);
          _e(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, at);
        }
        if (me.size > 0) {
          var yt = Jp(me);
          we(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, yt);
        }
        if (Ce.size > 0) {
          var bt = Jp(Ce);
          we(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, bt);
        }
        if (De.size > 0) {
          var Ut = Jp(De);
          we(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ut);
        }
      };
      var V0 = /* @__PURE__ */ new Map(), QS = /* @__PURE__ */ new Set();
      vl.recordLegacyContextWarning = function(me, ve) {
        var Ce = lI(me);
        if (Ce === null) {
          _e("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!QS.has(me.type)) {
          var Re = V0.get(Ce);
          (me.type.contextTypes != null || me.type.childContextTypes != null || ve !== null && typeof ve.getChildContext == "function") && (Re === void 0 && (Re = [], V0.set(Ce, Re)), Re.push(me));
        }
      }, vl.flushLegacyContextWarning = function() {
        V0.forEach(function(me, ve) {
          if (me.length !== 0) {
            var Ce = me[0], Re = /* @__PURE__ */ new Set();
            me.forEach(function(Ue) {
              Re.add(Ar(Ue) || "Component"), QS.add(Ue.type);
            });
            var De = Jp(Re);
            try {
              lo(Ce), _e(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, De);
            } finally {
              Ko();
            }
          }
        });
      }, vl.discardPendingWarnings = function() {
        cv = [], dv = [], fv = [], pv = [], hv = [], mv = [], V0 = /* @__PURE__ */ new Map();
      };
    }
    function gl(me, ve) {
      if (me && me.defaultProps) {
        var Ce = zr({}, ve), Re = me.defaultProps;
        for (var De in Re)
          Ce[De] === void 0 && (Ce[De] = Re[De]);
        return Ce;
      }
      return ve;
    }
    var y1 = Nf(null), b1;
    b1 = {};
    var H0 = null, Oy = null, v1 = null, Z0 = !1;
    function q0() {
      H0 = null, Oy = null, v1 = null, Z0 = !1;
    }
    function KS() {
      Z0 = !0;
    }
    function XS() {
      Z0 = !1;
    }
    function PP(me, ve, Ce) {
      bs(y1, ve._currentValue, me), ve._currentValue = Ce, ve._currentRenderer !== void 0 && ve._currentRenderer !== null && ve._currentRenderer !== b1 && _e("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), ve._currentRenderer = b1;
    }
    function g1(me, ve) {
      var Ce = y1.current;
      ys(y1, ve), me._currentValue = Ce;
    }
    function w1(me, ve, Ce) {
      for (var Re = me; Re !== null; ) {
        var De = Re.alternate;
        if (Ed(Re.childLanes, ve) ? De !== null && !Ed(De.childLanes, ve) && (De.childLanes = Fr(De.childLanes, ve)) : (Re.childLanes = Fr(Re.childLanes, ve), De !== null && (De.childLanes = Fr(De.childLanes, ve))), Re === Ce)
          break;
        Re = Re.return;
      }
      Re !== Ce && _e("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function cI(me, ve, Ce) {
      fI(me, ve, Ce);
    }
    function fI(me, ve, Ce) {
      var Re = me.child;
      for (Re !== null && (Re.return = me); Re !== null; ) {
        var De = void 0, Ue = Re.dependencies;
        if (Ue !== null) {
          De = Re.child;
          for (var Ye = Ue.firstContext; Ye !== null; ) {
            if (Ye.context === ve) {
              if (Re.tag === $e) {
                var et = $a(Ce), at = Ud(Co, et);
                at.tag = Y0;
                var yt = Re.updateQueue;
                if (yt !== null) {
                  var bt = yt.shared, Ut = bt.pending;
                  Ut === null ? at.next = at : (at.next = Ut.next, Ut.next = at), bt.pending = at;
                }
              }
              Re.lanes = Fr(Re.lanes, Ce);
              var jt = Re.alternate;
              jt !== null && (jt.lanes = Fr(jt.lanes, Ce)), w1(Re.return, Ce, me), Ue.lanes = Fr(Ue.lanes, Ce);
              break;
            }
            Ye = Ye.next;
          }
        } else if (Re.tag === Xe)
          De = Re.type === me.type ? null : Re.child;
        else if (Re.tag === Ft) {
          var tn = Re.return;
          if (tn === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          tn.lanes = Fr(tn.lanes, Ce);
          var nn = tn.alternate;
          nn !== null && (nn.lanes = Fr(nn.lanes, Ce)), w1(tn, Ce, me), De = Re.sibling;
        } else
          De = Re.child;
        if (De !== null)
          De.return = Re;
        else
          for (De = Re; De !== null; ) {
            if (De === me) {
              De = null;
              break;
            }
            var bn = De.sibling;
            if (bn !== null) {
              bn.return = De.return, De = bn;
              break;
            }
            De = De.return;
          }
        Re = De;
      }
    }
    function Ay(me, ve) {
      H0 = me, Oy = null, v1 = null;
      var Ce = me.dependencies;
      if (Ce !== null) {
        var Re = Ce.firstContext;
        Re !== null && (ls(Ce.lanes, ve) && Av(), Ce.firstContext = null);
      }
    }
    function Ha(me) {
      Z0 && _e("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var ve = me._currentValue;
      if (v1 !== me) {
        var Ce = { context: me, memoizedValue: ve, next: null };
        if (Oy === null) {
          if (H0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Oy = Ce, H0.dependencies = { lanes: vn, firstContext: Ce };
        } else
          Oy = Oy.next = Ce;
      }
      return ve;
    }
    var ch = null;
    function _1(me) {
      ch === null ? ch = [me] : ch.push(me);
    }
    function pI() {
      if (ch !== null) {
        for (var me = 0; me < ch.length; me++) {
          var ve = ch[me], Ce = ve.interleaved;
          if (Ce !== null) {
            ve.interleaved = null;
            var Re = Ce.next, De = ve.pending;
            if (De !== null) {
              var Ue = De.next;
              De.next = Re, Ce.next = Ue;
            }
            ve.pending = Ce;
          }
        }
        ch = null;
      }
    }
    function kP(me, ve, Ce, Re) {
      var De = ve.interleaved;
      return De === null ? (Ce.next = Ce, _1(ve)) : (Ce.next = De.next, De.next = Ce), ve.interleaved = Ce, W0(me, Re);
    }
    function mI(me, ve, Ce, Re) {
      var De = ve.interleaved;
      De === null ? (Ce.next = Ce, _1(ve)) : (Ce.next = De.next, De.next = Ce), ve.interleaved = Ce;
    }
    function yI(me, ve, Ce, Re) {
      var De = ve.interleaved;
      return De === null ? (Ce.next = Ce, _1(ve)) : (Ce.next = De.next, De.next = Ce), ve.interleaved = Ce, W0(me, Re);
    }
    function ru(me, ve) {
      return W0(me, ve);
    }
    var bI = W0;
    function W0(me, ve) {
      me.lanes = Fr(me.lanes, ve);
      var Ce = me.alternate;
      Ce !== null && (Ce.lanes = Fr(Ce.lanes, ve)), Ce === null && (me.flags & (Lo | Ws)) !== hr && g2(me);
      for (var Re = me, De = me.return; De !== null; )
        De.childLanes = Fr(De.childLanes, ve), Ce = De.alternate, Ce !== null ? Ce.childLanes = Fr(Ce.childLanes, ve) : (De.flags & (Lo | Ws)) !== hr && g2(me), Re = De, De = De.return;
      if (Re.tag === Me) {
        var Ue = Re.stateNode;
        return Ue;
      } else
        return null;
    }
    var AP = 0, IP = 1, Y0 = 2, x1 = 3, Q0 = !1, E1, K0;
    E1 = !1, K0 = null;
    function S1(me) {
      var ve = { baseState: me.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: vn }, effects: null };
      me.updateQueue = ve;
    }
    function $P(me, ve) {
      var Ce = ve.updateQueue, Re = me.updateQueue;
      if (Ce === Re) {
        var De = { baseState: Re.baseState, firstBaseUpdate: Re.firstBaseUpdate, lastBaseUpdate: Re.lastBaseUpdate, shared: Re.shared, effects: Re.effects };
        ve.updateQueue = De;
      }
    }
    function Ud(me, ve) {
      var Ce = { eventTime: me, lane: ve, tag: AP, payload: null, callback: null, next: null };
      return Ce;
    }
    function Df(me, ve, Ce) {
      var Re = me.updateQueue;
      if (Re === null)
        return null;
      var De = Re.shared;
      if (K0 === De && !E1 && (_e("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), E1 = !0), kN()) {
        var Ue = De.pending;
        return Ue === null ? ve.next = ve : (ve.next = Ue.next, Ue.next = ve), De.pending = ve, bI(me, Ce);
      } else
        return yI(me, De, ve, Ce);
    }
    function X0(me, ve, Ce) {
      var Re = ve.updateQueue;
      if (Re !== null) {
        var De = Re.shared;
        if (Cb(Ce)) {
          var Ue = De.lanes;
          Ue = $b(Ue, me.pendingLanes);
          var Ye = Fr(Ue, Ce);
          De.lanes = Ye, Ip(me, Ye);
        }
      }
    }
    function P1(me, ve) {
      var Ce = me.updateQueue, Re = me.alternate;
      if (Re !== null) {
        var De = Re.updateQueue;
        if (Ce === De) {
          var Ue = null, Ye = null, et = Ce.firstBaseUpdate;
          if (et !== null) {
            var at = et;
            do {
              var yt = { eventTime: at.eventTime, lane: at.lane, tag: at.tag, payload: at.payload, callback: at.callback, next: null };
              Ye === null ? Ue = Ye = yt : (Ye.next = yt, Ye = yt), at = at.next;
            } while (at !== null);
            Ye === null ? Ue = Ye = ve : (Ye.next = ve, Ye = ve);
          } else
            Ue = Ye = ve;
          Ce = { baseState: De.baseState, firstBaseUpdate: Ue, lastBaseUpdate: Ye, shared: De.shared, effects: De.effects }, me.updateQueue = Ce;
          return;
        }
      }
      var bt = Ce.lastBaseUpdate;
      bt === null ? Ce.firstBaseUpdate = ve : bt.next = ve, Ce.lastBaseUpdate = ve;
    }
    function vI(me, ve, Ce, Re, De, Ue) {
      switch (Ce.tag) {
        case IP: {
          var Ye = Ce.payload;
          if (typeof Ye == "function") {
            KS();
            var et = Ye.call(Ue, Re, De);
            {
              if (me.mode & ta) {
                Ia(!0);
                try {
                  Ye.call(Ue, Re, De);
                } finally {
                  Ia(!1);
                }
              }
              XS();
            }
            return et;
          }
          return Ye;
        }
        case x1:
          me.flags = me.flags & ~za | Cr;
        case AP: {
          var at = Ce.payload, yt;
          if (typeof at == "function") {
            KS(), yt = at.call(Ue, Re, De);
            {
              if (me.mode & ta) {
                Ia(!0);
                try {
                  at.call(Ue, Re, De);
                } finally {
                  Ia(!1);
                }
              }
              XS();
            }
          } else
            yt = at;
          return yt == null ? Re : zr({}, Re, yt);
        }
        case Y0:
          return Q0 = !0, Re;
      }
      return Re;
    }
    function J0(me, ve, Ce, Re) {
      var De = me.updateQueue;
      Q0 = !1, K0 = De.shared;
      var Ue = De.firstBaseUpdate, Ye = De.lastBaseUpdate, et = De.shared.pending;
      if (et !== null) {
        De.shared.pending = null;
        var at = et, yt = at.next;
        at.next = null, Ye === null ? Ue = yt : Ye.next = yt, Ye = at;
        var bt = me.alternate;
        if (bt !== null) {
          var Ut = bt.updateQueue, jt = Ut.lastBaseUpdate;
          jt !== Ye && (jt === null ? Ut.firstBaseUpdate = yt : jt.next = yt, Ut.lastBaseUpdate = at);
        }
      }
      if (Ue !== null) {
        var tn = De.baseState, nn = vn, bn = null, Fn = null, sr = null, wr = Ue;
        do {
          var Zr = wr.lane, Ur = wr.eventTime;
          if (Ed(Re, Zr)) {
            if (sr !== null) {
              var Qt = { eventTime: Ur, lane: oo, tag: wr.tag, payload: wr.payload, callback: wr.callback, next: null };
              sr = sr.next = Qt;
            }
            tn = vI(me, De, wr, tn, ve, Ce);
            var yn = wr.callback;
            if (yn !== null && wr.lane !== oo) {
              me.flags |= Uu;
              var Xt = De.effects;
              Xt === null ? De.effects = [wr] : Xt.push(wr);
            }
          } else {
            var $n = { eventTime: Ur, lane: Zr, tag: wr.tag, payload: wr.payload, callback: wr.callback, next: null };
            sr === null ? (Fn = sr = $n, bn = tn) : sr = sr.next = $n, nn = Fr(nn, Zr);
          }
          if (wr = wr.next, wr === null) {
            if (et = De.shared.pending, et === null)
              break;
            var Gn = et, zn = Gn.next;
            Gn.next = null, wr = zn, De.lastBaseUpdate = Gn, De.shared.pending = null;
          }
        } while (!0);
        sr === null && (bn = tn), De.baseState = bn, De.firstBaseUpdate = Fn, De.lastBaseUpdate = sr;
        var Or = De.shared.interleaved;
        if (Or !== null) {
          var Mr = Or;
          do
            nn = Fr(nn, Mr.lane), Mr = Mr.next;
          while (Mr !== Or);
        } else
          Ue === null && (De.shared.lanes = vn);
        Fv(nn), me.lanes = nn, me.memoizedState = tn;
      }
      K0 = null;
    }
    function gI(me, ve) {
      if (typeof me != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + me));
      me.call(ve);
    }
    function NP() {
      Q0 = !1;
    }
    function ew() {
      return Q0;
    }
    function MP(me, ve, Ce) {
      var Re = ve.effects;
      if (ve.effects = null, Re !== null)
        for (var De = 0; De < Re.length; De++) {
          var Ue = Re[De], Ye = Ue.callback;
          Ye !== null && (Ue.callback = null, gI(Ye, Ce));
        }
    }
    var k1 = {}, jP = new oe.Component().refs, T1, O1, A1, C1, I1, LP, tw, $1, R1, N1;
    {
      T1 = /* @__PURE__ */ new Set(), O1 = /* @__PURE__ */ new Set(), A1 = /* @__PURE__ */ new Set(), C1 = /* @__PURE__ */ new Set(), $1 = /* @__PURE__ */ new Set(), I1 = /* @__PURE__ */ new Set(), R1 = /* @__PURE__ */ new Set(), N1 = /* @__PURE__ */ new Set();
      var DP = /* @__PURE__ */ new Set();
      tw = function(me, ve) {
        if (!(me === null || typeof me == "function")) {
          var Ce = ve + "_" + me;
          DP.has(Ce) || (DP.add(Ce), _e("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve, me));
        }
      }, LP = function(me, ve) {
        if (ve === void 0) {
          var Ce = uo(me) || "Component";
          I1.has(Ce) || (I1.add(Ce), _e("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", Ce));
        }
      }, Object.defineProperty(k1, "_processChildContext", { enumerable: !1, value: function() {
        throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
      } }), Object.freeze(k1);
    }
    function M1(me, ve, Ce, Re) {
      var De = me.memoizedState, Ue = Ce(Re, De);
      {
        if (me.mode & ta) {
          Ia(!0);
          try {
            Ue = Ce(Re, De);
          } finally {
            Ia(!1);
          }
        }
        LP(ve, Ue);
      }
      var Ye = Ue == null ? De : zr({}, De, Ue);
      if (me.memoizedState = Ye, me.lanes === vn) {
        var et = me.updateQueue;
        et.baseState = Ye;
      }
    }
    var j1 = { isMounted: As, enqueueSetState: function(me, ve, Ce) {
      var Re = Zs(me), De = Ds(), Ue = qf(Re), Ye = Ud(De, Ue);
      Ye.payload = ve, Ce != null && (tw(Ce, "setState"), Ye.callback = Ce);
      var et = Df(Re, Ye, Ue);
      et !== null && (Ei(et, Re, Ue, De), X0(et, Re, Ue)), ic(Re, Ue);
    }, enqueueReplaceState: function(me, ve, Ce) {
      var Re = Zs(me), De = Ds(), Ue = qf(Re), Ye = Ud(De, Ue);
      Ye.tag = IP, Ye.payload = ve, Ce != null && (tw(Ce, "replaceState"), Ye.callback = Ce);
      var et = Df(Re, Ye, Ue);
      et !== null && (Ei(et, Re, Ue, De), X0(et, Re, Ue)), ic(Re, Ue);
    }, enqueueForceUpdate: function(me, ve) {
      var Ce = Zs(me), Re = Ds(), De = qf(Ce), Ue = Ud(Re, De);
      Ue.tag = Y0, ve != null && (tw(ve, "forceUpdate"), Ue.callback = ve);
      var Ye = Df(Ce, Ue, De);
      Ye !== null && (Ei(Ye, Ce, De, Re), X0(Ye, Ce, De)), kb(Ce, De);
    } };
    function BP(me, ve, Ce, Re, De, Ue, Ye) {
      var et = me.stateNode;
      if (typeof et.shouldComponentUpdate == "function") {
        var at = et.shouldComponentUpdate(Re, Ue, Ye);
        {
          if (me.mode & ta) {
            Ia(!0);
            try {
              at = et.shouldComponentUpdate(Re, Ue, Ye);
            } finally {
              Ia(!1);
            }
          }
          at === void 0 && _e("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", uo(ve) || "Component");
        }
        return at;
      }
      return ve.prototype && ve.prototype.isPureReactComponent ? !dr(Ce, Re) || !dr(De, Ue) : !0;
    }
    function wI(me, ve, Ce) {
      var Re = me.stateNode;
      {
        var De = uo(ve) || "Component", Ue = Re.render;
        Ue || (ve.prototype && typeof ve.prototype.render == "function" ? _e("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", De) : _e("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", De)), Re.getInitialState && !Re.getInitialState.isReactClassApproved && !Re.state && _e("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", De), Re.getDefaultProps && !Re.getDefaultProps.isReactClassApproved && _e("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", De), Re.propTypes && _e("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", De), Re.contextType && _e("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", De), Re.contextTypes && _e("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", De), ve.contextType && ve.contextTypes && !R1.has(ve) && (R1.add(ve), _e("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", De)), typeof Re.componentShouldUpdate == "function" && _e("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", De), ve.prototype && ve.prototype.isPureReactComponent && typeof Re.shouldComponentUpdate < "u" && _e("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", uo(ve) || "A pure component"), typeof Re.componentDidUnmount == "function" && _e("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", De), typeof Re.componentDidReceiveProps == "function" && _e("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", De), typeof Re.componentWillRecieveProps == "function" && _e("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", De), typeof Re.UNSAFE_componentWillRecieveProps == "function" && _e("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", De);
        var Ye = Re.props !== Ce;
        Re.props !== void 0 && Ye && _e("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", De, De), Re.defaultProps && _e("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", De, De), typeof Re.getSnapshotBeforeUpdate == "function" && typeof Re.componentDidUpdate != "function" && !A1.has(ve) && (A1.add(ve), _e("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", uo(ve))), typeof Re.getDerivedStateFromProps == "function" && _e("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", De), typeof Re.getDerivedStateFromError == "function" && _e("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", De), typeof ve.getSnapshotBeforeUpdate == "function" && _e("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", De);
        var et = Re.state;
        et && (typeof et != "object" || Jo(et)) && _e("%s.state: must be set to an object or null", De), typeof Re.getChildContext == "function" && typeof ve.childContextTypes != "object" && _e("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", De);
      }
    }
    function FP(me, ve) {
      ve.updater = j1, me.stateNode = ve, cf(ve, me), ve._reactInternalInstance = k1;
    }
    function zP(me, ve, Ce) {
      var Re = !1, De = yu, Ue = yu, Ye = ve.contextType;
      if ("contextType" in ve) {
        var et = Ye === null || Ye !== void 0 && Ye.$$typeof === An && Ye._context === void 0;
        if (!et && !N1.has(ve)) {
          N1.add(ve);
          var at = "";
          Ye === void 0 ? at = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Ye != "object" ? at = " However, it is set to a " + typeof Ye + "." : Ye.$$typeof === En ? at = " Did you accidentally pass the Context.Provider instead?" : Ye._context !== void 0 ? at = " Did you accidentally pass the Context.Consumer instead?" : at = " However, it is set to an object with keys {" + Object.keys(Ye).join(", ") + "}.", _e("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", uo(ve) || "Component", at);
        }
      }
      if (typeof Ye == "object" && Ye !== null)
        Ue = Ha(Ye);
      else {
        De = Ey(me, ve, !0);
        var yt = ve.contextTypes;
        Re = yt != null, Ue = Re ? Sy(me, De) : yu;
      }
      var bt = new ve(Ce, Ue);
      if (me.mode & ta) {
        Ia(!0);
        try {
          bt = new ve(Ce, Ue);
        } finally {
          Ia(!1);
        }
      }
      var Ut = me.memoizedState = bt.state !== null && bt.state !== void 0 ? bt.state : null;
      FP(me, bt);
      {
        if (typeof ve.getDerivedStateFromProps == "function" && Ut === null) {
          var jt = uo(ve) || "Component";
          O1.has(jt) || (O1.add(jt), _e("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", jt, bt.state === null ? "null" : "undefined", jt));
        }
        if (typeof ve.getDerivedStateFromProps == "function" || typeof bt.getSnapshotBeforeUpdate == "function") {
          var tn = null, nn = null, bn = null;
          if (typeof bt.componentWillMount == "function" && bt.componentWillMount.__suppressDeprecationWarning !== !0 ? tn = "componentWillMount" : typeof bt.UNSAFE_componentWillMount == "function" && (tn = "UNSAFE_componentWillMount"), typeof bt.componentWillReceiveProps == "function" && bt.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? nn = "componentWillReceiveProps" : typeof bt.UNSAFE_componentWillReceiveProps == "function" && (nn = "UNSAFE_componentWillReceiveProps"), typeof bt.componentWillUpdate == "function" && bt.componentWillUpdate.__suppressDeprecationWarning !== !0 ? bn = "componentWillUpdate" : typeof bt.UNSAFE_componentWillUpdate == "function" && (bn = "UNSAFE_componentWillUpdate"), tn !== null || nn !== null || bn !== null) {
            var Fn = uo(ve) || "Component", sr = typeof ve.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            C1.has(Fn) || (C1.add(Fn), _e(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Fn, sr, tn !== null ? `
  ` + tn : "", nn !== null ? `
  ` + nn : "", bn !== null ? `
  ` + bn : ""));
          }
        }
      }
      return Re && IS(me, De, Ue), bt;
    }
    function _I(me, ve) {
      var Ce = ve.state;
      typeof ve.componentWillMount == "function" && ve.componentWillMount(), typeof ve.UNSAFE_componentWillMount == "function" && ve.UNSAFE_componentWillMount(), Ce !== ve.state && (_e("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ar(me) || "Component"), j1.enqueueReplaceState(ve, ve.state, null));
    }
    function UP(me, ve, Ce, Re) {
      var De = ve.state;
      if (typeof ve.componentWillReceiveProps == "function" && ve.componentWillReceiveProps(Ce, Re), typeof ve.UNSAFE_componentWillReceiveProps == "function" && ve.UNSAFE_componentWillReceiveProps(Ce, Re), ve.state !== De) {
        {
          var Ue = Ar(me) || "Component";
          T1.has(Ue) || (T1.add(Ue), _e("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ue));
        }
        j1.enqueueReplaceState(ve, ve.state, null);
      }
    }
    function L1(me, ve, Ce, Re) {
      wI(me, ve, Ce);
      var De = me.stateNode;
      De.props = Ce, De.state = me.memoizedState, De.refs = jP, S1(me);
      var Ue = ve.contextType;
      if (typeof Ue == "object" && Ue !== null)
        De.context = Ha(Ue);
      else {
        var Ye = Ey(me, ve, !0);
        De.context = Sy(me, Ye);
      }
      {
        if (De.state === Ce) {
          var et = uo(ve) || "Component";
          $1.has(et) || ($1.add(et), _e("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", et));
        }
        me.mode & ta && vl.recordLegacyContextWarning(me, De), vl.recordUnsafeLifecycleWarnings(me, De);
      }
      De.state = me.memoizedState;
      var at = ve.getDerivedStateFromProps;
      if (typeof at == "function" && (M1(me, ve, at, Ce), De.state = me.memoizedState), typeof ve.getDerivedStateFromProps != "function" && typeof De.getSnapshotBeforeUpdate != "function" && (typeof De.UNSAFE_componentWillMount == "function" || typeof De.componentWillMount == "function") && (_I(me, De), J0(me, Ce, De, Re), De.state = me.memoizedState), typeof De.componentDidMount == "function") {
        var yt = Br;
        yt |= rs, (me.mode & Qs) !== vr && (yt |= os), me.flags |= yt;
      }
    }
    function EI(me, ve, Ce, Re) {
      var De = me.stateNode, Ue = me.memoizedProps;
      De.props = Ue;
      var Ye = De.context, et = ve.contextType, at = yu;
      if (typeof et == "object" && et !== null)
        at = Ha(et);
      else {
        var yt = Ey(me, ve, !0);
        at = Sy(me, yt);
      }
      var bt = ve.getDerivedStateFromProps, Ut = typeof bt == "function" || typeof De.getSnapshotBeforeUpdate == "function";
      !Ut && (typeof De.UNSAFE_componentWillReceiveProps == "function" || typeof De.componentWillReceiveProps == "function") && (Ue !== Ce || Ye !== at) && UP(me, De, Ce, at), NP();
      var jt = me.memoizedState, tn = De.state = jt;
      if (J0(me, Ce, De, Re), tn = me.memoizedState, Ue === Ce && jt === tn && !S0() && !ew()) {
        if (typeof De.componentDidMount == "function") {
          var nn = Br;
          nn |= rs, (me.mode & Qs) !== vr && (nn |= os), me.flags |= nn;
        }
        return !1;
      }
      typeof bt == "function" && (M1(me, ve, bt, Ce), tn = me.memoizedState);
      var bn = ew() || BP(me, ve, Ue, Ce, jt, tn, at);
      if (bn) {
        if (!Ut && (typeof De.UNSAFE_componentWillMount == "function" || typeof De.componentWillMount == "function") && (typeof De.componentWillMount == "function" && De.componentWillMount(), typeof De.UNSAFE_componentWillMount == "function" && De.UNSAFE_componentWillMount()), typeof De.componentDidMount == "function") {
          var Fn = Br;
          Fn |= rs, (me.mode & Qs) !== vr && (Fn |= os), me.flags |= Fn;
        }
      } else {
        if (typeof De.componentDidMount == "function") {
          var sr = Br;
          sr |= rs, (me.mode & Qs) !== vr && (sr |= os), me.flags |= sr;
        }
        me.memoizedProps = Ce, me.memoizedState = tn;
      }
      return De.props = Ce, De.state = tn, De.context = at, bn;
    }
    function PI(me, ve, Ce, Re, De) {
      var Ue = ve.stateNode;
      $P(me, ve);
      var Ye = ve.memoizedProps, et = ve.type === ve.elementType ? Ye : gl(ve.type, Ye);
      Ue.props = et;
      var at = ve.pendingProps, yt = Ue.context, bt = Ce.contextType, Ut = yu;
      if (typeof bt == "object" && bt !== null)
        Ut = Ha(bt);
      else {
        var jt = Ey(ve, Ce, !0);
        Ut = Sy(ve, jt);
      }
      var tn = Ce.getDerivedStateFromProps, nn = typeof tn == "function" || typeof Ue.getSnapshotBeforeUpdate == "function";
      !nn && (typeof Ue.UNSAFE_componentWillReceiveProps == "function" || typeof Ue.componentWillReceiveProps == "function") && (Ye !== at || yt !== Ut) && UP(ve, Ue, Re, Ut), NP();
      var bn = ve.memoizedState, Fn = Ue.state = bn;
      if (J0(ve, Re, Ue, De), Fn = ve.memoizedState, Ye === at && bn === Fn && !S0() && !ew() && !Rn)
        return typeof Ue.componentDidUpdate == "function" && (Ye !== me.memoizedProps || bn !== me.memoizedState) && (ve.flags |= Br), typeof Ue.getSnapshotBeforeUpdate == "function" && (Ye !== me.memoizedProps || bn !== me.memoizedState) && (ve.flags |= qs), !1;
      typeof tn == "function" && (M1(ve, Ce, tn, Re), Fn = ve.memoizedState);
      var sr = ew() || BP(ve, Ce, et, Re, bn, Fn, Ut) || Rn;
      return sr ? (!nn && (typeof Ue.UNSAFE_componentWillUpdate == "function" || typeof Ue.componentWillUpdate == "function") && (typeof Ue.componentWillUpdate == "function" && Ue.componentWillUpdate(Re, Fn, Ut), typeof Ue.UNSAFE_componentWillUpdate == "function" && Ue.UNSAFE_componentWillUpdate(Re, Fn, Ut)), typeof Ue.componentDidUpdate == "function" && (ve.flags |= Br), typeof Ue.getSnapshotBeforeUpdate == "function" && (ve.flags |= qs)) : (typeof Ue.componentDidUpdate == "function" && (Ye !== me.memoizedProps || bn !== me.memoizedState) && (ve.flags |= Br), typeof Ue.getSnapshotBeforeUpdate == "function" && (Ye !== me.memoizedProps || bn !== me.memoizedState) && (ve.flags |= qs), ve.memoizedProps = Re, ve.memoizedState = Fn), Ue.props = Re, Ue.state = Fn, Ue.context = Ut, sr;
    }
    var D1, B1, F1, z1, U1, VP = function(me, ve) {
    };
    D1 = !1, B1 = !1, F1 = {}, z1 = {}, U1 = {}, VP = function(me, ve) {
      if (!(me === null || typeof me != "object") && !(!me._store || me._store.validated || me.key != null)) {
        if (typeof me._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        me._store.validated = !0;
        var Ce = Ar(ve) || "Component";
        z1[Ce] || (z1[Ce] = !0, _e('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function yv(me, ve, Ce) {
      var Re = Ce.ref;
      if (Re !== null && typeof Re != "function" && typeof Re != "object") {
        if ((me.mode & ta || Ht) && !(Ce._owner && Ce._self && Ce._owner.stateNode !== Ce._self)) {
          var De = Ar(me) || "Component";
          F1[De] || (_e('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Re), F1[De] = !0);
        }
        if (Ce._owner) {
          var Ue = Ce._owner, Ye;
          if (Ue) {
            var et = Ue;
            if (et.tag !== $e)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Ye = et.stateNode;
          }
          if (!Ye)
            throw new Error("Missing owner for string ref " + Re + ". This error is likely caused by a bug in React. Please file an issue.");
          var at = Ye;
          ca(Re, "ref");
          var yt = "" + Re;
          if (ve !== null && ve.ref !== null && typeof ve.ref == "function" && ve.ref._stringRef === yt)
            return ve.ref;
          var bt = function(Ut) {
            var jt = at.refs;
            jt === jP && (jt = at.refs = {}), Ut === null ? delete jt[yt] : jt[yt] = Ut;
          };
          return bt._stringRef = yt, bt;
        } else {
          if (typeof Re != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!Ce._owner)
            throw new Error("Element ref was specified as a string (" + Re + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return Re;
    }
    function nw(me, ve) {
      var Ce = Object.prototype.toString.call(ve);
      throw new Error("Objects are not valid as a React child (found: " + (Ce === "[object Object]" ? "object with keys {" + Object.keys(ve).join(", ") + "}" : Ce) + "). If you meant to render a collection of children, use an array instead.");
    }
    function rw(me) {
      {
        var ve = Ar(me) || "Component";
        if (U1[ve])
          return;
        U1[ve] = !0, _e("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function HP(me) {
      var ve = me._payload, Ce = me._init;
      return Ce(ve);
    }
    function ZP(me) {
      function ve(Qt, yn) {
        if (me) {
          var Xt = Qt.deletions;
          Xt === null ? (Qt.deletions = [yn], Qt.flags |= yo) : Xt.push(yn);
        }
      }
      function Ce(Qt, yn) {
        if (!me)
          return null;
        for (var Xt = yn; Xt !== null; )
          ve(Qt, Xt), Xt = Xt.sibling;
        return null;
      }
      function Re(Qt, yn) {
        for (var Xt = /* @__PURE__ */ new Map(), $n = yn; $n !== null; )
          $n.key !== null ? Xt.set($n.key, $n) : Xt.set($n.index, $n), $n = $n.sibling;
        return Xt;
      }
      function De(Qt, yn) {
        var Xt = em(Qt, yn);
        return Xt.index = 0, Xt.sibling = null, Xt;
      }
      function Ue(Qt, yn, Xt) {
        if (Qt.index = Xt, !me)
          return Qt.flags |= hb, yn;
        var $n = Qt.alternate;
        if ($n !== null) {
          var Gn = $n.index;
          return Gn < yn ? (Qt.flags |= Lo, yn) : Gn;
        } else
          return Qt.flags |= Lo, yn;
      }
      function Ye(Qt) {
        return me && Qt.alternate === null && (Qt.flags |= Lo), Qt;
      }
      function et(Qt, yn, Xt, $n) {
        if (yn === null || yn.tag !== He) {
          var Gn = jE(Xt, Qt.mode, $n);
          return Gn.return = Qt, Gn;
        } else {
          var zn = De(yn, Xt);
          return zn.return = Qt, zn;
        }
      }
      function at(Qt, yn, Xt, $n) {
        var Gn = Xt.type;
        if (Gn === aa)
          return bt(Qt, yn, Xt.props.children, $n, Xt.key);
        if (yn !== null && (yn.elementType === Gn || E2(yn, Xt) || typeof Gn == "object" && Gn !== null && Gn.$$typeof === fr && HP(Gn) === yn.type)) {
          var zn = De(yn, Xt.props);
          return zn.ref = yv(Qt, yn, Xt), zn.return = Qt, zn._debugSource = Xt._source, zn._debugOwner = Xt._owner, zn;
        }
        var Or = ME(Xt, Qt.mode, $n);
        return Or.ref = yv(Qt, yn, Xt), Or.return = Qt, Or;
      }
      function yt(Qt, yn, Xt, $n) {
        if (yn === null || yn.tag !== Be || yn.stateNode.containerInfo !== Xt.containerInfo || yn.stateNode.implementation !== Xt.implementation) {
          var Gn = LE(Xt, Qt.mode, $n);
          return Gn.return = Qt, Gn;
        } else {
          var zn = De(yn, Xt.children || []);
          return zn.return = Qt, zn;
        }
      }
      function bt(Qt, yn, Xt, $n, Gn) {
        if (yn === null || yn.tag !== Ze) {
          var zn = Gf(Xt, Qt.mode, $n, Gn);
          return zn.return = Qt, zn;
        } else {
          var Or = De(yn, Xt);
          return Or.return = Qt, Or;
        }
      }
      function Ut(Qt, yn, Xt) {
        if (typeof yn == "string" && yn !== "" || typeof yn == "number") {
          var $n = jE("" + yn, Qt.mode, Xt);
          return $n.return = Qt, $n;
        }
        if (typeof yn == "object" && yn !== null) {
          switch (yn.$$typeof) {
            case Jr: {
              var Gn = ME(yn, Qt.mode, Xt);
              return Gn.ref = yv(Qt, null, yn), Gn.return = Qt, Gn;
            }
            case vo: {
              var zn = LE(yn, Qt.mode, Xt);
              return zn.return = Qt, zn;
            }
            case fr: {
              var Or = yn._payload, Mr = yn._init;
              return Ut(Qt, Mr(Or), Xt);
            }
          }
          if (Jo(yn) || _s(yn)) {
            var To = Gf(yn, Qt.mode, Xt, null);
            return To.return = Qt, To;
          }
          nw(Qt, yn);
        }
        return typeof yn == "function" && rw(Qt), null;
      }
      function jt(Qt, yn, Xt, $n) {
        var Gn = yn !== null ? yn.key : null;
        if (typeof Xt == "string" && Xt !== "" || typeof Xt == "number")
          return Gn !== null ? null : et(Qt, yn, "" + Xt, $n);
        if (typeof Xt == "object" && Xt !== null) {
          switch (Xt.$$typeof) {
            case Jr:
              return Xt.key === Gn ? at(Qt, yn, Xt, $n) : null;
            case vo:
              return Xt.key === Gn ? yt(Qt, yn, Xt, $n) : null;
            case fr: {
              var zn = Xt._payload, Or = Xt._init;
              return jt(Qt, yn, Or(zn), $n);
            }
          }
          if (Jo(Xt) || _s(Xt))
            return Gn !== null ? null : bt(Qt, yn, Xt, $n, null);
          nw(Qt, Xt);
        }
        return typeof Xt == "function" && rw(Qt), null;
      }
      function tn(Qt, yn, Xt, $n, Gn) {
        if (typeof $n == "string" && $n !== "" || typeof $n == "number") {
          var zn = Qt.get(Xt) || null;
          return et(yn, zn, "" + $n, Gn);
        }
        if (typeof $n == "object" && $n !== null) {
          switch ($n.$$typeof) {
            case Jr: {
              var Or = Qt.get($n.key === null ? Xt : $n.key) || null;
              return at(yn, Or, $n, Gn);
            }
            case vo: {
              var Mr = Qt.get($n.key === null ? Xt : $n.key) || null;
              return yt(yn, Mr, $n, Gn);
            }
            case fr:
              var To = $n._payload, po = $n._init;
              return tn(Qt, yn, Xt, po(To), Gn);
          }
          if (Jo($n) || _s($n)) {
            var ja = Qt.get(Xt) || null;
            return bt(yn, ja, $n, Gn, null);
          }
          nw(yn, $n);
        }
        return typeof $n == "function" && rw(yn), null;
      }
      function nn(Qt, yn, Xt) {
        {
          if (typeof Qt != "object" || Qt === null)
            return yn;
          switch (Qt.$$typeof) {
            case Jr:
            case vo:
              VP(Qt, Xt);
              var $n = Qt.key;
              if (typeof $n != "string")
                break;
              if (yn === null) {
                yn = /* @__PURE__ */ new Set(), yn.add($n);
                break;
              }
              if (!yn.has($n)) {
                yn.add($n);
                break;
              }
              _e("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", $n);
              break;
            case fr:
              var Gn = Qt._payload, zn = Qt._init;
              nn(zn(Gn), yn, Xt);
              break;
          }
        }
        return yn;
      }
      function bn(Qt, yn, Xt, $n) {
        for (var Gn = null, zn = 0; zn < Xt.length; zn++) {
          var Or = Xt[zn];
          Gn = nn(Or, Gn, Qt);
        }
        for (var Mr = null, To = null, po = yn, ja = 0, ho = 0, Oa = null; po !== null && ho < Xt.length; ho++) {
          po.index > ho ? (Oa = po, po = null) : Oa = po.sibling;
          var gs = jt(Qt, po, Xt[ho], $n);
          if (gs === null) {
            po === null && (po = Oa);
            break;
          }
          me && po && gs.alternate === null && ve(Qt, po), ja = Ue(gs, ja, ho), To === null ? Mr = gs : To.sibling = gs, To = gs, po = Oa;
        }
        if (ho === Xt.length) {
          if (Ce(Qt, po), Di()) {
            var Wi = ho;
            Qp(Qt, Wi);
          }
          return Mr;
        }
        if (po === null) {
          for (; ho < Xt.length; ho++) {
            var vu = Ut(Qt, Xt[ho], $n);
            vu !== null && (ja = Ue(vu, ja, ho), To === null ? Mr = vu : To.sibling = vu, To = vu);
          }
          if (Di()) {
            var Bs = ho;
            Qp(Qt, Bs);
          }
          return Mr;
        }
        for (var Fs = Re(Qt, po); ho < Xt.length; ho++) {
          var ws = tn(Fs, Qt, ho, Xt[ho], $n);
          ws !== null && (me && ws.alternate !== null && Fs.delete(ws.key === null ? ho : ws.key), ja = Ue(ws, ja, ho), To === null ? Mr = ws : To.sibling = ws, To = ws);
        }
        if (me && Fs.forEach(function(qy) {
          return ve(Qt, qy);
        }), Di()) {
          var Gd = ho;
          Qp(Qt, Gd);
        }
        return Mr;
      }
      function Fn(Qt, yn, Xt, $n) {
        var Gn = _s(Xt);
        if (typeof Gn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && Xt[Symbol.toStringTag] === "Generator" && (B1 || _e("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), B1 = !0), Xt.entries === Gn && (D1 || _e("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), D1 = !0);
          var zn = Gn.call(Xt);
          if (zn)
            for (var Or = null, Mr = zn.next(); !Mr.done; Mr = zn.next()) {
              var To = Mr.value;
              Or = nn(To, Or, Qt);
            }
        }
        var po = Gn.call(Xt);
        if (po == null)
          throw new Error("An iterable object provided no iterator.");
        for (var ja = null, ho = null, Oa = yn, gs = 0, Wi = 0, vu = null, Bs = po.next(); Oa !== null && !Bs.done; Wi++, Bs = po.next()) {
          Oa.index > Wi ? (vu = Oa, Oa = null) : vu = Oa.sibling;
          var Fs = jt(Qt, Oa, Bs.value, $n);
          if (Fs === null) {
            Oa === null && (Oa = vu);
            break;
          }
          me && Oa && Fs.alternate === null && ve(Qt, Oa), gs = Ue(Fs, gs, Wi), ho === null ? ja = Fs : ho.sibling = Fs, ho = Fs, Oa = vu;
        }
        if (Bs.done) {
          if (Ce(Qt, Oa), Di()) {
            var ws = Wi;
            Qp(Qt, ws);
          }
          return ja;
        }
        if (Oa === null) {
          for (; !Bs.done; Wi++, Bs = po.next()) {
            var Gd = Ut(Qt, Bs.value, $n);
            Gd !== null && (gs = Ue(Gd, gs, Wi), ho === null ? ja = Gd : ho.sibling = Gd, ho = Gd);
          }
          if (Di()) {
            var qy = Wi;
            Qp(Qt, qy);
          }
          return ja;
        }
        for (var Zv = Re(Qt, Oa); !Bs.done; Wi++, Bs = po.next()) {
          var Bc = tn(Zv, Qt, Wi, Bs.value, $n);
          Bc !== null && (me && Bc.alternate !== null && Zv.delete(Bc.key === null ? Wi : Bc.key), gs = Ue(Bc, gs, Wi), ho === null ? ja = Bc : ho.sibling = Bc, ho = Bc);
        }
        if (me && Zv.forEach(function(qM) {
          return ve(Qt, qM);
        }), Di()) {
          var ZM = Wi;
          Qp(Qt, ZM);
        }
        return ja;
      }
      function sr(Qt, yn, Xt, $n) {
        if (yn !== null && yn.tag === He) {
          Ce(Qt, yn.sibling);
          var Gn = De(yn, Xt);
          return Gn.return = Qt, Gn;
        }
        Ce(Qt, yn);
        var zn = jE(Xt, Qt.mode, $n);
        return zn.return = Qt, zn;
      }
      function wr(Qt, yn, Xt, $n) {
        for (var Gn = Xt.key, zn = yn; zn !== null; ) {
          if (zn.key === Gn) {
            var Or = Xt.type;
            if (Or === aa) {
              if (zn.tag === Ze) {
                Ce(Qt, zn.sibling);
                var Mr = De(zn, Xt.props.children);
                return Mr.return = Qt, Mr._debugSource = Xt._source, Mr._debugOwner = Xt._owner, Mr;
              }
            } else if (zn.elementType === Or || E2(zn, Xt) || typeof Or == "object" && Or !== null && Or.$$typeof === fr && HP(Or) === zn.type) {
              Ce(Qt, zn.sibling);
              var To = De(zn, Xt.props);
              return To.ref = yv(Qt, zn, Xt), To.return = Qt, To._debugSource = Xt._source, To._debugOwner = Xt._owner, To;
            }
            Ce(Qt, zn);
            break;
          } else
            ve(Qt, zn);
          zn = zn.sibling;
        }
        if (Xt.type === aa) {
          var po = Gf(Xt.props.children, Qt.mode, $n, Xt.key);
          return po.return = Qt, po;
        } else {
          var ja = ME(Xt, Qt.mode, $n);
          return ja.ref = yv(Qt, yn, Xt), ja.return = Qt, ja;
        }
      }
      function Zr(Qt, yn, Xt, $n) {
        for (var Gn = Xt.key, zn = yn; zn !== null; ) {
          if (zn.key === Gn)
            if (zn.tag === Be && zn.stateNode.containerInfo === Xt.containerInfo && zn.stateNode.implementation === Xt.implementation) {
              Ce(Qt, zn.sibling);
              var Or = De(zn, Xt.children || []);
              return Or.return = Qt, Or;
            } else {
              Ce(Qt, zn);
              break;
            }
          else
            ve(Qt, zn);
          zn = zn.sibling;
        }
        var Mr = LE(Xt, Qt.mode, $n);
        return Mr.return = Qt, Mr;
      }
      function Ur(Qt, yn, Xt, $n) {
        var Gn = typeof Xt == "object" && Xt !== null && Xt.type === aa && Xt.key === null;
        if (Gn && (Xt = Xt.props.children), typeof Xt == "object" && Xt !== null) {
          switch (Xt.$$typeof) {
            case Jr:
              return Ye(wr(Qt, yn, Xt, $n));
            case vo:
              return Ye(Zr(Qt, yn, Xt, $n));
            case fr:
              var zn = Xt._payload, Or = Xt._init;
              return Ur(Qt, yn, Or(zn), $n);
          }
          if (Jo(Xt))
            return bn(Qt, yn, Xt, $n);
          if (_s(Xt))
            return Fn(Qt, yn, Xt, $n);
          nw(Qt, Xt);
        }
        return typeof Xt == "string" && Xt !== "" || typeof Xt == "number" ? Ye(sr(Qt, yn, "" + Xt, $n)) : (typeof Xt == "function" && rw(Qt), Ce(Qt, yn));
      }
      return Ur;
    }
    var Cy = ZP(!0), qP = ZP(!1);
    function kI(me, ve) {
      if (me !== null && ve.child !== me.child)
        throw new Error("Resuming work not yet implemented.");
      if (ve.child !== null) {
        var Ce = ve.child, Re = em(Ce, Ce.pendingProps);
        for (ve.child = Re, Re.return = ve; Ce.sibling !== null; )
          Ce = Ce.sibling, Re = Re.sibling = em(Ce, Ce.pendingProps), Re.return = ve;
        Re.sibling = null;
      }
    }
    function OI(me, ve) {
      for (var Ce = me.child; Ce !== null; )
        lM(Ce, ve), Ce = Ce.sibling;
    }
    var bv = {}, Bf = Nf(bv), vv = Nf(bv), ow = Nf(bv);
    function aw(me) {
      if (me === bv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return me;
    }
    function WP() {
      var me = aw(ow.current);
      return me;
    }
    function V1(me, ve) {
      bs(ow, ve, me), bs(vv, me, me), bs(Bf, bv, me);
      var Ce = WO(ve);
      ys(Bf, me), bs(Bf, Ce, me);
    }
    function Iy(me) {
      ys(Bf, me), ys(vv, me), ys(ow, me);
    }
    function H1() {
      var me = aw(Bf.current);
      return me;
    }
    function GP(me) {
      aw(ow.current);
      var ve = aw(Bf.current), Ce = GO(ve, me.type);
      ve !== Ce && (bs(vv, me, me), bs(Bf, Ce, me));
    }
    function Z1(me) {
      vv.current === me && (ys(Bf, me), ys(vv, me));
    }
    var CI = 0, YP = 1, QP = 1, gv = 2, wl = Nf(CI);
    function q1(me, ve) {
      return (me & ve) !== 0;
    }
    function $y(me) {
      return me & YP;
    }
    function W1(me, ve) {
      return me & YP | ve;
    }
    function II(me, ve) {
      return me | ve;
    }
    function Ff(me, ve) {
      bs(wl, ve, me);
    }
    function Ry(me) {
      ys(wl, me);
    }
    function $I(me, ve) {
      var Ce = me.memoizedState;
      return Ce !== null ? Ce.dehydrated !== null : (me.memoizedProps, !0);
    }
    function iw(me) {
      for (var ve = me; ve !== null; ) {
        if (ve.tag === ht) {
          var Ce = ve.memoizedState;
          if (Ce !== null) {
            var Re = Ce.dehydrated;
            if (Re === null || SS(Re) || J_(Re))
              return ve;
          }
        } else if (ve.tag === on && ve.memoizedProps.revealOrder !== void 0) {
          var De = (ve.flags & Cr) !== hr;
          if (De)
            return ve;
        } else if (ve.child !== null) {
          ve.child.return = ve, ve = ve.child;
          continue;
        }
        if (ve === me)
          return null;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === me)
            return null;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
      return null;
    }
    var ou = 0, mi = 1, Ic = 2, yi = 4, Bi = 8, G1 = [];
    function Y1() {
      for (var me = 0; me < G1.length; me++) {
        var ve = G1[me];
        ve._workInProgressVersionPrimary = null;
      }
      G1.length = 0;
    }
    function BI(me, ve) {
      var Ce = ve._getVersion, Re = Ce(ve._source);
      me.mutableSourceEagerHydrationData == null ? me.mutableSourceEagerHydrationData = [ve, Re] : me.mutableSourceEagerHydrationData.push(ve, Re);
    }
    var Wn = fe.ReactCurrentDispatcher, wv = fe.ReactCurrentBatchConfig, Q1, Ny;
    Q1 = /* @__PURE__ */ new Set();
    var fh = vn, ko = null, bi = null, vi = null, sw = !1, _v = !1, xv = 0, UI = 0, VI = 25, gn = null, Qu = null, zf = -1, K1 = !1;
    function wo() {
      {
        var me = gn;
        Qu === null ? Qu = [me] : Qu.push(me);
      }
    }
    function Dn() {
      {
        var me = gn;
        Qu !== null && (zf++, Qu[zf] !== me && WI(me));
      }
    }
    function My(me) {
      me != null && !Jo(me) && _e("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", gn, typeof me);
    }
    function WI(me) {
      {
        var ve = Ar(ko);
        if (!Q1.has(ve) && (Q1.add(ve), Qu !== null)) {
          for (var Ce = "", Re = 30, De = 0; De <= zf; De++) {
            for (var Ue = Qu[De], Ye = De === zf ? me : Ue, et = De + 1 + ". " + Ue; et.length < Re; )
              et += " ";
            et += Ye + `
`, Ce += et;
          }
          _e(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, ve, Ce);
        }
      }
    }
    function vs() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function X1(me, ve) {
      if (K1)
        return !1;
      if (ve === null)
        return _e("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", gn), !1;
      me.length !== ve.length && _e(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, gn, "[" + ve.join(", ") + "]", "[" + me.join(", ") + "]");
      for (var Ce = 0; Ce < ve.length && Ce < me.length; Ce++)
        if (!Zn(me[Ce], ve[Ce]))
          return !1;
      return !0;
    }
    function jy(me, ve, Ce, Re, De, Ue) {
      fh = Ue, ko = ve, Qu = me !== null ? me._debugHookTypes : null, zf = -1, K1 = me !== null && me.type !== ve.type, ve.memoizedState = null, ve.updateQueue = null, ve.lanes = vn, me !== null && me.memoizedState !== null ? Wn.current = oT : Qu !== null ? Wn.current = rT : Wn.current = nT;
      var Ye = Ce(Re, De);
      if (_v) {
        var et = 0;
        do {
          if (_v = !1, xv = 0, et >= VI)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          et += 1, K1 = !1, bi = null, vi = null, ve.updateQueue = null, zf = -1, Wn.current = aT, Ye = Ce(Re, De);
        } while (_v);
      }
      Wn.current = _w, ve._debugHookTypes = Qu;
      var at = bi !== null && bi.next !== null;
      if (fh = vn, ko = null, bi = null, vi = null, gn = null, Qu = null, zf = -1, me !== null && (me.flags & ci) !== (ve.flags & ci) && (me.mode & Vr) !== vr && _e("Internal React error: Expected static flag was missing. Please notify the React team."), sw = !1, at)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Ye;
    }
    function Ly() {
      var me = xv !== 0;
      return xv = 0, me;
    }
    function KP(me, ve, Ce) {
      ve.updateQueue = me.updateQueue, (ve.mode & Qs) !== vr ? ve.flags &= ~(rd | os | Go | Br) : ve.flags &= ~(Go | Br), me.lanes = gf(me.lanes, Ce);
    }
    function XP() {
      if (Wn.current = _w, sw) {
        for (var me = ko.memoizedState; me !== null; ) {
          var ve = me.queue;
          ve !== null && (ve.pending = null), me = me.next;
        }
        sw = !1;
      }
      fh = vn, ko = null, bi = null, vi = null, Qu = null, zf = -1, gn = null, Qk = !1, _v = !1, xv = 0;
    }
    function $c() {
      var me = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return vi === null ? ko.memoizedState = vi = me : vi = vi.next = me, vi;
    }
    function Ku() {
      var me;
      if (bi === null) {
        var ve = ko.alternate;
        ve !== null ? me = ve.memoizedState : me = null;
      } else
        me = bi.next;
      var Ce;
      if (vi === null ? Ce = ko.memoizedState : Ce = vi.next, Ce !== null)
        vi = Ce, Ce = vi.next, bi = me;
      else {
        if (me === null)
          throw new Error("Rendered more hooks than during the previous render.");
        bi = me;
        var Re = { memoizedState: bi.memoizedState, baseState: bi.baseState, baseQueue: bi.baseQueue, queue: bi.queue, next: null };
        vi === null ? ko.memoizedState = vi = Re : vi = vi.next = Re;
      }
      return vi;
    }
    function JP() {
      return { lastEffect: null, stores: null };
    }
    function J1(me, ve) {
      return typeof ve == "function" ? ve(me) : ve;
    }
    function wx(me, ve, Ce) {
      var Re = $c(), De;
      Ce !== void 0 ? De = Ce(ve) : De = ve, Re.memoizedState = Re.baseState = De;
      var Ue = { pending: null, interleaved: null, lanes: vn, dispatch: null, lastRenderedReducer: me, lastRenderedState: De };
      Re.queue = Ue;
      var Ye = Ue.dispatch = KI.bind(null, ko, Ue);
      return [Re.memoizedState, Ye];
    }
    function _x(me, ve, Ce) {
      var Re = Ku(), De = Re.queue;
      if (De === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      De.lastRenderedReducer = me;
      var Ue = bi, Ye = Ue.baseQueue, et = De.pending;
      if (et !== null) {
        if (Ye !== null) {
          var at = Ye.next, yt = et.next;
          Ye.next = yt, et.next = at;
        }
        Ue.baseQueue !== Ye && _e("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), Ue.baseQueue = Ye = et, De.pending = null;
      }
      if (Ye !== null) {
        var bt = Ye.next, Ut = Ue.baseState, jt = null, tn = null, nn = null, bn = bt;
        do {
          var Fn = bn.lane;
          if (Ed(fh, Fn)) {
            if (nn !== null) {
              var sr = { lane: oo, action: bn.action, hasEagerState: bn.hasEagerState, eagerState: bn.eagerState, next: null };
              nn = nn.next = sr;
            }
            if (bn.hasEagerState)
              Ut = bn.eagerState;
            else {
              var wr = bn.action;
              Ut = me(Ut, wr);
            }
          } else {
            var Zr = { lane: Fn, action: bn.action, hasEagerState: bn.hasEagerState, eagerState: bn.eagerState, next: null };
            nn === null ? (tn = nn = Zr, jt = Ut) : nn = nn.next = Zr, ko.lanes = Fr(ko.lanes, Fn), Fv(Fn);
          }
          bn = bn.next;
        } while (bn !== null && bn !== bt);
        nn === null ? jt = Ut : nn.next = tn, Zn(Ut, Re.memoizedState) || Av(), Re.memoizedState = Ut, Re.baseState = jt, Re.baseQueue = nn, De.lastRenderedState = Ut;
      }
      var Ur = De.interleaved;
      if (Ur !== null) {
        var Qt = Ur;
        do {
          var yn = Qt.lane;
          ko.lanes = Fr(ko.lanes, yn), Fv(yn), Qt = Qt.next;
        } while (Qt !== Ur);
      } else
        Ye === null && (De.lanes = vn);
      var Xt = De.dispatch;
      return [Re.memoizedState, Xt];
    }
    function xx(me, ve, Ce) {
      var Re = Ku(), De = Re.queue;
      if (De === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      De.lastRenderedReducer = me;
      var Ue = De.dispatch, Ye = De.pending, et = Re.memoizedState;
      if (Ye !== null) {
        De.pending = null;
        var at = Ye.next, yt = at;
        do {
          var bt = yt.action;
          et = me(et, bt), yt = yt.next;
        } while (yt !== at);
        Zn(et, Re.memoizedState) || Av(), Re.memoizedState = et, Re.baseQueue === null && (Re.baseState = et), De.lastRenderedState = et;
      }
      return [et, Ue];
    }
    function Ex(me, ve, Ce) {
      var Re = ko, De = $c(), Ue, Ye = Di();
      if (Ye) {
        if (Ce === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        Ue = Ce(), Ny || Ue !== Ce() && (_e("The result of getServerSnapshot should be cached to avoid an infinite loop"), Ny = !0);
      } else {
        if (Ue = ve(), !Ny) {
          var et = ve();
          Zn(Ue, et) || (_e("The result of getSnapshot should be cached to avoid an infinite loop"), Ny = !0);
        }
        var at = Fw();
        if (at === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Cp(at, fh) || wk(Re, ve, Ue);
      }
      De.memoizedState = Ue;
      var yt = { value: Ue, getSnapshot: ve };
      return De.queue = yt, pw(Ik.bind(null, Re, yt, me), [me]), Re.flags |= Go, Ev(mi | Bi, _k.bind(null, Re, yt, Ue, ve), void 0, null), Ue;
    }
    function uw(me, ve, Ce) {
      var Re = ko, De = Ku(), Ue = ve();
      if (!Ny) {
        var Ye = ve();
        Zn(Ue, Ye) || (_e("The result of getSnapshot should be cached to avoid an infinite loop"), Ny = !0);
      }
      var et = De.memoizedState, at = !Zn(et, Ue);
      at && (De.memoizedState = Ue, Av());
      var yt = De.queue;
      if (Pv(Ik.bind(null, Re, yt, me), [me]), yt.getSnapshot !== ve || at || vi !== null && vi.memoizedState.tag & mi) {
        Re.flags |= Go, Ev(mi | Bi, _k.bind(null, Re, yt, Ue, ve), void 0, null);
        var bt = Fw();
        if (bt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Cp(bt, fh) || wk(Re, ve, Ue);
      }
      return Ue;
    }
    function wk(me, ve, Ce) {
      me.flags |= wp;
      var Re = { getSnapshot: ve, value: Ce }, De = ko.updateQueue;
      if (De === null)
        De = JP(), ko.updateQueue = De, De.stores = [Re];
      else {
        var Ue = De.stores;
        Ue === null ? De.stores = [Re] : Ue.push(Re);
      }
    }
    function _k(me, ve, Ce, Re) {
      ve.value = Ce, ve.getSnapshot = Re, jk(ve) && Lk(me);
    }
    function Ik(me, ve, Ce) {
      var Re = function() {
        jk(ve) && Lk(me);
      };
      return Ce(Re);
    }
    function jk(me) {
      var ve = me.getSnapshot, Ce = me.value;
      try {
        var Re = ve();
        return !Zn(Ce, Re);
      } catch {
        return !0;
      }
    }
    function Lk(me) {
      var ve = ru(me, kr);
      ve !== null && Ei(ve, me, kr, Co);
    }
    function lw(me) {
      var ve = $c();
      typeof me == "function" && (me = me()), ve.memoizedState = ve.baseState = me;
      var Ce = { pending: null, interleaved: null, lanes: vn, dispatch: null, lastRenderedReducer: J1, lastRenderedState: me };
      ve.queue = Ce;
      var Re = Ce.dispatch = XI.bind(null, ko, Ce);
      return [ve.memoizedState, Re];
    }
    function Px(me) {
      return _x(J1);
    }
    function kx(me) {
      return xx(J1);
    }
    function Ev(me, ve, Ce, Re) {
      var De = { tag: me, create: ve, destroy: Ce, deps: Re, next: null }, Ue = ko.updateQueue;
      if (Ue === null)
        Ue = JP(), ko.updateQueue = Ue, Ue.lastEffect = De.next = De;
      else {
        var Ye = Ue.lastEffect;
        if (Ye === null)
          Ue.lastEffect = De.next = De;
        else {
          var et = Ye.next;
          Ye.next = De, De.next = et, Ue.lastEffect = De;
        }
      }
      return De;
    }
    function Tx(me) {
      var ve = $c();
      {
        var Ce = { current: me };
        return ve.memoizedState = Ce, Ce;
      }
    }
    function cw(me) {
      var ve = Ku();
      return ve.memoizedState;
    }
    function Sv(me, ve, Ce, Re) {
      var De = $c(), Ue = Re === void 0 ? null : Re;
      ko.flags |= me, De.memoizedState = Ev(mi | ve, Ce, void 0, Ue);
    }
    function fw(me, ve, Ce, Re) {
      var De = Ku(), Ue = Re === void 0 ? null : Re, Ye = void 0;
      if (bi !== null) {
        var et = bi.memoizedState;
        if (Ye = et.destroy, Ue !== null) {
          var at = et.deps;
          if (X1(Ue, at)) {
            De.memoizedState = Ev(ve, Ce, Ye, Ue);
            return;
          }
        }
      }
      ko.flags |= me, De.memoizedState = Ev(mi | ve, Ce, Ye, Ue);
    }
    function pw(me, ve) {
      return (ko.mode & Qs) !== vr ? Sv(rd | Go | Jl, Bi, me, ve) : Sv(Go | Jl, Bi, me, ve);
    }
    function Pv(me, ve) {
      return fw(Go, Bi, me, ve);
    }
    function Ox(me, ve) {
      return Sv(Br, Ic, me, ve);
    }
    function hw(me, ve) {
      return fw(Br, Ic, me, ve);
    }
    function Ax(me, ve) {
      var Ce = Br;
      return Ce |= rs, (ko.mode & Qs) !== vr && (Ce |= os), Sv(Ce, yi, me, ve);
    }
    function mw(me, ve) {
      return fw(Br, yi, me, ve);
    }
    function Bk(me, ve) {
      if (typeof ve == "function") {
        var Ce = ve, Re = me();
        return Ce(Re), function() {
          Ce(null);
        };
      } else if (ve != null) {
        var De = ve;
        De.hasOwnProperty("current") || _e("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(De).join(", ") + "}");
        var Ue = me();
        return De.current = Ue, function() {
          De.current = null;
        };
      }
    }
    function Cx(me, ve, Ce) {
      typeof ve != "function" && _e("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ve !== null ? typeof ve : "null");
      var Re = Ce != null ? Ce.concat([me]) : null, De = Br;
      return De |= rs, (ko.mode & Qs) !== vr && (De |= os), Sv(De, yi, Bk.bind(null, ve, me), Re);
    }
    function yw(me, ve, Ce) {
      typeof ve != "function" && _e("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ve !== null ? typeof ve : "null");
      var Re = Ce != null ? Ce.concat([me]) : null;
      return fw(Br, yi, Bk.bind(null, ve, me), Re);
    }
    function GI(me, ve) {
    }
    var bw = GI;
    function Ix(me, ve) {
      var Ce = $c(), Re = ve === void 0 ? null : ve;
      return Ce.memoizedState = [me, Re], me;
    }
    function vw(me, ve) {
      var Ce = Ku(), Re = ve === void 0 ? null : ve, De = Ce.memoizedState;
      if (De !== null && Re !== null) {
        var Ue = De[1];
        if (X1(Re, Ue))
          return De[0];
      }
      return Ce.memoizedState = [me, Re], me;
    }
    function $x(me, ve) {
      var Ce = $c(), Re = ve === void 0 ? null : ve, De = me();
      return Ce.memoizedState = [De, Re], De;
    }
    function gw(me, ve) {
      var Ce = Ku(), Re = ve === void 0 ? null : ve, De = Ce.memoizedState;
      if (De !== null && Re !== null) {
        var Ue = De[1];
        if (X1(Re, Ue))
          return De[0];
      }
      var Ye = me();
      return Ce.memoizedState = [Ye, Re], Ye;
    }
    function Rx(me) {
      var ve = $c();
      return ve.memoizedState = me, me;
    }
    function zk(me) {
      var ve = Ku(), Ce = bi, Re = Ce.memoizedState;
      return Hk(ve, Re, me);
    }
    function Vk(me) {
      var ve = Ku();
      if (bi === null)
        return ve.memoizedState = me, me;
      var Ce = bi.memoizedState;
      return Hk(ve, Ce, me);
    }
    function Hk(me, ve, Ce) {
      var Re = !w_(fh);
      if (Re) {
        if (!Zn(Ce, ve)) {
          var De = Ib();
          ko.lanes = Fr(ko.lanes, De), Fv(De), me.baseState = !0;
        }
        return ve;
      } else
        return me.baseState && (me.baseState = !1, Av()), me.memoizedState = Ce, Ce;
    }
    function YI(me, ve, Ce) {
      var Re = $s();
      Ra($p(Re, Xs)), me(!0);
      var De = wv.transition;
      wv.transition = {};
      var Ue = wv.transition;
      wv.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        me(!1), ve();
      } finally {
        if (Ra(Re), wv.transition = De, De === null && Ue._updatedFibers) {
          var Ye = Ue._updatedFibers.size;
          Ye > 10 && we("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ue._updatedFibers.clear();
        }
      }
    }
    function Nx() {
      var me = lw(!1), ve = me[0], Ce = me[1], Re = YI.bind(null, Ce), De = $c();
      return De.memoizedState = Re, [ve, Re];
    }
    function qk() {
      var me = Px(), ve = me[0], Ce = Ku(), Re = Ce.memoizedState;
      return [ve, Re];
    }
    function Gk() {
      var me = kx(), ve = me[0], Ce = Ku(), Re = Ce.memoizedState;
      return [ve, Re];
    }
    var Qk = !1;
    function QI() {
      return Qk;
    }
    function Mx() {
      var me = $c(), ve = Fw(), Ce = ve.identifierPrefix, Re;
      if (Di()) {
        var De = qC();
        Re = ":" + Ce + "R" + De;
        var Ue = xv++;
        Ue > 0 && (Re += "H" + Ue.toString(32)), Re += ":";
      } else {
        var Ye = UI++;
        Re = ":" + Ce + "r" + Ye.toString(32) + ":";
      }
      return me.memoizedState = Re, Re;
    }
    function ww() {
      var me = Ku(), ve = me.memoizedState;
      return ve;
    }
    function KI(me, ve, Ce) {
      typeof arguments[3] == "function" && _e("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Re = qf(me), De = { lane: Re, action: Ce, hasEagerState: !1, eagerState: null, next: null };
      if (Kk(me))
        Jk(ve, De);
      else {
        var Ue = kP(me, ve, De, Re);
        if (Ue !== null) {
          var Ye = Ds();
          Ei(Ue, me, Re, Ye), eT(Ue, ve, Re);
        }
      }
      tT(me, Re);
    }
    function XI(me, ve, Ce) {
      typeof arguments[3] == "function" && _e("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Re = qf(me), De = { lane: Re, action: Ce, hasEagerState: !1, eagerState: null, next: null };
      if (Kk(me))
        Jk(ve, De);
      else {
        var Ue = me.alternate;
        if (me.lanes === vn && (Ue === null || Ue.lanes === vn)) {
          var Ye = ve.lastRenderedReducer;
          if (Ye !== null) {
            var et;
            et = Wn.current, Wn.current = _l;
            try {
              var at = ve.lastRenderedState, yt = Ye(at, Ce);
              if (De.hasEagerState = !0, De.eagerState = yt, Zn(yt, at)) {
                mI(me, ve, De, Re);
                return;
              }
            } catch {
            } finally {
              Wn.current = et;
            }
          }
        }
        var bt = kP(me, ve, De, Re);
        if (bt !== null) {
          var Ut = Ds();
          Ei(bt, me, Re, Ut), eT(bt, ve, Re);
        }
      }
      tT(me, Re);
    }
    function Kk(me) {
      var ve = me.alternate;
      return me === ko || ve !== null && ve === ko;
    }
    function Jk(me, ve) {
      _v = sw = !0;
      var Ce = me.pending;
      Ce === null ? ve.next = ve : (ve.next = Ce.next, Ce.next = ve), me.pending = ve;
    }
    function eT(me, ve, Ce) {
      if (Cb(Ce)) {
        var Re = ve.lanes;
        Re = $b(Re, me.pendingLanes);
        var De = Fr(Re, Ce);
        ve.lanes = De, Ip(me, De);
      }
    }
    function tT(me, ve, Ce) {
      ic(me, ve);
    }
    var _w = { readContext: Ha, useCallback: vs, useContext: vs, useEffect: vs, useImperativeHandle: vs, useInsertionEffect: vs, useLayoutEffect: vs, useMemo: vs, useReducer: vs, useRef: vs, useState: vs, useDebugValue: vs, useDeferredValue: vs, useTransition: vs, useMutableSource: vs, useSyncExternalStore: vs, useId: vs, unstable_isNewReconciler: xn }, nT = null, rT = null, oT = null, aT = null, Nc = null, _l = null, xw = null;
    {
      var jx = function() {
        _e("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Nr = function() {
        _e("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      nT = { readContext: function(me) {
        return Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", wo(), My(ve), Ix(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", wo(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", wo(), My(ve), pw(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", wo(), My(Ce), Cx(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", wo(), My(ve), Ox(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", wo(), My(ve), Ax(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", wo(), My(ve);
        var Ce = Wn.current;
        Wn.current = Nc;
        try {
          return $x(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", wo();
        var Re = Wn.current;
        Wn.current = Nc;
        try {
          return wx(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", wo(), Tx(me);
      }, useState: function(me) {
        gn = "useState", wo();
        var ve = Wn.current;
        Wn.current = Nc;
        try {
          return lw(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", wo(), void 0;
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", wo(), Rx(me);
      }, useTransition: function() {
        return gn = "useTransition", wo(), Nx();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", wo(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", wo(), Ex(me, ve, Ce);
      }, useId: function() {
        return gn = "useId", wo(), Mx();
      }, unstable_isNewReconciler: xn }, rT = { readContext: function(me) {
        return Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Dn(), Ix(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Dn(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Dn(), pw(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Dn(), Cx(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Dn(), Ox(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Dn(), Ax(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Dn();
        var Ce = Wn.current;
        Wn.current = Nc;
        try {
          return $x(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Dn();
        var Re = Wn.current;
        Wn.current = Nc;
        try {
          return wx(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Dn(), Tx(me);
      }, useState: function(me) {
        gn = "useState", Dn();
        var ve = Wn.current;
        Wn.current = Nc;
        try {
          return lw(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Dn(), void 0;
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Dn(), Rx(me);
      }, useTransition: function() {
        return gn = "useTransition", Dn(), Nx();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Dn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Dn(), Ex(me, ve, Ce);
      }, useId: function() {
        return gn = "useId", Dn(), Mx();
      }, unstable_isNewReconciler: xn }, oT = { readContext: function(me) {
        return Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Dn(), vw(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Dn(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Dn(), Pv(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Dn(), yw(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Dn(), hw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Dn(), mw(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Dn();
        var Ce = Wn.current;
        Wn.current = _l;
        try {
          return gw(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Dn();
        var Re = Wn.current;
        Wn.current = _l;
        try {
          return _x(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Dn(), cw();
      }, useState: function(me) {
        gn = "useState", Dn();
        var ve = Wn.current;
        Wn.current = _l;
        try {
          return Px(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Dn(), bw();
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Dn(), zk(me);
      }, useTransition: function() {
        return gn = "useTransition", Dn(), qk();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Dn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Dn(), uw(me, ve);
      }, useId: function() {
        return gn = "useId", Dn(), ww();
      }, unstable_isNewReconciler: xn }, aT = { readContext: function(me) {
        return Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Dn(), vw(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Dn(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Dn(), Pv(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Dn(), yw(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Dn(), hw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Dn(), mw(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Dn();
        var Ce = Wn.current;
        Wn.current = xw;
        try {
          return gw(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Dn();
        var Re = Wn.current;
        Wn.current = xw;
        try {
          return xx(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Dn(), cw();
      }, useState: function(me) {
        gn = "useState", Dn();
        var ve = Wn.current;
        Wn.current = xw;
        try {
          return kx(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Dn(), bw();
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Dn(), Vk(me);
      }, useTransition: function() {
        return gn = "useTransition", Dn(), Gk();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Dn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Dn(), uw(me, ve);
      }, useId: function() {
        return gn = "useId", Dn(), ww();
      }, unstable_isNewReconciler: xn }, Nc = { readContext: function(me) {
        return jx(), Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Nr(), wo(), Ix(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Nr(), wo(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Nr(), wo(), pw(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Nr(), wo(), Cx(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Nr(), wo(), Ox(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Nr(), wo(), Ax(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Nr(), wo();
        var Ce = Wn.current;
        Wn.current = Nc;
        try {
          return $x(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Nr(), wo();
        var Re = Wn.current;
        Wn.current = Nc;
        try {
          return wx(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Nr(), wo(), Tx(me);
      }, useState: function(me) {
        gn = "useState", Nr(), wo();
        var ve = Wn.current;
        Wn.current = Nc;
        try {
          return lw(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Nr(), wo(), void 0;
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Nr(), wo(), Rx(me);
      }, useTransition: function() {
        return gn = "useTransition", Nr(), wo(), Nx();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Nr(), wo(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Nr(), wo(), Ex(me, ve, Ce);
      }, useId: function() {
        return gn = "useId", Nr(), wo(), Mx();
      }, unstable_isNewReconciler: xn }, _l = { readContext: function(me) {
        return jx(), Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Nr(), Dn(), vw(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Nr(), Dn(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Nr(), Dn(), Pv(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Nr(), Dn(), yw(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Nr(), Dn(), hw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Nr(), Dn(), mw(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Nr(), Dn();
        var Ce = Wn.current;
        Wn.current = _l;
        try {
          return gw(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Nr(), Dn();
        var Re = Wn.current;
        Wn.current = _l;
        try {
          return _x(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Nr(), Dn(), cw();
      }, useState: function(me) {
        gn = "useState", Nr(), Dn();
        var ve = Wn.current;
        Wn.current = _l;
        try {
          return Px(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Nr(), Dn(), bw();
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Nr(), Dn(), zk(me);
      }, useTransition: function() {
        return gn = "useTransition", Nr(), Dn(), qk();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Nr(), Dn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Nr(), Dn(), uw(me, ve);
      }, useId: function() {
        return gn = "useId", Nr(), Dn(), ww();
      }, unstable_isNewReconciler: xn }, xw = { readContext: function(me) {
        return jx(), Ha(me);
      }, useCallback: function(me, ve) {
        return gn = "useCallback", Nr(), Dn(), vw(me, ve);
      }, useContext: function(me) {
        return gn = "useContext", Nr(), Dn(), Ha(me);
      }, useEffect: function(me, ve) {
        return gn = "useEffect", Nr(), Dn(), Pv(me, ve);
      }, useImperativeHandle: function(me, ve, Ce) {
        return gn = "useImperativeHandle", Nr(), Dn(), yw(me, ve, Ce);
      }, useInsertionEffect: function(me, ve) {
        return gn = "useInsertionEffect", Nr(), Dn(), hw(me, ve);
      }, useLayoutEffect: function(me, ve) {
        return gn = "useLayoutEffect", Nr(), Dn(), mw(me, ve);
      }, useMemo: function(me, ve) {
        gn = "useMemo", Nr(), Dn();
        var Ce = Wn.current;
        Wn.current = _l;
        try {
          return gw(me, ve);
        } finally {
          Wn.current = Ce;
        }
      }, useReducer: function(me, ve, Ce) {
        gn = "useReducer", Nr(), Dn();
        var Re = Wn.current;
        Wn.current = _l;
        try {
          return xx(me, ve, Ce);
        } finally {
          Wn.current = Re;
        }
      }, useRef: function(me) {
        return gn = "useRef", Nr(), Dn(), cw();
      }, useState: function(me) {
        gn = "useState", Nr(), Dn();
        var ve = Wn.current;
        Wn.current = _l;
        try {
          return kx(me);
        } finally {
          Wn.current = ve;
        }
      }, useDebugValue: function(me, ve) {
        return gn = "useDebugValue", Nr(), Dn(), bw();
      }, useDeferredValue: function(me) {
        return gn = "useDeferredValue", Nr(), Dn(), Vk(me);
      }, useTransition: function() {
        return gn = "useTransition", Nr(), Dn(), Gk();
      }, useMutableSource: function(me, ve, Ce) {
        return gn = "useMutableSource", Nr(), Dn(), void 0;
      }, useSyncExternalStore: function(me, ve, Ce) {
        return gn = "useSyncExternalStore", Nr(), Dn(), uw(me, ve);
      }, useId: function() {
        return gn = "useId", Nr(), Dn(), ww();
      }, unstable_isNewReconciler: xn };
    }
    var Uf = ae.unstable_now, iT = 0, Ew = -1, kv = -1, Sw = -1, Lx = !1, Pw = !1;
    function sT() {
      return Lx;
    }
    function x$() {
      Pw = !0;
    }
    function Z$() {
      Lx = !1, Pw = !1;
    }
    function W$() {
      Lx = Pw, Pw = !1;
    }
    function uT() {
      return iT;
    }
    function lT() {
      iT = Uf();
    }
    function Dx(me) {
      kv = Uf(), me.actualStartTime < 0 && (me.actualStartTime = Uf());
    }
    function cT(me) {
      kv = -1;
    }
    function kw(me, ve) {
      if (kv >= 0) {
        var Ce = Uf() - kv;
        me.actualDuration += Ce, ve && (me.selfBaseDuration = Ce), kv = -1;
      }
    }
    function Mc(me) {
      if (Ew >= 0) {
        var ve = Uf() - Ew;
        Ew = -1;
        for (var Ce = me.return; Ce !== null; ) {
          switch (Ce.tag) {
            case Me:
              var Re = Ce.stateNode;
              Re.effectDuration += ve;
              return;
            case pt:
              var De = Ce.stateNode;
              De.effectDuration += ve;
              return;
          }
          Ce = Ce.return;
        }
      }
    }
    function Bx(me) {
      if (Sw >= 0) {
        var ve = Uf() - Sw;
        Sw = -1;
        for (var Ce = me.return; Ce !== null; ) {
          switch (Ce.tag) {
            case Me:
              var Re = Ce.stateNode;
              Re !== null && (Re.passiveEffectDuration += ve);
              return;
            case pt:
              var De = Ce.stateNode;
              De !== null && (De.passiveEffectDuration += ve);
              return;
          }
          Ce = Ce.return;
        }
      }
    }
    function jc() {
      Ew = Uf();
    }
    function Fx() {
      Sw = Uf();
    }
    function zx(me) {
      for (var ve = me.child; ve; )
        me.actualDuration += ve.actualDuration, ve = ve.sibling;
    }
    function Zh(me, ve) {
      return { value: me, source: ve, stack: Su(ve), digest: null };
    }
    function Ux(me, ve, Ce) {
      return { value: me, source: null, stack: Ce ?? null, digest: ve ?? null };
    }
    function G$(me, ve) {
      return !0;
    }
    function Vx(me, ve) {
      try {
        var Ce = G$(me, ve);
        if (Ce === !1)
          return;
        var Re = ve.value, De = ve.source, Ue = ve.stack, Ye = Ue !== null ? Ue : "";
        if (Re != null && Re._suppressLogging) {
          if (me.tag === $e)
            return;
          console.error(Re);
        }
        var et = De ? Ar(De) : null, at = et ? "The above error occurred in the <" + et + "> component:" : "The above error occurred in one of your React components:", yt;
        if (me.tag === Me)
          yt = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var bt = Ar(me) || "Anonymous";
          yt = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + bt + ".");
        }
        var Ut = at + `
` + Ye + `

` + ("" + yt);
        console.error(Ut);
      } catch (jt) {
        setTimeout(function() {
          throw jt;
        });
      }
    }
    var Y$ = typeof WeakMap == "function" ? WeakMap : Map;
    function dT(me, ve, Ce) {
      var Re = Ud(Co, Ce);
      Re.tag = x1, Re.payload = { element: null };
      var De = ve.value;
      return Re.callback = function() {
        VN(De), Vx(me, ve);
      }, Re;
    }
    function Hx(me, ve, Ce) {
      var Re = Ud(Co, Ce);
      Re.tag = x1;
      var De = me.type.getDerivedStateFromError;
      if (typeof De == "function") {
        var Ue = ve.value;
        Re.payload = function() {
          return De(Ue);
        }, Re.callback = function() {
          S2(me), Vx(me, ve);
        };
      }
      var Ye = me.stateNode;
      return Ye !== null && typeof Ye.componentDidCatch == "function" && (Re.callback = function() {
        S2(me), Vx(me, ve), typeof De != "function" && zN(this);
        var et = ve.value, at = ve.stack;
        this.componentDidCatch(et, { componentStack: at !== null ? at : "" }), typeof De != "function" && (ls(me.lanes, kr) || _e("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ar(me) || "Unknown"));
      }), Re;
    }
    function fT(me, ve, Ce) {
      var Re = me.pingCache, De;
      if (Re === null ? (Re = me.pingCache = new Y$(), De = /* @__PURE__ */ new Set(), Re.set(ve, De)) : (De = Re.get(ve), De === void 0 && (De = /* @__PURE__ */ new Set(), Re.set(ve, De))), !De.has(Ce)) {
        De.add(Ce);
        var Ue = HN.bind(null, me, ve, Ce);
        di && zv(me, Ce), ve.then(Ue, Ue);
      }
    }
    function Q$(me, ve, Ce, Re) {
      var De = me.updateQueue;
      if (De === null) {
        var Ue = /* @__PURE__ */ new Set();
        Ue.add(Ce), me.updateQueue = Ue;
      } else
        De.add(Ce);
    }
    function K$(me, ve) {
      var Ce = me.tag;
      if ((me.mode & Vr) === vr && (Ce === Ie || Ce === ot || Ce === gt)) {
        var Re = me.alternate;
        Re ? (me.updateQueue = Re.updateQueue, me.memoizedState = Re.memoizedState, me.lanes = Re.lanes) : (me.updateQueue = null, me.memoizedState = null);
      }
    }
    function pT(me) {
      var ve = me;
      do {
        if (ve.tag === ht && $I(ve))
          return ve;
        ve = ve.return;
      } while (ve !== null);
      return null;
    }
    function hT(me, ve, Ce, Re, De) {
      if ((me.mode & Vr) === vr) {
        if (me === ve)
          me.flags |= za;
        else {
          if (me.flags |= Cr, Ce.flags |= _p, Ce.flags &= ~(ym | Ts), Ce.tag === $e) {
            var Ue = Ce.alternate;
            if (Ue === null)
              Ce.tag = Nt;
            else {
              var Ye = Ud(Co, kr);
              Ye.tag = Y0, Df(Ce, Ye, kr);
            }
          }
          Ce.lanes = Fr(Ce.lanes, kr);
        }
        return me;
      }
      return me.flags |= za, me.lanes = De, me;
    }
    function X$(me, ve, Ce, Re, De) {
      if (Ce.flags |= Ts, di && zv(me, De), Re !== null && typeof Re == "object" && typeof Re.then == "function") {
        var Ue = Re;
        K$(Ce), Di() && Ce.mode & Vr && DS();
        var Ye = pT(ve);
        if (Ye !== null) {
          Ye.flags &= ~ua, hT(Ye, ve, Ce, me, De), Ye.mode & Vr && fT(me, Ue, De), Q$(Ye, me, Ue);
          return;
        } else {
          if (!vf(De)) {
            fT(me, Ue, De), EE();
            return;
          }
          var et = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          Re = et;
        }
      } else if (Di() && Ce.mode & Vr) {
        DS();
        var at = pT(ve);
        if (at !== null) {
          (at.flags & za) === hr && (at.flags |= ua), hT(at, ve, Ce, me, De), m1(Zh(Re, Ce));
          return;
        }
      }
      Re = Zh(Re, Ce), RN(Re);
      var yt = ve;
      do {
        switch (yt.tag) {
          case Me: {
            var bt = Re;
            yt.flags |= za;
            var Ut = $a(De);
            yt.lanes = Fr(yt.lanes, Ut);
            var jt = dT(yt, bt, Ut);
            P1(yt, jt);
            return;
          }
          case $e:
            var tn = Re, nn = yt.type, bn = yt.stateNode;
            if ((yt.flags & Cr) === hr && (typeof nn.getDerivedStateFromError == "function" || bn !== null && typeof bn.componentDidCatch == "function" && !m2(bn))) {
              yt.flags |= za;
              var Fn = $a(De);
              yt.lanes = Fr(yt.lanes, Fn);
              var sr = Hx(yt, tn, Fn);
              P1(yt, sr);
              return;
            }
            break;
        }
        yt = yt.return;
      } while (yt !== null);
    }
    function J$() {
      return null;
    }
    var Tv = fe.ReactCurrentOwner, xl = !1, Zx, Ov, qx, Wx, Gx, Gh, Yx, Tw;
    Zx = {}, Ov = {}, qx = {}, Wx = {}, Gx = {}, Gh = !1, Yx = {}, Tw = {};
    function js(me, ve, Ce, Re) {
      me === null ? ve.child = qP(ve, null, Ce, Re) : ve.child = Cy(ve, me.child, Ce, Re);
    }
    function eR(me, ve, Ce, Re) {
      ve.child = Cy(ve, me.child, null, Re), ve.child = Cy(ve, null, Ce, Re);
    }
    function mT(me, ve, Ce, Re, De) {
      if (ve.type !== ve.elementType) {
        var Ue = Ce.propTypes;
        Ue && yl(Ue, Re, "prop", uo(Ce));
      }
      var Ye = Ce.render, et = ve.ref, at, yt;
      Ay(ve, De), ac(ve);
      {
        if (Tv.current = ve, Mi(!0), at = jy(me, ve, Ye, Re, et, De), yt = Ly(), ve.mode & ta) {
          Ia(!0);
          try {
            at = jy(me, ve, Ye, Re, et, De), yt = Ly();
          } finally {
            Ia(!1);
          }
        }
        Mi(!1);
      }
      return od(), me !== null && !xl ? (KP(me, ve, De), Vd(me, ve, De)) : (Di() && yt && l1(ve), ve.flags |= Ql, js(me, ve, at, De), ve.child);
    }
    function yT(me, ve, Ce, Re, De) {
      if (me === null) {
        var Ue = Ce.type;
        if (sM(Ue) && Ce.compare === null && Ce.defaultProps === void 0) {
          var Ye = Ue;
          return Ye = Zy(Ue), ve.tag = gt, ve.type = Ye, Xx(ve, Ue), bT(me, ve, Ye, Re, De);
        }
        {
          var et = Ue.propTypes;
          et && yl(et, Re, "prop", uo(Ue));
        }
        var at = NE(Ce.type, null, Re, ve, ve.mode, De);
        return at.ref = ve.ref, at.return = ve, ve.child = at, at;
      }
      {
        var yt = Ce.type, bt = yt.propTypes;
        bt && yl(bt, Re, "prop", uo(yt));
      }
      var Ut = me.child, jt = oE(me, De);
      if (!jt) {
        var tn = Ut.memoizedProps, nn = Ce.compare;
        if (nn = nn !== null ? nn : dr, nn(tn, Re) && me.ref === ve.ref)
          return Vd(me, ve, De);
      }
      ve.flags |= Ql;
      var bn = em(Ut, Re);
      return bn.ref = ve.ref, bn.return = ve, ve.child = bn, bn;
    }
    function bT(me, ve, Ce, Re, De) {
      if (ve.type !== ve.elementType) {
        var Ue = ve.elementType;
        if (Ue.$$typeof === fr) {
          var Ye = Ue, et = Ye._payload, at = Ye._init;
          try {
            Ue = at(et);
          } catch {
            Ue = null;
          }
          var yt = Ue && Ue.propTypes;
          yt && yl(yt, Re, "prop", uo(Ue));
        }
      }
      if (me !== null) {
        var bt = me.memoizedProps;
        if (dr(bt, Re) && me.ref === ve.ref && ve.type === me.type)
          if (xl = !1, ve.pendingProps = Re = bt, oE(me, De))
            (me.flags & _p) !== hr && (xl = !0);
          else
            return ve.lanes = me.lanes, Vd(me, ve, De);
      }
      return Qx(me, ve, Ce, Re, De);
    }
    function vT(me, ve, Ce) {
      var Re = ve.pendingProps, De = Re.children, Ue = me !== null ? me.memoizedState : null;
      if (Re.mode === "hidden" || At)
        if ((ve.mode & Vr) === vr) {
          var Ye = { baseLanes: vn, cachePool: null, transitions: null };
          ve.memoizedState = Ye, zw(ve, Ce);
        } else if (ls(Ce, us)) {
          var et = { baseLanes: vn, cachePool: null, transitions: null };
          ve.memoizedState = et;
          var at = Ue !== null ? Ue.baseLanes : Ce;
          zw(ve, at);
        } else {
          var yt = null, bt;
          if (Ue !== null) {
            var Ut = Ue.baseLanes;
            bt = Fr(Ut, Ce);
          } else
            bt = Ce;
          ve.lanes = ve.childLanes = us;
          var jt = { baseLanes: bt, cachePool: yt, transitions: null };
          return ve.memoizedState = jt, ve.updateQueue = null, zw(ve, bt), null;
        }
      else {
        var tn;
        Ue !== null ? (tn = Fr(Ue.baseLanes, Ce), ve.memoizedState = null) : tn = Ce, zw(ve, tn);
      }
      return js(me, ve, De, Ce), ve.child;
    }
    function tR(me, ve, Ce) {
      var Re = ve.pendingProps;
      return js(me, ve, Re, Ce), ve.child;
    }
    function nR(me, ve, Ce) {
      var Re = ve.pendingProps.children;
      return js(me, ve, Re, Ce), ve.child;
    }
    function rR(me, ve, Ce) {
      {
        ve.flags |= Br;
        {
          var Re = ve.stateNode;
          Re.effectDuration = 0, Re.passiveEffectDuration = 0;
        }
      }
      var De = ve.pendingProps, Ue = De.children;
      return js(me, ve, Ue, Ce), ve.child;
    }
    function gT(me, ve) {
      var Ce = ve.ref;
      (me === null && Ce !== null || me !== null && me.ref !== Ce) && (ve.flags |= ns, ve.flags |= mb);
    }
    function Qx(me, ve, Ce, Re, De) {
      if (ve.type !== ve.elementType) {
        var Ue = Ce.propTypes;
        Ue && yl(Ue, Re, "prop", uo(Ce));
      }
      var Ye;
      {
        var et = Ey(ve, Ce, !0);
        Ye = Sy(ve, et);
      }
      var at, yt;
      Ay(ve, De), ac(ve);
      {
        if (Tv.current = ve, Mi(!0), at = jy(me, ve, Ce, Re, Ye, De), yt = Ly(), ve.mode & ta) {
          Ia(!0);
          try {
            at = jy(me, ve, Ce, Re, Ye, De), yt = Ly();
          } finally {
            Ia(!1);
          }
        }
        Mi(!1);
      }
      return od(), me !== null && !xl ? (KP(me, ve, De), Vd(me, ve, De)) : (Di() && yt && l1(ve), ve.flags |= Ql, js(me, ve, at, De), ve.child);
    }
    function wT(me, ve, Ce, Re, De) {
      {
        switch (xM(ve)) {
          case !1: {
            var Ue = ve.stateNode, Ye = ve.type, et = new Ye(ve.memoizedProps, Ue.context), at = et.state;
            Ue.updater.enqueueSetState(Ue, at, null);
            break;
          }
          case !0: {
            ve.flags |= Cr, ve.flags |= za;
            var yt = new Error("Simulated error coming from DevTools"), bt = $a(De);
            ve.lanes = Fr(ve.lanes, bt);
            var Ut = Hx(ve, Zh(yt, ve), bt);
            P1(ve, Ut);
            break;
          }
        }
        if (ve.type !== ve.elementType) {
          var jt = Ce.propTypes;
          jt && yl(jt, Re, "prop", uo(Ce));
        }
      }
      var tn;
      Ac(Ce) ? (tn = !0, C0(ve)) : tn = !1, Ay(ve, De);
      var nn = ve.stateNode, bn;
      nn === null ? (Aw(me, ve), zP(ve, Ce, Re), L1(ve, Ce, Re, De), bn = !0) : me === null ? bn = EI(ve, Ce, Re, De) : bn = PI(me, ve, Ce, Re, De);
      var Fn = Kx(me, ve, Ce, bn, tn, De);
      {
        var sr = ve.stateNode;
        bn && sr.props !== Re && (Gh || _e("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ar(ve) || "a component"), Gh = !0);
      }
      return Fn;
    }
    function Kx(me, ve, Ce, Re, De, Ue) {
      gT(me, ve);
      var Ye = (ve.flags & Cr) !== hr;
      if (!Re && !Ye)
        return De && NS(ve, Ce, !1), Vd(me, ve, Ue);
      var et = ve.stateNode;
      Tv.current = ve;
      var at;
      if (Ye && typeof Ce.getDerivedStateFromError != "function")
        at = null, cT();
      else {
        ac(ve);
        {
          if (Mi(!0), at = et.render(), ve.mode & ta) {
            Ia(!0);
            try {
              et.render();
            } finally {
              Ia(!1);
            }
          }
          Mi(!1);
        }
        od();
      }
      return ve.flags |= Ql, me !== null && Ye ? eR(me, ve, at, Ue) : js(me, ve, at, Ue), ve.memoizedState = et.state, De && NS(ve, Ce, !0), ve.child;
    }
    function _T(me) {
      var ve = me.stateNode;
      ve.pendingContext ? $S(me, ve.pendingContext, ve.pendingContext !== ve.context) : ve.context && $S(me, ve.context, !1), V1(me, ve.containerInfo);
    }
    function oR(me, ve, Ce) {
      if (_T(ve), me === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var Re = ve.pendingProps, De = ve.memoizedState, Ue = De.element;
      $P(me, ve), J0(ve, Re, null, Ce);
      var Ye = ve.memoizedState;
      ve.stateNode;
      var et = Ye.element;
      if (De.isDehydrated) {
        var at = { element: et, isDehydrated: !1, cache: Ye.cache, pendingSuspenseBoundaries: Ye.pendingSuspenseBoundaries, transitions: Ye.transitions }, yt = ve.updateQueue;
        if (yt.baseState = at, ve.memoizedState = at, ve.flags & ua) {
          var bt = Zh(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), ve);
          return xT(me, ve, et, Ce, bt);
        } else if (et !== Ue) {
          var Ut = Zh(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), ve);
          return xT(me, ve, et, Ce, Ut);
        } else {
          XC(ve);
          var jt = qP(ve, null, et, Ce);
          ve.child = jt;
          for (var tn = jt; tn; )
            tn.flags = tn.flags & ~Lo | Ws, tn = tn.sibling;
        }
      } else {
        if (Ty(), et === Ue)
          return Vd(me, ve, Ce);
        js(me, ve, et, Ce);
      }
      return ve.child;
    }
    function xT(me, ve, Ce, Re, De) {
      return Ty(), m1(De), ve.flags |= ua, js(me, ve, Ce, Re), ve.child;
    }
    function aR(me, ve, Ce) {
      GP(ve), me === null && h1(ve);
      var Re = ve.type, De = ve.pendingProps, Ue = me !== null ? me.memoizedProps : null, Ye = De.children, et = Y_(Re, De);
      return et ? Ye = null : Ue !== null && Y_(Re, Ue) && (ve.flags |= go), gT(me, ve), js(me, ve, Ye, Ce), ve.child;
    }
    function iR(me, ve) {
      return me === null && h1(ve), null;
    }
    function sR(me, ve, Ce, Re) {
      Aw(me, ve);
      var De = ve.pendingProps, Ue = Ce, Ye = Ue._payload, et = Ue._init, at = et(Ye);
      ve.type = at;
      var yt = ve.tag = uM(at), bt = gl(at, De), Ut;
      switch (yt) {
        case Ie:
          return Xx(ve, at), ve.type = at = Zy(at), Ut = Qx(null, ve, at, bt, Re), Ut;
        case $e:
          return ve.type = at = OE(at), Ut = wT(null, ve, at, bt, Re), Ut;
        case ot:
          return ve.type = at = AE(at), Ut = mT(null, ve, at, bt, Re), Ut;
        case wt: {
          if (ve.type !== ve.elementType) {
            var jt = at.propTypes;
            jt && yl(jt, bt, "prop", uo(at));
          }
          return Ut = yT(null, ve, at, gl(at.type, bt), Re), Ut;
        }
      }
      var tn = "";
      throw at !== null && typeof at == "object" && at.$$typeof === fr && (tn = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + at + ". " + ("Lazy element type must resolve to a class or function." + tn));
    }
    function uR(me, ve, Ce, Re, De) {
      Aw(me, ve), ve.tag = $e;
      var Ue;
      return Ac(Ce) ? (Ue = !0, C0(ve)) : Ue = !1, Ay(ve, De), zP(ve, Ce, Re), L1(ve, Ce, Re, De), Kx(null, ve, Ce, !0, Ue, De);
    }
    function lR(me, ve, Ce, Re) {
      Aw(me, ve);
      var De = ve.pendingProps, Ue;
      {
        var Ye = Ey(ve, Ce, !1);
        Ue = Sy(ve, Ye);
      }
      Ay(ve, Re);
      var et, at;
      ac(ve);
      {
        if (Ce.prototype && typeof Ce.prototype.render == "function") {
          var yt = uo(Ce) || "Unknown";
          Zx[yt] || (_e("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", yt, yt), Zx[yt] = !0);
        }
        ve.mode & ta && vl.recordLegacyContextWarning(ve, null), Mi(!0), Tv.current = ve, et = jy(null, ve, Ce, De, Ue, Re), at = Ly(), Mi(!1);
      }
      if (od(), ve.flags |= Ql, typeof et == "object" && et !== null && typeof et.render == "function" && et.$$typeof === void 0) {
        var bt = uo(Ce) || "Unknown";
        Ov[bt] || (_e("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", bt, bt, bt), Ov[bt] = !0);
      }
      if (typeof et == "object" && et !== null && typeof et.render == "function" && et.$$typeof === void 0) {
        {
          var Ut = uo(Ce) || "Unknown";
          Ov[Ut] || (_e("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ut, Ut, Ut), Ov[Ut] = !0);
        }
        ve.tag = $e, ve.memoizedState = null, ve.updateQueue = null;
        var jt = !1;
        return Ac(Ce) ? (jt = !0, C0(ve)) : jt = !1, ve.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null, S1(ve), FP(ve, et), L1(ve, Ce, De, Re), Kx(null, ve, Ce, !0, jt, Re);
      } else {
        if (ve.tag = Ie, ve.mode & ta) {
          Ia(!0);
          try {
            et = jy(null, ve, Ce, De, Ue, Re), at = Ly();
          } finally {
            Ia(!1);
          }
        }
        return Di() && at && l1(ve), js(null, ve, et, Re), Xx(ve, Ce), ve.child;
      }
    }
    function Xx(me, ve) {
      {
        if (ve && ve.childContextTypes && _e("%s(...): childContextTypes cannot be defined on a function component.", ve.displayName || ve.name || "Component"), me.ref !== null) {
          var Ce = "", Re = si();
          Re && (Ce += `

Check the render method of \`` + Re + "`.");
          var De = Re || "", Ue = me._debugSource;
          Ue && (De = Ue.fileName + ":" + Ue.lineNumber), Gx[De] || (Gx[De] = !0, _e("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", Ce));
        }
        if (typeof ve.getDerivedStateFromProps == "function") {
          var Ye = uo(ve) || "Unknown";
          Wx[Ye] || (_e("%s: Function components do not support getDerivedStateFromProps.", Ye), Wx[Ye] = !0);
        }
        if (typeof ve.contextType == "object" && ve.contextType !== null) {
          var et = uo(ve) || "Unknown";
          qx[et] || (_e("%s: Function components do not support contextType.", et), qx[et] = !0);
        }
      }
    }
    var Jx = { dehydrated: null, treeContext: null, retryLane: oo };
    function eE(me) {
      return { baseLanes: me, cachePool: J$(), transitions: null };
    }
    function cR(me, ve) {
      var Ce = null;
      return { baseLanes: Fr(me.baseLanes, ve), cachePool: Ce, transitions: me.transitions };
    }
    function dR(me, ve, Ce, Re) {
      if (ve !== null) {
        var De = ve.memoizedState;
        if (De === null)
          return !1;
      }
      return q1(me, gv);
    }
    function fR(me, ve) {
      return gf(me.childLanes, ve);
    }
    function ET(me, ve, Ce) {
      var Re = ve.pendingProps;
      EM(ve) && (ve.flags |= Cr);
      var De = wl.current, Ue = !1, Ye = (ve.flags & Cr) !== hr;
      if (Ye || dR(De, me) ? (Ue = !0, ve.flags &= ~Cr) : (me === null || me.memoizedState !== null) && (De = II(De, QP)), De = $y(De), Ff(ve, De), me === null) {
        h1(ve);
        var et = ve.memoizedState;
        if (et !== null) {
          var at = et.dehydrated;
          if (at !== null)
            return bR(ve, at);
        }
        var yt = Re.children, bt = Re.fallback;
        if (Ue) {
          var Ut = pR(ve, yt, bt, Ce), jt = ve.child;
          return jt.memoizedState = eE(Ce), ve.memoizedState = Jx, Ut;
        } else
          return tE(ve, yt);
      } else {
        var tn = me.memoizedState;
        if (tn !== null) {
          var nn = tn.dehydrated;
          if (nn !== null)
            return vR(me, ve, Ye, Re, nn, tn, Ce);
        }
        if (Ue) {
          var bn = Re.fallback, Fn = Re.children, sr = mR(me, ve, Fn, bn, Ce), wr = ve.child, Zr = me.child.memoizedState;
          return wr.memoizedState = Zr === null ? eE(Ce) : cR(Zr, Ce), wr.childLanes = fR(me, Ce), ve.memoizedState = Jx, sr;
        } else {
          var Ur = Re.children, Qt = hR(me, ve, Ur, Ce);
          return ve.memoizedState = null, Qt;
        }
      }
    }
    function tE(me, ve, Ce) {
      var Re = me.mode, De = { mode: "visible", children: ve }, Ue = nE(De, Re);
      return Ue.return = me, me.child = Ue, Ue;
    }
    function pR(me, ve, Ce, Re) {
      var De = me.mode, Ue = me.child, Ye = { mode: "hidden", children: ve }, et, at;
      return (De & Vr) === vr && Ue !== null ? (et = Ue, et.childLanes = vn, et.pendingProps = Ye, me.mode & xr && (et.actualDuration = 0, et.actualStartTime = -1, et.selfBaseDuration = 0, et.treeBaseDuration = 0), at = Gf(Ce, De, Re, null)) : (et = nE(Ye, De), at = Gf(Ce, De, Re, null)), et.return = me, at.return = me, et.sibling = at, me.child = et, at;
    }
    function nE(me, ve, Ce) {
      return P2(me, ve, vn, null);
    }
    function ST(me, ve) {
      return em(me, ve);
    }
    function hR(me, ve, Ce, Re) {
      var De = me.child, Ue = De.sibling, Ye = ST(De, { mode: "visible", children: Ce });
      if ((ve.mode & Vr) === vr && (Ye.lanes = Re), Ye.return = ve, Ye.sibling = null, Ue !== null) {
        var et = ve.deletions;
        et === null ? (ve.deletions = [Ue], ve.flags |= yo) : et.push(Ue);
      }
      return ve.child = Ye, Ye;
    }
    function mR(me, ve, Ce, Re, De) {
      var Ue = ve.mode, Ye = me.child, et = Ye.sibling, at = { mode: "hidden", children: Ce }, yt;
      if ((Ue & Vr) === vr && ve.child !== Ye) {
        var bt = ve.child;
        yt = bt, yt.childLanes = vn, yt.pendingProps = at, ve.mode & xr && (yt.actualDuration = 0, yt.actualStartTime = -1, yt.selfBaseDuration = Ye.selfBaseDuration, yt.treeBaseDuration = Ye.treeBaseDuration), ve.deletions = null;
      } else
        yt = ST(Ye, at), yt.subtreeFlags = Ye.subtreeFlags & ci;
      var Ut;
      return et !== null ? Ut = em(et, Re) : (Ut = Gf(Re, Ue, De, null), Ut.flags |= Lo), Ut.return = ve, yt.return = ve, yt.sibling = Ut, ve.child = yt, Ut;
    }
    function Ow(me, ve, Ce, Re) {
      Re !== null && m1(Re), Cy(ve, me.child, null, Ce);
      var De = ve.pendingProps, Ue = De.children, Ye = tE(ve, Ue);
      return Ye.flags |= Lo, ve.memoizedState = null, Ye;
    }
    function yR(me, ve, Ce, Re, De) {
      var Ue = ve.mode, Ye = { mode: "visible", children: Ce }, et = nE(Ye, Ue), at = Gf(Re, Ue, De, null);
      return at.flags |= Lo, et.return = ve, at.return = ve, et.sibling = at, ve.child = et, (ve.mode & Vr) !== vr && Cy(ve, me.child, null, De), at;
    }
    function bR(me, ve, Ce) {
      return (me.mode & Vr) === vr ? (_e("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), me.lanes = kr) : J_(ve) ? me.lanes = ud : me.lanes = us, null;
    }
    function vR(me, ve, Ce, Re, De, Ue, Ye) {
      if (Ce)
        if (ve.flags & ua) {
          ve.flags &= ~ua;
          var et = Ux(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Ow(me, ve, Ye, et);
        } else {
          if (ve.memoizedState !== null)
            return ve.child = me.child, ve.flags |= Cr, null;
          var at = Re.children, yt = Re.fallback, bt = yR(me, ve, at, yt, Ye), Ut = ve.child;
          return Ut.memoizedState = eE(Ye), ve.memoizedState = Jx, bt;
        }
      else {
        if (QC(), (ve.mode & Vr) === vr)
          return Ow(me, ve, Ye, null);
        if (J_(De)) {
          var jt, tn, nn;
          {
            var bn = pC(De);
            jt = bn.digest, tn = bn.message, nn = bn.stack;
          }
          var Fn;
          tn ? Fn = new Error(tn) : Fn = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var sr = Ux(Fn, jt, nn);
          return Ow(me, ve, Ye, sr);
        }
        var wr = ls(Ye, me.childLanes);
        if (xl || wr) {
          var Zr = Fw();
          if (Zr !== null) {
            var Ur = Qm(Zr, Ye);
            if (Ur !== oo && Ur !== Ue.retryLane) {
              Ue.retryLane = Ur;
              var Qt = Co;
              ru(me, Ur), Ei(Zr, me, Ur, Qt);
            }
          }
          EE();
          var yn = Ux(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Ow(me, ve, Ye, yn);
        } else if (SS(De)) {
          ve.flags |= Cr, ve.child = me.child;
          var Xt = ZN.bind(null, me);
          return hC(De, Xt), null;
        } else {
          JC(ve, De, Ue.treeContext);
          var $n = Re.children, Gn = tE(ve, $n);
          return Gn.flags |= Ws, Gn;
        }
      }
    }
    function PT(me, ve, Ce) {
      me.lanes = Fr(me.lanes, ve);
      var Re = me.alternate;
      Re !== null && (Re.lanes = Fr(Re.lanes, ve)), w1(me.return, ve, Ce);
    }
    function gR(me, ve, Ce) {
      for (var Re = ve; Re !== null; ) {
        if (Re.tag === ht) {
          var De = Re.memoizedState;
          De !== null && PT(Re, Ce, me);
        } else if (Re.tag === on)
          PT(Re, Ce, me);
        else if (Re.child !== null) {
          Re.child.return = Re, Re = Re.child;
          continue;
        }
        if (Re === me)
          return;
        for (; Re.sibling === null; ) {
          if (Re.return === null || Re.return === me)
            return;
          Re = Re.return;
        }
        Re.sibling.return = Re.return, Re = Re.sibling;
      }
    }
    function wR(me) {
      for (var ve = me, Ce = null; ve !== null; ) {
        var Re = ve.alternate;
        Re !== null && iw(Re) === null && (Ce = ve), ve = ve.sibling;
      }
      return Ce;
    }
    function _R(me) {
      if (me !== void 0 && me !== "forwards" && me !== "backwards" && me !== "together" && !Yx[me])
        if (Yx[me] = !0, typeof me == "string")
          switch (me.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              _e('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', me, me.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              _e('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', me, me.toLowerCase());
              break;
            }
            default:
              _e('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
              break;
          }
        else
          _e('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', me);
    }
    function xR(me, ve) {
      me !== void 0 && !Tw[me] && (me !== "collapsed" && me !== "hidden" ? (Tw[me] = !0, _e('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', me)) : ve !== "forwards" && ve !== "backwards" && (Tw[me] = !0, _e('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', me)));
    }
    function kT(me, ve) {
      {
        var Ce = Jo(me), Re = !Ce && typeof _s(me) == "function";
        if (Ce || Re) {
          var De = Ce ? "array" : "iterable";
          return _e("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", De, ve, De), !1;
        }
      }
      return !0;
    }
    function ER(me, ve) {
      if ((ve === "forwards" || ve === "backwards") && me !== void 0 && me !== null && me !== !1)
        if (Jo(me)) {
          for (var Ce = 0; Ce < me.length; Ce++)
            if (!kT(me[Ce], Ce))
              return;
        } else {
          var Re = _s(me);
          if (typeof Re == "function") {
            var De = Re.call(me);
            if (De)
              for (var Ue = De.next(), Ye = 0; !Ue.done; Ue = De.next()) {
                if (!kT(Ue.value, Ye))
                  return;
                Ye++;
              }
          } else
            _e('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', ve);
        }
    }
    function rE(me, ve, Ce, Re, De) {
      var Ue = me.memoizedState;
      Ue === null ? me.memoizedState = { isBackwards: ve, rendering: null, renderingStartTime: 0, last: Re, tail: Ce, tailMode: De } : (Ue.isBackwards = ve, Ue.rendering = null, Ue.renderingStartTime = 0, Ue.last = Re, Ue.tail = Ce, Ue.tailMode = De);
    }
    function TT(me, ve, Ce) {
      var Re = ve.pendingProps, De = Re.revealOrder, Ue = Re.tail, Ye = Re.children;
      _R(De), xR(Ue, De), ER(Ye, De), js(me, ve, Ye, Ce);
      var et = wl.current, at = q1(et, gv);
      if (at)
        et = W1(et, gv), ve.flags |= Cr;
      else {
        var yt = me !== null && (me.flags & Cr) !== hr;
        yt && gR(ve, ve.child, Ce), et = $y(et);
      }
      if (Ff(ve, et), (ve.mode & Vr) === vr)
        ve.memoizedState = null;
      else
        switch (De) {
          case "forwards": {
            var bt = wR(ve.child), Ut;
            bt === null ? (Ut = ve.child, ve.child = null) : (Ut = bt.sibling, bt.sibling = null), rE(ve, !1, Ut, bt, Ue);
            break;
          }
          case "backwards": {
            var jt = null, tn = ve.child;
            for (ve.child = null; tn !== null; ) {
              var nn = tn.alternate;
              if (nn !== null && iw(nn) === null) {
                ve.child = tn;
                break;
              }
              var bn = tn.sibling;
              tn.sibling = jt, jt = tn, tn = bn;
            }
            rE(ve, !0, jt, null, Ue);
            break;
          }
          case "together": {
            rE(ve, !1, null, null, void 0);
            break;
          }
          default:
            ve.memoizedState = null;
        }
      return ve.child;
    }
    function SR(me, ve, Ce) {
      V1(ve, ve.stateNode.containerInfo);
      var Re = ve.pendingProps;
      return me === null ? ve.child = Cy(ve, null, Re, Ce) : js(me, ve, Re, Ce), ve.child;
    }
    var OT = !1;
    function PR(me, ve, Ce) {
      var Re = ve.type, De = Re._context, Ue = ve.pendingProps, Ye = ve.memoizedProps, et = Ue.value;
      {
        "value" in Ue || OT || (OT = !0, _e("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var at = ve.type.propTypes;
        at && yl(at, Ue, "prop", "Context.Provider");
      }
      if (PP(ve, De, et), Ye !== null) {
        var yt = Ye.value;
        if (Zn(yt, et)) {
          if (Ye.children === Ue.children && !S0())
            return Vd(me, ve, Ce);
        } else
          cI(ve, De, Ce);
      }
      var bt = Ue.children;
      return js(me, ve, bt, Ce), ve.child;
    }
    var AT = !1;
    function kR(me, ve, Ce) {
      var Re = ve.type;
      Re._context === void 0 ? Re !== Re.Consumer && (AT || (AT = !0, _e("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : Re = Re._context;
      var De = ve.pendingProps, Ue = De.children;
      typeof Ue != "function" && _e("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Ay(ve, Ce);
      var Ye = Ha(Re);
      ac(ve);
      var et;
      return Tv.current = ve, Mi(!0), et = Ue(Ye), Mi(!1), od(), ve.flags |= Ql, js(me, ve, et, Ce), ve.child;
    }
    function Av() {
      xl = !0;
    }
    function Aw(me, ve) {
      (ve.mode & Vr) === vr && me !== null && (me.alternate = null, ve.alternate = null, ve.flags |= Lo);
    }
    function Vd(me, ve, Ce) {
      return me !== null && (ve.dependencies = me.dependencies), cT(), Fv(ve.lanes), ls(Ce, ve.childLanes) ? (kI(me, ve), ve.child) : null;
    }
    function TR(me, ve, Ce) {
      {
        var Re = ve.return;
        if (Re === null)
          throw new Error("Cannot swap the root fiber.");
        if (me.alternate = null, ve.alternate = null, Ce.index = ve.index, Ce.sibling = ve.sibling, Ce.return = ve.return, Ce.ref = ve.ref, ve === Re.child)
          Re.child = Ce;
        else {
          var De = Re.child;
          if (De === null)
            throw new Error("Expected parent to have a child.");
          for (; De.sibling !== ve; )
            if (De = De.sibling, De === null)
              throw new Error("Expected to find the previous sibling.");
          De.sibling = Ce;
        }
        var Ue = Re.deletions;
        return Ue === null ? (Re.deletions = [me], Re.flags |= yo) : Ue.push(me), Ce.flags |= Lo, Ce;
      }
    }
    function oE(me, ve) {
      var Ce = me.lanes;
      return !!ls(Ce, ve);
    }
    function OR(me, ve, Ce) {
      switch (ve.tag) {
        case Me:
          _T(ve), ve.stateNode, Ty();
          break;
        case ze:
          GP(ve);
          break;
        case $e: {
          var Re = ve.type;
          Ac(Re) && C0(ve);
          break;
        }
        case Be:
          V1(ve, ve.stateNode.containerInfo);
          break;
        case Xe: {
          var De = ve.memoizedProps.value, Ue = ve.type._context;
          PP(ve, Ue, De);
          break;
        }
        case pt:
          {
            var Ye = ls(Ce, ve.childLanes);
            Ye && (ve.flags |= Br);
            {
              var et = ve.stateNode;
              et.effectDuration = 0, et.passiveEffectDuration = 0;
            }
          }
          break;
        case ht: {
          var at = ve.memoizedState;
          if (at !== null) {
            if (at.dehydrated !== null)
              return Ff(ve, $y(wl.current)), ve.flags |= Cr, null;
            var yt = ve.child, bt = yt.childLanes;
            if (ls(Ce, bt))
              return ET(me, ve, Ce);
            Ff(ve, $y(wl.current));
            var Ut = Vd(me, ve, Ce);
            return Ut !== null ? Ut.sibling : null;
          } else
            Ff(ve, $y(wl.current));
          break;
        }
        case on: {
          var jt = (me.flags & Cr) !== hr, tn = ls(Ce, ve.childLanes);
          if (jt) {
            if (tn)
              return TT(me, ve, Ce);
            ve.flags |= Cr;
          }
          var nn = ve.memoizedState;
          if (nn !== null && (nn.rendering = null, nn.tail = null, nn.lastEffect = null), Ff(ve, wl.current), tn)
            break;
          return null;
        }
        case wn:
        case Zt:
          return ve.lanes = vn, vT(me, ve, Ce);
      }
      return Vd(me, ve, Ce);
    }
    function CT(me, ve, Ce) {
      if (ve._debugNeedsRemount && me !== null)
        return TR(me, ve, NE(ve.type, ve.key, ve.pendingProps, ve._debugOwner || null, ve.mode, ve.lanes));
      if (me !== null) {
        var Re = me.memoizedProps, De = ve.pendingProps;
        if (Re !== De || S0() || ve.type !== me.type)
          xl = !0;
        else {
          var Ue = oE(me, Ce);
          if (!Ue && (ve.flags & Cr) === hr)
            return xl = !1, OR(me, ve, Ce);
          (me.flags & _p) !== hr ? xl = !0 : xl = !1;
        }
      } else if (xl = !1, Di() && HC(ve)) {
        var Ye = ve.index, et = ZC();
        LS(ve, et, Ye);
      }
      switch (ve.lanes = vn, ve.tag) {
        case Ne:
          return lR(me, ve, ve.type, Ce);
        case It: {
          var at = ve.elementType;
          return sR(me, ve, at, Ce);
        }
        case Ie: {
          var yt = ve.type, bt = ve.pendingProps, Ut = ve.elementType === yt ? bt : gl(yt, bt);
          return Qx(me, ve, yt, Ut, Ce);
        }
        case $e: {
          var jt = ve.type, tn = ve.pendingProps, nn = ve.elementType === jt ? tn : gl(jt, tn);
          return wT(me, ve, jt, nn, Ce);
        }
        case Me:
          return oR(me, ve, Ce);
        case ze:
          return aR(me, ve, Ce);
        case He:
          return iR(me, ve);
        case ht:
          return ET(me, ve, Ce);
        case Be:
          return SR(me, ve, Ce);
        case ot: {
          var bn = ve.type, Fn = ve.pendingProps, sr = ve.elementType === bn ? Fn : gl(bn, Fn);
          return mT(me, ve, bn, sr, Ce);
        }
        case Ze:
          return tR(me, ve, Ce);
        case qe:
          return nR(me, ve, Ce);
        case pt:
          return rR(me, ve, Ce);
        case Xe:
          return PR(me, ve, Ce);
        case tt:
          return kR(me, ve, Ce);
        case wt: {
          var wr = ve.type, Zr = ve.pendingProps, Ur = gl(wr, Zr);
          if (ve.type !== ve.elementType) {
            var Qt = wr.propTypes;
            Qt && yl(Qt, Ur, "prop", uo(wr));
          }
          return Ur = gl(wr.type, Ur), yT(me, ve, wr, Ur, Ce);
        }
        case gt:
          return bT(me, ve, ve.type, ve.pendingProps, Ce);
        case Nt: {
          var yn = ve.type, Xt = ve.pendingProps, $n = ve.elementType === yn ? Xt : gl(yn, Xt);
          return uR(me, ve, yn, $n, Ce);
        }
        case on:
          return TT(me, ve, Ce);
        case en:
          break;
        case wn:
          return vT(me, ve, Ce);
      }
      throw new Error("Unknown unit of work tag (" + ve.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Dy(me) {
      me.flags |= Br;
    }
    function IT(me) {
      me.flags |= ns, me.flags |= mb;
    }
    var $T, aE, RT, NT;
    $T = function(me, ve, Ce, Re) {
      for (var De = ve.child; De !== null; ) {
        if (De.tag === ze || De.tag === He)
          XO(me, De.stateNode);
        else if (De.tag !== Be && De.child !== null) {
          De.child.return = De, De = De.child;
          continue;
        }
        if (De === ve)
          return;
        for (; De.sibling === null; ) {
          if (De.return === null || De.return === ve)
            return;
          De = De.return;
        }
        De.sibling.return = De.return, De = De.sibling;
      }
    }, aE = function(me, ve) {
    }, RT = function(me, ve, Ce, Re, De) {
      var Ue = me.memoizedProps;
      if (Ue !== Re) {
        var Ye = ve.stateNode, et = H1(), at = eA(Ye, Ce, Ue, Re, De, et);
        ve.updateQueue = at, at && Dy(ve);
      }
    }, NT = function(me, ve, Ce, Re) {
      Ce !== Re && Dy(ve);
    };
    function Cv(me, ve) {
      if (!Di())
        switch (me.tailMode) {
          case "hidden": {
            for (var Ce = me.tail, Re = null; Ce !== null; )
              Ce.alternate !== null && (Re = Ce), Ce = Ce.sibling;
            Re === null ? me.tail = null : Re.sibling = null;
            break;
          }
          case "collapsed": {
            for (var De = me.tail, Ue = null; De !== null; )
              De.alternate !== null && (Ue = De), De = De.sibling;
            Ue === null ? !ve && me.tail !== null ? me.tail.sibling = null : me.tail = null : Ue.sibling = null;
            break;
          }
        }
    }
    function Fi(me) {
      var ve = me.alternate !== null && me.alternate.child === me.child, Ce = vn, Re = hr;
      if (ve) {
        if ((me.mode & xr) !== vr) {
          for (var De = me.selfBaseDuration, Ue = me.child; Ue !== null; )
            Ce = Fr(Ce, Fr(Ue.lanes, Ue.childLanes)), Re |= Ue.subtreeFlags & ci, Re |= Ue.flags & ci, De += Ue.treeBaseDuration, Ue = Ue.sibling;
          me.treeBaseDuration = De;
        } else
          for (var Ye = me.child; Ye !== null; )
            Ce = Fr(Ce, Fr(Ye.lanes, Ye.childLanes)), Re |= Ye.subtreeFlags & ci, Re |= Ye.flags & ci, Ye.return = me, Ye = Ye.sibling;
        me.subtreeFlags |= Re;
      } else {
        if ((me.mode & xr) !== vr) {
          for (var et = me.actualDuration, at = me.selfBaseDuration, yt = me.child; yt !== null; )
            Ce = Fr(Ce, Fr(yt.lanes, yt.childLanes)), Re |= yt.subtreeFlags, Re |= yt.flags, et += yt.actualDuration, at += yt.treeBaseDuration, yt = yt.sibling;
          me.actualDuration = et, me.treeBaseDuration = at;
        } else
          for (var bt = me.child; bt !== null; )
            Ce = Fr(Ce, Fr(bt.lanes, bt.childLanes)), Re |= bt.subtreeFlags, Re |= bt.flags, bt.return = me, bt = bt.sibling;
        me.subtreeFlags |= Re;
      }
      return me.childLanes = Ce, ve;
    }
    function CR(me, ve, Ce) {
      if (aI() && (ve.mode & Vr) !== vr && (ve.flags & Cr) === hr)
        return ZS(ve), Ty(), ve.flags |= ua | Ts | za, !1;
      var Re = B0(ve);
      if (Ce !== null && Ce.dehydrated !== null)
        if (me === null) {
          if (!Re)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (rI(ve), Fi(ve), (ve.mode & xr) !== vr) {
            var De = Ce !== null;
            if (De) {
              var Ue = ve.child;
              Ue !== null && (ve.treeBaseDuration -= Ue.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Ty(), (ve.flags & Cr) === hr && (ve.memoizedState = null), ve.flags |= Br, Fi(ve), (ve.mode & xr) !== vr) {
            var Ye = Ce !== null;
            if (Ye) {
              var et = ve.child;
              et !== null && (ve.treeBaseDuration -= et.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return YS(), !0;
    }
    function MT(me, ve, Ce) {
      var Re = ve.pendingProps;
      switch (c1(ve), ve.tag) {
        case Ne:
        case It:
        case gt:
        case Ie:
        case ot:
        case Ze:
        case qe:
        case pt:
        case tt:
        case wt:
          return Fi(ve), null;
        case $e: {
          var De = ve.type;
          return Ac(De) && O0(ve), Fi(ve), null;
        }
        case Me: {
          var Ue = ve.stateNode;
          if (Iy(ve), i1(ve), Y1(), Ue.pendingContext && (Ue.context = Ue.pendingContext, Ue.pendingContext = null), me === null || me.child === null) {
            var Ye = B0(ve);
            if (Ye)
              Dy(ve);
            else if (me !== null) {
              var et = me.memoizedState;
              (!et.isDehydrated || (ve.flags & ua) !== hr) && (ve.flags |= qs, YS());
            }
          }
          return aE(me, ve), Fi(ve), null;
        }
        case ze: {
          Z1(ve);
          var at = WP(), yt = ve.type;
          if (me !== null && ve.stateNode != null)
            RT(me, ve, yt, Re, at), me.ref !== ve.ref && IT(ve);
          else {
            if (!Re) {
              if (ve.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Fi(ve), null;
            }
            var bt = H1(), Ut = B0(ve);
            if (Ut)
              tI(ve, at, bt) && Dy(ve);
            else {
              var jt = KO(yt, Re, at, bt, ve);
              $T(jt, ve, !1, !1), ve.stateNode = jt, JO(jt, yt, Re, at) && Dy(ve);
            }
            ve.ref !== null && IT(ve);
          }
          return Fi(ve), null;
        }
        case He: {
          var tn = Re;
          if (me && ve.stateNode != null) {
            var nn = me.memoizedProps;
            NT(me, ve, nn, tn);
          } else {
            if (typeof tn != "string" && ve.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var bn = WP(), Fn = H1(), sr = B0(ve);
            sr ? nI(ve) && Dy(ve) : ve.stateNode = sA(tn, bn, Fn, ve);
          }
          return Fi(ve), null;
        }
        case ht: {
          Ry(ve);
          var wr = ve.memoizedState;
          if (me === null || me.memoizedState !== null && me.memoizedState.dehydrated !== null) {
            var Zr = CR(me, ve, wr);
            if (!Zr)
              return ve.flags & za ? ve : null;
          }
          if ((ve.flags & Cr) !== hr)
            return ve.lanes = Ce, (ve.mode & xr) !== vr && zx(ve), ve;
          var Ur = wr !== null, Qt = me !== null && me.memoizedState !== null;
          if (Ur !== Qt && Ur) {
            var yn = ve.child;
            if (yn.flags |= Xl, (ve.mode & Vr) !== vr) {
              var Xt = me === null && (ve.memoizedProps.unstable_avoidThisFallback !== !0 || !hn);
              Xt || q1(wl.current, QP) ? $N() : EE();
            }
          }
          var $n = ve.updateQueue;
          if ($n !== null && (ve.flags |= Br), Fi(ve), (ve.mode & xr) !== vr && Ur) {
            var Gn = ve.child;
            Gn !== null && (ve.treeBaseDuration -= Gn.treeBaseDuration);
          }
          return null;
        }
        case Be:
          return Iy(ve), aE(me, ve), me === null && LC(ve.stateNode.containerInfo), Fi(ve), null;
        case Xe:
          var zn = ve.type._context;
          return g1(zn, ve), Fi(ve), null;
        case Nt: {
          var Or = ve.type;
          return Ac(Or) && O0(ve), Fi(ve), null;
        }
        case on: {
          Ry(ve);
          var Mr = ve.memoizedState;
          if (Mr === null)
            return Fi(ve), null;
          var To = (ve.flags & Cr) !== hr, po = Mr.rendering;
          if (po === null)
            if (To)
              Cv(Mr, !1);
            else {
              var ja = NN() && (me === null || (me.flags & Cr) === hr);
              if (!ja)
                for (var ho = ve.child; ho !== null; ) {
                  var Oa = iw(ho);
                  if (Oa !== null) {
                    To = !0, ve.flags |= Cr, Cv(Mr, !1);
                    var gs = Oa.updateQueue;
                    return gs !== null && (ve.updateQueue = gs, ve.flags |= Br), ve.subtreeFlags = hr, OI(ve, Ce), Ff(ve, W1(wl.current, gv)), ve.child;
                  }
                  ho = ho.sibling;
                }
              Mr.tail !== null && ea() > n2() && (ve.flags |= Cr, To = !0, Cv(Mr, !1), ve.lanes = Ob);
            }
          else {
            if (!To) {
              var Wi = iw(po);
              if (Wi !== null) {
                ve.flags |= Cr, To = !0;
                var vu = Wi.updateQueue;
                if (vu !== null && (ve.updateQueue = vu, ve.flags |= Br), Cv(Mr, !0), Mr.tail === null && Mr.tailMode === "hidden" && !po.alternate && !Di())
                  return Fi(ve), null;
              } else
                ea() * 2 - Mr.renderingStartTime > n2() && Ce !== us && (ve.flags |= Cr, To = !0, Cv(Mr, !1), ve.lanes = Ob);
            }
            if (Mr.isBackwards)
              po.sibling = ve.child, ve.child = po;
            else {
              var Bs = Mr.last;
              Bs !== null ? Bs.sibling = po : ve.child = po, Mr.last = po;
            }
          }
          if (Mr.tail !== null) {
            var Fs = Mr.tail;
            Mr.rendering = Fs, Mr.tail = Fs.sibling, Mr.renderingStartTime = ea(), Fs.sibling = null;
            var ws = wl.current;
            return To ? ws = W1(ws, gv) : ws = $y(ws), Ff(ve, ws), Fs;
          }
          return Fi(ve), null;
        }
        case en:
          break;
        case wn:
        case Zt: {
          xE(ve);
          var Gd = ve.memoizedState, qy = Gd !== null;
          if (me !== null) {
            var Zv = me.memoizedState, Bc = Zv !== null;
            Bc !== qy && !At && (ve.flags |= Xl);
          }
          return !qy || (ve.mode & Vr) === vr ? Fi(ve) : ls(Dc, us) && (Fi(ve), ve.subtreeFlags & (Lo | Br) && (ve.flags |= Xl)), null;
        }
        case pn:
          return null;
        case un:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + ve.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function IR(me, ve, Ce) {
      switch (c1(ve), ve.tag) {
        case $e: {
          var Re = ve.type;
          Ac(Re) && O0(ve);
          var De = ve.flags;
          return De & za ? (ve.flags = De & ~za | Cr, (ve.mode & xr) !== vr && zx(ve), ve) : null;
        }
        case Me: {
          ve.stateNode, Iy(ve), i1(ve), Y1();
          var Ue = ve.flags;
          return (Ue & za) !== hr && (Ue & Cr) === hr ? (ve.flags = Ue & ~za | Cr, ve) : null;
        }
        case ze:
          return Z1(ve), null;
        case ht: {
          Ry(ve);
          var Ye = ve.memoizedState;
          if (Ye !== null && Ye.dehydrated !== null) {
            if (ve.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Ty();
          }
          var et = ve.flags;
          return et & za ? (ve.flags = et & ~za | Cr, (ve.mode & xr) !== vr && zx(ve), ve) : null;
        }
        case on:
          return Ry(ve), null;
        case Be:
          return Iy(ve), null;
        case Xe:
          var at = ve.type._context;
          return g1(at, ve), null;
        case wn:
        case Zt:
          return xE(ve), null;
        case pn:
          return null;
        default:
          return null;
      }
    }
    function jT(me, ve, Ce) {
      switch (c1(ve), ve.tag) {
        case $e: {
          var Re = ve.type.childContextTypes;
          Re != null && O0(ve);
          break;
        }
        case Me: {
          ve.stateNode, Iy(ve), i1(ve), Y1();
          break;
        }
        case ze: {
          Z1(ve);
          break;
        }
        case Be:
          Iy(ve);
          break;
        case ht:
          Ry(ve);
          break;
        case on:
          Ry(ve);
          break;
        case Xe:
          var De = ve.type._context;
          g1(De, ve);
          break;
        case wn:
        case Zt:
          xE(ve);
          break;
      }
    }
    var LT = null;
    LT = /* @__PURE__ */ new Set();
    var Cw = !1, Ui = !1, $R = typeof WeakSet == "function" ? WeakSet : Set, tr = null, By = null, Fy = null;
    function RR(me) {
      nd(null, function() {
        throw me;
      }), pb();
    }
    var NR = function(me, ve) {
      if (ve.props = me.memoizedProps, ve.state = me.memoizedState, me.mode & xr)
        try {
          jc(), ve.componentWillUnmount();
        } finally {
          Mc(me);
        }
      else
        ve.componentWillUnmount();
    };
    function DT(me, ve) {
      try {
        Vf(yi, me);
      } catch (Ce) {
        Vo(me, ve, Ce);
      }
    }
    function iE(me, ve, Ce) {
      try {
        NR(me, Ce);
      } catch (Re) {
        Vo(me, ve, Re);
      }
    }
    function MR(me, ve, Ce) {
      try {
        Ce.componentDidMount();
      } catch (Re) {
        Vo(me, ve, Re);
      }
    }
    function BT(me, ve) {
      try {
        zT(me);
      } catch (Ce) {
        Vo(me, ve, Ce);
      }
    }
    function zy(me, ve) {
      var Ce = me.ref;
      if (Ce !== null)
        if (typeof Ce == "function") {
          var Re;
          try {
            if (Vn && br && me.mode & xr)
              try {
                jc(), Re = Ce(null);
              } finally {
                Mc(me);
              }
            else
              Re = Ce(null);
          } catch (De) {
            Vo(me, ve, De);
          }
          typeof Re == "function" && _e("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ar(me));
        } else
          Ce.current = null;
    }
    function Iw(me, ve, Ce) {
      try {
        Ce();
      } catch (Re) {
        Vo(me, ve, Re);
      }
    }
    var FT = !1;
    function jR(me, ve) {
      YO(me.containerInfo), tr = ve, LR();
      var Ce = FT;
      return FT = !1, Ce;
    }
    function LR() {
      for (; tr !== null; ) {
        var me = tr, ve = me.child;
        (me.subtreeFlags & df) !== hr && ve !== null ? (ve.return = me, tr = ve) : DR();
      }
    }
    function DR() {
      for (; tr !== null; ) {
        var me = tr;
        lo(me);
        try {
          BR(me);
        } catch (Ce) {
          Vo(me, me.return, Ce);
        }
        Ko();
        var ve = me.sibling;
        if (ve !== null) {
          ve.return = me.return, tr = ve;
          return;
        }
        tr = me.return;
      }
    }
    function BR(me) {
      var ve = me.alternate, Ce = me.flags;
      if ((Ce & qs) !== hr) {
        switch (lo(me), me.tag) {
          case Ie:
          case ot:
          case gt:
            break;
          case $e: {
            if (ve !== null) {
              var Re = ve.memoizedProps, De = ve.memoizedState, Ue = me.stateNode;
              me.type === me.elementType && !Gh && (Ue.props !== me.memoizedProps && _e("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ar(me) || "instance"), Ue.state !== me.memoizedState && _e("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ar(me) || "instance"));
              var Ye = Ue.getSnapshotBeforeUpdate(me.elementType === me.type ? Re : gl(me.type, Re), De);
              {
                var et = LT;
                Ye === void 0 && !et.has(me.type) && (et.add(me.type), _e("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ar(me)));
              }
              Ue.__reactInternalSnapshotBeforeUpdate = Ye;
            }
            break;
          }
          case Me: {
            {
              var at = me.stateNode;
              lC(at.containerInfo);
            }
            break;
          }
          case ze:
          case He:
          case Be:
          case Nt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ko();
      }
    }
    function El(me, ve, Ce) {
      var Re = ve.updateQueue, De = Re !== null ? Re.lastEffect : null;
      if (De !== null) {
        var Ue = De.next, Ye = Ue;
        do {
          if ((Ye.tag & me) === me) {
            var et = Ye.destroy;
            Ye.destroy = void 0, et !== void 0 && ((me & Bi) !== ou ? Sm(ve) : (me & yi) !== ou && Pm(ve), (me & Ic) !== ou && Uv(!0), Iw(ve, Ce, et), (me & Ic) !== ou && Uv(!1), (me & Bi) !== ou ? kg() : (me & yi) !== ou && ff());
          }
          Ye = Ye.next;
        } while (Ye !== Ue);
      }
    }
    function Vf(me, ve) {
      var Ce = ve.updateQueue, Re = Ce !== null ? Ce.lastEffect : null;
      if (Re !== null) {
        var De = Re.next, Ue = De;
        do {
          if ((Ue.tag & me) === me) {
            (me & Bi) !== ou ? Pg(ve) : (me & yi) !== ou && Tg(ve);
            var Ye = Ue.create;
            (me & Ic) !== ou && Uv(!0), Ue.destroy = Ye(), (me & Ic) !== ou && Uv(!1), (me & Bi) !== ou ? Pb() : (me & yi) !== ou && Og();
            {
              var et = Ue.destroy;
              if (et !== void 0 && typeof et != "function") {
                var at = void 0;
                (Ue.tag & yi) !== hr ? at = "useLayoutEffect" : (Ue.tag & Ic) !== hr ? at = "useInsertionEffect" : at = "useEffect";
                var yt = void 0;
                et === null ? yt = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof et.then == "function" ? yt = `

It looks like you wrote ` + at + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + at + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : yt = " You returned: " + et, _e("%s must not return anything besides a function, which is used for clean-up.%s", at, yt);
              }
            }
          }
          Ue = Ue.next;
        } while (Ue !== De);
      }
    }
    function FR(me, ve) {
      if ((ve.flags & Br) !== hr)
        switch (ve.tag) {
          case pt: {
            var Ce = ve.stateNode.passiveEffectDuration, Re = ve.memoizedProps, De = Re.id, Ue = Re.onPostCommit, Ye = uT(), et = ve.alternate === null ? "mount" : "update";
            sT() && (et = "nested-update"), typeof Ue == "function" && Ue(De, et, Ce, Ye);
            var at = ve.return;
            e:
              for (; at !== null; ) {
                switch (at.tag) {
                  case Me:
                    var yt = at.stateNode;
                    yt.passiveEffectDuration += Ce;
                    break e;
                  case pt:
                    var bt = at.stateNode;
                    bt.passiveEffectDuration += Ce;
                    break e;
                }
                at = at.return;
              }
            break;
          }
        }
    }
    function zR(me, ve, Ce, Re) {
      if ((Ce.flags & Ii) !== hr)
        switch (Ce.tag) {
          case Ie:
          case ot:
          case gt: {
            if (!Ui)
              if (Ce.mode & xr)
                try {
                  jc(), Vf(yi | mi, Ce);
                } finally {
                  Mc(Ce);
                }
              else
                Vf(yi | mi, Ce);
            break;
          }
          case $e: {
            var De = Ce.stateNode;
            if (Ce.flags & Br && !Ui)
              if (ve === null)
                if (Ce.type === Ce.elementType && !Gh && (De.props !== Ce.memoizedProps && _e("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ar(Ce) || "instance"), De.state !== Ce.memoizedState && _e("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ar(Ce) || "instance")), Ce.mode & xr)
                  try {
                    jc(), De.componentDidMount();
                  } finally {
                    Mc(Ce);
                  }
                else
                  De.componentDidMount();
              else {
                var Ue = Ce.elementType === Ce.type ? ve.memoizedProps : gl(Ce.type, ve.memoizedProps), Ye = ve.memoizedState;
                if (Ce.type === Ce.elementType && !Gh && (De.props !== Ce.memoizedProps && _e("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ar(Ce) || "instance"), De.state !== Ce.memoizedState && _e("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ar(Ce) || "instance")), Ce.mode & xr)
                  try {
                    jc(), De.componentDidUpdate(Ue, Ye, De.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Mc(Ce);
                  }
                else
                  De.componentDidUpdate(Ue, Ye, De.__reactInternalSnapshotBeforeUpdate);
              }
            var et = Ce.updateQueue;
            et !== null && (Ce.type === Ce.elementType && !Gh && (De.props !== Ce.memoizedProps && _e("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ar(Ce) || "instance"), De.state !== Ce.memoizedState && _e("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ar(Ce) || "instance")), MP(Ce, et, De));
            break;
          }
          case Me: {
            var at = Ce.updateQueue;
            if (at !== null) {
              var yt = null;
              if (Ce.child !== null)
                switch (Ce.child.tag) {
                  case ze:
                    yt = Ce.child.stateNode;
                    break;
                  case $e:
                    yt = Ce.child.stateNode;
                    break;
                }
              MP(Ce, at, yt);
            }
            break;
          }
          case ze: {
            var bt = Ce.stateNode;
            if (ve === null && Ce.flags & Br) {
              var Ut = Ce.type, jt = Ce.memoizedProps;
              OA(bt, Ut, jt);
            }
            break;
          }
          case He:
            break;
          case Be:
            break;
          case pt: {
            {
              var tn = Ce.memoizedProps, nn = tn.onCommit, bn = tn.onRender, Fn = Ce.stateNode.effectDuration, sr = uT(), wr = ve === null ? "mount" : "update";
              sT() && (wr = "nested-update"), typeof bn == "function" && bn(Ce.memoizedProps.id, wr, Ce.actualDuration, Ce.treeBaseDuration, Ce.actualStartTime, sr);
              {
                typeof nn == "function" && nn(Ce.memoizedProps.id, wr, Fn, sr), BN(Ce);
                var Zr = Ce.return;
                e:
                  for (; Zr !== null; ) {
                    switch (Zr.tag) {
                      case Me:
                        var Ur = Zr.stateNode;
                        Ur.effectDuration += Fn;
                        break e;
                      case pt:
                        var Qt = Zr.stateNode;
                        Qt.effectDuration += Fn;
                        break e;
                    }
                    Zr = Zr.return;
                  }
              }
            }
            break;
          }
          case ht: {
            QR(me, Ce);
            break;
          }
          case on:
          case Nt:
          case en:
          case wn:
          case Zt:
          case un:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ui || Ce.flags & ns && zT(Ce);
    }
    function UR(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          if (me.mode & xr)
            try {
              jc(), DT(me, me.return);
            } finally {
              Mc(me);
            }
          else
            DT(me, me.return);
          break;
        }
        case $e: {
          var ve = me.stateNode;
          typeof ve.componentDidMount == "function" && MR(me, me.return, ve), BT(me, me.return);
          break;
        }
        case ze: {
          BT(me, me.return);
          break;
        }
      }
    }
    function VR(me, ve) {
      for (var Ce = null, Re = me; ; ) {
        if (Re.tag === ze) {
          if (Ce === null) {
            Ce = Re;
            try {
              var De = Re.stateNode;
              ve ? aC(De) : sC(Re.stateNode, Re.memoizedProps);
            } catch (Ye) {
              Vo(me, me.return, Ye);
            }
          }
        } else if (Re.tag === He) {
          if (Ce === null)
            try {
              var Ue = Re.stateNode;
              ve ? iC(Ue) : uC(Ue, Re.memoizedProps);
            } catch (Ye) {
              Vo(me, me.return, Ye);
            }
        } else if (!((Re.tag === wn || Re.tag === Zt) && Re.memoizedState !== null && Re !== me) && Re.child !== null) {
          Re.child.return = Re, Re = Re.child;
          continue;
        }
        if (Re === me)
          return;
        for (; Re.sibling === null; ) {
          if (Re.return === null || Re.return === me)
            return;
          Ce === Re && (Ce = null), Re = Re.return;
        }
        Ce === Re && (Ce = null), Re.sibling.return = Re.return, Re = Re.sibling;
      }
    }
    function zT(me) {
      var ve = me.ref;
      if (ve !== null) {
        var Ce = me.stateNode, Re;
        switch (me.tag) {
          case ze:
            Re = Ce;
            break;
          default:
            Re = Ce;
        }
        if (typeof ve == "function") {
          var De;
          if (me.mode & xr)
            try {
              jc(), De = ve(Re);
            } finally {
              Mc(me);
            }
          else
            De = ve(Re);
          typeof De == "function" && _e("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ar(me));
        } else
          ve.hasOwnProperty("current") || _e("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ar(me)), ve.current = Re;
      }
    }
    function HR(me) {
      var ve = me.alternate;
      ve !== null && (ve.return = null), me.return = null;
    }
    function UT(me) {
      var ve = me.alternate;
      ve !== null && (me.alternate = null, UT(ve));
      {
        if (me.child = null, me.deletions = null, me.sibling = null, me.tag === ze) {
          var Ce = me.stateNode;
          Ce !== null && FC(Ce);
        }
        me.stateNode = null, me._debugOwner = null, me.return = null, me.dependencies = null, me.memoizedProps = null, me.memoizedState = null, me.pendingProps = null, me.stateNode = null, me.updateQueue = null;
      }
    }
    function ZR(me) {
      for (var ve = me.return; ve !== null; ) {
        if (VT(ve))
          return ve;
        ve = ve.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function VT(me) {
      return me.tag === ze || me.tag === Me || me.tag === Be;
    }
    function HT(me) {
      var ve = me;
      e:
        for (; ; ) {
          for (; ve.sibling === null; ) {
            if (ve.return === null || VT(ve.return))
              return null;
            ve = ve.return;
          }
          for (ve.sibling.return = ve.return, ve = ve.sibling; ve.tag !== ze && ve.tag !== He && ve.tag !== Ft; ) {
            if (ve.flags & Lo || ve.child === null || ve.tag === Be)
              continue e;
            ve.child.return = ve, ve = ve.child;
          }
          if (!(ve.flags & Lo))
            return ve.stateNode;
        }
    }
    function qR(me) {
      var ve = ZR(me);
      switch (ve.tag) {
        case ze: {
          var Ce = ve.stateNode;
          ve.flags & go && (ES(Ce), ve.flags &= ~go);
          var Re = HT(me);
          uE(me, Re, Ce);
          break;
        }
        case Me:
        case Be: {
          var De = ve.stateNode.containerInfo, Ue = HT(me);
          sE(me, Ue, De);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function sE(me, ve, Ce) {
      var Re = me.tag, De = Re === ze || Re === He;
      if (De) {
        var Ue = me.stateNode;
        ve ? tC(Ce, Ue, ve) : qA(Ce, Ue);
      } else if (Re !== Be) {
        var Ye = me.child;
        if (Ye !== null) {
          sE(Ye, ve, Ce);
          for (var et = Ye.sibling; et !== null; )
            sE(et, ve, Ce), et = et.sibling;
        }
      }
    }
    function uE(me, ve, Ce) {
      var Re = me.tag, De = Re === ze || Re === He;
      if (De) {
        var Ue = me.stateNode;
        ve ? eC(Ce, Ue, ve) : BA(Ce, Ue);
      } else if (Re !== Be) {
        var Ye = me.child;
        if (Ye !== null) {
          uE(Ye, ve, Ce);
          for (var et = Ye.sibling; et !== null; )
            uE(et, ve, Ce), et = et.sibling;
        }
      }
    }
    var Vi = null, Sl = !1;
    function WR(me, ve, Ce) {
      {
        var Re = ve;
        e:
          for (; Re !== null; ) {
            switch (Re.tag) {
              case ze: {
                Vi = Re.stateNode, Sl = !1;
                break e;
              }
              case Me: {
                Vi = Re.stateNode.containerInfo, Sl = !0;
                break e;
              }
              case Be: {
                Vi = Re.stateNode.containerInfo, Sl = !0;
                break e;
              }
            }
            Re = Re.return;
          }
        if (Vi === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        ZT(me, ve, Ce), Vi = null, Sl = !1;
      }
      HR(Ce);
    }
    function Hf(me, ve, Ce) {
      for (var Re = Ce.child; Re !== null; )
        ZT(me, ve, Re), Re = Re.sibling;
    }
    function ZT(me, ve, Ce) {
      switch (Eb(Ce), Ce.tag) {
        case ze:
          Ui || zy(Ce, ve);
        case He: {
          {
            var Re = Vi, De = Sl;
            Vi = null, Hf(me, ve, Ce), Vi = Re, Sl = De, Vi !== null && (Sl ? rC(Vi, Ce.stateNode) : nC(Vi, Ce.stateNode));
          }
          return;
        }
        case Ft: {
          Vi !== null && (Sl ? oC(Vi, Ce.stateNode) : X_(Vi, Ce.stateNode));
          return;
        }
        case Be: {
          {
            var Ue = Vi, Ye = Sl;
            Vi = Ce.stateNode.containerInfo, Sl = !0, Hf(me, ve, Ce), Vi = Ue, Sl = Ye;
          }
          return;
        }
        case Ie:
        case ot:
        case wt:
        case gt: {
          if (!Ui) {
            var et = Ce.updateQueue;
            if (et !== null) {
              var at = et.lastEffect;
              if (at !== null) {
                var yt = at.next, bt = yt;
                do {
                  var Ut = bt, jt = Ut.destroy, tn = Ut.tag;
                  jt !== void 0 && ((tn & Ic) !== ou ? Iw(Ce, ve, jt) : (tn & yi) !== ou && (Pm(Ce), Ce.mode & xr ? (jc(), Iw(Ce, ve, jt), Mc(Ce)) : Iw(Ce, ve, jt), ff())), bt = bt.next;
                } while (bt !== yt);
              }
            }
          }
          Hf(me, ve, Ce);
          return;
        }
        case $e: {
          if (!Ui) {
            zy(Ce, ve);
            var nn = Ce.stateNode;
            typeof nn.componentWillUnmount == "function" && iE(Ce, ve, nn);
          }
          Hf(me, ve, Ce);
          return;
        }
        case en: {
          Hf(me, ve, Ce);
          return;
        }
        case wn: {
          if (Ce.mode & Vr) {
            var bn = Ui;
            Ui = bn || Ce.memoizedState !== null, Hf(me, ve, Ce), Ui = bn;
          } else
            Hf(me, ve, Ce);
          break;
        }
        default: {
          Hf(me, ve, Ce);
          return;
        }
      }
    }
    function YR(me) {
      me.memoizedState;
    }
    function QR(me, ve) {
      var Ce = ve.memoizedState;
      if (Ce === null) {
        var Re = ve.alternate;
        if (Re !== null) {
          var De = Re.memoizedState;
          if (De !== null) {
            var Ue = De.dehydrated;
            Ue !== null && EC(Ue);
          }
        }
      }
    }
    function qT(me) {
      var ve = me.updateQueue;
      if (ve !== null) {
        me.updateQueue = null;
        var Ce = me.stateNode;
        Ce === null && (Ce = me.stateNode = new $R()), ve.forEach(function(Re) {
          var De = qN.bind(null, me, Re);
          if (!Ce.has(Re)) {
            if (Ce.add(Re), di)
              if (By !== null && Fy !== null)
                zv(Fy, By);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            Re.then(De, De);
          }
        });
      }
    }
    function KR(me, ve, Ce) {
      By = Ce, Fy = me, lo(ve), WT(ve, me), lo(ve), By = null, Fy = null;
    }
    function Pl(me, ve, Ce) {
      var Re = ve.deletions;
      if (Re !== null)
        for (var De = 0; De < Re.length; De++) {
          var Ue = Re[De];
          try {
            WR(me, ve, Ue);
          } catch (at) {
            Vo(Ue, ve, at);
          }
        }
      var Ye = Xd();
      if (ve.subtreeFlags & as)
        for (var et = ve.child; et !== null; )
          lo(et), WT(et, me), et = et.sibling;
      lo(Ye);
    }
    function WT(me, ve, Ce) {
      var Re = me.alternate, De = me.flags;
      switch (me.tag) {
        case Ie:
        case ot:
        case wt:
        case gt: {
          if (Pl(ve, me), Lc(me), De & Br) {
            try {
              El(Ic | mi, me, me.return), Vf(Ic | mi, me);
            } catch (Or) {
              Vo(me, me.return, Or);
            }
            if (me.mode & xr) {
              try {
                jc(), El(yi | mi, me, me.return);
              } catch (Or) {
                Vo(me, me.return, Or);
              }
              Mc(me);
            } else
              try {
                El(yi | mi, me, me.return);
              } catch (Or) {
                Vo(me, me.return, Or);
              }
          }
          return;
        }
        case $e: {
          Pl(ve, me), Lc(me), De & ns && Re !== null && zy(Re, Re.return);
          return;
        }
        case ze: {
          Pl(ve, me), Lc(me), De & ns && Re !== null && zy(Re, Re.return);
          {
            if (me.flags & go) {
              var Ue = me.stateNode;
              try {
                ES(Ue);
              } catch (Or) {
                Vo(me, me.return, Or);
              }
            }
            if (De & Br) {
              var Ye = me.stateNode;
              if (Ye != null) {
                var et = me.memoizedProps, at = Re !== null ? Re.memoizedProps : et, yt = me.type, bt = me.updateQueue;
                if (me.updateQueue = null, bt !== null)
                  try {
                    $A(Ye, bt, yt, at, et, me);
                  } catch (Or) {
                    Vo(me, me.return, Or);
                  }
              }
            }
          }
          return;
        }
        case He: {
          if (Pl(ve, me), Lc(me), De & Br) {
            if (me.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Ut = me.stateNode, jt = me.memoizedProps, tn = Re !== null ? Re.memoizedProps : jt;
            try {
              RA(Ut, tn, jt);
            } catch (Or) {
              Vo(me, me.return, Or);
            }
          }
          return;
        }
        case Me: {
          if (Pl(ve, me), Lc(me), De & Br && Re !== null) {
            var nn = Re.memoizedState;
            if (nn.isDehydrated)
              try {
                xC(ve.containerInfo);
              } catch (Or) {
                Vo(me, me.return, Or);
              }
          }
          return;
        }
        case Be: {
          Pl(ve, me), Lc(me);
          return;
        }
        case ht: {
          Pl(ve, me), Lc(me);
          var bn = me.child;
          if (bn.flags & Xl) {
            var Fn = bn.stateNode, sr = bn.memoizedState, wr = sr !== null;
            if (Fn.isHidden = wr, wr) {
              var Zr = bn.alternate !== null && bn.alternate.memoizedState !== null;
              Zr || IN();
            }
          }
          if (De & Br) {
            try {
              YR(me);
            } catch (Or) {
              Vo(me, me.return, Or);
            }
            qT(me);
          }
          return;
        }
        case wn: {
          var Ur = Re !== null && Re.memoizedState !== null;
          if (me.mode & Vr) {
            var Qt = Ui;
            Ui = Qt || Ur, Pl(ve, me), Ui = Qt;
          } else
            Pl(ve, me);
          if (Lc(me), De & Xl) {
            var yn = me.stateNode, Xt = me.memoizedState, $n = Xt !== null, Gn = me;
            if (yn.isHidden = $n, $n && !Ur && (Gn.mode & Vr) !== vr) {
              tr = Gn;
              for (var zn = Gn.child; zn !== null; )
                tr = zn, JR(zn), zn = zn.sibling;
            }
            VR(Gn, $n);
          }
          return;
        }
        case on: {
          Pl(ve, me), Lc(me), De & Br && qT(me);
          return;
        }
        case en:
          return;
        default: {
          Pl(ve, me), Lc(me);
          return;
        }
      }
    }
    function Lc(me) {
      var ve = me.flags;
      if (ve & Lo) {
        try {
          qR(me);
        } catch (Ce) {
          Vo(me, me.return, Ce);
        }
        me.flags &= ~Lo;
      }
      ve & Ws && (me.flags &= ~Ws);
    }
    function XR(me, ve, Ce) {
      By = Ce, Fy = ve, tr = me, GT(me, ve, Ce), By = null, Fy = null;
    }
    function GT(me, ve, Ce) {
      for (var Re = (me.mode & Vr) !== vr; tr !== null; ) {
        var De = tr, Ue = De.child;
        if (De.tag === wn && Re) {
          var Ye = De.memoizedState !== null, et = Ye || Cw;
          if (et) {
            lE(me, ve, Ce);
            continue;
          } else {
            var at = De.alternate, yt = at !== null && at.memoizedState !== null, bt = yt || Ui, Ut = Cw, jt = Ui;
            Cw = et, Ui = bt, Ui && !jt && (tr = De, eN(De));
            for (var tn = Ue; tn !== null; )
              tr = tn, GT(tn, ve, Ce), tn = tn.sibling;
            tr = De, Cw = Ut, Ui = jt, lE(me, ve, Ce);
            continue;
          }
        }
        (De.subtreeFlags & Ii) !== hr && Ue !== null ? (Ue.return = De, tr = Ue) : lE(me, ve, Ce);
      }
    }
    function lE(me, ve, Ce) {
      for (; tr !== null; ) {
        var Re = tr;
        if ((Re.flags & Ii) !== hr) {
          var De = Re.alternate;
          lo(Re);
          try {
            zR(ve, De, Re, Ce);
          } catch (Ye) {
            Vo(Re, Re.return, Ye);
          }
          Ko();
        }
        if (Re === me) {
          tr = null;
          return;
        }
        var Ue = Re.sibling;
        if (Ue !== null) {
          Ue.return = Re.return, tr = Ue;
          return;
        }
        tr = Re.return;
      }
    }
    function JR(me) {
      for (; tr !== null; ) {
        var ve = tr, Ce = ve.child;
        switch (ve.tag) {
          case Ie:
          case ot:
          case wt:
          case gt: {
            if (ve.mode & xr)
              try {
                jc(), El(yi, ve, ve.return);
              } finally {
                Mc(ve);
              }
            else
              El(yi, ve, ve.return);
            break;
          }
          case $e: {
            zy(ve, ve.return);
            var Re = ve.stateNode;
            typeof Re.componentWillUnmount == "function" && iE(ve, ve.return, Re);
            break;
          }
          case ze: {
            zy(ve, ve.return);
            break;
          }
          case wn: {
            var De = ve.memoizedState !== null;
            if (De) {
              YT(me);
              continue;
            }
            break;
          }
        }
        Ce !== null ? (Ce.return = ve, tr = Ce) : YT(me);
      }
    }
    function YT(me) {
      for (; tr !== null; ) {
        var ve = tr;
        if (ve === me) {
          tr = null;
          return;
        }
        var Ce = ve.sibling;
        if (Ce !== null) {
          Ce.return = ve.return, tr = Ce;
          return;
        }
        tr = ve.return;
      }
    }
    function eN(me) {
      for (; tr !== null; ) {
        var ve = tr, Ce = ve.child;
        if (ve.tag === wn) {
          var Re = ve.memoizedState !== null;
          if (Re) {
            QT(me);
            continue;
          }
        }
        Ce !== null ? (Ce.return = ve, tr = Ce) : QT(me);
      }
    }
    function QT(me) {
      for (; tr !== null; ) {
        var ve = tr;
        lo(ve);
        try {
          UR(ve);
        } catch (Re) {
          Vo(ve, ve.return, Re);
        }
        if (Ko(), ve === me) {
          tr = null;
          return;
        }
        var Ce = ve.sibling;
        if (Ce !== null) {
          Ce.return = ve.return, tr = Ce;
          return;
        }
        tr = ve.return;
      }
    }
    function tN(me, ve, Ce, Re) {
      tr = ve, nN(ve, me, Ce, Re);
    }
    function nN(me, ve, Ce, Re) {
      for (; tr !== null; ) {
        var De = tr, Ue = De.child;
        (De.subtreeFlags & Gs) !== hr && Ue !== null ? (Ue.return = De, tr = Ue) : rN(me, ve, Ce, Re);
      }
    }
    function rN(me, ve, Ce, Re) {
      for (; tr !== null; ) {
        var De = tr;
        if ((De.flags & Go) !== hr) {
          lo(De);
          try {
            oN(ve, De, Ce, Re);
          } catch (Ye) {
            Vo(De, De.return, Ye);
          }
          Ko();
        }
        if (De === me) {
          tr = null;
          return;
        }
        var Ue = De.sibling;
        if (Ue !== null) {
          Ue.return = De.return, tr = Ue;
          return;
        }
        tr = De.return;
      }
    }
    function oN(me, ve, Ce, Re) {
      switch (ve.tag) {
        case Ie:
        case ot:
        case gt: {
          if (ve.mode & xr) {
            Fx();
            try {
              Vf(Bi | mi, ve);
            } finally {
              Bx(ve);
            }
          } else
            Vf(Bi | mi, ve);
          break;
        }
      }
    }
    function aN(me) {
      tr = me, iN();
    }
    function iN() {
      for (; tr !== null; ) {
        var me = tr, ve = me.child;
        if ((tr.flags & yo) !== hr) {
          var Ce = me.deletions;
          if (Ce !== null) {
            for (var Re = 0; Re < Ce.length; Re++) {
              var De = Ce[Re];
              tr = De, lN(De, me);
            }
            {
              var Ue = me.alternate;
              if (Ue !== null) {
                var Ye = Ue.child;
                if (Ye !== null) {
                  Ue.child = null;
                  do {
                    var et = Ye.sibling;
                    Ye.sibling = null, Ye = et;
                  } while (Ye !== null);
                }
              }
            }
            tr = me;
          }
        }
        (me.subtreeFlags & Gs) !== hr && ve !== null ? (ve.return = me, tr = ve) : sN();
      }
    }
    function sN() {
      for (; tr !== null; ) {
        var me = tr;
        (me.flags & Go) !== hr && (lo(me), uN(me), Ko());
        var ve = me.sibling;
        if (ve !== null) {
          ve.return = me.return, tr = ve;
          return;
        }
        tr = me.return;
      }
    }
    function uN(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          me.mode & xr ? (Fx(), El(Bi | mi, me, me.return), Bx(me)) : El(Bi | mi, me, me.return);
          break;
        }
      }
    }
    function lN(me, ve) {
      for (; tr !== null; ) {
        var Ce = tr;
        lo(Ce), dN(Ce, ve), Ko();
        var Re = Ce.child;
        Re !== null ? (Re.return = Ce, tr = Re) : cN(me);
      }
    }
    function cN(me) {
      for (; tr !== null; ) {
        var ve = tr, Ce = ve.sibling, Re = ve.return;
        if (UT(ve), ve === me) {
          tr = null;
          return;
        }
        if (Ce !== null) {
          Ce.return = Re, tr = Ce;
          return;
        }
        tr = Re;
      }
    }
    function dN(me, ve) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          me.mode & xr ? (Fx(), El(Bi, me, ve), Bx(me)) : El(Bi, me, ve);
          break;
        }
      }
    }
    function fN(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          try {
            Vf(yi | mi, me);
          } catch (Ce) {
            Vo(me, me.return, Ce);
          }
          break;
        }
        case $e: {
          var ve = me.stateNode;
          try {
            ve.componentDidMount();
          } catch (Ce) {
            Vo(me, me.return, Ce);
          }
          break;
        }
      }
    }
    function pN(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          try {
            Vf(Bi | mi, me);
          } catch (ve) {
            Vo(me, me.return, ve);
          }
          break;
        }
      }
    }
    function hN(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt: {
          try {
            El(yi | mi, me, me.return);
          } catch (Ce) {
            Vo(me, me.return, Ce);
          }
          break;
        }
        case $e: {
          var ve = me.stateNode;
          typeof ve.componentWillUnmount == "function" && iE(me, me.return, ve);
          break;
        }
      }
    }
    function mN(me) {
      switch (me.tag) {
        case Ie:
        case ot:
        case gt:
          try {
            El(Bi | mi, me, me.return);
          } catch (ve) {
            Vo(me, me.return, ve);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Iv = Symbol.for;
      Iv("selector.component"), Iv("selector.has_pseudo_class"), Iv("selector.role"), Iv("selector.test_id"), Iv("selector.text");
    }
    var yN = [];
    function bN() {
      yN.forEach(function(me) {
        return me();
      });
    }
    var vN = fe.ReactCurrentActQueue;
    function gN(me) {
      {
        var ve = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, Ce = typeof jest < "u";
        return Ce && ve !== !1;
      }
    }
    function KT() {
      {
        var me = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !me && vN.current !== null && _e("The current testing environment is not configured to support act(...)"), me;
      }
    }
    var wN = Math.ceil, cE = fe.ReactCurrentDispatcher, dE = fe.ReactCurrentOwner, Hi = fe.ReactCurrentBatchConfig, kl = fe.ReactCurrentActQueue, gi = 0, XT = 1, qi = 2, Xu = 4, Hd = 0, $v = 1, Qh = 2, $w = 3, Rv = 4, JT = 5, fE = 6, ao = gi, Ls = null, wa = null, wi = vn, Dc = vn, pE = Nf(vn), xi = Hd, Nv = null, Rw = vn, Mv = vn, Nw = vn, jv = null, au = null, hE = 0, e2 = 500, t2 = 1 / 0, _N = 500, Zd = null;
    function Lv() {
      t2 = ea() + _N;
    }
    function n2() {
      return t2;
    }
    var Mw = !1, mE = null, Uy = null, Kh = !1, Zf = null, Dv = vn, yE = [], bE = null, xN = 50, Bv = 0, vE = null, gE = !1, jw = !1, EN = 50, Vy = 0, Lw = null, Dw = Co, Bw = vn, r2 = !1;
    function Fw() {
      return Ls;
    }
    function Ds() {
      return (ao & (qi | Xu)) !== gi ? ea() : (Dw !== Co || (Dw = ea()), Dw);
    }
    function qf(me) {
      var ve = me.mode;
      if ((ve & Vr) === vr)
        return kr;
      if ((ao & qi) !== gi && wi !== vn)
        return $a(wi);
      var Ce = uI() !== sI;
      if (Ce) {
        if (Hi.transition !== null) {
          var Re = Hi.transition;
          Re._updatedFibers || (Re._updatedFibers = /* @__PURE__ */ new Set()), Re._updatedFibers.add(me);
        }
        return Bw === oo && (Bw = Ib()), Bw;
      }
      var De = $s();
      if (De !== oo)
        return De;
      var Ue = uA();
      return Ue;
    }
    function SN(me) {
      var ve = me.mode;
      return (ve & Vr) === vr ? kr : __();
    }
    function Ei(me, ve, Ce, Re) {
      GN(), r2 && _e("useInsertionEffect must not schedule updates."), gE && (jw = !0), wf(me, Ce, Re), (ao & qi) !== vn && me === Ls ? KN(ve) : (di && jg(me, ve, Ce), XN(ve), me === Ls && ((ao & qi) === gi && (Mv = Fr(Mv, Ce)), xi === Rv && Wf(me, wi)), iu(me, Re), Ce === kr && ao === gi && (ve.mode & Vr) === vr && !kl.isBatchingLegacy && (Lv(), jS()));
    }
    function PN(me, ve, Ce) {
      var Re = me.current;
      Re.lanes = ve, wf(me, ve, Ce), iu(me, Ce);
    }
    function kN(me) {
      return (ao & qi) !== gi;
    }
    function iu(me, ve) {
      var Ce = me.callbackNode;
      v_(me, ve);
      var Re = Tp(me, me === Ls ? wi : vn);
      if (Re === vn) {
        Ce !== null && _2(Ce), me.callbackNode = null, me.callbackPriority = oo;
        return;
      }
      var De = ka(Re), Ue = me.callbackPriority;
      if (Ue === De && !(kl.current !== null && Ce !== kE)) {
        Ce == null && Ue !== kr && _e("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      Ce != null && _2(Ce);
      var Ye;
      if (De === kr)
        me.tag === Mf ? (kl.isBatchingLegacy !== null && (kl.didScheduleLegacyUpdate = !0), VC(i2.bind(null, me))) : MS(i2.bind(null, me)), kl.current !== null ? kl.current.push(jf) : yA(function() {
          (ao & (qi | Xu)) === gi && jf();
        }), Ye = null;
      else {
        var et;
        switch (Dg(Re)) {
          case cs:
            et = _m;
            break;
          case Xs:
            et = Cs;
            break;
          case fi:
            et = Vu;
            break;
          case ey:
            et = ec;
            break;
          default:
            et = Vu;
            break;
        }
        Ye = TE(et, o2.bind(null, me));
      }
      me.callbackPriority = De, me.callbackNode = Ye;
    }
    function o2(me, ve) {
      if (Z$(), Dw = Co, Bw = vn, (ao & (qi | Xu)) !== gi)
        throw new Error("Should not already be working.");
      var Ce = me.callbackNode, Re = Wd();
      if (Re && me.callbackNode !== Ce)
        return null;
      var De = Tp(me, me === Ls ? wi : vn);
      if (De === vn)
        return null;
      var Ue = !Cp(me, De) && !Ng(me, De) && !ve, Ye = Ue ? jN(me, De) : Uw(me, De);
      if (Ye !== Hd) {
        if (Ye === Qh) {
          var et = Ab(me);
          et !== vn && (De = et, Ye = wE(me, et));
        }
        if (Ye === $v) {
          var at = Nv;
          throw Xh(me, vn), Wf(me, De), iu(me, ea()), at;
        }
        if (Ye === fE)
          Wf(me, De);
        else {
          var yt = !Cp(me, De), bt = me.current.alternate;
          if (yt && !ON(bt)) {
            if (Ye = Uw(me, De), Ye === Qh) {
              var Ut = Ab(me);
              Ut !== vn && (De = Ut, Ye = wE(me, Ut));
            }
            if (Ye === $v) {
              var jt = Nv;
              throw Xh(me, vn), Wf(me, De), iu(me, ea()), jt;
            }
          }
          me.finishedWork = bt, me.finishedLanes = De, TN(me, Ye, De);
        }
      }
      return iu(me, ea()), me.callbackNode === Ce ? o2.bind(null, me) : null;
    }
    function wE(me, ve) {
      var Ce = jv;
      if (Pd(me)) {
        var Re = Xh(me, ve);
        Re.flags |= ua, jC(me.containerInfo);
      }
      var De = Uw(me, ve);
      if (De !== Qh) {
        var Ue = au;
        au = Ce, Ue !== null && a2(Ue);
      }
      return De;
    }
    function a2(me) {
      au === null ? au = me : au.push.apply(au, me);
    }
    function TN(me, ve, Ce) {
      switch (ve) {
        case Hd:
        case $v:
          throw new Error("Root did not complete. This is a bug in React.");
        case Qh: {
          Jh(me, au, Zd);
          break;
        }
        case $w: {
          if (Wf(me, Ce), qm(Ce) && !x2()) {
            var Re = hE + e2 - ea();
            if (Re > 10) {
              var De = Tp(me, vn);
              if (De !== vn)
                break;
              var Ue = me.suspendedLanes;
              if (!Ed(Ue, Ce)) {
                Ds(), Ym(me, Ue);
                break;
              }
              me.timeoutHandle = Q_(Jh.bind(null, me, au, Zd), Re);
              break;
            }
          }
          Jh(me, au, Zd);
          break;
        }
        case Rv: {
          if (Wf(me, Ce), Rg(Ce))
            break;
          if (!x2()) {
            var Ye = $g(me, Ce), et = Ye, at = ea() - et, yt = WN(at) - at;
            if (yt > 10) {
              me.timeoutHandle = Q_(Jh.bind(null, me, au, Zd), yt);
              break;
            }
          }
          Jh(me, au, Zd);
          break;
        }
        case JT: {
          Jh(me, au, Zd);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function ON(me) {
      for (var ve = me; ; ) {
        if (ve.flags & wp) {
          var Ce = ve.updateQueue;
          if (Ce !== null) {
            var Re = Ce.stores;
            if (Re !== null)
              for (var De = 0; De < Re.length; De++) {
                var Ue = Re[De], Ye = Ue.getSnapshot, et = Ue.value;
                try {
                  if (!Zn(Ye(), et))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var at = ve.child;
        if (ve.subtreeFlags & wp && at !== null) {
          at.return = ve, ve = at;
          continue;
        }
        if (ve === me)
          return !0;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === me)
            return !0;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
      return !0;
    }
    function Wf(me, ve) {
      ve = gf(ve, Nw), ve = gf(ve, Mv), Nb(me, ve);
    }
    function i2(me) {
      if (W$(), (ao & (qi | Xu)) !== gi)
        throw new Error("Should not already be working.");
      Wd();
      var ve = Tp(me, vn);
      if (!ls(ve, kr))
        return iu(me, ea()), null;
      var Ce = Uw(me, ve);
      if (me.tag !== Mf && Ce === Qh) {
        var Re = Ab(me);
        Re !== vn && (ve = Re, Ce = wE(me, Re));
      }
      if (Ce === $v) {
        var De = Nv;
        throw Xh(me, vn), Wf(me, ve), iu(me, ea()), De;
      }
      if (Ce === fE)
        throw new Error("Root did not complete. This is a bug in React.");
      var Ue = me.current.alternate;
      return me.finishedWork = Ue, me.finishedLanes = ve, Jh(me, au, Zd), iu(me, ea()), null;
    }
    function AN(me, ve) {
      ve !== vn && (Ip(me, Fr(ve, kr)), iu(me, ea()), (ao & (qi | Xu)) === gi && (Lv(), jf()));
    }
    function _E(me, ve) {
      var Ce = ao;
      ao |= XT;
      try {
        return me(ve);
      } finally {
        ao = Ce, ao === gi && !kl.isBatchingLegacy && (Lv(), jS());
      }
    }
    function CN(me, ve, Ce, Re, De) {
      var Ue = $s(), Ye = Hi.transition;
      try {
        return Hi.transition = null, Ra(cs), me(ve, Ce, Re, De);
      } finally {
        Ra(Ue), Hi.transition = Ye, ao === gi && Lv();
      }
    }
    function qd(me) {
      Zf !== null && Zf.tag === Mf && (ao & (qi | Xu)) === gi && Wd();
      var ve = ao;
      ao |= XT;
      var Ce = Hi.transition, Re = $s();
      try {
        return Hi.transition = null, Ra(cs), me ? me() : void 0;
      } finally {
        Ra(Re), Hi.transition = Ce, ao = ve, (ao & (qi | Xu)) === gi && jf();
      }
    }
    function u2() {
      return (ao & (qi | Xu)) !== gi;
    }
    function zw(me, ve) {
      bs(pE, Dc, me), Dc = Fr(Dc, ve);
    }
    function xE(me) {
      Dc = pE.current, ys(pE, me);
    }
    function Xh(me, ve) {
      me.finishedWork = null, me.finishedLanes = vn;
      var Ce = me.timeoutHandle;
      if (Ce !== K_ && (me.timeoutHandle = K_, lA(Ce)), wa !== null)
        for (var Re = wa.return; Re !== null; ) {
          var De = Re.alternate;
          jT(De, Re), Re = Re.return;
        }
      Ls = me;
      var Ue = em(me.current, null);
      return wa = Ue, wi = Dc = ve, xi = Hd, Nv = null, Rw = vn, Mv = vn, Nw = vn, jv = null, au = null, pI(), vl.discardPendingWarnings(), Ue;
    }
    function c2(me, ve) {
      do {
        var Ce = wa;
        try {
          if (q0(), XP(), Ko(), dE.current = null, Ce === null || Ce.return === null) {
            xi = $v, Nv = ve, wa = null;
            return;
          }
          if (Vn && Ce.mode & xr && kw(Ce, !0), _n)
            if (od(), ve !== null && typeof ve == "object" && typeof ve.then == "function") {
              var Re = ve;
              Ag(Ce, Re, wi);
            } else
              km(Ce, ve, wi);
          X$(me, Ce.return, Ce, ve, wi), h2(Ce);
        } catch (De) {
          ve = De, wa === Ce && Ce !== null ? (Ce = Ce.return, wa = Ce) : Ce = wa;
          continue;
        }
        return;
      } while (!0);
    }
    function d2() {
      var me = cE.current;
      return cE.current = _w, me === null ? _w : me;
    }
    function f2(me) {
      cE.current = me;
    }
    function IN() {
      hE = ea();
    }
    function Fv(me) {
      Rw = Fr(me, Rw);
    }
    function $N() {
      xi === Hd && (xi = $w);
    }
    function EE() {
      (xi === Hd || xi === $w || xi === Qh) && (xi = Rv), Ls !== null && (Ap(Rw) || Ap(Mv)) && Wf(Ls, wi);
    }
    function RN(me) {
      xi !== Rv && (xi = Qh), jv === null ? jv = [me] : jv.push(me);
    }
    function NN() {
      return xi === Hd;
    }
    function Uw(me, ve) {
      var Ce = ao;
      ao |= qi;
      var Re = d2();
      if (Ls !== me || wi !== ve) {
        if (di) {
          var De = me.memoizedUpdaters;
          De.size > 0 && (zv(me, wi), De.clear()), Mb(me, ve);
        }
        Zd = Km(), Xh(me, ve);
      }
      pu(ve);
      do
        try {
          MN();
          break;
        } catch (Ue) {
          c2(me, Ue);
        }
      while (!0);
      if (q0(), ao = Ce, f2(Re), wa !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return hf(), Ls = null, wi = vn, xi;
    }
    function MN() {
      for (; wa !== null; )
        p2(wa);
    }
    function jN(me, ve) {
      var Ce = ao;
      ao |= qi;
      var Re = d2();
      if (Ls !== me || wi !== ve) {
        if (di) {
          var De = me.memoizedUpdaters;
          De.size > 0 && (zv(me, wi), De.clear()), Mb(me, ve);
        }
        Zd = Km(), Lv(), Xh(me, ve);
      }
      pu(ve);
      do
        try {
          LN();
          break;
        } catch (Ue) {
          c2(me, Ue);
        }
      while (!0);
      return q0(), f2(Re), ao = Ce, wa !== null ? (Ep(), Hd) : (hf(), Ls = null, wi = vn, xi);
    }
    function LN() {
      for (; wa !== null && !wm(); )
        p2(wa);
    }
    function p2(me) {
      var ve = me.alternate;
      lo(me);
      var Ce;
      (me.mode & xr) !== vr ? (Dx(me), Ce = SE(ve, me, Dc), kw(me, !0)) : Ce = SE(ve, me, Dc), Ko(), me.memoizedProps = me.pendingProps, Ce === null ? h2(me) : wa = Ce, dE.current = null;
    }
    function h2(me) {
      var ve = me;
      do {
        var Ce = ve.alternate, Re = ve.return;
        if ((ve.flags & Ts) === hr) {
          lo(ve);
          var De = void 0;
          if ((ve.mode & xr) === vr ? De = MT(Ce, ve, Dc) : (Dx(ve), De = MT(Ce, ve, Dc), kw(ve, !1)), Ko(), De !== null) {
            wa = De;
            return;
          }
        } else {
          var Ue = IR(Ce, ve);
          if (Ue !== null) {
            Ue.flags &= wg, wa = Ue;
            return;
          }
          if ((ve.mode & xr) !== vr) {
            kw(ve, !1);
            for (var Ye = ve.actualDuration, et = ve.child; et !== null; )
              Ye += et.actualDuration, et = et.sibling;
            ve.actualDuration = Ye;
          }
          if (Re !== null)
            Re.flags |= Ts, Re.subtreeFlags = hr, Re.deletions = null;
          else {
            xi = fE, wa = null;
            return;
          }
        }
        var at = ve.sibling;
        if (at !== null) {
          wa = at;
          return;
        }
        ve = Re, wa = ve;
      } while (ve !== null);
      xi === Hd && (xi = JT);
    }
    function Jh(me, ve, Ce) {
      var Re = $s(), De = Hi.transition;
      try {
        Hi.transition = null, Ra(cs), DN(me, ve, Ce, Re);
      } finally {
        Hi.transition = De, Ra(Re);
      }
      return null;
    }
    function DN(me, ve, Ce, Re) {
      do
        Wd();
      while (Zf !== null);
      if (YN(), (ao & (qi | Xu)) !== gi)
        throw new Error("Should not already be working.");
      var De = me.finishedWork, Ue = me.finishedLanes;
      if (Em(Ue), De === null)
        return Sb(), null;
      if (Ue === vn && _e("root.finishedLanes should not be empty during a commit. This is a bug in React."), me.finishedWork = null, me.finishedLanes = vn, De === me.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      me.callbackNode = null, me.callbackPriority = oo;
      var Ye = Fr(De.lanes, De.childLanes);
      Mg(me, Ye), me === Ls && (Ls = null, wa = null, wi = vn), ((De.subtreeFlags & Gs) !== hr || (De.flags & Gs) !== hr) && (Kh || (Kh = !0, bE = Ce, TE(Vu, function() {
        return Wd(), null;
      })));
      var et = (De.subtreeFlags & (df | as | Ii | Gs)) !== hr, at = (De.flags & (df | as | Ii | Gs)) !== hr;
      if (et || at) {
        var yt = Hi.transition;
        Hi.transition = null;
        var bt = $s();
        Ra(cs);
        var Ut = ao;
        ao |= Xu, dE.current = null, jR(me, De), lT(), KR(me, De, Ue), QO(me.containerInfo), me.current = De, Cg(Ue), XR(De, me, Ue), pf(), Eg(), ao = Ut, Ra(bt), Hi.transition = yt;
      } else
        me.current = De, lT();
      var jt = Kh;
      if (Kh ? (Kh = !1, Zf = me, Dv = Ue) : (Vy = 0, Lw = null), Ye = me.pendingLanes, Ye === vn && (Uy = null), jt || v2(me.current, !1), dl(De.stateNode, Re), di && me.memoizedUpdaters.clear(), bN(), iu(me, ea()), ve !== null)
        for (var tn = me.onRecoverableError, nn = 0; nn < ve.length; nn++) {
          var bn = ve[nn], Fn = bn.stack, sr = bn.digest;
          tn(bn.value, { componentStack: Fn, digest: sr });
        }
      if (Mw) {
        Mw = !1;
        var wr = mE;
        throw mE = null, wr;
      }
      return ls(Dv, kr) && me.tag !== Mf && Wd(), Ye = me.pendingLanes, ls(Ye, kr) ? (x$(), me === vE ? Bv++ : (Bv = 0, vE = me)) : Bv = 0, jf(), Sb(), null;
    }
    function Wd() {
      if (Zf !== null) {
        var me = Dg(Dv), ve = $i(fi, me), Ce = Hi.transition, Re = $s();
        try {
          return Hi.transition = null, Ra(ve), FN();
        } finally {
          Ra(Re), Hi.transition = Ce;
        }
      }
      return !1;
    }
    function BN(me) {
      yE.push(me), Kh || (Kh = !0, TE(Vu, function() {
        return Wd(), null;
      }));
    }
    function FN() {
      if (Zf === null)
        return !1;
      var me = bE;
      bE = null;
      var ve = Zf, Ce = Dv;
      if (Zf = null, Dv = vn, (ao & (qi | Xu)) !== gi)
        throw new Error("Cannot flush passive effects while already rendering.");
      gE = !0, jw = !1, Ig(Ce);
      var Re = ao;
      ao |= Xu, aN(ve.current), tN(ve, ve.current, Ce, me);
      {
        var De = yE;
        yE = [];
        for (var Ue = 0; Ue < De.length; Ue++) {
          var Ye = De[Ue];
          FR(ve, Ye);
        }
      }
      xp(), v2(ve.current, !0), ao = Re, jf(), jw ? ve === Lw ? Vy++ : (Vy = 0, Lw = ve) : Vy = 0, gE = !1, jw = !1, nc(ve);
      {
        var et = ve.current.stateNode;
        et.effectDuration = 0, et.passiveEffectDuration = 0;
      }
      return !0;
    }
    function m2(me) {
      return Uy !== null && Uy.has(me);
    }
    function zN(me) {
      Uy === null ? Uy = /* @__PURE__ */ new Set([me]) : Uy.add(me);
    }
    function UN(me) {
      Mw || (Mw = !0, mE = me);
    }
    var VN = UN;
    function y2(me, ve, Ce) {
      var Re = Zh(Ce, ve), De = dT(me, Re, kr), Ue = Df(me, De, kr), Ye = Ds();
      Ue !== null && (wf(Ue, kr, Ye), iu(Ue, Ye));
    }
    function Vo(me, ve, Ce) {
      if (RR(Ce), Uv(!1), me.tag === Me) {
        y2(me, me, Ce);
        return;
      }
      var Re = null;
      for (Re = ve; Re !== null; ) {
        if (Re.tag === Me) {
          y2(Re, me, Ce);
          return;
        } else if (Re.tag === $e) {
          var De = Re.type, Ue = Re.stateNode;
          if (typeof De.getDerivedStateFromError == "function" || typeof Ue.componentDidCatch == "function" && !m2(Ue)) {
            var Ye = Zh(Ce, me), et = Hx(Re, Ye, kr), at = Df(Re, et, kr), yt = Ds();
            at !== null && (wf(at, kr, yt), iu(at, yt));
            return;
          }
        }
        Re = Re.return;
      }
      _e(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, Ce);
    }
    function HN(me, ve, Ce) {
      var Re = me.pingCache;
      Re !== null && Re.delete(ve);
      var De = Ds();
      Ym(me, Ce), JN(me), Ls === me && Ed(wi, Ce) && (xi === Rv || xi === $w && qm(wi) && ea() - hE < e2 ? Xh(me, vn) : Nw = Fr(Nw, Ce)), iu(me, De);
    }
    function b2(me, ve) {
      ve === oo && (ve = SN(me));
      var Ce = Ds(), Re = ru(me, ve);
      Re !== null && (wf(Re, ve, Ce), iu(Re, Ce));
    }
    function ZN(me) {
      var ve = me.memoizedState, Ce = oo;
      ve !== null && (Ce = ve.retryLane), b2(me, Ce);
    }
    function qN(me, ve) {
      var Ce = oo, Re;
      switch (me.tag) {
        case ht:
          Re = me.stateNode;
          var De = me.memoizedState;
          De !== null && (Ce = De.retryLane);
          break;
        case on:
          Re = me.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      Re !== null && Re.delete(ve), b2(me, Ce);
    }
    function WN(me) {
      return me < 120 ? 120 : me < 480 ? 480 : me < 1080 ? 1080 : me < 1920 ? 1920 : me < 3e3 ? 3e3 : me < 4320 ? 4320 : wN(me / 1960) * 1960;
    }
    function GN() {
      if (Bv > xN)
        throw Bv = 0, vE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Vy > EN && (Vy = 0, Lw = null, _e("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function YN() {
      vl.flushLegacyContextWarning(), vl.flushPendingUnsafeLifecycleWarnings();
    }
    function v2(me, ve) {
      lo(me), Vw(me, os, hN), ve && Vw(me, rd, mN), Vw(me, os, fN), ve && Vw(me, rd, pN), Ko();
    }
    function Vw(me, ve, Ce) {
      for (var Re = me, De = null; Re !== null; ) {
        var Ue = Re.subtreeFlags & ve;
        Re !== De && Re.child !== null && Ue !== hr ? Re = Re.child : ((Re.flags & ve) !== hr && Ce(Re), Re.sibling !== null ? Re = Re.sibling : Re = De = Re.return);
      }
    }
    var Hw = null;
    function g2(me) {
      {
        if ((ao & qi) !== gi || !(me.mode & Vr))
          return;
        var ve = me.tag;
        if (ve !== Ne && ve !== Me && ve !== $e && ve !== Ie && ve !== ot && ve !== wt && ve !== gt)
          return;
        var Ce = Ar(me) || "ReactComponent";
        if (Hw !== null) {
          if (Hw.has(Ce))
            return;
          Hw.add(Ce);
        } else
          Hw = /* @__PURE__ */ new Set([Ce]);
        var Re = Zo;
        try {
          lo(me), _e("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          Re ? lo(me) : Ko();
        }
      }
    }
    var SE;
    {
      var QN = null;
      SE = function(me, ve, Ce) {
        var Re = k2(QN, ve);
        try {
          return CT(me, ve, Ce);
        } catch (Ue) {
          if (KC() || Ue !== null && typeof Ue == "object" && typeof Ue.then == "function")
            throw Ue;
          if (q0(), XP(), jT(me, ve), k2(ve, Re), ve.mode & xr && Dx(ve), nd(null, CT, null, me, ve, Ce), y_()) {
            var De = pb();
            typeof De == "object" && De !== null && De._suppressLogging && typeof Ue == "object" && Ue !== null && !Ue._suppressLogging && (Ue._suppressLogging = !0);
          }
          throw Ue;
        }
      };
    }
    var w2 = !1, PE;
    PE = /* @__PURE__ */ new Set();
    function KN(me) {
      if (ii && !QI())
        switch (me.tag) {
          case Ie:
          case ot:
          case gt: {
            var ve = wa && Ar(wa) || "Unknown", Ce = ve;
            if (!PE.has(Ce)) {
              PE.add(Ce);
              var Re = Ar(me) || "Unknown";
              _e("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", Re, ve, ve);
            }
            break;
          }
          case $e: {
            w2 || (_e("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), w2 = !0);
            break;
          }
        }
    }
    function zv(me, ve) {
      if (di) {
        var Ce = me.memoizedUpdaters;
        Ce.forEach(function(Re) {
          jg(me, Re, ve);
        });
      }
    }
    var kE = {};
    function TE(me, ve) {
      {
        var Ce = kl.current;
        return Ce !== null ? (Ce.push(ve), kE) : gm(me, ve);
      }
    }
    function _2(me) {
      if (me !== kE)
        return xg(me);
    }
    function x2() {
      return kl.current !== null;
    }
    function XN(me) {
      {
        if (me.mode & Vr) {
          if (!KT())
            return;
        } else if (!gN() || ao !== gi || me.tag !== Ie && me.tag !== ot && me.tag !== gt)
          return;
        if (kl.current === null) {
          var ve = Zo;
          try {
            lo(me), _e(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ar(me));
          } finally {
            ve ? lo(me) : Ko();
          }
        }
      }
    }
    function JN(me) {
      me.tag !== Mf && KT() && kl.current === null && _e(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Uv(me) {
      r2 = me;
    }
    var Ju = null, Hy = null, eM = function(me) {
      Ju = me;
    };
    function Zy(me) {
      {
        if (Ju === null)
          return me;
        var ve = Ju(me);
        return ve === void 0 ? me : ve.current;
      }
    }
    function OE(me) {
      return Zy(me);
    }
    function AE(me) {
      {
        if (Ju === null)
          return me;
        var ve = Ju(me);
        if (ve === void 0) {
          if (me != null && typeof me.render == "function") {
            var Ce = Zy(me.render);
            if (me.render !== Ce) {
              var Re = { $$typeof: ar, render: Ce };
              return me.displayName !== void 0 && (Re.displayName = me.displayName), Re;
            }
          }
          return me;
        }
        return ve.current;
      }
    }
    function E2(me, ve) {
      {
        if (Ju === null)
          return !1;
        var Ce = me.elementType, Re = ve.type, De = !1, Ue = typeof Re == "object" && Re !== null ? Re.$$typeof : null;
        switch (me.tag) {
          case $e: {
            typeof Re == "function" && (De = !0);
            break;
          }
          case Ie: {
            (typeof Re == "function" || Ue === fr) && (De = !0);
            break;
          }
          case ot: {
            (Ue === ar || Ue === fr) && (De = !0);
            break;
          }
          case wt:
          case gt: {
            (Ue === Lr || Ue === fr) && (De = !0);
            break;
          }
          default:
            return !1;
        }
        if (De) {
          var Ye = Ju(Ce);
          if (Ye !== void 0 && Ye === Ju(Re))
            return !0;
        }
        return !1;
      }
    }
    function S2(me) {
      {
        if (Ju === null || typeof WeakSet != "function")
          return;
        Hy === null && (Hy = /* @__PURE__ */ new WeakSet()), Hy.add(me);
      }
    }
    var tM = function(me, ve) {
      {
        if (Ju === null)
          return;
        var Ce = ve.staleFamilies, Re = ve.updatedFamilies;
        Wd(), qd(function() {
          CE(me.current, Re, Ce);
        });
      }
    }, nM = function(me, ve) {
      {
        if (me.context !== yu)
          return;
        Wd(), qd(function() {
          Vv(ve, me, null, null);
        });
      }
    };
    function CE(me, ve, Ce) {
      {
        var Re = me.alternate, De = me.child, Ue = me.sibling, Ye = me.tag, et = me.type, at = null;
        switch (Ye) {
          case Ie:
          case gt:
          case $e:
            at = et;
            break;
          case ot:
            at = et.render;
            break;
        }
        if (Ju === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var yt = !1, bt = !1;
        if (at !== null) {
          var Ut = Ju(at);
          Ut !== void 0 && (Ce.has(Ut) ? bt = !0 : ve.has(Ut) && (Ye === $e ? bt = !0 : yt = !0));
        }
        if (Hy !== null && (Hy.has(me) || Re !== null && Hy.has(Re)) && (bt = !0), bt && (me._debugNeedsRemount = !0), bt || yt) {
          var jt = ru(me, kr);
          jt !== null && Ei(jt, me, kr, Co);
        }
        De !== null && !bt && CE(De, ve, Ce), Ue !== null && CE(Ue, ve, Ce);
      }
    }
    var rM = function(me, ve) {
      {
        var Ce = /* @__PURE__ */ new Set(), Re = new Set(ve.map(function(De) {
          return De.current;
        }));
        return IE(me.current, Re, Ce), Ce;
      }
    };
    function IE(me, ve, Ce) {
      {
        var Re = me.child, De = me.sibling, Ue = me.tag, Ye = me.type, et = null;
        switch (Ue) {
          case Ie:
          case gt:
          case $e:
            et = Ye;
            break;
          case ot:
            et = Ye.render;
            break;
        }
        var at = !1;
        et !== null && ve.has(et) && (at = !0), at ? oM(me, Ce) : Re !== null && IE(Re, ve, Ce), De !== null && IE(De, ve, Ce);
      }
    }
    function oM(me, ve) {
      {
        var Ce = aM(me, ve);
        if (Ce)
          return;
        for (var Re = me; ; ) {
          switch (Re.tag) {
            case ze:
              ve.add(Re.stateNode);
              return;
            case Be:
              ve.add(Re.stateNode.containerInfo);
              return;
            case Me:
              ve.add(Re.stateNode.containerInfo);
              return;
          }
          if (Re.return === null)
            throw new Error("Expected to reach root first.");
          Re = Re.return;
        }
      }
    }
    function aM(me, ve) {
      for (var Ce = me, Re = !1; ; ) {
        if (Ce.tag === ze)
          Re = !0, ve.add(Ce.stateNode);
        else if (Ce.child !== null) {
          Ce.child.return = Ce, Ce = Ce.child;
          continue;
        }
        if (Ce === me)
          return Re;
        for (; Ce.sibling === null; ) {
          if (Ce.return === null || Ce.return === me)
            return Re;
          Ce = Ce.return;
        }
        Ce.sibling.return = Ce.return, Ce = Ce.sibling;
      }
      return !1;
    }
    var $E;
    {
      $E = !1;
      try {
        var YM = Object.preventExtensions({});
      } catch {
        $E = !0;
      }
    }
    function iM(me, ve, Ce, Re) {
      this.tag = me, this.key = Ce, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = ve, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = Re, this.flags = hr, this.subtreeFlags = hr, this.deletions = null, this.lanes = vn, this.childLanes = vn, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !$E && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var bu = function(me, ve, Ce, Re) {
      return new iM(me, ve, Ce, Re);
    };
    function RE(me) {
      var ve = me.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function sM(me) {
      return typeof me == "function" && !RE(me) && me.defaultProps === void 0;
    }
    function uM(me) {
      if (typeof me == "function")
        return RE(me) ? $e : Ie;
      if (me != null) {
        var ve = me.$$typeof;
        if (ve === ar)
          return ot;
        if (ve === Lr)
          return wt;
      }
      return Ne;
    }
    function em(me, ve) {
      var Ce = me.alternate;
      Ce === null ? (Ce = bu(me.tag, ve, me.key, me.mode), Ce.elementType = me.elementType, Ce.type = me.type, Ce.stateNode = me.stateNode, Ce._debugSource = me._debugSource, Ce._debugOwner = me._debugOwner, Ce._debugHookTypes = me._debugHookTypes, Ce.alternate = me, me.alternate = Ce) : (Ce.pendingProps = ve, Ce.type = me.type, Ce.flags = hr, Ce.subtreeFlags = hr, Ce.deletions = null, Ce.actualDuration = 0, Ce.actualStartTime = -1), Ce.flags = me.flags & ci, Ce.childLanes = me.childLanes, Ce.lanes = me.lanes, Ce.child = me.child, Ce.memoizedProps = me.memoizedProps, Ce.memoizedState = me.memoizedState, Ce.updateQueue = me.updateQueue;
      var Re = me.dependencies;
      switch (Ce.dependencies = Re === null ? null : { lanes: Re.lanes, firstContext: Re.firstContext }, Ce.sibling = me.sibling, Ce.index = me.index, Ce.ref = me.ref, Ce.selfBaseDuration = me.selfBaseDuration, Ce.treeBaseDuration = me.treeBaseDuration, Ce._debugNeedsRemount = me._debugNeedsRemount, Ce.tag) {
        case Ne:
        case Ie:
        case gt:
          Ce.type = Zy(me.type);
          break;
        case $e:
          Ce.type = OE(me.type);
          break;
        case ot:
          Ce.type = AE(me.type);
          break;
      }
      return Ce;
    }
    function lM(me, ve) {
      me.flags &= ci | Lo;
      var Ce = me.alternate;
      if (Ce === null)
        me.childLanes = vn, me.lanes = ve, me.child = null, me.subtreeFlags = hr, me.memoizedProps = null, me.memoizedState = null, me.updateQueue = null, me.dependencies = null, me.stateNode = null, me.selfBaseDuration = 0, me.treeBaseDuration = 0;
      else {
        me.childLanes = Ce.childLanes, me.lanes = Ce.lanes, me.child = Ce.child, me.subtreeFlags = hr, me.deletions = null, me.memoizedProps = Ce.memoizedProps, me.memoizedState = Ce.memoizedState, me.updateQueue = Ce.updateQueue, me.type = Ce.type;
        var Re = Ce.dependencies;
        me.dependencies = Re === null ? null : { lanes: Re.lanes, firstContext: Re.firstContext }, me.selfBaseDuration = Ce.selfBaseDuration, me.treeBaseDuration = Ce.treeBaseDuration;
      }
      return me;
    }
    function cM(me, ve, Ce) {
      var Re;
      return me === I0 ? (Re = Vr, ve === !0 && (Re |= ta, Re |= Qs)) : Re = vr, di && (Re |= xr), bu(Me, null, null, Re);
    }
    function NE(me, ve, Ce, Re, De, Ue) {
      var Ye = Ne, et = me;
      if (typeof me == "function")
        RE(me) ? (Ye = $e, et = OE(et)) : et = Zy(et);
      else if (typeof me == "string")
        Ye = ze;
      else
        e:
          switch (me) {
            case aa:
              return Gf(Ce.children, De, Ue, ve);
            case ni:
              Ye = qe, De |= ta, (De & Vr) !== vr && (De |= Qs);
              break;
            case Ot:
              return dM(Ce, De, Ue, ve);
            case Rr:
              return fM(Ce, De, Ue, ve);
            case Wr:
              return pM(Ce, De, Ue, ve);
            case So:
              return P2(Ce, De, Ue, ve);
            case Ca:
            case sa:
            case zs:
            case Ol:
            case Eo:
            default: {
              if (typeof me == "object" && me !== null)
                switch (me.$$typeof) {
                  case En:
                    Ye = Xe;
                    break e;
                  case An:
                    Ye = tt;
                    break e;
                  case ar:
                    Ye = ot, et = AE(et);
                    break e;
                  case Lr:
                    Ye = wt;
                    break e;
                  case fr:
                    Ye = It, et = null;
                    break e;
                }
              var at = "";
              {
                (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (at += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var yt = Re ? Ar(Re) : null;
                yt && (at += `

Check the render method of \`` + yt + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (me == null ? me : typeof me) + "." + at));
            }
          }
      var bt = bu(Ye, Ce, ve, De);
      return bt.elementType = me, bt.type = et, bt.lanes = Ue, bt._debugOwner = Re, bt;
    }
    function ME(me, ve, Ce) {
      var Re = null;
      Re = me._owner;
      var De = me.type, Ue = me.key, Ye = me.props, et = NE(De, Ue, Ye, Re, ve, Ce);
      return et._debugSource = me._source, et._debugOwner = me._owner, et;
    }
    function Gf(me, ve, Ce, Re) {
      var De = bu(Ze, me, Re, ve);
      return De.lanes = Ce, De;
    }
    function dM(me, ve, Ce, Re) {
      typeof me.id != "string" && _e('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof me.id);
      var De = bu(pt, me, Re, ve | xr);
      return De.elementType = Ot, De.lanes = Ce, De.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, De;
    }
    function fM(me, ve, Ce, Re) {
      var De = bu(ht, me, Re, ve);
      return De.elementType = Rr, De.lanes = Ce, De;
    }
    function pM(me, ve, Ce, Re) {
      var De = bu(on, me, Re, ve);
      return De.elementType = Wr, De.lanes = Ce, De;
    }
    function P2(me, ve, Ce, Re) {
      var De = bu(wn, me, Re, ve);
      De.elementType = So, De.lanes = Ce;
      var Ue = { isHidden: !1 };
      return De.stateNode = Ue, De;
    }
    function jE(me, ve, Ce) {
      var Re = bu(He, me, null, ve);
      return Re.lanes = Ce, Re;
    }
    function hM() {
      var me = bu(ze, null, null, vr);
      return me.elementType = "DELETED", me;
    }
    function mM(me) {
      var ve = bu(Ft, null, null, vr);
      return ve.stateNode = me, ve;
    }
    function LE(me, ve, Ce) {
      var Re = me.children !== null ? me.children : [], De = bu(Be, Re, me.key, ve);
      return De.lanes = Ce, De.stateNode = { containerInfo: me.containerInfo, pendingChildren: null, implementation: me.implementation }, De;
    }
    function k2(me, ve) {
      return me === null && (me = bu(Ne, null, null, vr)), me.tag = ve.tag, me.key = ve.key, me.elementType = ve.elementType, me.type = ve.type, me.stateNode = ve.stateNode, me.return = ve.return, me.child = ve.child, me.sibling = ve.sibling, me.index = ve.index, me.ref = ve.ref, me.pendingProps = ve.pendingProps, me.memoizedProps = ve.memoizedProps, me.updateQueue = ve.updateQueue, me.memoizedState = ve.memoizedState, me.dependencies = ve.dependencies, me.mode = ve.mode, me.flags = ve.flags, me.subtreeFlags = ve.subtreeFlags, me.deletions = ve.deletions, me.lanes = ve.lanes, me.childLanes = ve.childLanes, me.alternate = ve.alternate, me.actualDuration = ve.actualDuration, me.actualStartTime = ve.actualStartTime, me.selfBaseDuration = ve.selfBaseDuration, me.treeBaseDuration = ve.treeBaseDuration, me._debugSource = ve._debugSource, me._debugOwner = ve._debugOwner, me._debugNeedsRemount = ve._debugNeedsRemount, me._debugHookTypes = ve._debugHookTypes, me;
    }
    function yM(me, ve, Ce, Re, De) {
      this.tag = ve, this.containerInfo = me, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = K_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = oo, this.eventTimes = Gm(vn), this.expirationTimes = Gm(Co), this.pendingLanes = vn, this.suspendedLanes = vn, this.pingedLanes = vn, this.expiredLanes = vn, this.mutableReadLanes = vn, this.finishedLanes = vn, this.entangledLanes = vn, this.entanglements = Gm(vn), this.identifierPrefix = Re, this.onRecoverableError = De, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var Ue = this.pendingUpdatersLaneMap = [], Ye = 0; Ye < Fo; Ye++)
          Ue.push(/* @__PURE__ */ new Set());
      }
      switch (ve) {
        case I0:
          this._debugRootType = Ce ? "hydrateRoot()" : "createRoot()";
          break;
        case Mf:
          this._debugRootType = Ce ? "hydrate()" : "render()";
          break;
      }
    }
    function T2(me, ve, Ce, Re, De, Ue, Ye, et, at, yt) {
      var bt = new yM(me, ve, Ce, et, at), Ut = cM(ve, Ue);
      bt.current = Ut, Ut.stateNode = bt;
      {
        var jt = { element: Re, isDehydrated: Ce, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        Ut.memoizedState = jt;
      }
      return S1(Ut), bt;
    }
    var DE = "18.2.0";
    function bM(me, ve, Ce) {
      var Re = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Ho(Re), { $$typeof: vo, key: Re == null ? null : "" + Re, children: me, containerInfo: ve, implementation: Ce };
    }
    var BE, FE;
    BE = !1, FE = {};
    function O2(me) {
      if (!me)
        return yu;
      var ve = Zs(me), Ce = UC(ve);
      if (ve.tag === $e) {
        var Re = ve.type;
        if (Ac(Re))
          return RS(ve, Re, Ce);
      }
      return Ce;
    }
    function vM(me, ve) {
      {
        var Ce = Zs(me);
        if (Ce === void 0) {
          if (typeof me.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var Re = Object.keys(me).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + Re);
        }
        var De = Ys(Ce);
        if (De === null)
          return null;
        if (De.mode & ta) {
          var Ue = Ar(Ce) || "Component";
          if (!FE[Ue]) {
            FE[Ue] = !0;
            var Ye = Zo;
            try {
              lo(De), Ce.mode & ta ? _e("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ve, ve, Ue) : _e("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ve, ve, Ue);
            } finally {
              Ye ? lo(Ye) : Ko();
            }
          }
        }
        return De.stateNode;
      }
    }
    function A2(me, ve, Ce, Re, De, Ue, Ye, et) {
      var at = !1, yt = null;
      return T2(me, ve, at, yt, Ce, Re, De, Ue, Ye);
    }
    function C2(me, ve, Ce, Re, De, Ue, Ye, et, at, yt) {
      var bt = !0, Ut = T2(Ce, Re, bt, me, De, Ue, Ye, et, at);
      Ut.context = O2(null);
      var jt = Ut.current, tn = Ds(), nn = qf(jt), bn = Ud(tn, nn);
      return bn.callback = ve ?? null, Df(jt, bn, nn), PN(Ut, nn, tn), Ut;
    }
    function Vv(me, ve, Ce, Re) {
      Sg(ve, me);
      var De = ve.current, Ue = Ds(), Ye = qf(De);
      ad(Ye);
      var et = O2(Ce);
      ve.context === null ? ve.context = et : ve.pendingContext = et, ii && Zo !== null && !BE && (BE = !0, _e(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ar(Zo) || "Unknown"));
      var at = Ud(Ue, Ye);
      at.payload = { element: me }, Re = Re === void 0 ? null : Re, Re !== null && (typeof Re != "function" && _e("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", Re), at.callback = Re);
      var yt = Df(De, at, Ye);
      return yt !== null && (Ei(yt, De, Ye, Ue), X0(yt, De, Ye)), Ye;
    }
    function qw(me) {
      var ve = me.current;
      if (!ve.child)
        return null;
      switch (ve.child.tag) {
        case ze:
          return ve.child.stateNode;
        default:
          return ve.child.stateNode;
      }
    }
    function gM(me) {
      switch (me.tag) {
        case Me: {
          var ve = me.stateNode;
          if (Pd(ve)) {
            var Ce = g_(ve);
            AN(ve, Ce);
          }
          break;
        }
        case ht: {
          qd(function() {
            var De = ru(me, kr);
            if (De !== null) {
              var Ue = Ds();
              Ei(De, me, kr, Ue);
            }
          });
          var Re = kr;
          zE(me, Re);
          break;
        }
      }
    }
    function I2(me, ve) {
      var Ce = me.memoizedState;
      Ce !== null && Ce.dehydrated !== null && (Ce.retryLane = Rb(Ce.retryLane, ve));
    }
    function zE(me, ve) {
      I2(me, ve);
      var Ce = me.alternate;
      Ce && I2(Ce, ve);
    }
    function wM(me) {
      if (me.tag === ht) {
        var ve = mf, Ce = ru(me, ve);
        if (Ce !== null) {
          var Re = Ds();
          Ei(Ce, me, ve, Re);
        }
        zE(me, ve);
      }
    }
    function _M(me) {
      if (me.tag === ht) {
        var ve = qf(me), Ce = ru(me, ve);
        if (Ce !== null) {
          var Re = Ds();
          Ei(Ce, me, ve, Re);
        }
        zE(me, ve);
      }
    }
    function $2(me) {
      var ve = _g(me);
      return ve === null ? null : ve.stateNode;
    }
    var R2 = function(me) {
      return null;
    };
    function xM(me) {
      return R2(me);
    }
    var N2 = function(me) {
      return !1;
    };
    function EM(me) {
      return N2(me);
    }
    var M2 = null, j2 = null, L2 = null, D2 = null, B2 = null, F2 = null, z2 = null, U2 = null, V2 = null;
    {
      var H2 = function(me, ve, Ce) {
        var Re = ve[Ce], De = Jo(me) ? me.slice() : zr({}, me);
        return Ce + 1 === ve.length ? (Jo(De) ? De.splice(Re, 1) : delete De[Re], De) : (De[Re] = H2(me[Re], ve, Ce + 1), De);
      }, Z2 = function(me, ve) {
        return H2(me, ve, 0);
      }, q2 = function(me, ve, Ce, Re) {
        var De = ve[Re], Ue = Jo(me) ? me.slice() : zr({}, me);
        if (Re + 1 === ve.length) {
          var Ye = Ce[Re];
          Ue[Ye] = Ue[De], Jo(Ue) ? Ue.splice(De, 1) : delete Ue[De];
        } else
          Ue[De] = q2(me[De], ve, Ce, Re + 1);
        return Ue;
      }, W2 = function(me, ve, Ce) {
        if (ve.length !== Ce.length) {
          we("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var Re = 0; Re < Ce.length - 1; Re++)
            if (ve[Re] !== Ce[Re]) {
              we("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return q2(me, ve, Ce, 0);
      }, G2 = function(me, ve, Ce, Re) {
        if (Ce >= ve.length)
          return Re;
        var De = ve[Ce], Ue = Jo(me) ? me.slice() : zr({}, me);
        return Ue[De] = G2(me[De], ve, Ce + 1, Re), Ue;
      }, Y2 = function(me, ve, Ce) {
        return G2(me, ve, 0, Ce);
      }, UE = function(me, ve) {
        for (var Ce = me.memoizedState; Ce !== null && ve > 0; )
          Ce = Ce.next, ve--;
        return Ce;
      };
      M2 = function(me, ve, Ce, Re) {
        var De = UE(me, ve);
        if (De !== null) {
          var Ue = Y2(De.memoizedState, Ce, Re);
          De.memoizedState = Ue, De.baseState = Ue, me.memoizedProps = zr({}, me.memoizedProps);
          var Ye = ru(me, kr);
          Ye !== null && Ei(Ye, me, kr, Co);
        }
      }, j2 = function(me, ve, Ce) {
        var Re = UE(me, ve);
        if (Re !== null) {
          var De = Z2(Re.memoizedState, Ce);
          Re.memoizedState = De, Re.baseState = De, me.memoizedProps = zr({}, me.memoizedProps);
          var Ue = ru(me, kr);
          Ue !== null && Ei(Ue, me, kr, Co);
        }
      }, L2 = function(me, ve, Ce, Re) {
        var De = UE(me, ve);
        if (De !== null) {
          var Ue = W2(De.memoizedState, Ce, Re);
          De.memoizedState = Ue, De.baseState = Ue, me.memoizedProps = zr({}, me.memoizedProps);
          var Ye = ru(me, kr);
          Ye !== null && Ei(Ye, me, kr, Co);
        }
      }, D2 = function(me, ve, Ce) {
        me.pendingProps = Y2(me.memoizedProps, ve, Ce), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Re = ru(me, kr);
        Re !== null && Ei(Re, me, kr, Co);
      }, B2 = function(me, ve) {
        me.pendingProps = Z2(me.memoizedProps, ve), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Ce = ru(me, kr);
        Ce !== null && Ei(Ce, me, kr, Co);
      }, F2 = function(me, ve, Ce) {
        me.pendingProps = W2(me.memoizedProps, ve, Ce), me.alternate && (me.alternate.pendingProps = me.pendingProps);
        var Re = ru(me, kr);
        Re !== null && Ei(Re, me, kr, Co);
      }, z2 = function(me) {
        var ve = ru(me, kr);
        ve !== null && Ei(ve, me, kr, Co);
      }, U2 = function(me) {
        R2 = me;
      }, V2 = function(me) {
        N2 = me;
      };
    }
    function SM(me) {
      var ve = Ys(me);
      return ve === null ? null : ve.stateNode;
    }
    function PM(me) {
      return null;
    }
    function kM() {
      return Zo;
    }
    function TM(me) {
      var ve = me.findFiberByHostInstance, Ce = fe.ReactCurrentDispatcher;
      return xb({ bundleType: me.bundleType, version: me.version, rendererPackageName: me.rendererPackageName, rendererConfig: me.rendererConfig, overrideHookState: M2, overrideHookStateDeletePath: j2, overrideHookStateRenamePath: L2, overrideProps: D2, overridePropsDeletePath: B2, overridePropsRenamePath: F2, setErrorHandler: U2, setSuspenseHandler: V2, scheduleUpdate: z2, currentDispatcherRef: Ce, findHostInstanceByFiber: SM, findFiberByHostInstance: ve || PM, findHostInstancesForRefresh: rM, scheduleRefresh: tM, scheduleRoot: nM, setRefreshHandler: eM, getCurrentFiber: kM, reconcilerVersion: DE });
    }
    var Q2 = typeof reportError == "function" ? reportError : function(me) {
      console.error(me);
    };
    function VE(me) {
      this._internalRoot = me;
    }
    Ww.prototype.render = VE.prototype.render = function(me) {
      var ve = this._internalRoot;
      if (ve === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? _e("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Yw(arguments[1]) ? _e("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && _e("You passed a second argument to root.render(...) but it only accepts one argument.");
        var Ce = ve.containerInfo;
        if (Ce.nodeType !== Pa) {
          var Re = $2(ve.current);
          Re && Re.parentNode !== Ce && _e("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Vv(me, ve, null, null);
    }, Ww.prototype.unmount = VE.prototype.unmount = function() {
      typeof arguments[0] == "function" && _e("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var me = this._internalRoot;
      if (me !== null) {
        this._internalRoot = null;
        var ve = me.containerInfo;
        u2() && _e("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), qd(function() {
          Vv(null, me, null, null);
        }), kS(ve);
      }
    };
    function OM(me, ve) {
      if (!Yw(me))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      K2(me);
      var Ce = !1, Re = !1, De = "", Ue = Q2;
      ve != null && (ve.hydrate ? we("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof ve == "object" && ve !== null && ve.$$typeof === Jr && _e(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), ve.unstable_strictMode === !0 && (Ce = !0), ve.identifierPrefix !== void 0 && (De = ve.identifierPrefix), ve.onRecoverableError !== void 0 && (Ue = ve.onRecoverableError), ve.transitionCallbacks !== void 0 && ve.transitionCallbacks);
      var Ye = A2(me, I0, null, Ce, Re, De, Ue);
      w0(Ye.current, me);
      var et = me.nodeType === Pa ? me.parentNode : me;
      return Xb(et), new VE(Ye);
    }
    function Ww(me) {
      this._internalRoot = me;
    }
    function AM(me) {
      me && Hg(me);
    }
    Ww.prototype.unstable_scheduleHydration = AM;
    function CM(me, ve, Ce) {
      if (!Yw(me))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      K2(me), ve === void 0 && _e("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var Re = Ce ?? null, De = Ce != null && Ce.hydratedSources || null, Ue = !1, Ye = !1, et = "", at = Q2;
      Ce != null && (Ce.unstable_strictMode === !0 && (Ue = !0), Ce.identifierPrefix !== void 0 && (et = Ce.identifierPrefix), Ce.onRecoverableError !== void 0 && (at = Ce.onRecoverableError));
      var yt = C2(ve, null, me, I0, Re, Ue, Ye, et, at);
      if (w0(yt.current, me), Xb(me), De)
        for (var bt = 0; bt < De.length; bt++) {
          var Ut = De[bt];
          BI(yt, Ut);
        }
      return new Ww(yt);
    }
    function Yw(me) {
      return !!(me && (me.nodeType === ts || me.nodeType === cu || me.nodeType === Kc || !Yn));
    }
    function Hv(me) {
      return !!(me && (me.nodeType === ts || me.nodeType === cu || me.nodeType === Kc || me.nodeType === Pa && me.nodeValue === " react-mount-point-unstable "));
    }
    function K2(me) {
      me.nodeType === ts && me.tagName && me.tagName.toUpperCase() === "BODY" && _e("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), lv(me) && (me._reactRootContainer ? _e("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : _e("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var IM = fe.ReactCurrentOwner, X2;
    X2 = function(me) {
      if (me._reactRootContainer && me.nodeType !== Pa) {
        var ve = $2(me._reactRootContainer.current);
        ve && ve.parentNode !== me && _e("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var Ce = !!me._reactRootContainer, Re = HE(me), De = !!(Re && Rf(Re));
      De && !Ce && _e("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), me.nodeType === ts && me.tagName && me.tagName.toUpperCase() === "BODY" && _e("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function HE(me) {
      return me ? me.nodeType === cu ? me.documentElement : me.firstChild : null;
    }
    function J2() {
    }
    function $M(me, ve, Ce, Re, De) {
      if (De) {
        if (typeof Re == "function") {
          var Ue = Re;
          Re = function() {
            var jt = qw(Ye);
            Ue.call(jt);
          };
        }
        var Ye = C2(ve, Re, me, Mf, null, !1, !1, "", J2);
        me._reactRootContainer = Ye, w0(Ye.current, me);
        var et = me.nodeType === Pa ? me.parentNode : me;
        return Xb(et), qd(), Ye;
      } else {
        for (var at; at = me.lastChild; )
          me.removeChild(at);
        if (typeof Re == "function") {
          var yt = Re;
          Re = function() {
            var jt = qw(bt);
            yt.call(jt);
          };
        }
        var bt = A2(me, Mf, null, !1, !1, "", J2);
        me._reactRootContainer = bt, w0(bt.current, me);
        var Ut = me.nodeType === Pa ? me.parentNode : me;
        return Xb(Ut), qd(function() {
          Vv(ve, bt, Ce, Re);
        }), bt;
      }
    }
    function RM(me, ve) {
      me !== null && typeof me != "function" && _e("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve, me);
    }
    function e_(me, ve, Ce, Re, De) {
      X2(Ce), RM(De === void 0 ? null : De, "render");
      var Ue = Ce._reactRootContainer, Ye;
      if (!Ue)
        Ye = $M(Ce, ve, me, De, Re);
      else {
        if (Ye = Ue, typeof De == "function") {
          var et = De;
          De = function() {
            var at = qw(Ye);
            et.call(at);
          };
        }
        Vv(ve, Ye, me, De);
      }
      return qw(Ye);
    }
    function NM(me) {
      {
        var ve = IM.current;
        if (ve !== null && ve.stateNode !== null) {
          var Ce = ve.stateNode._warnedAboutRefsInRender;
          Ce || _e("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", uo(ve.type) || "A component"), ve.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return me == null ? null : me.nodeType === ts ? me : vM(me, "findDOMNode");
    }
    function MM(me, ve, Ce) {
      if (_e("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hv(ve))
        throw new Error("Target container is not a DOM element.");
      {
        var Re = lv(ve) && ve._reactRootContainer === void 0;
        Re && _e("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return e_(null, me, ve, !0, Ce);
    }
    function jM(me, ve, Ce) {
      if (_e("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hv(ve))
        throw new Error("Target container is not a DOM element.");
      {
        var Re = lv(ve) && ve._reactRootContainer === void 0;
        Re && _e("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return e_(null, me, ve, !1, Ce);
    }
    function LM(me, ve, Ce, Re) {
      if (_e("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hv(Ce))
        throw new Error("Target container is not a DOM element.");
      if (me == null || !gp(me))
        throw new Error("parentComponent must be a valid React Component");
      return e_(me, ve, Ce, !1, Re);
    }
    function DM(me) {
      if (!Hv(me))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var ve = lv(me) && me._reactRootContainer === void 0;
        ve && _e("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (me._reactRootContainer) {
        {
          var Ce = HE(me), Re = Ce && !Rf(Ce);
          Re && _e("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return qd(function() {
          e_(null, null, me, !1, function() {
            me._reactRootContainer = null, kS(me);
          });
        }), !0;
      } else {
        {
          var De = HE(me), Ue = !!(De && Rf(De)), Ye = me.nodeType === ts && Hv(me.parentNode) && !!me.parentNode._reactRootContainer;
          Ue && _e("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", Ye ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    x_(gM), Bg(wM), E_(_M), ty($s), Fg(Lg), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && _e("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), vg(FO), hm(_E, CN, qd);
    function BM(me, ve) {
      var Ce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Yw(ve))
        throw new Error("Target container is not a DOM element.");
      return bM(me, ve, null, Ce);
    }
    function FM(me, ve, Ce, Re) {
      return LM(me, ve, Ce, Re);
    }
    var ZE = { usingClientEntryPoint: !1, Events: [Rf, xy, _0, pm, mp, _E] };
    function zM(me, ve) {
      return ZE.usingClientEntryPoint || _e('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), OM(me, ve);
    }
    function UM(me, ve, Ce) {
      return ZE.usingClientEntryPoint || _e('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), CM(me, ve, Ce);
    }
    function VM(me) {
      return u2() && _e("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), qd(me);
    }
    var HM = TM({ findFiberByHostInstance: Gp, bundleType: 1, version: DE, rendererPackageName: "react-dom" });
    if (!HM && Kr && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var eO = window.location.protocol;
      /^(https?|file):$/.test(eO) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (eO === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ZE, ne.createPortal = BM, ne.createRoot = zM, ne.findDOMNode = NM, ne.flushSync = VM, ne.hydrate = MM, ne.hydrateRoot = UM, ne.render = jM, ne.unmountComponentAtNode = DM, ne.unstable_batchedUpdates = _E, ne.unstable_renderSubtreeIntoContainer = FM, ne.version = DE, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
}), gz = M((ne, oe) => {
  function ae() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ae);
      } catch (fe) {
        console.error(fe);
      }
    }
  }
  process.env.NODE_ENV === "production" ? (ae(), oe.exports = mz()) : oe.exports = hz();
}), bz = M((ne) => {
  var oe = gz();
  process.env.NODE_ENV === "production" ? (ne.createRoot = oe.createRoot, ne.hydrateRoot = oe.hydrateRoot) : (ae = oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ne.createRoot = function(fe, ye) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.createRoot(fe, ye);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  }, ne.hydrateRoot = function(fe, ye, ge) {
    ae.usingClientEntryPoint = !0;
    try {
      return oe.hydrateRoot(fe, ye, ge);
    } finally {
      ae.usingClientEntryPoint = !1;
    }
  });
  var ae;
});
function Xm(ne, { insertAt: oe } = {}) {
  if (!ne || typeof document > "u")
    return;
  let ae = document.head || document.getElementsByTagName("head")[0], fe = document.createElement("style");
  fe.type = "text/css", oe === "top" && ae.firstChild ? ae.insertBefore(fe, ae.firstChild) : ae.appendChild(fe), fe.styleSheet ? fe.styleSheet.cssText = ne : fe.appendChild(document.createTextNode(ne));
}
var ek = Y(() => {
}), Sz = Y(() => {
  ek(), Xm(`#mud-dev-tools{all:initial}#mud-dev-tools *,#mud-dev-tools :before,#mud-dev-tools :after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}#mud-dev-tools :before,#mud-dev-tools :after{--tw-content: ""}#mud-dev-tools{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}#mud-dev-tools{margin:0;line-height:inherit}#mud-dev-tools hr{height:0;color:inherit;border-top-width:1px}#mud-dev-tools abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6{font-size:inherit;font-weight:inherit}#mud-dev-tools a{color:inherit;text-decoration:inherit}#mud-dev-tools b,#mud-dev-tools strong{font-weight:bolder}#mud-dev-tools code,#mud-dev-tools kbd,#mud-dev-tools samp,#mud-dev-tools pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}#mud-dev-tools small{font-size:80%}#mud-dev-tools sub,#mud-dev-tools sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#mud-dev-tools sub{bottom:-.25em}#mud-dev-tools sup{top:-.5em}#mud-dev-tools table{text-indent:0;border-color:inherit;border-collapse:collapse}#mud-dev-tools button,#mud-dev-tools input,#mud-dev-tools optgroup,#mud-dev-tools select,#mud-dev-tools textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}#mud-dev-tools button,#mud-dev-tools select{text-transform:none}#mud-dev-tools button,#mud-dev-tools [type=button],#mud-dev-tools [type=reset],#mud-dev-tools [type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}#mud-dev-tools :-moz-focusring{outline:auto}#mud-dev-tools :-moz-ui-invalid{box-shadow:none}#mud-dev-tools progress{vertical-align:baseline}#mud-dev-tools ::-webkit-inner-spin-button,#mud-dev-tools ::-webkit-outer-spin-button{height:auto}#mud-dev-tools [type=search]{-webkit-appearance:textfield;outline-offset:-2px}#mud-dev-tools ::-webkit-search-decoration{-webkit-appearance:none}#mud-dev-tools ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}#mud-dev-tools summary{display:list-item}#mud-dev-tools blockquote,#mud-dev-tools dl,#mud-dev-tools dd,#mud-dev-tools h1,#mud-dev-tools h2,#mud-dev-tools h3,#mud-dev-tools h4,#mud-dev-tools h5,#mud-dev-tools h6,#mud-dev-tools hr,#mud-dev-tools figure,#mud-dev-tools p,#mud-dev-tools pre{margin:0}#mud-dev-tools fieldset{margin:0;padding:0}#mud-dev-tools legend{padding:0}#mud-dev-tools ol,#mud-dev-tools ul,#mud-dev-tools menu{list-style:none;margin:0;padding:0}#mud-dev-tools textarea{resize:vertical}#mud-dev-tools input::-moz-placeholder,#mud-dev-tools textarea::-moz-placeholder{opacity:1;color:#9ca3af}#mud-dev-tools input::placeholder,#mud-dev-tools textarea::placeholder{opacity:1;color:#9ca3af}#mud-dev-tools button,#mud-dev-tools [role=button]{cursor:pointer}#mud-dev-tools :disabled{cursor:default}#mud-dev-tools img,#mud-dev-tools svg,#mud-dev-tools video,#mud-dev-tools canvas,#mud-dev-tools audio,#mud-dev-tools iframe,#mud-dev-tools embed,#mud-dev-tools object{display:block;vertical-align:middle}#mud-dev-tools img,#mud-dev-tools video{max-width:100%;height:auto}#mud-dev-tools [hidden]{display:none}
`);
}), _z = Y(() => {
  ek(), Xm(`*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }#mud-dev-tools :is(.pointer-events-none){pointer-events:none}#mud-dev-tools :is(.pointer-events-auto){pointer-events:auto}#mud-dev-tools :is(.fixed){position:fixed}#mud-dev-tools :is(.absolute){position:absolute}#mud-dev-tools :is(.relative){position:relative}#mud-dev-tools :is(.sticky){position:sticky}#mud-dev-tools :is(.inset-0){inset:0}#mud-dev-tools :is(.bottom-0){bottom:0}#mud-dev-tools :is(.left-0){left:0}#mud-dev-tools :is(.right-0){right:0}#mud-dev-tools :is(.right-full){right:100%}#mud-dev-tools :is(.top-0){top:0}#mud-dev-tools :is(.top-1){top:.25rem}#mud-dev-tools :is(.z-10){z-index:10}#mud-dev-tools :is(.z-20){z-index:20}#mud-dev-tools :is(.m-2){margin:.5rem}#mud-dev-tools :is(.-mx-1){margin-left:-.25rem;margin-right:-.25rem}#mud-dev-tools :is(.block){display:block}#mud-dev-tools :is(.flex){display:flex}#mud-dev-tools :is(.inline-flex){display:inline-flex}#mud-dev-tools :is(.\\!table){display:table!important}#mud-dev-tools :is(.table){display:table}#mud-dev-tools :is(.grid){display:grid}#mud-dev-tools :is(.hidden){display:none}#mud-dev-tools :is(.h-4){height:1rem}#mud-dev-tools :is(.h-\\[1em\\]){height:1em}#mud-dev-tools :is(.h-full){height:100%}#mud-dev-tools :is(.w-2\\/12){width:16.666667%}#mud-dev-tools :is(.w-3\\/12){width:25%}#mud-dev-tools :is(.w-4){width:1rem}#mud-dev-tools :is(.w-\\[1em\\]){width:1em}#mud-dev-tools :is(.w-full){width:100%}#mud-dev-tools :is(.min-w-max){min-width:max-content}#mud-dev-tools :is(.max-w-screen-sm){max-width:640px}#mud-dev-tools :is(.flex-1){flex:1 1 0%}#mud-dev-tools :is(.flex-none){flex:none}#mud-dev-tools :is(.flex-grow){flex-grow:1}#mud-dev-tools :is(.table-fixed){table-layout:fixed}#mud-dev-tools :is(.translate-x-0){--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}#mud-dev-tools :is(.translate-x-full){--tw-translate-x: 100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}#mud-dev-tools :is(.animate-spin){animation:spin 1s linear infinite}#mud-dev-tools :is(.cursor-default){cursor:default}#mud-dev-tools :is(.cursor-pointer){cursor:pointer}#mud-dev-tools :is(.select-none){-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.grid-cols-\\[max-content\\,1fr\\]){grid-template-columns:max-content 1fr}#mud-dev-tools :is(.flex-col){flex-direction:column}#mud-dev-tools :is(.flex-col-reverse){flex-direction:column-reverse}#mud-dev-tools :is(.items-start){align-items:flex-start}#mud-dev-tools :is(.items-end){align-items:flex-end}#mud-dev-tools :is(.items-center){align-items:center}#mud-dev-tools :is(.justify-center){justify-content:center}#mud-dev-tools :is(.gap-1){gap:.25rem}#mud-dev-tools :is(.gap-2){gap:.5rem}#mud-dev-tools :is(.gap-x-4){column-gap:1rem}#mud-dev-tools :is(.space-y-1 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-2 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-4 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-6 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.space-y-8 > :not([hidden]) ~ :not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(2rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(2rem * var(--tw-space-y-reverse))}#mud-dev-tools :is(.overflow-auto){overflow:auto}#mud-dev-tools :is(.overflow-hidden){overflow:hidden}#mud-dev-tools :is(.text-ellipsis){text-overflow:ellipsis}#mud-dev-tools :is(.whitespace-nowrap){white-space:nowrap}#mud-dev-tools :is(.whitespace-pre){white-space:pre}#mud-dev-tools :is(.rounded){border-radius:.25rem}#mud-dev-tools :is(.border-2){border-width:2px}#mud-dev-tools :is(.border-dashed){border-style:dashed}#mud-dev-tools :is(.border-transparent){border-color:transparent}#mud-dev-tools :is(.border-white\\/10){border-color:#ffffff1a}#mud-dev-tools :is(.border-white\\/20){border-color:#fff3}#mud-dev-tools :is(.bg-gray-500\\/10){background-color:#6b72801a}#mud-dev-tools :is(.bg-red-800){--tw-bg-opacity: 1;background-color:rgb(153 27 27 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-red-900\\/50){background-color:#7f1d1d80}#mud-dev-tools :is(.bg-slate-600){--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-700){--tw-bg-opacity: 1;background-color:rgb(51 65 85 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-800){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-slate-900){--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}#mud-dev-tools :is(.bg-white\\/5){background-color:#ffffff0d}#mud-dev-tools :is(.p-1){padding:.25rem}#mud-dev-tools :is(.p-2){padding:.5rem}#mud-dev-tools :is(.p-4){padding:1rem}#mud-dev-tools :is(.p-6){padding:1.5rem}#mud-dev-tools :is(.px-1){padding-left:.25rem;padding-right:.25rem}#mud-dev-tools :is(.px-1\\.5){padding-left:.375rem;padding-right:.375rem}#mud-dev-tools :is(.px-2){padding-left:.5rem;padding-right:.5rem}#mud-dev-tools :is(.px-3){padding-left:.75rem;padding-right:.75rem}#mud-dev-tools :is(.py-0){padding-top:0;padding-bottom:0}#mud-dev-tools :is(.py-0\\.5){padding-top:.125rem;padding-bottom:.125rem}#mud-dev-tools :is(.py-1){padding-top:.25rem;padding-bottom:.25rem}#mud-dev-tools :is(.py-1\\.5){padding-top:.375rem;padding-bottom:.375rem}#mud-dev-tools :is(.py-2){padding-top:.5rem;padding-bottom:.5rem}#mud-dev-tools :is(.pb-0){padding-bottom:0}#mud-dev-tools :is(.pb-0\\.5){padding-bottom:.125rem}#mud-dev-tools :is(.pb-1){padding-bottom:.25rem}#mud-dev-tools :is(.pt-1){padding-top:.25rem}#mud-dev-tools :is(.pt-1\\.5){padding-top:.375rem}#mud-dev-tools :is(.text-left){text-align:left}#mud-dev-tools :is(.text-right){text-align:right}#mud-dev-tools :is(.font-mono){font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}#mud-dev-tools :is(.text-sm){font-size:.875rem;line-height:1.25rem}#mud-dev-tools :is(.text-xs){font-size:.75rem;line-height:1rem}#mud-dev-tools :is(.font-bold){font-weight:700}#mud-dev-tools :is(.font-medium){font-weight:500}#mud-dev-tools :is(.font-normal){font-weight:400}#mud-dev-tools :is(.font-semibold){font-weight:600}#mud-dev-tools :is(.uppercase){text-transform:uppercase}#mud-dev-tools :is(.leading-none){line-height:1}#mud-dev-tools :is(.tracking-\\[-1ch\\]){letter-spacing:-1ch}#mud-dev-tools :is(.text-amber-200\\/80){color:#fde68acc}#mud-dev-tools :is(.text-cyan-500){--tw-text-opacity: 1;color:rgb(6 182 212 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-gray-500){--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-green-500){--tw-text-opacity: 1;color:rgb(34 197 94 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-red-500){--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-transparent){color:transparent}#mud-dev-tools :is(.text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.text-white\\/20){color:#fff3}#mud-dev-tools :is(.text-white\\/40){color:#fff6}#mud-dev-tools :is(.text-white\\/60){color:#fff9}#mud-dev-tools :is(.text-white\\/80){color:#fffc}#mud-dev-tools :is(.underline){text-decoration-line:underline}#mud-dev-tools :is(.opacity-0){opacity:0}#mud-dev-tools :is(.opacity-100){opacity:1}#mud-dev-tools :is(.opacity-25){opacity:.25}#mud-dev-tools :is(.opacity-60){opacity:.6}#mud-dev-tools :is(.opacity-75){opacity:.75}#mud-dev-tools :is(.shadow-lg){--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}#mud-dev-tools :is(.filter){filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}#mud-dev-tools :is(.transition){transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}#mud-dev-tools :is(.duration-500){transition-duration:.5s}#mud-dev-tools :is(.after\\:select-none):after{content:var(--tw-content);-webkit-user-select:none;user-select:none}#mud-dev-tools :is(.after\\:content-\\[\\'\\2026\\'\\]):after{--tw-content: "\\2026";content:var(--tw-content)}#mud-dev-tools :is(.hover\\:bg-blue-700:hover){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:bg-blue-800:hover){--tw-bg-opacity: 1;background-color:rgb(30 64 175 / var(--tw-bg-opacity))}#mud-dev-tools :is(.hover\\:text-white:hover){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.hover\\:text-white\\/60:hover){color:#fff9}#mud-dev-tools :is(.hover\\:underline:hover){text-decoration-line:underline}#mud-dev-tools :is(.hover\\:opacity-100:hover){opacity:1}#mud-dev-tools :is(.group:hover .group-hover\\:border-blue-700){--tw-border-opacity: 1;border-color:rgb(29 78 216 / var(--tw-border-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:bg-blue-700){--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}#mud-dev-tools :is(.group:hover .group-hover\\:text-white){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#mud-dev-tools :is(.peer:hover ~ .peer-hover\\:opacity-60){opacity:.6}
`);
});
function wz() {
  for (var ne = 0, oe, ae, fe = ""; ne < arguments.length; )
    (oe = arguments[ne++]) && (ae = xz(oe)) && (fe && (fe += " "), fe += ae);
  return fe;
}
function xz(ne) {
  if (typeof ne == "string")
    return ne;
  for (var oe, ae = "", fe = 0; fe < ne.length; fe++)
    ne[fe] && (oe = xz(ne[fe])) && (ae && (ae += " "), ae += oe);
  return ae;
}
var Ez = Y(() => {
});
function Oz(ne) {
  var oe = BZ(ne), ae = ne.conflictingClassGroups, fe = ne.conflictingClassGroupModifiers, ye = fe === void 0 ? {} : fe;
  function ge(_e) {
    var Se = _e.split(rk);
    return Se[0] === "" && Se.length !== 1 && Se.shift(), Tz(Se, oe) || IZ(_e);
  }
  function we(_e, Se) {
    var Ie = ae[_e] || [];
    return Se && ye[_e] ? [].concat(Ie, ye[_e]) : Ie;
  }
  return { getClassGroupId: ge, getConflictingClassGroupIds: we };
}
function Tz(ne, oe) {
  var we;
  if (ne.length === 0)
    return oe.classGroupId;
  var ae = ne[0], fe = oe.nextPart.get(ae), ye = fe ? Tz(ne.slice(1), fe) : void 0;
  if (ye)
    return ye;
  if (oe.validators.length !== 0) {
    var ge = ne.join(rk);
    return (we = oe.validators.find(function(_e) {
      var Se = _e.validator;
      return Se(ge);
    })) == null ? void 0 : we.classGroupId;
  }
}
function IZ(ne) {
  if (Cz.test(ne)) {
    var oe = Cz.exec(ne)[1], ae = oe == null ? void 0 : oe.substring(0, oe.indexOf(":"));
    if (ae)
      return "arbitrary.." + ae;
  }
}
function BZ(ne) {
  var oe = ne.theme, ae = ne.prefix, fe = { nextPart: /* @__PURE__ */ new Map(), validators: [] }, ye = VZ(Object.entries(ne.classGroups), ae);
  return ye.forEach(function(ge) {
    var we = ge[0], _e = ge[1];
    tk(_e, fe, we, oe);
  }), fe;
}
function tk(ne, oe, ae, fe) {
  ne.forEach(function(ye) {
    if (typeof ye == "string") {
      var ge = ye === "" ? oe : Rz(oe, ye);
      ge.classGroupId = ae;
      return;
    }
    if (typeof ye == "function") {
      if (HZ(ye)) {
        tk(ye(fe), oe, ae, fe);
        return;
      }
      oe.validators.push({ validator: ye, classGroupId: ae });
      return;
    }
    Object.entries(ye).forEach(function(we) {
      var _e = we[0], Se = we[1];
      tk(Se, Rz(oe, _e), ae, fe);
    });
  });
}
function Rz(ne, oe) {
  var ae = ne;
  return oe.split(rk).forEach(function(fe) {
    ae.nextPart.has(fe) || ae.nextPart.set(fe, { nextPart: /* @__PURE__ */ new Map(), validators: [] }), ae = ae.nextPart.get(fe);
  }), ae;
}
function HZ(ne) {
  return ne.isThemeGetter;
}
function VZ(ne, oe) {
  return oe ? ne.map(function(ae) {
    var fe = ae[0], ye = ae[1], ge = ye.map(function(we) {
      return typeof we == "string" ? oe + we : typeof we == "object" ? Object.fromEntries(Object.entries(we).map(function(_e) {
        var Se = _e[0], Ie = _e[1];
        return [oe + Se, Ie];
      })) : we;
    });
    return [fe, ge];
  }) : ne;
}
var rk, Cz, kz = Y(() => {
  rk = "-", Cz = /^\[(.+)\]$/;
});
function Az(ne) {
  if (ne < 1)
    return { get: function() {
    }, set: function() {
    } };
  var oe = 0, ae = /* @__PURE__ */ new Map(), fe = /* @__PURE__ */ new Map();
  function ye(ge, we) {
    ae.set(ge, we), oe++, oe > ne && (oe = 0, fe = ae, ae = /* @__PURE__ */ new Map());
  }
  return { get: function(ge) {
    var we = ae.get(ge);
    if (we !== void 0)
      return we;
    if ((we = fe.get(ge)) !== void 0)
      return ye(ge, we), we;
  }, set: function(ge, we) {
    ae.has(ge) ? ae.set(ge, we) : ye(ge, we);
  } };
}
var Pz = Y(() => {
});
function Mz(ne) {
  var oe = ne.separator || ":", ae = oe.length === 1, fe = oe[0], ye = oe.length;
  return function(ge) {
    for (var we = [], _e = 0, Se = 0, Ie, $e = 0; $e < ge.length; $e++) {
      var Ne = ge[$e];
      if (_e === 0) {
        if (Ne === fe && (ae || ge.slice($e, $e + ye) === oe)) {
          we.push(ge.slice(Se, $e)), Se = $e + ye;
          continue;
        }
        if (Ne === "/") {
          Ie = $e;
          continue;
        }
      }
      Ne === "[" ? _e++ : Ne === "]" && _e--;
    }
    var Me = we.length === 0 ? ge : ge.substring(Se), Be = Me.startsWith(nk), ze = Be ? Me.substring(1) : Me, He = Ie && Ie > Se ? Ie - Se : void 0;
    return { modifiers: we, hasImportantModifier: Be, baseClassName: ze, maybePostfixModifierPosition: He };
  };
}
function Dz(ne) {
  if (ne.length <= 1)
    return ne;
  var oe = [], ae = [];
  return ne.forEach(function(fe) {
    var ye = fe[0] === "[";
    ye ? (oe.push.apply(oe, ae.sort().concat([fe])), ae = []) : ae.push(fe);
  }), oe.push.apply(oe, ae.sort()), oe;
}
var nk, ik = Y(() => {
  nk = "!";
});
function Nz(ne) {
  return { cache: Az(ne.cacheSize), splitModifiers: Mz(ne), ...Oz(ne) };
}
var Lz = Y(() => {
  kz(), Pz(), ik();
});
function jz(ne, oe) {
  var ae = oe.splitModifiers, fe = oe.getClassGroupId, ye = oe.getConflictingClassGroupIds, ge = /* @__PURE__ */ new Set();
  return ne.trim().split($Z).map(function(we) {
    var _e = ae(we), Se = _e.modifiers, Ie = _e.hasImportantModifier, $e = _e.baseClassName, Ne = _e.maybePostfixModifierPosition, Me = fe(Ne ? $e.substring(0, Ne) : $e), Be = !!Ne;
    if (!Me) {
      if (!Ne)
        return { isTailwindClass: !1, originalClassName: we };
      if (Me = fe($e), !Me)
        return { isTailwindClass: !1, originalClassName: we };
      Be = !1;
    }
    var ze = Dz(Se).join(":"), He = Ie ? ze + nk : ze;
    return { isTailwindClass: !0, modifierId: He, classGroupId: Me, originalClassName: we, hasPostfixModifier: Be };
  }).reverse().filter(function(we) {
    if (!we.isTailwindClass)
      return !0;
    var _e = we.modifierId, Se = we.classGroupId, Ie = we.hasPostfixModifier, $e = _e + Se;
    return ge.has($e) ? !1 : (ge.add($e), ye(Se, Ie).forEach(function(Ne) {
      return ge.add(_e + Ne);
    }), !0);
  }).reverse().map(function(we) {
    return we.originalClassName;
  }).join(" ");
}
var $Z, Uz = Y(() => {
  ik(), $Z = /\s+/;
});
function Fz() {
  for (var ne = arguments.length, oe = new Array(ne), ae = 0; ae < ne; ae++)
    oe[ae] = arguments[ae];
  var fe, ye, ge, we = _e;
  function _e(Ie) {
    var $e = oe[0], Ne = oe.slice(1), Me = Ne.reduce(function(Be, ze) {
      return ze(Be);
    }, $e());
    return fe = Nz(Me), ye = fe.cache.get, ge = fe.cache.set, we = Se, Se(Ie);
  }
  function Se(Ie) {
    var $e = ye(Ie);
    if ($e)
      return $e;
    var Ne = jz(Ie, fe);
    return ge(Ie, Ne), Ne;
  }
  return function() {
    return we(wz.apply(null, arguments));
  };
}
var zz = Y(() => {
  Lz(), Uz(), Ez();
});
function Wt(ne) {
  var oe = function(ae) {
    return ae[ne] || [];
  };
  return oe.isThemeGetter = !0, oe;
}
var qz = Y(() => {
});
function ma(ne) {
  return Ll(ne) || YZ.has(ne) || WZ.test(ne) || wu(ne);
}
function wu(ne) {
  return oc(ne, "length", XZ);
}
function Hz(ne) {
  return oc(ne, "size", Gz);
}
function Vz(ne) {
  return oc(ne, "position", Gz);
}
function $z(ne) {
  return oc(ne, "url", JZ);
}
function Jm(ne) {
  return oc(ne, "number", Ll);
}
function Ll(ne) {
  return !Number.isNaN(Number(ne));
}
function Wz(ne) {
  return ne.endsWith("%") && Ll(ne.slice(0, -1));
}
function sd(ne) {
  return Iz(ne) || oc(ne, "number", Iz);
}
function yr(ne) {
  return Bz.test(ne);
}
function cd() {
  return !0;
}
function xu(ne) {
  return GZ.test(ne);
}
function Yz(ne) {
  return oc(ne, "", ZZ);
}
function oc(ne, oe, ae) {
  var fe = Bz.exec(ne);
  return fe ? fe[1] ? fe[1] === oe : ae(fe[2]) : !1;
}
function XZ(ne) {
  return QZ.test(ne);
}
function Gz() {
  return !1;
}
function JZ(ne) {
  return ne.startsWith("url(");
}
function Iz(ne) {
  return Number.isInteger(Number(ne));
}
function ZZ(ne) {
  return KZ.test(ne);
}
var Bz, WZ, YZ, GZ, QZ, KZ, Qz = Y(() => {
  Bz = /^\[(?:([a-z-]+):)?(.+)\]$/i, WZ = /^\d+\/\d+$/, YZ = /* @__PURE__ */ new Set(["px", "full", "screen"]), GZ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, QZ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))/, KZ = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
});
function Kz() {
  var ne = Wt("colors"), oe = Wt("spacing"), ae = Wt("blur"), fe = Wt("brightness"), ye = Wt("borderColor"), ge = Wt("borderRadius"), we = Wt("borderSpacing"), _e = Wt("borderWidth"), Se = Wt("contrast"), Ie = Wt("grayscale"), $e = Wt("hueRotate"), Ne = Wt("invert"), Me = Wt("gap"), Be = Wt("gradientColorStops"), ze = Wt("gradientColorStopPositions"), He = Wt("inset"), Ze = Wt("margin"), qe = Wt("opacity"), tt = Wt("padding"), Xe = Wt("saturate"), ot = Wt("scale"), pt = Wt("sepia"), ht = Wt("skew"), wt = Wt("space"), gt = Wt("translate"), It = function() {
    return ["auto", "contain", "none"];
  }, Nt = function() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  }, Ft = function() {
    return ["auto", oe];
  }, on = function() {
    return ["", ma];
  }, en = function() {
    return ["auto", Ll, yr];
  }, wn = function() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  }, Zt = function() {
    return ["solid", "dashed", "dotted", "double", "none"];
  }, pn = function() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  }, un = function() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  }, dn = function() {
    return ["", "0", yr];
  }, xn = function() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  }, Rn = function() {
    return [Ll, Jm];
  }, At = function() {
    return [Ll, yr];
  };
  return { cacheSize: 500, theme: { colors: [cd], spacing: [ma], blur: ["none", "", xu, wu], brightness: Rn(), borderColor: [ne], borderRadius: ["none", "", "full", xu, wu], borderSpacing: [oe], borderWidth: on(), contrast: Rn(), grayscale: dn(), hueRotate: At(), invert: dn(), gap: [oe], gradientColorStops: [ne], gradientColorStopPositions: [Wz, wu], inset: Ft(), margin: Ft(), opacity: Rn(), padding: [oe], saturate: Rn(), scale: Rn(), sepia: dn(), skew: At(), space: [oe], translate: [oe] }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", yr] }], container: ["container"], columns: [{ columns: [xu] }], "break-after": [{ "break-after": xn() }], "break-before": [{ "break-before": xn() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none"] }], clear: [{ clear: ["left", "right", "both", "none"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [].concat(wn(), [yr]) }], overflow: [{ overflow: Nt() }], "overflow-x": [{ "overflow-x": Nt() }], "overflow-y": [{ "overflow-y": Nt() }], overscroll: [{ overscroll: It() }], "overscroll-x": [{ "overscroll-x": It() }], "overscroll-y": [{ "overscroll-y": It() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [He] }], "inset-x": [{ "inset-x": [He] }], "inset-y": [{ "inset-y": [He] }], start: [{ start: [He] }], end: [{ end: [He] }], top: [{ top: [He] }], right: [{ right: [He] }], bottom: [{ bottom: [He] }], left: [{ left: [He] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", sd] }], basis: [{ basis: [oe] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", yr] }], grow: [{ grow: dn() }], shrink: [{ shrink: dn() }], order: [{ order: ["first", "last", "none", sd] }], "grid-cols": [{ "grid-cols": [cd] }], "col-start-end": [{ col: ["auto", { span: [sd] }, yr] }], "col-start": [{ "col-start": en() }], "col-end": [{ "col-end": en() }], "grid-rows": [{ "grid-rows": [cd] }], "row-start-end": [{ row: ["auto", { span: [sd] }, yr] }], "row-start": [{ "row-start": en() }], "row-end": [{ "row-end": en() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", yr] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", yr] }], gap: [{ gap: [Me] }], "gap-x": [{ "gap-x": [Me] }], "gap-y": [{ "gap-y": [Me] }], "justify-content": [{ justify: ["normal"].concat(un()) }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal"].concat(un(), ["baseline"]) }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [].concat(un(), ["baseline"]) }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [tt] }], px: [{ px: [tt] }], py: [{ py: [tt] }], ps: [{ ps: [tt] }], pe: [{ pe: [tt] }], pt: [{ pt: [tt] }], pr: [{ pr: [tt] }], pb: [{ pb: [tt] }], pl: [{ pl: [tt] }], m: [{ m: [Ze] }], mx: [{ mx: [Ze] }], my: [{ my: [Ze] }], ms: [{ ms: [Ze] }], me: [{ me: [Ze] }], mt: [{ mt: [Ze] }], mr: [{ mr: [Ze] }], mb: [{ mb: [Ze] }], ml: [{ ml: [Ze] }], "space-x": [{ "space-x": [wt] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [wt] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", oe] }], "min-w": [{ "min-w": ["min", "max", "fit", ma] }], "max-w": [{ "max-w": ["0", "none", "full", "min", "max", "fit", "prose", { screen: [xu] }, xu, wu] }], h: [{ h: [oe, "auto", "min", "max", "fit"] }], "min-h": [{ "min-h": ["min", "max", "fit", ma] }], "max-h": [{ "max-h": [oe, "min", "max", "fit"] }], "font-size": [{ text: ["base", xu, wu] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Jm] }], "font-family": [{ font: [cd] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", wu] }], "line-clamp": [{ "line-clamp": ["none", Ll, Jm] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ma] }], "list-image": [{ "list-image": ["none", yr] }], "list-style-type": [{ list: ["none", "disc", "decimal", yr] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [ne] }], "placeholder-opacity": [{ "placeholder-opacity": [qe] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [ne] }], "text-opacity": [{ "text-opacity": [qe] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [].concat(Zt(), ["wavy"]) }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", ma] }], "underline-offset": [{ "underline-offset": ["auto", ma] }], "text-decoration-color": [{ decoration: [ne] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], indent: [{ indent: [oe] }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", wu] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", yr] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [qe] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [].concat(wn(), [Vz]) }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Hz] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, $z] }], "bg-color": [{ bg: [ne] }], "gradient-from-pos": [{ from: [ze] }], "gradient-via-pos": [{ via: [ze] }], "gradient-to-pos": [{ to: [ze] }], "gradient-from": [{ from: [Be] }], "gradient-via": [{ via: [Be] }], "gradient-to": [{ to: [Be] }], rounded: [{ rounded: [ge] }], "rounded-s": [{ "rounded-s": [ge] }], "rounded-e": [{ "rounded-e": [ge] }], "rounded-t": [{ "rounded-t": [ge] }], "rounded-r": [{ "rounded-r": [ge] }], "rounded-b": [{ "rounded-b": [ge] }], "rounded-l": [{ "rounded-l": [ge] }], "rounded-ss": [{ "rounded-ss": [ge] }], "rounded-se": [{ "rounded-se": [ge] }], "rounded-ee": [{ "rounded-ee": [ge] }], "rounded-es": [{ "rounded-es": [ge] }], "rounded-tl": [{ "rounded-tl": [ge] }], "rounded-tr": [{ "rounded-tr": [ge] }], "rounded-br": [{ "rounded-br": [ge] }], "rounded-bl": [{ "rounded-bl": [ge] }], "border-w": [{ border: [_e] }], "border-w-x": [{ "border-x": [_e] }], "border-w-y": [{ "border-y": [_e] }], "border-w-s": [{ "border-s": [_e] }], "border-w-e": [{ "border-e": [_e] }], "border-w-t": [{ "border-t": [_e] }], "border-w-r": [{ "border-r": [_e] }], "border-w-b": [{ "border-b": [_e] }], "border-w-l": [{ "border-l": [_e] }], "border-opacity": [{ "border-opacity": [qe] }], "border-style": [{ border: [].concat(Zt(), ["hidden"]) }], "divide-x": [{ "divide-x": [_e] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [_e] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [qe] }], "divide-style": [{ divide: Zt() }], "border-color": [{ border: [ye] }], "border-color-x": [{ "border-x": [ye] }], "border-color-y": [{ "border-y": [ye] }], "border-color-t": [{ "border-t": [ye] }], "border-color-r": [{ "border-r": [ye] }], "border-color-b": [{ "border-b": [ye] }], "border-color-l": [{ "border-l": [ye] }], "divide-color": [{ divide: [ye] }], "outline-style": [{ outline: [""].concat(Zt()) }], "outline-offset": [{ "outline-offset": [ma] }], "outline-w": [{ outline: [ma] }], "outline-color": [{ outline: [ne] }], "ring-w": [{ ring: on() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [ne] }], "ring-opacity": [{ "ring-opacity": [qe] }], "ring-offset-w": [{ "ring-offset": [ma] }], "ring-offset-color": [{ "ring-offset": [ne] }], shadow: [{ shadow: ["", "inner", "none", xu, Yz] }], "shadow-color": [{ shadow: [cd] }], opacity: [{ opacity: [qe] }], "mix-blend": [{ "mix-blend": pn() }], "bg-blend": [{ "bg-blend": pn() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [ae] }], brightness: [{ brightness: [fe] }], contrast: [{ contrast: [Se] }], "drop-shadow": [{ "drop-shadow": ["", "none", xu, yr] }], grayscale: [{ grayscale: [Ie] }], "hue-rotate": [{ "hue-rotate": [$e] }], invert: [{ invert: [Ne] }], saturate: [{ saturate: [Xe] }], sepia: [{ sepia: [pt] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [ae] }], "backdrop-brightness": [{ "backdrop-brightness": [fe] }], "backdrop-contrast": [{ "backdrop-contrast": [Se] }], "backdrop-grayscale": [{ "backdrop-grayscale": [Ie] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [$e] }], "backdrop-invert": [{ "backdrop-invert": [Ne] }], "backdrop-opacity": [{ "backdrop-opacity": [qe] }], "backdrop-saturate": [{ "backdrop-saturate": [Xe] }], "backdrop-sepia": [{ "backdrop-sepia": [pt] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [we] }], "border-spacing-x": [{ "border-spacing-x": [we] }], "border-spacing-y": [{ "border-spacing-y": [we] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", yr] }], duration: [{ duration: At() }], ease: [{ ease: ["linear", "in", "out", "in-out", yr] }], delay: [{ delay: At() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", yr] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [ot] }], "scale-x": [{ "scale-x": [ot] }], "scale-y": [{ "scale-y": [ot] }], rotate: [{ rotate: [sd, yr] }], "translate-x": [{ "translate-x": [gt] }], "translate-y": [{ "translate-y": [gt] }], "skew-x": [{ "skew-x": [ht] }], "skew-y": [{ "skew-y": [ht] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", yr] }], accent: [{ accent: ["auto", ne] }], appearance: ["appearance-none"], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", yr] }], "caret-color": [{ caret: [ne] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": [oe] }], "scroll-mx": [{ "scroll-mx": [oe] }], "scroll-my": [{ "scroll-my": [oe] }], "scroll-ms": [{ "scroll-ms": [oe] }], "scroll-me": [{ "scroll-me": [oe] }], "scroll-mt": [{ "scroll-mt": [oe] }], "scroll-mr": [{ "scroll-mr": [oe] }], "scroll-mb": [{ "scroll-mb": [oe] }], "scroll-ml": [{ "scroll-ml": [oe] }], "scroll-p": [{ "scroll-p": [oe] }], "scroll-px": [{ "scroll-px": [oe] }], "scroll-py": [{ "scroll-py": [oe] }], "scroll-ps": [{ "scroll-ps": [oe] }], "scroll-pe": [{ "scroll-pe": [oe] }], "scroll-pt": [{ "scroll-pt": [oe] }], "scroll-pr": [{ "scroll-pr": [oe] }], "scroll-pb": [{ "scroll-pb": [oe] }], "scroll-pl": [{ "scroll-pl": [oe] }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "pinch-zoom", "manipulation", { pan: ["x", "left", "right", "y", "up", "down"] }] }], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", yr] }], fill: [{ fill: [ne, "none"] }], "stroke-w": [{ stroke: [ma, Jm] }], stroke: [{ stroke: [ne, "none"] }], sr: ["sr-only", "not-sr-only"] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } };
}
var Xz = Y(() => {
  qz(), Qz();
}), Pr, Jz = Y(() => {
  zz(), Xz(), Pr = Fz(Kz);
}), uc = Y(() => {
  Jz();
});
function Tt() {
  return Tt = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, Tt.apply(this, arguments);
}
function fq(ne) {
  ne === void 0 && (ne = {});
  let { initialEntries: oe = ["/"], initialIndex: ae, v5Compat: fe = !1 } = ne, ye;
  ye = oe.map((Me, Be) => $e(Me, typeof Me == "string" ? null : Me.state, Be === 0 ? "default" : void 0));
  let ge = Se(ae ?? ye.length - 1), we = pr.Pop, _e = null;
  function Se(Me) {
    return Math.min(Math.max(Me, 0), ye.length - 1);
  }
  function Ie() {
    return ye[ge];
  }
  function $e(Me, Be, ze) {
    Be === void 0 && (Be = null);
    let He = uk(ye ? Ie().pathname : "/", Me, Be, ze);
    return ln(He.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(Me)), He;
  }
  function Ne(Me) {
    return typeof Me == "string" ? Me : Mo(Me);
  }
  return { get index() {
    return ge;
  }, get action() {
    return we;
  }, get location() {
    return Ie();
  }, createHref: Ne, createURL(Me) {
    return new URL(Ne(Me), "http://localhost");
  }, encodeLocation(Me) {
    let Be = typeof Me == "string" ? Qi(Me) : Me;
    return { pathname: Be.pathname || "", search: Be.search || "", hash: Be.hash || "" };
  }, push(Me, Be) {
    we = pr.Push;
    let ze = $e(Me, Be);
    ge += 1, ye.splice(ge, ye.length, ze), fe && _e && _e({ action: we, location: ze, delta: 1 });
  }, replace(Me, Be) {
    we = pr.Replace;
    let ze = $e(Me, Be);
    ye[ge] = ze, fe && _e && _e({ action: we, location: ze, delta: 0 });
  }, go(Me) {
    we = pr.Pop;
    let Be = Se(ge + Me), ze = ye[Be];
    ge = Be, _e && _e({ action: we, location: ze, delta: Me });
  }, listen(Me) {
    return _e = Me, () => {
      _e = null;
    };
  } };
}
function Te(ne, oe) {
  if (ne === !1 || ne === null || typeof ne > "u")
    throw new Error(oe);
}
function ln(ne, oe) {
  if (!ne) {
    typeof console < "u" && console.warn(oe);
    try {
      throw new Error(oe);
    } catch {
    }
  }
}
function eee() {
  return Math.random().toString(36).substr(2, 8);
}
function uk(ne, oe, ae, fe) {
  return ae === void 0 && (ae = null), Tt({ pathname: typeof ne == "string" ? ne : ne.pathname, search: "", hash: "" }, typeof oe == "string" ? Qi(oe) : oe, { state: ae, key: oe && oe.key || fe || eee() });
}
function Mo(ne) {
  let { pathname: oe = "/", search: ae = "", hash: fe = "" } = ne;
  return ae && ae !== "?" && (oe += ae.charAt(0) === "?" ? ae : "?" + ae), fe && fe !== "#" && (oe += fe.charAt(0) === "#" ? fe : "#" + fe), oe;
}
function Qi(ne) {
  let oe = {};
  if (ne) {
    let ae = ne.indexOf("#");
    ae >= 0 && (oe.hash = ne.substr(ae), ne = ne.substr(0, ae));
    let fe = ne.indexOf("?");
    fe >= 0 && (oe.search = ne.substr(fe), ne = ne.substr(0, fe)), ne && (oe.pathname = ne);
  }
  return oe;
}
function ree(ne) {
  return ne.index === !0;
}
function dq(ne, oe, ae, fe) {
  return ae === void 0 && (ae = []), fe === void 0 && (fe = {}), ne.map((ye, ge) => {
    let we = [...ae, ge], _e = typeof ye.id == "string" ? ye.id : we.join("-");
    if (Te(ye.index !== !0 || !ye.children, "Cannot specify children on an index route"), Te(!fe[_e], 'Found a route id collision on id "' + _e + `".  Route id's must be globally unique within Data Router usages`), ree(ye)) {
      let Se = Tt({}, ye, oe(ye), { id: _e });
      return fe[_e] = Se, Se;
    } else {
      let Se = Tt({}, ye, oe(ye), { id: _e, children: void 0 });
      return fe[_e] = Se, ye.children && (Se.children = dq(ye.children, oe, we, fe)), Se;
    }
  });
}
function Cu(ne, oe, ae) {
  ae === void 0 && (ae = "/");
  let fe = typeof oe == "string" ? Qi(oe) : oe, ye = Ru(fe.pathname || "/", ae);
  if (ye == null)
    return null;
  let ge = pq(ne);
  nee(ge);
  let we = null;
  for (let _e = 0; we == null && _e < ge.length; ++_e)
    we = dee(ge[_e], vee(ye));
  return we;
}
function pq(ne, oe, ae, fe) {
  oe === void 0 && (oe = []), ae === void 0 && (ae = []), fe === void 0 && (fe = "");
  let ye = (ge, we, _e) => {
    let Se = { relativePath: _e === void 0 ? ge.path || "" : _e, caseSensitive: ge.caseSensitive === !0, childrenIndex: we, route: ge };
    Se.relativePath.startsWith("/") && (Te(Se.relativePath.startsWith(fe), 'Absolute route path "' + Se.relativePath + '" nested under path ' + ('"' + fe + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), Se.relativePath = Se.relativePath.slice(fe.length));
    let Ie = ha([fe, Se.relativePath]), $e = ae.concat(Se);
    ge.children && ge.children.length > 0 && (Te(ge.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + Ie + '".')), pq(ge.children, oe, $e, Ie)), !(ge.path == null && !ge.index) && oe.push({ path: Ie, score: cee(Ie, ge.index), routesMeta: $e });
  };
  return ne.forEach((ge, we) => {
    var _e;
    if (ge.path === "" || !((_e = ge.path) != null && _e.includes("?")))
      ye(ge, we);
    else
      for (let Se of vq(ge.path))
        ye(ge, we, Se);
  }), oe;
}
function vq(ne) {
  let oe = ne.split("/");
  if (oe.length === 0)
    return [];
  let [ae, ...fe] = oe, ye = ae.endsWith("?"), ge = ae.replace(/\?$/, "");
  if (fe.length === 0)
    return ye ? [ge, ""] : [ge];
  let we = vq(fe.join("/")), _e = [];
  return _e.push(...we.map((Se) => Se === "" ? ge : [ge, Se].join("/"))), ye && _e.push(...we), _e.map((Se) => ne.startsWith("/") && Se === "" ? "/" : Se);
}
function nee(ne) {
  ne.sort((oe, ae) => oe.score !== ae.score ? ae.score - oe.score : fee(oe.routesMeta.map((fe) => fe.childrenIndex), ae.routesMeta.map((fe) => fe.childrenIndex)));
}
function cee(ne, oe) {
  let ae = ne.split("/"), fe = ae.length;
  return ae.some(Zz) && (fe += see), oe && (fe += oee), ae.filter((ye) => !Zz(ye)).reduce((ye, ge) => ye + (iee.test(ge) ? aee : ge === "" ? uee : lee), fe);
}
function fee(ne, oe) {
  return ne.length === oe.length && ne.slice(0, -1).every((ae, fe) => ae === oe[fe]) ? ne[ne.length - 1] - oe[oe.length - 1] : 0;
}
function dee(ne, oe) {
  let { routesMeta: ae } = ne, fe = {}, ye = "/", ge = [];
  for (let we = 0; we < ae.length; ++we) {
    let _e = ae[we], Se = we === ae.length - 1, Ie = ye === "/" ? oe : oe.slice(ye.length) || "/", $e = T0({ path: _e.relativePath, caseSensitive: _e.caseSensitive, end: Se }, Ie);
    if (!$e)
      return null;
    Object.assign(fe, $e.params);
    let Ne = _e.route;
    ge.push({ params: fe, pathname: ha([ye, $e.pathname]), pathnameBase: yee(ha([ye, $e.pathnameBase])), route: Ne }), $e.pathnameBase !== "/" && (ye = ha([ye, $e.pathnameBase]));
  }
  return ge;
}
function T0(ne, oe) {
  typeof ne == "string" && (ne = { path: ne, caseSensitive: !1, end: !0 });
  let [ae, fe] = pee(ne.path, ne.caseSensitive, ne.end), ye = oe.match(ae);
  if (!ye)
    return null;
  let ge = ye[0], we = ge.replace(/(.)\/+$/, "$1"), _e = ye.slice(1);
  return { params: fe.reduce((Se, Ie, $e) => {
    if (Ie === "*") {
      let Ne = _e[$e] || "";
      we = ge.slice(0, ge.length - Ne.length).replace(/(.)\/+$/, "$1");
    }
    return Se[Ie] = mee(_e[$e] || "", Ie), Se;
  }, {}), pathname: ge, pathnameBase: we, pattern: ne };
}
function pee(ne, oe, ae) {
  oe === void 0 && (oe = !1), ae === void 0 && (ae = !0), ln(ne === "*" || !ne.endsWith("*") || ne.endsWith("/*"), 'Route path "' + ne + '" will be treated as if it were ' + ('"' + ne.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + ne.replace(/\*$/, "/*") + '".'));
  let fe = [], ye = "^" + ne.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (ge, we) => (fe.push(we), "/([^\\/]+)"));
  return ne.endsWith("*") ? (fe.push("*"), ye += ne === "*" || ne === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : ae ? ye += "\\/*$" : ne !== "" && ne !== "/" && (ye += "(?:(?=\\/|$))"), [new RegExp(ye, oe ? void 0 : "i"), fe];
}
function vee(ne) {
  try {
    return decodeURI(ne);
  } catch (oe) {
    return ln(!1, 'The URL path "' + ne + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + oe + ").")), ne;
  }
}
function mee(ne, oe) {
  try {
    return decodeURIComponent(ne);
  } catch (ae) {
    return ln(!1, 'The value for the URL param "' + oe + '" will not be decoded because' + (' the string "' + ne + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + ae + ").")), ne;
  }
}
function Ru(ne, oe) {
  if (oe === "/")
    return ne;
  if (!ne.toLowerCase().startsWith(oe.toLowerCase()))
    return null;
  let ae = oe.endsWith("/") ? oe.length - 1 : oe.length, fe = ne.charAt(ae);
  return fe && fe !== "/" ? null : ne.slice(ae) || "/";
}
function ck(ne, oe) {
  oe === void 0 && (oe = "/");
  let { pathname: ae, search: fe = "", hash: ye = "" } = typeof ne == "string" ? Qi(ne) : ne;
  return { pathname: ae ? ae.startsWith("/") ? ae : hee(ae, oe) : oe, search: gee(fe), hash: bee(ye) };
}
function hee(ne, oe) {
  let ae = oe.replace(/\/+$/, "").split("/");
  return ne.split("/").forEach((fe) => {
    fe === ".." ? ae.length > 1 && ae.pop() : fe !== "." && ae.push(fe);
  }), ae.length > 1 ? ae.join("/") : "/";
}
function ak(ne, oe, ae, fe) {
  return "Cannot include a '" + ne + "' character in a manually specified " + ("`to." + oe + "` field [" + JSON.stringify(fe) + "].  Please separate it out to the ") + ("`to." + ae + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function nh(ne) {
  return ne.filter((oe, ae) => ae === 0 || oe.route.path && oe.route.path.length > 0);
}
function k0(ne, oe, ae, fe) {
  fe === void 0 && (fe = !1);
  let ye;
  typeof ne == "string" ? ye = Qi(ne) : (ye = Tt({}, ne), Te(!ye.pathname || !ye.pathname.includes("?"), ak("?", "pathname", "search", ye)), Te(!ye.pathname || !ye.pathname.includes("#"), ak("#", "pathname", "hash", ye)), Te(!ye.search || !ye.search.includes("#"), ak("#", "search", "hash", ye)));
  let ge = ne === "" || ye.pathname === "", we = ge ? "/" : ye.pathname, _e;
  if (fe || we == null)
    _e = ae;
  else {
    let Ne = oe.length - 1;
    if (we.startsWith("..")) {
      let Me = we.split("/");
      for (; Me[0] === ".."; )
        Me.shift(), Ne -= 1;
      ye.pathname = Me.join("/");
    }
    _e = Ne >= 0 ? oe[Ne] : "/";
  }
  let Se = ck(ye, _e), Ie = we && we !== "/" && we.endsWith("/"), $e = (ge || we === ".") && ae.endsWith("/");
  return !Se.pathname.endsWith("/") && (Ie || $e) && (Se.pathname += "/"), Se;
}
function ih(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.internal == "boolean" && "data" in ne;
}
function fk(ne) {
  Te(ne.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let oe;
  if (ne.mapRouteProperties)
    oe = ne.mapRouteProperties;
  else if (ne.detectErrorBoundary) {
    let $t = ne.detectErrorBoundary;
    oe = (Vt) => ({ hasErrorBoundary: $t(Vt) });
  } else
    oe = Oee;
  let ae = {}, fe = dq(ne.routes, oe, void 0, ae), ye, ge = ne.basename || "/", we = Tt({ v7_normalizeFormMethod: !1, v7_prependBasename: !1 }, ne.future), _e = null, Se = /* @__PURE__ */ new Set(), Ie = null, $e = null, Ne = null, Me = ne.hydrationData != null, Be = Cu(fe, ne.history.location, ge), ze = null;
  if (Be == null) {
    let $t = Wa(404, { pathname: ne.history.location.pathname }), { matches: Vt, route: rn } = uq(fe);
    Be = Vt, ze = { [rn.id]: $t };
  }
  let He = !Be.some(($t) => $t.route.lazy) && (!Be.some(($t) => $t.route.loader) || ne.hydrationData != null), Ze, qe = { historyAction: ne.history.action, location: ne.history.location, matches: Be, initialized: He, navigation: ok, restoreScrollPosition: ne.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: ne.hydrationData && ne.hydrationData.loaderData || {}, actionData: ne.hydrationData && ne.hydrationData.actionData || null, errors: ne.hydrationData && ne.hydrationData.errors || ze, fetchers: /* @__PURE__ */ new Map(), blockers: /* @__PURE__ */ new Map() }, tt = pr.Pop, Xe = !1, ot, pt = !1, ht = !1, wt = [], gt = [], It = /* @__PURE__ */ new Map(), Nt = 0, Ft = -1, on = /* @__PURE__ */ new Map(), en = /* @__PURE__ */ new Set(), wn = /* @__PURE__ */ new Map(), Zt = /* @__PURE__ */ new Map(), pn = /* @__PURE__ */ new Map(), un = !1;
  function dn() {
    return _e = ne.history.listen(($t) => {
      let { action: Vt, location: rn, delta: Cn } = $t;
      if (un) {
        un = !1;
        return;
      }
      ln(pn.size === 0 || Cn != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let Mn = qa({ currentLocation: qe.location, nextLocation: rn, historyAction: Vt });
      if (Mn && Cn != null) {
        un = !0, ne.history.go(Cn * -1), xa(Mn, { state: "blocked", location: rn, proceed() {
          xa(Mn, { state: "proceeding", proceed: void 0, reset: void 0, location: rn }), ne.history.go(Cn);
        }, reset() {
          No(Mn), At({ blockers: new Map(Ze.state.blockers) });
        } });
        return;
      }
      return Ht(Vt, rn);
    }), qe.initialized || Ht(pr.Pop, qe.location), Ze;
  }
  function xn() {
    _e && _e(), Se.clear(), ot && ot.abort(), qe.fetchers.forEach(($t, Vt) => xo(Vt)), qe.blockers.forEach(($t, Vt) => No(Vt));
  }
  function Rn($t) {
    return Se.add($t), () => Se.delete($t);
  }
  function At($t) {
    qe = Tt({}, qe, $t), Se.forEach((Vt) => Vt(qe));
  }
  function hn($t, Vt) {
    var rn, Cn;
    let Mn = qe.actionData != null && qe.navigation.formMethod != null && Eu(qe.navigation.formMethod) && qe.navigation.state === "loading" && ((rn = $t.state) == null ? void 0 : rn._isRedirect) !== !0, Bn;
    Vt.actionData ? Object.keys(Vt.actionData).length > 0 ? Bn = Vt.actionData : Bn = null : Mn ? Bn = qe.actionData : Bn = null;
    let Qn = Vt.loaderData ? oq(qe.loaderData, Vt.loaderData, Vt.matches || [], Vt.errors) : qe.loaderData;
    for (let [jn] of pn)
      No(jn);
    let Kn = Xe === !0 || qe.navigation.formMethod != null && Eu(qe.navigation.formMethod) && ((Cn = $t.state) == null ? void 0 : Cn._isRedirect) !== !0;
    ye && (fe = ye, ye = void 0), At(Tt({}, Vt, { actionData: Bn, loaderData: Qn, historyAction: tt, location: $t, initialized: !0, navigation: ok, revalidation: "idle", restoreScrollPosition: jo($t, Vt.matches || qe.matches), preventScrollReset: Kn, blockers: new Map(qe.blockers) })), pt || tt === pr.Pop || (tt === pr.Push ? ne.history.push($t, $t.state) : tt === pr.Replace && ne.history.replace($t, $t.state)), tt = pr.Pop, Xe = !1, pt = !1, ht = !1, wt = [], gt = [];
  }
  async function Yn($t, Vt) {
    if (typeof $t == "number") {
      ne.history.go($t);
      return;
    }
    let rn = lk(qe.location, qe.matches, ge, we.v7_prependBasename, $t, Vt == null ? void 0 : Vt.fromRouteId, Vt == null ? void 0 : Vt.relative), { path: Cn, submission: Mn, error: Bn } = tq(we.v7_normalizeFormMethod, !1, rn, Vt), Qn = qe.location, Kn = uk(qe.location, Cn, Vt && Vt.state);
    Kn = Tt({}, Kn, ne.history.encodeLocation(Kn));
    let jn = Vt && Vt.replace != null ? Vt.replace : void 0, Tr = pr.Push;
    jn === !0 ? Tr = pr.Replace : jn === !1 || Mn != null && Eu(Mn.formMethod) && Mn.formAction === qe.location.pathname + qe.location.search && (Tr = pr.Replace);
    let jr = Vt && "preventScrollReset" in Vt ? Vt.preventScrollReset === !0 : void 0, bo = qa({ currentLocation: Qn, nextLocation: Kn, historyAction: Tr });
    if (bo) {
      xa(bo, { state: "blocked", location: Kn, proceed() {
        xa(bo, { state: "proceeding", proceed: void 0, reset: void 0, location: Kn }), Yn($t, Vt);
      }, reset() {
        No(bo), At({ blockers: new Map(qe.blockers) });
      } });
      return;
    }
    return await Ht(Tr, Kn, { submission: Mn, pendingError: Bn, preventScrollReset: jr, replace: Vt && Vt.replace });
  }
  function Un() {
    if (Kr(), At({ revalidation: "loading" }), qe.navigation.state !== "submitting") {
      if (qe.navigation.state === "idle") {
        Ht(qe.historyAction, qe.location, { startUninterruptedRevalidation: !0 });
        return;
      }
      Ht(tt || qe.historyAction, qe.navigation.location, { overrideNavigation: qe.navigation });
    }
  }
  async function Ht($t, Vt, rn) {
    ot && ot.abort(), ot = null, tt = $t, pt = (rn && rn.startUninterruptedRevalidation) === !0, Ka(qe.location, qe.matches), Xe = (rn && rn.preventScrollReset) === !0;
    let Cn = ye || fe, Mn = rn && rn.overrideNavigation, Bn = Cu(Cn, Vt, ge);
    if (!Bn) {
      let _r = Wa(404, { pathname: Vt.pathname }), { matches: Sr, route: Ro } = uq(Cn);
      da(), hn(Vt, { matches: Sr, loaderData: {}, errors: { [Ro.id]: _r } });
      return;
    }
    if (Mee(qe.location, Vt) && !(rn && rn.submission && Eu(rn.submission.formMethod))) {
      hn(Vt, { matches: Bn });
      return;
    }
    ot = new AbortController();
    let Qn = eh(ne.history, Vt, ot.signal, rn && rn.submission), Kn, jn;
    if (rn && rn.pendingError)
      jn = { [fd(Bn).route.id]: rn.pendingError };
    else if (rn && rn.submission && Eu(rn.submission.formMethod)) {
      let _r = await _n(Qn, Vt, rn.submission, Bn, { replace: rn.replace });
      if (_r.shortCircuited)
        return;
      Kn = _r.pendingActionData, jn = _r.pendingActionError, Mn = Tt({ state: "loading", location: Vt }, rn.submission), Qn = new Request(Qn.url, { signal: Qn.signal });
    }
    let { shortCircuited: Tr, loaderData: jr, errors: bo } = await Vn(Qn, Vt, Bn, Mn, rn && rn.submission, rn && rn.fetcherSubmission, rn && rn.replace, Kn, jn);
    Tr || (ot = null, hn(Vt, Tt({ matches: Bn }, Kn ? { actionData: Kn } : {}, { loaderData: jr, errors: bo })));
  }
  async function _n($t, Vt, rn, Cn, Mn) {
    Kr();
    let Bn = Tt({ state: "submitting", location: Vt }, rn);
    At({ navigation: Bn });
    let Qn, Kn = sk(Cn, Vt);
    if (!Kn.route.action && !Kn.route.lazy)
      Qn = { type: Gr.error, error: Wa(405, { method: $t.method, pathname: Vt.pathname, routeId: Kn.route.id }) };
    else if (Qn = await Zm("action", $t, Kn, Cn, ae, oe, ge), $t.signal.aborted)
      return { shortCircuited: !0 };
    if (dd(Qn)) {
      let jn;
      return Mn && Mn.replace != null ? jn = Mn.replace : jn = Qn.location === qe.location.pathname + qe.location.search, await Yr(qe, Qn, { submission: rn, replace: jn }), { shortCircuited: !0 };
    }
    if (th(Qn)) {
      let jn = fd(Cn, Kn.route.id);
      return (Mn && Mn.replace) !== !0 && (tt = pr.Push), { pendingActionData: {}, pendingActionError: { [jn.route.id]: Qn.error } };
    }
    if (lc(Qn))
      throw Wa(400, { type: "defer-action" });
    return { pendingActionData: { [Kn.route.id]: Qn.data } };
  }
  async function Vn($t, Vt, rn, Cn, Mn, Bn, Qn, Kn, jn) {
    let Tr = Cn;
    Tr || (Tr = Tt({ state: "loading", location: Vt, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Mn));
    let jr = Mn || Bn ? Mn || Bn : Tr.formMethod && Tr.formAction && Tr.formData && Tr.formEncType ? { formMethod: Tr.formMethod, formAction: Tr.formAction, formData: Tr.formData, formEncType: Tr.formEncType } : void 0, bo = ye || fe, [_r, Sr] = rq(ne.history, qe, rn, jr, Vt, ht, wt, gt, wn, bo, ge, Kn, jn);
    if (da((Jr) => !(rn && rn.some((vo) => vo.route.id === Jr)) || _r && _r.some((vo) => vo.route.id === Jr)), _r.length === 0 && Sr.length === 0) {
      let Jr = Aa();
      return hn(Vt, Tt({ matches: rn, loaderData: {}, errors: jn || null }, Kn ? { actionData: Kn } : {}, Jr ? { fetchers: new Map(qe.fetchers) } : {})), { shortCircuited: !0 };
    }
    if (!pt) {
      Sr.forEach((vo) => {
        let aa = qe.fetchers.get(vo.key), ni = { state: "loading", data: aa && aa.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        qe.fetchers.set(vo.key, ni);
      });
      let Jr = Kn || qe.actionData;
      At(Tt({ navigation: Tr }, Jr ? Object.keys(Jr).length === 0 ? { actionData: null } : { actionData: Jr } : {}, Sr.length > 0 ? { fetchers: new Map(qe.fetchers) } : {}));
    }
    Ft = ++Nt, Sr.forEach((Jr) => {
      Jr.controller && It.set(Jr.key, Jr.controller);
    });
    let Ro = () => Sr.forEach((Jr) => _o(Jr.key));
    ot && ot.signal.addEventListener("abort", Ro);
    let { results: Xa, loaderResults: Gi, fetcherResults: Yi } = await qr(qe.matches, rn, _r, Sr, $t);
    if ($t.signal.aborted)
      return { shortCircuited: !0 };
    ot && ot.signal.removeEventListener("abort", Ro), Sr.forEach((Jr) => It.delete(Jr.key));
    let ei = lq(Xa);
    if (ei)
      return await Yr(qe, ei, { replace: Qn }), { shortCircuited: !0 };
    let { loaderData: Si, errors: Da } = aq(qe, rn, _r, Gi, jn, Sr, Yi, Zt);
    Zt.forEach((Jr, vo) => {
      Jr.subscribe((aa) => {
        (aa || Jr.done) && Zt.delete(vo);
      });
    });
    let ti = Aa(), Ni = Ho(Ft), Ea = ti || Ni || Sr.length > 0;
    return Tt({ loaderData: Si, errors: Da }, Ea ? { fetchers: new Map(qe.fetchers) } : {});
  }
  function br($t) {
    return qe.fetchers.get($t) || Cee;
  }
  function nr($t, Vt, rn, Cn) {
    if (Ree)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    It.has($t) && _o($t);
    let Mn = ye || fe, Bn = lk(qe.location, qe.matches, ge, we.v7_prependBasename, rn, Vt, Cn == null ? void 0 : Cn.relative), Qn = Cu(Mn, Bn, ge);
    if (!Qn) {
      $o($t, Vt, Wa(404, { pathname: Bn }));
      return;
    }
    let { path: Kn, submission: jn } = tq(we.v7_normalizeFormMethod, !0, Bn, Cn), Tr = sk(Qn, Kn);
    if (Xe = (Cn && Cn.preventScrollReset) === !0, jn && Eu(jn.formMethod)) {
      Er($t, Vt, Kn, Tr, Qn, jn);
      return;
    }
    wn.set($t, { routeId: Vt, path: Kn }), Qo($t, Vt, Kn, Tr, Qn, jn);
  }
  async function Er($t, Vt, rn, Cn, Mn, Bn) {
    if (Kr(), wn.delete($t), !Cn.route.action && !Cn.route.lazy) {
      let Ot = Wa(405, { method: Bn.formMethod, pathname: rn, routeId: Vt });
      $o($t, Vt, Ot);
      return;
    }
    let Qn = qe.fetchers.get($t), Kn = Tt({ state: "submitting" }, Bn, { data: Qn && Qn.data, " _hasFetcherDoneAnything ": !0 });
    qe.fetchers.set($t, Kn), At({ fetchers: new Map(qe.fetchers) });
    let jn = new AbortController(), Tr = eh(ne.history, rn, jn.signal, Bn);
    It.set($t, jn);
    let jr = await Zm("action", Tr, Cn, Mn, ae, oe, ge);
    if (Tr.signal.aborted) {
      It.get($t) === jn && It.delete($t);
      return;
    }
    if (dd(jr)) {
      It.delete($t), en.add($t);
      let Ot = Tt({ state: "loading" }, Bn, { data: void 0, " _hasFetcherDoneAnything ": !0 });
      return qe.fetchers.set($t, Ot), At({ fetchers: new Map(qe.fetchers) }), Yr(qe, jr, { submission: Bn, isFetchActionRedirect: !0 });
    }
    if (th(jr)) {
      $o($t, Vt, jr.error);
      return;
    }
    if (lc(jr))
      throw Wa(400, { type: "defer-action" });
    let bo = qe.navigation.location || qe.location, _r = eh(ne.history, bo, jn.signal), Sr = ye || fe, Ro = qe.navigation.state !== "idle" ? Cu(Sr, qe.navigation.location, ge) : qe.matches;
    Te(Ro, "Didn't find any matches after fetcher action");
    let Xa = ++Nt;
    on.set($t, Xa);
    let Gi = Tt({ state: "loading", data: jr.data }, Bn, { " _hasFetcherDoneAnything ": !0 });
    qe.fetchers.set($t, Gi);
    let [Yi, ei] = rq(ne.history, qe, Ro, Bn, bo, ht, wt, gt, wn, Sr, ge, { [Cn.route.id]: jr.data }, void 0);
    ei.filter((Ot) => Ot.key !== $t).forEach((Ot) => {
      let En = Ot.key, An = qe.fetchers.get(En), ar = { state: "loading", data: An && An.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      qe.fetchers.set(En, ar), Ot.controller && It.set(En, Ot.controller);
    }), At({ fetchers: new Map(qe.fetchers) });
    let Si = () => ei.forEach((Ot) => _o(Ot.key));
    jn.signal.addEventListener("abort", Si);
    let { results: Da, loaderResults: ti, fetcherResults: Ni } = await qr(qe.matches, Ro, Yi, ei, _r);
    if (jn.signal.aborted)
      return;
    jn.signal.removeEventListener("abort", Si), on.delete($t), It.delete($t), ei.forEach((Ot) => It.delete(Ot.key));
    let Ea = lq(Da);
    if (Ea)
      return Yr(qe, Ea);
    let { loaderData: Jr, errors: vo } = aq(qe, qe.matches, Yi, ti, void 0, ei, Ni, Zt), aa = { state: "idle", data: jr.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    qe.fetchers.set($t, aa);
    let ni = Ho(Xa);
    qe.navigation.state === "loading" && Xa > Ft ? (Te(tt, "Expected pending action"), ot && ot.abort(), hn(qe.navigation.location, { matches: Ro, loaderData: Jr, errors: vo, fetchers: new Map(qe.fetchers) })) : (At(Tt({ errors: vo, loaderData: oq(qe.loaderData, Jr, Ro, vo) }, ni ? { fetchers: new Map(qe.fetchers) } : {})), ht = !1);
  }
  async function Qo($t, Vt, rn, Cn, Mn, Bn) {
    let Qn = qe.fetchers.get($t), Kn = Tt({ state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Bn, { data: Qn && Qn.data, " _hasFetcherDoneAnything ": !0 });
    qe.fetchers.set($t, Kn), At({ fetchers: new Map(qe.fetchers) });
    let jn = new AbortController(), Tr = eh(ne.history, rn, jn.signal);
    It.set($t, jn);
    let jr = await Zm("loader", Tr, Cn, Mn, ae, oe, ge);
    if (lc(jr) && (jr = await _q(jr, Tr.signal, !0) || jr), It.get($t) === jn && It.delete($t), Tr.signal.aborted)
      return;
    if (dd(jr)) {
      en.add($t), await Yr(qe, jr);
      return;
    }
    if (th(jr)) {
      let _r = fd(qe.matches, Vt);
      qe.fetchers.delete($t), At({ fetchers: new Map(qe.fetchers), errors: { [_r.route.id]: jr.error } });
      return;
    }
    Te(!lc(jr), "Unhandled fetcher deferred data");
    let bo = { state: "idle", data: jr.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
    qe.fetchers.set($t, bo), At({ fetchers: new Map(qe.fetchers) });
  }
  async function Yr($t, Vt, rn) {
    var Cn;
    let { submission: Mn, replace: Bn, isFetchActionRedirect: Qn } = rn === void 0 ? {} : rn;
    Vt.revalidate && (ht = !0);
    let Kn = uk($t.location, Vt.location, Tt({ _isRedirect: !0 }, Qn ? { _isFetchActionRedirect: !0 } : {}));
    if (Te(Kn, "Expected a location on the redirect navigation"), hq.test(Vt.location) && yq && typeof ((Cn = window) == null ? void 0 : Cn.location) < "u") {
      let Sr = ne.history.createURL(Vt.location), Ro = Ru(Sr.pathname, ge) == null;
      if (window.location.origin !== Sr.origin || Ro) {
        Bn ? window.location.replace(Vt.location) : window.location.assign(Vt.location);
        return;
      }
    }
    ot = null;
    let jn = Bn === !0 ? pr.Replace : pr.Push, { formMethod: Tr, formAction: jr, formEncType: bo, formData: _r } = $t.navigation;
    !Mn && Tr && jr && _r && bo && (Mn = { formMethod: Tr, formAction: jr, formEncType: bo, formData: _r }), Eee.has(Vt.status) && Mn && Eu(Mn.formMethod) ? await Ht(jn, Kn, { submission: Tt({}, Mn, { formAction: Vt.location }), preventScrollReset: Xe }) : Qn ? await Ht(jn, Kn, { overrideNavigation: { state: "loading", location: Kn, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, fetcherSubmission: Mn, preventScrollReset: Xe }) : await Ht(jn, Kn, { overrideNavigation: { state: "loading", location: Kn, formMethod: Mn ? Mn.formMethod : void 0, formAction: Mn ? Mn.formAction : void 0, formEncType: Mn ? Mn.formEncType : void 0, formData: Mn ? Mn.formData : void 0 }, preventScrollReset: Xe });
  }
  async function qr($t, Vt, rn, Cn, Mn) {
    let Bn = await Promise.all([...rn.map((jn) => Zm("loader", Mn, jn, Vt, ae, oe, ge)), ...Cn.map((jn) => jn.matches && jn.match && jn.controller ? Zm("loader", eh(ne.history, jn.path, jn.controller.signal), jn.match, jn.matches, ae, oe, ge) : { type: Gr.error, error: Wa(404, { pathname: jn.path }) })]), Qn = Bn.slice(0, rn.length), Kn = Bn.slice(rn.length);
    return await Promise.all([sq($t, rn, Qn, Qn.map(() => Mn.signal), !1, qe.loaderData), sq($t, Cn.map((jn) => jn.match), Kn, Cn.map((jn) => jn.controller ? jn.controller.signal : null), !0)]), { results: Bn, loaderResults: Qn, fetcherResults: Kn };
  }
  function Kr() {
    ht = !0, wt.push(...da()), wn.forEach(($t, Vt) => {
      It.has(Vt) && (gt.push(Vt), _o(Vt));
    });
  }
  function $o($t, Vt, rn) {
    let Cn = fd(qe.matches, Vt);
    xo($t), At({ errors: { [Cn.route.id]: rn }, fetchers: new Map(qe.fetchers) });
  }
  function xo($t) {
    It.has($t) && _o($t), wn.delete($t), on.delete($t), en.delete($t), qe.fetchers.delete($t);
  }
  function _o($t) {
    let Vt = It.get($t);
    Te(Vt, "Expected fetch controller: " + $t), Vt.abort(), It.delete($t);
  }
  function ra($t) {
    for (let Vt of $t) {
      let rn = { state: "idle", data: br(Vt).data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
      qe.fetchers.set(Vt, rn);
    }
  }
  function Aa() {
    let $t = [], Vt = !1;
    for (let rn of en) {
      let Cn = qe.fetchers.get(rn);
      Te(Cn, "Expected fetcher: " + rn), Cn.state === "loading" && (en.delete(rn), $t.push(rn), Vt = !0);
    }
    return ra($t), Vt;
  }
  function Ho($t) {
    let Vt = [];
    for (let [rn, Cn] of on)
      if (Cn < $t) {
        let Mn = qe.fetchers.get(rn);
        Te(Mn, "Expected fetcher: " + rn), Mn.state === "loading" && (_o(rn), on.delete(rn), Vt.push(rn));
      }
    return ra(Vt), Vt.length > 0;
  }
  function ca($t, Vt) {
    let rn = qe.blockers.get($t) || eq;
    return pn.get($t) !== Vt && pn.set($t, Vt), rn;
  }
  function No($t) {
    qe.blockers.delete($t), pn.delete($t);
  }
  function xa($t, Vt) {
    let rn = qe.blockers.get($t) || eq;
    Te(rn.state === "unblocked" && Vt.state === "blocked" || rn.state === "blocked" && Vt.state === "blocked" || rn.state === "blocked" && Vt.state === "proceeding" || rn.state === "blocked" && Vt.state === "unblocked" || rn.state === "proceeding" && Vt.state === "unblocked", "Invalid blocker state transition: " + rn.state + " -> " + Vt.state), qe.blockers.set($t, Vt), At({ blockers: new Map(qe.blockers) });
  }
  function qa($t) {
    let { currentLocation: Vt, nextLocation: rn, historyAction: Cn } = $t;
    if (pn.size === 0)
      return;
    pn.size > 1 && ln(!1, "A router only supports one blocker at a time");
    let Mn = Array.from(pn.entries()), [Bn, Qn] = Mn[Mn.length - 1], Kn = qe.blockers.get(Bn);
    if (!(Kn && Kn.state === "proceeding") && Qn({ currentLocation: Vt, nextLocation: rn, historyAction: Cn }))
      return Bn;
  }
  function da($t) {
    let Vt = [];
    return Zt.forEach((rn, Cn) => {
      (!$t || $t(Cn)) && (rn.cancel(), Vt.push(Cn), Zt.delete(Cn));
    }), Vt;
  }
  function oa($t, Vt, rn) {
    if (Ie = $t, Ne = Vt, $e = rn || ((Cn) => Cn.key), !Me && qe.navigation === ok) {
      Me = !0;
      let Cn = jo(qe.location, qe.matches);
      Cn != null && At({ restoreScrollPosition: Cn });
    }
    return () => {
      Ie = null, Ne = null, $e = null;
    };
  }
  function Ka($t, Vt) {
    if (Ie && $e && Ne) {
      let rn = Vt.map((Mn) => cq(Mn, qe.loaderData)), Cn = $e($t, rn) || $t.key;
      Ie[Cn] = Ne();
    }
  }
  function jo($t, Vt) {
    if (Ie && $e && Ne) {
      let rn = Vt.map((Bn) => cq(Bn, qe.loaderData)), Cn = $e($t, rn) || $t.key, Mn = Ie[Cn];
      if (typeof Mn == "number")
        return Mn;
    }
    return null;
  }
  function La($t) {
    ye = $t;
  }
  return Ze = { get basename() {
    return ge;
  }, get state() {
    return qe;
  }, get routes() {
    return fe;
  }, initialize: dn, subscribe: Rn, enableScrollRestoration: oa, navigate: Yn, fetch: nr, revalidate: Un, createHref: ($t) => ne.history.createHref($t), encodeLocation: ($t) => ne.history.encodeLocation($t), getFetcher: br, deleteFetcher: xo, dispose: xn, getBlocker: ca, deleteBlocker: No, _internalFetchControllers: It, _internalActiveDeferreds: Zt, _internalSetRoutes: La }, Ze;
}
function Tee(ne) {
  return ne != null && "formData" in ne;
}
function lk(ne, oe, ae, fe, ye, ge, we) {
  let _e, Se;
  if (ge != null && we !== "path") {
    _e = [];
    for (let $e of oe)
      if (_e.push($e), $e.route.id === ge) {
        Se = $e;
        break;
      }
  } else
    _e = oe, Se = oe[oe.length - 1];
  let Ie = k0(ye || ".", nh(_e).map(($e) => $e.pathnameBase), ne.pathname, we === "path");
  return ye == null && (Ie.search = ne.search, Ie.hash = ne.hash), (ye == null || ye === "" || ye === ".") && Se && Se.route.index && !dk(Ie.search) && (Ie.search = Ie.search ? Ie.search.replace(/^\?/, "?index&") : "?index"), fe && ae !== "/" && (Ie.pathname = Ie.pathname === "/" ? ae : ha([ae, Ie.pathname])), Mo(Ie);
}
function tq(ne, oe, ae, fe) {
  if (!fe || !Tee(fe))
    return { path: ae };
  if (fe.formMethod && !Lee(fe.formMethod))
    return { path: ae, error: Wa(405, { method: fe.formMethod }) };
  let ye;
  if (fe.formData) {
    let _e = fe.formMethod || "get";
    if (ye = { formMethod: ne ? _e.toUpperCase() : _e.toLowerCase(), formAction: Sq(ae), formEncType: fe && fe.formEncType || "application/x-www-form-urlencoded", formData: fe.formData }, Eu(ye.formMethod))
      return { path: ae, submission: ye };
  }
  let ge = Qi(ae), we = bq(fe.formData);
  return oe && ge.search && dk(ge.search) && we.append("index", ""), ge.search = "?" + we, { path: Mo(ge), submission: ye };
}
function kee(ne, oe) {
  let ae = ne;
  if (oe) {
    let fe = ne.findIndex((ye) => ye.route.id === oe);
    fe >= 0 && (ae = ne.slice(0, fe));
  }
  return ae;
}
function rq(ne, oe, ae, fe, ye, ge, we, _e, Se, Ie, $e, Ne, Me) {
  let Be = Me ? Object.values(Me)[0] : Ne ? Object.values(Ne)[0] : void 0, ze = ne.createURL(oe.location), He = ne.createURL(ye), Ze = Me ? Object.keys(Me)[0] : void 0, qe = kee(ae, Ze).filter((Xe, ot) => {
    if (Xe.route.lazy)
      return !0;
    if (Xe.route.loader == null)
      return !1;
    if (Aee(oe.loaderData, oe.matches[ot], Xe) || we.some((wt) => wt === Xe.route.id))
      return !0;
    let pt = oe.matches[ot], ht = Xe;
    return nq(Xe, Tt({ currentUrl: ze, currentParams: pt.params, nextUrl: He, nextParams: ht.params }, fe, { actionResult: Be, defaultShouldRevalidate: ge || ze.toString() === He.toString() || ze.search !== He.search || gq(pt, ht) }));
  }), tt = [];
  return Se.forEach((Xe, ot) => {
    if (!ae.some((wt) => wt.route.id === Xe.routeId))
      return;
    let pt = Cu(Ie, Xe.path, $e);
    if (!pt) {
      tt.push({ key: ot, routeId: Xe.routeId, path: Xe.path, matches: null, match: null, controller: null });
      return;
    }
    let ht = sk(pt, Xe.path);
    if (_e.includes(ot)) {
      tt.push({ key: ot, routeId: Xe.routeId, path: Xe.path, matches: pt, match: ht, controller: new AbortController() });
      return;
    }
    nq(ht, Tt({ currentUrl: ze, currentParams: oe.matches[oe.matches.length - 1].params, nextUrl: He, nextParams: ae[ae.length - 1].params }, fe, { actionResult: Be, defaultShouldRevalidate: ge })) && tt.push({ key: ot, routeId: Xe.routeId, path: Xe.path, matches: pt, match: ht, controller: new AbortController() });
  }), [qe, tt];
}
function Aee(ne, oe, ae) {
  let fe = !oe || ae.route.id !== oe.route.id, ye = ne[ae.route.id] === void 0;
  return fe || ye;
}
function gq(ne, oe) {
  let ae = ne.route.path;
  return ne.pathname !== oe.pathname || ae != null && ae.endsWith("*") && ne.params["*"] !== oe.params["*"];
}
function nq(ne, oe) {
  if (ne.route.shouldRevalidate) {
    let ae = ne.route.shouldRevalidate(oe);
    if (typeof ae == "boolean")
      return ae;
  }
  return oe.defaultShouldRevalidate;
}
async function iq(ne, oe, ae) {
  if (!ne.lazy)
    return;
  let fe = await ne.lazy();
  if (!ne.lazy)
    return;
  let ye = ae[ne.id];
  Te(ye, "No route found in manifest");
  let ge = {};
  for (let we in fe) {
    let _e = ye[we] !== void 0 && we !== "hasErrorBoundary";
    ln(!_e, 'Route "' + ye.id + '" has a static property "' + we + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + we + '" will be ignored.')), !_e && !tee.has(we) && (ge[we] = fe[we]);
  }
  Object.assign(ye, ge), Object.assign(ye, Tt({}, oe(ye), { lazy: void 0 }));
}
async function Zm(ne, oe, ae, fe, ye, ge, we, _e, Se, Ie) {
  _e === void 0 && (_e = !1), Se === void 0 && (Se = !1);
  let $e, Ne, Me, Be = (Ze) => {
    let qe, tt = new Promise((Xe, ot) => qe = ot);
    return Me = () => qe(), oe.signal.addEventListener("abort", Me), Promise.race([Ze({ request: oe, params: ae.params, context: Ie }), tt]);
  };
  try {
    let Ze = ae.route[ne];
    if (ae.route.lazy)
      if (Ze)
        Ne = (await Promise.all([Be(Ze), iq(ae.route, ge, ye)]))[0];
      else if (await iq(ae.route, ge, ye), Ze = ae.route[ne], Ze)
        Ne = await Be(Ze);
      else if (ne === "action") {
        let qe = new URL(oe.url), tt = qe.pathname + qe.search;
        throw Wa(405, { method: oe.method, pathname: tt, routeId: ae.route.id });
      } else
        return { type: Gr.data, data: void 0 };
    else if (Ze)
      Ne = await Be(Ze);
    else {
      let qe = new URL(oe.url), tt = qe.pathname + qe.search;
      throw Wa(404, { pathname: tt });
    }
    Te(Ne !== void 0, "You defined " + (ne === "action" ? "an action" : "a loader") + " for route " + ('"' + ae.route.id + "\" but didn't return anything from your `" + ne + "` ") + "function. Please return a value or `null`.");
  } catch (Ze) {
    $e = Gr.error, Ne = Ze;
  } finally {
    Me && oe.signal.removeEventListener("abort", Me);
  }
  if (Nee(Ne)) {
    let Ze = Ne.status;
    if (xee.has(Ze)) {
      let Xe = Ne.headers.get("Location");
      if (Te(Xe, "Redirects returned/thrown from loaders/actions must have a Location header"), !hq.test(Xe))
        Xe = lk(new URL(oe.url), fe.slice(0, fe.indexOf(ae) + 1), we, !0, Xe);
      else if (!_e) {
        let ot = new URL(oe.url), pt = Xe.startsWith("//") ? new URL(ot.protocol + Xe) : new URL(Xe), ht = Ru(pt.pathname, we) != null;
        pt.origin === ot.origin && ht && (Xe = pt.pathname + pt.search + pt.hash);
      }
      if (_e)
        throw Ne.headers.set("Location", Xe), Ne;
      return { type: Gr.redirect, status: Ze, location: Xe, revalidate: Ne.headers.get("X-Remix-Revalidate") !== null };
    }
    if (Se)
      throw { type: $e || Gr.data, response: Ne };
    let qe, tt = Ne.headers.get("Content-Type");
    return tt && /\bapplication\/json\b/.test(tt) ? qe = await Ne.json() : qe = await Ne.text(), $e === Gr.error ? { type: $e, error: new rh(Ze, Ne.statusText, qe), headers: Ne.headers } : { type: Gr.data, data: qe, statusCode: Ne.status, headers: Ne.headers };
  }
  if ($e === Gr.error)
    return { type: $e, error: Ne };
  if (Dee(Ne)) {
    var ze, He;
    return { type: Gr.deferred, deferredData: Ne, statusCode: (ze = Ne.init) == null ? void 0 : ze.status, headers: ((He = Ne.init) == null ? void 0 : He.headers) && new Headers(Ne.init.headers) };
  }
  return { type: Gr.data, data: Ne };
}
function eh(ne, oe, ae, fe) {
  let ye = ne.createURL(Sq(oe)).toString(), ge = { signal: ae };
  if (fe && Eu(fe.formMethod)) {
    let { formMethod: we, formEncType: _e, formData: Se } = fe;
    ge.method = we.toUpperCase(), ge.body = _e === "application/x-www-form-urlencoded" ? bq(Se) : Se;
  }
  return new Request(ye, ge);
}
function bq(ne) {
  let oe = new URLSearchParams();
  for (let [ae, fe] of ne.entries())
    oe.append(ae, fe instanceof File ? fe.name : fe);
  return oe;
}
function Pee(ne, oe, ae, fe, ye) {
  let ge = {}, we = null, _e, Se = !1, Ie = {};
  return ae.forEach(($e, Ne) => {
    let Me = oe[Ne].route.id;
    if (Te(!dd($e), "Cannot handle redirect results in processLoaderData"), th($e)) {
      let Be = fd(ne, Me), ze = $e.error;
      fe && (ze = Object.values(fe)[0], fe = void 0), we = we || {}, we[Be.route.id] == null && (we[Be.route.id] = ze), ge[Me] = void 0, Se || (Se = !0, _e = ih($e.error) ? $e.error.status : 500), $e.headers && (Ie[Me] = $e.headers);
    } else
      lc($e) ? (ye.set(Me, $e.deferredData), ge[Me] = $e.deferredData.data) : ge[Me] = $e.data, $e.statusCode != null && $e.statusCode !== 200 && !Se && (_e = $e.statusCode), $e.headers && (Ie[Me] = $e.headers);
  }), fe && (we = fe, ge[Object.keys(fe)[0]] = void 0), { loaderData: ge, errors: we, statusCode: _e || 200, loaderHeaders: Ie };
}
function aq(ne, oe, ae, fe, ye, ge, we, _e) {
  let { loaderData: Se, errors: Ie } = Pee(oe, ae, fe, ye, _e);
  for (let $e = 0; $e < ge.length; $e++) {
    let { key: Ne, match: Me, controller: Be } = ge[$e];
    Te(we !== void 0 && we[$e] !== void 0, "Did not find corresponding fetcher result");
    let ze = we[$e];
    if (!(Be && Be.signal.aborted))
      if (th(ze)) {
        let He = fd(ne.matches, Me == null ? void 0 : Me.route.id);
        Ie && Ie[He.route.id] || (Ie = Tt({}, Ie, { [He.route.id]: ze.error })), ne.fetchers.delete(Ne);
      } else if (dd(ze))
        Te(!1, "Unhandled fetcher revalidation redirect");
      else if (lc(ze))
        Te(!1, "Unhandled fetcher deferred data");
      else {
        let He = { state: "idle", data: ze.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 };
        ne.fetchers.set(Ne, He);
      }
  }
  return { loaderData: Se, errors: Ie };
}
function oq(ne, oe, ae, fe) {
  let ye = Tt({}, oe);
  for (let ge of ae) {
    let we = ge.route.id;
    if (oe.hasOwnProperty(we) ? oe[we] !== void 0 && (ye[we] = oe[we]) : ne[we] !== void 0 && ge.route.loader && (ye[we] = ne[we]), fe && fe.hasOwnProperty(we))
      break;
  }
  return ye;
}
function fd(ne, oe) {
  return (oe ? ne.slice(0, ne.findIndex((ae) => ae.route.id === oe) + 1) : [...ne]).reverse().find((ae) => ae.route.hasErrorBoundary === !0) || ne[0];
}
function uq(ne) {
  let oe = ne.find((ae) => ae.index || !ae.path || ae.path === "/") || { id: "__shim-error-route__" };
  return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: oe }], route: oe };
}
function Wa(ne, oe) {
  let { pathname: ae, routeId: fe, method: ye, type: ge } = oe === void 0 ? {} : oe, we = "Unknown Server Error", _e = "Unknown @remix-run/router error";
  return ne === 400 ? (we = "Bad Request", ye && ae && fe ? _e = "You made a " + ye + ' request to "' + ae + '" but ' + ('did not provide a `loader` for route "' + fe + '", ') + "so there is no way to handle the request." : ge === "defer-action" && (_e = "defer() is not supported in actions")) : ne === 403 ? (we = "Forbidden", _e = 'Route "' + fe + '" does not match URL "' + ae + '"') : ne === 404 ? (we = "Not Found", _e = 'No route matches URL "' + ae + '"') : ne === 405 && (we = "Method Not Allowed", ye && ae && fe ? _e = "You made a " + ye.toUpperCase() + ' request to "' + ae + '" but ' + ('did not provide an `action` for route "' + fe + '", ') + "so there is no way to handle the request." : ye && (_e = 'Invalid request method "' + ye.toUpperCase() + '"')), new rh(ne || 500, we, new Error(_e), !0);
}
function lq(ne) {
  for (let oe = ne.length - 1; oe >= 0; oe--) {
    let ae = ne[oe];
    if (dd(ae))
      return ae;
  }
}
function Sq(ne) {
  let oe = typeof ne == "string" ? Qi(ne) : ne;
  return Mo(Tt({}, oe, { hash: "" }));
}
function Mee(ne, oe) {
  return ne.pathname === oe.pathname && ne.search === oe.search && ne.hash !== oe.hash;
}
function lc(ne) {
  return ne.type === Gr.deferred;
}
function th(ne) {
  return ne.type === Gr.error;
}
function dd(ne) {
  return (ne && ne.type) === Gr.redirect;
}
function Dee(ne) {
  let oe = ne;
  return oe && typeof oe == "object" && typeof oe.data == "object" && typeof oe.subscribe == "function" && typeof oe.cancel == "function" && typeof oe.resolveData == "function";
}
function Nee(ne) {
  return ne != null && typeof ne.status == "number" && typeof ne.statusText == "string" && typeof ne.headers == "object" && typeof ne.body < "u";
}
function Lee(ne) {
  return wee.has(ne.toLowerCase());
}
function Eu(ne) {
  return See.has(ne.toLowerCase());
}
async function sq(ne, oe, ae, fe, ye, ge) {
  for (let we = 0; we < ae.length; we++) {
    let _e = ae[we], Se = oe[we];
    if (!Se)
      continue;
    let Ie = ne.find((Ne) => Ne.route.id === Se.route.id), $e = Ie != null && !gq(Ie, Se) && (ge && ge[Se.route.id]) !== void 0;
    if (lc(_e) && (ye || $e)) {
      let Ne = fe[we];
      Te(Ne, "Expected an AbortSignal for revalidating fetcher deferred result"), await _q(_e, Ne, ye).then((Me) => {
        Me && (ae[we] = Me || ae[we]);
      });
    }
  }
}
async function _q(ne, oe, ae) {
  if (ae === void 0 && (ae = !1), !await ne.deferredData.resolveData(oe)) {
    if (ae)
      try {
        return { type: Gr.data, data: ne.deferredData.unwrappedData };
      } catch (fe) {
        return { type: Gr.error, error: fe };
      }
    return { type: Gr.data, data: ne.deferredData.data };
  }
}
function dk(ne) {
  return new URLSearchParams(ne).getAll("index").some((oe) => oe === "");
}
function cq(ne, oe) {
  let { route: ae, pathname: fe, params: ye } = ne;
  return { id: ae.id, pathname: fe, params: ye, data: oe[ae.id], handle: ae.handle };
}
function sk(ne, oe) {
  let ae = typeof oe == "string" ? Qi(oe).search : oe.search;
  if (ne[ne.length - 1].route.index && dk(ae || ""))
    return ne[ne.length - 1];
  let fe = nh(ne);
  return fe[fe.length - 1];
}
var pr, Gr, tee, iee, aee, oee, uee, lee, see, Zz, ha, yee, gee, bee, rh, mq, See, _ee, wee, xee, Eee, ok, Cee, eq, hq, yq, Ree, Oee, A0 = Y(() => {
  (function(ne) {
    ne.Pop = "POP", ne.Push = "PUSH", ne.Replace = "REPLACE";
  })(pr || (pr = {})), function(ne) {
    ne.data = "data", ne.deferred = "deferred", ne.redirect = "redirect", ne.error = "error";
  }(Gr || (Gr = {})), tee = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]), iee = /^:\w+$/, aee = 3, oee = 2, uee = 1, lee = 10, see = -2, Zz = (ne) => ne === "*", ha = (ne) => ne.join("/").replace(/\/\/+/g, "/"), yee = (ne) => ne.replace(/\/+$/, "").replace(/^\/*/, "/"), gee = (ne) => !ne || ne === "?" ? "" : ne.startsWith("?") ? ne : "?" + ne, bee = (ne) => !ne || ne === "#" ? "" : ne.startsWith("#") ? ne : "#" + ne, rh = class {
    constructor(ne, oe, ae, fe) {
      fe === void 0 && (fe = !1), this.status = ne, this.statusText = oe || "", this.internal = fe, ae instanceof Error ? (this.data = ae.toString(), this.error = ae) : this.data = ae;
    }
  }, mq = ["post", "put", "patch", "delete"], See = new Set(mq), _ee = ["get", ...mq], wee = new Set(_ee), xee = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Eee = /* @__PURE__ */ new Set([307, 308]), ok = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, Cee = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, eq = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, hq = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, yq = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ree = !yq, Oee = (ne) => ({ hasErrorBoundary: !!ne.hasErrorBoundary });
});
function ah() {
  return ah = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, ah.apply(this, arguments);
}
function hk(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe;
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useHref() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: fe, navigator: ye } = se.useContext(ya), { hash: ge, pathname: we, search: _e } = Fl(ne, { relative: ae }), Se = we;
  return fe !== "/" && (Se = we === "/" ? fe : ha([fe, we])), ye.createHref({ pathname: Se, search: _e, hash: ge });
}
function md() {
  return se.useContext(vd) != null;
}
function Ya() {
  return md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useLocation() may be used only in the context of a <Router> component.") : Te(!1)), se.useContext(vd).location;
}
function Rq(ne) {
  se.useContext(ya).static || se.useLayoutEffect(ne);
}
function Ou() {
  return se.useContext(Ul) != null ? Kee() : Iee();
}
function Iee() {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useNavigate() may be used only in the context of a <Router> component.") : Te(!1));
  let { basename: ne, navigator: oe } = se.useContext(ya), { matches: ae } = se.useContext(ga), { pathname: fe } = Ya(), ye = JSON.stringify(nh(ae).map((we) => we.pathnameBase)), ge = se.useRef(!1);
  return Rq(() => {
    ge.current = !0;
  }), se.useCallback(function(we, _e) {
    if (_e === void 0 && (_e = {}), process.env.NODE_ENV !== "production" && ln(ge.current, Cq), !ge.current)
      return;
    if (typeof we == "number") {
      oe.go(we);
      return;
    }
    let Se = k0(we, JSON.parse(ye), fe, _e.relative === "path");
    ne !== "/" && (Se.pathname = Se.pathname === "/" ? ne : ha([ne, Se.pathname])), (_e.replace ? oe.replace : oe.push)(Se, _e.state, _e);
  }, [ne, oe, ye, fe]);
}
function Oq(ne) {
  let oe = se.useContext(ga).outlet;
  return oe && se.createElement(Bee.Provider, { value: ne }, oe);
}
function Tu() {
  let { matches: ne } = se.useContext(ga), oe = ne[ne.length - 1];
  return oe ? oe.params : {};
}
function Fl(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { matches: fe } = se.useContext(ga), { pathname: ye } = Ya(), ge = JSON.stringify(nh(fe).map((we) => we.pathnameBase));
  return se.useMemo(() => k0(ne, JSON.parse(ge), ye, ae === "path"), [ne, ge, ye, ae]);
}
function Hee(ne, oe, ae) {
  md() || (process.env.NODE_ENV !== "production" ? Te(!1, "useRoutes() may be used only in the context of a <Router> component.") : Te(!1));
  let { navigator: fe } = se.useContext(ya), { matches: ye } = se.useContext(ga), ge = ye[ye.length - 1], we = ge ? ge.params : {}, _e = ge ? ge.pathname : "/", Se = ge ? ge.pathnameBase : "/", Ie = ge && ge.route;
  if (process.env.NODE_ENV !== "production") {
    let qe = Ie && Ie.path || "";
    Xee(_e, !Ie || qe.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + _e + '" (under <Route path="' + qe + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + qe + '"> to <Route ') + ('path="' + (qe === "/" ? "*" : qe + "/*") + '">.'));
  }
  let $e = Ya(), Ne;
  if (oe) {
    var Me;
    let qe = typeof oe == "string" ? Qi(oe) : oe;
    Se === "/" || (Me = qe.pathname) != null && Me.startsWith(Se) || (process.env.NODE_ENV !== "production" ? Te(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + Se + '" ') + ('but pathname "' + qe.pathname + '" was given in the `location` prop.')) : Te(!1)), Ne = qe;
  } else
    Ne = $e;
  let Be = Ne.pathname || "/", ze = Se === "/" ? Be : Be.slice(Se.length) || "/", He = Cu(ne, { pathname: ze });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && ln(Ie || He != null, 'No routes matched location "' + Ne.pathname + Ne.search + Ne.hash + '" '), process.env.NODE_ENV !== "production" && ln(He == null || He[He.length - 1].route.element !== void 0 || He[He.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + Ne.pathname + Ne.search + Ne.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let Ze = Yee(He && He.map((qe) => Object.assign({}, qe, { params: Object.assign({}, we, qe.params), pathname: ha([Se, fe.encodeLocation ? fe.encodeLocation(qe.pathname).pathname : qe.pathname]), pathnameBase: qe.pathnameBase === "/" ? Se : ha([Se, fe.encodeLocation ? fe.encodeLocation(qe.pathnameBase).pathname : qe.pathnameBase]) })), ye, ae);
  return oe && Ze ? se.createElement(vd.Provider, { value: { location: ah({ pathname: "/", search: "", hash: "", state: null, key: "default" }, Ne), navigationType: pr.Pop } }, Ze) : Ze;
}
function Vee() {
  let ne = P0(), oe = ih(ne) ? ne.status + " " + ne.statusText : ne instanceof Error ? ne.message : JSON.stringify(ne), ae = ne instanceof Error ? ne.stack : null, fe = "rgba(200,200,200, 0.5)", ye = { padding: "0.5rem", backgroundColor: fe }, ge = { padding: "2px 4px", backgroundColor: fe }, we = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", ne), we = se.createElement(se.Fragment, null, se.createElement("p", null, "💿 Hey developer 👋"), se.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", se.createElement("code", { style: ge }, "ErrorBoundary"), " or", " ", se.createElement("code", { style: ge }, "errorElement"), " prop on your route."))), se.createElement(se.Fragment, null, se.createElement("h2", null, "Unexpected Application Error!"), se.createElement("h3", { style: { fontStyle: "italic" } }, oe), ae ? se.createElement("pre", { style: ye }, ae) : null, we);
}
function Wee(ne) {
  let { routeContext: oe, match: ae, children: fe } = ne, ye = se.useContext(Ul);
  return ye && ye.static && ye.staticContext && (ae.route.errorElement || ae.route.ErrorBoundary) && (ye.staticContext._deepestRenderedBoundaryId = ae.route.id), se.createElement(ga.Provider, { value: oe }, fe);
}
function Yee(ne, oe, ae) {
  var fe;
  if (oe === void 0 && (oe = []), ae === void 0 && (ae = null), ne == null) {
    var ye;
    if ((ye = ae) != null && ye.errors)
      ne = ae.matches;
    else
      return null;
  }
  let ge = ne, we = (fe = ae) == null ? void 0 : fe.errors;
  if (we != null) {
    let _e = ge.findIndex((Se) => Se.route.id && (we == null ? void 0 : we[Se.route.id]));
    _e >= 0 || (process.env.NODE_ENV !== "production" ? Te(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(we).join(",")) : Te(!1)), ge = ge.slice(0, Math.min(ge.length, _e + 1));
  }
  return ge.reduceRight((_e, Se, Ie) => {
    let $e = Se.route.id ? we == null ? void 0 : we[Se.route.id] : null, Ne = null;
    ae && (Ne = Se.route.errorElement || $ee);
    let Me = oe.concat(ge.slice(0, Ie + 1)), Be = () => {
      let ze;
      return $e ? ze = Ne : Se.route.element ? ze = Se.route.element : ze = _e, se.createElement(Wee, { match: Se, routeContext: { outlet: _e, matches: Me }, children: ze });
    };
    return ae && (Se.route.ErrorBoundary || Se.route.errorElement || Ie === 0) ? se.createElement(pk, { location: ae.location, revalidation: ae.revalidation, component: Ne, error: $e, children: Be(), routeContext: { outlet: null, matches: Me } }) : Be();
  }, null);
}
function yk(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Gee(ne) {
  let oe = se.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function gk(ne) {
  let oe = se.useContext(sc);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function Qee(ne) {
  let oe = se.useContext(ga);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, yk(ne)) : Te(!1)), oe;
}
function bk(ne) {
  let oe = Qee(ne), ae = oe.matches[oe.matches.length - 1];
  return ae.route.id || (process.env.NODE_ENV !== "production" ? Te(!1, ne + ' can only be used on routes that contain a unique "id"') : Te(!1)), ae.route.id;
}
function Sk() {
  return bk(jl.UseRouteId);
}
function P0() {
  var ne;
  let oe = se.useContext(mk), ae = gk(jl.UseRouteError), fe = bk(jl.UseRouteError);
  return oe || ((ne = ae.errors) == null ? void 0 : ne[fe]);
}
function Kee() {
  let { router: ne } = Gee(vk.UseNavigateStable), oe = bk(jl.UseNavigateStable), ae = se.useRef(!1);
  return Rq(() => {
    ae.current = !0;
  }), se.useCallback(function(fe, ye) {
    ye === void 0 && (ye = {}), process.env.NODE_ENV !== "production" && ln(ae.current, Cq), ae.current && (typeof fe == "number" ? ne.navigate(fe) : ne.navigate(fe, ah({ fromRouteId: oe }, ye)));
  }, [ne, oe]);
}
function Xee(ne, oe, ae) {
  !oe && !wq[ne] && (wq[ne] = !0, process.env.NODE_ENV !== "production" && ln(!1, ae));
}
function xk(ne) {
  let { fallbackElement: oe, router: ae } = ne, [fe, ye] = se.useState(ae.state);
  se.useLayoutEffect(() => ae.subscribe(ye), [ae, ye]);
  let ge = se.useMemo(() => ({ createHref: ae.createHref, encodeLocation: ae.encodeLocation, go: (Se) => ae.navigate(Se), push: (Se, Ie, $e) => ae.navigate(Se, { state: Ie, preventScrollReset: $e == null ? void 0 : $e.preventScrollReset }), replace: (Se, Ie, $e) => ae.navigate(Se, { replace: !0, state: Ie, preventScrollReset: $e == null ? void 0 : $e.preventScrollReset }) }), [ae]), we = ae.basename || "/", _e = se.useMemo(() => ({ router: ae, navigator: ge, static: !1, basename: we }), [ae, ge, we]);
  return se.createElement(se.Fragment, null, se.createElement(Ul.Provider, { value: _e }, se.createElement(sc.Provider, { value: fe }, se.createElement(M0, { basename: ae.basename, location: ae.state.location, navigationType: ae.state.historyAction, navigator: ge }, ae.state.initialized ? se.createElement(Jee, { routes: ae.routes, state: fe }) : oe))), null);
}
function Jee(ne) {
  let { routes: oe, state: ae } = ne;
  return Hee(oe, void 0, ae);
}
function cc(ne) {
  return Oq(ne.context);
}
function Ga(ne) {
  process.env.NODE_ENV !== "production" ? Te(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : Te(!1);
}
function M0(ne) {
  let { basename: oe = "/", children: ae = null, location: fe, navigationType: ye = pr.Pop, navigator: ge, static: we = !1 } = ne;
  md() && (process.env.NODE_ENV !== "production" ? Te(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Te(!1));
  let _e = oe.replace(/^\/*/, "/"), Se = se.useMemo(() => ({ basename: _e, navigator: ge, static: we }), [_e, ge, we]);
  typeof fe == "string" && (fe = Qi(fe));
  let { pathname: Ie = "/", search: $e = "", hash: Ne = "", state: Me = null, key: Be = "default" } = fe, ze = se.useMemo(() => {
    let He = Ru(Ie, _e);
    return He == null ? null : { location: { pathname: He, search: $e, hash: Ne, state: Me, key: Be }, navigationType: ye };
  }, [_e, Ie, $e, Ne, Me, Be, ye]);
  return process.env.NODE_ENV !== "production" && ln(ze != null, '<Router basename="' + _e + '"> is not able to match the URL ' + ('"' + Ie + $e + Ne + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), ze == null ? null : se.createElement(ya.Provider, { value: Se }, se.createElement(vd.Provider, { children: ae, value: ze }));
}
function pd(ne, oe) {
  oe === void 0 && (oe = []);
  let ae = [];
  return se.Children.forEach(ne, (fe, ye) => {
    if (!se.isValidElement(fe))
      return;
    let ge = [...oe, ye];
    if (fe.type === se.Fragment) {
      ae.push.apply(ae, pd(fe.props.children, ge));
      return;
    }
    fe.type !== Ga && (process.env.NODE_ENV !== "production" ? Te(!1, "[" + (typeof fe.type == "string" ? fe.type : fe.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : Te(!1)), !fe.props.index || !fe.props.children || (process.env.NODE_ENV !== "production" ? Te(!1, "An index route cannot have child routes.") : Te(!1));
    let we = { id: fe.props.id || ge.join("-"), caseSensitive: fe.props.caseSensitive, element: fe.props.element, Component: fe.props.Component, index: fe.props.index, path: fe.props.path, loader: fe.props.loader, action: fe.props.action, errorElement: fe.props.errorElement, ErrorBoundary: fe.props.ErrorBoundary, hasErrorBoundary: fe.props.ErrorBoundary != null || fe.props.errorElement != null, shouldRevalidate: fe.props.shouldRevalidate, handle: fe.props.handle, lazy: fe.props.lazy };
    fe.props.children && (we.children = pd(fe.props.children, ge)), ae.push(we);
  }), ae;
}
function Tq(ne) {
  let oe = { hasErrorBoundary: ne.ErrorBoundary != null || ne.errorElement != null };
  return ne.Component && (process.env.NODE_ENV !== "production" && ne.element && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(oe, { element: se.createElement(ne.Component), Component: void 0 })), ne.ErrorBoundary && (process.env.NODE_ENV !== "production" && ne.errorElement && process.env.NODE_ENV !== "production" && ln(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(oe, { errorElement: se.createElement(ne.ErrorBoundary), ErrorBoundary: void 0 })), oe;
}
function Ek(ne, oe) {
  return fk({ basename: oe == null ? void 0 : oe.basename, future: ah({}, oe == null ? void 0 : oe.future, { v7_prependBasename: !0 }), history: fq({ initialEntries: oe == null ? void 0 : oe.initialEntries, initialIndex: oe == null ? void 0 : oe.initialIndex }), hydrationData: oe == null ? void 0 : oe.hydrationData, routes: ne, mapRouteProperties: Tq }).initialize();
}
var se, Ul, sc, qee, ya, vd, ga, mk, Cq, Bee, $ee, pk, vk, jl, wq, xq, Ck = Y(() => {
  se = le(ir()), A0(), A0(), Ul = se.createContext(null), process.env.NODE_ENV !== "production" && (Ul.displayName = "DataRouter"), sc = se.createContext(null), process.env.NODE_ENV !== "production" && (sc.displayName = "DataRouterState"), qee = se.createContext(null), process.env.NODE_ENV !== "production" && (qee.displayName = "Await"), ya = se.createContext(null), process.env.NODE_ENV !== "production" && (ya.displayName = "Navigation"), vd = se.createContext(null), process.env.NODE_ENV !== "production" && (vd.displayName = "Location"), ga = se.createContext({ outlet: null, matches: [] }), process.env.NODE_ENV !== "production" && (ga.displayName = "Route"), mk = se.createContext(null), process.env.NODE_ENV !== "production" && (mk.displayName = "RouteError"), Cq = "You should call navigate() in a React.useEffect(), not when your component is first rendered.", Bee = se.createContext(null), $ee = se.createElement(Vee, null), pk = class extends se.Component {
    constructor(ne) {
      super(ne), this.state = { location: ne.location, revalidation: ne.revalidation, error: ne.error };
    }
    static getDerivedStateFromError(ne) {
      return { error: ne };
    }
    static getDerivedStateFromProps(ne, oe) {
      return oe.location !== ne.location || oe.revalidation !== "idle" && ne.revalidation === "idle" ? { error: ne.error, location: ne.location, revalidation: ne.revalidation } : { error: ne.error || oe.error, location: oe.location, revalidation: ne.revalidation || oe.revalidation };
    }
    componentDidCatch(ne, oe) {
      console.error("React Router caught the following error during render", ne, oe);
    }
    render() {
      return this.state.error ? se.createElement(ga.Provider, { value: this.props.routeContext }, se.createElement(mk.Provider, { value: this.state.error, children: this.props.component })) : this.props.children;
    }
  }, function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate";
  }(vk || (vk = {})), function(ne) {
    ne.UseBlocker = "useBlocker", ne.UseLoaderData = "useLoaderData", ne.UseActionData = "useActionData", ne.UseRouteError = "useRouteError", ne.UseNavigation = "useNavigation", ne.UseRouteLoaderData = "useRouteLoaderData", ne.UseMatches = "useMatches", ne.UseRevalidator = "useRevalidator", ne.UseNavigateStable = "useNavigate", ne.UseRouteId = "useRouteId";
  }(jl || (jl = {})), wq = {}, function(ne) {
    ne[ne.pending = 0] = "pending", ne[ne.success = 1] = "success", ne[ne.error = 2] = "error";
  }(xq || (xq = {})), new Promise(() => {
  });
});
function zl() {
  return zl = Object.assign ? Object.assign.bind() : function(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ae = arguments[oe];
      for (var fe in ae)
        Object.prototype.hasOwnProperty.call(ae, fe) && (ne[fe] = ae[fe]);
    }
    return ne;
  }, zl.apply(this, arguments);
}
function Tk(ne, oe) {
  if (ne == null)
    return {};
  var ae = {}, fe = Object.keys(ne), ye, ge;
  for (ge = 0; ge < fe.length; ge++)
    ye = fe[ge], !(oe.indexOf(ye) >= 0) && (ae[ye] = ne[ye]);
  return ae;
}
function j0(ne) {
  return ne != null && typeof ne.tagName == "string";
}
function ete(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "button";
}
function tte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "form";
}
function rte(ne) {
  return j0(ne) && ne.tagName.toLowerCase() === "input";
}
function nte(ne) {
  return !!(ne.metaKey || ne.altKey || ne.ctrlKey || ne.shiftKey);
}
function ite(ne, oe) {
  return ne.button === 0 && (!oe || oe === "_self") && !nte(ne);
}
function ate(ne, oe, ae) {
  let fe, ye = null, ge, we;
  if (tte(ne)) {
    let _e = oe.submissionTrigger;
    if (oe.action)
      ye = oe.action;
    else {
      let Se = ne.getAttribute("action");
      ye = Se ? Ru(Se, ae) : null;
    }
    fe = oe.method || ne.getAttribute("method") || N0, ge = oe.encType || ne.getAttribute("enctype") || Rk, we = new FormData(ne), _e && _e.name && we.append(_e.name, _e.value);
  } else if (ete(ne) || rte(ne) && (ne.type === "submit" || ne.type === "image")) {
    let _e = ne.form;
    if (_e == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    if (oe.action)
      ye = oe.action;
    else {
      let Se = ne.getAttribute("formaction") || _e.getAttribute("action");
      ye = Se ? Ru(Se, ae) : null;
    }
    fe = oe.method || ne.getAttribute("formmethod") || _e.getAttribute("method") || N0, ge = oe.encType || ne.getAttribute("formenctype") || _e.getAttribute("enctype") || Rk, we = new FormData(_e), ne.name && we.append(ne.name, ne.value);
  } else {
    if (j0(ne))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    if (fe = oe.method || N0, ye = oe.action || null, ge = oe.encType || Rk, ne instanceof FormData)
      we = ne;
    else if (we = new FormData(), ne instanceof URLSearchParams)
      for (let [_e, Se] of ne)
        we.append(_e, Se);
    else if (ne != null)
      for (let _e of Object.keys(ne))
        we.append(_e, ne[_e]);
  }
  return { action: ye, method: fe.toLowerCase(), encType: ge, formData: we };
}
function Mq(ne) {
  return ne + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Dq(ne) {
  let oe = ft.useContext(Ul);
  return oe || (process.env.NODE_ENV !== "production" ? Te(!1, Mq(ne)) : Te(!1)), oe;
}
function hte(ne, oe) {
  let { target: ae, replace: fe, state: ye, preventScrollReset: ge, relative: we } = oe === void 0 ? {} : oe, _e = Ou(), Se = Ya(), Ie = Fl(ne, { relative: we });
  return ft.useCallback(($e) => {
    if (ite($e, ae)) {
      $e.preventDefault();
      let Ne = fe !== void 0 ? fe : Mo(Se) === Mo(Ie);
      _e(ne, { replace: Ne, state: ye, preventScrollReset: ge, relative: we });
    }
  }, [Se, _e, Ie, fe, ye, ae, ne, ge, we]);
}
function yte(ne, oe) {
  let { router: ae } = Dq(L0.UseSubmitImpl), { basename: fe } = ft.useContext(ya), ye = Sk();
  return ft.useCallback(function(ge, we) {
    if (we === void 0 && (we = {}), typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let { action: _e, method: Se, encType: Ie, formData: $e } = ate(ge, we, fe), Ne = { preventScrollReset: we.preventScrollReset, formData: $e, formMethod: Se, formEncType: Ie };
    ne ? (oe == null && (process.env.NODE_ENV !== "production" ? Te(!1, "No routeId available for useFetcher()") : Te(!1)), ae.fetch(ne, oe, _e, Ne)) : ae.navigate(_e, zl({}, Ne, { replace: we.replace, fromRouteId: ye }));
  }, [ae, fe, ne, oe, ye]);
}
function gte(ne, oe) {
  let { relative: ae } = oe === void 0 ? {} : oe, { basename: fe } = ft.useContext(ya), ye = ft.useContext(ga);
  ye || (process.env.NODE_ENV !== "production" ? Te(!1, "useFormAction must be used inside a RouteContext") : Te(!1));
  let [ge] = ye.matches.slice(-1), we = zl({}, Fl(ne || ".", { relative: ae })), _e = Ya();
  if (ne == null && (we.search = _e.search, we.hash = _e.hash, ge.route.index)) {
    let Se = new URLSearchParams(we.search);
    Se.delete("index"), we.search = Se.toString() ? "?" + Se.toString() : "";
  }
  return (!ne || ne === ".") && ge.route.index && (we.search = we.search ? we.search.replace(/^\?/, "?index&") : "?index"), fe !== "/" && (we.pathname = we.pathname === "/" ? fe : ha([fe, we.pathname])), Mo(we);
}
var ft, N0, Rk, ote, ute, lte, cte, fte, Aq, dte, pte, Pq, L0, Ok, Do = Y(() => {
  ft = le(ir()), Ck(), Ck(), A0(), N0 = "get", Rk = "application/x-www-form-urlencoded", ote = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], ute = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], lte = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"], process.env.NODE_ENV, cte = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", fte = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Aq = ft.forwardRef(function(ne, oe) {
    let { onClick: ae, relative: fe, reloadDocument: ye, replace: ge, state: we, target: _e, to: Se, preventScrollReset: Ie } = ne, $e = Tk(ne, ote), { basename: Ne } = ft.useContext(ya), Me, Be = !1;
    if (typeof Se == "string" && fte.test(Se) && (Me = Se, cte))
      try {
        let qe = new URL(window.location.href), tt = Se.startsWith("//") ? new URL(qe.protocol + Se) : new URL(Se), Xe = Ru(tt.pathname, Ne);
        tt.origin === qe.origin && Xe != null ? Se = Xe + tt.search + tt.hash : Be = !0;
      } catch {
        process.env.NODE_ENV !== "production" && ln(!1, '<Link to="' + Se + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
      }
    let ze = hk(Se, { relative: fe }), He = hte(Se, { replace: ge, state: we, target: _e, preventScrollReset: Ie, relative: fe });
    function Ze(qe) {
      ae && ae(qe), qe.defaultPrevented || He(qe);
    }
    return ft.createElement("a", zl({}, $e, { href: Me || ze, onClick: Be || ye ? ae : Ze, ref: oe, target: _e }));
  }), process.env.NODE_ENV !== "production" && (Aq.displayName = "Link"), dte = ft.forwardRef(function(ne, oe) {
    let { "aria-current": ae = "page", caseSensitive: fe = !1, className: ye = "", end: ge = !1, style: we, to: _e, children: Se } = ne, Ie = Tk(ne, ute), $e = Fl(_e, { relative: Ie.relative }), Ne = Ya(), Me = ft.useContext(sc), { navigator: Be } = ft.useContext(ya), ze = Be.encodeLocation ? Be.encodeLocation($e).pathname : $e.pathname, He = Ne.pathname, Ze = Me && Me.navigation && Me.navigation.location ? Me.navigation.location.pathname : null;
    fe || (He = He.toLowerCase(), Ze = Ze ? Ze.toLowerCase() : null, ze = ze.toLowerCase());
    let qe = He === ze || !ge && He.startsWith(ze) && He.charAt(ze.length) === "/", tt = Ze != null && (Ze === ze || !ge && Ze.startsWith(ze) && Ze.charAt(ze.length) === "/"), Xe = qe ? ae : void 0, ot;
    typeof ye == "function" ? ot = ye({ isActive: qe, isPending: tt }) : ot = [ye, qe ? "active" : null, tt ? "pending" : null].filter(Boolean).join(" ");
    let pt = typeof we == "function" ? we({ isActive: qe, isPending: tt }) : we;
    return ft.createElement(Aq, zl({}, Ie, { "aria-current": Xe, className: ot, ref: oe, style: pt, to: _e }), typeof Se == "function" ? Se({ isActive: qe, isPending: tt }) : Se);
  }), process.env.NODE_ENV !== "production" && (dte.displayName = "NavLink"), pte = ft.forwardRef((ne, oe) => ft.createElement(Pq, zl({}, ne, { ref: oe }))), process.env.NODE_ENV !== "production" && (pte.displayName = "Form"), Pq = ft.forwardRef((ne, oe) => {
    let { reloadDocument: ae, replace: fe, method: ye = N0, action: ge, onSubmit: we, fetcherKey: _e, routeId: Se, relative: Ie, preventScrollReset: $e } = ne, Ne = Tk(ne, lte), Me = yte(_e, Se), Be = ye.toLowerCase() === "get" ? "get" : "post", ze = gte(ge, { relative: Ie });
    return ft.createElement("form", zl({ ref: oe, method: Be, action: ze, onSubmit: ae ? we : (He) => {
      if (we && we(He), He.defaultPrevented)
        return;
      He.preventDefault();
      let Ze = He.nativeEvent.submitter, qe = (Ze == null ? void 0 : Ze.getAttribute("formmethod")) || ye;
      Me(Ze || He.currentTarget, { method: qe, replace: fe, relative: Ie, preventScrollReset: $e });
    } }, Ne));
  }), process.env.NODE_ENV !== "production" && (Pq.displayName = "FormImpl"), process.env.NODE_ENV, function(ne) {
    ne.UseScrollRestoration = "useScrollRestoration", ne.UseSubmitImpl = "useSubmitImpl", ne.UseFetcher = "useFetcher";
  }(L0 || (L0 = {})), function(ne) {
    ne.UseFetchers = "useFetchers", ne.UseScrollRestoration = "useScrollRestoration";
  }(Ok || (Ok = {}));
});
function sn({ to: ne, className: oe, type: ae, onClick: fe, ...ye }) {
  let ge = Ou(), we = Fl(ne), _e = Ya(), Se = we.pathname, Ie = _e.pathname, $e = Ie === Se || Ie.startsWith(Se) && Ie.charAt(Se.length) === "/";
  return (0, Nq.jsx)("button", { type: ae || "button", className: typeof oe == "function" ? oe({ isActive: $e }) : oe, onClick: (Ne) => {
    ge(ne), fe == null || fe(Ne);
  }, ...ye });
}
var Nq, ql = Y(() => {
  Do(), Nq = le(ke(), 1);
}), Lq = {};
Uj(Lq, { DevToolsProvider: () => _te, useDevToolsContext: () => zt });
var Qa, jq, kk, _te, zt, ai = Y(() => {
  Qa = le(ir(), 1), jq = le(ke(), 1), kk = (0, Qa.createContext)(null), _te = ({ children: ne, value: oe }) => {
    if ((0, Qa.useContext)(kk))
      throw new Error("DevToolsProvider can only be used once");
    let [ae, fe] = (0, Qa.useState)([]);
    (0, Qa.useEffect)(() => {
      let we = oe.write$.subscribe((_e) => {
        fe((Se) => [...Se, _e]);
      });
      return () => we.unsubscribe();
    }, [oe.write$]);
    let [ye, ge] = (0, Qa.useState)([]);
    return (0, Qa.useEffect)(() => {
      let we = oe.storedBlockLogs$.subscribe(({ logs: _e }) => {
        ge((Se) => [...Se, ..._e]);
      });
      return () => we.unsubscribe();
    }, [oe.storedBlockLogs$]), (0, jq.jsx)(kk.Provider, { value: { ...oe, writes: ae, storedLogs: ye }, children: ne });
  }, zt = () => {
    let ne = (0, Qa.useContext)(kk);
    if (!ne)
      throw new Error("Must be used within a DevToolsProvider");
    return ne;
  };
});
function Uq() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Ki.jsxs)(Ki.Fragment, { children: [(0, Ki.jsxs)("div", { className: "flex-none bg-slate-900 text-white/60 font-medium", children: [(0, Ki.jsx)(sn, { to: "/", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Summary" }), (0, Ki.jsx)(sn, { to: "/actions", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Actions" }), (0, Ki.jsx)(sn, { to: "/events", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Store log" }), oe ? (0, Ki.jsx)(sn, { to: "/tables", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Tables" }) : null, ne ? (0, Ki.jsx)(sn, { to: "/components", className: ({ isActive: ae }) => Pr("py-1.5 px-3", ae ? "bg-slate-800 text-white" : "hover:bg-blue-800 hover:text-white"), children: "Components" }) : null] }), (0, Ki.jsx)("div", { className: "flex-1 overflow-auto", children: (0, Ki.jsx)(cc, {}) })] });
}
var Ki, Fq = Y(() => {
  uc(), Do(), ql(), ai(), Ki = le(ke(), 1);
});
function U0({ error: ne }) {
  return (0, zq.jsx)("div", { className: "font-mono text-xs whitespace-pre overflow-auto bg-red-900/50 text-white p-4 rounded", children: ne instanceof Error ? ne.stack : String(ne) });
}
var zq, Ak = Y(() => {
  zq = le(ke(), 1);
});
function qq() {
  let ne = P0();
  return (0, hd.jsxs)("div", { className: "p-6 space-y-6", children: [(0, hd.jsxs)("p", { children: ["Whoops, something broke! Please", " ", (0, hd.jsx)("a", { href: `https://github.com/latticexyz/mud/issues/new?${new URLSearchParams({ body: `
**Steps to reproduce**

1. Go to …
2. Click on …
3. Scroll down to …
4. See error

**Expected behavior**

A clear and concise description of what you expected to happen.

**Error**
\`\`\`
${ne instanceof Error ? ne.stack : String(ne)}
\`\`\`
` })}`, target: "_blank", className: "text-white underline", children: "report the issue" }), " ", "so we can look into it."] }), (0, hd.jsx)(U0, { error: ne })] });
}
var hd, Iq = Y(() => {
  Do(), Ak(), hd = le(ke(), 1);
});
function Bq({ type: ne }) {
  switch (ne) {
    case "Store_SetRecord":
      return (0, F0.jsx)("span", { className: "text-green-500 font-bold", children: "=" });
    case "Store_SpliceStaticData":
    case "Store_SpliceDynamicData":
      return (0, F0.jsx)("span", { className: "text-cyan-500 font-bold", children: "+" });
    case "Store_DeleteRecord":
      return (0, F0.jsx)("span", { className: "text-red-500 font-bold", children: "-" });
    default:
      return u$3(ne, `Unexpected event type: ${ne}`);
  }
}
var F0, Hq = Y(() => {
  F0 = le(ke(), 1);
});
function z0({ logs: ne }) {
  return (0, cn.jsxs)("table", { className: "w-full table-fixed -mx-1", children: [(0, cn.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-amber-200/80 text-left", children: (0, cn.jsxs)("tr", { children: [(0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "block" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "table" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-2/12", children: "key" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs w-[1em]" }), (0, cn.jsx)("th", { className: "px-1 pt-1.5 pb-0.5 font-semibold uppercase text-xs", children: "value" })] }) }), (0, cn.jsx)("tbody", { className: "font-mono text-xs", children: ne.map((oe) => {
    var ge;
    let ae = _$2(oe.args.tableId), { namespace: fe, name: ye } = ae;
    return (0, cn.jsxs)("tr", { className: "hover:bg-blue-800", children: [(0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis text-white/40", children: (ge = oe.blockNumber) == null ? void 0 : ge.toString() }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: i$2(ae) }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: oe.args.keyTuple.join(",") }), (0, cn.jsx)("td", { className: "px-1 whitespace-nowrap", children: (0, cn.jsx)(Bq, { type: oe.eventName }) }), (0, cn.jsxs)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: [oe.eventName === "Store_SetRecord" ? JSON.stringify({ staticData: oe.args.staticData, encodedLengths: oe.args.encodedLengths, dynamicData: oe.args.dynamicData }) : null, oe.eventName === "Store_SpliceStaticData" ? JSON.stringify({ start: oe.args.start, data: oe.args.data }) : null, oe.eventName === "Store_SpliceDynamicData" ? JSON.stringify({ start: oe.args.start, deleteCount: oe.args.deleteCount, encodedLengths: oe.args.encodedLengths, data: oe.args.data }) : null] })] }, oe.blockHash != null && oe.logIndex != null ? `${oe.blockHash}:${oe.logIndex}` : `${fe}:${ye}:${oe.args.keyTuple.join(",")}`);
  }) })] });
}
var cn, Pk = Y(() => {
  Hq(), cn = le(ke(), 1);
});
function Vq() {
  let { storedLogs: ne } = zt(), oe = (0, yd.useRef)(null), ae = (0, yd.useRef)(!1), fe = (0, yd.useRef)("auto");
  return (0, yd.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, Mk.jsx)("div", { ref: oe, className: "px-2 pb-1", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: (0, Mk.jsx)(z0, { logs: ne }) });
}
var yd, Mk, $q = Y(() => {
  yd = le(ir(), 1), ai(), Pk(), Mk = le(ke(), 1);
}), Dk = M((ne, oe) => {
  oe.exports = function ae(fe, ye) {
    if (fe === ye)
      return !0;
    if (fe && ye && typeof fe == "object" && typeof ye == "object") {
      if (fe.constructor !== ye.constructor)
        return !1;
      var ge, we, _e;
      if (Array.isArray(fe)) {
        if (ge = fe.length, ge != ye.length)
          return !1;
        for (we = ge; we-- !== 0; )
          if (!ae(fe[we], ye[we]))
            return !1;
        return !0;
      }
      if (fe.constructor === RegExp)
        return fe.source === ye.source && fe.flags === ye.flags;
      if (fe.valueOf !== Object.prototype.valueOf)
        return fe.valueOf() === ye.valueOf();
      if (fe.toString !== Object.prototype.toString)
        return fe.toString() === ye.toString();
      if (_e = Object.keys(fe), ge = _e.length, ge !== Object.keys(ye).length)
        return !1;
      for (we = ge; we-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(ye, _e[we]))
          return !1;
      for (we = ge; we-- !== 0; ) {
        var Se = _e[we];
        if (!ae(fe[Se], ye[Se]))
          return !1;
      }
      return !0;
    }
    return fe !== fe && ye !== ye;
  };
}), Mt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isFunction = void 0;
  function oe(ae) {
    return typeof ae == "function";
  }
  ne.isFunction = oe;
}), Il = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createErrorClass = void 0;
  function oe(ae) {
    var fe = function(ge) {
      Error.call(ge), ge.stack = new Error().stack;
    }, ye = ae(fe);
    return ye.prototype = Object.create(Error.prototype), ye.prototype.constructor = ye, ye;
  }
  ne.createErrorClass = oe;
}), Nk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.UnsubscriptionError = void 0;
  var oe = Il();
  ne.UnsubscriptionError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.message = fe ? fe.length + ` errors occurred during unsubscription:
` + fe.map(function(ye, ge) {
        return ge + 1 + ") " + ye.toString();
      }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = fe;
    };
  });
}), ku = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.arrRemove = void 0;
  function oe(ae, fe) {
    if (ae) {
      var ye = ae.indexOf(fe);
      0 <= ye && ae.splice(ye, 1);
    }
  }
  ne.arrRemove = oe;
}), Oi = M((ne) => {
  var oe = ne && ne.__values || function($e) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, Me = Ne && $e[Ne], Be = 0;
    if (Me)
      return Me.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && Be >= $e.length && ($e = void 0), { value: $e && $e[Be++], done: !$e };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }, ae = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, fe = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isSubscription = ne.EMPTY_SUBSCRIPTION = ne.Subscription = void 0;
  var ye = Mt(), ge = Nk(), we = ku(), _e = function() {
    function $e(Ne) {
      this.initialTeardown = Ne, this.closed = !1, this._parentage = null, this._finalizers = null;
    }
    return $e.prototype.unsubscribe = function() {
      var Ne, Me, Be, ze, He;
      if (!this.closed) {
        this.closed = !0;
        var Ze = this._parentage;
        if (Ze)
          if (this._parentage = null, Array.isArray(Ze))
            try {
              for (var qe = oe(Ze), tt = qe.next(); !tt.done; tt = qe.next()) {
                var Xe = tt.value;
                Xe.remove(this);
              }
            } catch (It) {
              Ne = { error: It };
            } finally {
              try {
                tt && !tt.done && (Me = qe.return) && Me.call(qe);
              } finally {
                if (Ne)
                  throw Ne.error;
              }
            }
          else
            Ze.remove(this);
        var ot = this.initialTeardown;
        if (ye.isFunction(ot))
          try {
            ot();
          } catch (It) {
            He = It instanceof ge.UnsubscriptionError ? It.errors : [It];
          }
        var pt = this._finalizers;
        if (pt) {
          this._finalizers = null;
          try {
            for (var ht = oe(pt), wt = ht.next(); !wt.done; wt = ht.next()) {
              var gt = wt.value;
              try {
                Ie(gt);
              } catch (It) {
                He = He ?? [], It instanceof ge.UnsubscriptionError ? He = fe(fe([], ae(He)), ae(It.errors)) : He.push(It);
              }
            }
          } catch (It) {
            Be = { error: It };
          } finally {
            try {
              wt && !wt.done && (ze = ht.return) && ze.call(ht);
            } finally {
              if (Be)
                throw Be.error;
            }
          }
        }
        if (He)
          throw new ge.UnsubscriptionError(He);
      }
    }, $e.prototype.add = function(Ne) {
      var Me;
      if (Ne && Ne !== this)
        if (this.closed)
          Ie(Ne);
        else {
          if (Ne instanceof $e) {
            if (Ne.closed || Ne._hasParent(this))
              return;
            Ne._addParent(this);
          }
          (this._finalizers = (Me = this._finalizers) !== null && Me !== void 0 ? Me : []).push(Ne);
        }
    }, $e.prototype._hasParent = function(Ne) {
      var Me = this._parentage;
      return Me === Ne || Array.isArray(Me) && Me.includes(Ne);
    }, $e.prototype._addParent = function(Ne) {
      var Me = this._parentage;
      this._parentage = Array.isArray(Me) ? (Me.push(Ne), Me) : Me ? [Me, Ne] : Ne;
    }, $e.prototype._removeParent = function(Ne) {
      var Me = this._parentage;
      Me === Ne ? this._parentage = null : Array.isArray(Me) && we.arrRemove(Me, Ne);
    }, $e.prototype.remove = function(Ne) {
      var Me = this._finalizers;
      Me && we.arrRemove(Me, Ne), Ne instanceof $e && Ne._removeParent(this);
    }, $e.EMPTY = function() {
      var Ne = new $e();
      return Ne.closed = !0, Ne;
    }(), $e;
  }();
  ne.Subscription = _e, ne.EMPTY_SUBSCRIPTION = _e.EMPTY;
  function Se($e) {
    return $e instanceof _e || $e && "closed" in $e && ye.isFunction($e.remove) && ye.isFunction($e.add) && ye.isFunction($e.unsubscribe);
  }
  ne.isSubscription = Se;
  function Ie($e) {
    ye.isFunction($e) ? $e() : $e.unsubscribe();
  }
}), gd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.config = void 0, ne.config = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 };
}), Uk = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var ge = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!ge)
      return fe;
    var we = ge.call(fe), _e, Se = [], Ie;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(_e = we.next()).done; )
        Se.push(_e.value);
    } catch ($e) {
      Ie = { error: $e };
    } finally {
      try {
        _e && !_e.done && (ge = we.return) && ge.call(we);
      } finally {
        if (Ie)
          throw Ie.error;
      }
    }
    return Se;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var ge = 0, we = ye.length, _e = fe.length; ge < we; ge++, _e++)
      fe[_e] = ye[ge];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutProvider = void 0, ne.timeoutProvider = { setTimeout: function(fe, ye) {
    for (var ge = [], we = 2; we < arguments.length; we++)
      ge[we - 2] = arguments[we];
    var _e = ne.timeoutProvider.delegate;
    return _e != null && _e.setTimeout ? _e.setTimeout.apply(_e, ae([fe, ye], oe(ge))) : setTimeout.apply(void 0, ae([fe, ye], oe(ge)));
  }, clearTimeout: function(fe) {
    var ye = ne.timeoutProvider.delegate;
    return ((ye == null ? void 0 : ye.clearTimeout) || clearTimeout)(fe);
  }, delegate: void 0 };
}), Fk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reportUnhandledError = void 0;
  var oe = gd(), ae = Uk();
  function fe(ye) {
    ae.timeoutProvider.setTimeout(function() {
      var ge = oe.config.onUnhandledError;
      if (ge)
        ge(ye);
      else
        throw ye;
    });
  }
  ne.reportUnhandledError = fe;
}), On = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.noop = void 0;
  function oe() {
  }
  ne.noop = oe;
}), eI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createNotification = ne.nextNotification = ne.errorNotification = ne.COMPLETE_NOTIFICATION = void 0, ne.COMPLETE_NOTIFICATION = function() {
    return fe("C", void 0, void 0);
  }();
  function oe(ye) {
    return fe("E", void 0, ye);
  }
  ne.errorNotification = oe;
  function ae(ye) {
    return fe("N", ye, void 0);
  }
  ne.nextNotification = ae;
  function fe(ye, ge, we) {
    return { kind: ye, value: ge, error: we };
  }
  ne.createNotification = fe;
}), G0 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.captureError = ne.errorContext = void 0;
  var oe = gd(), ae = null;
  function fe(ge) {
    if (oe.config.useDeprecatedSynchronousErrorHandling) {
      var we = !ae;
      if (we && (ae = { errorThrown: !1, error: null }), ge(), we) {
        var _e = ae, Se = _e.errorThrown, Ie = _e.error;
        if (ae = null, Se)
          throw Ie;
      }
    } else
      ge();
  }
  ne.errorContext = fe;
  function ye(ge) {
    oe.config.useDeprecatedSynchronousErrorHandling && ae && (ae.errorThrown = !0, ae.error = ge);
  }
  ne.captureError = ye;
}), Sd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var tt = function(Xe, ot) {
      return tt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(pt, ht) {
        pt.__proto__ = ht;
      } || function(pt, ht) {
        for (var wt in ht)
          Object.prototype.hasOwnProperty.call(ht, wt) && (pt[wt] = ht[wt]);
      }, tt(Xe, ot);
    };
    return function(Xe, ot) {
      if (typeof ot != "function" && ot !== null)
        throw new TypeError("Class extends value " + String(ot) + " is not a constructor or null");
      tt(Xe, ot);
      function pt() {
        this.constructor = Xe;
      }
      Xe.prototype = ot === null ? Object.create(ot) : (pt.prototype = ot.prototype, new pt());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EMPTY_OBSERVER = ne.SafeSubscriber = ne.Subscriber = void 0;
  var ae = Mt(), fe = Oi(), ye = gd(), ge = Fk(), we = On(), _e = eI(), Se = Uk(), Ie = G0(), $e = function(tt) {
    oe(Xe, tt);
    function Xe(ot) {
      var pt = tt.call(this) || this;
      return pt.isStopped = !1, ot ? (pt.destination = ot, fe.isSubscription(ot) && ot.add(pt)) : pt.destination = ne.EMPTY_OBSERVER, pt;
    }
    return Xe.create = function(ot, pt, ht) {
      return new ze(ot, pt, ht);
    }, Xe.prototype.next = function(ot) {
      this.isStopped ? qe(_e.nextNotification(ot), this) : this._next(ot);
    }, Xe.prototype.error = function(ot) {
      this.isStopped ? qe(_e.errorNotification(ot), this) : (this.isStopped = !0, this._error(ot));
    }, Xe.prototype.complete = function() {
      this.isStopped ? qe(_e.COMPLETE_NOTIFICATION, this) : (this.isStopped = !0, this._complete());
    }, Xe.prototype.unsubscribe = function() {
      this.closed || (this.isStopped = !0, tt.prototype.unsubscribe.call(this), this.destination = null);
    }, Xe.prototype._next = function(ot) {
      this.destination.next(ot);
    }, Xe.prototype._error = function(ot) {
      try {
        this.destination.error(ot);
      } finally {
        this.unsubscribe();
      }
    }, Xe.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    }, Xe;
  }(fe.Subscription);
  ne.Subscriber = $e;
  var Ne = Function.prototype.bind;
  function Me(tt, Xe) {
    return Ne.call(tt, Xe);
  }
  var Be = function() {
    function tt(Xe) {
      this.partialObserver = Xe;
    }
    return tt.prototype.next = function(Xe) {
      var ot = this.partialObserver;
      if (ot.next)
        try {
          ot.next(Xe);
        } catch (pt) {
          He(pt);
        }
    }, tt.prototype.error = function(Xe) {
      var ot = this.partialObserver;
      if (ot.error)
        try {
          ot.error(Xe);
        } catch (pt) {
          He(pt);
        }
      else
        He(Xe);
    }, tt.prototype.complete = function() {
      var Xe = this.partialObserver;
      if (Xe.complete)
        try {
          Xe.complete();
        } catch (ot) {
          He(ot);
        }
    }, tt;
  }(), ze = function(tt) {
    oe(Xe, tt);
    function Xe(ot, pt, ht) {
      var wt = tt.call(this) || this, gt;
      if (ae.isFunction(ot) || !ot)
        gt = { next: ot ?? void 0, error: pt ?? void 0, complete: ht ?? void 0 };
      else {
        var It;
        wt && ye.config.useDeprecatedNextContext ? (It = Object.create(ot), It.unsubscribe = function() {
          return wt.unsubscribe();
        }, gt = { next: ot.next && Me(ot.next, It), error: ot.error && Me(ot.error, It), complete: ot.complete && Me(ot.complete, It) }) : gt = ot;
      }
      return wt.destination = new Be(gt), wt;
    }
    return Xe;
  }($e);
  ne.SafeSubscriber = ze;
  function He(tt) {
    ye.config.useDeprecatedSynchronousErrorHandling ? Ie.captureError(tt) : ge.reportUnhandledError(tt);
  }
  function Ze(tt) {
    throw tt;
  }
  function qe(tt, Xe) {
    var ot = ye.config.onStoppedNotification;
    ot && Se.timeoutProvider.setTimeout(function() {
      return ot(tt, Xe);
    });
  }
  ne.EMPTY_OBSERVER = { closed: !0, next: we.noop, error: Ze, complete: we.noop };
}), uh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observable = void 0, ne.observable = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable";
  }();
}), Hn = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.identity = void 0;
  function oe(ae) {
    return ae;
  }
  ne.identity = oe;
}), lh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pipeFromArray = ne.pipe = void 0;
  var oe = Hn();
  function ae() {
    for (var ye = [], ge = 0; ge < arguments.length; ge++)
      ye[ge] = arguments[ge];
    return fe(ye);
  }
  ne.pipe = ae;
  function fe(ye) {
    return ye.length === 0 ? oe.identity : ye.length === 1 ? ye[0] : function(ge) {
      return ye.reduce(function(we, _e) {
        return _e(we);
      }, ge);
    };
  }
  ne.pipeFromArray = fe;
}), qt = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Observable = void 0;
  var oe = Sd(), ae = Oi(), fe = uh(), ye = lh(), ge = gd(), we = Mt(), _e = G0(), Se = function() {
    function Me(Be) {
      Be && (this._subscribe = Be);
    }
    return Me.prototype.lift = function(Be) {
      var ze = new Me();
      return ze.source = this, ze.operator = Be, ze;
    }, Me.prototype.subscribe = function(Be, ze, He) {
      var Ze = this, qe = Ne(Be) ? Be : new oe.SafeSubscriber(Be, ze, He);
      return _e.errorContext(function() {
        var tt = Ze, Xe = tt.operator, ot = tt.source;
        qe.add(Xe ? Xe.call(qe, ot) : ot ? Ze._subscribe(qe) : Ze._trySubscribe(qe));
      }), qe;
    }, Me.prototype._trySubscribe = function(Be) {
      try {
        return this._subscribe(Be);
      } catch (ze) {
        Be.error(ze);
      }
    }, Me.prototype.forEach = function(Be, ze) {
      var He = this;
      return ze = Ie(ze), new ze(function(Ze, qe) {
        var tt = new oe.SafeSubscriber({ next: function(Xe) {
          try {
            Be(Xe);
          } catch (ot) {
            qe(ot), tt.unsubscribe();
          }
        }, error: qe, complete: Ze });
        He.subscribe(tt);
      });
    }, Me.prototype._subscribe = function(Be) {
      var ze;
      return (ze = this.source) === null || ze === void 0 ? void 0 : ze.subscribe(Be);
    }, Me.prototype[fe.observable] = function() {
      return this;
    }, Me.prototype.pipe = function() {
      for (var Be = [], ze = 0; ze < arguments.length; ze++)
        Be[ze] = arguments[ze];
      return ye.pipeFromArray(Be)(this);
    }, Me.prototype.toPromise = function(Be) {
      var ze = this;
      return Be = Ie(Be), new Be(function(He, Ze) {
        var qe;
        ze.subscribe(function(tt) {
          return qe = tt;
        }, function(tt) {
          return Ze(tt);
        }, function() {
          return He(qe);
        });
      });
    }, Me.create = function(Be) {
      return new Me(Be);
    }, Me;
  }();
  ne.Observable = Se;
  function Ie(Me) {
    var Be;
    return (Be = Me ?? ge.config.Promise) !== null && Be !== void 0 ? Be : Promise;
  }
  function $e(Me) {
    return Me && we.isFunction(Me.next) && we.isFunction(Me.error) && we.isFunction(Me.complete);
  }
  function Ne(Me) {
    return Me && Me instanceof oe.Subscriber || $e(Me) && ae.isSubscription(Me);
  }
}), he = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.operate = ne.hasLift = void 0;
  var oe = Mt();
  function ae(ye) {
    return oe.isFunction(ye == null ? void 0 : ye.lift);
  }
  ne.hasLift = ae;
  function fe(ye) {
    return function(ge) {
      if (ae(ge))
        return ge.lift(function(we) {
          try {
            return ye(we, this);
          } catch (_e) {
            this.error(_e);
          }
        });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  ne.operate = fe;
}), Ae = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ge = function(we, _e) {
      return ge = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Se, Ie) {
        Se.__proto__ = Ie;
      } || function(Se, Ie) {
        for (var $e in Ie)
          Object.prototype.hasOwnProperty.call(Ie, $e) && (Se[$e] = Ie[$e]);
      }, ge(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ge(we, _e);
      function Se() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (Se.prototype = _e.prototype, new Se());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.OperatorSubscriber = ne.createOperatorSubscriber = void 0;
  var ae = Sd();
  function fe(ge, we, _e, Se, Ie) {
    return new ye(ge, we, _e, Se, Ie);
  }
  ne.createOperatorSubscriber = fe;
  var ye = function(ge) {
    oe(we, ge);
    function we(_e, Se, Ie, $e, Ne, Me) {
      var Be = ge.call(this, _e) || this;
      return Be.onFinalize = Ne, Be.shouldUnsubscribe = Me, Be._next = Se ? function(ze) {
        try {
          Se(ze);
        } catch (He) {
          _e.error(He);
        }
      } : ge.prototype._next, Be._error = $e ? function(ze) {
        try {
          $e(ze);
        } catch (He) {
          _e.error(He);
        } finally {
          this.unsubscribe();
        }
      } : ge.prototype._error, Be._complete = Ie ? function() {
        try {
          Ie();
        } catch (ze) {
          _e.error(ze);
        } finally {
          this.unsubscribe();
        }
      } : ge.prototype._complete, Be;
    }
    return we.prototype.unsubscribe = function() {
      var _e;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var Se = this.closed;
        ge.prototype.unsubscribe.call(this), !Se && ((_e = this.onFinalize) === null || _e === void 0 || _e.call(this));
      }
    }, we;
  }(ae.Subscriber);
  ne.OperatorSubscriber = ye;
}), $k = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.refCount = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ge) {
      var we = null;
      ye._refCount++;
      var _e = ae.createOperatorSubscriber(ge, void 0, void 0, void 0, function() {
        if (!ye || ye._refCount <= 0 || 0 < --ye._refCount) {
          we = null;
          return;
        }
        var Se = ye._connection, Ie = we;
        we = null, Se && (!Ie || Se === Ie) && Se.unsubscribe(), ge.unsubscribe();
      });
      ye.subscribe(_e), _e.closed || (we = ye.connect());
    });
  }
  ne.refCount = fe;
}), sh = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var Se = function(Ie, $e) {
      return Se = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ne, Me) {
        Ne.__proto__ = Me;
      } || function(Ne, Me) {
        for (var Be in Me)
          Object.prototype.hasOwnProperty.call(Me, Be) && (Ne[Be] = Me[Be]);
      }, Se(Ie, $e);
    };
    return function(Ie, $e) {
      if (typeof $e != "function" && $e !== null)
        throw new TypeError("Class extends value " + String($e) + " is not a constructor or null");
      Se(Ie, $e);
      function Ne() {
        this.constructor = Ie;
      }
      Ie.prototype = $e === null ? Object.create($e) : (Ne.prototype = $e.prototype, new Ne());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ConnectableObservable = void 0;
  var ae = qt(), fe = Oi(), ye = $k(), ge = Ae(), we = he(), _e = function(Se) {
    oe(Ie, Se);
    function Ie($e, Ne) {
      var Me = Se.call(this) || this;
      return Me.source = $e, Me.subjectFactory = Ne, Me._subject = null, Me._refCount = 0, Me._connection = null, we.hasLift($e) && (Me.lift = $e.lift), Me;
    }
    return Ie.prototype._subscribe = function($e) {
      return this.getSubject().subscribe($e);
    }, Ie.prototype.getSubject = function() {
      var $e = this._subject;
      return (!$e || $e.isStopped) && (this._subject = this.subjectFactory()), this._subject;
    }, Ie.prototype._teardown = function() {
      this._refCount = 0;
      var $e = this._connection;
      this._subject = this._connection = null, $e == null || $e.unsubscribe();
    }, Ie.prototype.connect = function() {
      var $e = this, Ne = this._connection;
      if (!Ne) {
        Ne = this._connection = new fe.Subscription();
        var Me = this.getSubject();
        Ne.add(this.source.subscribe(ge.createOperatorSubscriber(Me, void 0, function() {
          $e._teardown(), Me.complete();
        }, function(Be) {
          $e._teardown(), Me.error(Be);
        }, function() {
          return $e._teardown();
        }))), Ne.closed && (this._connection = null, Ne = fe.Subscription.EMPTY);
      }
      return Ne;
    }, Ie.prototype.refCount = function() {
      return ye.refCount()(this);
    }, Ie;
  }(ae.Observable);
  ne.ConnectableObservable = _e;
}), dI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.performanceTimestampProvider = void 0, ne.performanceTimestampProvider = { now: function() {
    return (ne.performanceTimestampProvider.delegate || performance).now();
  }, delegate: void 0 };
}), Wk = M((ne) => {
  var oe = ne && ne.__read || function(ye, ge) {
    var we = typeof Symbol == "function" && ye[Symbol.iterator];
    if (!we)
      return ye;
    var _e = we.call(ye), Se, Ie = [], $e;
    try {
      for (; (ge === void 0 || ge-- > 0) && !(Se = _e.next()).done; )
        Ie.push(Se.value);
    } catch (Ne) {
      $e = { error: Ne };
    } finally {
      try {
        Se && !Se.done && (we = _e.return) && we.call(_e);
      } finally {
        if ($e)
          throw $e.error;
      }
    }
    return Ie;
  }, ae = ne && ne.__spreadArray || function(ye, ge) {
    for (var we = 0, _e = ge.length, Se = ye.length; we < _e; we++, Se++)
      ye[Se] = ge[we];
    return ye;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrameProvider = void 0;
  var fe = Oi();
  ne.animationFrameProvider = { schedule: function(ye) {
    var ge = requestAnimationFrame, we = cancelAnimationFrame, _e = ne.animationFrameProvider.delegate;
    _e && (ge = _e.requestAnimationFrame, we = _e.cancelAnimationFrame);
    var Se = ge(function(Ie) {
      we = void 0, ye(Ie);
    });
    return new fe.Subscription(function() {
      return we == null ? void 0 : we(Se);
    });
  }, requestAnimationFrame: function() {
    for (var ye = [], ge = 0; ge < arguments.length; ge++)
      ye[ge] = arguments[ge];
    var we = ne.animationFrameProvider.delegate;
    return ((we == null ? void 0 : we.requestAnimationFrame) || requestAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, cancelAnimationFrame: function() {
    for (var ye = [], ge = 0; ge < arguments.length; ge++)
      ye[ge] = arguments[ge];
    var we = ne.animationFrameProvider.delegate;
    return ((we == null ? void 0 : we.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, ae([], oe(ye)));
  }, delegate: void 0 };
}), hI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrames = void 0;
  var oe = qt(), ae = Oi(), fe = dI(), ye = Wk();
  function ge(Se) {
    return Se ? we(Se) : _e;
  }
  ne.animationFrames = ge;
  function we(Se) {
    var Ie = ye.animationFrameProvider.schedule;
    return new oe.Observable(function($e) {
      var Ne = new ae.Subscription(), Me = Se || fe.performanceTimestampProvider, Be = Me.now(), ze = function(He) {
        var Ze = Me.now();
        $e.next({ timestamp: Se ? Ze : He, elapsed: Ze - Be }), $e.closed || Ne.add(Ie(ze));
      };
      return Ne.add(Ie(ze)), Ne;
    });
  }
  var _e = we();
}), Yk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ObjectUnsubscribedError = void 0;
  var oe = Il();
  ne.ObjectUnsubscribedError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
    };
  });
}), Tn = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var $e = function(Ne, Me) {
      return $e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Be, ze) {
        Be.__proto__ = ze;
      } || function(Be, ze) {
        for (var He in ze)
          Object.prototype.hasOwnProperty.call(ze, He) && (Be[He] = ze[He]);
      }, $e(Ne, Me);
    };
    return function(Ne, Me) {
      if (typeof Me != "function" && Me !== null)
        throw new TypeError("Class extends value " + String(Me) + " is not a constructor or null");
      $e(Ne, Me);
      function Be() {
        this.constructor = Ne;
      }
      Ne.prototype = Me === null ? Object.create(Me) : (Be.prototype = Me.prototype, new Be());
    };
  }(), ae = ne && ne.__values || function($e) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, Me = Ne && $e[Ne], Be = 0;
    if (Me)
      return Me.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && Be >= $e.length && ($e = void 0), { value: $e && $e[Be++], done: !$e };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnonymousSubject = ne.Subject = void 0;
  var fe = qt(), ye = Oi(), ge = Yk(), we = ku(), _e = G0(), Se = function($e) {
    oe(Ne, $e);
    function Ne() {
      var Me = $e.call(this) || this;
      return Me.closed = !1, Me.currentObservers = null, Me.observers = [], Me.isStopped = !1, Me.hasError = !1, Me.thrownError = null, Me;
    }
    return Ne.prototype.lift = function(Me) {
      var Be = new Ie(this, this);
      return Be.operator = Me, Be;
    }, Ne.prototype._throwIfClosed = function() {
      if (this.closed)
        throw new ge.ObjectUnsubscribedError();
    }, Ne.prototype.next = function(Me) {
      var Be = this;
      _e.errorContext(function() {
        var ze, He;
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.currentObservers || (Be.currentObservers = Array.from(Be.observers));
          try {
            for (var Ze = ae(Be.currentObservers), qe = Ze.next(); !qe.done; qe = Ze.next()) {
              var tt = qe.value;
              tt.next(Me);
            }
          } catch (Xe) {
            ze = { error: Xe };
          } finally {
            try {
              qe && !qe.done && (He = Ze.return) && He.call(Ze);
            } finally {
              if (ze)
                throw ze.error;
            }
          }
        }
      });
    }, Ne.prototype.error = function(Me) {
      var Be = this;
      _e.errorContext(function() {
        if (Be._throwIfClosed(), !Be.isStopped) {
          Be.hasError = Be.isStopped = !0, Be.thrownError = Me;
          for (var ze = Be.observers; ze.length; )
            ze.shift().error(Me);
        }
      });
    }, Ne.prototype.complete = function() {
      var Me = this;
      _e.errorContext(function() {
        if (Me._throwIfClosed(), !Me.isStopped) {
          Me.isStopped = !0;
          for (var Be = Me.observers; Be.length; )
            Be.shift().complete();
        }
      });
    }, Ne.prototype.unsubscribe = function() {
      this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
    }, Object.defineProperty(Ne.prototype, "observed", { get: function() {
      var Me;
      return ((Me = this.observers) === null || Me === void 0 ? void 0 : Me.length) > 0;
    }, enumerable: !1, configurable: !0 }), Ne.prototype._trySubscribe = function(Me) {
      return this._throwIfClosed(), $e.prototype._trySubscribe.call(this, Me);
    }, Ne.prototype._subscribe = function(Me) {
      return this._throwIfClosed(), this._checkFinalizedStatuses(Me), this._innerSubscribe(Me);
    }, Ne.prototype._innerSubscribe = function(Me) {
      var Be = this, ze = this, He = ze.hasError, Ze = ze.isStopped, qe = ze.observers;
      return He || Ze ? ye.EMPTY_SUBSCRIPTION : (this.currentObservers = null, qe.push(Me), new ye.Subscription(function() {
        Be.currentObservers = null, we.arrRemove(qe, Me);
      }));
    }, Ne.prototype._checkFinalizedStatuses = function(Me) {
      var Be = this, ze = Be.hasError, He = Be.thrownError, Ze = Be.isStopped;
      ze ? Me.error(He) : Ze && Me.complete();
    }, Ne.prototype.asObservable = function() {
      var Me = new fe.Observable();
      return Me.source = this, Me;
    }, Ne.create = function(Me, Be) {
      return new Ie(Me, Be);
    }, Ne;
  }(fe.Observable);
  ne.Subject = Se;
  var Ie = function($e) {
    oe(Ne, $e);
    function Ne(Me, Be) {
      var ze = $e.call(this) || this;
      return ze.destination = Me, ze.source = Be, ze;
    }
    return Ne.prototype.next = function(Me) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.next) === null || ze === void 0 || ze.call(Be, Me);
    }, Ne.prototype.error = function(Me) {
      var Be, ze;
      (ze = (Be = this.destination) === null || Be === void 0 ? void 0 : Be.error) === null || ze === void 0 || ze.call(Be, Me);
    }, Ne.prototype.complete = function() {
      var Me, Be;
      (Be = (Me = this.destination) === null || Me === void 0 ? void 0 : Me.complete) === null || Be === void 0 || Be.call(Me);
    }, Ne.prototype._subscribe = function(Me) {
      var Be, ze;
      return (ze = (Be = this.source) === null || Be === void 0 ? void 0 : Be.subscribe(Me)) !== null && ze !== void 0 ? ze : ye.EMPTY_SUBSCRIPTION;
    }, Ne;
  }(Se);
  ne.AnonymousSubject = Ie;
}), Xk = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.BehaviorSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(ge, ye);
    function ge(we) {
      var _e = ye.call(this) || this;
      return _e._value = we, _e;
    }
    return Object.defineProperty(ge.prototype, "value", { get: function() {
      return this.getValue();
    }, enumerable: !1, configurable: !0 }), ge.prototype._subscribe = function(we) {
      var _e = ye.prototype._subscribe.call(this, we);
      return !_e.closed && we.next(this._value), _e;
    }, ge.prototype.getValue = function() {
      var we = this, _e = we.hasError, Se = we.thrownError, Ie = we._value;
      if (_e)
        throw Se;
      return this._throwIfClosed(), Ie;
    }, ge.prototype.next = function(we) {
      ye.prototype.next.call(this, this._value = we);
    }, ge;
  }(ae.Subject);
  ne.BehaviorSubject = fe;
}), rS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dateTimestampProvider = void 0, ne.dateTimestampProvider = { now: function() {
    return (ne.dateTimestampProvider.delegate || Date).now();
  }, delegate: void 0 };
}), nS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ge = function(we, _e) {
      return ge = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Se, Ie) {
        Se.__proto__ = Ie;
      } || function(Se, Ie) {
        for (var $e in Ie)
          Object.prototype.hasOwnProperty.call(Ie, $e) && (Se[$e] = Ie[$e]);
      }, ge(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ge(we, _e);
      function Se() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (Se.prototype = _e.prototype, new Se());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ReplaySubject = void 0;
  var ae = Tn(), fe = rS(), ye = function(ge) {
    oe(we, ge);
    function we(_e, Se, Ie) {
      _e === void 0 && (_e = 1 / 0), Se === void 0 && (Se = 1 / 0), Ie === void 0 && (Ie = fe.dateTimestampProvider);
      var $e = ge.call(this) || this;
      return $e._bufferSize = _e, $e._windowTime = Se, $e._timestampProvider = Ie, $e._buffer = [], $e._infiniteTimeWindow = !0, $e._infiniteTimeWindow = Se === 1 / 0, $e._bufferSize = Math.max(1, _e), $e._windowTime = Math.max(1, Se), $e;
    }
    return we.prototype.next = function(_e) {
      var Se = this, Ie = Se.isStopped, $e = Se._buffer, Ne = Se._infiniteTimeWindow, Me = Se._timestampProvider, Be = Se._windowTime;
      Ie || ($e.push(_e), !Ne && $e.push(Me.now() + Be)), this._trimBuffer(), ge.prototype.next.call(this, _e);
    }, we.prototype._subscribe = function(_e) {
      this._throwIfClosed(), this._trimBuffer();
      for (var Se = this._innerSubscribe(_e), Ie = this, $e = Ie._infiniteTimeWindow, Ne = Ie._buffer, Me = Ne.slice(), Be = 0; Be < Me.length && !_e.closed; Be += $e ? 1 : 2)
        _e.next(Me[Be]);
      return this._checkFinalizedStatuses(_e), Se;
    }, we.prototype._trimBuffer = function() {
      var _e = this, Se = _e._bufferSize, Ie = _e._timestampProvider, $e = _e._buffer, Ne = _e._infiniteTimeWindow, Me = (Ne ? 1 : 2) * Se;
      if (Se < 1 / 0 && Me < $e.length && $e.splice(0, $e.length - Me), !Ne) {
        for (var Be = Ie.now(), ze = 0, He = 1; He < $e.length && $e[He] <= Be; He += 2)
          ze = He;
        ze && $e.splice(0, ze + 1);
      }
    }, we;
  }(ae.Subject);
  ne.ReplaySubject = ye;
}), iS = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncSubject = void 0;
  var ae = Tn(), fe = function(ye) {
    oe(ge, ye);
    function ge() {
      var we = ye !== null && ye.apply(this, arguments) || this;
      return we._value = null, we._hasValue = !1, we._isComplete = !1, we;
    }
    return ge.prototype._checkFinalizedStatuses = function(we) {
      var _e = this, Se = _e.hasError, Ie = _e._hasValue, $e = _e._value, Ne = _e.thrownError, Me = _e.isStopped, Be = _e._isComplete;
      Se ? we.error(Ne) : (Me || Be) && (Ie && we.next($e), we.complete());
    }, ge.prototype.next = function(we) {
      this.isStopped || (this._value = we, this._hasValue = !0);
    }, ge.prototype.complete = function() {
      var we = this, _e = we._hasValue, Se = we._value, Ie = we._isComplete;
      Ie || (this._isComplete = !0, _e && ye.prototype.next.call(this, Se), ye.prototype.complete.call(this));
    }, ge;
  }(ae.Subject);
  ne.AsyncSubject = fe;
}), SI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Action = void 0;
  var ae = Oi(), fe = function(ye) {
    oe(ge, ye);
    function ge(we, _e) {
      return ye.call(this) || this;
    }
    return ge.prototype.schedule = function(we, _e) {
      return this;
    }, ge;
  }(ae.Subscription);
  ne.Action = fe;
}), xI = M((ne) => {
  var oe = ne && ne.__read || function(fe, ye) {
    var ge = typeof Symbol == "function" && fe[Symbol.iterator];
    if (!ge)
      return fe;
    var we = ge.call(fe), _e, Se = [], Ie;
    try {
      for (; (ye === void 0 || ye-- > 0) && !(_e = we.next()).done; )
        Se.push(_e.value);
    } catch ($e) {
      Ie = { error: $e };
    } finally {
      try {
        _e && !_e.done && (ge = we.return) && ge.call(we);
      } finally {
        if (Ie)
          throw Ie.error;
      }
    }
    return Se;
  }, ae = ne && ne.__spreadArray || function(fe, ye) {
    for (var ge = 0, we = ye.length, _e = fe.length; ge < we; ge++, _e++)
      fe[_e] = ye[ge];
    return fe;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.intervalProvider = void 0, ne.intervalProvider = { setInterval: function(fe, ye) {
    for (var ge = [], we = 2; we < arguments.length; we++)
      ge[we - 2] = arguments[we];
    var _e = ne.intervalProvider.delegate;
    return _e != null && _e.setInterval ? _e.setInterval.apply(_e, ae([fe, ye], oe(ge))) : setInterval.apply(void 0, ae([fe, ye], oe(ge)));
  }, clearInterval: function(fe) {
    var ye = ne.intervalProvider.delegate;
    return ((ye == null ? void 0 : ye.clearInterval) || clearInterval)(fe);
  }, delegate: void 0 };
}), kd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var we = function(_e, Se) {
      return we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ie, $e) {
        Ie.__proto__ = $e;
      } || function(Ie, $e) {
        for (var Ne in $e)
          Object.prototype.hasOwnProperty.call($e, Ne) && (Ie[Ne] = $e[Ne]);
      }, we(_e, Se);
    };
    return function(_e, Se) {
      if (typeof Se != "function" && Se !== null)
        throw new TypeError("Class extends value " + String(Se) + " is not a constructor or null");
      we(_e, Se);
      function Ie() {
        this.constructor = _e;
      }
      _e.prototype = Se === null ? Object.create(Se) : (Ie.prototype = Se.prototype, new Ie());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncAction = void 0;
  var ae = SI(), fe = xI(), ye = ku(), ge = function(we) {
    oe(_e, we);
    function _e(Se, Ie) {
      var $e = we.call(this, Se, Ie) || this;
      return $e.scheduler = Se, $e.work = Ie, $e.pending = !1, $e;
    }
    return _e.prototype.schedule = function(Se, Ie) {
      if (Ie === void 0 && (Ie = 0), this.closed)
        return this;
      this.state = Se;
      var $e = this.id, Ne = this.scheduler;
      return $e != null && (this.id = this.recycleAsyncId(Ne, $e, Ie)), this.pending = !0, this.delay = Ie, this.id = this.id || this.requestAsyncId(Ne, this.id, Ie), this;
    }, _e.prototype.requestAsyncId = function(Se, Ie, $e) {
      return $e === void 0 && ($e = 0), fe.intervalProvider.setInterval(Se.flush.bind(Se, this), $e);
    }, _e.prototype.recycleAsyncId = function(Se, Ie, $e) {
      if ($e === void 0 && ($e = 0), $e != null && this.delay === $e && this.pending === !1)
        return Ie;
      fe.intervalProvider.clearInterval(Ie);
    }, _e.prototype.execute = function(Se, Ie) {
      if (this.closed)
        return new Error("executing a cancelled action");
      this.pending = !1;
      var $e = this._execute(Se, Ie);
      if ($e)
        return $e;
      this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
    }, _e.prototype._execute = function(Se, Ie) {
      var $e = !1, Ne;
      try {
        this.work(Se);
      } catch (Me) {
        $e = !0, Ne = Me || new Error("Scheduled action threw falsy error");
      }
      if ($e)
        return this.unsubscribe(), Ne;
    }, _e.prototype.unsubscribe = function() {
      if (!this.closed) {
        var Se = this, Ie = Se.id, $e = Se.scheduler, Ne = $e.actions;
        this.work = this.state = this.scheduler = null, this.pending = !1, ye.arrRemove(Ne, this), Ie != null && (this.id = this.recycleAsyncId($e, Ie, null)), this.delay = null, we.prototype.unsubscribe.call(this);
      }
    }, _e;
  }(ae.Action);
  ne.AsyncAction = ge;
}), RI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TestTools = ne.Immediate = void 0;
  var oe = 1, ae, fe = {};
  function ye(ge) {
    return ge in fe ? (delete fe[ge], !0) : !1;
  }
  ne.Immediate = { setImmediate: function(ge) {
    var we = oe++;
    return fe[we] = !0, ae || (ae = Promise.resolve()), ae.then(function() {
      return ye(we) && ge();
    }), we;
  }, clearImmediate: function(ge) {
    ye(ge);
  } }, ne.TestTools = { pending: function() {
    return Object.keys(fe).length;
  } };
}), TI = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var Se = typeof Symbol == "function" && we[Symbol.iterator];
    if (!Se)
      return we;
    var Ie = Se.call(we), $e, Ne = [], Me;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Ie.next()).done; )
        Ne.push($e.value);
    } catch (Be) {
      Me = { error: Be };
    } finally {
      try {
        $e && !$e.done && (Se = Ie.return) && Se.call(Ie);
      } finally {
        if (Me)
          throw Me.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var Se = 0, Ie = _e.length, $e = we.length; Se < Ie; Se++, $e++)
      we[$e] = _e[Se];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.immediateProvider = void 0;
  var fe = RI(), ye = fe.Immediate.setImmediate, ge = fe.Immediate.clearImmediate;
  ne.immediateProvider = { setImmediate: function() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    var Se = ne.immediateProvider.delegate;
    return ((Se == null ? void 0 : Se.setImmediate) || ye).apply(void 0, ae([], oe(we)));
  }, clearImmediate: function(we) {
    var _e = ne.immediateProvider.delegate;
    return ((_e == null ? void 0 : _e.clearImmediate) || ge)(we);
  }, delegate: void 0 };
}), AI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ge = function(we, _e) {
      return ge = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Se, Ie) {
        Se.__proto__ = Ie;
      } || function(Se, Ie) {
        for (var $e in Ie)
          Object.prototype.hasOwnProperty.call(Ie, $e) && (Se[$e] = Ie[$e]);
      }, ge(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ge(we, _e);
      function Se() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (Se.prototype = _e.prototype, new Se());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapAction = void 0;
  var ae = kd(), fe = TI(), ye = function(ge) {
    oe(we, ge);
    function we(_e, Se) {
      var Ie = ge.call(this, _e, Se) || this;
      return Ie.scheduler = _e, Ie.work = Se, Ie;
    }
    return we.prototype.requestAsyncId = function(_e, Se, Ie) {
      return Ie === void 0 && (Ie = 0), Ie !== null && Ie > 0 ? ge.prototype.requestAsyncId.call(this, _e, Se, Ie) : (_e.actions.push(this), _e._scheduled || (_e._scheduled = fe.immediateProvider.setImmediate(_e.flush.bind(_e, void 0))));
    }, we.prototype.recycleAsyncId = function(_e, Se, Ie) {
      if (Ie === void 0 && (Ie = 0), Ie != null && Ie > 0 || Ie == null && this.delay > 0)
        return ge.prototype.recycleAsyncId.call(this, _e, Se, Ie);
      _e.actions.some(function($e) {
        return $e.id === Se;
      }) || (fe.immediateProvider.clearImmediate(Se), _e._scheduled = void 0);
    }, we;
  }(ae.AsyncAction);
  ne.AsapAction = ye;
}), Zk = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.Scheduler = void 0;
  var oe = rS(), ae = function() {
    function fe(ye, ge) {
      ge === void 0 && (ge = fe.now), this.schedulerActionCtor = ye, this.now = ge;
    }
    return fe.prototype.schedule = function(ye, ge, we) {
      return ge === void 0 && (ge = 0), new this.schedulerActionCtor(this, ye).schedule(we, ge);
    }, fe.now = oe.dateTimestampProvider.now, fe;
  }();
  ne.Scheduler = ae;
}), Dd = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsyncScheduler = void 0;
  var ae = Zk(), fe = function(ye) {
    oe(ge, ye);
    function ge(we, _e) {
      _e === void 0 && (_e = ae.Scheduler.now);
      var Se = ye.call(this, we, _e) || this;
      return Se.actions = [], Se._active = !1, Se._scheduled = void 0, Se;
    }
    return ge.prototype.flush = function(we) {
      var _e = this.actions;
      if (this._active) {
        _e.push(we);
        return;
      }
      var Se;
      this._active = !0;
      do
        if (Se = we.execute(we.state, we.delay))
          break;
      while (we = _e.shift());
      if (this._active = !1, Se) {
        for (; we = _e.shift(); )
          we.unsubscribe();
        throw Se;
      }
    }, ge;
  }(ae.Scheduler);
  ne.AsyncScheduler = fe;
}), MI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AsapScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ge, ye);
    function ge() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ge.prototype.flush = function(we) {
      this._active = !0;
      var _e = this._scheduled;
      this._scheduled = void 0;
      var Se = this.actions, Ie;
      we = we || Se.shift();
      do
        if (Ie = we.execute(we.state, we.delay))
          break;
      while ((we = Se[0]) && we.id === _e && Se.shift());
      if (this._active = !1, Ie) {
        for (; (we = Se[0]) && we.id === _e && Se.shift(); )
          we.unsubscribe();
        throw Ie;
      }
    }, ge;
  }(ae.AsyncScheduler);
  ne.AsapScheduler = fe;
}), DI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.asap = ne.asapScheduler = void 0;
  var oe = AI(), ae = MI();
  ne.asapScheduler = new ae.AsapScheduler(oe.AsapAction), ne.asap = ne.asapScheduler;
}), Ti = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.async = ne.asyncScheduler = void 0;
  var oe = kd(), ae = Dd();
  ne.asyncScheduler = new ae.AsyncScheduler(oe.AsyncAction), ne.async = ne.asyncScheduler;
}), NI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueAction = void 0;
  var ae = kd(), fe = function(ye) {
    oe(ge, ye);
    function ge(we, _e) {
      var Se = ye.call(this, we, _e) || this;
      return Se.scheduler = we, Se.work = _e, Se;
    }
    return ge.prototype.schedule = function(we, _e) {
      return _e === void 0 && (_e = 0), _e > 0 ? ye.prototype.schedule.call(this, we, _e) : (this.delay = _e, this.state = we, this.scheduler.flush(this), this);
    }, ge.prototype.execute = function(we, _e) {
      return _e > 0 || this.closed ? ye.prototype.execute.call(this, we, _e) : this._execute(we, _e);
    }, ge.prototype.requestAsyncId = function(we, _e, Se) {
      return Se === void 0 && (Se = 0), Se != null && Se > 0 || Se == null && this.delay > 0 ? ye.prototype.requestAsyncId.call(this, we, _e, Se) : we.flush(this);
    }, ge;
  }(ae.AsyncAction);
  ne.QueueAction = fe;
}), LI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.QueueScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ge, ye);
    function ge() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ge;
  }(ae.AsyncScheduler);
  ne.QueueScheduler = fe;
}), jI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.queue = ne.queueScheduler = void 0;
  var oe = NI(), ae = LI();
  ne.queueScheduler = new ae.QueueScheduler(oe.QueueAction), ne.queue = ne.queueScheduler;
}), FI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ge = function(we, _e) {
      return ge = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Se, Ie) {
        Se.__proto__ = Ie;
      } || function(Se, Ie) {
        for (var $e in Ie)
          Object.prototype.hasOwnProperty.call(Ie, $e) && (Se[$e] = Ie[$e]);
      }, ge(we, _e);
    };
    return function(we, _e) {
      if (typeof _e != "function" && _e !== null)
        throw new TypeError("Class extends value " + String(_e) + " is not a constructor or null");
      ge(we, _e);
      function Se() {
        this.constructor = we;
      }
      we.prototype = _e === null ? Object.create(_e) : (Se.prototype = _e.prototype, new Se());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameAction = void 0;
  var ae = kd(), fe = Wk(), ye = function(ge) {
    oe(we, ge);
    function we(_e, Se) {
      var Ie = ge.call(this, _e, Se) || this;
      return Ie.scheduler = _e, Ie.work = Se, Ie;
    }
    return we.prototype.requestAsyncId = function(_e, Se, Ie) {
      return Ie === void 0 && (Ie = 0), Ie !== null && Ie > 0 ? ge.prototype.requestAsyncId.call(this, _e, Se, Ie) : (_e.actions.push(this), _e._scheduled || (_e._scheduled = fe.animationFrameProvider.requestAnimationFrame(function() {
        return _e.flush(void 0);
      })));
    }, we.prototype.recycleAsyncId = function(_e, Se, Ie) {
      if (Ie === void 0 && (Ie = 0), Ie != null && Ie > 0 || Ie == null && this.delay > 0)
        return ge.prototype.recycleAsyncId.call(this, _e, Se, Ie);
      _e.actions.some(function($e) {
        return $e.id === Se;
      }) || (fe.animationFrameProvider.cancelAnimationFrame(Se), _e._scheduled = void 0);
    }, we;
  }(ae.AsyncAction);
  ne.AnimationFrameAction = ye;
}), zI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var ye = function(ge, we) {
      return ye = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_e, Se) {
        _e.__proto__ = Se;
      } || function(_e, Se) {
        for (var Ie in Se)
          Object.prototype.hasOwnProperty.call(Se, Ie) && (_e[Ie] = Se[Ie]);
      }, ye(ge, we);
    };
    return function(ge, we) {
      if (typeof we != "function" && we !== null)
        throw new TypeError("Class extends value " + String(we) + " is not a constructor or null");
      ye(ge, we);
      function _e() {
        this.constructor = ge;
      }
      ge.prototype = we === null ? Object.create(we) : (_e.prototype = we.prototype, new _e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.AnimationFrameScheduler = void 0;
  var ae = Dd(), fe = function(ye) {
    oe(ge, ye);
    function ge() {
      return ye !== null && ye.apply(this, arguments) || this;
    }
    return ge.prototype.flush = function(we) {
      this._active = !0;
      var _e = this._scheduled;
      this._scheduled = void 0;
      var Se = this.actions, Ie;
      we = we || Se.shift();
      do
        if (Ie = we.execute(we.state, we.delay))
          break;
      while ((we = Se[0]) && we.id === _e && Se.shift());
      if (this._active = !1, Ie) {
        for (; (we = Se[0]) && we.id === _e && Se.shift(); )
          we.unsubscribe();
        throw Ie;
      }
    }, ge;
  }(ae.AsyncScheduler);
  ne.AnimationFrameScheduler = fe;
}), qI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.animationFrame = ne.animationFrameScheduler = void 0;
  var oe = FI(), ae = zI();
  ne.animationFrameScheduler = new ae.AnimationFrameScheduler(oe.AnimationFrameAction), ne.animationFrame = ne.animationFrameScheduler;
}), HI = M((ne) => {
  var oe = ne && ne.__extends || function() {
    var _e = function(Se, Ie) {
      return _e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function($e, Ne) {
        $e.__proto__ = Ne;
      } || function($e, Ne) {
        for (var Me in Ne)
          Object.prototype.hasOwnProperty.call(Ne, Me) && ($e[Me] = Ne[Me]);
      }, _e(Se, Ie);
    };
    return function(Se, Ie) {
      if (typeof Ie != "function" && Ie !== null)
        throw new TypeError("Class extends value " + String(Ie) + " is not a constructor or null");
      _e(Se, Ie);
      function $e() {
        this.constructor = Se;
      }
      Se.prototype = Ie === null ? Object.create(Ie) : ($e.prototype = Ie.prototype, new $e());
    };
  }();
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.VirtualAction = ne.VirtualTimeScheduler = void 0;
  var ae = kd(), fe = Oi(), ye = Dd(), ge = function(_e) {
    oe(Se, _e);
    function Se(Ie, $e) {
      Ie === void 0 && (Ie = we), $e === void 0 && ($e = 1 / 0);
      var Ne = _e.call(this, Ie, function() {
        return Ne.frame;
      }) || this;
      return Ne.maxFrames = $e, Ne.frame = 0, Ne.index = -1, Ne;
    }
    return Se.prototype.flush = function() {
      for (var Ie = this, $e = Ie.actions, Ne = Ie.maxFrames, Me, Be; (Be = $e[0]) && Be.delay <= Ne && ($e.shift(), this.frame = Be.delay, !(Me = Be.execute(Be.state, Be.delay))); )
        ;
      if (Me) {
        for (; Be = $e.shift(); )
          Be.unsubscribe();
        throw Me;
      }
    }, Se.frameTimeFactor = 10, Se;
  }(ye.AsyncScheduler);
  ne.VirtualTimeScheduler = ge;
  var we = function(_e) {
    oe(Se, _e);
    function Se(Ie, $e, Ne) {
      Ne === void 0 && (Ne = Ie.index += 1);
      var Me = _e.call(this, Ie, $e) || this;
      return Me.scheduler = Ie, Me.work = $e, Me.index = Ne, Me.active = !0, Me.index = Ie.index = Ne, Me;
    }
    return Se.prototype.schedule = function(Ie, $e) {
      if ($e === void 0 && ($e = 0), Number.isFinite($e)) {
        if (!this.id)
          return _e.prototype.schedule.call(this, Ie, $e);
        this.active = !1;
        var Ne = new Se(this.scheduler, this.work);
        return this.add(Ne), Ne.schedule(Ie, $e);
      } else
        return fe.Subscription.EMPTY;
    }, Se.prototype.requestAsyncId = function(Ie, $e, Ne) {
      Ne === void 0 && (Ne = 0), this.delay = Ie.frame + Ne;
      var Me = Ie.actions;
      return Me.push(this), Me.sort(Se.sortActions), !0;
    }, Se.prototype.recycleAsyncId = function(Ie, $e, Ne) {
    }, Se.prototype._execute = function(Ie, $e) {
      if (this.active === !0)
        return _e.prototype._execute.call(this, Ie, $e);
    }, Se.sortActions = function(Ie, $e) {
      return Ie.delay === $e.delay ? Ie.index === $e.index ? 0 : Ie.index > $e.index ? 1 : -1 : Ie.delay > $e.delay ? 1 : -1;
    }, Se;
  }(ae.AsyncAction);
  ne.VirtualAction = we;
}), ba = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.empty = ne.EMPTY = void 0;
  var oe = qt();
  ne.EMPTY = new oe.Observable(function(ye) {
    return ye.complete();
  });
  function ae(ye) {
    return ye ? fe(ye) : ne.EMPTY;
  }
  ne.empty = ae;
  function fe(ye) {
    return new oe.Observable(function(ge) {
      return ye.schedule(function() {
        return ge.complete();
      });
    });
  }
}), dh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isScheduler = void 0;
  var oe = Mt();
  function ae(fe) {
    return fe && oe.isFunction(fe.schedule);
  }
  ne.isScheduler = ae;
}), ki = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.popNumber = ne.popScheduler = ne.popResultSelector = void 0;
  var oe = Mt(), ae = dh();
  function fe(_e) {
    return _e[_e.length - 1];
  }
  function ye(_e) {
    return oe.isFunction(fe(_e)) ? _e.pop() : void 0;
  }
  ne.popResultSelector = ye;
  function ge(_e) {
    return ae.isScheduler(fe(_e)) ? _e.pop() : void 0;
  }
  ne.popScheduler = ge;
  function we(_e, Se) {
    return typeof fe(_e) == "number" ? _e.pop() : Se;
  }
  ne.popNumber = we;
}), sS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isArrayLike = void 0, ne.isArrayLike = function(oe) {
    return oe && typeof oe.length == "number" && typeof oe != "function";
  };
}), tA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isPromise = void 0;
  var oe = Mt();
  function ae(fe) {
    return oe.isFunction(fe == null ? void 0 : fe.then);
  }
  ne.isPromise = ae;
}), rA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isInteropObservable = void 0;
  var oe = uh(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye[oe.observable]);
  }
  ne.isInteropObservable = fe;
}), nA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isAsyncIterable = void 0;
  var oe = Mt();
  function ae(fe) {
    return Symbol.asyncIterator && oe.isFunction(fe == null ? void 0 : fe[Symbol.asyncIterator]);
  }
  ne.isAsyncIterable = ae;
}), iA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createInvalidObservableTypeError = void 0;
  function oe(ae) {
    return new TypeError("You provided " + (ae !== null && typeof ae == "object" ? "an invalid object" : "'" + ae + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  ne.createInvalidObservableTypeError = oe;
}), aA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iterator = ne.getSymbolIterator = void 0;
  function oe() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
  }
  ne.getSymbolIterator = oe, ne.iterator = oe();
}), oA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isIterable = void 0;
  var oe = aA(), ae = Mt();
  function fe(ye) {
    return ae.isFunction(ye == null ? void 0 : ye[oe.iterator]);
  }
  ne.isIterable = fe;
}), mS = M((ne) => {
  var oe = ne && ne.__generator || function(_e, Se) {
    var Ie = { label: 0, sent: function() {
      if (Me[0] & 1)
        throw Me[1];
      return Me[1];
    }, trys: [], ops: [] }, $e, Ne, Me, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(Ze) {
      return function(qe) {
        return He([Ze, qe]);
      };
    }
    function He(Ze) {
      if ($e)
        throw new TypeError("Generator is already executing.");
      for (; Ie; )
        try {
          if ($e = 1, Ne && (Me = Ze[0] & 2 ? Ne.return : Ze[0] ? Ne.throw || ((Me = Ne.return) && Me.call(Ne), 0) : Ne.next) && !(Me = Me.call(Ne, Ze[1])).done)
            return Me;
          switch (Ne = 0, Me && (Ze = [Ze[0] & 2, Me.value]), Ze[0]) {
            case 0:
            case 1:
              Me = Ze;
              break;
            case 4:
              return Ie.label++, { value: Ze[1], done: !1 };
            case 5:
              Ie.label++, Ne = Ze[1], Ze = [0];
              continue;
            case 7:
              Ze = Ie.ops.pop(), Ie.trys.pop();
              continue;
            default:
              if (Me = Ie.trys, !(Me = Me.length > 0 && Me[Me.length - 1]) && (Ze[0] === 6 || Ze[0] === 2)) {
                Ie = 0;
                continue;
              }
              if (Ze[0] === 3 && (!Me || Ze[1] > Me[0] && Ze[1] < Me[3])) {
                Ie.label = Ze[1];
                break;
              }
              if (Ze[0] === 6 && Ie.label < Me[1]) {
                Ie.label = Me[1], Me = Ze;
                break;
              }
              if (Me && Ie.label < Me[2]) {
                Ie.label = Me[2], Ie.ops.push(Ze);
                break;
              }
              Me[2] && Ie.ops.pop(), Ie.trys.pop();
              continue;
          }
          Ze = Se.call(_e, Ie);
        } catch (qe) {
          Ze = [6, qe], Ne = 0;
        } finally {
          $e = Me = 0;
        }
      if (Ze[0] & 5)
        throw Ze[1];
      return { value: Ze[0] ? Ze[1] : void 0, done: !0 };
    }
  }, ae = ne && ne.__await || function(_e) {
    return this instanceof ae ? (this.v = _e, this) : new ae(_e);
  }, fe = ne && ne.__asyncGenerator || function(_e, Se, Ie) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var $e = Ie.apply(_e, Se || []), Ne, Me = [];
    return Ne = {}, Be("next"), Be("throw"), Be("return"), Ne[Symbol.asyncIterator] = function() {
      return this;
    }, Ne;
    function Be(Xe) {
      $e[Xe] && (Ne[Xe] = function(ot) {
        return new Promise(function(pt, ht) {
          Me.push([Xe, ot, pt, ht]) > 1 || ze(Xe, ot);
        });
      });
    }
    function ze(Xe, ot) {
      try {
        He($e[Xe](ot));
      } catch (pt) {
        tt(Me[0][3], pt);
      }
    }
    function He(Xe) {
      Xe.value instanceof ae ? Promise.resolve(Xe.value.v).then(Ze, qe) : tt(Me[0][2], Xe);
    }
    function Ze(Xe) {
      ze("next", Xe);
    }
    function qe(Xe) {
      ze("throw", Xe);
    }
    function tt(Xe, ot) {
      Xe(ot), Me.shift(), Me.length && ze(Me[0][0], Me[0][1]);
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isReadableStreamLike = ne.readableStreamLikeToAsyncGenerator = void 0;
  var ye = Mt();
  function ge(_e) {
    return fe(this, arguments, function() {
      var Se, Ie, $e, Ne;
      return oe(this, function(Me) {
        switch (Me.label) {
          case 0:
            Se = _e.getReader(), Me.label = 1;
          case 1:
            Me.trys.push([1, , 9, 10]), Me.label = 2;
          case 2:
            return [4, ae(Se.read())];
          case 3:
            return Ie = Me.sent(), $e = Ie.value, Ne = Ie.done, Ne ? [4, ae(void 0)] : [3, 5];
          case 4:
            return [2, Me.sent()];
          case 5:
            return [4, ae($e)];
          case 6:
            return [4, Me.sent()];
          case 7:
            return Me.sent(), [3, 2];
          case 8:
            return [3, 10];
          case 9:
            return Se.releaseLock(), [7];
          case 10:
            return [2];
        }
      });
    });
  }
  ne.readableStreamLikeToAsyncGenerator = ge;
  function we(_e) {
    return ye.isFunction(_e == null ? void 0 : _e.getReader);
  }
  ne.isReadableStreamLike = we;
}), _t = M((ne) => {
  var oe = ne && ne.__awaiter || function(gt, It, Nt, Ft) {
    function on(en) {
      return en instanceof Nt ? en : new Nt(function(wn) {
        wn(en);
      });
    }
    return new (Nt || (Nt = Promise))(function(en, wn) {
      function Zt(dn) {
        try {
          un(Ft.next(dn));
        } catch (xn) {
          wn(xn);
        }
      }
      function pn(dn) {
        try {
          un(Ft.throw(dn));
        } catch (xn) {
          wn(xn);
        }
      }
      function un(dn) {
        dn.done ? en(dn.value) : on(dn.value).then(Zt, pn);
      }
      un((Ft = Ft.apply(gt, It || [])).next());
    });
  }, ae = ne && ne.__generator || function(gt, It) {
    var Nt = { label: 0, sent: function() {
      if (en[0] & 1)
        throw en[1];
      return en[1];
    }, trys: [], ops: [] }, Ft, on, en, wn;
    return wn = { next: Zt(0), throw: Zt(1), return: Zt(2) }, typeof Symbol == "function" && (wn[Symbol.iterator] = function() {
      return this;
    }), wn;
    function Zt(un) {
      return function(dn) {
        return pn([un, dn]);
      };
    }
    function pn(un) {
      if (Ft)
        throw new TypeError("Generator is already executing.");
      for (; Nt; )
        try {
          if (Ft = 1, on && (en = un[0] & 2 ? on.return : un[0] ? on.throw || ((en = on.return) && en.call(on), 0) : on.next) && !(en = en.call(on, un[1])).done)
            return en;
          switch (on = 0, en && (un = [un[0] & 2, en.value]), un[0]) {
            case 0:
            case 1:
              en = un;
              break;
            case 4:
              return Nt.label++, { value: un[1], done: !1 };
            case 5:
              Nt.label++, on = un[1], un = [0];
              continue;
            case 7:
              un = Nt.ops.pop(), Nt.trys.pop();
              continue;
            default:
              if (en = Nt.trys, !(en = en.length > 0 && en[en.length - 1]) && (un[0] === 6 || un[0] === 2)) {
                Nt = 0;
                continue;
              }
              if (un[0] === 3 && (!en || un[1] > en[0] && un[1] < en[3])) {
                Nt.label = un[1];
                break;
              }
              if (un[0] === 6 && Nt.label < en[1]) {
                Nt.label = en[1], en = un;
                break;
              }
              if (en && Nt.label < en[2]) {
                Nt.label = en[2], Nt.ops.push(un);
                break;
              }
              en[2] && Nt.ops.pop(), Nt.trys.pop();
              continue;
          }
          un = It.call(gt, Nt);
        } catch (dn) {
          un = [6, dn], on = 0;
        } finally {
          Ft = en = 0;
        }
      if (un[0] & 5)
        throw un[1];
      return { value: un[0] ? un[1] : void 0, done: !0 };
    }
  }, fe = ne && ne.__asyncValues || function(gt) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var It = gt[Symbol.asyncIterator], Nt;
    return It ? It.call(gt) : (gt = typeof ye == "function" ? ye(gt) : gt[Symbol.iterator](), Nt = {}, Ft("next"), Ft("throw"), Ft("return"), Nt[Symbol.asyncIterator] = function() {
      return this;
    }, Nt);
    function Ft(en) {
      Nt[en] = gt[en] && function(wn) {
        return new Promise(function(Zt, pn) {
          wn = gt[en](wn), on(Zt, pn, wn.done, wn.value);
        });
      };
    }
    function on(en, wn, Zt, pn) {
      Promise.resolve(pn).then(function(un) {
        en({ value: un, done: Zt });
      }, wn);
    }
  }, ye = ne && ne.__values || function(gt) {
    var It = typeof Symbol == "function" && Symbol.iterator, Nt = It && gt[It], Ft = 0;
    if (Nt)
      return Nt.call(gt);
    if (gt && typeof gt.length == "number")
      return { next: function() {
        return gt && Ft >= gt.length && (gt = void 0), { value: gt && gt[Ft++], done: !gt };
      } };
    throw new TypeError(It ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromReadableStreamLike = ne.fromAsyncIterable = ne.fromIterable = ne.fromPromise = ne.fromArrayLike = ne.fromInteropObservable = ne.innerFrom = void 0;
  var ge = sS(), we = tA(), _e = qt(), Se = rA(), Ie = nA(), $e = iA(), Ne = oA(), Me = mS(), Be = Mt(), ze = Fk(), He = uh();
  function Ze(gt) {
    if (gt instanceof _e.Observable)
      return gt;
    if (gt != null) {
      if (Se.isInteropObservable(gt))
        return qe(gt);
      if (ge.isArrayLike(gt))
        return tt(gt);
      if (we.isPromise(gt))
        return Xe(gt);
      if (Ie.isAsyncIterable(gt))
        return pt(gt);
      if (Ne.isIterable(gt))
        return ot(gt);
      if (Me.isReadableStreamLike(gt))
        return ht(gt);
    }
    throw $e.createInvalidObservableTypeError(gt);
  }
  ne.innerFrom = Ze;
  function qe(gt) {
    return new _e.Observable(function(It) {
      var Nt = gt[He.observable]();
      if (Be.isFunction(Nt.subscribe))
        return Nt.subscribe(It);
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  ne.fromInteropObservable = qe;
  function tt(gt) {
    return new _e.Observable(function(It) {
      for (var Nt = 0; Nt < gt.length && !It.closed; Nt++)
        It.next(gt[Nt]);
      It.complete();
    });
  }
  ne.fromArrayLike = tt;
  function Xe(gt) {
    return new _e.Observable(function(It) {
      gt.then(function(Nt) {
        It.closed || (It.next(Nt), It.complete());
      }, function(Nt) {
        return It.error(Nt);
      }).then(null, ze.reportUnhandledError);
    });
  }
  ne.fromPromise = Xe;
  function ot(gt) {
    return new _e.Observable(function(It) {
      var Nt, Ft;
      try {
        for (var on = ye(gt), en = on.next(); !en.done; en = on.next()) {
          var wn = en.value;
          if (It.next(wn), It.closed)
            return;
        }
      } catch (Zt) {
        Nt = { error: Zt };
      } finally {
        try {
          en && !en.done && (Ft = on.return) && Ft.call(on);
        } finally {
          if (Nt)
            throw Nt.error;
        }
      }
      It.complete();
    });
  }
  ne.fromIterable = ot;
  function pt(gt) {
    return new _e.Observable(function(It) {
      wt(gt, It).catch(function(Nt) {
        return It.error(Nt);
      });
    });
  }
  ne.fromAsyncIterable = pt;
  function ht(gt) {
    return pt(Me.readableStreamLikeToAsyncGenerator(gt));
  }
  ne.fromReadableStreamLike = ht;
  function wt(gt, It) {
    var Nt, Ft, on, en;
    return oe(this, void 0, void 0, function() {
      var wn, Zt;
      return ae(this, function(pn) {
        switch (pn.label) {
          case 0:
            pn.trys.push([0, 5, 6, 11]), Nt = fe(gt), pn.label = 1;
          case 1:
            return [4, Nt.next()];
          case 2:
            if (Ft = pn.sent(), !!Ft.done)
              return [3, 4];
            if (wn = Ft.value, It.next(wn), It.closed)
              return [2];
            pn.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return Zt = pn.sent(), on = { error: Zt }, [3, 11];
          case 6:
            return pn.trys.push([6, , 9, 10]), Ft && !Ft.done && (en = Nt.return) ? [4, en.call(Nt)] : [3, 8];
          case 7:
            pn.sent(), pn.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (on)
              throw on.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return It.complete(), [2];
        }
      });
    });
  }
}), Au = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.executeSchedule = void 0;
  function oe(ae, fe, ye, ge, we) {
    ge === void 0 && (ge = 0), we === void 0 && (we = !1);
    var _e = fe.schedule(function() {
      ye(), we ? ae.add(this.schedule(null, ge)) : this.unsubscribe();
    }, ge);
    if (ae.add(_e), !we)
      return _e;
  }
  ne.executeSchedule = oe;
}), ph = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeOn = void 0;
  var oe = Au(), ae = he(), fe = Ae();
  function ye(ge, we) {
    return we === void 0 && (we = 0), ae.operate(function(_e, Se) {
      _e.subscribe(fe.createOperatorSubscriber(Se, function(Ie) {
        return oe.executeSchedule(Se, ge, function() {
          return Se.next(Ie);
        }, we);
      }, function() {
        return oe.executeSchedule(Se, ge, function() {
          return Se.complete();
        }, we);
      }, function(Ie) {
        return oe.executeSchedule(Se, ge, function() {
          return Se.error(Ie);
        }, we);
      }));
    });
  }
  ne.observeOn = ye;
}), vh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.subscribeOn = void 0;
  var oe = he();
  function ae(fe, ye) {
    return ye === void 0 && (ye = 0), oe.operate(function(ge, we) {
      we.add(fe.schedule(function() {
        return ge.subscribe(we);
      }, ye));
    });
  }
  ne.subscribeOn = ae;
}), JI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleObservable = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(ge, we) {
    return oe.innerFrom(ge).pipe(fe.subscribeOn(we), ae.observeOn(we));
  }
  ne.scheduleObservable = ye;
}), ZI = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.schedulePromise = void 0;
  var oe = _t(), ae = ph(), fe = vh();
  function ye(ge, we) {
    return oe.innerFrom(ge).pipe(fe.subscribeOn(we), ae.observeOn(we));
  }
  ne.schedulePromise = ye;
}), e3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleArray = void 0;
  var oe = qt();
  function ae(fe, ye) {
    return new oe.Observable(function(ge) {
      var we = 0;
      return ye.schedule(function() {
        we === fe.length ? ge.complete() : (ge.next(fe[we++]), ge.closed || this.schedule());
      });
    });
  }
  ne.scheduleArray = ae;
}), cA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleIterable = void 0;
  var oe = qt(), ae = aA(), fe = Mt(), ye = Au();
  function ge(we, _e) {
    return new oe.Observable(function(Se) {
      var Ie;
      return ye.executeSchedule(Se, _e, function() {
        Ie = we[ae.iterator](), ye.executeSchedule(Se, _e, function() {
          var $e, Ne, Me;
          try {
            $e = Ie.next(), Ne = $e.value, Me = $e.done;
          } catch (Be) {
            Se.error(Be);
            return;
          }
          Me ? Se.complete() : Se.next(Ne);
        }, 0, !0);
      }), function() {
        return fe.isFunction(Ie == null ? void 0 : Ie.return) && Ie.return();
      };
    });
  }
  ne.scheduleIterable = ge;
}), fA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleAsyncIterable = void 0;
  var oe = qt(), ae = Au();
  function fe(ye, ge) {
    if (!ye)
      throw new Error("Iterable cannot be null");
    return new oe.Observable(function(we) {
      ae.executeSchedule(we, ge, function() {
        var _e = ye[Symbol.asyncIterator]();
        ae.executeSchedule(we, ge, function() {
          _e.next().then(function(Se) {
            Se.done ? we.complete() : we.next(Se.value);
          });
        }, 0, !0);
      });
    });
  }
  ne.scheduleAsyncIterable = fe;
}), n3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduleReadableStreamLike = void 0;
  var oe = fA(), ae = mS();
  function fe(ye, ge) {
    return oe.scheduleAsyncIterable(ae.readableStreamLikeToAsyncGenerator(ye), ge);
  }
  ne.scheduleReadableStreamLike = fe;
}), dA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scheduled = void 0;
  var oe = JI(), ae = ZI(), fe = e3(), ye = cA(), ge = fA(), we = rA(), _e = tA(), Se = sS(), Ie = oA(), $e = nA(), Ne = iA(), Me = mS(), Be = n3();
  function ze(He, Ze) {
    if (He != null) {
      if (we.isInteropObservable(He))
        return oe.scheduleObservable(He, Ze);
      if (Se.isArrayLike(He))
        return fe.scheduleArray(He, Ze);
      if (_e.isPromise(He))
        return ae.schedulePromise(He, Ze);
      if ($e.isAsyncIterable(He))
        return ge.scheduleAsyncIterable(He, Ze);
      if (Ie.isIterable(He))
        return ye.scheduleIterable(He, Ze);
      if (Me.isReadableStreamLike(He))
        return Be.scheduleReadableStreamLike(He, Ze);
    }
    throw Ne.createInvalidObservableTypeError(He);
  }
  ne.scheduled = ze;
}), Ja = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.from = void 0;
  var oe = dA(), ae = _t();
  function fe(ye, ge) {
    return ge ? oe.scheduled(ye, ge) : ae.innerFrom(ye);
  }
  ne.from = fe;
}), TS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.of = void 0;
  var oe = ki(), ae = Ja();
  function fe() {
    for (var ye = [], ge = 0; ge < arguments.length; ge++)
      ye[ge] = arguments[ge];
    var we = oe.popScheduler(ye);
    return ae.from(ye, we);
  }
  ne.of = fe;
}), pA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwError = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye, ge) {
    var we = ae.isFunction(ye) ? ye : function() {
      return ye;
    }, _e = function(Se) {
      return Se.error(we());
    };
    return new oe.Observable(ge ? function(Se) {
      return ge.schedule(_e, 0, Se);
    } : _e);
  }
  ne.throwError = fe;
}), AS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.observeNotification = ne.Notification = ne.NotificationKind = void 0;
  var oe = ba(), ae = TS(), fe = pA(), ye = Mt();
  (function(_e) {
    _e.NEXT = "N", _e.ERROR = "E", _e.COMPLETE = "C";
  })(ne.NotificationKind || (ne.NotificationKind = {}));
  var ge = function() {
    function _e(Se, Ie, $e) {
      this.kind = Se, this.value = Ie, this.error = $e, this.hasValue = Se === "N";
    }
    return _e.prototype.observe = function(Se) {
      return we(this, Se);
    }, _e.prototype.do = function(Se, Ie, $e) {
      var Ne = this, Me = Ne.kind, Be = Ne.value, ze = Ne.error;
      return Me === "N" ? Se == null ? void 0 : Se(Be) : Me === "E" ? Ie == null ? void 0 : Ie(ze) : $e == null ? void 0 : $e();
    }, _e.prototype.accept = function(Se, Ie, $e) {
      var Ne;
      return ye.isFunction((Ne = Se) === null || Ne === void 0 ? void 0 : Ne.next) ? this.observe(Se) : this.do(Se, Ie, $e);
    }, _e.prototype.toObservable = function() {
      var Se = this, Ie = Se.kind, $e = Se.value, Ne = Se.error, Me = Ie === "N" ? ae.of($e) : Ie === "E" ? fe.throwError(function() {
        return Ne;
      }) : Ie === "C" ? oe.EMPTY : 0;
      if (!Me)
        throw new TypeError("Unexpected notification kind " + Ie);
      return Me;
    }, _e.createNext = function(Se) {
      return new _e("N", Se);
    }, _e.createError = function(Se) {
      return new _e("E", void 0, Se);
    }, _e.createComplete = function() {
      return _e.completeNotification;
    }, _e.completeNotification = new _e("C"), _e;
  }();
  ne.Notification = ge;
  function we(_e, Se) {
    var Ie, $e, Ne, Me = _e, Be = Me.kind, ze = Me.value, He = Me.error;
    if (typeof Be != "string")
      throw new TypeError('Invalid notification, missing "kind"');
    Be === "N" ? (Ie = Se.next) === null || Ie === void 0 || Ie.call(Se, ze) : Be === "E" ? ($e = Se.error) === null || $e === void 0 || $e.call(Se, He) : (Ne = Se.complete) === null || Ne === void 0 || Ne.call(Se);
  }
  ne.observeNotification = we;
}), o3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isObservable = void 0;
  var oe = qt(), ae = Mt();
  function fe(ye) {
    return !!ye && (ye instanceof oe.Observable || ae.isFunction(ye.lift) && ae.isFunction(ye.subscribe));
  }
  ne.isObservable = fe;
}), $l = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.EmptyError = void 0;
  var oe = Il();
  ne.EmptyError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "EmptyError", this.message = "no elements in sequence";
    };
  });
}), u3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.lastValueFrom = void 0;
  var oe = $l();
  function ae(fe, ye) {
    var ge = typeof ye == "object";
    return new Promise(function(we, _e) {
      var Se = !1, Ie;
      fe.subscribe({ next: function($e) {
        Ie = $e, Se = !0;
      }, error: _e, complete: function() {
        Se ? we(Ie) : ge ? we(ye.defaultValue) : _e(new oe.EmptyError());
      } });
    });
  }
  ne.lastValueFrom = ae;
}), l3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.firstValueFrom = void 0;
  var oe = $l(), ae = Sd();
  function fe(ye, ge) {
    var we = typeof ge == "object";
    return new Promise(function(_e, Se) {
      var Ie = new ae.SafeSubscriber({ next: function($e) {
        _e($e), Ie.unsubscribe();
      }, error: Se, complete: function() {
        we ? _e(ge.defaultValue) : Se(new oe.EmptyError());
      } });
      ye.subscribe(Ie);
    });
  }
  ne.firstValueFrom = fe;
}), vA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ArgumentOutOfRangeError = void 0;
  var oe = Il();
  ne.ArgumentOutOfRangeError = oe.createErrorClass(function(ae) {
    return function() {
      ae(this), this.name = "ArgumentOutOfRangeError", this.message = "argument out of range";
    };
  });
}), mA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.NotFoundError = void 0;
  var oe = Il();
  ne.NotFoundError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "NotFoundError", this.message = fe;
    };
  });
}), hA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.SequenceError = void 0;
  var oe = Il();
  ne.SequenceError = oe.createErrorClass(function(ae) {
    return function(fe) {
      ae(this), this.name = "SequenceError", this.message = fe;
    };
  });
}), zS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isValidDate = void 0;
  function oe(ae) {
    return ae instanceof Date && !isNaN(ae);
  }
  ne.isValidDate = oe;
}), qS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeout = ne.TimeoutError = void 0;
  var oe = Ti(), ae = zS(), fe = he(), ye = _t(), ge = Il(), we = Ae(), _e = Au();
  ne.TimeoutError = ge.createErrorClass(function($e) {
    return function(Ne) {
      Ne === void 0 && (Ne = null), $e(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = Ne;
    };
  });
  function Se($e, Ne) {
    var Me = ae.isValidDate($e) ? { first: $e } : typeof $e == "number" ? { each: $e } : $e, Be = Me.first, ze = Me.each, He = Me.with, Ze = He === void 0 ? Ie : He, qe = Me.scheduler, tt = qe === void 0 ? Ne ?? oe.asyncScheduler : qe, Xe = Me.meta, ot = Xe === void 0 ? null : Xe;
    if (Be == null && ze == null)
      throw new TypeError("No timeout provided.");
    return fe.operate(function(pt, ht) {
      var wt, gt, It = null, Nt = 0, Ft = function(on) {
        gt = _e.executeSchedule(ht, tt, function() {
          try {
            wt.unsubscribe(), ye.innerFrom(Ze({ meta: ot, lastValue: It, seen: Nt })).subscribe(ht);
          } catch (en) {
            ht.error(en);
          }
        }, on);
      };
      wt = pt.subscribe(we.createOperatorSubscriber(ht, function(on) {
        gt == null || gt.unsubscribe(), Nt++, ht.next(It = on), ze > 0 && Ft(ze);
      }, void 0, void 0, function() {
        gt != null && gt.closed || (gt == null || gt.unsubscribe()), It = null;
      })), !Nt && Ft(Be != null ? typeof Be == "number" ? Be : +Be - tt.now() : ze);
    });
  }
  ne.timeout = Se;
  function Ie($e) {
    throw new ne.TimeoutError($e);
  }
}), Wl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.map = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ge) {
    return oe.operate(function(we, _e) {
      var Se = 0;
      we.subscribe(ae.createOperatorSubscriber(_e, function(Ie) {
        _e.next(ye.call(ge, Ie, Se++));
      }));
    });
  }
  ne.map = fe;
}), Gl = M((ne) => {
  var oe = ne && ne.__read || function(_e, Se) {
    var Ie = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Ie)
      return _e;
    var $e = Ie.call(_e), Ne, Me = [], Be;
    try {
      for (; (Se === void 0 || Se-- > 0) && !(Ne = $e.next()).done; )
        Me.push(Ne.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Ne && !Ne.done && (Ie = $e.return) && Ie.call($e);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(_e, Se) {
    for (var Ie = 0, $e = Se.length, Ne = _e.length; Ie < $e; Ie++, Ne++)
      _e[Ne] = Se[Ie];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapOneOrManyArgs = void 0;
  var fe = Wl(), ye = Array.isArray;
  function ge(_e, Se) {
    return ye(Se) ? _e.apply(void 0, ae([], oe(Se))) : _e(Se);
  }
  function we(_e) {
    return fe.map(function(Se) {
      return ge(_e, Se);
    });
  }
  ne.mapOneOrManyArgs = we;
}), gA = M((ne) => {
  var oe = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallbackInternals = void 0;
  var fe = dh(), ye = qt(), ge = vh(), we = Gl(), _e = ph(), Se = iS();
  function Ie($e, Ne, Me, Be) {
    if (Me)
      if (fe.isScheduler(Me))
        Be = Me;
      else
        return function() {
          for (var ze = [], He = 0; He < arguments.length; He++)
            ze[He] = arguments[He];
          return Ie($e, Ne, Be).apply(this, ze).pipe(we.mapOneOrManyArgs(Me));
        };
    return Be ? function() {
      for (var ze = [], He = 0; He < arguments.length; He++)
        ze[He] = arguments[He];
      return Ie($e, Ne).apply(this, ze).pipe(ge.subscribeOn(Be), _e.observeOn(Be));
    } : function() {
      for (var ze = this, He = [], Ze = 0; Ze < arguments.length; Ze++)
        He[Ze] = arguments[Ze];
      var qe = new Se.AsyncSubject(), tt = !0;
      return new ye.Observable(function(Xe) {
        var ot = qe.subscribe(Xe);
        if (tt) {
          tt = !1;
          var pt = !1, ht = !1;
          Ne.apply(ze, ae(ae([], oe(He)), [function() {
            for (var wt = [], gt = 0; gt < arguments.length; gt++)
              wt[gt] = arguments[gt];
            if ($e) {
              var It = wt.shift();
              if (It != null) {
                qe.error(It);
                return;
              }
            }
            qe.next(1 < wt.length ? wt : wt[0]), ht = !0, pt && qe.complete();
          }])), ht && qe.complete(), pt = !0;
        }
        return ot;
      });
    };
  }
  ne.bindCallbackInternals = Ie;
}), c3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindCallback = void 0;
  var oe = gA();
  function ae(fe, ye, ge) {
    return oe.bindCallbackInternals(!1, fe, ye, ge);
  }
  ne.bindCallback = ae;
}), f3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bindNodeCallback = void 0;
  var oe = gA();
  function ae(fe, ye, ge) {
    return oe.bindCallbackInternals(!0, fe, ye, ge);
  }
  ne.bindNodeCallback = ae;
}), bA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsArgArrayOrObject = void 0;
  var oe = Array.isArray, ae = Object.getPrototypeOf, fe = Object.prototype, ye = Object.keys;
  function ge(_e) {
    if (_e.length === 1) {
      var Se = _e[0];
      if (oe(Se))
        return { args: Se, keys: null };
      if (we(Se)) {
        var Ie = ye(Se);
        return { args: Ie.map(function($e) {
          return Se[$e];
        }), keys: Ie };
      }
    }
    return { args: _e, keys: null };
  }
  ne.argsArgArrayOrObject = ge;
  function we(_e) {
    return _e && typeof _e == "object" && ae(_e) === fe;
  }
}), SA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createObject = void 0;
  function oe(ae, fe) {
    return ae.reduce(function(ye, ge, we) {
      return ye[ge] = fe[we], ye;
    }, {});
  }
  ne.createObject = oe;
}), WS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestInit = ne.combineLatest = void 0;
  var oe = qt(), ae = bA(), fe = Ja(), ye = Hn(), ge = Gl(), we = ki(), _e = SA(), Se = Ae(), Ie = Au();
  function $e() {
    for (var Be = [], ze = 0; ze < arguments.length; ze++)
      Be[ze] = arguments[ze];
    var He = we.popScheduler(Be), Ze = we.popResultSelector(Be), qe = ae.argsArgArrayOrObject(Be), tt = qe.args, Xe = qe.keys;
    if (tt.length === 0)
      return fe.from([], He);
    var ot = new oe.Observable(Ne(tt, He, Xe ? function(pt) {
      return _e.createObject(Xe, pt);
    } : ye.identity));
    return Ze ? ot.pipe(ge.mapOneOrManyArgs(Ze)) : ot;
  }
  ne.combineLatest = $e;
  function Ne(Be, ze, He) {
    return He === void 0 && (He = ye.identity), function(Ze) {
      Me(ze, function() {
        for (var qe = Be.length, tt = new Array(qe), Xe = qe, ot = qe, pt = function(wt) {
          Me(ze, function() {
            var gt = fe.from(Be[wt], ze), It = !1;
            gt.subscribe(Se.createOperatorSubscriber(Ze, function(Nt) {
              tt[wt] = Nt, It || (It = !0, ot--), ot || Ze.next(He(tt.slice()));
            }, function() {
              --Xe || Ze.complete();
            }));
          }, Ze);
        }, ht = 0; ht < qe; ht++)
          pt(ht);
      }, Ze);
    };
  }
  ne.combineLatestInit = Ne;
  function Me(Be, ze, He) {
    Be ? Ie.executeSchedule(He, Be, ze) : ze();
  }
}), GS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeInternals = void 0;
  var oe = _t(), ae = Au(), fe = Ae();
  function ye(ge, we, _e, Se, Ie, $e, Ne, Me) {
    var Be = [], ze = 0, He = 0, Ze = !1, qe = function() {
      Ze && !Be.length && !ze && we.complete();
    }, tt = function(ot) {
      return ze < Se ? Xe(ot) : Be.push(ot);
    }, Xe = function(ot) {
      $e && we.next(ot), ze++;
      var pt = !1;
      oe.innerFrom(_e(ot, He++)).subscribe(fe.createOperatorSubscriber(we, function(ht) {
        Ie == null || Ie(ht), $e ? tt(ht) : we.next(ht);
      }, function() {
        pt = !0;
      }, void 0, function() {
        if (pt)
          try {
            ze--;
            for (var ht = function() {
              var wt = Be.shift();
              Ne ? ae.executeSchedule(we, Ne, function() {
                return Xe(wt);
              }) : Xe(wt);
            }; Be.length && ze < Se; )
              ht();
            qe();
          } catch (wt) {
            we.error(wt);
          }
      }));
    };
    return ge.subscribe(fe.createOperatorSubscriber(we, tt, function() {
      Ze = !0, qe();
    })), function() {
      Me == null || Me();
    };
  }
  ne.mergeInternals = ye;
}), Mu = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = GS(), ge = Mt();
  function we(_e, Se, Ie) {
    return Ie === void 0 && (Ie = 1 / 0), ge.isFunction(Se) ? we(function($e, Ne) {
      return oe.map(function(Me, Be) {
        return Se($e, Me, Ne, Be);
      })(ae.innerFrom(_e($e, Ne)));
    }, Ie) : (typeof Se == "number" && (Ie = Se), fe.operate(function($e, Ne) {
      return ye.mergeInternals($e, Ne, _e, Ie);
    }));
  }
  ne.mergeMap = we;
}), mh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeAll = void 0;
  var oe = Mu(), ae = Hn();
  function fe(ye) {
    return ye === void 0 && (ye = 1 / 0), oe.mergeMap(ae.identity, ye);
  }
  ne.mergeAll = fe;
}), JS = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatAll = void 0;
  var oe = mh();
  function ae() {
    return oe.mergeAll(1);
  }
  ne.concatAll = ae;
}), hh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var oe = JS(), ae = ki(), fe = Ja();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return oe.concatAll()(fe.from(ge, ae.popScheduler(ge)));
  }
  ne.concat = ye;
}), yh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defer = void 0;
  var oe = qt(), ae = _t();
  function fe(ye) {
    return new oe.Observable(function(ge) {
      ae.innerFrom(ye()).subscribe(ge);
    });
  }
  ne.defer = fe;
}), b3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connectable = void 0;
  var oe = Tn(), ae = qt(), fe = yh(), ye = { connector: function() {
    return new oe.Subject();
  }, resetOnDisconnect: !0 };
  function ge(we, _e) {
    _e === void 0 && (_e = ye);
    var Se = null, Ie = _e.connector, $e = _e.resetOnDisconnect, Ne = $e === void 0 ? !0 : $e, Me = Ie(), Be = new ae.Observable(function(ze) {
      return Me.subscribe(ze);
    });
    return Be.connect = function() {
      return (!Se || Se.closed) && (Se = fe.defer(function() {
        return we;
      }).subscribe(Me), Ne && Se.add(function() {
        return Me = Ie();
      })), Se;
    }, Be;
  }
  ne.connectable = ge;
}), S3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.forkJoin = void 0;
  var oe = qt(), ae = bA(), fe = _t(), ye = ki(), ge = Ae(), we = Gl(), _e = SA();
  function Se() {
    for (var Ie = [], $e = 0; $e < arguments.length; $e++)
      Ie[$e] = arguments[$e];
    var Ne = ye.popResultSelector(Ie), Me = ae.argsArgArrayOrObject(Ie), Be = Me.args, ze = Me.keys, He = new oe.Observable(function(Ze) {
      var qe = Be.length;
      if (!qe) {
        Ze.complete();
        return;
      }
      for (var tt = new Array(qe), Xe = qe, ot = qe, pt = function(wt) {
        var gt = !1;
        fe.innerFrom(Be[wt]).subscribe(ge.createOperatorSubscriber(Ze, function(It) {
          gt || (gt = !0, ot--), tt[wt] = It;
        }, function() {
          return Xe--;
        }, void 0, function() {
          (!Xe || !gt) && (ot || Ze.next(ze ? _e.createObject(ze, tt) : tt), Ze.complete());
        }));
      }, ht = 0; ht < qe; ht++)
        pt(ht);
    });
    return Ne ? He.pipe(we.mapOneOrManyArgs(Ne)) : He;
  }
  ne.forkJoin = Se;
}), w3 = M((ne) => {
  var oe = ne && ne.__read || function(Ze, qe) {
    var tt = typeof Symbol == "function" && Ze[Symbol.iterator];
    if (!tt)
      return Ze;
    var Xe = tt.call(Ze), ot, pt = [], ht;
    try {
      for (; (qe === void 0 || qe-- > 0) && !(ot = Xe.next()).done; )
        pt.push(ot.value);
    } catch (wt) {
      ht = { error: wt };
    } finally {
      try {
        ot && !ot.done && (tt = Xe.return) && tt.call(Xe);
      } finally {
        if (ht)
          throw ht.error;
      }
    }
    return pt;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEvent = void 0;
  var ae = _t(), fe = qt(), ye = Mu(), ge = sS(), we = Mt(), _e = Gl(), Se = ["addListener", "removeListener"], Ie = ["addEventListener", "removeEventListener"], $e = ["on", "off"];
  function Ne(Ze, qe, tt, Xe) {
    if (we.isFunction(tt) && (Xe = tt, tt = void 0), Xe)
      return Ne(Ze, qe, tt).pipe(_e.mapOneOrManyArgs(Xe));
    var ot = oe(He(Ze) ? Ie.map(function(wt) {
      return function(gt) {
        return Ze[wt](qe, gt, tt);
      };
    }) : Be(Ze) ? Se.map(Me(Ze, qe)) : ze(Ze) ? $e.map(Me(Ze, qe)) : [], 2), pt = ot[0], ht = ot[1];
    if (!pt && ge.isArrayLike(Ze))
      return ye.mergeMap(function(wt) {
        return Ne(wt, qe, tt);
      })(ae.innerFrom(Ze));
    if (!pt)
      throw new TypeError("Invalid event target");
    return new fe.Observable(function(wt) {
      var gt = function() {
        for (var It = [], Nt = 0; Nt < arguments.length; Nt++)
          It[Nt] = arguments[Nt];
        return wt.next(1 < It.length ? It : It[0]);
      };
      return pt(gt), function() {
        return ht(gt);
      };
    });
  }
  ne.fromEvent = Ne;
  function Me(Ze, qe) {
    return function(tt) {
      return function(Xe) {
        return Ze[tt](qe, Xe);
      };
    };
  }
  function Be(Ze) {
    return we.isFunction(Ze.addListener) && we.isFunction(Ze.removeListener);
  }
  function ze(Ze) {
    return we.isFunction(Ze.on) && we.isFunction(Ze.off);
  }
  function He(Ze) {
    return we.isFunction(Ze.addEventListener) && we.isFunction(Ze.removeEventListener);
  }
}), E3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromEventPattern = void 0;
  var oe = qt(), ae = Mt(), fe = Gl();
  function ye(ge, we, _e) {
    return _e ? ye(ge, we).pipe(fe.mapOneOrManyArgs(_e)) : new oe.Observable(function(Se) {
      var Ie = function() {
        for (var Ne = [], Me = 0; Me < arguments.length; Me++)
          Ne[Me] = arguments[Me];
        return Se.next(Ne.length === 1 ? Ne[0] : Ne);
      }, $e = ge(Ie);
      return ae.isFunction(we) ? function() {
        return we(Ie, $e);
      } : void 0;
    });
  }
  ne.fromEventPattern = ye;
}), R3 = M((ne) => {
  var oe = ne && ne.__generator || function(_e, Se) {
    var Ie = { label: 0, sent: function() {
      if (Me[0] & 1)
        throw Me[1];
      return Me[1];
    }, trys: [], ops: [] }, $e, Ne, Me, Be;
    return Be = { next: ze(0), throw: ze(1), return: ze(2) }, typeof Symbol == "function" && (Be[Symbol.iterator] = function() {
      return this;
    }), Be;
    function ze(Ze) {
      return function(qe) {
        return He([Ze, qe]);
      };
    }
    function He(Ze) {
      if ($e)
        throw new TypeError("Generator is already executing.");
      for (; Ie; )
        try {
          if ($e = 1, Ne && (Me = Ze[0] & 2 ? Ne.return : Ze[0] ? Ne.throw || ((Me = Ne.return) && Me.call(Ne), 0) : Ne.next) && !(Me = Me.call(Ne, Ze[1])).done)
            return Me;
          switch (Ne = 0, Me && (Ze = [Ze[0] & 2, Me.value]), Ze[0]) {
            case 0:
            case 1:
              Me = Ze;
              break;
            case 4:
              return Ie.label++, { value: Ze[1], done: !1 };
            case 5:
              Ie.label++, Ne = Ze[1], Ze = [0];
              continue;
            case 7:
              Ze = Ie.ops.pop(), Ie.trys.pop();
              continue;
            default:
              if (Me = Ie.trys, !(Me = Me.length > 0 && Me[Me.length - 1]) && (Ze[0] === 6 || Ze[0] === 2)) {
                Ie = 0;
                continue;
              }
              if (Ze[0] === 3 && (!Me || Ze[1] > Me[0] && Ze[1] < Me[3])) {
                Ie.label = Ze[1];
                break;
              }
              if (Ze[0] === 6 && Ie.label < Me[1]) {
                Ie.label = Me[1], Me = Ze;
                break;
              }
              if (Me && Ie.label < Me[2]) {
                Ie.label = Me[2], Ie.ops.push(Ze);
                break;
              }
              Me[2] && Ie.ops.pop(), Ie.trys.pop();
              continue;
          }
          Ze = Se.call(_e, Ie);
        } catch (qe) {
          Ze = [6, qe], Ne = 0;
        } finally {
          $e = Me = 0;
        }
      if (Ze[0] & 5)
        throw Ze[1];
      return { value: Ze[0] ? Ze[1] : void 0, done: !0 };
    }
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.generate = void 0;
  var ae = Hn(), fe = dh(), ye = yh(), ge = cA();
  function we(_e, Se, Ie, $e, Ne) {
    var Me, Be, ze, He;
    arguments.length === 1 ? (Me = _e, He = Me.initialState, Se = Me.condition, Ie = Me.iterate, Be = Me.resultSelector, ze = Be === void 0 ? ae.identity : Be, Ne = Me.scheduler) : (He = _e, !$e || fe.isScheduler($e) ? (ze = ae.identity, Ne = $e) : ze = $e);
    function Ze() {
      var qe;
      return oe(this, function(tt) {
        switch (tt.label) {
          case 0:
            qe = He, tt.label = 1;
          case 1:
            return !Se || Se(qe) ? [4, ze(qe)] : [3, 4];
          case 2:
            tt.sent(), tt.label = 3;
          case 3:
            return qe = Ie(qe), [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return ye.defer(Ne ? function() {
      return ge.scheduleIterable(Ze(), Ne);
    } : Ze);
  }
  ne.generate = we;
}), O3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.iif = void 0;
  var oe = yh();
  function ae(fe, ye, ge) {
    return oe.defer(function() {
      return fe() ? ye : ge;
    });
  }
  ne.iif = ae;
}), Kl = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timer = void 0;
  var oe = qt(), ae = Ti(), fe = dh(), ye = zS();
  function ge(we, _e, Se) {
    we === void 0 && (we = 0), Se === void 0 && (Se = ae.async);
    var Ie = -1;
    return _e != null && (fe.isScheduler(_e) ? Se = _e : Ie = _e), new oe.Observable(function($e) {
      var Ne = ye.isValidDate(we) ? +we - Se.now() : we;
      Ne < 0 && (Ne = 0);
      var Me = 0;
      return Se.schedule(function() {
        $e.closed || ($e.next(Me++), 0 <= Ie ? this.schedule(void 0, Ie) : $e.complete());
      }, Ne);
    });
  }
  ne.timer = ge;
}), wA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = void 0;
  var oe = Ti(), ae = Kl();
  function fe(ye, ge) {
    return ye === void 0 && (ye = 0), ge === void 0 && (ge = oe.asyncScheduler), ye < 0 && (ye = 0), ae.timer(ye, ye, ge);
  }
  ne.interval = fe;
}), k3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var oe = mh(), ae = _t(), fe = ba(), ye = ki(), ge = Ja();
  function we() {
    for (var _e = [], Se = 0; Se < arguments.length; Se++)
      _e[Se] = arguments[Se];
    var Ie = ye.popScheduler(_e), $e = ye.popNumber(_e, 1 / 0), Ne = _e;
    return Ne.length ? Ne.length === 1 ? ae.innerFrom(Ne[0]) : oe.mergeAll($e)(ge.from(Ne, Ie)) : fe.EMPTY;
  }
  ne.merge = we;
}), xA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.never = ne.NEVER = void 0;
  var oe = qt(), ae = On();
  ne.NEVER = new oe.Observable(ae.noop);
  function fe() {
    return ne.NEVER;
  }
  ne.never = fe;
}), Sc = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.argsOrArgArray = void 0;
  var oe = Array.isArray;
  function ae(fe) {
    return fe.length === 1 && oe(fe[0]) ? fe[0] : fe;
  }
  ne.argsOrArgArray = ae;
}), P3 = M((ne) => {
  var oe = ne && ne.__read || function(Ie, $e) {
    var Ne = typeof Symbol == "function" && Ie[Symbol.iterator];
    if (!Ne)
      return Ie;
    var Me = Ne.call(Ie), Be, ze = [], He;
    try {
      for (; ($e === void 0 || $e-- > 0) && !(Be = Me.next()).done; )
        ze.push(Be.value);
    } catch (Ze) {
      He = { error: Ze };
    } finally {
      try {
        Be && !Be.done && (Ne = Me.return) && Ne.call(Me);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function(Ie, $e) {
    for (var Ne = 0, Me = $e.length, Be = Ie.length; Ne < Me; Ne++, Be++)
      Ie[Be] = $e[Ne];
    return Ie;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var fe = he(), ye = _t(), ge = Sc(), we = Ae(), _e = On();
  function Se() {
    for (var Ie = [], $e = 0; $e < arguments.length; $e++)
      Ie[$e] = arguments[$e];
    var Ne = ge.argsOrArgArray(Ie);
    return fe.operate(function(Me, Be) {
      var ze = ae([Me], oe(Ne)), He = function() {
        if (!Be.closed)
          if (ze.length > 0) {
            var Ze = void 0;
            try {
              Ze = ye.innerFrom(ze.shift());
            } catch {
              He();
              return;
            }
            var qe = we.createOperatorSubscriber(Be, void 0, _e.noop, _e.noop);
            Ze.subscribe(qe), qe.add(He);
          } else
            Be.complete();
      };
      He();
    });
  }
  ne.onErrorResumeNext = Se;
}), M3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.onErrorResumeNext = void 0;
  var oe = ba(), ae = P3(), fe = Sc();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return ae.onErrorResumeNext(fe.argsOrArgArray(ge))(oe.EMPTY);
  }
  ne.onErrorResumeNext = ye;
}), D3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairs = void 0;
  var oe = Ja();
  function ae(fe, ye) {
    return oe.from(Object.entries(fe), ye);
  }
  ne.pairs = ae;
}), N3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.not = void 0;
  function oe(ae, fe) {
    return function(ye, ge) {
      return !ae.call(fe, ye, ge);
    };
  }
  ne.not = oe;
}), _c = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.filter = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ge) {
    return oe.operate(function(we, _e) {
      var Se = 0;
      we.subscribe(ae.createOperatorSubscriber(_e, function(Ie) {
        return ye.call(ge, Ie, Se++) && _e.next(Ie);
      }));
    });
  }
  ne.filter = fe;
}), U3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.partition = void 0;
  var oe = N3(), ae = _c(), fe = _t();
  function ye(ge, we, _e) {
    return [ae.filter(we, _e)(fe.innerFrom(ge)), ae.filter(oe.not(we, _e))(fe.innerFrom(ge))];
  }
  ne.partition = ye;
}), EA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceInit = ne.race = void 0;
  var oe = qt(), ae = _t(), fe = Sc(), ye = Ae();
  function ge() {
    for (var _e = [], Se = 0; Se < arguments.length; Se++)
      _e[Se] = arguments[Se];
    return _e = fe.argsOrArgArray(_e), _e.length === 1 ? ae.innerFrom(_e[0]) : new oe.Observable(we(_e));
  }
  ne.race = ge;
  function we(_e) {
    return function(Se) {
      for (var Ie = [], $e = function(Me) {
        Ie.push(ae.innerFrom(_e[Me]).subscribe(ye.createOperatorSubscriber(Se, function(Be) {
          if (Ie) {
            for (var ze = 0; ze < Ie.length; ze++)
              ze !== Me && Ie[ze].unsubscribe();
            Ie = null;
          }
          Se.next(Be);
        })));
      }, Ne = 0; Ie && !Se.closed && Ne < _e.length; Ne++)
        $e(Ne);
    };
  }
  ne.raceInit = we;
}), q3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.range = void 0;
  var oe = qt(), ae = ba();
  function fe(ye, ge, we) {
    if (ge == null && (ge = ye, ye = 0), ge <= 0)
      return ae.EMPTY;
    var _e = ge + ye;
    return new oe.Observable(we ? function(Se) {
      var Ie = ye;
      return we.schedule(function() {
        Ie < _e ? (Se.next(Ie++), this.schedule()) : Se.complete();
      });
    } : function(Se) {
      for (var Ie = ye; Ie < _e && !Se.closed; )
        Se.next(Ie++);
      Se.complete();
    });
  }
  ne.range = fe;
}), I3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.using = void 0;
  var oe = qt(), ae = _t(), fe = ba();
  function ye(ge, we) {
    return new oe.Observable(function(_e) {
      var Se = ge(), Ie = we(Se), $e = Ie ? ae.innerFrom(Ie) : fe.EMPTY;
      return $e.subscribe(_e), function() {
        Se && Se.unsubscribe();
      };
    });
  }
  ne.using = ye;
}), h_ = M((ne) => {
  var oe = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = qt(), ye = _t(), ge = Sc(), we = ba(), _e = Ae(), Se = ki();
  function Ie() {
    for (var $e = [], Ne = 0; Ne < arguments.length; Ne++)
      $e[Ne] = arguments[Ne];
    var Me = Se.popResultSelector($e), Be = ge.argsOrArgArray($e);
    return Be.length ? new fe.Observable(function(ze) {
      var He = Be.map(function() {
        return [];
      }), Ze = Be.map(function() {
        return !1;
      });
      ze.add(function() {
        He = Ze = null;
      });
      for (var qe = function(Xe) {
        ye.innerFrom(Be[Xe]).subscribe(_e.createOperatorSubscriber(ze, function(ot) {
          if (He[Xe].push(ot), He.every(function(ht) {
            return ht.length;
          })) {
            var pt = He.map(function(ht) {
              return ht.shift();
            });
            ze.next(Me ? Me.apply(void 0, ae([], oe(pt))) : pt), He.some(function(ht, wt) {
              return !ht.length && Ze[wt];
            }) && ze.complete();
          }
        }, function() {
          Ze[Xe] = !0, !He[Xe].length && ze.complete();
        }));
      }, tt = 0; !ze.closed && tt < Be.length; tt++)
        qe(tt);
      return function() {
        He = Ze = null;
      };
    }) : we.EMPTY;
  }
  ne.zip = Ie;
}), H3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 });
}), CA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.audit = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye(ge) {
    return oe.operate(function(we, _e) {
      var Se = !1, Ie = null, $e = null, Ne = !1, Me = function() {
        if ($e == null || $e.unsubscribe(), $e = null, Se) {
          Se = !1;
          var ze = Ie;
          Ie = null, _e.next(ze);
        }
        Ne && _e.complete();
      }, Be = function() {
        $e = null, Ne && _e.complete();
      };
      we.subscribe(fe.createOperatorSubscriber(_e, function(ze) {
        Se = !0, Ie = ze, $e || ae.innerFrom(ge(ze)).subscribe($e = fe.createOperatorSubscriber(_e, Me, Be));
      }, function() {
        Ne = !0, (!Se || !$e || $e.closed) && _e.complete();
      }));
    });
  }
  ne.audit = ye;
}), $3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.auditTime = void 0;
  var oe = Ti(), ae = CA(), fe = Kl();
  function ye(ge, we) {
    return we === void 0 && (we = oe.asyncScheduler), ae.audit(function() {
      return fe.timer(ge, we);
    });
  }
  ne.auditTime = ye;
}), Y3 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.buffer = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(ge) {
    return oe.operate(function(we, _e) {
      var Se = [];
      return we.subscribe(fe.createOperatorSubscriber(_e, function(Ie) {
        return Se.push(Ie);
      }, function() {
        _e.next(Se), _e.complete();
      })), ge.subscribe(fe.createOperatorSubscriber(_e, function() {
        var Ie = Se;
        Se = [], _e.next(Ie);
      }, ae.noop)), function() {
        Se = null;
      };
    });
  }
  ne.buffer = ye;
}), G3 = M((ne) => {
  var oe = ne && ne.__values || function(we) {
    var _e = typeof Symbol == "function" && Symbol.iterator, Se = _e && we[_e], Ie = 0;
    if (Se)
      return Se.call(we);
    if (we && typeof we.length == "number")
      return { next: function() {
        return we && Ie >= we.length && (we = void 0), { value: we && we[Ie++], done: !we };
      } };
    throw new TypeError(_e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferCount = void 0;
  var ae = he(), fe = Ae(), ye = ku();
  function ge(we, _e) {
    return _e === void 0 && (_e = null), _e = _e ?? we, ae.operate(function(Se, Ie) {
      var $e = [], Ne = 0;
      Se.subscribe(fe.createOperatorSubscriber(Ie, function(Me) {
        var Be, ze, He, Ze, qe = null;
        Ne++ % _e === 0 && $e.push([]);
        try {
          for (var tt = oe($e), Xe = tt.next(); !Xe.done; Xe = tt.next()) {
            var ot = Xe.value;
            ot.push(Me), we <= ot.length && (qe = qe ?? [], qe.push(ot));
          }
        } catch (wt) {
          Be = { error: wt };
        } finally {
          try {
            Xe && !Xe.done && (ze = tt.return) && ze.call(tt);
          } finally {
            if (Be)
              throw Be.error;
          }
        }
        if (qe)
          try {
            for (var pt = oe(qe), ht = pt.next(); !ht.done; ht = pt.next()) {
              var ot = ht.value;
              ye.arrRemove($e, ot), Ie.next(ot);
            }
          } catch (wt) {
            He = { error: wt };
          } finally {
            try {
              ht && !ht.done && (Ze = pt.return) && Ze.call(pt);
            } finally {
              if (He)
                throw He.error;
            }
          }
      }, function() {
        var Me, Be;
        try {
          for (var ze = oe($e), He = ze.next(); !He.done; He = ze.next()) {
            var Ze = He.value;
            Ie.next(Ze);
          }
        } catch (qe) {
          Me = { error: qe };
        } finally {
          try {
            He && !He.done && (Be = ze.return) && Be.call(ze);
          } finally {
            if (Me)
              throw Me.error;
          }
        }
        Ie.complete();
      }, void 0, function() {
        $e = null;
      }));
    });
  }
  ne.bufferCount = ge;
}), K3 = M((ne) => {
  var oe = ne && ne.__values || function($e) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, Me = Ne && $e[Ne], Be = 0;
    if (Me)
      return Me.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && Be >= $e.length && ($e = void 0), { value: $e && $e[Be++], done: !$e };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferTime = void 0;
  var ae = Oi(), fe = he(), ye = Ae(), ge = ku(), we = Ti(), _e = ki(), Se = Au();
  function Ie($e) {
    for (var Ne, Me, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Ne = _e.popScheduler(Be)) !== null && Ne !== void 0 ? Ne : we.asyncScheduler, Ze = (Me = Be[0]) !== null && Me !== void 0 ? Me : null, qe = Be[1] || 1 / 0;
    return fe.operate(function(tt, Xe) {
      var ot = [], pt = !1, ht = function(It) {
        var Nt = It.buffer, Ft = It.subs;
        Ft.unsubscribe(), ge.arrRemove(ot, It), Xe.next(Nt), pt && wt();
      }, wt = function() {
        if (ot) {
          var It = new ae.Subscription();
          Xe.add(It);
          var Nt = [], Ft = { buffer: Nt, subs: It };
          ot.push(Ft), Se.executeSchedule(It, He, function() {
            return ht(Ft);
          }, $e);
        }
      };
      Ze !== null && Ze >= 0 ? Se.executeSchedule(Xe, He, wt, Ze, !0) : pt = !0, wt();
      var gt = ye.createOperatorSubscriber(Xe, function(It) {
        var Nt, Ft, on = ot.slice();
        try {
          for (var en = oe(on), wn = en.next(); !wn.done; wn = en.next()) {
            var Zt = wn.value, pn = Zt.buffer;
            pn.push(It), qe <= pn.length && ht(Zt);
          }
        } catch (un) {
          Nt = { error: un };
        } finally {
          try {
            wn && !wn.done && (Ft = en.return) && Ft.call(en);
          } finally {
            if (Nt)
              throw Nt.error;
          }
        }
      }, function() {
        for (; ot != null && ot.length; )
          Xe.next(ot.shift().buffer);
        gt == null || gt.unsubscribe(), Xe.complete(), Xe.unsubscribe();
      }, void 0, function() {
        return ot = null;
      });
      tt.subscribe(gt);
    });
  }
  ne.bufferTime = Ie;
}), Z3 = M((ne) => {
  var oe = ne && ne.__values || function(Ie) {
    var $e = typeof Symbol == "function" && Symbol.iterator, Ne = $e && Ie[$e], Me = 0;
    if (Ne)
      return Ne.call(Ie);
    if (Ie && typeof Ie.length == "number")
      return { next: function() {
        return Ie && Me >= Ie.length && (Ie = void 0), { value: Ie && Ie[Me++], done: !Ie };
      } };
    throw new TypeError($e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferToggle = void 0;
  var ae = Oi(), fe = he(), ye = _t(), ge = Ae(), we = On(), _e = ku();
  function Se(Ie, $e) {
    return fe.operate(function(Ne, Me) {
      var Be = [];
      ye.innerFrom(Ie).subscribe(ge.createOperatorSubscriber(Me, function(ze) {
        var He = [];
        Be.push(He);
        var Ze = new ae.Subscription(), qe = function() {
          _e.arrRemove(Be, He), Me.next(He), Ze.unsubscribe();
        };
        Ze.add(ye.innerFrom($e(ze)).subscribe(ge.createOperatorSubscriber(Me, qe, we.noop)));
      }, we.noop)), Ne.subscribe(ge.createOperatorSubscriber(Me, function(ze) {
        var He, Ze;
        try {
          for (var qe = oe(Be), tt = qe.next(); !tt.done; tt = qe.next()) {
            var Xe = tt.value;
            Xe.push(ze);
          }
        } catch (ot) {
          He = { error: ot };
        } finally {
          try {
            tt && !tt.done && (Ze = qe.return) && Ze.call(qe);
          } finally {
            if (He)
              throw He.error;
          }
        }
      }, function() {
        for (; Be.length > 0; )
          Me.next(Be.shift());
        Me.complete();
      }));
    });
  }
  ne.bufferToggle = Se;
}), tB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.bufferWhen = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function ge(we) {
    return oe.operate(function(_e, Se) {
      var Ie = null, $e = null, Ne = function() {
        $e == null || $e.unsubscribe();
        var Me = Ie;
        Ie = [], Me && Se.next(Me), ye.innerFrom(we()).subscribe($e = fe.createOperatorSubscriber(Se, Ne, ae.noop));
      };
      Ne(), _e.subscribe(fe.createOperatorSubscriber(Se, function(Me) {
        return Ie == null ? void 0 : Ie.push(Me);
      }, function() {
        Ie && Se.next(Ie), Se.complete();
      }, void 0, function() {
        return Ie = $e = null;
      }));
    });
  }
  ne.bufferWhen = ge;
}), nB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.catchError = void 0;
  var oe = _t(), ae = Ae(), fe = he();
  function ye(ge) {
    return fe.operate(function(we, _e) {
      var Se = null, Ie = !1, $e;
      Se = we.subscribe(ae.createOperatorSubscriber(_e, void 0, void 0, function(Ne) {
        $e = oe.innerFrom(ge(Ne, ye(ge)(we))), Se ? (Se.unsubscribe(), Se = null, $e.subscribe(_e)) : Ie = !0;
      })), Ie && (Se.unsubscribe(), Se = null, $e.subscribe(_e));
    });
  }
  ne.catchError = ye;
}), TA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scanInternals = void 0;
  var oe = Ae();
  function ae(fe, ye, ge, we, _e) {
    return function(Se, Ie) {
      var $e = ge, Ne = ye, Me = 0;
      Se.subscribe(oe.createOperatorSubscriber(Ie, function(Be) {
        var ze = Me++;
        Ne = $e ? fe(Ne, Be, ze) : ($e = !0, Be), we && Ie.next(Ne);
      }, _e && function() {
        $e && Ie.next(Ne), Ie.complete();
      }));
    };
  }
  ne.scanInternals = ae;
}), Qd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.reduce = void 0;
  var oe = TA(), ae = he();
  function fe(ye, ge) {
    return ae.operate(oe.scanInternals(ye, ge, arguments.length >= 2, !1, !0));
  }
  ne.reduce = fe;
}), kA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.toArray = void 0;
  var oe = Qd(), ae = he(), fe = function(ge, we) {
    return ge.push(we), ge;
  };
  function ye() {
    return ae.operate(function(ge, we) {
      oe.reduce(fe, [])(ge).subscribe(we);
    });
  }
  ne.toArray = ye;
}), AA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.joinAllInternals = void 0;
  var oe = Hn(), ae = Gl(), fe = lh(), ye = Mu(), ge = kA();
  function we(_e, Se) {
    return fe.pipe(ge.toArray(), ye.mergeMap(function(Ie) {
      return _e(Ie);
    }), Se ? ae.mapOneOrManyArgs(Se) : oe.identity);
  }
  ne.joinAllInternals = we;
}), PA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestAll = void 0;
  var oe = WS(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.combineLatest, ye);
  }
  ne.combineLatestAll = fe;
}), iB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineAll = void 0;
  var oe = PA();
  ne.combineAll = oe.combineLatestAll;
}), lB = M((ne) => {
  var oe = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatest = void 0;
  var fe = WS(), ye = he(), ge = Sc(), we = Gl(), _e = lh(), Se = ki();
  function Ie() {
    for (var $e = [], Ne = 0; Ne < arguments.length; Ne++)
      $e[Ne] = arguments[Ne];
    var Me = Se.popResultSelector($e);
    return Me ? _e.pipe(Ie.apply(void 0, ae([], oe($e))), we.mapOneOrManyArgs(Me)) : ye.operate(function(Be, ze) {
      fe.combineLatestInit(ae([Be], oe(ge.argsOrArgArray($e))))(ze);
    });
  }
  ne.combineLatest = Ie;
}), sB = M((ne) => {
  var oe = ne && ne.__read || function(ge, we) {
    var _e = typeof Symbol == "function" && ge[Symbol.iterator];
    if (!_e)
      return ge;
    var Se = _e.call(ge), Ie, $e = [], Ne;
    try {
      for (; (we === void 0 || we-- > 0) && !(Ie = Se.next()).done; )
        $e.push(Ie.value);
    } catch (Me) {
      Ne = { error: Me };
    } finally {
      try {
        Ie && !Ie.done && (_e = Se.return) && _e.call(Se);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ge, we) {
    for (var _e = 0, Se = we.length, Ie = ge.length; _e < Se; _e++, Ie++)
      ge[Ie] = we[_e];
    return ge;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.combineLatestWith = void 0;
  var fe = lB();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return fe.combineLatest.apply(void 0, ae([], oe(ge)));
  }
  ne.combineLatestWith = ye;
}), MA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMap = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, ge) {
    return ae.isFunction(ge) ? oe.mergeMap(ye, ge, 1) : oe.mergeMap(ye, 1);
  }
  ne.concatMap = fe;
}), dB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatMapTo = void 0;
  var oe = MA(), ae = Mt();
  function fe(ye, ge) {
    return ae.isFunction(ge) ? oe.concatMap(function() {
      return ye;
    }, ge) : oe.concatMap(function() {
      return ye;
    });
  }
  ne.concatMapTo = fe;
}), pB = M((ne) => {
  var oe = ne && ne.__read || function(Se, Ie) {
    var $e = typeof Symbol == "function" && Se[Symbol.iterator];
    if (!$e)
      return Se;
    var Ne = $e.call(Se), Me, Be = [], ze;
    try {
      for (; (Ie === void 0 || Ie-- > 0) && !(Me = Ne.next()).done; )
        Be.push(Me.value);
    } catch (He) {
      ze = { error: He };
    } finally {
      try {
        Me && !Me.done && ($e = Ne.return) && $e.call(Ne);
      } finally {
        if (ze)
          throw ze.error;
      }
    }
    return Be;
  }, ae = ne && ne.__spreadArray || function(Se, Ie) {
    for (var $e = 0, Ne = Ie.length, Me = Se.length; $e < Ne; $e++, Me++)
      Se[Me] = Ie[$e];
    return Se;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concat = void 0;
  var fe = he(), ye = JS(), ge = ki(), we = Ja();
  function _e() {
    for (var Se = [], Ie = 0; Ie < arguments.length; Ie++)
      Se[Ie] = arguments[Ie];
    var $e = ge.popScheduler(Se);
    return fe.operate(function(Ne, Me) {
      ye.concatAll()(we.from(ae([Ne], oe(Se)), $e)).subscribe(Me);
    });
  }
  ne.concat = _e;
}), vB = M((ne) => {
  var oe = ne && ne.__read || function(ge, we) {
    var _e = typeof Symbol == "function" && ge[Symbol.iterator];
    if (!_e)
      return ge;
    var Se = _e.call(ge), Ie, $e = [], Ne;
    try {
      for (; (we === void 0 || we-- > 0) && !(Ie = Se.next()).done; )
        $e.push(Ie.value);
    } catch (Me) {
      Ne = { error: Me };
    } finally {
      try {
        Ie && !Ie.done && (_e = Se.return) && _e.call(Se);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ge, we) {
    for (var _e = 0, Se = we.length, Ie = ge.length; _e < Se; _e++, Ie++)
      ge[Ie] = we[_e];
    return ge;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.concatWith = void 0;
  var fe = pB();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return fe.concat.apply(void 0, ae([], oe(ge)));
  }
  ne.concatWith = ye;
}), mB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.fromSubscribable = void 0;
  var oe = qt();
  function ae(fe) {
    return new oe.Observable(function(ye) {
      return fe.subscribe(ye);
    });
  }
  ne.fromSubscribable = ae;
}), M_ = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.connect = void 0;
  var oe = Tn(), ae = Ja(), fe = he(), ye = mB(), ge = { connector: function() {
    return new oe.Subject();
  } };
  function we(_e, Se) {
    Se === void 0 && (Se = ge);
    var Ie = Se.connector;
    return fe.operate(function($e, Ne) {
      var Me = Ie();
      ae.from(_e(ye.fromSubscribable(Me))).subscribe(Ne), Ne.add($e.subscribe(Me));
    });
  }
  ne.connect = we;
}), hB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.count = void 0;
  var oe = Qd();
  function ae(fe) {
    return oe.reduce(function(ye, ge, we) {
      return !fe || fe(ge, we) ? ye + 1 : ye;
    }, 0);
  }
  ne.count = ae;
}), gB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounce = void 0;
  var oe = he(), ae = On(), fe = Ae(), ye = _t();
  function ge(we) {
    return oe.operate(function(_e, Se) {
      var Ie = !1, $e = null, Ne = null, Me = function() {
        if (Ne == null || Ne.unsubscribe(), Ne = null, Ie) {
          Ie = !1;
          var Be = $e;
          $e = null, Se.next(Be);
        }
      };
      _e.subscribe(fe.createOperatorSubscriber(Se, function(Be) {
        Ne == null || Ne.unsubscribe(), Ie = !0, $e = Be, Ne = fe.createOperatorSubscriber(Se, Me, ae.noop), ye.innerFrom(we(Be)).subscribe(Ne);
      }, function() {
        Me(), Se.complete();
      }, void 0, function() {
        $e = Ne = null;
      }));
    });
  }
  ne.debounce = ge;
}), bB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.debounceTime = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(ge, we) {
    return we === void 0 && (we = oe.asyncScheduler), ae.operate(function(_e, Se) {
      var Ie = null, $e = null, Ne = null, Me = function() {
        if (Ie) {
          Ie.unsubscribe(), Ie = null;
          var ze = $e;
          $e = null, Se.next(ze);
        }
      };
      function Be() {
        var ze = Ne + ge, He = we.now();
        if (He < ze) {
          Ie = this.schedule(void 0, ze - He), Se.add(Ie);
          return;
        }
        Me();
      }
      _e.subscribe(fe.createOperatorSubscriber(Se, function(ze) {
        $e = ze, Ne = we.now(), Ie || (Ie = we.schedule(Be, ge), Se.add(Ie));
      }, function() {
        Me(), Se.complete();
      }, void 0, function() {
        $e = Ie = null;
      }));
    });
  }
  ne.debounceTime = ye;
}), gh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.defaultIfEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(ge, we) {
      var _e = !1;
      ge.subscribe(ae.createOperatorSubscriber(we, function(Se) {
        _e = !0, we.next(Se);
      }, function() {
        _e || we.next(ye), we.complete();
      }));
    });
  }
  ne.defaultIfEmpty = fe;
}), Kd = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.take = void 0;
  var oe = ba(), ae = he(), fe = Ae();
  function ye(ge) {
    return ge <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(we, _e) {
      var Se = 0;
      we.subscribe(fe.createOperatorSubscriber(_e, function(Ie) {
        ++Se <= ge && (_e.next(Ie), ge <= Se && _e.complete());
      }));
    });
  }
  ne.take = ye;
}), DA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.ignoreElements = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye() {
    return oe.operate(function(ge, we) {
      ge.subscribe(ae.createOperatorSubscriber(we, fe.noop));
    });
  }
  ne.ignoreElements = ye;
}), NA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mapTo = void 0;
  var oe = Wl();
  function ae(fe) {
    return oe.map(function() {
      return fe;
    });
  }
  ne.mapTo = ae;
}), LA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delayWhen = void 0;
  var oe = hh(), ae = Kd(), fe = DA(), ye = NA(), ge = Mu();
  function we(_e, Se) {
    return Se ? function(Ie) {
      return oe.concat(Se.pipe(ae.take(1), fe.ignoreElements()), Ie.pipe(we(_e)));
    } : ge.mergeMap(function(Ie, $e) {
      return _e(Ie, $e).pipe(ae.take(1), ye.mapTo(Ie));
    });
  }
  ne.delayWhen = we;
}), wB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.delay = void 0;
  var oe = Ti(), ae = LA(), fe = Kl();
  function ye(ge, we) {
    we === void 0 && (we = oe.asyncScheduler);
    var _e = fe.timer(ge, we);
    return ae.delayWhen(function() {
      return _e;
    });
  }
  ne.delay = ye;
}), xB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.dematerialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(ge, we) {
      ge.subscribe(fe.createOperatorSubscriber(we, function(_e) {
        return oe.observeNotification(_e, we);
      }));
    });
  }
  ne.dematerialize = ye;
}), CB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinct = void 0;
  var oe = he(), ae = Ae(), fe = On();
  function ye(ge, we) {
    return oe.operate(function(_e, Se) {
      var Ie = /* @__PURE__ */ new Set();
      _e.subscribe(ae.createOperatorSubscriber(Se, function($e) {
        var Ne = ge ? ge($e) : $e;
        Ie.has(Ne) || (Ie.add(Ne), Se.next($e));
      })), we == null || we.subscribe(ae.createOperatorSubscriber(Se, function() {
        return Ie.clear();
      }, fe.noop));
    });
  }
  ne.distinct = ye;
}), jA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilChanged = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(we, _e) {
    return _e === void 0 && (_e = oe.identity), we = we ?? ge, ae.operate(function(Se, Ie) {
      var $e, Ne = !0;
      Se.subscribe(fe.createOperatorSubscriber(Ie, function(Me) {
        var Be = _e(Me);
        (Ne || !we($e, Be)) && (Ne = !1, $e = Be, Ie.next(Me));
      }));
    });
  }
  ne.distinctUntilChanged = ye;
  function ge(we, _e) {
    return we === _e;
  }
}), RB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.distinctUntilKeyChanged = void 0;
  var oe = jA();
  function ae(fe, ye) {
    return oe.distinctUntilChanged(function(ge, we) {
      return ye ? ye(ge[fe], we[fe]) : ge[fe] === we[fe];
    });
  }
  ne.distinctUntilKeyChanged = ae;
}), bh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throwIfEmpty = void 0;
  var oe = $l(), ae = he(), fe = Ae();
  function ye(we) {
    return we === void 0 && (we = ge), ae.operate(function(_e, Se) {
      var Ie = !1;
      _e.subscribe(fe.createOperatorSubscriber(Se, function($e) {
        Ie = !0, Se.next($e);
      }, function() {
        return Ie ? Se.complete() : Se.error(we());
      }));
    });
  }
  ne.throwIfEmpty = ye;
  function ge() {
    return new oe.EmptyError();
  }
}), TB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.elementAt = void 0;
  var oe = vA(), ae = _c(), fe = bh(), ye = gh(), ge = Kd();
  function we(_e, Se) {
    if (_e < 0)
      throw new oe.ArgumentOutOfRangeError();
    var Ie = arguments.length >= 2;
    return function($e) {
      return $e.pipe(ae.filter(function(Ne, Me) {
        return Me === _e;
      }), ge.take(1), Ie ? ye.defaultIfEmpty(Se) : fe.throwIfEmpty(function() {
        return new oe.ArgumentOutOfRangeError();
      }));
    };
  }
  ne.elementAt = we;
}), kB = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var Se = typeof Symbol == "function" && we[Symbol.iterator];
    if (!Se)
      return we;
    var Ie = Se.call(we), $e, Ne = [], Me;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Ie.next()).done; )
        Ne.push($e.value);
    } catch (Be) {
      Me = { error: Be };
    } finally {
      try {
        $e && !$e.done && (Se = Ie.return) && Se.call(Ie);
      } finally {
        if (Me)
          throw Me.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var Se = 0, Ie = _e.length, $e = we.length; Se < Ie; Se++, $e++)
      we[$e] = _e[Se];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.endWith = void 0;
  var fe = hh(), ye = TS();
  function ge() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return function(Se) {
      return fe.concat(Se, ye.of.apply(void 0, ae([], oe(we))));
    };
  }
  ne.endWith = ge;
}), AB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.every = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ge) {
    return oe.operate(function(we, _e) {
      var Se = 0;
      we.subscribe(ae.createOperatorSubscriber(_e, function(Ie) {
        ye.call(ge, Ie, Se++, we) || (_e.next(!1), _e.complete());
      }, function() {
        _e.next(!0), _e.complete();
      }));
    });
  }
  ne.every = fe;
}), UA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustAll = void 0;
  var oe = he(), ae = _t(), fe = Ae();
  function ye() {
    return oe.operate(function(ge, we) {
      var _e = !1, Se = null;
      ge.subscribe(fe.createOperatorSubscriber(we, function(Ie) {
        Se || (Se = ae.innerFrom(Ie).subscribe(fe.createOperatorSubscriber(we, void 0, function() {
          Se = null, _e && we.complete();
        })));
      }, function() {
        _e = !0, !Se && we.complete();
      }));
    });
  }
  ne.exhaustAll = ye;
}), MB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaust = void 0;
  var oe = UA();
  ne.exhaust = oe.exhaustAll;
}), jB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.exhaustMap = void 0;
  var oe = Wl(), ae = _t(), fe = he(), ye = Ae();
  function ge(we, _e) {
    return _e ? function(Se) {
      return Se.pipe(ge(function(Ie, $e) {
        return ae.innerFrom(we(Ie, $e)).pipe(oe.map(function(Ne, Me) {
          return _e(Ie, Ne, $e, Me);
        }));
      }));
    } : fe.operate(function(Se, Ie) {
      var $e = 0, Ne = null, Me = !1;
      Se.subscribe(ye.createOperatorSubscriber(Ie, function(Be) {
        Ne || (Ne = ye.createOperatorSubscriber(Ie, void 0, function() {
          Ne = null, Me && Ie.complete();
        }), ae.innerFrom(we(Be, $e++)).subscribe(Ne));
      }, function() {
        Me = !0, !Ne && Ie.complete();
      }));
    });
  }
  ne.exhaustMap = ge;
}), UB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.expand = void 0;
  var oe = he(), ae = GS();
  function fe(ye, ge, we) {
    return ge === void 0 && (ge = 1 / 0), ge = (ge || 0) < 1 ? 1 / 0 : ge, oe.operate(function(_e, Se) {
      return ae.mergeInternals(_e, Se, ye, ge, void 0, !0, we);
    });
  }
  ne.expand = fe;
}), FB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.finalize = void 0;
  var oe = he();
  function ae(fe) {
    return oe.operate(function(ye, ge) {
      try {
        ye.subscribe(ge);
      } finally {
        ge.add(fe);
      }
    });
  }
  ne.finalize = ae;
}), FA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.createFind = ne.find = void 0;
  var oe = he(), ae = Ae();
  function fe(ge, we) {
    return oe.operate(ye(ge, we, "value"));
  }
  ne.find = fe;
  function ye(ge, we, _e) {
    var Se = _e === "index";
    return function(Ie, $e) {
      var Ne = 0;
      Ie.subscribe(ae.createOperatorSubscriber($e, function(Me) {
        var Be = Ne++;
        ge.call(we, Me, Be, Ie) && ($e.next(Se ? Be : Me), $e.complete());
      }, function() {
        $e.next(Se ? -1 : void 0), $e.complete();
      }));
    };
  }
  ne.createFind = ye;
}), qB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.findIndex = void 0;
  var oe = he(), ae = FA();
  function fe(ye, ge) {
    return oe.operate(ae.createFind(ye, ge, "index"));
  }
  ne.findIndex = fe;
}), IB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.first = void 0;
  var oe = $l(), ae = _c(), fe = Kd(), ye = gh(), ge = bh(), we = Hn();
  function _e(Se, Ie) {
    var $e = arguments.length >= 2;
    return function(Ne) {
      return Ne.pipe(Se ? ae.filter(function(Me, Be) {
        return Se(Me, Be, Ne);
      }) : we.identity, fe.take(1), $e ? ye.defaultIfEmpty(Ie) : ge.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.first = _e;
}), HB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.groupBy = void 0;
  var oe = qt(), ae = _t(), fe = Tn(), ye = he(), ge = Ae();
  function we(_e, Se, Ie, $e) {
    return ye.operate(function(Ne, Me) {
      var Be;
      !Se || typeof Se == "function" ? Be = Se : (Ie = Se.duration, Be = Se.element, $e = Se.connector);
      var ze = /* @__PURE__ */ new Map(), He = function(pt) {
        ze.forEach(pt), pt(Me);
      }, Ze = function(pt) {
        return He(function(ht) {
          return ht.error(pt);
        });
      }, qe = 0, tt = !1, Xe = new ge.OperatorSubscriber(Me, function(pt) {
        try {
          var ht = _e(pt), wt = ze.get(ht);
          if (!wt) {
            ze.set(ht, wt = $e ? $e() : new fe.Subject());
            var gt = ot(ht, wt);
            if (Me.next(gt), Ie) {
              var It = ge.createOperatorSubscriber(wt, function() {
                wt.complete(), It == null || It.unsubscribe();
              }, void 0, void 0, function() {
                return ze.delete(ht);
              });
              Xe.add(ae.innerFrom(Ie(gt)).subscribe(It));
            }
          }
          wt.next(Be ? Be(pt) : pt);
        } catch (Nt) {
          Ze(Nt);
        }
      }, function() {
        return He(function(pt) {
          return pt.complete();
        });
      }, Ze, function() {
        return ze.clear();
      }, function() {
        return tt = !0, qe === 0;
      });
      Ne.subscribe(Xe);
      function ot(pt, ht) {
        var wt = new oe.Observable(function(gt) {
          qe++;
          var It = ht.subscribe(gt);
          return function() {
            It.unsubscribe(), --qe === 0 && tt && Xe.unsubscribe();
          };
        });
        return wt.key = pt, wt;
      }
    });
  }
  ne.groupBy = we;
}), VB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.isEmpty = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ge) {
      ye.subscribe(ae.createOperatorSubscriber(ge, function() {
        ge.next(!1), ge.complete();
      }, function() {
        ge.next(!0), ge.complete();
      }));
    });
  }
  ne.isEmpty = fe;
}), zA = M((ne) => {
  var oe = ne && ne.__values || function(we) {
    var _e = typeof Symbol == "function" && Symbol.iterator, Se = _e && we[_e], Ie = 0;
    if (Se)
      return Se.call(we);
    if (we && typeof we.length == "number")
      return { next: function() {
        return we && Ie >= we.length && (we = void 0), { value: we && we[Ie++], done: !we };
      } };
    throw new TypeError(_e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeLast = void 0;
  var ae = ba(), fe = he(), ye = Ae();
  function ge(we) {
    return we <= 0 ? function() {
      return ae.EMPTY;
    } : fe.operate(function(_e, Se) {
      var Ie = [];
      _e.subscribe(ye.createOperatorSubscriber(Se, function($e) {
        Ie.push($e), we < Ie.length && Ie.shift();
      }, function() {
        var $e, Ne;
        try {
          for (var Me = oe(Ie), Be = Me.next(); !Be.done; Be = Me.next()) {
            var ze = Be.value;
            Se.next(ze);
          }
        } catch (He) {
          $e = { error: He };
        } finally {
          try {
            Be && !Be.done && (Ne = Me.return) && Ne.call(Me);
          } finally {
            if ($e)
              throw $e.error;
          }
        }
        Se.complete();
      }, void 0, function() {
        Ie = null;
      }));
    });
  }
  ne.takeLast = ge;
}), $B = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.last = void 0;
  var oe = $l(), ae = _c(), fe = zA(), ye = bh(), ge = gh(), we = Hn();
  function _e(Se, Ie) {
    var $e = arguments.length >= 2;
    return function(Ne) {
      return Ne.pipe(Se ? ae.filter(function(Me, Be) {
        return Se(Me, Be, Ne);
      }) : we.identity, fe.takeLast(1), $e ? ge.defaultIfEmpty(Ie) : ye.throwIfEmpty(function() {
        return new oe.EmptyError();
      }));
    };
  }
  ne.last = _e;
}), WB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.materialize = void 0;
  var oe = AS(), ae = he(), fe = Ae();
  function ye() {
    return ae.operate(function(ge, we) {
      ge.subscribe(fe.createOperatorSubscriber(we, function(_e) {
        we.next(oe.Notification.createNext(_e));
      }, function() {
        we.next(oe.Notification.createComplete()), we.complete();
      }, function(_e) {
        we.next(oe.Notification.createError(_e)), we.complete();
      }));
    });
  }
  ne.materialize = ye;
}), YB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.max = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(ge, we) {
      return ye(ge, we) > 0 ? ge : we;
    } : function(ge, we) {
      return ge > we ? ge : we;
    });
  }
  ne.max = fe;
}), GB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.flatMap = void 0;
  var oe = Mu();
  ne.flatMap = oe.mergeMap;
}), KB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeMapTo = void 0;
  var oe = Mu(), ae = Mt();
  function fe(ye, ge, we) {
    return we === void 0 && (we = 1 / 0), ae.isFunction(ge) ? oe.mergeMap(function() {
      return ye;
    }, ge, we) : (typeof ge == "number" && (we = ge), oe.mergeMap(function() {
      return ye;
    }, we));
  }
  ne.mergeMapTo = fe;
}), XB = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeScan = void 0;
  var oe = he(), ae = GS();
  function fe(ye, ge, we) {
    return we === void 0 && (we = 1 / 0), oe.operate(function(_e, Se) {
      var Ie = ge;
      return ae.mergeInternals(_e, Se, function($e, Ne) {
        return ye(Ie, $e, Ne);
      }, we, function($e) {
        Ie = $e;
      }, !1, void 0, function() {
        return Ie = null;
      });
    });
  }
  ne.mergeScan = fe;
}), ZB = M((ne) => {
  var oe = ne && ne.__read || function(Ie, $e) {
    var Ne = typeof Symbol == "function" && Ie[Symbol.iterator];
    if (!Ne)
      return Ie;
    var Me = Ne.call(Ie), Be, ze = [], He;
    try {
      for (; ($e === void 0 || $e-- > 0) && !(Be = Me.next()).done; )
        ze.push(Be.value);
    } catch (Ze) {
      He = { error: Ze };
    } finally {
      try {
        Be && !Be.done && (Ne = Me.return) && Ne.call(Me);
      } finally {
        if (He)
          throw He.error;
      }
    }
    return ze;
  }, ae = ne && ne.__spreadArray || function(Ie, $e) {
    for (var Ne = 0, Me = $e.length, Be = Ie.length; Ne < Me; Ne++, Be++)
      Ie[Be] = $e[Ne];
    return Ie;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.merge = void 0;
  var fe = he(), ye = Sc(), ge = mh(), we = ki(), _e = Ja();
  function Se() {
    for (var Ie = [], $e = 0; $e < arguments.length; $e++)
      Ie[$e] = arguments[$e];
    var Ne = we.popScheduler(Ie), Me = we.popNumber(Ie, 1 / 0);
    return Ie = ye.argsOrArgArray(Ie), fe.operate(function(Be, ze) {
      ge.mergeAll(Me)(_e.from(ae([Be], oe(Ie)), Ne)).subscribe(ze);
    });
  }
  ne.merge = Se;
}), eH = M((ne) => {
  var oe = ne && ne.__read || function(ge, we) {
    var _e = typeof Symbol == "function" && ge[Symbol.iterator];
    if (!_e)
      return ge;
    var Se = _e.call(ge), Ie, $e = [], Ne;
    try {
      for (; (we === void 0 || we-- > 0) && !(Ie = Se.next()).done; )
        $e.push(Ie.value);
    } catch (Me) {
      Ne = { error: Me };
    } finally {
      try {
        Ie && !Ie.done && (_e = Se.return) && _e.call(Se);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ge, we) {
    for (var _e = 0, Se = we.length, Ie = ge.length; _e < Se; _e++, Ie++)
      ge[Ie] = we[_e];
    return ge;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.mergeWith = void 0;
  var fe = ZB();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return fe.merge.apply(void 0, ae([], oe(ge)));
  }
  ne.mergeWith = ye;
}), tH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.min = void 0;
  var oe = Qd(), ae = Mt();
  function fe(ye) {
    return oe.reduce(ae.isFunction(ye) ? function(ge, we) {
      return ye(ge, we) < 0 ? ge : we;
    } : function(ge, we) {
      return ge < we ? ge : we;
    });
  }
  ne.min = fe;
}), dw = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.multicast = void 0;
  var oe = sh(), ae = Mt(), fe = M_();
  function ye(ge, we) {
    var _e = ae.isFunction(ge) ? ge : function() {
      return ge;
    };
    return ae.isFunction(we) ? fe.connect(we, { connector: _e }) : function(Se) {
      return new oe.ConnectableObservable(Se, _e);
    };
  }
  ne.multicast = ye;
}), nH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pairwise = void 0;
  var oe = he(), ae = Ae();
  function fe() {
    return oe.operate(function(ye, ge) {
      var we, _e = !1;
      ye.subscribe(ae.createOperatorSubscriber(ge, function(Se) {
        var Ie = we;
        we = Se, _e && ge.next([Ie, Se]), _e = !0;
      }));
    });
  }
  ne.pairwise = fe;
}), iH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.pluck = void 0;
  var oe = Wl();
  function ae() {
    for (var fe = [], ye = 0; ye < arguments.length; ye++)
      fe[ye] = arguments[ye];
    var ge = fe.length;
    if (ge === 0)
      throw new Error("list of properties cannot be empty.");
    return oe.map(function(we) {
      for (var _e = we, Se = 0; Se < ge; Se++) {
        var Ie = _e == null ? void 0 : _e[fe[Se]];
        if (typeof Ie < "u")
          _e = Ie;
        else
          return;
      }
      return _e;
    });
  }
  ne.pluck = ae;
}), aH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publish = void 0;
  var oe = Tn(), ae = dw(), fe = M_();
  function ye(ge) {
    return ge ? function(we) {
      return fe.connect(ge)(we);
    } : function(we) {
      return ae.multicast(new oe.Subject())(we);
    };
  }
  ne.publish = ye;
}), oH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishBehavior = void 0;
  var oe = Xk(), ae = sh();
  function fe(ye) {
    return function(ge) {
      var we = new oe.BehaviorSubject(ye);
      return new ae.ConnectableObservable(ge, function() {
        return we;
      });
    };
  }
  ne.publishBehavior = fe;
}), uH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishLast = void 0;
  var oe = iS(), ae = sh();
  function fe() {
    return function(ye) {
      var ge = new oe.AsyncSubject();
      return new ae.ConnectableObservable(ye, function() {
        return ge;
      });
    };
  }
  ne.publishLast = fe;
}), sH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.publishReplay = void 0;
  var oe = nS(), ae = dw(), fe = Mt();
  function ye(ge, we, _e, Se) {
    _e && !fe.isFunction(_e) && (Se = _e);
    var Ie = fe.isFunction(_e) ? _e : void 0;
    return function($e) {
      return ae.multicast(new oe.ReplaySubject(ge, we, Se), Ie)($e);
    };
  }
  ne.publishReplay = ye;
}), cH = M((ne) => {
  var oe = ne && ne.__read || function(_e, Se) {
    var Ie = typeof Symbol == "function" && _e[Symbol.iterator];
    if (!Ie)
      return _e;
    var $e = Ie.call(_e), Ne, Me = [], Be;
    try {
      for (; (Se === void 0 || Se-- > 0) && !(Ne = $e.next()).done; )
        Me.push(Ne.value);
    } catch (ze) {
      Be = { error: ze };
    } finally {
      try {
        Ne && !Ne.done && (Ie = $e.return) && Ie.call($e);
      } finally {
        if (Be)
          throw Be.error;
      }
    }
    return Me;
  }, ae = ne && ne.__spreadArray || function(_e, Se) {
    for (var Ie = 0, $e = Se.length, Ne = _e.length; Ie < $e; Ie++, Ne++)
      _e[Ne] = Se[Ie];
    return _e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.raceWith = void 0;
  var fe = EA(), ye = he(), ge = Hn();
  function we() {
    for (var _e = [], Se = 0; Se < arguments.length; Se++)
      _e[Se] = arguments[Se];
    return _e.length ? ye.operate(function(Ie, $e) {
      fe.raceInit(ae([Ie], oe(_e)))($e);
    }) : ge.identity;
  }
  ne.raceWith = we;
}), dH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeat = void 0;
  var oe = ba(), ae = he(), fe = Ae(), ye = _t(), ge = Kl();
  function we(_e) {
    var Se, Ie = 1 / 0, $e;
    return _e != null && (typeof _e == "object" ? (Se = _e.count, Ie = Se === void 0 ? 1 / 0 : Se, $e = _e.delay) : Ie = _e), Ie <= 0 ? function() {
      return oe.EMPTY;
    } : ae.operate(function(Ne, Me) {
      var Be = 0, ze, He = function() {
        if (ze == null || ze.unsubscribe(), ze = null, $e != null) {
          var qe = typeof $e == "number" ? ge.timer($e) : ye.innerFrom($e(Be)), tt = fe.createOperatorSubscriber(Me, function() {
            tt.unsubscribe(), Ze();
          });
          qe.subscribe(tt);
        } else
          Ze();
      }, Ze = function() {
        var qe = !1;
        ze = Ne.subscribe(fe.createOperatorSubscriber(Me, void 0, function() {
          ++Be < Ie ? ze ? He() : qe = !0 : Me.complete();
        })), qe && He();
      };
      Ze();
    });
  }
  ne.repeat = we;
}), vH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.repeatWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(ge) {
    return ae.operate(function(we, _e) {
      var Se, Ie = !1, $e, Ne = !1, Me = !1, Be = function() {
        return Me && Ne && (_e.complete(), !0);
      }, ze = function() {
        return $e || ($e = new oe.Subject(), ge($e).subscribe(fe.createOperatorSubscriber(_e, function() {
          Se ? He() : Ie = !0;
        }, function() {
          Ne = !0, Be();
        }))), $e;
      }, He = function() {
        Me = !1, Se = we.subscribe(fe.createOperatorSubscriber(_e, void 0, function() {
          Me = !0, !Be() && ze().next();
        })), Ie && (Se.unsubscribe(), Se = null, Ie = !1, He());
      };
      He();
    });
  }
  ne.repeatWhen = ye;
}), hH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retry = void 0;
  var oe = he(), ae = Ae(), fe = Hn(), ye = Kl(), ge = _t();
  function we(_e) {
    _e === void 0 && (_e = 1 / 0);
    var Se;
    _e && typeof _e == "object" ? Se = _e : Se = { count: _e };
    var Ie = Se.count, $e = Ie === void 0 ? 1 / 0 : Ie, Ne = Se.delay, Me = Se.resetOnSuccess, Be = Me === void 0 ? !1 : Me;
    return $e <= 0 ? fe.identity : oe.operate(function(ze, He) {
      var Ze = 0, qe, tt = function() {
        var Xe = !1;
        qe = ze.subscribe(ae.createOperatorSubscriber(He, function(ot) {
          Be && (Ze = 0), He.next(ot);
        }, void 0, function(ot) {
          if (Ze++ < $e) {
            var pt = function() {
              qe ? (qe.unsubscribe(), qe = null, tt()) : Xe = !0;
            };
            if (Ne != null) {
              var ht = typeof Ne == "number" ? ye.timer(Ne) : ge.innerFrom(Ne(ot, Ze)), wt = ae.createOperatorSubscriber(He, function() {
                wt.unsubscribe(), pt();
              }, function() {
                He.complete();
              });
              ht.subscribe(wt);
            } else
              pt();
          } else
            He.error(ot);
        })), Xe && (qe.unsubscribe(), qe = null, tt());
      };
      tt();
    });
  }
  ne.retry = we;
}), gH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.retryWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae();
  function ye(ge) {
    return ae.operate(function(we, _e) {
      var Se, Ie = !1, $e, Ne = function() {
        Se = we.subscribe(fe.createOperatorSubscriber(_e, void 0, void 0, function(Me) {
          $e || ($e = new oe.Subject(), ge($e).subscribe(fe.createOperatorSubscriber(_e, function() {
            return Se ? Ne() : Ie = !0;
          }))), $e && $e.next(Me);
        })), Ie && (Se.unsubscribe(), Se = null, Ie = !1, Ne());
      };
      Ne();
    });
  }
  ne.retryWhen = ye;
}), IA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sample = void 0;
  var oe = he(), ae = On(), fe = Ae();
  function ye(ge) {
    return oe.operate(function(we, _e) {
      var Se = !1, Ie = null;
      we.subscribe(fe.createOperatorSubscriber(_e, function($e) {
        Se = !0, Ie = $e;
      })), ge.subscribe(fe.createOperatorSubscriber(_e, function() {
        if (Se) {
          Se = !1;
          var $e = Ie;
          Ie = null, _e.next($e);
        }
      }, ae.noop));
    });
  }
  ne.sample = ye;
}), SH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sampleTime = void 0;
  var oe = Ti(), ae = IA(), fe = wA();
  function ye(ge, we) {
    return we === void 0 && (we = oe.asyncScheduler), ae.sample(fe.interval(ge, we));
  }
  ne.sampleTime = ye;
}), _H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.scan = void 0;
  var oe = he(), ae = TA();
  function fe(ye, ge) {
    return oe.operate(ae.scanInternals(ye, ge, arguments.length >= 2, !0));
  }
  ne.scan = fe;
}), xH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.sequenceEqual = void 0;
  var oe = he(), ae = Ae();
  function fe(ge, we) {
    return we === void 0 && (we = function(_e, Se) {
      return _e === Se;
    }), oe.operate(function(_e, Se) {
      var Ie = ye(), $e = ye(), Ne = function(Be) {
        Se.next(Be), Se.complete();
      }, Me = function(Be, ze) {
        var He = ae.createOperatorSubscriber(Se, function(Ze) {
          var qe = ze.buffer, tt = ze.complete;
          qe.length === 0 ? tt ? Ne(!1) : Be.buffer.push(Ze) : !we(Ze, qe.shift()) && Ne(!1);
        }, function() {
          Be.complete = !0;
          var Ze = ze.complete, qe = ze.buffer;
          Ze && Ne(qe.length === 0), He == null || He.unsubscribe();
        });
        return He;
      };
      _e.subscribe(Me(Ie, $e)), ge.subscribe(Me($e, Ie));
    });
  }
  ne.sequenceEqual = fe;
  function ye() {
    return { buffer: [], complete: !1 };
  }
}), HA = M((ne) => {
  var oe = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.share = void 0;
  var fe = Ja(), ye = Kd(), ge = Tn(), we = Sd(), _e = he();
  function Se($e) {
    $e === void 0 && ($e = {});
    var Ne = $e.connector, Me = Ne === void 0 ? function() {
      return new ge.Subject();
    } : Ne, Be = $e.resetOnError, ze = Be === void 0 ? !0 : Be, He = $e.resetOnComplete, Ze = He === void 0 ? !0 : He, qe = $e.resetOnRefCountZero, tt = qe === void 0 ? !0 : qe;
    return function(Xe) {
      var ot = null, pt = null, ht = null, wt = 0, gt = !1, It = !1, Nt = function() {
        pt == null || pt.unsubscribe(), pt = null;
      }, Ft = function() {
        Nt(), ot = ht = null, gt = It = !1;
      }, on = function() {
        var en = ot;
        Ft(), en == null || en.unsubscribe();
      };
      return _e.operate(function(en, wn) {
        wt++, !It && !gt && Nt();
        var Zt = ht = ht ?? Me();
        wn.add(function() {
          wt--, wt === 0 && !It && !gt && (pt = Ie(on, tt));
        }), Zt.subscribe(wn), ot || (ot = new we.SafeSubscriber({ next: function(pn) {
          return Zt.next(pn);
        }, error: function(pn) {
          It = !0, Nt(), pt = Ie(Ft, ze, pn), Zt.error(pn);
        }, complete: function() {
          gt = !0, Nt(), pt = Ie(Ft, Ze), Zt.complete();
        } }), fe.from(en).subscribe(ot));
      })(Xe);
    };
  }
  ne.share = Se;
  function Ie($e, Ne) {
    for (var Me = [], Be = 2; Be < arguments.length; Be++)
      Me[Be - 2] = arguments[Be];
    return Ne === !0 ? ($e(), null) : Ne === !1 ? null : Ne.apply(void 0, ae([], oe(Me))).pipe(ye.take(1)).subscribe(function() {
      return $e();
    });
  }
}), EH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.shareReplay = void 0;
  var oe = nS(), ae = HA();
  function fe(ye, ge, we) {
    var _e, Se, Ie, $e, Ne = !1;
    return ye && typeof ye == "object" ? (_e = ye.bufferSize, $e = _e === void 0 ? 1 / 0 : _e, Se = ye.windowTime, ge = Se === void 0 ? 1 / 0 : Se, Ie = ye.refCount, Ne = Ie === void 0 ? !1 : Ie, we = ye.scheduler) : $e = ye ?? 1 / 0, ae.share({ connector: function() {
      return new oe.ReplaySubject($e, ge, we);
    }, resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: Ne });
  }
  ne.shareReplay = fe;
}), CH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.single = void 0;
  var oe = $l(), ae = hA(), fe = mA(), ye = he(), ge = Ae();
  function we(_e) {
    return ye.operate(function(Se, Ie) {
      var $e = !1, Ne, Me = !1, Be = 0;
      Se.subscribe(ge.createOperatorSubscriber(Ie, function(ze) {
        Me = !0, (!_e || _e(ze, Be++, Se)) && ($e && Ie.error(new ae.SequenceError("Too many matching values")), $e = !0, Ne = ze);
      }, function() {
        $e ? (Ie.next(Ne), Ie.complete()) : Ie.error(Me ? new fe.NotFoundError("No matching values") : new oe.EmptyError());
      }));
    });
  }
  ne.single = we;
}), RH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skip = void 0;
  var oe = _c();
  function ae(fe) {
    return oe.filter(function(ye, ge) {
      return fe <= ge;
    });
  }
  ne.skip = ae;
}), OH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipLast = void 0;
  var oe = Hn(), ae = he(), fe = Ae();
  function ye(ge) {
    return ge <= 0 ? oe.identity : ae.operate(function(we, _e) {
      var Se = new Array(ge), Ie = 0;
      return we.subscribe(fe.createOperatorSubscriber(_e, function($e) {
        var Ne = Ie++;
        if (Ne < ge)
          Se[Ne] = $e;
        else {
          var Me = Ne % ge, Be = Se[Me];
          Se[Me] = $e, _e.next(Be);
        }
      })), function() {
        Se = null;
      };
    });
  }
  ne.skipLast = ye;
}), kH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function ge(we) {
    return oe.operate(function(_e, Se) {
      var Ie = !1, $e = ae.createOperatorSubscriber(Se, function() {
        $e == null || $e.unsubscribe(), Ie = !0;
      }, ye.noop);
      fe.innerFrom(we).subscribe($e), _e.subscribe(ae.createOperatorSubscriber(Se, function(Ne) {
        return Ie && Se.next(Ne);
      }));
    });
  }
  ne.skipUntil = ge;
}), AH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.skipWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye) {
    return oe.operate(function(ge, we) {
      var _e = !1, Se = 0;
      ge.subscribe(ae.createOperatorSubscriber(we, function(Ie) {
        return (_e || (_e = !ye(Ie, Se++))) && we.next(Ie);
      }));
    });
  }
  ne.skipWhile = fe;
}), MH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.startWith = void 0;
  var oe = hh(), ae = ki(), fe = he();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    var _e = ae.popScheduler(ge);
    return fe.operate(function(Se, Ie) {
      (_e ? oe.concat(ge, Se, _e) : oe.concat(ge, Se)).subscribe(Ie);
    });
  }
  ne.startWith = ye;
}), Sh = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMap = void 0;
  var oe = _t(), ae = he(), fe = Ae();
  function ye(ge, we) {
    return ae.operate(function(_e, Se) {
      var Ie = null, $e = 0, Ne = !1, Me = function() {
        return Ne && !Ie && Se.complete();
      };
      _e.subscribe(fe.createOperatorSubscriber(Se, function(Be) {
        Ie == null || Ie.unsubscribe();
        var ze = 0, He = $e++;
        oe.innerFrom(ge(Be, He)).subscribe(Ie = fe.createOperatorSubscriber(Se, function(Ze) {
          return Se.next(we ? we(Be, Ze, He, ze++) : Ze);
        }, function() {
          Ie = null, Me();
        }));
      }, function() {
        Ne = !0, Me();
      }));
    });
  }
  ne.switchMap = ye;
}), NH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchAll = void 0;
  var oe = Sh(), ae = Hn();
  function fe() {
    return oe.switchMap(ae.identity);
  }
  ne.switchAll = fe;
}), jH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchMapTo = void 0;
  var oe = Sh(), ae = Mt();
  function fe(ye, ge) {
    return ae.isFunction(ge) ? oe.switchMap(function() {
      return ye;
    }, ge) : oe.switchMap(function() {
      return ye;
    });
  }
  ne.switchMapTo = fe;
}), UH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.switchScan = void 0;
  var oe = Sh(), ae = he();
  function fe(ye, ge) {
    return ae.operate(function(we, _e) {
      var Se = ge;
      return oe.switchMap(function(Ie, $e) {
        return ye(Se, Ie, $e);
      }, function(Ie, $e) {
        return Se = $e, $e;
      })(we).subscribe(_e), function() {
        Se = null;
      };
    });
  }
  ne.switchScan = fe;
}), FH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeUntil = void 0;
  var oe = he(), ae = Ae(), fe = _t(), ye = On();
  function ge(we) {
    return oe.operate(function(_e, Se) {
      fe.innerFrom(we).subscribe(ae.createOperatorSubscriber(Se, function() {
        return Se.complete();
      }, ye.noop)), !Se.closed && _e.subscribe(Se);
    });
  }
  ne.takeUntil = ge;
}), zH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.takeWhile = void 0;
  var oe = he(), ae = Ae();
  function fe(ye, ge) {
    return ge === void 0 && (ge = !1), oe.operate(function(we, _e) {
      var Se = 0;
      we.subscribe(ae.createOperatorSubscriber(_e, function(Ie) {
        var $e = ye(Ie, Se++);
        ($e || ge) && _e.next(Ie), !$e && _e.complete();
      }));
    });
  }
  ne.takeWhile = fe;
}), qH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.tap = void 0;
  var oe = Mt(), ae = he(), fe = Ae(), ye = Hn();
  function ge(we, _e, Se) {
    var Ie = oe.isFunction(we) || _e || Se ? { next: we, error: _e, complete: Se } : we;
    return Ie ? ae.operate(function($e, Ne) {
      var Me;
      (Me = Ie.subscribe) === null || Me === void 0 || Me.call(Ie);
      var Be = !0;
      $e.subscribe(fe.createOperatorSubscriber(Ne, function(ze) {
        var He;
        (He = Ie.next) === null || He === void 0 || He.call(Ie, ze), Ne.next(ze);
      }, function() {
        var ze;
        Be = !1, (ze = Ie.complete) === null || ze === void 0 || ze.call(Ie), Ne.complete();
      }, function(ze) {
        var He;
        Be = !1, (He = Ie.error) === null || He === void 0 || He.call(Ie, ze), Ne.error(ze);
      }, function() {
        var ze, He;
        Be && ((ze = Ie.unsubscribe) === null || ze === void 0 || ze.call(Ie)), (He = Ie.finalize) === null || He === void 0 || He.call(Ie);
      }));
    }) : ye.identity;
  }
  ne.tap = ge;
}), VA = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttle = ne.defaultThrottleConfig = void 0;
  var oe = he(), ae = Ae(), fe = _t();
  ne.defaultThrottleConfig = { leading: !0, trailing: !1 };
  function ye(ge, we) {
    return we === void 0 && (we = ne.defaultThrottleConfig), oe.operate(function(_e, Se) {
      var Ie = we.leading, $e = we.trailing, Ne = !1, Me = null, Be = null, ze = !1, He = function() {
        Be == null || Be.unsubscribe(), Be = null, $e && (tt(), ze && Se.complete());
      }, Ze = function() {
        Be = null, ze && Se.complete();
      }, qe = function(Xe) {
        return Be = fe.innerFrom(ge(Xe)).subscribe(ae.createOperatorSubscriber(Se, He, Ze));
      }, tt = function() {
        if (Ne) {
          Ne = !1;
          var Xe = Me;
          Me = null, Se.next(Xe), !ze && qe(Xe);
        }
      };
      _e.subscribe(ae.createOperatorSubscriber(Se, function(Xe) {
        Ne = !0, Me = Xe, !(Be && !Be.closed) && (Ie ? tt() : qe(Xe));
      }, function() {
        ze = !0, !($e && Ne && Be && !Be.closed) && Se.complete();
      }));
    });
  }
  ne.throttle = ye;
}), HH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.throttleTime = void 0;
  var oe = Ti(), ae = VA(), fe = Kl();
  function ye(ge, we, _e) {
    we === void 0 && (we = oe.asyncScheduler), _e === void 0 && (_e = ae.defaultThrottleConfig);
    var Se = fe.timer(ge, we);
    return ae.throttle(function() {
      return Se;
    }, _e);
  }
  ne.throttleTime = ye;
}), $H = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.TimeInterval = ne.timeInterval = void 0;
  var oe = Ti(), ae = he(), fe = Ae();
  function ye(we) {
    return we === void 0 && (we = oe.asyncScheduler), ae.operate(function(_e, Se) {
      var Ie = we.now();
      _e.subscribe(fe.createOperatorSubscriber(Se, function($e) {
        var Ne = we.now(), Me = Ne - Ie;
        Ie = Ne, Se.next(new ge($e, Me));
      }));
    });
  }
  ne.timeInterval = ye;
  var ge = function() {
    function we(_e, Se) {
      this.value = _e, this.interval = Se;
    }
    return we;
  }();
  ne.TimeInterval = ge;
}), WH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timeoutWith = void 0;
  var oe = Ti(), ae = zS(), fe = qS();
  function ye(ge, we, _e) {
    var Se, Ie, $e;
    if (_e = _e ?? oe.async, ae.isValidDate(ge) ? Se = ge : typeof ge == "number" && (Ie = ge), we)
      $e = function() {
        return we;
      };
    else
      throw new TypeError("No observable provided to switch to");
    if (Se == null && Ie == null)
      throw new TypeError("No timeout provided.");
    return fe.timeout({ first: Se, each: Ie, scheduler: _e, with: $e });
  }
  ne.timeoutWith = ye;
}), YH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.timestamp = void 0;
  var oe = rS(), ae = Wl();
  function fe(ye) {
    return ye === void 0 && (ye = oe.dateTimestampProvider), ae.map(function(ge) {
      return { value: ge, timestamp: ye.now() };
    });
  }
  ne.timestamp = fe;
}), KH = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.window = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = On();
  function ge(we) {
    return ae.operate(function(_e, Se) {
      var Ie = new oe.Subject();
      Se.next(Ie.asObservable());
      var $e = function(Ne) {
        Ie.error(Ne), Se.error(Ne);
      };
      return _e.subscribe(fe.createOperatorSubscriber(Se, function(Ne) {
        return Ie == null ? void 0 : Ie.next(Ne);
      }, function() {
        Ie.complete(), Se.complete();
      }, $e)), we.subscribe(fe.createOperatorSubscriber(Se, function() {
        Ie.complete(), Se.next(Ie = new oe.Subject());
      }, ye.noop, $e)), function() {
        Ie == null || Ie.unsubscribe(), Ie = null;
      };
    });
  }
  ne.window = ge;
}), JH = M((ne) => {
  var oe = ne && ne.__values || function(we) {
    var _e = typeof Symbol == "function" && Symbol.iterator, Se = _e && we[_e], Ie = 0;
    if (Se)
      return Se.call(we);
    if (we && typeof we.length == "number")
      return { next: function() {
        return we && Ie >= we.length && (we = void 0), { value: we && we[Ie++], done: !we };
      } };
    throw new TypeError(_e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowCount = void 0;
  var ae = Tn(), fe = he(), ye = Ae();
  function ge(we, _e) {
    _e === void 0 && (_e = 0);
    var Se = _e > 0 ? _e : we;
    return fe.operate(function(Ie, $e) {
      var Ne = [new ae.Subject()], Me = 0;
      $e.next(Ne[0].asObservable()), Ie.subscribe(ye.createOperatorSubscriber($e, function(Be) {
        var ze, He;
        try {
          for (var Ze = oe(Ne), qe = Ze.next(); !qe.done; qe = Ze.next()) {
            var tt = qe.value;
            tt.next(Be);
          }
        } catch (pt) {
          ze = { error: pt };
        } finally {
          try {
            qe && !qe.done && (He = Ze.return) && He.call(Ze);
          } finally {
            if (ze)
              throw ze.error;
          }
        }
        var Xe = Me - we + 1;
        if (Xe >= 0 && Xe % Se === 0 && Ne.shift().complete(), ++Me % Se === 0) {
          var ot = new ae.Subject();
          Ne.push(ot), $e.next(ot.asObservable());
        }
      }, function() {
        for (; Ne.length > 0; )
          Ne.shift().complete();
        $e.complete();
      }, function(Be) {
        for (; Ne.length > 0; )
          Ne.shift().error(Be);
        $e.error(Be);
      }, function() {
        Ne = null;
      }));
    });
  }
  ne.windowCount = ge;
}), e4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowTime = void 0;
  var oe = Tn(), ae = Ti(), fe = Oi(), ye = he(), ge = Ae(), we = ku(), _e = ki(), Se = Au();
  function Ie($e) {
    for (var Ne, Me, Be = [], ze = 1; ze < arguments.length; ze++)
      Be[ze - 1] = arguments[ze];
    var He = (Ne = _e.popScheduler(Be)) !== null && Ne !== void 0 ? Ne : ae.asyncScheduler, Ze = (Me = Be[0]) !== null && Me !== void 0 ? Me : null, qe = Be[1] || 1 / 0;
    return ye.operate(function(tt, Xe) {
      var ot = [], pt = !1, ht = function(Nt) {
        var Ft = Nt.window, on = Nt.subs;
        Ft.complete(), on.unsubscribe(), we.arrRemove(ot, Nt), pt && wt();
      }, wt = function() {
        if (ot) {
          var Nt = new fe.Subscription();
          Xe.add(Nt);
          var Ft = new oe.Subject(), on = { window: Ft, subs: Nt, seen: 0 };
          ot.push(on), Xe.next(Ft.asObservable()), Se.executeSchedule(Nt, He, function() {
            return ht(on);
          }, $e);
        }
      };
      Ze !== null && Ze >= 0 ? Se.executeSchedule(Xe, He, wt, Ze, !0) : pt = !0, wt();
      var gt = function(Nt) {
        return ot.slice().forEach(Nt);
      }, It = function(Nt) {
        gt(function(Ft) {
          var on = Ft.window;
          return Nt(on);
        }), Nt(Xe), Xe.unsubscribe();
      };
      return tt.subscribe(ge.createOperatorSubscriber(Xe, function(Nt) {
        gt(function(Ft) {
          Ft.window.next(Nt), qe <= ++Ft.seen && ht(Ft);
        });
      }, function() {
        return It(function(Nt) {
          return Nt.complete();
        });
      }, function(Nt) {
        return It(function(Ft) {
          return Ft.error(Nt);
        });
      })), function() {
        ot = null;
      };
    });
  }
  ne.windowTime = Ie;
}), n4 = M((ne) => {
  var oe = ne && ne.__values || function($e) {
    var Ne = typeof Symbol == "function" && Symbol.iterator, Me = Ne && $e[Ne], Be = 0;
    if (Me)
      return Me.call($e);
    if ($e && typeof $e.length == "number")
      return { next: function() {
        return $e && Be >= $e.length && ($e = void 0), { value: $e && $e[Be++], done: !$e };
      } };
    throw new TypeError(Ne ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowToggle = void 0;
  var ae = Tn(), fe = Oi(), ye = he(), ge = _t(), we = Ae(), _e = On(), Se = ku();
  function Ie($e, Ne) {
    return ye.operate(function(Me, Be) {
      var ze = [], He = function(Ze) {
        for (; 0 < ze.length; )
          ze.shift().error(Ze);
        Be.error(Ze);
      };
      ge.innerFrom($e).subscribe(we.createOperatorSubscriber(Be, function(Ze) {
        var qe = new ae.Subject();
        ze.push(qe);
        var tt = new fe.Subscription(), Xe = function() {
          Se.arrRemove(ze, qe), qe.complete(), tt.unsubscribe();
        }, ot;
        try {
          ot = ge.innerFrom(Ne(Ze));
        } catch (pt) {
          He(pt);
          return;
        }
        Be.next(qe.asObservable()), tt.add(ot.subscribe(we.createOperatorSubscriber(Be, Xe, _e.noop, He)));
      }, _e.noop)), Me.subscribe(we.createOperatorSubscriber(Be, function(Ze) {
        var qe, tt, Xe = ze.slice();
        try {
          for (var ot = oe(Xe), pt = ot.next(); !pt.done; pt = ot.next()) {
            var ht = pt.value;
            ht.next(Ze);
          }
        } catch (wt) {
          qe = { error: wt };
        } finally {
          try {
            pt && !pt.done && (tt = ot.return) && tt.call(ot);
          } finally {
            if (qe)
              throw qe.error;
          }
        }
      }, function() {
        for (; 0 < ze.length; )
          ze.shift().complete();
        Be.complete();
      }, He, function() {
        for (; 0 < ze.length; )
          ze.shift().unsubscribe();
      }));
    });
  }
  ne.windowToggle = Ie;
}), a4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.windowWhen = void 0;
  var oe = Tn(), ae = he(), fe = Ae(), ye = _t();
  function ge(we) {
    return ae.operate(function(_e, Se) {
      var Ie, $e, Ne = function(Be) {
        Ie.error(Be), Se.error(Be);
      }, Me = function() {
        $e == null || $e.unsubscribe(), Ie == null || Ie.complete(), Ie = new oe.Subject(), Se.next(Ie.asObservable());
        var Be;
        try {
          Be = ye.innerFrom(we());
        } catch (ze) {
          Ne(ze);
          return;
        }
        Be.subscribe($e = fe.createOperatorSubscriber(Se, Me, Me, Ne));
      };
      Me(), _e.subscribe(fe.createOperatorSubscriber(Se, function(Be) {
        return Ie.next(Be);
      }, function() {
        Ie.complete(), Se.complete();
      }, Ne, function() {
        $e == null || $e.unsubscribe(), Ie = null;
      }));
    });
  }
  ne.windowWhen = ge;
}), s4 = M((ne) => {
  var oe = ne && ne.__read || function($e, Ne) {
    var Me = typeof Symbol == "function" && $e[Symbol.iterator];
    if (!Me)
      return $e;
    var Be = Me.call($e), ze, He = [], Ze;
    try {
      for (; (Ne === void 0 || Ne-- > 0) && !(ze = Be.next()).done; )
        He.push(ze.value);
    } catch (qe) {
      Ze = { error: qe };
    } finally {
      try {
        ze && !ze.done && (Me = Be.return) && Me.call(Be);
      } finally {
        if (Ze)
          throw Ze.error;
      }
    }
    return He;
  }, ae = ne && ne.__spreadArray || function($e, Ne) {
    for (var Me = 0, Be = Ne.length, ze = $e.length; Me < Be; Me++, ze++)
      $e[ze] = Ne[Me];
    return $e;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.withLatestFrom = void 0;
  var fe = he(), ye = Ae(), ge = _t(), we = Hn(), _e = On(), Se = ki();
  function Ie() {
    for (var $e = [], Ne = 0; Ne < arguments.length; Ne++)
      $e[Ne] = arguments[Ne];
    var Me = Se.popResultSelector($e);
    return fe.operate(function(Be, ze) {
      for (var He = $e.length, Ze = new Array(He), qe = $e.map(function() {
        return !1;
      }), tt = !1, Xe = function(pt) {
        ge.innerFrom($e[pt]).subscribe(ye.createOperatorSubscriber(ze, function(ht) {
          Ze[pt] = ht, !tt && !qe[pt] && (qe[pt] = !0, (tt = qe.every(we.identity)) && (qe = null));
        }, _e.noop));
      }, ot = 0; ot < He; ot++)
        Xe(ot);
      Be.subscribe(ye.createOperatorSubscriber(ze, function(pt) {
        if (tt) {
          var ht = ae([pt], oe(Ze));
          ze.next(Me ? Me.apply(void 0, ae([], oe(ht))) : ht);
        }
      }));
    });
  }
  ne.withLatestFrom = Ie;
}), c4 = M((ne) => {
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipAll = void 0;
  var oe = h_(), ae = AA();
  function fe(ye) {
    return ae.joinAllInternals(oe.zip, ye);
  }
  ne.zipAll = fe;
}), f4 = M((ne) => {
  var oe = ne && ne.__read || function(we, _e) {
    var Se = typeof Symbol == "function" && we[Symbol.iterator];
    if (!Se)
      return we;
    var Ie = Se.call(we), $e, Ne = [], Me;
    try {
      for (; (_e === void 0 || _e-- > 0) && !($e = Ie.next()).done; )
        Ne.push($e.value);
    } catch (Be) {
      Me = { error: Be };
    } finally {
      try {
        $e && !$e.done && (Se = Ie.return) && Se.call(Ie);
      } finally {
        if (Me)
          throw Me.error;
      }
    }
    return Ne;
  }, ae = ne && ne.__spreadArray || function(we, _e) {
    for (var Se = 0, Ie = _e.length, $e = we.length; Se < Ie; Se++, $e++)
      we[$e] = _e[Se];
    return we;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zip = void 0;
  var fe = h_(), ye = he();
  function ge() {
    for (var we = [], _e = 0; _e < arguments.length; _e++)
      we[_e] = arguments[_e];
    return ye.operate(function(Se, Ie) {
      fe.zip.apply(void 0, ae([Se], oe(we))).subscribe(Ie);
    });
  }
  ne.zip = ge;
}), d4 = M((ne) => {
  var oe = ne && ne.__read || function(ge, we) {
    var _e = typeof Symbol == "function" && ge[Symbol.iterator];
    if (!_e)
      return ge;
    var Se = _e.call(ge), Ie, $e = [], Ne;
    try {
      for (; (we === void 0 || we-- > 0) && !(Ie = Se.next()).done; )
        $e.push(Ie.value);
    } catch (Me) {
      Ne = { error: Me };
    } finally {
      try {
        Ie && !Ie.done && (_e = Se.return) && _e.call(Se);
      } finally {
        if (Ne)
          throw Ne.error;
      }
    }
    return $e;
  }, ae = ne && ne.__spreadArray || function(ge, we) {
    for (var _e = 0, Se = we.length, Ie = ge.length; _e < Se; _e++, Ie++)
      ge[Ie] = we[_e];
    return ge;
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.zipWith = void 0;
  var fe = f4();
  function ye() {
    for (var ge = [], we = 0; we < arguments.length; we++)
      ge[we] = arguments[we];
    return fe.zip.apply(void 0, ae([], oe(ge)));
  }
  ne.zipWith = ye;
}), WA = M((ne) => {
  var oe = ne && ne.__createBinding || (Object.create ? function(Kt, mn, Sn, or) {
    or === void 0 && (or = Sn), Object.defineProperty(Kt, or, { enumerable: !0, get: function() {
      return mn[Sn];
    } });
  } : function(Kt, mn, Sn, or) {
    or === void 0 && (or = Sn), Kt[or] = mn[Sn];
  }), ae = ne && ne.__exportStar || function(Kt, mn) {
    for (var Sn in Kt)
      Sn !== "default" && !Object.prototype.hasOwnProperty.call(mn, Sn) && oe(mn, Kt, Sn);
  };
  Object.defineProperty(ne, "__esModule", { value: !0 }), ne.interval = ne.iif = ne.generate = ne.fromEventPattern = ne.fromEvent = ne.from = ne.forkJoin = ne.empty = ne.defer = ne.connectable = ne.concat = ne.combineLatest = ne.bindNodeCallback = ne.bindCallback = ne.UnsubscriptionError = ne.TimeoutError = ne.SequenceError = ne.ObjectUnsubscribedError = ne.NotFoundError = ne.EmptyError = ne.ArgumentOutOfRangeError = ne.firstValueFrom = ne.lastValueFrom = ne.isObservable = ne.identity = ne.noop = ne.pipe = ne.NotificationKind = ne.Notification = ne.Subscriber = ne.Subscription = ne.Scheduler = ne.VirtualAction = ne.VirtualTimeScheduler = ne.animationFrameScheduler = ne.animationFrame = ne.queueScheduler = ne.queue = ne.asyncScheduler = ne.async = ne.asapScheduler = ne.asap = ne.AsyncSubject = ne.ReplaySubject = ne.BehaviorSubject = ne.Subject = ne.animationFrames = ne.observable = ne.ConnectableObservable = ne.Observable = void 0, ne.filter = ne.expand = ne.exhaustMap = ne.exhaustAll = ne.exhaust = ne.every = ne.endWith = ne.elementAt = ne.distinctUntilKeyChanged = ne.distinctUntilChanged = ne.distinct = ne.dematerialize = ne.delayWhen = ne.delay = ne.defaultIfEmpty = ne.debounceTime = ne.debounce = ne.count = ne.connect = ne.concatWith = ne.concatMapTo = ne.concatMap = ne.concatAll = ne.combineLatestWith = ne.combineLatestAll = ne.combineAll = ne.catchError = ne.bufferWhen = ne.bufferToggle = ne.bufferTime = ne.bufferCount = ne.buffer = ne.auditTime = ne.audit = ne.config = ne.NEVER = ne.EMPTY = ne.scheduled = ne.zip = ne.using = ne.timer = ne.throwError = ne.range = ne.race = ne.partition = ne.pairs = ne.onErrorResumeNext = ne.of = ne.never = ne.merge = void 0, ne.switchMapTo = ne.switchMap = ne.switchAll = ne.subscribeOn = ne.startWith = ne.skipWhile = ne.skipUntil = ne.skipLast = ne.skip = ne.single = ne.shareReplay = ne.share = ne.sequenceEqual = ne.scan = ne.sampleTime = ne.sample = ne.refCount = ne.retryWhen = ne.retry = ne.repeatWhen = ne.repeat = ne.reduce = ne.raceWith = ne.publishReplay = ne.publishLast = ne.publishBehavior = ne.publish = ne.pluck = ne.pairwise = ne.observeOn = ne.multicast = ne.min = ne.mergeWith = ne.mergeScan = ne.mergeMapTo = ne.mergeMap = ne.flatMap = ne.mergeAll = ne.max = ne.materialize = ne.mapTo = ne.map = ne.last = ne.isEmpty = ne.ignoreElements = ne.groupBy = ne.first = ne.findIndex = ne.find = ne.finalize = void 0, ne.zipWith = ne.zipAll = ne.withLatestFrom = ne.windowWhen = ne.windowToggle = ne.windowTime = ne.windowCount = ne.window = ne.toArray = ne.timestamp = ne.timeoutWith = ne.timeout = ne.timeInterval = ne.throwIfEmpty = ne.throttleTime = ne.throttle = ne.tap = ne.takeWhile = ne.takeUntil = ne.takeLast = ne.take = ne.switchScan = void 0;
  var fe = qt();
  Object.defineProperty(ne, "Observable", { enumerable: !0, get: function() {
    return fe.Observable;
  } });
  var ye = sh();
  Object.defineProperty(ne, "ConnectableObservable", { enumerable: !0, get: function() {
    return ye.ConnectableObservable;
  } });
  var ge = uh();
  Object.defineProperty(ne, "observable", { enumerable: !0, get: function() {
    return ge.observable;
  } });
  var we = hI();
  Object.defineProperty(ne, "animationFrames", { enumerable: !0, get: function() {
    return we.animationFrames;
  } });
  var _e = Tn();
  Object.defineProperty(ne, "Subject", { enumerable: !0, get: function() {
    return _e.Subject;
  } });
  var Se = Xk();
  Object.defineProperty(ne, "BehaviorSubject", { enumerable: !0, get: function() {
    return Se.BehaviorSubject;
  } });
  var Ie = nS();
  Object.defineProperty(ne, "ReplaySubject", { enumerable: !0, get: function() {
    return Ie.ReplaySubject;
  } });
  var $e = iS();
  Object.defineProperty(ne, "AsyncSubject", { enumerable: !0, get: function() {
    return $e.AsyncSubject;
  } });
  var Ne = DI();
  Object.defineProperty(ne, "asap", { enumerable: !0, get: function() {
    return Ne.asap;
  } }), Object.defineProperty(ne, "asapScheduler", { enumerable: !0, get: function() {
    return Ne.asapScheduler;
  } });
  var Me = Ti();
  Object.defineProperty(ne, "async", { enumerable: !0, get: function() {
    return Me.async;
  } }), Object.defineProperty(ne, "asyncScheduler", { enumerable: !0, get: function() {
    return Me.asyncScheduler;
  } });
  var Be = jI();
  Object.defineProperty(ne, "queue", { enumerable: !0, get: function() {
    return Be.queue;
  } }), Object.defineProperty(ne, "queueScheduler", { enumerable: !0, get: function() {
    return Be.queueScheduler;
  } });
  var ze = qI();
  Object.defineProperty(ne, "animationFrame", { enumerable: !0, get: function() {
    return ze.animationFrame;
  } }), Object.defineProperty(ne, "animationFrameScheduler", { enumerable: !0, get: function() {
    return ze.animationFrameScheduler;
  } });
  var He = HI();
  Object.defineProperty(ne, "VirtualTimeScheduler", { enumerable: !0, get: function() {
    return He.VirtualTimeScheduler;
  } }), Object.defineProperty(ne, "VirtualAction", { enumerable: !0, get: function() {
    return He.VirtualAction;
  } });
  var Ze = Zk();
  Object.defineProperty(ne, "Scheduler", { enumerable: !0, get: function() {
    return Ze.Scheduler;
  } });
  var qe = Oi();
  Object.defineProperty(ne, "Subscription", { enumerable: !0, get: function() {
    return qe.Subscription;
  } });
  var tt = Sd();
  Object.defineProperty(ne, "Subscriber", { enumerable: !0, get: function() {
    return tt.Subscriber;
  } });
  var Xe = AS();
  Object.defineProperty(ne, "Notification", { enumerable: !0, get: function() {
    return Xe.Notification;
  } }), Object.defineProperty(ne, "NotificationKind", { enumerable: !0, get: function() {
    return Xe.NotificationKind;
  } });
  var ot = lh();
  Object.defineProperty(ne, "pipe", { enumerable: !0, get: function() {
    return ot.pipe;
  } });
  var pt = On();
  Object.defineProperty(ne, "noop", { enumerable: !0, get: function() {
    return pt.noop;
  } });
  var ht = Hn();
  Object.defineProperty(ne, "identity", { enumerable: !0, get: function() {
    return ht.identity;
  } });
  var wt = o3();
  Object.defineProperty(ne, "isObservable", { enumerable: !0, get: function() {
    return wt.isObservable;
  } });
  var gt = u3();
  Object.defineProperty(ne, "lastValueFrom", { enumerable: !0, get: function() {
    return gt.lastValueFrom;
  } });
  var It = l3();
  Object.defineProperty(ne, "firstValueFrom", { enumerable: !0, get: function() {
    return It.firstValueFrom;
  } });
  var Nt = vA();
  Object.defineProperty(ne, "ArgumentOutOfRangeError", { enumerable: !0, get: function() {
    return Nt.ArgumentOutOfRangeError;
  } });
  var Ft = $l();
  Object.defineProperty(ne, "EmptyError", { enumerable: !0, get: function() {
    return Ft.EmptyError;
  } });
  var on = mA();
  Object.defineProperty(ne, "NotFoundError", { enumerable: !0, get: function() {
    return on.NotFoundError;
  } });
  var en = Yk();
  Object.defineProperty(ne, "ObjectUnsubscribedError", { enumerable: !0, get: function() {
    return en.ObjectUnsubscribedError;
  } });
  var wn = hA();
  Object.defineProperty(ne, "SequenceError", { enumerable: !0, get: function() {
    return wn.SequenceError;
  } });
  var Zt = qS();
  Object.defineProperty(ne, "TimeoutError", { enumerable: !0, get: function() {
    return Zt.TimeoutError;
  } });
  var pn = Nk();
  Object.defineProperty(ne, "UnsubscriptionError", { enumerable: !0, get: function() {
    return pn.UnsubscriptionError;
  } });
  var un = c3();
  Object.defineProperty(ne, "bindCallback", { enumerable: !0, get: function() {
    return un.bindCallback;
  } });
  var dn = f3();
  Object.defineProperty(ne, "bindNodeCallback", { enumerable: !0, get: function() {
    return dn.bindNodeCallback;
  } });
  var xn = WS();
  Object.defineProperty(ne, "combineLatest", { enumerable: !0, get: function() {
    return xn.combineLatest;
  } });
  var Rn = hh();
  Object.defineProperty(ne, "concat", { enumerable: !0, get: function() {
    return Rn.concat;
  } });
  var At = b3();
  Object.defineProperty(ne, "connectable", { enumerable: !0, get: function() {
    return At.connectable;
  } });
  var hn = yh();
  Object.defineProperty(ne, "defer", { enumerable: !0, get: function() {
    return hn.defer;
  } });
  var Yn = ba();
  Object.defineProperty(ne, "empty", { enumerable: !0, get: function() {
    return Yn.empty;
  } });
  var Un = S3();
  Object.defineProperty(ne, "forkJoin", { enumerable: !0, get: function() {
    return Un.forkJoin;
  } });
  var Ht = Ja();
  Object.defineProperty(ne, "from", { enumerable: !0, get: function() {
    return Ht.from;
  } });
  var _n = w3();
  Object.defineProperty(ne, "fromEvent", { enumerable: !0, get: function() {
    return _n.fromEvent;
  } });
  var Vn = E3();
  Object.defineProperty(ne, "fromEventPattern", { enumerable: !0, get: function() {
    return Vn.fromEventPattern;
  } });
  var br = R3();
  Object.defineProperty(ne, "generate", { enumerable: !0, get: function() {
    return br.generate;
  } });
  var nr = O3();
  Object.defineProperty(ne, "iif", { enumerable: !0, get: function() {
    return nr.iif;
  } });
  var Er = wA();
  Object.defineProperty(ne, "interval", { enumerable: !0, get: function() {
    return Er.interval;
  } });
  var Qo = k3();
  Object.defineProperty(ne, "merge", { enumerable: !0, get: function() {
    return Qo.merge;
  } });
  var Yr = xA();
  Object.defineProperty(ne, "never", { enumerable: !0, get: function() {
    return Yr.never;
  } });
  var qr = TS();
  Object.defineProperty(ne, "of", { enumerable: !0, get: function() {
    return qr.of;
  } });
  var Kr = M3();
  Object.defineProperty(ne, "onErrorResumeNext", { enumerable: !0, get: function() {
    return Kr.onErrorResumeNext;
  } });
  var $o = D3();
  Object.defineProperty(ne, "pairs", { enumerable: !0, get: function() {
    return $o.pairs;
  } });
  var xo = U3();
  Object.defineProperty(ne, "partition", { enumerable: !0, get: function() {
    return xo.partition;
  } });
  var _o = EA();
  Object.defineProperty(ne, "race", { enumerable: !0, get: function() {
    return _o.race;
  } });
  var ra = q3();
  Object.defineProperty(ne, "range", { enumerable: !0, get: function() {
    return ra.range;
  } });
  var Aa = pA();
  Object.defineProperty(ne, "throwError", { enumerable: !0, get: function() {
    return Aa.throwError;
  } });
  var Ho = Kl();
  Object.defineProperty(ne, "timer", { enumerable: !0, get: function() {
    return Ho.timer;
  } });
  var ca = I3();
  Object.defineProperty(ne, "using", { enumerable: !0, get: function() {
    return ca.using;
  } });
  var No = h_();
  Object.defineProperty(ne, "zip", { enumerable: !0, get: function() {
    return No.zip;
  } });
  var xa = dA();
  Object.defineProperty(ne, "scheduled", { enumerable: !0, get: function() {
    return xa.scheduled;
  } });
  var qa = ba();
  Object.defineProperty(ne, "EMPTY", { enumerable: !0, get: function() {
    return qa.EMPTY;
  } });
  var da = xA();
  Object.defineProperty(ne, "NEVER", { enumerable: !0, get: function() {
    return da.NEVER;
  } }), ae(H3(), ne);
  var oa = gd();
  Object.defineProperty(ne, "config", { enumerable: !0, get: function() {
    return oa.config;
  } });
  var Ka = CA();
  Object.defineProperty(ne, "audit", { enumerable: !0, get: function() {
    return Ka.audit;
  } });
  var jo = $3();
  Object.defineProperty(ne, "auditTime", { enumerable: !0, get: function() {
    return jo.auditTime;
  } });
  var La = Y3();
  Object.defineProperty(ne, "buffer", { enumerable: !0, get: function() {
    return La.buffer;
  } });
  var $t = G3();
  Object.defineProperty(ne, "bufferCount", { enumerable: !0, get: function() {
    return $t.bufferCount;
  } });
  var Vt = K3();
  Object.defineProperty(ne, "bufferTime", { enumerable: !0, get: function() {
    return Vt.bufferTime;
  } });
  var rn = Z3();
  Object.defineProperty(ne, "bufferToggle", { enumerable: !0, get: function() {
    return rn.bufferToggle;
  } });
  var Cn = tB();
  Object.defineProperty(ne, "bufferWhen", { enumerable: !0, get: function() {
    return Cn.bufferWhen;
  } });
  var Mn = nB();
  Object.defineProperty(ne, "catchError", { enumerable: !0, get: function() {
    return Mn.catchError;
  } });
  var Bn = iB();
  Object.defineProperty(ne, "combineAll", { enumerable: !0, get: function() {
    return Bn.combineAll;
  } });
  var Qn = PA();
  Object.defineProperty(ne, "combineLatestAll", { enumerable: !0, get: function() {
    return Qn.combineLatestAll;
  } });
  var Kn = sB();
  Object.defineProperty(ne, "combineLatestWith", { enumerable: !0, get: function() {
    return Kn.combineLatestWith;
  } });
  var jn = JS();
  Object.defineProperty(ne, "concatAll", { enumerable: !0, get: function() {
    return jn.concatAll;
  } });
  var Tr = MA();
  Object.defineProperty(ne, "concatMap", { enumerable: !0, get: function() {
    return Tr.concatMap;
  } });
  var jr = dB();
  Object.defineProperty(ne, "concatMapTo", { enumerable: !0, get: function() {
    return jr.concatMapTo;
  } });
  var bo = vB();
  Object.defineProperty(ne, "concatWith", { enumerable: !0, get: function() {
    return bo.concatWith;
  } });
  var _r = M_();
  Object.defineProperty(ne, "connect", { enumerable: !0, get: function() {
    return _r.connect;
  } });
  var Sr = hB();
  Object.defineProperty(ne, "count", { enumerable: !0, get: function() {
    return Sr.count;
  } });
  var Ro = gB();
  Object.defineProperty(ne, "debounce", { enumerable: !0, get: function() {
    return Ro.debounce;
  } });
  var Xa = bB();
  Object.defineProperty(ne, "debounceTime", { enumerable: !0, get: function() {
    return Xa.debounceTime;
  } });
  var Gi = gh();
  Object.defineProperty(ne, "defaultIfEmpty", { enumerable: !0, get: function() {
    return Gi.defaultIfEmpty;
  } });
  var Yi = wB();
  Object.defineProperty(ne, "delay", { enumerable: !0, get: function() {
    return Yi.delay;
  } });
  var ei = LA();
  Object.defineProperty(ne, "delayWhen", { enumerable: !0, get: function() {
    return ei.delayWhen;
  } });
  var Si = xB();
  Object.defineProperty(ne, "dematerialize", { enumerable: !0, get: function() {
    return Si.dematerialize;
  } });
  var Da = CB();
  Object.defineProperty(ne, "distinct", { enumerable: !0, get: function() {
    return Da.distinct;
  } });
  var ti = jA();
  Object.defineProperty(ne, "distinctUntilChanged", { enumerable: !0, get: function() {
    return ti.distinctUntilChanged;
  } });
  var Ni = RB();
  Object.defineProperty(ne, "distinctUntilKeyChanged", { enumerable: !0, get: function() {
    return Ni.distinctUntilKeyChanged;
  } });
  var Ea = TB();
  Object.defineProperty(ne, "elementAt", { enumerable: !0, get: function() {
    return Ea.elementAt;
  } });
  var Jr = kB();
  Object.defineProperty(ne, "endWith", { enumerable: !0, get: function() {
    return Jr.endWith;
  } });
  var vo = AB();
  Object.defineProperty(ne, "every", { enumerable: !0, get: function() {
    return vo.every;
  } });
  var aa = MB();
  Object.defineProperty(ne, "exhaust", { enumerable: !0, get: function() {
    return aa.exhaust;
  } });
  var ni = UA();
  Object.defineProperty(ne, "exhaustAll", { enumerable: !0, get: function() {
    return ni.exhaustAll;
  } });
  var Ot = jB();
  Object.defineProperty(ne, "exhaustMap", { enumerable: !0, get: function() {
    return Ot.exhaustMap;
  } });
  var En = UB();
  Object.defineProperty(ne, "expand", { enumerable: !0, get: function() {
    return En.expand;
  } });
  var An = _c();
  Object.defineProperty(ne, "filter", { enumerable: !0, get: function() {
    return An.filter;
  } });
  var ar = FB();
  Object.defineProperty(ne, "finalize", { enumerable: !0, get: function() {
    return ar.finalize;
  } });
  var Rr = FA();
  Object.defineProperty(ne, "find", { enumerable: !0, get: function() {
    return Rr.find;
  } });
  var Wr = qB();
  Object.defineProperty(ne, "findIndex", { enumerable: !0, get: function() {
    return Wr.findIndex;
  } });
  var Lr = IB();
  Object.defineProperty(ne, "first", { enumerable: !0, get: function() {
    return Lr.first;
  } });
  var fr = HB();
  Object.defineProperty(ne, "groupBy", { enumerable: !0, get: function() {
    return fr.groupBy;
  } });
  var sa = DA();
  Object.defineProperty(ne, "ignoreElements", { enumerable: !0, get: function() {
    return sa.ignoreElements;
  } });
  var Eo = VB();
  Object.defineProperty(ne, "isEmpty", { enumerable: !0, get: function() {
    return Eo.isEmpty;
  } });
  var So = $B();
  Object.defineProperty(ne, "last", { enumerable: !0, get: function() {
    return So.last;
  } });
  var Ca = Wl();
  Object.defineProperty(ne, "map", { enumerable: !0, get: function() {
    return Ca.map;
  } });
  var zs = NA();
  Object.defineProperty(ne, "mapTo", { enumerable: !0, get: function() {
    return zs.mapTo;
  } });
  var Ol = WB();
  Object.defineProperty(ne, "materialize", { enumerable: !0, get: function() {
    return Ol.materialize;
  } });
  var Xr = YB();
  Object.defineProperty(ne, "max", { enumerable: !0, get: function() {
    return Xr.max;
  } });
  var Yf = mh();
  Object.defineProperty(ne, "mergeAll", { enumerable: !0, get: function() {
    return Yf.mergeAll;
  } });
  var _s = GB();
  Object.defineProperty(ne, "flatMap", { enumerable: !0, get: function() {
    return _s.flatMap;
  } });
  var zr = Mu();
  Object.defineProperty(ne, "mergeMap", { enumerable: !0, get: function() {
    return zr.mergeMap;
  } });
  var Pi = KB();
  Object.defineProperty(ne, "mergeMapTo", { enumerable: !0, get: function() {
    return Pi.mergeMapTo;
  } });
  var Fc = XB();
  Object.defineProperty(ne, "mergeScan", { enumerable: !0, get: function() {
    return Fc.mergeScan;
  } });
  var Al = eH();
  Object.defineProperty(ne, "mergeWith", { enumerable: !0, get: function() {
    return Al.mergeWith;
  } });
  var gu = tH();
  Object.defineProperty(ne, "min", { enumerable: !0, get: function() {
    return gu.min;
  } });
  var Ci = dw();
  Object.defineProperty(ne, "multicast", { enumerable: !0, get: function() {
    return Ci.multicast;
  } });
  var zc = ph();
  Object.defineProperty(ne, "observeOn", { enumerable: !0, get: function() {
    return zc.observeOn;
  } });
  var ri = nH();
  Object.defineProperty(ne, "pairwise", { enumerable: !0, get: function() {
    return ri.pairwise;
  } });
  var Uc = iH();
  Object.defineProperty(ne, "pluck", { enumerable: !0, get: function() {
    return Uc.pluck;
  } });
  var Vc = aH();
  Object.defineProperty(ne, "publish", { enumerable: !0, get: function() {
    return Vc.publish;
  } });
  var Qf = oH();
  Object.defineProperty(ne, "publishBehavior", { enumerable: !0, get: function() {
    return Qf.publishBehavior;
  } });
  var Cl = uH();
  Object.defineProperty(ne, "publishLast", { enumerable: !0, get: function() {
    return Cl.publishLast;
  } });
  var Us = sH();
  Object.defineProperty(ne, "publishReplay", { enumerable: !0, get: function() {
    return Us.publishReplay;
  } });
  var xs = cH();
  Object.defineProperty(ne, "raceWith", { enumerable: !0, get: function() {
    return xs.raceWith;
  } });
  var Ba = Qd();
  Object.defineProperty(ne, "reduce", { enumerable: !0, get: function() {
    return Ba.reduce;
  } });
  var el = dH();
  Object.defineProperty(ne, "repeat", { enumerable: !0, get: function() {
    return el.repeat;
  } });
  var su = vH();
  Object.defineProperty(ne, "repeatWhen", { enumerable: !0, get: function() {
    return su.repeatWhen;
  } });
  var Hc = hH();
  Object.defineProperty(ne, "retry", { enumerable: !0, get: function() {
    return Hc.retry;
  } });
  var tl = gH();
  Object.defineProperty(ne, "retryWhen", { enumerable: !0, get: function() {
    return tl.retryWhen;
  } });
  var Zc = $k();
  Object.defineProperty(ne, "refCount", { enumerable: !0, get: function() {
    return Zc.refCount;
  } });
  var uu = IA();
  Object.defineProperty(ne, "sample", { enumerable: !0, get: function() {
    return uu.sample;
  } });
  var Rl = SH();
  Object.defineProperty(ne, "sampleTime", { enumerable: !0, get: function() {
    return Rl.sampleTime;
  } });
  var _u = _H();
  Object.defineProperty(ne, "scan", { enumerable: !0, get: function() {
    return _u.scan;
  } });
  var so = xH();
  Object.defineProperty(ne, "sequenceEqual", { enumerable: !0, get: function() {
    return so.sequenceEqual;
  } });
  var Su = HA();
  Object.defineProperty(ne, "share", { enumerable: !0, get: function() {
    return Su.share;
  } });
  var Yd = EH();
  Object.defineProperty(ne, "shareReplay", { enumerable: !0, get: function() {
    return Yd.shareReplay;
  } });
  var Es = CH();
  Object.defineProperty(ne, "single", { enumerable: !0, get: function() {
    return Es.single;
  } });
  var uo = RH();
  Object.defineProperty(ne, "skip", { enumerable: !0, get: function() {
    return uo.skip;
  } });
  var qc = OH();
  Object.defineProperty(ne, "skipLast", { enumerable: !0, get: function() {
    return qc.skipLast;
  } });
  var Wc = kH();
  Object.defineProperty(ne, "skipUntil", { enumerable: !0, get: function() {
    return Wc.skipUntil;
  } });
  var Ar = AH();
  Object.defineProperty(ne, "skipWhile", { enumerable: !0, get: function() {
    return Ar.skipWhile;
  } });
  var Pu = MH();
  Object.defineProperty(ne, "startWith", { enumerable: !0, get: function() {
    return Pu.startWith;
  } });
  var Zo = vh();
  Object.defineProperty(ne, "subscribeOn", { enumerable: !0, get: function() {
    return Zo.subscribeOn;
  } });
  var ii = NH();
  Object.defineProperty(ne, "switchAll", { enumerable: !0, get: function() {
    return ii.switchAll;
  } });
  var si = Sh();
  Object.defineProperty(ne, "switchMap", { enumerable: !0, get: function() {
    return si.switchMap;
  } });
  var Iu = jH();
  Object.defineProperty(ne, "switchMapTo", { enumerable: !0, get: function() {
    return Iu.switchMapTo;
  } });
  var Ko = UH();
  Object.defineProperty(ne, "switchScan", { enumerable: !0, get: function() {
    return Ko.switchScan;
  } });
  var lo = Kd();
  Object.defineProperty(ne, "take", { enumerable: !0, get: function() {
    return lo.take;
  } });
  var Xd = zA();
  Object.defineProperty(ne, "takeLast", { enumerable: !0, get: function() {
    return Xd.takeLast;
  } });
  var Mi = FH();
  Object.defineProperty(ne, "takeUntil", { enumerable: !0, get: function() {
    return Mi.takeUntil;
  } });
  var Sa = zH();
  Object.defineProperty(ne, "takeWhile", { enumerable: !0, get: function() {
    return Sa.takeWhile;
  } });
  var Vs = qH();
  Object.defineProperty(ne, "tap", { enumerable: !0, get: function() {
    return Vs.tap;
  } });
  var Gc = VA();
  Object.defineProperty(ne, "throttle", { enumerable: !0, get: function() {
    return Gc.throttle;
  } });
  var Ss = HH();
  Object.defineProperty(ne, "throttleTime", { enumerable: !0, get: function() {
    return Ss.throttleTime;
  } });
  var Yc = bh();
  Object.defineProperty(ne, "throwIfEmpty", { enumerable: !0, get: function() {
    return Yc.throwIfEmpty;
  } });
  var lu = $H();
  Object.defineProperty(ne, "timeInterval", { enumerable: !0, get: function() {
    return lu.timeInterval;
  } });
  var $u = qS();
  Object.defineProperty(ne, "timeout", { enumerable: !0, get: function() {
    return $u.timeout;
  } });
  var nl = WH();
  Object.defineProperty(ne, "timeoutWith", { enumerable: !0, get: function() {
    return nl.timeoutWith;
  } });
  var Ps = YH();
  Object.defineProperty(ne, "timestamp", { enumerable: !0, get: function() {
    return Ps.timestamp;
  } });
  var ks = kA();
  Object.defineProperty(ne, "toArray", { enumerable: !0, get: function() {
    return ks.toArray;
  } });
  var Nl = KH();
  Object.defineProperty(ne, "window", { enumerable: !0, get: function() {
    return Nl.window;
  } });
  var Bu = JH();
  Object.defineProperty(ne, "windowCount", { enumerable: !0, get: function() {
    return Bu.windowCount;
  } });
  var Ml = e4();
  Object.defineProperty(ne, "windowTime", { enumerable: !0, get: function() {
    return Ml.windowTime;
  } });
  var rl = n4();
  Object.defineProperty(ne, "windowToggle", { enumerable: !0, get: function() {
    return rl.windowToggle;
  } });
  var Dl = a4();
  Object.defineProperty(ne, "windowWhen", { enumerable: !0, get: function() {
    return Dl.windowWhen;
  } });
  var Qc = s4();
  Object.defineProperty(ne, "withLatestFrom", { enumerable: !0, get: function() {
    return Qc.withLatestFrom;
  } });
  var it = c4();
  Object.defineProperty(ne, "zipAll", { enumerable: !0, get: function() {
    return it.zipAll;
  } });
  var Ct = d4();
  Object.defineProperty(ne, "zipWith", { enumerable: !0, get: function() {
    return Ct.zipWith;
  } });
});
function Kw(ne, oe) {
  let ae = (oe == null ? void 0 : oe.updateOnValueChange) ?? !0, fe = Nge(ne), ye = (0, rp.useMemo)(() => f(fe, { runOnInit: !0 }), [fe]), [ge, we] = (0, rp.useState)([...ye.matching]);
  return (0, rp.useEffect)(() => {
    we([...ye.matching]);
    let _e = ye.update$.pipe((0, Qw.map)(() => [...ye.matching]));
    ae || (_e = _e.pipe((0, Qw.distinctUntilChanged)((Ie, $e) => (0, _4.default)(Ie, $e))));
    let Se = _e.subscribe((Ie) => we(Ie));
    return () => Se.unsubscribe();
  }, [ye, ae]), ge;
}
function w4(ne, oe) {
  let [ae, fe] = (0, Xw.useState)(oe);
  return (0, Xw.useEffect)(() => {
    let ye = ne.subscribe(fe);
    return () => ye.unsubscribe();
  }, [ne]), ae;
}
function _h(ne) {
  let oe = (0, xc.useRef)(ne), [ae, fe] = (0, xc.useState)(ne == null ? { status: "idle" } : { status: "pending" });
  return (0, xc.useEffect)(() => {
    ne !== oe.current && (oe.current = ne, fe(ne == null ? { status: "idle" } : { status: "pending" }));
  }, [ne]), (0, xc.useEffect)(() => {
    ne != null && Promise.allSettled([ne]).then(([ye]) => {
      ne === oe.current && fe(ye);
    });
  }, [ne]), ae;
}
var rp, Gw, S4, _4, Qw, Xw, xc, Nge, wh = Y(() => {
  le(ir(), 1), rp = le(ir(), 1), Gw = le(ir(), 1), S4 = le(Dk(), 1), _4 = le(Dk(), 1), Qw = le(WA(), 1), Xw = le(ir(), 1), xc = le(ir(), 1), Nge = (ne) => {
    let [oe, ae] = (0, Gw.useState)(ne);
    return (0, Gw.useEffect)(() => {
      (0, S4.default)(ne, oe) || ae(ne);
    }, [ne]), oe;
  };
});
function E4() {
  var ye, ge;
  let { publicClient: ne, worldAddress: oe, latestBlock$: ae } = zt(), fe = w4(ae.pipe((0, x4.map)((we) => we.number)));
  return (0, Za.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Chain" }), (0, Za.jsxs)("dd", { className: "text-sm", children: [(ye = ne.chain) == null ? void 0 : ye.id, " (", (ge = ne.chain) == null ? void 0 : ge.name, ")"] }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "Block number" }), (0, Za.jsx)("dd", { className: "text-sm", children: fe == null ? void 0 : fe.toString() }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "RPC" }), (0, Za.jsx)("dd", { className: "text-sm text-green-500", children: "Connected ✓" }), (0, Za.jsx)("dt", { className: "text-amber-200/80", children: "World" }), (0, Za.jsx)("dd", { className: "text-sm", children: oe })] });
}
var x4, Za, C4 = Y(() => {
  wh(), ai(), x4 = le(WA(), 1), Za = le(ke(), 1);
});
function R4(ne, oe) {
  var ae;
  return (ae = ne.exec(oe)) == null ? void 0 : ae.groups;
}
var O4 = Y(() => {
});
function Jw(ne) {
  let oe = ne.type;
  if (T4.test(ne.type) && "components" in ne) {
    oe = "(";
    let ae = ne.components.length;
    for (let ye = 0; ye < ae; ye++) {
      let ge = ne.components[ye];
      oe += Jw(ge), ye < ae - 1 && (oe += ", ");
    }
    let fe = R4(T4, ne.type);
    return oe += `)${(fe == null ? void 0 : fe.array) ?? ""}`, Jw({ ...ne, type: oe });
  }
  return "indexed" in ne && ne.indexed && (oe = `${oe} indexed`), ne.name ? `${oe} ${ne.name}` : oe;
}
var T4, k4 = Y(() => {
  O4(), T4 = /^tuple(?<array>(\[(\d*)\])*)$/;
});
function np(ne) {
  let oe = "", ae = ne.length;
  for (let fe = 0; fe < ae; fe++) {
    let ye = ne[fe];
    oe += Jw(ye), fe !== ae - 1 && (oe += ", ");
  }
  return oe;
}
var A4 = Y(() => {
  k4();
});
function YA(ne) {
  return ne.type === "function" ? `function ${ne.name}(${np(ne.inputs)})${ne.stateMutability && ne.stateMutability !== "nonpayable" ? ` ${ne.stateMutability}` : ""}${ne.outputs.length ? ` returns (${np(ne.outputs)})` : ""}` : ne.type === "event" ? `event ${ne.name}(${np(ne.inputs)})` : ne.type === "error" ? `error ${ne.name}(${np(ne.inputs)})` : ne.type === "constructor" ? `constructor(${np(ne.inputs)})${ne.stateMutability === "payable" ? " payable" : ""}` : ne.type === "fallback" ? "fallback()" : "receive() external payable";
}
var P4 = Y(() => {
  A4();
}), M4 = Y(() => {
  P4();
});
function ip(ne, { includeName: oe = !1 } = {}) {
  if (ne.type !== "function" && ne.type !== "event" && ne.type !== "error")
    throw new Eh(ne.type);
  return `${ne.name}(${xh(ne.inputs, { includeName: oe })})`;
}
function xh(ne, { includeName: oe = !1 } = {}) {
  return ne ? ne.map((ae) => Lge(ae, { includeName: oe })).join(oe ? ", " : ",") : "";
}
function Lge(ne, { includeName: oe }) {
  return ne.type.startsWith("tuple") ? `(${xh(ne.components, { includeName: oe })})${ne.type.slice(5)}` : ne.type + (oe && ne.name ? ` ${ne.name}` : "");
}
var Zw = Y(() => {
  ap();
});
function eo(ne, { strict: oe = !0 } = {}) {
  return !ne || typeof ne != "string" ? !1 : oe ? /^0x[0-9a-fA-F]*$/.test(ne) : ne.startsWith("0x");
}
var op = Y(() => {
});
function oi(ne) {
  return eo(ne, { strict: !1 }) ? Math.ceil((ne.length - 2) / 2) : ne.length;
}
var Ch = Y(() => {
  op();
}), D4, N4 = Y(() => {
  D4 = "2.9.20";
}), L4, j4 = Y(() => {
  N4(), L4 = () => `viem@${D4}`;
});
function U4(ne, oe) {
  return oe != null && oe(ne) ? ne : ne && typeof ne == "object" && "cause" in ne ? U4(ne.cause, oe) : oe ? null : ne;
}
var kt, Ec = Y(() => {
  j4(), kt = class extends Error {
    constructor(ne, oe = {}) {
      var ye;
      super(), Object.defineProperty(this, "details", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "docsPath", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "metaMessages", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shortMessage", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "ViemError" }), Object.defineProperty(this, "version", { enumerable: !0, configurable: !0, writable: !0, value: L4() });
      let ae = oe.cause instanceof kt ? oe.cause.details : (ye = oe.cause) != null && ye.message ? oe.cause.message : oe.details, fe = oe.cause instanceof kt && oe.cause.docsPath || oe.docsPath;
      this.message = [ne || "An error occurred.", "", ...oe.metaMessages ? [...oe.metaMessages, ""] : [], ...fe ? [`Docs: https://viem.sh${fe}${oe.docsSlug ? `#${oe.docsSlug}` : ""}`] : [], ...ae ? [`Details: ${ae}`] : [], `Version: ${this.version}`].join(`
`), oe.cause && (this.cause = oe.cause), this.details = ae, this.docsPath = fe, this.metaMessages = oe.metaMessages, this.shortMessage = ne;
    }
    walk(ne) {
      return U4(this, ne);
    }
  };
}), Cc, Rh, Oh, Rc, Th, up, kh, Ah, Eh, ap = Y(() => {
  Zw(), Ec(), Cc = class extends kt {
    constructor({ data: ne, params: oe, size: ae }) {
      super([`Data size of ${ae} bytes is too small for given parameters.`].join(`
`), { metaMessages: [`Params: (${xh(oe, { includeName: !0 })})`, `Data:   ${ne} (${ae} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingDataSizeTooSmallError" }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.data = ne, this.params = oe, this.size = ae;
    }
  }, Rh = class extends kt {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiDecodingZeroDataError" });
    }
  }, Oh = class extends kt {
    constructor({ docsPath: ne }) {
      super("Cannot extract event signature from empty topics.", { docsPath: ne }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureEmptyTopicsError" });
    }
  }, Rc = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded event signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiEventSignatureNotFoundError" });
    }
  }, Th = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Encoded function signature "${ne}" not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${ne}.`].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "AbiFunctionSignatureNotFoundError" });
    }
  }, up = class extends kt {
    constructor({ abiItem: ne, data: oe, params: ae, size: fe }) {
      super([`Data size of ${fe} bytes is too small for non-indexed event parameters.`].join(`
`), { metaMessages: [`Params: (${xh(ae, { includeName: !0 })})`, `Data:   ${oe} (${fe} bytes)`] }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogDataMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "data", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "params", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "size", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne, this.data = oe, this.params = ae, this.size = fe;
    }
  }, kh = class extends kt {
    constructor({ abiItem: ne, param: oe }) {
      super([`Expected a topic for indexed event parameter${oe.name ? ` "${oe.name}"` : ""} on event "${ip(ne, { includeName: !0 })}".`].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.abiItem = ne;
    }
  }, Ah = class extends kt {
    constructor(ne, { docsPath: oe }) {
      super([`Type "${ne}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), { docsPath: oe }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidAbiDecodingType" });
    }
  }, Eh = class extends kt {
    constructor(ne) {
      super([`"${ne}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidDefinitionTypeError" });
    }
  };
}), Ph, Mh, GA = Y(() => {
  Ec(), Ph = class extends kt {
    constructor({ offset: ne, position: oe, size: ae }) {
      super(`Slice ${oe === "start" ? "starting" : "ending"} at offset "${ne}" is out-of-bounds (size: ${ae}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SliceOffsetOutOfBoundsError" });
    }
  }, Mh = class extends kt {
    constructor({ size: ne, targetSize: oe, type: ae }) {
      super(`${ae.charAt(0).toUpperCase()}${ae.slice(1).toLowerCase()} size (${ne}) exceeds padding size (${oe}).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeExceedsPaddingSizeError" });
    }
  };
});
function fs(ne, { dir: oe, size: ae = 32 } = {}) {
  return typeof ne == "string" ? jge(ne, { dir: oe, size: ae }) : Uge(ne, { dir: oe, size: ae });
}
function jge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  let fe = ne.replace("0x", "");
  if (fe.length > ae * 2)
    throw new Mh({ size: Math.ceil(fe.length / 2), targetSize: ae, type: "hex" });
  return `0x${fe[oe === "right" ? "padEnd" : "padStart"](ae * 2, "0")}`;
}
function Uge(ne, { dir: oe, size: ae = 32 } = {}) {
  if (ae === null)
    return ne;
  if (ne.length > ae)
    throw new Mh({ size: ne.length, targetSize: ae, type: "bytes" });
  let fe = new Uint8Array(ae);
  for (let ye = 0; ye < ae; ye++) {
    let ge = oe === "right";
    fe[ge ? ye : ae - ye - 1] = ne[ge ? ye : ne.length - ye - 1];
  }
  return fe;
}
var QA = Y(() => {
  GA();
}), ex, tx, rx, nx = Y(() => {
  Ec(), ex = class extends kt {
    constructor({ max: ne, min: oe, signed: ae, size: fe, value: ye }) {
      super(`Number "${ye}" is not in safe ${fe ? `${fe * 8}-bit ${ae ? "signed" : "unsigned"} ` : ""}integer range ${ne ? `(${oe} to ${ne})` : `(above ${oe})`}`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "IntegerOutOfRangeError" });
    }
  }, tx = class extends kt {
    constructor(ne) {
      super(`Bytes value "${ne}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "InvalidBytesBooleanError" });
    }
  }, rx = class extends kt {
    constructor({ givenSize: ne, maxSize: oe }) {
      super(`Size cannot exceed ${oe} bytes. Given size: ${ne} bytes.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "SizeOverflowError" });
    }
  };
});
function Dh(ne, { dir: oe = "left" } = {}) {
  let ae = typeof ne == "string" ? ne.replace("0x", "") : ne, fe = 0;
  for (let ye = 0; ye < ae.length - 1 && ae[oe === "left" ? ye : ae.length - ye - 1].toString() === "0"; ye++)
    fe++;
  return ae = oe === "left" ? ae.slice(fe) : ae.slice(0, ae.length - fe), typeof ne == "string" ? (ae.length === 1 && oe === "right" && (ae = `${ae}0`), `0x${ae.length % 2 === 1 ? `0${ae}` : ae}`) : ae;
}
var KA = Y(() => {
});
function Xi(ne, { size: oe }) {
  if (oi(ne) > oe)
    throw new rx({ givenSize: oi(ne), maxSize: oe });
}
function XA(ne, oe = {}) {
  let { signed: ae } = oe;
  oe.size && Xi(ne, { size: oe.size });
  let fe = BigInt(ne);
  if (!ae)
    return fe;
  let ye = (ne.length - 2) / 2, ge = (1n << BigInt(ye) * 8n - 1n) - 1n;
  return fe <= ge ? fe : fe - BigInt(`0x${"f".padStart(ye * 2, "f")}`) - 1n;
}
function Nh(ne, oe = {}) {
  return Number(XA(ne, oe));
}
var Lh = Y(() => {
  nx(), Ch();
});
function F4(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? xt(ne, oe) : typeof ne == "string" ? Ige(ne, oe) : typeof ne == "boolean" ? zge(ne, oe) : _a(ne, oe);
}
function zge(ne, oe = {}) {
  let ae = `0x${Number(ne)}`;
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function _a(ne, oe = {}) {
  let ae = "";
  for (let ye = 0; ye < ne.length; ye++)
    ae += Fge[ne[ye]];
  let fe = `0x${ae}`;
  return typeof oe.size == "number" ? (Xi(fe, { size: oe.size }), fs(fe, { dir: "right", size: oe.size })) : fe;
}
function xt(ne, oe = {}) {
  let { signed: ae, size: fe } = oe, ye = BigInt(ne), ge;
  fe ? ae ? ge = (1n << BigInt(fe) * 8n - 1n) - 1n : ge = 2n ** (BigInt(fe) * 8n) - 1n : typeof ne == "number" && (ge = BigInt(Number.MAX_SAFE_INTEGER));
  let we = typeof ge == "bigint" && ae ? -ge - 1n : 0;
  if (ge && ye > ge || ye < we) {
    let Se = typeof ne == "bigint" ? "n" : "";
    throw new ex({ max: ge ? `${ge}${Se}` : void 0, min: `${we}${Se}`, signed: ae, size: fe, value: `${ne}${Se}` });
  }
  let _e = `0x${(ae && ye < 0 ? (1n << BigInt(fe * 8)) + BigInt(ye) : ye).toString(16)}`;
  return fe ? fs(_e, { size: fe }) : _e;
}
function Ige(ne, oe = {}) {
  let ae = qge.encode(ne);
  return _a(ae, oe);
}
var Fge, qge, ui = Y(() => {
  nx(), QA(), Lh(), Fge = Array.from({ length: 256 }, (ne, oe) => oe.toString(16).padStart(2, "0")), qge = new TextEncoder();
});
function ix(ne, oe = {}) {
  return typeof ne == "number" || typeof ne == "bigint" ? Vge(ne, oe) : typeof ne == "boolean" ? Hge(ne, oe) : eo(ne) ? ax(ne, oe) : JA(ne, oe);
}
function Hge(ne, oe = {}) {
  let ae = new Uint8Array(1);
  return ae[0] = Number(ne), typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { size: oe.size })) : ae;
}
function z4(ne) {
  if (ne >= Du.zero && ne <= Du.nine)
    return ne - Du.zero;
  if (ne >= Du.A && ne <= Du.F)
    return ne - (Du.A - 10);
  if (ne >= Du.a && ne <= Du.f)
    return ne - (Du.a - 10);
}
function ax(ne, oe = {}) {
  let ae = ne;
  oe.size && (Xi(ae, { size: oe.size }), ae = fs(ae, { dir: "right", size: oe.size }));
  let fe = ae.slice(2);
  fe.length % 2 && (fe = `0${fe}`);
  let ye = fe.length / 2, ge = new Uint8Array(ye);
  for (let we = 0, _e = 0; we < ye; we++) {
    let Se = z4(fe.charCodeAt(_e++)), Ie = z4(fe.charCodeAt(_e++));
    if (Se === void 0 || Ie === void 0)
      throw new kt(`Invalid byte sequence ("${fe[_e - 2]}${fe[_e - 1]}" in "${fe}").`);
    ge[we] = Se * 16 + Ie;
  }
  return ge;
}
function Vge(ne, oe) {
  let ae = xt(ne, oe);
  return ax(ae);
}
function JA(ne, oe = {}) {
  let ae = Bge.encode(ne);
  return typeof oe.size == "number" ? (Xi(ae, { size: oe.size }), fs(ae, { dir: "right", size: oe.size })) : ae;
}
var Bge, Du, jh = Y(() => {
  Ec(), op(), QA(), Lh(), ui(), Bge = new TextEncoder(), Du = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
});
function ZA(ne) {
  if (!Number.isSafeInteger(ne) || ne < 0)
    throw new Error(`Wrong positive integer: ${ne}`);
}
function eP(ne, ...oe) {
  if (!(ne instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (oe.length > 0 && !oe.includes(ne.length))
    throw new Error(`Expected Uint8Array of length ${oe}, not of length=${ne.length}`);
}
function tP(ne, oe = !0) {
  if (ne.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (oe && ne.finished)
    throw new Error("Hash#digest() has already been called");
}
function q4(ne, oe) {
  eP(ne);
  let ae = oe.outputLen;
  if (ne.length < ae)
    throw new Error(`digestInto() expects output buffer of length at least ${ae}`);
}
var I4 = Y(() => {
});
function $ge(ne, oe = !1) {
  return oe ? { h: Number(ne & ox), l: Number(ne >> B4 & ox) } : { h: Number(ne >> B4 & ox) | 0, l: Number(ne & ox) | 0 };
}
function H4(ne, oe = !1) {
  let ae = new Uint32Array(ne.length), fe = new Uint32Array(ne.length);
  for (let ye = 0; ye < ne.length; ye++) {
    let { h: ge, l: we } = $ge(ne[ye], oe);
    [ae[ye], fe[ye]] = [ge, we];
  }
  return [ae, fe];
}
var ox, B4, V4, $4, W4, Y4, G4 = Y(() => {
  ox = BigInt(4294967295), B4 = BigInt(32), V4 = (ne, oe, ae) => ne << ae | oe >>> 32 - ae, $4 = (ne, oe, ae) => oe << ae | ne >>> 32 - ae, W4 = (ne, oe, ae) => oe << ae - 32 | ne >>> 64 - ae, Y4 = (ne, oe, ae) => ne << ae - 32 | oe >>> 64 - ae;
});
function Gge(ne) {
  if (typeof ne != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ne}`);
  return new Uint8Array(new TextEncoder().encode(ne));
}
function lx(ne) {
  if (typeof ne == "string" && (ne = Gge(ne)), !Wge(ne))
    throw new Error(`expected Uint8Array, got ${typeof ne}`);
  return ne;
}
function K4(ne) {
  let oe = (fe) => ne().update(lx(fe)).digest(), ae = ne();
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = () => ne(), oe;
}
function X4(ne) {
  let oe = (fe, ye) => ne(ye).update(lx(fe)).digest(), ae = ne({});
  return oe.outputLen = ae.outputLen, oe.blockLen = ae.blockLen, oe.create = (fe) => ne(fe), oe;
}
var Wge, Q4, Yge, ux, J4 = Y(() => {
  if (Wge = (ne) => ne instanceof Uint8Array, Q4 = (ne) => new Uint32Array(ne.buffer, ne.byteOffset, Math.floor(ne.byteLength / 4)), Yge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !Yge)
    throw new Error("Non little-endian hardware is not supported");
  ux = class {
    clone() {
      return this._cloneInto();
    }
  };
});
function rbe(ne, oe = 24) {
  let ae = new Uint32Array(10);
  for (let fe = 24 - oe; fe < 24; fe++) {
    for (let we = 0; we < 10; we++)
      ae[we] = ne[we] ^ ne[we + 10] ^ ne[we + 20] ^ ne[we + 30] ^ ne[we + 40];
    for (let we = 0; we < 10; we += 2) {
      let _e = (we + 8) % 10, Se = (we + 2) % 10, Ie = ae[Se], $e = ae[Se + 1], Ne = Z4(Ie, $e, 1) ^ ae[_e], Me = eV(Ie, $e, 1) ^ ae[_e + 1];
      for (let Be = 0; Be < 50; Be += 10)
        ne[we + Be] ^= Ne, ne[we + Be + 1] ^= Me;
    }
    let ye = ne[2], ge = ne[3];
    for (let we = 0; we < 24; we++) {
      let _e = rV[we], Se = Z4(ye, ge, _e), Ie = eV(ye, ge, _e), $e = tV[we];
      ye = ne[$e], ge = ne[$e + 1], ne[$e] = Se, ne[$e + 1] = Ie;
    }
    for (let we = 0; we < 50; we += 10) {
      for (let _e = 0; _e < 10; _e++)
        ae[_e] = ne[we + _e];
      for (let _e = 0; _e < 10; _e++)
        ne[we + _e] ^= ~ae[(_e + 2) % 10] & ae[(_e + 4) % 10];
    }
    ne[0] ^= ebe[fe], ne[1] ^= tbe[fe];
  }
  ae.fill(0);
}
var tV, rV, nV, Qge, Uh, Kge, Xge, Jge, Zge, ebe, tbe, Z4, eV, lp, ds, iV, aV, oV = Y(() => {
  I4(), G4(), J4(), [tV, rV, nV] = [[], [], []], Qge = BigInt(0), Uh = BigInt(1), Kge = BigInt(2), Xge = BigInt(7), Jge = BigInt(256), Zge = BigInt(113);
  for (let ne = 0, oe = Uh, ae = 1, fe = 0; ne < 24; ne++) {
    [ae, fe] = [fe, (2 * ae + 3 * fe) % 5], tV.push(2 * (5 * fe + ae)), rV.push((ne + 1) * (ne + 2) / 2 % 64);
    let ye = Qge;
    for (let ge = 0; ge < 7; ge++)
      oe = (oe << Uh ^ (oe >> Xge) * Zge) % Jge, oe & Kge && (ye ^= Uh << (Uh << BigInt(ge)) - Uh);
    nV.push(ye);
  }
  [ebe, tbe] = H4(nV, !0), Z4 = (ne, oe, ae) => ae > 32 ? W4(ne, oe, ae) : V4(ne, oe, ae), eV = (ne, oe, ae) => ae > 32 ? Y4(ne, oe, ae) : $4(ne, oe, ae), lp = class extends ux {
    constructor(ne, oe, ae, fe = !1, ye = 24) {
      if (super(), this.blockLen = ne, this.suffix = oe, this.outputLen = ae, this.enableXOF = fe, this.rounds = ye, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ZA(ae), 0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = Q4(this.state);
    }
    keccak() {
      rbe(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
    }
    update(ne) {
      tP(this);
      let { blockLen: oe, state: ae } = this;
      ne = lx(ne);
      let fe = ne.length;
      for (let ye = 0; ye < fe; ) {
        let ge = Math.min(oe - this.pos, fe - ye);
        for (let we = 0; we < ge; we++)
          ae[this.pos++] ^= ne[ye++];
        this.pos === oe && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = !0;
      let { state: ne, suffix: oe, pos: ae, blockLen: fe } = this;
      ne[ae] ^= oe, oe & 128 && ae === fe - 1 && this.keccak(), ne[fe - 1] ^= 128, this.keccak();
    }
    writeInto(ne) {
      tP(this, !1), eP(ne), this.finish();
      let oe = this.state, { blockLen: ae } = this;
      for (let fe = 0, ye = ne.length; fe < ye; ) {
        this.posOut >= ae && this.keccak();
        let ge = Math.min(ae - this.posOut, ye - fe);
        ne.set(oe.subarray(this.posOut, this.posOut + ge), fe), this.posOut += ge, fe += ge;
      }
      return ne;
    }
    xofInto(ne) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(ne);
    }
    xof(ne) {
      return ZA(ne), this.xofInto(new Uint8Array(ne));
    }
    digestInto(ne) {
      if (q4(ne, this), this.finished)
        throw new Error("digest() was already called");
      return this.writeInto(ne), this.destroy(), ne;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = !0, this.state.fill(0);
    }
    _cloneInto(ne) {
      let { blockLen: oe, suffix: ae, outputLen: fe, rounds: ye, enableXOF: ge } = this;
      return ne || (ne = new lp(oe, ae, fe, ge, ye)), ne.state32.set(this.state32), ne.pos = this.pos, ne.posOut = this.posOut, ne.finished = this.finished, ne.rounds = ye, ne.suffix = ae, ne.outputLen = fe, ne.enableXOF = ge, ne.destroyed = this.destroyed, ne;
    }
  }, ds = (ne, oe, ae) => K4(() => new lp(oe, ne, ae)), ds(6, 144, 224 / 8), ds(6, 136, 256 / 8), ds(6, 104, 384 / 8), ds(6, 72, 512 / 8), ds(1, 144, 224 / 8), iV = ds(1, 136, 256 / 8), ds(1, 104, 384 / 8), ds(1, 72, 512 / 8), aV = (ne, oe, ae) => X4((fe = {}) => new lp(oe, ne, fe.dkLen === void 0 ? ae : fe.dkLen, !0)), aV(31, 168, 128 / 8), aV(31, 136, 256 / 8);
});
function sx(ne, oe) {
  let ae = oe || "hex", fe = iV(eo(ne, { strict: !1 }) ? ix(ne) : ne);
  return ae === "bytes" ? fe : F4(fe);
}
var rP = Y(() => {
  oV(), op(), jh(), ui();
});
function uV(ne) {
  return nbe(ne);
}
var nbe, lV = Y(() => {
  jh(), rP(), nbe = (ne) => sx(ix(ne));
});
function sV(ne) {
  let oe = !0, ae = "", fe = 0, ye = "", ge = !1;
  for (let we = 0; we < ne.length; we++) {
    let _e = ne[we];
    if (["(", ")", ","].includes(_e) && (oe = !0), _e === "(" && fe++, _e === ")" && fe--, !!oe) {
      if (fe === 0) {
        if (_e === " " && ["event", "function", ""].includes(ye))
          ye = "";
        else if (ye += _e, _e === ")") {
          ge = !0;
          break;
        }
        continue;
      }
      if (_e === " ") {
        ne[we - 1] !== "," && ae !== "," && ae !== ",(" && (ae = "", oe = !1);
        continue;
      }
      ye += _e, ae += _e;
    }
  }
  if (!ge)
    throw new kt("Unable to normalize signature.");
  return ye;
}
var cV = Y(() => {
  Ec();
}), fV, dV = Y(() => {
  M4(), cV(), fV = (ne) => {
    let oe = (() => typeof ne == "string" ? ne : YA(ne))();
    return sV(oe);
  };
});
function cx(ne) {
  return uV(fV(ne));
}
var nP = Y(() => {
  lV(), dV();
}), pV, vV = Y(() => {
  nP(), pV = cx;
});
function mV(ne, oe) {
  let ae = oe ? `${oe}${ne.toLowerCase()}` : ne.substring(2).toLowerCase(), fe = sx(JA(ae), "bytes"), ye = (oe ? ae.substring(`${oe}0x`.length) : ae).split("");
  for (let ge = 0; ge < 40; ge += 2)
    fe[ge >> 1] >> 4 >= 8 && ye[ge] && (ye[ge] = ye[ge].toUpperCase()), (fe[ge >> 1] & 15) >= 8 && ye[ge + 1] && (ye[ge + 1] = ye[ge + 1].toUpperCase());
  return `0x${ye.join("")}`;
}
var hV = Y(() => {
  jh(), rP();
});
function Fh(ne, oe, ae, { strict: fe } = {}) {
  return eo(ne, { strict: !1 }) ? ibe(ne, oe, ae, { strict: fe }) : iP(ne, oe, ae, { strict: fe });
}
function yV(ne, oe) {
  if (typeof oe == "number" && oe > 0 && oe > oi(ne) - 1)
    throw new Ph({ offset: oe, position: "start", size: oi(ne) });
}
function gV(ne, oe, ae) {
  if (typeof oe == "number" && typeof ae == "number" && oi(ne) !== ae - oe)
    throw new Ph({ offset: ae, position: "end", size: oi(ne) });
}
function iP(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = ne.slice(oe, ae);
  return fe && gV(ye, oe, ae), ye;
}
function ibe(ne, oe, ae, { strict: fe } = {}) {
  yV(ne, oe);
  let ye = `0x${ne.replace("0x", "").slice((oe ?? 0) * 2, (ae ?? ne.length) * 2)}`;
  return fe && gV(ye, oe, ae), ye;
}
var fx = Y(() => {
  GA(), op(), Ch();
});
function aP(ne) {
  let oe = ne.match(/^(.*)\[(\d+)?\]$/);
  return oe ? [oe[2] ? Number(oe[2]) : null, oe[1]] : void 0;
}
var bV = Y(() => {
}), SV, _V = Y(() => {
  fx(), nP(), SV = (ne) => Fh(cx(ne), 0, 4);
}), zh, sp, dx, oP = Y(() => {
  Ec(), zh = class extends kt {
    constructor({ offset: ne }) {
      super(`Offset \`${ne}\` cannot be negative.`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "NegativeOffsetError" });
    }
  }, sp = class extends kt {
    constructor({ length: ne, position: oe }) {
      super(`Position \`${oe}\` is out of bounds (\`0 < position < ${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "PositionOutOfBoundsError" });
    }
  }, dx = class extends kt {
    constructor({ count: ne, limit: oe }) {
      super(`Recursive read limit of \`${oe}\` exceeded (recursive read count: \`${ne}\`).`), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: "RecursiveReadLimitExceededError" });
    }
  };
});
function wV(ne, { recursiveReadLimit: oe = 8192 } = {}) {
  let ae = Object.create(abe);
  return ae.bytes = ne, ae.dataView = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), ae.positionReadCount = /* @__PURE__ */ new Map(), ae.recursiveReadLimit = oe, ae;
}
var abe, xV = Y(() => {
  oP(), abe = { bytes: new Uint8Array(), dataView: new DataView(new ArrayBuffer(0)), position: 0, positionReadCount: /* @__PURE__ */ new Map(), recursiveReadCount: 0, recursiveReadLimit: 1 / 0, assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new dx({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit });
  }, assertPosition(ne) {
    if (ne < 0 || ne > this.bytes.length - 1)
      throw new sp({ length: this.bytes.length, position: ne });
  }, decrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position - ne;
    this.assertPosition(oe), this.position = oe;
  }, getReadCount(ne) {
    return this.positionReadCount.get(ne || this.position) || 0;
  }, incrementPosition(ne) {
    if (ne < 0)
      throw new zh({ offset: ne });
    let oe = this.position + ne;
    this.assertPosition(oe), this.position = oe;
  }, inspectByte(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectBytes(ne, oe) {
    let ae = oe ?? this.position;
    return this.assertPosition(ae + ne - 1), this.bytes.subarray(ae, ae + ne);
  }, inspectUint8(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe), this.bytes[oe];
  }, inspectUint16(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 1), this.dataView.getUint16(oe);
  }, inspectUint24(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 2), (this.dataView.getUint16(oe) << 8) + this.dataView.getUint8(oe + 2);
  }, inspectUint32(ne) {
    let oe = ne ?? this.position;
    return this.assertPosition(oe + 3), this.dataView.getUint32(oe);
  }, pushByte(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushBytes(ne) {
    this.assertPosition(this.position + ne.length - 1), this.bytes.set(ne, this.position), this.position += ne.length;
  }, pushUint8(ne) {
    this.assertPosition(this.position), this.bytes[this.position] = ne, this.position++;
  }, pushUint16(ne) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, ne), this.position += 2;
  }, pushUint24(ne) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, ne >> 8), this.dataView.setUint8(this.position + 2, ne & 255), this.position += 3;
  }, pushUint32(ne) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, ne), this.position += 4;
  }, readByte() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectByte();
    return this.position++, ne;
  }, readBytes(ne, oe) {
    this.assertReadLimit(), this._touch();
    let ae = this.inspectBytes(ne);
    return this.position += oe ?? ne, ae;
  }, readUint8() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint8();
    return this.position += 1, ne;
  }, readUint16() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint16();
    return this.position += 2, ne;
  }, readUint24() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint24();
    return this.position += 3, ne;
  }, readUint32() {
    this.assertReadLimit(), this._touch();
    let ne = this.inspectUint32();
    return this.position += 4, ne;
  }, get remaining() {
    return this.bytes.length - this.position;
  }, setPosition(ne) {
    let oe = this.position;
    return this.assertPosition(ne), this.position = ne, () => this.position = oe;
  }, _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    let ne = this.getReadCount();
    this.positionReadCount.set(this.position, ne + 1), ne > 0 && this.recursiveReadCount++;
  } };
});
function EV(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return XA(ae, oe);
}
function CV(ne, oe = {}) {
  let ae = ne;
  if (typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae)), ae.length > 1 || ae[0] > 1)
    throw new tx(ae);
  return !!ae[0];
}
function zo(ne, oe = {}) {
  typeof oe.size < "u" && Xi(ne, { size: oe.size });
  let ae = _a(ne, oe);
  return Nh(ae, oe);
}
function RV(ne, oe = {}) {
  let ae = ne;
  return typeof oe.size < "u" && (Xi(ae, { size: oe.size }), ae = Dh(ae, { dir: "right" })), new TextDecoder().decode(ae);
}
var OV = Y(() => {
  nx(), KA(), Lh(), ui();
});
function Ih(ne, oe) {
  let ae = typeof oe == "string" ? ax(oe) : oe, fe = wV(ae);
  if (oi(ae) === 0 && ne.length > 0)
    throw new Rh();
  if (oi(oe) && oi(oe) < 32)
    throw new Cc({ data: typeof oe == "string" ? oe : _a(oe), params: ne, size: oi(oe) });
  let ye = 0, ge = [];
  for (let we = 0; we < ne.length; ++we) {
    let _e = ne[we];
    fe.setPosition(ye);
    let [Se, Ie] = cp(fe, _e, { staticPosition: 0 });
    ye += Ie, ge.push(Se);
  }
  return ge;
}
function cp(ne, oe, { staticPosition: ae }) {
  let fe = aP(oe.type);
  if (fe) {
    let [ye, ge] = fe;
    return ube(ne, { ...oe, type: ge }, { length: ye, staticPosition: ae });
  }
  if (oe.type === "tuple")
    return fbe(ne, oe, { staticPosition: ae });
  if (oe.type === "address")
    return obe(ne);
  if (oe.type === "bool")
    return lbe(ne);
  if (oe.type.startsWith("bytes"))
    return sbe(ne, oe, { staticPosition: ae });
  if (oe.type.startsWith("uint") || oe.type.startsWith("int"))
    return cbe(ne, oe);
  if (oe.type === "string")
    return dbe(ne, { staticPosition: ae });
  throw new Ah(oe.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
function obe(ne) {
  let oe = ne.readBytes(32);
  return [mV(_a(iP(oe, -20))), 32];
}
function ube(ne, oe, { length: ae, staticPosition: fe }) {
  if (!ae) {
    let we = zo(ne.readBytes(uP)), _e = fe + we, Se = _e + TV;
    ne.setPosition(_e);
    let Ie = zo(ne.readBytes(TV)), $e = qh(oe), Ne = 0, Me = [];
    for (let Be = 0; Be < Ie; ++Be) {
      ne.setPosition(Se + ($e ? Be * 32 : Ne));
      let [ze, He] = cp(ne, oe, { staticPosition: Se });
      Ne += He, Me.push(ze);
    }
    return ne.setPosition(fe + 32), [Me, 32];
  }
  if (qh(oe)) {
    let we = zo(ne.readBytes(uP)), _e = fe + we, Se = [];
    for (let Ie = 0; Ie < ae; ++Ie) {
      ne.setPosition(_e + Ie * 32);
      let [$e] = cp(ne, oe, { staticPosition: _e });
      Se.push($e);
    }
    return ne.setPosition(fe + 32), [Se, 32];
  }
  let ye = 0, ge = [];
  for (let we = 0; we < ae; ++we) {
    let [_e, Se] = cp(ne, oe, { staticPosition: fe + ye });
    ye += Se, ge.push(_e);
  }
  return [ge, ye];
}
function lbe(ne) {
  return [CV(ne.readBytes(32), { size: 32 }), 32];
}
function sbe(ne, oe, { staticPosition: ae }) {
  let [fe, ye] = oe.type.split("bytes");
  if (!ye) {
    let ge = zo(ne.readBytes(32));
    ne.setPosition(ae + ge);
    let we = zo(ne.readBytes(32));
    if (we === 0)
      return ne.setPosition(ae + 32), ["0x", 32];
    let _e = ne.readBytes(we);
    return ne.setPosition(ae + 32), [_a(_e), 32];
  }
  return [_a(ne.readBytes(parseInt(ye), 32)), 32];
}
function cbe(ne, oe) {
  let ae = oe.type.startsWith("int"), fe = parseInt(oe.type.split("int")[1] || "256"), ye = ne.readBytes(32);
  return [fe > 48 ? EV(ye, { signed: ae }) : zo(ye, { signed: ae }), 32];
}
function fbe(ne, oe, { staticPosition: ae }) {
  let fe = oe.components.length === 0 || oe.components.some(({ name: we }) => !we), ye = fe ? [] : {}, ge = 0;
  if (qh(oe)) {
    let we = zo(ne.readBytes(uP)), _e = ae + we;
    for (let Se = 0; Se < oe.components.length; ++Se) {
      let Ie = oe.components[Se];
      ne.setPosition(_e + ge);
      let [$e, Ne] = cp(ne, Ie, { staticPosition: _e });
      ge += Ne, ye[fe ? Se : Ie == null ? void 0 : Ie.name] = $e;
    }
    return ne.setPosition(ae + 32), [ye, 32];
  }
  for (let we = 0; we < oe.components.length; ++we) {
    let _e = oe.components[we], [Se, Ie] = cp(ne, _e, { staticPosition: ae });
    ye[fe ? we : _e == null ? void 0 : _e.name] = Se, ge += Ie;
  }
  return [ye, ge];
}
function dbe(ne, { staticPosition: oe }) {
  let ae = zo(ne.readBytes(32)), fe = oe + ae;
  ne.setPosition(fe);
  let ye = zo(ne.readBytes(32));
  if (ye === 0)
    return ne.setPosition(oe + 32), ["", 32];
  let ge = ne.readBytes(ye, 32), we = RV(Dh(ge));
  return ne.setPosition(oe + 32), [we, 32];
}
function qh(ne) {
  var fe;
  let { type: oe } = ne;
  if (oe === "string" || oe === "bytes" || oe.endsWith("[]"))
    return !0;
  if (oe === "tuple")
    return (fe = ne.components) == null ? void 0 : fe.some(qh);
  let ae = aP(ne.type);
  return !!(ae && qh({ ...ne, type: ae[1] }));
}
var TV, uP, lP = Y(() => {
  ap(), hV(), xV(), Ch(), fx(), KA(), OV(), jh(), ui(), bV(), TV = 32, uP = 32;
}), kV, AV = Y(() => {
  kV = { gwei: 9, wei: 18 };
});
function sP(ne, oe) {
  let ae = ne.toString(), fe = ae.startsWith("-");
  fe && (ae = ae.slice(1)), ae = ae.padStart(oe, "0");
  let [ye, ge] = [ae.slice(0, ae.length - oe), ae.slice(ae.length - oe)];
  return ge = ge.replace(/(0+)$/, ""), `${fe ? "-" : ""}${ye || "0"}${ge ? `.${ge}` : ""}`;
}
var PV = Y(() => {
});
function MV(ne, { format: oe }) {
  if (!oe)
    return {};
  let ae = {};
  function fe(ge) {
    let we = Object.keys(ge);
    for (let _e of we)
      _e in ne && (ae[_e] = ne[_e]), ge[_e] && typeof ge[_e] == "object" && !Array.isArray(ge[_e]) && fe(ge[_e]);
  }
  let ye = oe(ne || {});
  return fe(ye), ae;
}
var DV = Y(() => {
});
function NV(ne) {
  let oe = {};
  return typeof ne.accessList < "u" && (oe.accessList = ne.accessList), typeof ne.blobVersionedHashes < "u" && (oe.blobVersionedHashes = ne.blobVersionedHashes), typeof ne.blobs < "u" && (typeof ne.blobs[0] != "string" ? oe.blobs = ne.blobs.map((ae) => _a(ae)) : oe.blobs = ne.blobs), typeof ne.data < "u" && (oe.data = ne.data), typeof ne.from < "u" && (oe.from = ne.from), typeof ne.gas < "u" && (oe.gas = xt(ne.gas)), typeof ne.gasPrice < "u" && (oe.gasPrice = xt(ne.gasPrice)), typeof ne.maxFeePerBlobGas < "u" && (oe.maxFeePerBlobGas = xt(ne.maxFeePerBlobGas)), typeof ne.maxFeePerGas < "u" && (oe.maxFeePerGas = xt(ne.maxFeePerGas)), typeof ne.maxPriorityFeePerGas < "u" && (oe.maxPriorityFeePerGas = xt(ne.maxPriorityFeePerGas)), typeof ne.nonce < "u" && (oe.nonce = xt(ne.nonce)), typeof ne.to < "u" && (oe.to = ne.to), typeof ne.type < "u" && (oe.type = pbe[ne.type]), typeof ne.value < "u" && (oe.value = xt(ne.value)), oe;
}
var pbe, LV = Y(() => {
  ui(), pbe = { legacy: "0x0", eip2930: "0x1", eip1559: "0x2", eip4844: "0x3" };
});
function cP(ne) {
  let { abi: oe, data: ae, strict: fe, topics: ye } = ne, ge = fe ?? !0, [we, ..._e] = ye;
  if (!we)
    throw new Oh({ docsPath: jV });
  let Se = oe.find((He) => He.type === "event" && we === pV(ip(He)));
  if (!(Se && "name" in Se) || Se.type !== "event")
    throw new Rc(we, { docsPath: jV });
  let { name: Ie, inputs: $e } = Se, Ne = $e == null ? void 0 : $e.some((He) => !("name" in He && He.name)), Me = Ne ? [] : {}, Be = $e.filter((He) => "indexed" in He && He.indexed);
  for (let He = 0; He < Be.length; He++) {
    let Ze = Be[He], qe = _e[He];
    if (!qe)
      throw new kh({ abiItem: Se, param: Ze });
    Me[Ne ? He : Ze.name || He] = vbe({ param: Ze, value: qe });
  }
  let ze = $e.filter((He) => !("indexed" in He && He.indexed));
  if (ze.length > 0) {
    if (ae && ae !== "0x")
      try {
        let He = Ih(ze, ae);
        if (He)
          if (Ne)
            Me = [...Me, ...He];
          else
            for (let Ze = 0; Ze < ze.length; Ze++)
              Me[ze[Ze].name] = He[Ze];
      } catch (He) {
        if (ge)
          throw He instanceof Cc || He instanceof sp ? new up({ abiItem: Se, data: ae, params: ze, size: oi(ae) }) : He;
      }
    else if (ge)
      throw new up({ abiItem: Se, data: "0x", params: ze, size: 0 });
  }
  return { eventName: Ie, args: Object.values(Me).length > 0 ? Me : void 0 };
}
function vbe({ param: ne, value: oe }) {
  return ne.type === "string" || ne.type === "bytes" || ne.type === "tuple" || ne.type.match(/^(.*)\[(\d+)?\]$/) ? oe : (Ih([ne], oe) || [])[0];
}
var jV, UV = Y(() => {
  ap(), Ch(), vV(), oP(), lP(), Zw(), jV = "/docs/contract/decodeEventLog";
});
function Bh(ne) {
  let { abi: oe, data: ae } = ne, fe = Fh(ae, 0, 4), ye = oe.find((ge) => ge.type === "function" && fe === SV(ip(ge)));
  if (!ye)
    throw new Th(fe, { docsPath: "/docs/contract/decodeFunctionData" });
  return { functionName: ye.name, args: "inputs" in ye && ye.inputs && ye.inputs.length > 0 ? Ih(ye.inputs, Fh(ae, 4)) : void 0 };
}
var FV = Y(() => {
  ap(), fx(), _V(), lP(), Zw();
});
function zV(ne, oe) {
  let [ae, fe = "0"] = ne.split("."), ye = ae.startsWith("-");
  if (ye && (ae = ae.slice(1)), fe = fe.replace(/(0+)$/, ""), oe === 0)
    Math.round(+`.${fe}`) === 1 && (ae = `${BigInt(ae) + 1n}`), fe = "";
  else if (fe.length > oe) {
    let [ge, we, _e] = [fe.slice(0, oe - 1), fe.slice(oe - 1, oe), fe.slice(oe)], Se = Math.round(+`${we}.${_e}`);
    Se > 9 ? fe = `${BigInt(ge) + BigInt(1)}0`.padStart(ge.length + 1, "0") : fe = `${ge}${Se}`, fe.length > oe && (fe = fe.slice(1), ae = `${BigInt(ae) + 1n}`), fe = fe.slice(0, oe);
  } else
    fe = fe.padEnd(oe, "0");
  return BigInt(`${ye ? "-" : ""}${ae}${fe}`);
}
var qV = Y(() => {
});
function fP(ne, oe = "wei") {
  return zV(ne, kV[oe]);
}
var IV = Y(() => {
  AV(), qV();
});
async function BV(ne, { hash: oe }) {
  await ne.request({ method: `${ne.mode}_dropTransaction`, params: [oe] });
}
var HV = Y(() => {
});
async function VV(ne) {
  return ne.request({ method: `${ne.mode}_dumpState` });
}
var $V = Y(() => {
});
async function WV(ne) {
  return ne.mode === "ganache" ? await ne.request({ method: "eth_mining" }) : await ne.request({ method: `${ne.mode}_getAutomine` });
}
var YV = Y(() => {
});
async function GV(ne) {
  return await ne.request({ method: "txpool_content" });
}
var QV = Y(() => {
});
async function KV(ne) {
  let { pending: oe, queued: ae } = await ne.request({ method: "txpool_status" });
  return { pending: Nh(oe), queued: Nh(ae) };
}
var XV = Y(() => {
  Lh();
});
async function JV(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_impersonateAccount`, params: [oe] });
}
var ZV = Y(() => {
});
async function e5(ne, { seconds: oe }) {
  return await ne.request({ method: "evm_increaseTime", params: [xt(oe)] });
}
var t5 = Y(() => {
  ui();
});
async function r5(ne) {
  return await ne.request({ method: "txpool_inspect" });
}
var n5 = Y(() => {
});
async function i5(ne, { state: oe }) {
  await ne.request({ method: `${ne.mode}_loadState`, params: [oe] });
}
var a5 = Y(() => {
});
async function o5(ne, { blocks: oe, interval: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_mine", params: [{ blocks: xt(oe) }] }) : await ne.request({ method: `${ne.mode}_mine`, params: [xt(oe), xt(ae || 0)] });
}
var u5 = Y(() => {
  ui();
});
async function l5(ne) {
  await ne.request({ method: `${ne.mode}_removeBlockTimestampInterval` });
}
var s5 = Y(() => {
});
async function c5(ne, { blockNumber: oe, jsonRpcUrl: ae } = {}) {
  await ne.request({ method: `${ne.mode}_reset`, params: [{ forking: { blockNumber: Number(oe), jsonRpcUrl: ae } }] });
}
var f5 = Y(() => {
});
async function d5(ne, { id: oe }) {
  await ne.request({ method: "evm_revert", params: [oe] });
}
var p5 = Y(() => {
});
async function v5(ne, oe) {
  var He, Ze, qe;
  let { accessList: ae, data: fe, from: ye, gas: ge, gasPrice: we, maxFeePerGas: _e, maxPriorityFeePerGas: Se, nonce: Ie, to: $e, value: Ne, ...Me } = oe, Be = (qe = (Ze = (He = ne.chain) == null ? void 0 : He.formatters) == null ? void 0 : Ze.transactionRequest) == null ? void 0 : qe.format, ze = (Be || NV)({ ...MV(Me, { format: Be }), accessList: ae, data: fe, from: ye, gas: ge, gasPrice: we, maxFeePerGas: _e, maxPriorityFeePerGas: Se, nonce: Ie, to: $e, value: Ne });
  return await ne.request({ method: "eth_sendUnsignedTransaction", params: [ze] });
}
var m5 = Y(() => {
  DV(), LV();
});
async function h5(ne, oe) {
  ne.mode === "ganache" ? oe ? await ne.request({ method: "miner_start" }) : await ne.request({ method: "miner_stop" }) : await ne.request({ method: "evm_setAutomine", params: [oe] });
}
var y5 = Y(() => {
});
async function g5(ne, { address: oe, value: ae }) {
  ne.mode === "ganache" ? await ne.request({ method: "evm_setAccountBalance", params: [oe, xt(ae)] }) : await ne.request({ method: `${ne.mode}_setBalance`, params: [oe, xt(ae)] });
}
var b5 = Y(() => {
  ui();
});
async function S5(ne, { gasLimit: oe }) {
  await ne.request({ method: "evm_setBlockGasLimit", params: [xt(oe)] });
}
var _5 = Y(() => {
  ui();
});
async function w5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: `${ne.mode}_setBlockTimestampInterval`, params: [ae] });
}
var x5 = Y(() => {
});
async function E5(ne, { address: oe, bytecode: ae }) {
  await ne.request({ method: `${ne.mode}_setCode`, params: [oe, ae] });
}
var C5 = Y(() => {
});
async function R5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_setCoinbase`, params: [oe] });
}
var O5 = Y(() => {
});
async function T5(ne, { interval: oe }) {
  let ae = (() => ne.mode === "hardhat" ? oe * 1e3 : oe)();
  await ne.request({ method: "evm_setIntervalMining", params: [ae] });
}
var k5 = Y(() => {
});
async function A5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setLoggingEnabled`, params: [oe] });
}
var P5 = Y(() => {
});
async function M5(ne, { gasPrice: oe }) {
  await ne.request({ method: `${ne.mode}_setMinGasPrice`, params: [xt(oe)] });
}
var D5 = Y(() => {
  ui();
});
async function N5(ne, { baseFeePerGas: oe }) {
  await ne.request({ method: `${ne.mode}_setNextBlockBaseFeePerGas`, params: [xt(oe)] });
}
var L5 = Y(() => {
  ui();
});
async function j5(ne, { timestamp: oe }) {
  await ne.request({ method: "evm_setNextBlockTimestamp", params: [xt(oe)] });
}
var U5 = Y(() => {
  ui();
});
async function F5(ne, { address: oe, nonce: ae }) {
  await ne.request({ method: `${ne.mode}_setNonce`, params: [oe, xt(ae)] });
}
var z5 = Y(() => {
  ui();
});
async function q5(ne, oe) {
  await ne.request({ method: `${ne.mode}_setRpcUrl`, params: [oe] });
}
var I5 = Y(() => {
});
async function B5(ne, { address: oe, index: ae, value: fe }) {
  await ne.request({ method: `${ne.mode}_setStorageAt`, params: [oe, typeof ae == "number" ? xt(ae) : ae, fe] });
}
var H5 = Y(() => {
  ui();
});
async function V5(ne) {
  return await ne.request({ method: "evm_snapshot" });
}
var $5 = Y(() => {
});
async function W5(ne, { address: oe }) {
  await ne.request({ method: `${ne.mode}_stopImpersonatingAccount`, params: [oe] });
}
var Y5 = Y(() => {
});
function dP({ mode: ne }) {
  return (oe) => {
    let ae = oe.extend(() => ({ mode: ne }));
    return { dropTransaction: (fe) => BV(ae, fe), dumpState: () => VV(ae), getAutomine: () => WV(ae), getTxpoolContent: () => GV(ae), getTxpoolStatus: () => KV(ae), impersonateAccount: (fe) => JV(ae, fe), increaseTime: (fe) => e5(ae, fe), inspectTxpool: () => r5(ae), loadState: (fe) => i5(ae, fe), mine: (fe) => o5(ae, fe), removeBlockTimestampInterval: () => l5(ae), reset: (fe) => c5(ae, fe), revert: (fe) => d5(ae, fe), sendUnsignedTransaction: (fe) => v5(ae, fe), setAutomine: (fe) => h5(ae, fe), setBalance: (fe) => g5(ae, fe), setBlockGasLimit: (fe) => S5(ae, fe), setBlockTimestampInterval: (fe) => w5(ae, fe), setCode: (fe) => E5(ae, fe), setCoinbase: (fe) => R5(ae, fe), setIntervalMining: (fe) => T5(ae, fe), setLoggingEnabled: (fe) => A5(ae, fe), setMinGasPrice: (fe) => M5(ae, fe), setNextBlockBaseFeePerGas: (fe) => N5(ae, fe), setNextBlockTimestamp: (fe) => j5(ae, fe), setNonce: (fe) => F5(ae, fe), setRpcUrl: (fe) => q5(ae, fe), setStorageAt: (fe) => B5(ae, fe), snapshot: () => V5(ae), stopImpersonatingAccount: (fe) => W5(ae, fe) };
  };
}
var G5 = Y(() => {
  HV(), $V(), YV(), QV(), XV(), ZV(), t5(), n5(), a5(), u5(), s5(), f5(), p5(), m5(), y5(), b5(), _5(), x5(), C5(), O5(), k5(), P5(), D5(), L5(), U5(), z5(), I5(), H5(), $5(), Y5();
}), Hh = Y(() => {
  G5(), ap(), UV(), FV(), PV(), op(), IV();
});
function Q5() {
  var we;
  let { publicClient: ne, walletClient: oe } = zt(), ae = (we = oe == null ? void 0 : oe.account) == null ? void 0 : we.address, fe = ne.chain.id === 31337 ? ne.extend(dP({ mode: "anvil" })) : null, [ye, ge] = (0, px.useState)(null);
  return (0, px.useEffect)(() => {
    if (!ne || !oe)
      return ge(null);
    let _e = oe.account;
    if (!_e)
      return ge(null);
    let Se = async () => {
      let $e = await ne.getBalance({ address: _e.address });
      ge($e);
    };
    Se();
    let Ie = setInterval(Se, ne.pollingInterval);
    return () => clearInterval(Ie);
  }, [ne, oe]), (0, Nu.jsxs)("dl", { className: "grid grid-cols-[max-content,1fr] gap-x-4", children: [(0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Address" }), (0, Nu.jsx)("dd", { className: "text-sm", children: ae }), (0, Nu.jsx)("dt", { className: "text-amber-200/80", children: "Balance" }), (0, Nu.jsxs)("dd", { className: "text-sm flex items-center gap-2", title: ye ? ye.toString() : void 0, children: [ne && ye != null ? (0, Nu.jsxs)("span", { children: [sP(ye, ne.chain.nativeCurrency.decimals).replace(/(\.\d{4})\d+$/, "$1"), " ", ne.chain.nativeCurrency.symbol] }) : null, ae && fe ? (0, Nu.jsx)("button", { type: "button", className: "text-xs px-1.5 py-0.5 bg-slate-700 hover:bg-blue-700 hover:text-white rounded", onClick: () => fe.setBalance({ address: ae, value: fP("1") + (ye ?? 0n) }), children: "top up" }) : null] })] });
}
var px, Nu, K5 = Y(() => {
  px = le(ir(), 1), Hh(), ai(), Nu = le(ke(), 1);
});
function X5() {
  let { storedLogs: ne } = zt();
  return (0, Oc.jsxs)(Oc.Fragment, { children: [(0, Oc.jsx)(z0, { logs: ne.slice(-10) }), (0, Oc.jsx)(sn, { to: "/events", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] });
}
var Oc, J5 = Y(() => {
  ql(), ai(), Pk(), Oc = le(ke(), 1);
});
function pP({ className: ne }) {
  return (0, Vh.jsxs)("svg", { className: Pr("animate-spin w-[1em] h-[1em]", ne), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [(0, Vh.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), (0, Vh.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] });
}
var Vh, Z5 = Y(() => {
  uc(), Vh = le(ke(), 1);
});
function e$(ne) {
  return ne.replace(/^(0x[0-9A-F]{3})[0-9A-F]+([0-9A-F]{4})$/i, "$1…$2");
}
var t$ = Y(() => {
});
function $h(ne) {
  return JSON.stringify(ne, (oe, ae) => typeof ae == "bigint" ? ae.toString() : ae);
}
var vP = Y(() => {
});
function vx(ne, oe) {
  return mP[oe.id] || (mP[oe.id] = oe.result.then((ae) => ne.getTransaction({ hash: ae }))), mP[oe.id];
}
var mP, hP = Y(() => {
  mP = {};
});
function mx(ne, oe) {
  return yP[oe.id] || (yP[oe.id] = oe.result.then((ae) => ne.waitForTransactionReceipt({ hash: ae }))), yP[oe.id];
}
var yP, gP = Y(() => {
  yP = {};
});
function r$(ne, oe, ae) {
  if (!bP[ae.id]) {
    let fe = vx(ne, ae), ye = mx(ne, ae);
    bP[ae.id] = Promise.all([fe, ye]).then(([ge, we]) => {
      let { functionName: _e, args: Se } = Bh({ abi: oe, data: ge.input });
      return ne.simulateContract({ account: ge.from, address: ge.to, abi: oe, functionName: _e, args: Se, blockNumber: we.blockNumber - 1n, value: ge.value });
    });
  }
  return bP[ae.id];
}
var bP, n$ = Y(() => {
  Hh(), hP(), gP(), bP = {};
});
function hx({ write: ne }) {
  var qe, tt, Xe;
  let { publicClient: oe, worldAbi: ae } = zt(), fe = (qe = oe.chain.blockExplorers) == null ? void 0 : qe.default.url, ye = _h(ne.result), ge = vx(oe, ne), we = mx(oe, ne), _e = r$(oe, ae, ne), Se = _h(ge), Ie = _h(we), $e = _h(_e), Ne = ye.status === "pending" || Ie.status === "pending", Me = ye.status === "rejected" || Ie.status === "fulfilled" && Ie.value.status === "reverted", Be = $e.status === "fulfilled" ? $e.value.result : null, ze = ae && Ie.status === "fulfilled" ? Ie.value.logs.map((ot) => {
    try {
      return cP({ abi: ae, ...ot });
    } catch (pt) {
      if (pt instanceof Rc)
        return;
      throw pt;
    }
  }).filter(b$5) : null, He = ne.request.functionName, Ze = ne.request.args;
  if (He === "call" || He === "callFrom") {
    let ot = (Xe = (tt = ne.request) == null ? void 0 : tt.args) != null && Xe.length ? ne.request.args[ne.request.args.length - 1] : "0x", pt = Bh({ abi: ae, data: ot });
    He = pt.functionName, Ze = pt.args;
  }
  return (0, nt.jsxs)("details", { onToggle: (ot) => {
    ot.currentTarget.open && (console.log("transaction", Se), console.log("transaction receipt", Ie), console.log("transaction result", $e));
  }, children: [(0, nt.jsxs)("summary", { className: Pr("px-2 py-1 rounded flex items-center gap-2 border-2 border-transparent border-dashed cursor-pointer", Ne ? "border-white/20 cursor-default" : Me ? "bg-red-800" : "bg-slate-700"), children: [(0, nt.jsxs)("div", { className: "flex-1 font-mono text-white whitespace-nowrap overflow-hidden text-ellipsis", children: [He, "(", Ze == null ? void 0 : Ze.map((ot) => $h(ot)).join(", "), ")", " ", ne.request.functionName !== He ? (0, nt.jsxs)("span", { className: "text-xs text-white/40", children: ["via ", ne.request.functionName] }) : null] }), Ie.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/block/${Ie.value.blockNumber.toString()}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: Ie.value.blockNumber.toString(), children: ["block ", Ie.value.blockNumber.toString()] }) : null, ye.status === "fulfilled" ? (0, nt.jsxs)("a", { href: fe ? `${fe}/tx/${ye.value}` : void 0, target: "_blank", className: Pr("flex-none font-mono text-xs text-white/40", fe ? "hover:text-white/60 hover:underline" : null), title: ye.value, children: ["tx ", e$(ye.value)] }) : null, (0, nt.jsx)("div", { className: "flex-none inline-flex w-4 h-4 justify-center items-center font-bold", children: Ne ? (0, nt.jsx)(pP, {}) : Me ? (0, nt.jsx)(nt.Fragment, { children: "⚠" }) : (0, nt.jsx)(nt.Fragment, { children: "✓" }) })] }), (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Result" }), $e.status === "fulfilled" ? (0, nt.jsx)("div", { className: "font-mono", children: $h(Be) }) : $e.status === "rejected" ? (0, nt.jsx)(U0, { error: $e.reason }) : (0, nt.jsx)(pP, {})] }), ze != null && ze.length ? (0, nt.jsxs)("div", { className: "p-2 space-y-1", children: [(0, nt.jsx)("div", { className: "font-bold text-white/40 uppercase text-xs", children: "Store events" }), (0, nt.jsxs)("table", { className: "w-full table-fixed", children: [(0, nt.jsx)("thead", { className: "bg-slate-800 text-amber-200/80 text-left", children: (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "table" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-[1em]" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs w-3/12", children: "key" }), (0, nt.jsx)("th", { className: "font-semibold uppercase text-xs", children: "value" })] }) }), (0, nt.jsx)("tbody", { className: "font-mono text-xs", children: ze.map(({ eventName: ot, args: pt }, ht) => {
    let wt = _$2(pt.tableId);
    return (0, nt.jsxs)("tr", { children: [(0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: i$2(wt) }), (0, nt.jsxs)("td", { className: "whitespace-nowrap", children: [ot === "Store_SetRecord" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "=" }) : null, ot === "Store_SpliceStaticData" || ot === "Store_SpliceDynamicData" ? (0, nt.jsx)("span", { className: "text-green-500 font-bold", children: "+" }) : null, ot === "Store_DeleteRecord" ? (0, nt.jsx)("span", { className: "text-red-500 font-bold", children: "-" }) : null] }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: d(pt.keyTuple) }), (0, nt.jsx)("td", { className: "whitespace-nowrap overflow-hidden text-ellipsis", children: pt.data })] }, ht);
  }) })] })] }) : null] });
}
var nt, SP = Y(() => {
  Hh(), uc(), Z5(), wh(), t$(), vP(), hP(), gP(), n$(), Ak(), ai(), nt = le(ke(), 1);
});
function i$() {
  let { writes: ne } = zt();
  return (0, to.jsx)(to.Fragment, { children: ne.length ? (0, to.jsxs)(to.Fragment, { children: [(0, to.jsx)("div", { className: "space-y-1", children: ne.slice(-5).map((oe) => (0, to.jsx)(hx, { write: oe }, oe.id)) }), (0, to.jsx)(sn, { to: "/actions", className: "block w-full bg-white/5 hover:bg-blue-700 hover:text-white", children: "See more" })] }) : (0, to.jsx)("div", { children: "Waiting for transactions…" }) });
}
var to, a$ = Y(() => {
  ql(), ai(), SP(), to = le(ke(), 1);
});
function fp() {
  let { useStore: ne } = zt();
  if (!ne)
    throw new Error("Missing useStore");
  let [oe, ae] = (0, yx.useState)(ne.getState().tables);
  return (0, yx.useEffect)(() => ne.subscribe((fe) => {
    fe.tables !== oe && ae(fe.tables);
  }), [ne, oe]), Object.values(oe);
}
var yx, gx = Y(() => {
  ai(), yx = le(ir(), 1);
});
function o$() {
  let ne = fp();
  return (0, _P.jsx)("div", { className: "flex flex-col gap-1 items-start", children: ne.map((oe) => (0, _P.jsx)(sn, { to: `/tables/${oe.tableId}`, className: "font-mono text-xs hover:text-white", children: i$2(oe) }, oe.tableId)) });
}
var _P, u$ = Y(() => {
  ql(), gx(), _P = le(ke(), 1);
});
function Lu(ne) {
  var oe, ae;
  return String(((oe = ne.metadata) == null ? void 0 : oe.tableName) ?? ((ae = ne.metadata) == null ? void 0 : ae.componentName) ?? ne.id);
}
var wP = Y(() => {
});
function l$({ world: ne }) {
  let oe = [...ne.components].sort((ae, fe) => Lu(ae).localeCompare(Lu(fe)));
  return (0, ju.jsx)(ju.Fragment, { children: oe.length ? (0, ju.jsx)(ju.Fragment, { children: (0, ju.jsx)("div", { className: "flex flex-col gap-1 items-start", children: oe.map((ae) => (0, ju.jsx)(sn, { to: `/components/${ae.id}`, className: "font-mono text-xs hover:text-white", children: Lu(ae) }, ae.id)) }) }) : (0, ju.jsx)("div", { children: "Waiting for components…" }) });
}
var ju, s$ = Y(() => {
  ql(), wP(), ju = le(ke(), 1);
}), xP, c$ = Y(() => {
  xP = { name: "@latticexyz/dev-tools", version: "2.1.0", description: "MUD developer tools", repository: { type: "git", url: "https://github.com/latticexyz/mud.git", directory: "packages/dev-tools" }, license: "MIT", type: "module", exports: { ".": "./dist/index.js" }, typesVersions: { "*": { index: ["./dist/index.d.ts"] } }, files: ["dist"], scripts: { build: "pnpm run build:js", "build:js": "tsup", clean: "pnpm run clean:js", "clean:js": "rimraf dist", dev: "tsup --watch", test: "tsc --noEmit", "test:ci": "pnpm run test" }, dependencies: { "@latticexyz/common": "workspace:*", "@latticexyz/react": "workspace:*", "@latticexyz/recs": "workspace:*", "@latticexyz/schema-type": "workspace:*", "@latticexyz/store": "workspace:*", "@latticexyz/store-sync": "workspace:*", "@latticexyz/utils": "workspace:*", "@latticexyz/world": "workspace:*", react: "^18.2.0", "react-dom": "^18.2.0", "react-router-dom": "^6.11.0", rxjs: "7.5.5", "tailwind-merge": "^1.12.0", "use-local-storage-state": "^18.3.2", viem: "2.9.20", zustand: "^4.3.7" }, devDependencies: { "@types/react": "18.2.22", "@types/react-dom": "18.2.7", "@types/ws": "^8.5.4", autoprefixer: "^10.4.14", postcss: "^8.4.23", tailwindcss: "^3.3.2", tsup: "^6.7.0", vitest: "0.34.6" }, peerDependencies: { "@latticexyz/common": "2.x", "@latticexyz/recs": "2.x", "@latticexyz/store": "2.x", "@latticexyz/store-sync": "2.x", "@latticexyz/utils": "2.x", "@latticexyz/world": "2.x" }, publishConfig: { access: "public" } };
});
function f$() {
  let { recsWorld: ne, useStore: oe } = zt();
  return (0, Dt.jsxs)("div", { className: "h-full flex flex-col", children: [(0, Dt.jsxs)("div", { className: "flex-grow p-6 space-y-8 relative", children: [(0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Network" }), (0, Dt.jsx)(E4, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Account" }), (0, Dt.jsx)(Q5, {})] }), (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent actions" }), (0, Dt.jsx)(i$, {})] }), (0, Dt.jsxs)("div", { className: "space-y-1", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Recent store events" }), (0, Dt.jsx)(X5, {})] }), oe ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Tables" }), (0, Dt.jsx)(o$, {})] }) : null, ne ? (0, Dt.jsxs)("div", { className: "space-y-2", children: [(0, Dt.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Components" }), (0, Dt.jsx)(l$, { world: ne })] }) : null] }), (0, Dt.jsxs)("div", { className: "p-2 text-right font-mono text-xs leading-none text-white/20", children: ["MUD ", _be ? (0, Dt.jsxs)(Dt.Fragment, { children: ["v", xP.version] }) : (0, Dt.jsx)(Dt.Fragment, { children: "linked" })] })] });
}
var Dt, _be, d$ = Y(() => {
  C4(), K5(), J5(), a$(), u$(), s$(), c$(), ai(), Dt = le(ke(), 1), _be = Object.entries(xP.dependencies).some(([ne, oe]) => ne.startsWith("@latticexyz/") && oe.startsWith("link:"));
});
function p$() {
  let { writes: ne } = zt(), oe = (0, dp.useRef)(null), ae = (0, dp.useRef)(!1), fe = (0, dp.useRef)("auto");
  return (0, dp.useEffect)(() => {
    var ye;
    ae.current || ((ye = oe.current) == null || ye.scrollIntoView({ behavior: fe.current, block: "end" })), fe.current = "smooth";
  }, [ne]), (0, pp.jsx)("div", { ref: oe, className: "p-4 space-y-2", onMouseEnter: () => {
    ae.current = !0;
  }, onMouseLeave: () => {
    ae.current = !1;
  }, children: ne.length ? ne.map((ye) => (0, pp.jsx)(hx, { write: ye }, ye.id)) : (0, pp.jsx)(pp.Fragment, { children: "Waiting for transactions…" }) });
}
var dp, pp, v$ = Y(() => {
  dp = le(ir(), 1), SP(), ai(), pp = le(ke(), 1);
});
function m$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let oe = [...ne.components].sort((we, _e) => Lu(we).localeCompare(Lu(_e))), { id: ae } = Tu(), fe = oe.find((we) => we.id === ae) ?? oe[0], ye = (0, Wh.useRef)(null), ge = Ou();
  return (0, Wh.useEffect)(() => {
    ae !== fe.id && ge(fe.id);
  }, [ae, fe.id]), (0, Wh.useEffect)(() => {
    let we = (_e) => {
      ye.current && (_e.target instanceof Node && ye.current.contains(_e.target) || (ye.current.open = !1));
    };
    return window.addEventListener("click", we), () => window.removeEventListener("click", we);
  }), (0, fn.jsxs)("div", { className: "p-6 space-y-4", children: [oe.length ? (0, fn.jsxs)("div", { className: "space-y-2", children: [(0, fn.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Component" }), (0, fn.jsxs)("details", { ref: ye, className: "pointer-events-none select-none", children: [(0, fn.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, fn.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [fe ? (0, fn.jsx)("span", { className: "font-mono", children: Lu(fe) }) : (0, fn.jsx)("span", { children: "Pick a component…" }), (0, fn.jsx)("span", { className: "text-white/40 text-xs", children: "▼" })] }) }), (0, fn.jsx)("div", { className: "relative", children: (0, fn.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: oe.map((we) => (0, fn.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", we === fe ? "bg-slate-600" : null), to: we.id, onClick: () => {
    ye.current && (ye.current.open = !1);
  }, children: Lu(we) }, we.id)) }) })] })] }) : (0, fn.jsx)(fn.Fragment, { children: "Waiting for components…" }), (0, fn.jsx)(cc, {})] });
}
var Wh, fn, h$ = Y(() => {
  Do(), ql(), Wh = le(ir(), 1), uc(), ai(), wP(), fn = le(ke(), 1);
});
function y$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, ro.jsxs)("table", { className: "w-full -mx-1", children: [(0, ro.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, ro.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [(0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: "entity" }), Object.keys(ne.schema).map((ae) => (0, ro.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, ro.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = de(ne, ae);
    return (0, ro.jsxs)("tr", { children: [(0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ae }), Object.keys(ne.schema).map((ye) => {
      let ge = fe[ye];
      return (0, ro.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: ne.schema[ye] === P$1.T ? $h(ge) : Array.isArray(ge) ? ge.map(String).join(", ") : String(ge) }, ye);
    })] }, ae);
  }) })] });
}
var ro, g$ = Y(() => {
  wh(), vP(), ro = le(ke(), 1);
});
function b$({ component: ne }) {
  let oe = Kw([Le(ne)]);
  return (0, no.jsxs)("table", { className: "w-full -mx-1", children: [(0, no.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, no.jsxs)("tr", { className: "text-amber-200/80 font-mono", children: [Object.keys(ne.metadata.keySchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae)), Object.keys(ne.metadata.valueSchema).map((ae) => (0, no.jsx)("th", { className: "px-1 pt-1.5 font-normal", children: ae }, ae))] }) }), (0, no.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => {
    let fe = vt(ne.metadata.keySchema, ae), ye = de(ne, ae);
    return (0, no.jsxs)("tr", { children: [Object.keys(ne.metadata.keySchema).map((ge) => (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: String(fe[ge]) }, ge)), Object.keys(ne.metadata.valueSchema).map((ge) => {
      let we = ye[ge];
      return (0, no.jsx)("td", { className: "px-1 whitespace-nowrap overflow-hidden text-ellipsis", children: Array.isArray(we) ? we.map(String).join(", ") : String(we) }, ge);
    })] }, ae);
  }) })] });
}
var no, S$ = Y(() => {
  wh(), no = le(ke(), 1);
});
function _$() {
  let { recsWorld: ne } = zt();
  if (!ne)
    throw new Error("Missing recsWorld");
  let { id: oe } = Tu(), ae = ne.components.find((fe) => fe.id === oe);
  return ae ? Pt(ae) ? (0, EP.jsx)(b$, { component: ae }, ae.id) : (0, EP.jsx)(y$, { component: ae }, ae.id) : null;
}
var EP, w$ = Y(() => {
  Do(), ai(), g$(), S$(), EP = le(ke(), 1);
});
function E$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((ge) => ge.tableId === oe) ?? ne[0], fe = (0, Yh.useRef)(null), ye = Ou();
  return (0, Yh.useEffect)(() => {
    oe !== ae.tableId && ye(ae.tableId);
  }, [oe, ae.tableId]), (0, Yh.useEffect)(() => {
    let ge = (we) => {
      fe.current && (we.target instanceof Node && fe.current.contains(we.target) || (fe.current.open = !1));
    };
    return window.addEventListener("click", ge), () => window.removeEventListener("click", ge);
  }), (0, li.jsxs)("div", { className: "p-6 space-y-4", children: [(0, li.jsxs)("div", { className: "space-y-2", children: [(0, li.jsx)("h1", { className: "font-bold text-white/40 uppercase text-xs", children: "Table" }), (0, li.jsxs)("details", { ref: fe, className: "pointer-events-none select-none", children: [(0, li.jsx)("summary", { className: "group pointer-events-auto cursor-pointer inline-flex", children: (0, li.jsxs)("span", { className: "inline-flex gap-2 px-3 py-2 items-center border-2 border-white/10 rounded group-hover:border-blue-700 group-hover:bg-blue-700 group-hover:text-white", children: [ae ? (0, li.jsx)("span", { className: "font-mono", children: i$2(ae) }) : (0, li.jsx)("span", { children: "Pick a table…" }), (0, li.jsx)("span", { className: "text-white/40 text-xs", children: "▼" })] }) }), (0, li.jsx)("div", { className: "relative", children: (0, li.jsx)("div", { className: "pointer-events-auto absolute top-1 left-0 z-20 bg-slate-700 rounded shadow-lg flex flex-col py-1.5 font-mono text-xs leading-none", children: ne.map((ge) => (0, li.jsx)(sn, { className: Pr("px-2 py-1.5 text-left hover:bg-blue-700 hover:text-white", ge === ae ? "bg-slate-600" : null), to: ge.tableId, onClick: () => {
    fe.current && (fe.current.open = !1);
  }, children: i$2(ge) }, ge.tableId)) }) })] })] }), (0, li.jsx)(cc, {})] });
}
var Yh, li, C$ = Y(() => {
  Do(), ql(), Yh = le(ir(), 1), uc(), gx(), li = le(ke(), 1);
});
function R$(ne) {
  let { useStore: oe } = zt();
  if (!oe)
    throw new Error("Missing useStore");
  let [ae, fe] = (0, bx.useState)(oe.getState().getRecords(ne));
  return (0, bx.useEffect)(() => oe.subscribe(() => {
    let ye = oe.getState().getRecords(ne);
    ye !== ae && fe(ye);
  }), [oe, ae]), Object.values(ae);
}
var bx, O$ = Y(() => {
  ai(), bx = le(ir(), 1);
});
function T$({ hex: ne }) {
  return ne.length <= 10 ? (0, vp.jsx)("span", { children: ne }) : (0, vp.jsxs)("span", { children: [(0, vp.jsx)("span", { className: "after:content-['…'] after:select-none", children: ne.slice(0, 6) }), (0, vp.jsx)("span", { className: "tracking-[-1ch] text-transparent", children: ne.slice(6, -4) }), ne.slice(-4)] });
}
var vp, k$ = Y(() => {
  vp = le(ke(), 1);
});
function CP({ value: ne }) {
  return Array.isArray(ne) ? ne.map((oe, ae) => (0, ps.jsxs)(A$.default.Fragment, { children: [ae > 0 ? ", " : null, (0, ps.jsx)(CP, { value: oe })] }, JSON.stringify({ i: ae, value: ne }))) : eo(ne) ? (0, ps.jsx)(T$, { hex: ne }) : (0, ps.jsx)(ps.Fragment, { children: String(ne) });
}
var A$, ps, P$ = Y(() => {
  A$ = le(ir(), 1), Hh(), k$(), ps = le(ke(), 1);
});
function M$({ table: ne }) {
  let oe = R$(ne);
  return (0, qo.jsxs)("table", { className: "w-full -mx-1", children: [(0, qo.jsx)("thead", { className: "sticky top-0 z-10 bg-slate-800 text-left", children: (0, qo.jsx)("tr", { className: "text-amber-200/80 font-mono", children: Object.keys(ne.schema).map((ae) => (0, qo.jsx)("th", { className: "px-1.5 pt-1.5 font-normal", children: ae }, ae)) }) }), (0, qo.jsx)("tbody", { className: "font-mono text-xs", children: oe.map((ae) => (0, qo.jsx)("tr", { children: Object.keys(ne.schema).map((fe) => (0, qo.jsx)("td", { className: "px-1.5 whitespace-nowrap overflow-hidden text-ellipsis", children: (0, qo.jsx)(CP, { value: ae.fields[fe] }) }, fe)) }, ae.id)) })] });
}
var qo, D$ = Y(() => {
  O$(), P$(), qo = le(ke(), 1);
});
function N$() {
  let ne = fp(), { id: oe } = Tu(), ae = ne.find((fe) => fe.tableId === oe);
  return ae ? (0, L$.jsx)(M$, { table: ae }, ae.tableId) : null;
}
var L$, j$ = Y(() => {
  Do(), D$(), gx(), L$ = le(ke(), 1);
}), Qr, U$, F$ = Y(() => {
  Do(), Fq(), Iq(), $q(), d$(), v$(), h$(), w$(), C$(), j$(), Qr = le(ke(), 1), U$ = Ek(pd((0, Qr.jsxs)(Ga, { path: "/", element: (0, Qr.jsx)(Uq, {}), errorElement: (0, Qr.jsx)(qq, {}), children: [(0, Qr.jsx)(Ga, { index: !0, element: (0, Qr.jsx)(f$, {}) }), (0, Qr.jsx)(Ga, { path: "actions", element: (0, Qr.jsx)(p$, {}) }), (0, Qr.jsx)(Ga, { path: "events", element: (0, Qr.jsx)(Vq, {}) }), (0, Qr.jsx)(Ga, { path: "tables", element: (0, Qr.jsx)(E$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(N$, {}) }) }), (0, Qr.jsx)(Ga, { path: "components", element: (0, Qr.jsx)(m$, {}), children: (0, Qr.jsx)(Ga, { path: ":id", element: (0, Qr.jsx)(_$, {}) }) })] })));
});
function TP(ne, oe) {
  if (Ai.useSyncExternalStore === void 0)
    throw new TypeError('You are using React 17 or below. Install with "npm install use-local-storage-state@17".');
  let [ae] = (0, Ai.useState)(oe == null ? void 0 : oe.defaultValue);
  if (typeof window > "u")
    return [ae, () => {
    }, { isPersistent: !0, removeItem: () => {
    } }];
  let fe = oe == null ? void 0 : oe.serializer;
  return kbe(ne, ae, oe == null ? void 0 : oe.storageSync, fe == null ? void 0 : fe.parse, fe == null ? void 0 : fe.stringify);
}
function kbe(ne, oe, ae = !0, fe = Abe, ye = JSON.stringify) {
  if (!Tc.has(ne) && oe !== void 0 && localStorage.getItem(ne) === null)
    try {
      localStorage.setItem(ne, ye(oe));
    } catch {
    }
  let ge = (0, Ai.useRef)({ item: null, parsed: oe }), we = (0, Ai.useSyncExternalStore)((0, Ai.useCallback)((Se) => {
    let Ie = ($e) => {
      ne === $e && Se();
    };
    return OP.add(Ie), () => {
      OP.delete(Ie);
    };
  }, [ne]), () => {
    let Se = localStorage.getItem(ne);
    if (Tc.has(ne))
      ge.current = { item: Se, parsed: Tc.get(ne) };
    else if (Se !== ge.current.item) {
      let Ie;
      try {
        Ie = Se === null ? oe : fe(Se);
      } catch {
        Ie = oe;
      }
      ge.current = { item: Se, parsed: Ie };
    }
    return ge.current.parsed;
  }, () => oe), _e = (0, Ai.useCallback)((Se) => {
    let Ie = Se instanceof Function ? Se(ge.current.parsed) : Se;
    try {
      localStorage.setItem(ne, ye(Ie)), Tc.delete(ne);
    } catch {
      Tc.set(ne, Ie);
    }
    RP(ne);
  }, [ne, ye]);
  return (0, Ai.useEffect)(() => {
    if (!ae)
      return;
    let Se = (Ie) => {
      Ie.storageArea === localStorage && Ie.key === ne && RP(ne);
    };
    return window.addEventListener("storage", Se), () => window.removeEventListener("storage", Se);
  }, [ne, ae]), (0, Ai.useMemo)(() => [we, _e, { isPersistent: we === oe || !Tc.has(ne), removeItem() {
    Tc.delete(ne), localStorage.removeItem(ne), RP(ne);
  } }], [ne, _e, we, oe]);
}
function RP(ne) {
  for (let oe of [...OP])
    oe(ne);
}
function Abe(ne) {
  return ne === "undefined" ? void 0 : JSON.parse(ne);
}
var Ai, Tc, OP, z$ = Y(() => {
  Ai = le(ir()), Tc = /* @__PURE__ */ new Map(), OP = /* @__PURE__ */ new Set();
}), q$, I$ = Y(() => {
  z$(), q$ = TP;
}), H$ = {};
Uj(H$, { App: () => Pbe });
function Pbe() {
  let [ne, oe] = q$("mud-dev-tools-shown", { defaultValue: !0 });
  return (0, B$.useEffect)(() => {
    let ae = (fe) => {
      fe.key === "`" && oe(!ne);
    };
    return window.addEventListener("keypress", ae), () => window.removeEventListener("keypress", ae);
  }), (0, io.jsx)("div", { className: "fixed inset-0 pointer-events-none", children: (0, io.jsxs)("div", { className: Pr("pointer-events-auto w-full max-w-screen-sm h-full absolute right-0", "transition duration-500", ne ? "translate-x-0" : "translate-x-full"), children: [(0, io.jsxs)("div", { className: "absolute bottom-0 right-full min-w-max flex flex-col-reverse items-end justify-center m-2 text-gray-500", children: [(0, io.jsx)("button", { type: "button", className: "peer text-sm p-2 rounded leading-none transition opacity-60 hover:opacity-100", onClick: () => oe(!ne), children: (0, io.jsxs)("span", { className: "whitespace-nowrap font-medium", children: [ne ? "→" : "←", " MUD Dev Tools"] }) }), (0, io.jsxs)("span", { className: "transition opacity-0 peer-hover:opacity-60 px-2 text-xs flex items-center justify-center gap-2", children: ["Keyboard shortcut", (0, io.jsx)("code", { className: "bg-gray-500/10 p-1 rounded text-mono text-xs leading-none", children: "`" })] })] }), (0, io.jsx)("div", { className: Pr("w-full h-full bg-slate-800 text-white/80 text-sm flex flex-col", "transition duration-500", ne ? "opacity-100" : "opacity-0"), children: (0, io.jsx)(xk, { router: U$ }) })] }) });
}
var B$, io, V$ = Y(() => {
  Sz(), _z(), B$ = le(ir(), 1), uc(), F$(), Do(), I$(), io = le(ke(), 1);
}), Sx = le(ke(), 1), $$ = "mud-dev-tools";
async function Mbe(ne) {
  if (typeof window > "u") {
    console.warn("MUD dev-tools should only be used in browser bundles");
    return;
  }
  if (document.getElementById($$)) {
    console.warn("MUD dev-tools is already mounted");
    return;
  }
  try {
    let oe = await Promise.resolve().then(() => le(ir(), 1)), ae = await Promise.resolve().then(() => le(bz(), 1)), { App: fe } = await Promise.resolve().then(() => (V$(), H$)), { DevToolsProvider: ye } = await Promise.resolve().then(() => (ai(), Lq)), ge = document.createElement("div");
    ge.id = $$, ge.style.position = "relative", ge.style.zIndex = "999999";
    let we = ae.createRoot(ge);
    return we.render((0, Sx.jsx)(oe.StrictMode, { children: (0, Sx.jsx)(ye, { value: ne, children: (0, Sx.jsx)(fe, {}) }) })), document.body.appendChild(ge), () => {
      we.unmount(), ge.remove();
    };
  } catch (oe) {
    console.error("Failed to mount MUD dev-tools", oe);
  }
}
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.6.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.11.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
class MudLib {
  constructor() {
    Tl(this, "increment");
  }
  async setup() {
    const {
      components: oe,
      systemCalls: {
        spawnPlayer: ae,
        spawnCapital: fe,
        marchArmy: ye,
        attack: ge,
        garrison: we,
        buyInfantry: _e,
        buyCavalryA: Se,
        buyCavalryB: Ie,
        buyCavalryC: $e,
        stakeTokenB: Ne,
        stakeTokenC: Me,
        unStakeTokenB: Be,
        unStakeTokenC: ze,
        farming: He,
        setMerkleRoot: Ze,
        claim: qe,
        swapA2B: tt,
        swapA2C: Xe,
        withdrawToken: ot
      },
      network: pt
    } = await setup();
    this.spawnPlayer = ae, this.spawnCapital = fe, this.marchArmy = ye, this.attack = ge, this.garrison = we, this.buyInfantry = _e, this.buyCavalryA = Se, this.buyCavalryB = Ie, this.buyCavalryC = $e, this.stakeTokenB = Ne, this.stakeTokenC = Me, this.unStakeTokenB = Be, this.unStakeTokenC = ze, this.farming = He, this.setMerkleRoot = Ze, this.claim = qe, this.swapA2B = tt, this.swapA2C = Xe, this.withdrawToken = ot, Mbe({
      config: mudConfig,
      publicClient: pt.publicClient,
      walletClient: pt.walletClient,
      latestBlock$: pt.latestBlock$,
      storedBlockLogs$: pt.storedBlockLogs$,
      worldAddress: pt.worldContract.address,
      worldAbi: pt.worldContract.abi,
      write$: pt.write$
      // useStore: network.useStore,
    }), this.network = pt, oe.Player.update$.subscribe((ht) => {
      console.log("Player updated", ht), this.player_updated(ht);
    }), oe.PlayerDetail.update$.subscribe((ht) => {
      console.log("PlayerDetails updated", ht), this.player_detail_updated(ht);
    });
  }
  // To be overwritten by Godot callback
  player_updated(oe) {
  }
  player_detail_updated(oe) {
  }
}
window.mud = new MudLib();
export {
  BaseError as B,
  HttpRequestError as H,
  InvalidAddressError as I,
  concat$1 as a,
  isHex as b,
  call as c,
  decodeErrorResult as d,
  encodeAbiParameters as e,
  getUrl$1 as g,
  isAddress as i,
  stringify as s
};
